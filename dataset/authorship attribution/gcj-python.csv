code,author,id,tokens
"#!/usr/bin/env python
 = (
     set(['X']),
     set(['O']),
     set(['X', 'T']),
     set(['O', 'T']),
 )
 
 
 def solve_problem(matrix):
     game_completed = True
 
     lines_combo = (matrix[i] for i in xrange(4))
     rows_combo = ((matrix[k][i] for k in xrange(4)) for i in xrange(4))
     diagonals = ((matrix[i][i] for i in xrange(4)),
                  (matrix[i][3 - i] for i in xrange(4)))
 
     for combo in itertools.chain(lines_combo, rows_combo, diagonals):
         combo_set = set(combo)
         if combo_set in WINNING:
             if 'X' in combo_set:
                 return 'X won'
             if 'O' in combo_set:
                 return 'O won'
         if '.' in combo_set:
             game_completed = False
 
     # we have no winner, check game status
 
     if game_completed:
         return 'Draw'
     else:
         return 'Game has not completed'
 
     return 0
 
 def read_matrix(stdin):
     matrix = [[], [], [], []]
     for i in xrange(4):
         line = stdin.readline().strip()
         for k in line:
             matrix[i].append(k)
     return matrix
 
 
 if __name__ == '__main__':
     num_of_cases = int(sys.stdin.readline())
     for i in xrange(1, num_of_cases + 1):
         matrix = read_matrix(sys.stdin)
         print 'Case #{0}: {1}'.format(i, solve_problem(matrix))
         sys.stdin.readline() # separator
",0,1,481
"# coding: cp932
 
 #input = open(r'C:\MyDocument\home\gcj\2014-04-12\a.sample')
 input = open(r'C:\MyDocument\home\gcj\2014-04-12\A-small-attempt0.in')
 caseCnt = int(input.readline())
 for caseNo in range(1, caseCnt+1):
 	ans1 = int(input.readline())
 	for i in range(1, 5):
 		line = input.readline()
 		if ans1 == i:
 			candidates = set(map(int, line.split()))
 		
 	ans2 = int(input.readline())
 	for i in range(1, 5):
 		line = input.readline()
 		if ans2 == i:
 			answers = candidates.intersection(set(map(int, line.split())))
 		
 	if len(answers) == 0:
 		print('Case #%d: Volunteer cheated!'%caseNo)
 	elif len(answers) > 1:
 		print('Case #%d: Bad magician!'%caseNo)
 	elif len(answers) == 1:
 		answer = answers.pop()
 		print('Case #%d: %d'%(caseNo, answer))
",1,2,363
"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 (object):
     cache = {}
 
     def __init__(self, infile, testcase):
         self.testcase = testcase
         #self.N = N = int(infile.next())
         #self.P = P = map(int, infile.next().split())
         self.I = I = map(int, infile.next().split())
         #self.T = T = infile.next().split()
         #self.S = S = [infile.next().strip() for i in range(N)]
 
         #self.init_cache()
 
     def init_cache(self):
         if 'main' in self.cache:
             return
         #self.cache['main'] = res
 
     def solve(self):
         #########N = self.N
         #N, M = self.P
         I = self.I
         #T = self.T
         #S = self.S
         l = len(str(I[0]))
 
         r = 0
         for i in xrange(I[0], I[1]):
             ii = str(i)
             rr = set()
             for j in xrange(1, l):
                 if  i < int(ii[j:]+ii[:j]) <= I[1]:
                     rr.add(ii[j:]+ii[:j])
             r += len(rr)
 
         return r
 
 
 def main():
     T = int(sys.stdin.next())
     for t in xrange(T):
         sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))
 
 
 if __name__ == '__main__':
     main()
",2,3,454
"def war(n, k):
     k.sort()
     score = 0
     for x in n:
         for i  in xrange(len(k)):
             if k[i] > x:
                 score += 1
                 k.pop(i)
                 break
     return len(n) - score    
             
 
 def deceit(n, k):
     n.sort()
     k.sort()
     score = 0
     for y in k:
         for i in xrange(len(n)):
             if n[i] > y:
                 score +=1
                 n.pop(i)
                 break
     return score
     
 
 f = open('Dsmall.in', 'r')
 g = open('outputD.txt', 'w')
 
 data = [[float(e) for e in line.strip(""\n"").split(' ')] for line in f]
 T = int(data.pop(0)[0])
 c = 1
 for i in xrange(0, T*3, 3):
     N = data[i+1]
     K = data[i+2]
 
     w = war(N, list(K))
     d = deceit(list(N), list(K))
     g.write('Case #%i: %i %i\n' %(c, d, w))
     c += 1
 
 f.close()
 g.close()
 
",3,4,344
"#!/bin/env python       
 """"""
 GCJ framework (gcj.fw.framework)
  - Command Line and Package interface
  - output redirection
  - parsing case input
  - executing problem code against cases
  - testing framework
 """"""
 (object):
     class Case(object):
         def __init__(self, caseNumber, caseData=None):
             self.number = caseNumber
             self.data = caseData
             self.result = None
     
         @classmethod
         def parser(cls, f_in):
             pass
     
         def run(self):
             pass
     
         def execute(self, f_in=None):
             if self.data is None:
                 self.data = self.parser(f_in)
             self.result = self.run(**self.data)
     
         def __str__(self):
             return ""Case #%d: %s"" % (self.number, self.result)
     
     
     class Result(object):
         def __init__(self, resultData):
             self.data = resultData
     
         def __str__(self):
             return str(self.ata)
 
     def __init__(self, f_in, f_out):
         sys.stdout = f_out
         self.f_in = f_in if f_in is not None else sys.stdin
 
     def run(self):
         nCases = int(self.f_in.readline().strip())
         for num in xrange(nCases):
             case = type(self).Case(num+1)
             case.execute( f_in=self.f_in)
             print case
 
 
     @classmethod
     def __main__(cls):
         f_in = sys.stdin
         if len(sys.argv) > 1:
             if sys.argv[1] == ""-t"":
                 unittest.main()
                 sys.exit()
             f_in = open(sys.argv[1])
         framework = cls(f_in, sys.stdout)
         framework.run()
     
 class Test(unittest.TestCase):
     cases = []
     case = None
     c=[]
     
     def setUp(self):
         self.c = []
         self.defineCases()
         counter = 1
         self.cases = []
         for c in self.c:
             case = self.case(counter)
             case.data = case.parser(StringIO.StringIO(c[0]))
             self.cases.append( [case, c[1]])
     
     def defineCases(self):
         pass
     
     def tearDown(self):
         pass 
 
     def test_Name(self):
         self.setUp()
         for case in self.cases:
             print case[0].data, case[1]
             case[0].execute()
             self.assertEqual(case[0].result, case[1])
 '''
 Created on Apr 8, 2012
 
 @author: Joe
 '''
 
 
 class B(Framework):
     class Case(Framework.Case):
         def parser(self, fh):
             args = map(int, fh.readline().strip().split("" ""))
             N,S,p = args[:3]
             scores = args[3:] 
             return {""N"":N,""S"":S,""p"":p,""scores"":scores}
         
         def run(self, N=None,S=None,p=None,scores=None):
             ret = 0
             surps = 0
             for score in scores:
                 if p > 0 and score == 0: continue
                 if 3*p-2 <= score:
                     ret += 1
                 else:
                     if 3*p - 4 <= score:
                         surps += 1
             return str(ret + min(surps,S))
             
 class Test(Test):
     def defineCases(self):
         self.case = B.Case
         self.c = [
                   [""3 1 5 15 13 11"",""3""],
                   [""3 0 8 23 22 21"",""2""],
                   [""2 1 1 8 0"",""1""],
                   [""6 2 8 29 20 8 18 18 21"",""3""],
                   [""1 1 1 1"", ""1""]
                   ]
 
 if __name__ == ""__main__"":
     B.__main__()
     
",4,5,1108
"#!/usr/bin/python
 # -*- coding: utf-8 -*-
 
 = 'abcdefghijklmnopqrstuvwxyz'
 gog = 'ejp mysljylc kd kxveddknmc re jsicpdrysi' + \
       'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd' + \
       'de kr kd eoya kw aej tysr re ujdr lkgc jv' + \
       'y qee'
 
 eng = 'our language is impossible to understand' + \
       'there are twenty six factorial possibilities' + \
       'so it is okay if you want to just give up' + \
       'a zoo'
 
 rule = {}
 for i, c in enumerate(gog):
    rule[c] = eng[i]
 
 gog_alphabet = rule.keys()
 eng_alphabet = rule.values()
 missing_key = None
 missing_val = None
 for c in alphabet:
     if not c in gog_alphabet:
         missing_key = c
     if not c in eng_alphabet:
         missing_val = c
 rule[missing_key] = missing_val
 
 for i, line in enumerate(sys.stdin):
     if i == 0:
         continue
 
     orig = line.strip()
     ans = ''.join([rule[c] for c in orig])
     print 'Case #%(i)s: %(ans)s' % locals()
 
",5,6,377
"__author__ = 'Jeffrey'
 
 inFileName = ""C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\A-small-attempt0.in""
 outFileName = ""C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\A-small-attempt0.out""
 
 
 def parseInput(f):
     T = int(f.readline())
     L = []
 
     for i in range(T):
         picks = []
         cards = []
         for j in range(2):
             picks.append( int(f.readline()))
             tempL = []
             for k in range(4):
                 tempL.append( [int(j) for j in f.readline().split()])
             cards.append(tempL)
         L.append((picks, cards))
 
     return T, L
 
 
 def performTrick(picks, cards):
     matchFound = False
     matchedCard = None
     for card in cards[0][picks[0] - 1]:
         possibleMatch = card in cards[1][picks[1] - 1]
         if possibleMatch and matchFound:
             return ""Bad magician!""
         elif possibleMatch:
             matchFound = True
             matchedCard = card
     if matchFound:
         return matchedCard
     else:
         return ""Volunteer cheated!""
 
 
 def playGame(T,L):
     for i in range(T):
         result = performTrick(L[i][0], L[i][1])
         yield ""Case #"" + str(i + 1) + "": "" + str(result)
 
 
 if __name__==""__main__"":
     iF = open(inFileName, 'r')
     T, L = parseInput(iF)
     iF.close()
 
     oF = open(outFileName, ""wb"")
     for out in playGame(T, L):
         # print(out)
         # print(bytes(out, 'utf-8'), file=oF)
         oF.write(bytes(out + ""\n"",'utf-8'))
     oF.close()
",6,7,540
"= int(sys.stdin.readline())
 for i in range(T):
     line = sys.stdin.readline().strip()
     values = map(int, line.split(' '))
     N = values[0]
     S = values[1]
     p = values[2]
     totals = values[3:]
     ans = 0
     for total in totals:
         base = total / 3
         remainder = total - (base * 3)
         scores = [base, base, base]
         j = 0
         while remainder > 0:
             scores[j] += 1
             remainder -= 1
             j = (j + 1) % 3
         if max(scores) >= p:
             ans += 1
         else:
             if S > 0:
                 remainder = total - (base * 3)
                 if remainder == 0 and base > 0:
                     if base + 2 >= p:
                         ans += 1
                         S -= 1
                 elif base + min(remainder, 2) >= p:
                     ans += 1
                     S -= 1
     print 'Case #%s: %s' % (i+1, ans)
",7,8,298
"T = int(input().strip())
 
 for case in range(1,T+1):
     N,M = [int(x) for x in input().strip().split()]
     lawn = []
     for r in range(N):
         lawn.append([int(x) for x in input().strip().split()])
     rmax = [max(row) for row in lawn]
     cmax = [max(lawn[r][c] for r in range(N)) for c in range(M)]
     ans = all(lawn[r][c] == min(rmax[r],cmax[c]) for r in range(N) for c in range(M))
     ans = ""YES"" if ans else ""NO""
     print(""Case #"",case,"": "",ans,sep = '')
",8,9,194
"def solve(pre):
     b = [raw_input().strip() for _ in xrange(4)]
     raw_input()
     for s in b + zip(*b) + [''.join(b[i][i] for i in xrange(4)), ''.join(b[3-i][i] for i in xrange(4))]:
         for c in 'XO':
             if s.count('T') + s.count(c) == 4:
                 print pre, c, ""won""
                 return
     if ''.join(b).count('.'):
         print pre, ""Game has not completed""
     else:
         print pre, ""Draw""
 
 n = int(raw_input())
 for i in xrange(n):
     solve(""Case #%d:"" % (i + 1))
",9,10,196
"= int(stdin.readline())
 for i in xrange(1,T+1):
 	ns = map(int, stdin.readline().split())
 	N,S,p = ns[0:3]
 	
 	h = 0
 	z = 0
 
 	for n in ns[3:]:
 		if n <= 1:
 			if n >= p: h += 1	
 		elif (n+2) // 3 >= p:
 			h += 1
 		elif (n+4) // 3 >= p:
 			z += 1
 
 	print ""Case #%d: %d"" % (i, h + min(S,z))
 
 
",10,11,191
"= open( sys.argv[1] )
 f.readline()
 
 numcases = 1
 input = f.readline()
 while input != """":
 	inC,inF,inX = [float(x) for x in input.split()]
 
 	start = (0.0,0.0,2.0)
 	h = [start]
 	checked =set()
 
 	while h[0][1] < inX:
 		x = heapq.heappop(h)
 
 		if x in checked:
 			continue
 		else:
 			checked.add(x)	
 
 		time,numCookies,rate = x
 		#time to win
 		timeW = (inX - numCookies) / rate
 		heapq.heappush( h,(time+timeW,numCookies+rate*timeW,rate) )
 
 		#time to new farm
 		timeF = (inC - numCookies) / rate
 		newC = numCookies + rate*timeF
 		newT = time + timeF
 		heapq.heappush( h,(newT,(newC - inC),rate+inF) )
 		heapq.heappush( h,(newT,newC,rate) )
 		#print h
 
 	output = ""{:.7f}"".format(h[0][0])
 
 	print ""Case #""+str(numcases)+"": ""+output
 	input = f.readline()
 	numcases += 1
 	",11,12,409
"#!/usr/bin/python
 
 = open(sys.argv[1],'r')
 
 num = int(f.readline())
 
 def count(z, r, c):
     return len(z_and_nei(z,r,c))
 
 def nei(z, r, c):
     s = z_and_nei(z, r, c)
     s -= set(z)
     return s
 
 def z_and_nei(z, r, c):
     s = set()
     for x in z:
         s.add(x)
         s.add((x[0]-1,x[1]-1))
         s.add((x[0]-1,x[1]))
         s.add((x[0]-1,x[1]+1))
         s.add((x[0],x[1]-1))
         s.add((x[0],x[1]+1))
         s.add((x[0]+1,x[1]-1))
         s.add((x[0]+1,x[1]))
         s.add((x[0]+1,x[1]+1))
     o = set()
     for x in s:
         if x[0] < 0 or x[0] > r-1 or x[1] < 0 or x[1] > c-1:
             o.add(x)
     s-=o
     return s
 
 def find_config(z, r, c, t):
     if count(z,r,c) == t:
         return z
     if count(z,r,c) > t:
         return []
     n = nei(z,r,c)
     for x in n:
         z.append(x)
         if find_config(z,r,c,t) != []:
             return z
         z.pop()
     return []
 
 for i in range(num):
     print 'Case #{}:'.format(i+1)
     r, c, m = [int(x) for x in f.readline().split()]
     if r*c-m == 1:
         print 'c' + '*'*(c-1)
         for i in range(r-1):
             print '*'*c
     else:
         z = find_config([(0,0)], c, r, c*r-m)
         if z == []:
             print ""Impossible""
         else:
             s = z_and_nei(z, c, r)
             for j in range(r):
                 for k in range(c):
                     if j == 0 and k == 0:
                         print 'c',
                     elif (k,j) in s:
                         print '.',
                     else:
                         print '*',
                 print
 
 
",12,13,697
"= int(input())
 
 for t in range(T):
     N = int(input())
     naomi = sorted(list(map(float, input().split())))
     ken = sorted(list(map(float, input().split())))
     naomi_dw = naomi[:]
     ken_dw = ken[:]
     war = 0
     dwar = 0
     for pn in naomi:
         pk = bisect.bisect_left(ken, pn)
         if pk == len(ken):
             war += 1
             ken.pop(0)
         else:
             ken.pop(pk)
     for pn in naomi_dw:
         if pn > ken_dw[0]:
             dwar += 1
             ken_dw.pop(0)
         else:
             ken_dw.pop()
     print('Case #{}: {} {}'.format(t + 1, dwar, war))
",13,14,237
"def solve(grid, M, N):
     row_max = {}
     column_max = {}
     for i in range(M):
         row_max[i] = max(grid[i])
     for i in range(N):
         column_max[i] = max([grid[j][i] for j in range(M)])
     for i in range(M):
         for j in range(N):
             v = grid[i][j]
             if v < row_max[i] and v < column_max[j]:
                 return ""NO""
     return ""YES""
 
 if __name__ == ""__main__"":
     T = int(raw_input())
     for i in range(1,T+1):
         M,N = [int(x) for x in raw_input().split()]
         grid = [[int(x) for x in raw_input().split()] for j in range(M)]
         print ""Case #%d: %s"" % (i, solve(grid, M,N))
",14,15,249
"# python 3
 (board, xr, xc, nfree):
     to_refill = xr*xc - nfree
     for r in reversed(range(2, xr)):
         for c in reversed(range(2, xc)):
             if not to_refill:
                 return
             assert(board[r][c] == '.')
             board[r][c] = '*'
             to_refill -= 1
     # Bad board, but valid one
     for r in reversed(range(xr)):
         for c in reversed(range(xc)):
             if not to_refill:
                 return
             if board[r][c] == '.':
                 board[r][c] = '*'
                 to_refill -= 1
     assert(to_refill == 0)
     
 def generate_board(nrows, ncols, nmines):
     nfree = nrows*ncols - nmines
     xr=1; xc=1;
     while True:
         if xr*xc >= nfree:
             break
         if xr < nrows:
             xr += 1
         if xr*xc >= nfree:
             break
         if xc < ncols:
             xc += 1
     board = [['*' for c in range(ncols)] for r in range(nrows)]
     for r in range(xr):
         for c in range(xc):
             board[r][c] = '.'
     mines_refill(board, xr, xc, nfree)
     board[0][0] = 'c'
     return board
         
 def find_click_point(board):
     nrows = len(board)
     ncols = len(board[0])
     for r in range(nrows):
         for c in range(ncols):
             if board[r][c] == 'c':
                 return (r,c)
     raise ValueError('Start point not present')
 
 def enum_neighbour_coords(r0, c0, nrows, ncols):
     for r in range(r0-1, r0+2):
         if r<0 or r>=nrows:
             continue
         for c in range(c0-1, c0+2):
             if c<0 or c>=ncols:
                 continue
             yield (r,c)
 
 def click_board(board, click_coords):
     nrows = len(board)
     ncols = len(board[0])
     points = [click_coords]
     while points:
         r0,c0 = points.pop()
         mines_cnt = 0
         for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):
             if board[r][c] == '*':
                 mines_cnt += 1
         board[r0][c0] = str(mines_cnt)
         if not mines_cnt:
             for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):
                 if board[r][c] == '.':
                     points.append((r,c))
 
 def all_fields_checked(board):
     nrows = len(board)
     ncols = len(board[0])
     for r in range(nrows):
         for c in range(ncols):
             if board[r][c] == '.':
                 return False
     return True
 
 def is_board_oneclick(original_board):
     board = [row[:] for row in original_board] # deep copy
     assert(board[0][0] == 'c')
     r,c = find_click_point(board)
     click_board(board, (r,c))
     is_oneclick = all_fields_checked(board)
     return is_oneclick
 
 def board2result(board):
     return [''.join(row) for row in board]
 
 def process_case(nrows, ncols, nmines):
     board = generate_board(nrows, ncols, nmines)
     if is_board_oneclick(board):
         result = board2result(board)
     else:
         result = ['Impossible']
     return result
 
 def result_gen(lines):
     ncases = int(next(lines))
     for ci in range(1,ncases+1):
         R, C, M = line_of_numbers(next(lines))
         result = process_case(R, C, M)
         yield 'Case #{0}:\n'.format(ci, result)
         for res_line in result:
             yield res_line + '\n'
     
 def line_of_numbers(s):
     return [int(sub) for sub in s.split()]
 
 def input_gen(f_in):
     for line in f_in:
         if line.endswith('\n'):
             line = line[:-1]
         yield line
 
 def start(basename):
     infile = basename + '.in'
     outfile = basename + '.out'
     f_in = open(infile, 'r')
     f_out = open(outfile, 'w')
     f_out.writelines(result_gen(input_gen(f_in)))
     f_in.close()
     f_out.close()
 
 ##start('C-test')
 start('C-small-attempt0')
 ##start('C-large')
",15,16,1339
"(n):
     generators = []
     for ii in range(1, n + 1):
         generators += get_generators_length_n(ii)
     return generators        
 
 def get_generators_length_n(length):
     if length % 2 == 0: return get_even_generators_length_n(length)
     else: return get_odd_generators_length_n(length)
 
 def get_odd_generators_length_n(length):
     if length == 1: return [1, 2, 3]
     else: 
         n = length / 2
         generators = []
         for ii in range(min(n, 4)):
             for comb in itertools.combinations(range(1, n), ii):
                 first_half = [""1""] + [""0""] * (n-1)
                 for jj in comb:
                     first_half[jj] = ""1""
                 second_half = list(first_half)
                 second_half.reverse()
                 palin = first_half + [""0""] + second_half
                 generators.append(int("""".join([elem for elem in palin])))
                 palin[n] = ""1""
                 generators.append(int("""".join([elem for elem in palin])))
                 if ii <= 1:
                     palin[n] = ""2""
                     generators.append(int("""".join([elem for elem in palin])))
         generators.append(int("""".join([elem for elem in ([""2""] + [""0""] * (n - 1) + [""0""] + [""0""] * (n - 1) + [""2""])])))
         generators.append(int("""".join([elem for elem in ([""2""] + [""0""] * (n - 1) + [""1""] + [""0""] * (n - 1) + [""2""])])))
         generators.sort()
         return generators
 
 def get_even_generators_length_n(length):
     if length == 2: return [11, 22]
     n = length / 2
     generators = []
     for ii in range(min(n, 4)):
         for comb in itertools.combinations(range(1, n), ii):
             first_half = [""1""] + [""0""] * (n-1)
             for jj in comb:
                 first_half[jj] = ""1""
             second_half = list(first_half)
             second_half.reverse()
             palin = first_half + second_half
             generators.append(int("""".join([elem for elem in palin])))
     generators.append(int("""".join([elem for elem in ([""2""] + [""0""] * (length - 2) + [""2""])])))
     generators.sort()
     return generators
 
 def is_palin(num):
     string = str(num)
     length = len(string)
     ii = 0
     while ii < length/2:
         if string[ii] != string[-(1+ii)]:
             return False
         ii += 1
     return True
 
 def gen_fair_and_squares(upper_limit):
     fair_and_squares = []
     for ii in range(1, upper_limit + 1):
         if (is_palin(ii) and is_palin(ii*ii)):
             fair_and_squares.append(ii)
     return fair_and_squares
 
 f = open(sys.argv[1])
 T = int(f.readline())
 gens = get_generators_up_to_length_n(60)
 squares = map(lambda x: x*x, gens)
 
 for t in range(T):
     A, B = map(int, f.readline().strip().split())
     total = 0
     for elem in squares:
         assert(is_palin(elem))
         if elem >= A and elem <= B: total += 1
         if elem > B:
             break
 
     print ""Case #%d:"" % (t + 1), total
",16,17,1012
"# coding: utf-8
 (v):
     pass#print(v)
 
 def read(f):
     t = tuple(int(v) for v in f.readline().split())
     debug(t)
     return t
 
 def readf(f):
     t = tuple(float(v) for v in f.readline().split())
     debug(t)
     return t
 
 def answer(f, X, ans):
     out = ""Case #{}:\n{}"".format(X, ans)
     f.write(out)
     f.write(""\n"")
     print(out)
 
 def answer_cells(f, X, cells):
     out = ""Case #{}:"".format(X)
     f.write(out)
     f.write(""\n"")
     print(out)
     for row in cells:
         out = """".join(row)
         f.write(out)
         f.write(""\n"")
         print(out)
 
 def main(inf, outf):
     T, = read(inf)
     for casenmbr in range(1, T + 1):
         R, C, M = read(inf)
 
         if M == 0:
             cells = [['.'] * C for i in range(R)]
             cells[0][0] = 'c'
             answer_cells(outf, casenmbr, cells)
             continue
 
         empty = R * C - M
 
         if empty == 1:
             cells = [['*'] * C for i in range(R)]
             cells[0][0] = 'c'
             answer_cells(outf, casenmbr, cells)
             continue
 
         if R == 1 or C == 1:
             cells = [['.'] * C for i in range(R)]
             m = 0
             for r in range(R):
                 for c in range(C):
                     cells[r][c] = '*'
                     m += 1
                     if m == M:
                         break
                 else:
                     continue
                 break
             cells[-1][-1] = 'c'
             answer_cells(outf, casenmbr, cells)
             continue
 
         if empty in (2, 3, 5, 7):
             answer(outf, casenmbr, ""Impossible"")
             continue
 
         if (R == 2 or C == 2) and empty % 2:
             answer(outf, casenmbr, ""Impossible"")
             continue
 
         cells = [['*'] * C for i in range(R)]
 
 
         cells[0][0] = 'c'
         empty -= 1
         cc = 1
         rr = 1
         while empty > 0:
             if cc < C:
                 for r in range(rr):
                     if empty == 2 and r == rr - 1:
                         break
                     cells[r][cc] = '.'
                     empty -= 1
                     if empty == 0:
                         break
                 cc += 1
             if rr < R and empty > 0:
                 for c in range(cc):
                     if empty == 2 and c == cc - 1:
                         break
                     cells[rr][c] = '.'
                     empty -= 1
                     if empty == 0:
                         break
                 rr += 1            
 
         # cnt = 0
         # for row in cells:
         #     for v in row:
         #         if v == '*':
         #             cnt += 1
         # if cnt != M:
         #     raise ""!""
         answer_cells(outf, casenmbr, cells)
 
 
 if __name__==""__main__"":
     infname = sys.argv[1]
     outfname = os.path.splitext(infname)[0] + "".out""
     with open(infname, ""r"") as inf:
         with open(outfname, ""w"") as outf:
             main(inf, outf)
",17,18,1011
"YES = 0
 NO = 1
 
 messages = [
     ""YES"",
     ""NO""
 ]
 
 # def check_height(lawn, N, M, height, was, levels):
 #     for x, y in levels[height]:
 #         if x not in was['row'] and y not in was['col']:
 #             # Try the row
 #             good_row = True
 #             for i in xrange(M):
 #                 if lawn[x][i] > height:
 #                     good_row = False
 #                     break
 #             if good_row:
 #                 was['row'].add(x)
 #                 continue
 #             good_col = True
 #             for i in xrange(N):
 #                 if lawn[i][y] > height:
 #                     good_col = False
 #                     break
 #             if good_col:
 #                 was['col'].add(y)
 #                 continue
 #             # There is no good cut for this field
 #             return False
 #     return True
 
 # def check_lawn(lawn, N, M):
 #     heights_dict = {i: False for i in xrange(1,101)}
 #     for i in xrange(N):
 #         for j in xrange(M):
 #             heights_dict[lawn[i][j]] = True
 
 #     heights = [key for key in sorted(heights_dict.keys()) if heights_dict[key]]
 #     if len(heights) == 1:
 #         return YES
 #     levels = {height: [] for height in heights}
 
 #     for i in xrange(N):
 #         for j in xrange(M):
 #             levels[lawn[i][j]].append((i, j))
 
 #     was = {
 #         ""row"": set()
 #         ""col"": set()
 #     }
 
 #     for i, height in enumerate(heights[:-1]):
 #         if not check_height(lawn, N, M, height, was, levels):
 #             return NO
 
 #     return YES
 
 def check_lawn(lawn, N, M):
     row_maxs = [0 for _ in xrange(N)]
     col_maxs = [0 for _ in xrange(M)]
 
     for i in xrange(N):
         cmax = -1
         for j in xrange(M):
             if lawn[i][j] > cmax:
                 cmax = lawn[i][j]
         row_maxs[i] = cmax
 
     for j in xrange(M):
         cmax = -1
         for i in xrange(N):
             if lawn[i][j] > cmax:
                 cmax = lawn[i][j]
         col_maxs[j] = cmax
 
     for i in xrange(N):
         for j in xrange(M):
             if row_maxs[i] > lawn[i][j] and col_maxs[j] > lawn[i][j]:
                 return NO
 
     return YES
 
 
 T = int(raw_input().strip())
 for i in xrange(T):
     N, M = map(int, raw_input().strip().split(' '))
     lawn = [[] for j in xrange(N)]
     for j in xrange(N):
         lawn[j] = map(int, raw_input().strip().split(' '))
     print ""Case #%s: %s"" % (i + 1, messages[check_lawn(lawn, N, M)])
",18,19,893
"T = int(raw_input())
 
 def readSq(n):
     res = []
     for i in xrange(n):
         res.append(set(map(int, raw_input().split())))
     return res
 
 def solve():
     a1 = int(raw_input())
     s1 = readSq(4)
     a2 = int(raw_input())
     s2 = readSq(4)
     ans = s1[a1-1] & s2[a2-1]
     if len(ans) == 0:
         return ""Volunteer cheated!""
     if len(ans) > 1:
         return ""Bad magician!""
     return str(list(ans)[0])
 
 for z in xrange(T):
     print ""Case #%d: %s"" % (z+1, solve())
",19,20,210
"#!/usr/bin/env python
 
 = ""tiny""
 if 1:
     INPUT = ""C-small-attempt0.in""
 
 def debug(*args):
     pass #print str(args)
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args
 
 def is_palindrome(N):
     s = str(N)
     return s == ''.join(reversed(s))
 
 def fair_and_square_set(max_N):
     p = ""squareset_%d"" % max_N
     try:
         s = pickle.load(file(p))
         return s
     except:
         pass
     s = set()
     for i in range(1,max_N+1):
         if is_palindrome(i) and is_palindrome(i*i):
             s.add(i*i)
     pickle.dump(s, file(p, ""wb""))
     return s
 
 MAX_N = int(1e7)
 SQUARE_SET = fair_and_square_set(MAX_N)
 #print(SQUARE_SET)
 
 def do_trial(A, B):
     count = 0
     for ss in SQUARE_SET:
         if A <= ss <= B:
             count += 1
     return count
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     A, B = [int(x) for x in f.readline().split()]
     v = do_trial(A, B)
     print ""Case #%d: %s"" % (i+1, v)
",20,21,552
"def esPal(x):
 	return str(x) == str(x)[::-1]
 
 t = int(raw_input())
 
 for case in range(t):
 	line = raw_input().split(' ')
 	a = int(line[0])
 	b = int(line[1])
 
 	i = int(a**.5)
 	if i*i != a:
 		i += 1
 	max = int(b**.5)
 	cantidad = 0
 	while i <= max:
 		if esPal(i) and esPal(i*i):
 			cantidad += 1
 		i += 1
 
 	print 'Case #'+str(case+1)+':', cantidad
",21,22,197
"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	cost, prod, goal = (float(x) for x in inp.readline().split())
 	return cost, prod, goal
 
 def solve(cost, prod, goal):
 	rate = 2
 	now = 0
 	while True:
 		nobuyEnd = goal / rate
 		buyEnd = cost / rate + goal / (rate + prod)
 		if buyEnd < nobuyEnd:
 			now += cost / rate
 			rate += prod
 		else:
 			return '%0.7f' % (now + nobuyEnd)
 
 def main():
 	(RECURSION_LIMIT)
 
 	= resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		= Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",22,23,581
"# -*- coding: utf-8 -*-
 
 T = int(raw_input())
 for test_case in xrange(1, T + 1):
     C, F, X = map(float, raw_input().split())
     answer = X / 2
     i = 0
     last_tc = 0
     while True:
         tc = last_tc + C / (2 + (i * F))
         if answer < tc:
             break
         answer = min(tc + X / (2 + (i + 1) * F), answer)
 
         i += 1
         last_tc = tc
     print 'Case #{}: {:.7f}'.format(test_case, answer)
",23,24,176
"#use combinations!
 (filepath):	#1lpc = 1 line per case
 	with file(filepath, 'rb') as f_in:
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			yield line_index, line.strip().split(' ')
 
 def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case
 	with file(filepath, 'rb') as f_in:
 		case_counter = 1
 		case = []
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			case.append(line.strip().split(' '))
 			if not line_index % n:
 				yield case_counter, case
 				case_counter += 1
 				case = []
 
 def iterate_cases_glpc(filepath):		#glpc - given lines per case
 	with file(filepath, 'rb') as f_in:
 		case_counter = 0
 		new_case = True
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			if new_case:
 				new_case = False
 				case_counter += 1
 				case = []
 				assert len(line.strip().split(' ')) == 1
 				lines_left = int(line.strip())
 				if not lines_left:
 					new_case = True
 					yield case_counter, case
 				continue
 			if lines_left:
 				lines_left -= 1
 				case.append(line.strip().split(' '))
 			if not lines_left:
 				new_case = True
 				yield case_counter, case
 			
 def part_of_list_to_int(array, flags):
 	assert len(array) == len(flags)
 	output = []
 	for index, elem in enumerate(array):
 		if flags[index]:
 			output.append(int(elem))
 		else:
 			output.append(elem)
 	return output
 
 def list_to_int(array):
 	return part_of_list_to_int(array, [True] * len(array))
 
 def part_of_list_to_float(array, flags):
 	assert len(array) == len(flags)
 	output = []
 	for index, elem in enumerate(array):
 		if flags[index]:
 			output.append(float(elem))
 		else:
 			output.append(elem)
 	return output
 
 def list_to_float(array):
 	return part_of_list_to_float(array, [True] * len(array))
 
 def get_max_array_on_index(array, index):
 	elem_len = len(array[0])
 	assert index < elem_len
 	for elem in array:
 		assert elem_len == len(elem)
 	max_sub = array[0][index]
 	max_elem = array[0]
 	for elem in array:
 		if elem[index] > max_sub:
 			max_sub = elem[index]
 			max_elem = elem
 	return max_elem
 
 def list_index_in_sorted_with_position(a_list, value, pos):
 	list_len = len(a_list)
 	if list_len == 1:
 		if a_list[0] == value:
 			return pos
 		return -1
 	if a_list[list_len/2] > value:
 		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)
 	else:
 		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))
 	
 def list_index_in_sorted_list(a_list, value):
 	return list_index_in_sorted_with_position(a_list, value, 0)
 
 def copy_list(list):
 	res = []
 	for elem in list:
 		res.append(elem)
 	return res	
 
 ############################################################
 #### add solution here 									####
 #### don't forget to change data from str to int/float  ####
 ############################################################
 
 def conj_mat(a):
 	R = len(a)
 	C = len(a[0])
 	res = [['.' for _ in xrange(R)] for __ in xrange(C)]
 	for i in xrange(R):
 		for j in xrange(C):
 			res[j][i] = a[i][j]
 	return res
 
 def one_line_builder(R, C, M):
 	res = []
 	res.extend(['*'] * M)
 	res.extend(['.'] * (C - M))
 	res[-1] = 'c'
 	return [res]
 	
 def two_line_builder(R, C, M):
 	line = []
 	line.extend(['*'] * (M / 2))
 	line.extend(['.'] * (C - M / 2))
 	res = [line, copy_list(line)]
 	res[1][-1] = 'c'
 	if M%2 == 1:
 		res[0][-1] = '*'
 	return res
 	
 def three_line_builder(R, C, M):
 	res = [['.' for _ in xrange(C)] for __ in xrange(R)]
 	res[-1][-1] = 'c'
 	m = min([M, R * C - 9])
 	stop_flag = False
 	for j in xrange(C):
 		if stop_flag:
 			break
 		for i in xrange(R):
 			if m == 0:
 				stop_flag = True
 				break
 			res[i][j] = '*'
 			m -= 1
 	print i,j
 	if i == 2:
 		res[1][j-1] = '.'
 		if j == C - 3:
 			res[0][j] = '*'
 		else:
 			res[0][-1] = '*'
 	
 	if M <= R * C - 9:
 		return res
 	else:
 		m = M - (R * C - 9)
 		assert m not in [2, 4, 6, 7, 9]
 		assert m > 0
 		assert m < 10
 		
 		res[-3][-3] = '*'
 		m -= 1
 		if m == 0: return res
 		res[-2][-3] = '*'
 		res[-1][-3] = '*'
 		m -= 2
 		if m == 0: return res
 		res[-3][-2] = '*'
 		res[-3][-1] = '*'
 		m -= 2
 		if m == 0: return res
 		res[-2][-2] = '*'
 		res[-2][-1] = '*'
 		res[-1][-2] = '*'
 		m -= 3
 		if m == 0: return res
 		assert False
 	
 	
 	
 def over_three_line_builder(R, C, M):
 	if M <= (R - 3) * C:
 		res = [['*' for _ in xrange(C)] for __ in xrange(M / C)]
 		flag = False
 		if (M % C) != (C - 1):
 			line = ['*' for _ in xrange(M % C)]
 			line.extend(['.' for _ in xrange(C - (M % C))])
 		else:
 			line = ['*' for _ in xrange((M % C) - 1)]
 			line.extend(['.' for _ in xrange((C - (M % C)) + 1)])
 			flag = True
 		res.append(line)
 		index = len(res)
 		res.extend([['.' for _ in xrange(C)] for __ in xrange(R - len(res))])
 		if flag:
 			res[index][0] = '*'
 		res[-1][-1] = 'c'
 		assert len(res) == R
 		assert len(res[0]) == C
 		return res
 	else:
 		res = [['*' for _ in xrange(C)] for __ in xrange(R - 3)]
 		M -= (R - 3) * C
 		tmp = three_line_builder(3, C, M)
 		if len(tmp) != 3: # error msg
 			return tmp
 		res.extend(tmp)
 		return res
 	
 def solve(R, C, M):
 	res = None
 	
 	if M == R * C:
 		return 'Impossible'
 	if R >= 3 and C >= 3:
 		if R*C - M in [7, 5, 3, 2]:
 			return 'Impossible'
 		return over_three_line_builder(R, C, M)
 		
 	elif R != 1 and C != 1:  #which means one of them is 2, and the other not 1
 		if (R*C - M) % 2 == 1:
 			if M < R*C - 1:
 				return 'Impossible'
 		if M + 2 == R * C:
 			return 'Impossible'
 		else:
 			if R == 2:
 				return two_line_builder(R, C, M)
 			else:
 				tmp = two_line_builder(C, R, M)
 				return conj_mat(tmp)
 	
 	else:					#which means one of them is 1
 		if R == 1:
 			return one_line_builder(R, C, M)
 		else:
 			tmp = one_line_builder(C, R, M)
 			return conj_mat(tmp)
 		
 	return res
 
 def mat_to_str(a):
 	if a in ['Impossible', 'Not Implemented']:
 		return a
 	str_out = ''
 	for row in a:
 		for elem in row:
 			str_out += elem
 		str_out += '\n'
 	return str_out[:-1]
 	
 def calc_result(case):
 	result = None
 	
 	R = int(case[0])
 	C = int(case[1])
 	M = int(case[2])
 	print R, C, M
 	
 	result = solve(R, C, M)
 	
 	str_out = mat_to_str(result)
 	m = str_out.count('*')
 	assert (m==0 or m==M)
 	print str_out
 	
 	return '\n%s' % str_out
 
 def main(filepath):
 	start_time = time.time()
 	with file('output.txt', 'wb') as f_out:
 		
 		######################################
 		#### select input iteration type: ####
 		####	- iterate_cases_1lpc	  ####
 		####	- iterate_cases_nlpc +n	  ####
 		####	- iterate_cases_glpc	  ####
 		######################################
 		for case_index, case in iterate_cases_1lpc(filepath):
 			
 			print ""case #%d: time:%.02f"" % (case_index, time.time() - start_time)
 			result = calc_result(case)
 			
 			#######################
 			#### format output ####
 			#######################
 			f_out.write(""Case #%d: %s\n"" % (case_index, result))
 				
 if __name__ == '__main__':
 	main(sys.argv[1])
",24,25,3415
"#!/usr/bin/env python
 # -*- coding:utf-8 -*-
 #
 # Problem C. Minesweeper Master
 # https://code.google.com/codejam/contest/2974486/dashboard#s=p2
 #
 
 (R, C, M, _board):
     # deepcopy
     board = [line[:] for line in _board]
 
     pos = [(0, 0)]
     while pos:
         row, col = pos.pop()
         # neighbor cell list
         neighbor = []
         for r in (-1, 0, 1):
             r += row
             for c in (-1, 0, 1):
                 c += col
                 if r >= 0 and r < R and c >= 0 and c < C:
                     neighbor.append((r, c))
         # count bomb
         count = len([1 for r, c in neighbor if board[r][c] == '*'])
         board[row][col] = str(count)
         # push next cell
         if count == 0:
             for r, c in neighbor:
                 if board[r][c] == '.':
                     pos.append((r, c))
 
     flat = ''.join(''.join(line) for line in board)
     result = not flat.count('.')
     if not result and False: # for DEBUG
         print '-' * 20
         print R, C, M
         print '\n'.join(''.join(line) for line in _board)
         print '-' * 20
     assert flat.count('*') == M
     return result
 
 
 def solve(R, C, M):
     # initialize
     board = [['.'] * C for row in range(R)]
     board[0][0] = 'c'
     row = R
     col = C
     mine = M
 
     # phase 1: right edge, bottom edge
     while mine:
         if 0 < row <= col and mine >= row:
             for r in range(row):
                 board[row - r - 1][col - 1] = '*'
             mine -= row
             col -= 1
         elif 0 < col <= row and mine >= col:
             for c in range(col):
                 board[row - 1][col - c - 1] = '*'
             mine -= col
             row -= 1
         else:
             break
 
     # phase 2:
     if mine:
         #print '\n'.join(''.join(line) for line in board)
         #print 'left', mine
         while mine and row > 2:
             for r in range(min(mine, row - 2)):
                 board[row - r - 1][col - 1] = '*'
                 mine -= 1
             col -= 1
         while mine and col > 2:
             for c in range(min(mine, col - 2)):
                 board[row - 1][col - c - 1] = '*'
                 mine -= 1
             row -= 1
 
     # phase 3
     if mine:
         # col == row == 2
         if mine:
             board[1][1] = '*'
             mine -= 1
         if mine:
             board[1][0] = '*'
             mine -= 1
         if mine:
             board[0][1] = '*'
             mine -= 1
 
     assert mine == 0
     return '\n'.join(''.join(line) for line in board) if check(R, C, M, board) else 'Impossible'
 
 
 def main(IN, OUT):
     T = int(IN.readline())
     for index in range(T):
         R, C, M = map(int, IN.readline().split())
         OUT.write('Case #%d:\n%s\n' % (index + 1, solve(R, C, M)))
 
 
 def makesample(maxSize=5, T=230):
     (T):
         R = random.randint(1, maxSize)
         C = random.randint(1, maxSize)
         print R, C, random.randint(0, R * C - 1)
 
 
 def makesample():
     pattern = []
     for R in range(1, 5+1):
         for C in range(1, 5+1):
             for M in range(R * C):
                 pattern.append((R, C, M))
     print len(pattern)
     for R, C, M in pattern:
         print R, C, M
 
 
 if __name__ == '__main__':
     if '-makesample' in sys.argv[1:]:
         makesample()
     else:
         main(sys.stdin, sys.stdout)
 
",25,26,1186
"(board, mapping):
     val = int(board.translate(string.maketrans(mapping, ""1100"")), 2)
     for v in [0x000f, 0x00f0, 0x0f00, 0xf000,
               0x1111, 0x2222, 0x4444, 0x8888,
               0x1248, 0x8421]:
         if (val & v) == v:
             return True
     return False
 
 
 def finished(board):
     return '.' not in board
 
 
 def compute(board):
     if won(board, 'XTO.'):
         return ""X won""
     if won(board, 'OTX.'):
         return ""O won""
     if finished(board):
         return ""Draw""
     return ""Game has not completed""
 
 
 def parse():
     board = []
     for i in xrange(4):
         board.append(sys.stdin.readline().strip())
     sys.stdin.readline()
     return (''.join(board),)
 
 
 if __name__ == ""__main__"":
     sys.setrecursionlimit(100000)
     T = int(sys.stdin.readline().strip())
     count = 1
     part = 0
     if len(sys.argv) == 3:
         part = int(sys.argv[1])
         count = int(sys.argv[2])
     for i in xrange(T):
         data = parse()
         if i * count >= part * T and i * count < (part + 1) * T:
             result = compute(*data)
             print ""Case #%d: %s"" % (i + 1, result)
",26,27,453
"def read_line():
     return raw_input().strip()
 
 def read_words():
     return read_line().split()
 
 def read_integer():
     return int( read_line() )
 
 def read_integers():
     return [ int( x ) for x in read_words() ]
 
 T = read_integer()
 for t in range( T ):
     print 'Case #%i:' % ( t + 1 ),
     A, B = read_integers()
     length = len( str( A ) )
     pairs = set()
     for n in range( A, B ):
         digits = str( n )
         for start in range( 1, length ):
             m = int( digits[ start : ] + digits[ : start ] )
             if n < m <= B:
                 pairs.add( ( n, m ) )
     print len( pairs )
",27,28,216
"#!/usr/bin/python
 
 (file):
   """"""
     input:
 
 		T (number of test cases)
 
 		N M
 		N lines of M numbers (desired height of grass)
 
   """"""
 
   tests = []
 
   T = int(file.readline().strip())
 
   for i in xrange(T):
 		test = {}
 
 		line = file.readline().strip()
 		parts = line.split(' ')
 
 		if len(parts) != 2:
 			print ""HORRIBLE ERROR in TEST %d!"" % (i+1, )
 			return None
 
 		N = int(parts[0])
 		M = int(parts[1])
 
 		test['N'] = N
 		test['M'] = M
 		test['desired'] = []
     
 		for j in xrange(N):
 			line = file.readline().strip()
 			parts = line.split(' ')
 
 			if len(parts) != M:
 				print ""TERRIBLE ERROR in TEST %d!"" % (i+1, )
 				return None
 
 			for p in parts:
 				k = int(p)
 				test['desired'].append(k)
 
 		tests.append(test)
 
   return tests
 
 def run(test):
 	""""""
 		Run a test and return output.
 	""""""
 
 	# Figure out row/col min and max
 	test['row'] = []
 	test['col'] = []
 
 	for row in xrange(test['N']):
 		r = []
 
 		for col in xrange(test['M']):
 			i = row * test['M'] + col
 
 			r.append(test['desired'][i])
 
 		test['row'].append({'min' : min(r), 'max' : max(r)})
 
 	for col in xrange(test['M']):
 		c = []
 
 		for row in xrange(test['N']):
 			i = row * test['M'] + col
 
 			c.append(test['desired'][i])
 
 		test['col'].append({'min' : min(c), 'max' : max(c)})
 
 	for x in xrange(test['M']):
 		for y in xrange(test['N']):
 			i = y * test['M'] + x
 			v = test['desired'][i]
 
 			# If you are smaller than someone in both directions, it's impossible
 			rowmax = test['row'][y]['max']
 			colmax = test['col'][x]['max']
 			if (v < rowmax) and (v < colmax):
 				#print ""(%d,%d) = %d, row = %d, col = %d"" % (x, y, v, rowmax, colmax)
 				return ""NO""
 
 	return ""YES""
 
 file = open(sys.argv[1], ""rt"")
 
 tests = readfile(file)
 
 file.close()
 
 case = 1
 
 for test in tests:
 #if True:
   #test = tests[0]
   result = run(test)
   print ""Case #%d: %s"" % (case, result)
   case = case + 1
",28,29,940
"# -*- coding: utf-8 -*-
 = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     numbers = map(int, fin.readline().split())
     N, S, p = numbers[:3]
     T = numbers[3:]
     normal_limit = p + 2*max(0, (p-1))
     surpising_limit = p + 2*max(0, (p-2))
 
     normal_count = 0
     surprising_count = 0
 
     for t in T:
         if t >= normal_limit:
             normal_count += 1
         elif t >= surpising_limit:
             surprising_count += 1
 
     result = normal_count + min(surprising_count, S)
 
     print ""Case #%d: %s"" % (case, result)
 
",29,30,223
"#!/usr/bin/python
 (state, coord):
     if coord[0] < 0 or coord[1] < 0:
         return False
     elif coord[0] > (len(state) - 1):
         return False
     elif coord[1] > (len(state[coord[0]]) - 1):
         return False
     else:
         return True
 
 def clear(state, coord):
     for r in range(-1,2):
         for c in range(-1,2):
             row = coord[0] + r
             col = coord[1] + c
             if check_bounds(state, (row, col)):
                 state[row][col] = 0
 
 def count(state):
     return sum([sum(x) for x in state])
 
 def state_print(state):
     print(""c"" + """".join([""*""  if x else ""."" for x in state[0][1:]]))
     for line in state[1:]:
         print("""".join([""*""  if x else ""."" for x in line]))
 
 def solve(state, mines):
     prev_state = deepcopy(state)
     for row in range(len(state)):
         for col in range(len(state[row])):
             new_state = deepcopy(state)
             clear(new_state, (row, col))
             c = count(new_state)
             # print(c)
             # state_print(state)
             if(c < mines):
                 state = prev_state
             elif( c == mines):
                 state_print(new_state)
                 return True
             else:
                 if col == len(state[row]) -2:
                     prev_state = deepcopy(state)
                 state = new_state
     print(""Impossible"")
     return False
 
 
 
 
 def main():
     filename = ""C-small-attempt0.in""
     # filename = ""C-large.in""
     # filename = ""sample.in""
 
 
     inp = open(filename, ""rU"")
 
     n = int(inp.readline().strip())
 
     for case in range(1, n + 1):
         R, C, M = map(int, inp.readline().strip().split("" ""))
         state = [[1 for x in range(C)] for y in range(R)]
         print(""Case #{}:"".format(case))
         solve(state, M)
     # state = [[1 for x in range(7)] for y in range(4)]
     # solve(state, 13)
 
 main()",30,31,639
"=0 #no. of Test cases
 for line in fileinput.input():
     if fileinput.isfirstline():
         T=int(line)
         print ""no. of test cases:"", T
         continue
     
     nums=[int(x) for x in line.split()]
     N=nums[0] #no. of googlers
     S=nums[1] #no. of surprising triplets
     p=nums[2] #max value
     #print ""N S p:"", N, S, p
     
     del nums[:3]
     count=0
     for num in nums:
         quo=num//3
         rem=num%3
         #print ""num, quo, rem"", num, quo, rem
         if quo >= p:
             count += 1
             continue
         elif quo+1 == p and rem > 0:
             count += 1
             continue
         elif quo+1 ==p and rem == 0 and quo > 0 and S > 0:
             count += 1
             S -= 1
             continue
         elif quo+2 >= p and rem == 2 and S > 0:
             count += 1
             S -= 1
     
     print ""Case #%(k)i: %(count)i"" % {""k"":fileinput.lineno()-1,""count"":count}
",31,32,335
"filename = raw_input(""Name of file: "")
 infile = open(filename, ""r"")
 outfile = open(filename + "".out"", ""w"")
 
 
 T = int(infile.readline()[:-1])
 ## Code starts here
 
 
 def getMinTime(c, f, x):
     p0 = 2.0
     s_prev = x / p0
     s_curr = c / p0
     prev_item = 0
     next_item = x / (p0 + f)
     n = 1
     while s_prev + prev_item > s_curr + next_item:
         s_prev = s_curr
         prev_item = next_item
         s_curr += c / (p0 + (n * f))
         next_item = x / (p0 + ((n + 1) * f))
         n += 1
     return s_prev + prev_item
 
 for t in range(1, T + 1):
     items = infile.readline()[:-1].split("" "")
     c = float(items[0])
     f = float(items[1])
     x = float(items[2])
     time = getMinTime(c, f, x)
     outfile.write(""Case #%d: %.7f\n"" %(t, time))
     
         
     
 ## code ends here
 
 outfile.close()
 infile.close()
",32,33,350
"(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         nn = [float(x) for x in inputs[1].split()]
         nn.sort()
         kk = [float(x) for x in inputs[2].split()]
         kk.sort()
         dw = self.dwar(nn[:], kk[:])
         w = self.war(nn[:], kk[:])
         return '%d %d'%(dw, w)
         pass
     
     def dwar(self, nn, kk):
         turn = len(nn)
         cnt = 0
         for i in range(turn):
             i = i
             if nn[-1] < kk[-1]:
                 nn.pop(0)
                 kk.pop(-1)
             elif nn[0] < kk[0]:
                 nn.pop(0)
                 kk.pop(-1)
             else:
                 cnt += 1
                 nn.pop(0)
                 kk.pop(0)
         return cnt
     
     def war(self, nn, kk):
         turn = len(nn)
         cnt = 0
         for i in range(turn):
             i = i
             j = bisect.bisect_left(kk, nn[0])
             if j == len(kk):
                 cnt += 1
                 kk.pop(0)
             else:
                 kk.pop(j)
             nn.pop(0)
         return cnt
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 3
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'D-small-attempt0.in'
 #     iname = 'foo'
     sample_in = '''
 4
 1
 0.5
 0.6
 2
 0.7 0.2
 0.8 0.3
 3
 0.5 0.1 0.9
 0.6 0.4 0.3
 9
 0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899
 0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458
     '''
     sample_out = '''
 Case #1: 0 0
 Case #2: 1 0
 Case #3: 2 1
 Case #4: 8 4
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",33,34,1100
"():
     height, width = sys.stdin.readline().split()
     width = int(width)
     height = int(height)
 
     lawn = [[0 for c in range(width)] for r in range(height)]
     mark = [[0 for c in range(width)] for r in range(height)]
     settings = []
 
     for r in range(height):
         row = sys.stdin.readline().split()
         for c in range(width):
             h = int(row[c])
             lawn[r][c] = h
             if h not in settings: settings.append(h)
 
     settings = sorted(settings)
 
     for i in range(len(settings)):
         h = settings[i]
         h_next = 0
         if i < len(settings) - 1:
             h_next = settings[i + 1]
 
         # check row
         for r in range(height):
             count = 0
             for c in range(width):
                 if lawn[r][c] == h: count = count + 1
             if count == width:
                 for c in range(width): mark[r][c] = h
 
         # check col
         for c in range(width):
             count = 0
             for r in range(height):
                 if lawn[r][c] == h: count = count + 1
             if count == height:
                 for r in range(height): mark[r][c] = h
 
         # anything left?
         for c in range(width):
             for r in range(height):
                 if lawn[r][c] == h:
                     if mark[r][c] != h: return ""NO""
                     lawn[r][c] = h_next
 
     return ""YES""
 
         
 
 def main():
 
     count = int(sys.stdin.readline())
     for index in range(count):
         result = process()
         print ""Case #%d: %s"" % (index + 1, result)
 
 if __name__ == '__main__':
     main()
",34,35,522
"(rows,cols,width,height):
     # Calculate the lowest setting that can be used when cutting a row or col.
     row_mins = [max(row) for row in rows]
     col_mins = [max(col) for col in cols]
     for row_idx in range(height):
         for col_idx in range(width):
             if row_mins[row_idx] > rows[row_idx][col_idx] \
                and col_mins[col_idx] > rows[row_idx][col_idx]:
                 return ""NO""
     return ""YES""
 
 
 def parse_case(data,width,height):
     data_line = [int(entry) for entry in reduce(lambda x,y: x+y, data, [])]
     rows = []
     cols = []
     for idx in range(height):
         offset = idx * width
         # Pull rows
         rows.append(data_line[offset:offset+width])
     for idx in range(width):
         # Pull columns
         cols.append(data_line[idx::width][:height])
     return (rows, cols, width, height)
 
 def main():
     parser = OptionParser()
     parser.add_option(""-f"", ""--file"", dest=""filename"",
                       help=""read input from FILE"", metavar=""FILE"")
 
     (options, args) = parser.parse_args()
     if not options.filename:
         parser.error(""Must provide a filename."")
     input_file = open(options.filename, ""r"")
     total_cases = int(input_file.readline())
     case_number = 0
     while case_number < total_cases:
         case_number += 1
         height,width = input_file.readline().split()
         width = int(width)
         height = int(height)
         data = []
         for idx in range(height):
             data.append(input_file.readline().split())
         data_args = parse_case(data, width, height)
         print ""Case #%d: %s"" % (case_number, solve(*data_args))
 
 if __name__ == ""__main__"":
     main()",35,36,539
"= "".out""
 IN_S = ""small.in""
 IN_L = ""large.in""
 CASE_PRFX = ""Case #%s: ""
 
 ddd = {}
 
 def read_input(filename):
     data = []
     with open(filename, ""r"") as f:
         cases = int(f.readline())
         for _ in xrange(cases):
             code = f.readline()
             data.append(code)
     return data
 
 def make_output(fname, output):
     fname = fname + OEXT
     with open(fname, ""w"") as f:
         restext = []
         for i, v in enumerate(output):
             restext.append(CASE_PRFX % (i+1,) + v)
         f.writelines(restext)
     
 def main(fname):
     data = read_input(fname)
     output = []
     for code in data:
         output.append("""".join([ddd[k] for k in code]))
     print output
     make_output(fname, output)
     
 def mainex(fname):
     with open(fname, ""r"") as f:
         cases = int(f.readline())
         for _ in xrange(cases):
             code = f.readline()
             trans = f.readline()
             for i, c in enumerate(code):
                 ddd.setdefault(c, trans[i])
     
     abc = string.ascii_lowercase + "" \n""
     for c in abc:
         if c not in ddd.values():
             print ""not in trans:"", c
             missingt = c
         if c not in ddd.keys():
             print ""not in code:"", c
             missingc = c
     ddd.setdefault(missingc, missingt)
     print ddd
     print len(ddd)
     return ddd
     
     
     
 mainex(""examples.in"")
 main(""examples_raw.in"")
 main(""small.in"")",36,37,496
"(): return stdin.readline().rstrip('\n')
 def read_int(): return int(stdin.readline())
 def read_ints(): return map(int, stdin.readline().split())
 def read_floats(): return map(float, stdin.readline().split())
 
 
 def solve_case():
     C, F, X = read_floats()
     rate = 2
     current = 0
     best = X / rate
     
     while True:
         current += C / rate
         rate += F
         next = current + X / rate
         if next < best:
             best = next
         else:
             break
     
     return best
 
     
 def main():
     cases = read_int()
     for case in range(1, cases + 1):
         print('Case #{}: {:.7f}'.format(case, solve_case()))
 
         
 main()
",37,38,224
"(IN):
     def rstr(): return IN.readline().strip()
     def rint(): return int(rstr())
     def rints(): return map(int, rstr().split())
     def nrints(N): return [rints() for i in xrange(N)]
     N, M = rints()
     A = nrints(N)
     R = [max(row) for row in A]
     C = [max(col) for col in izip(*A)]
     for i, r in enumerate(R):
         for j, c in enumerate(C):
             if A[i][j] != min(r,c):
                 return ""NO""
     return ""YES""
 
 def RUN(IN, OUT):
     t = int(IN.readline().strip())
     for i in xrange(1,t+1):
         OUT.write(""Case #%i: %s\n"" % (i, CASE(IN)))
 
 if __name__ == ""__main__"":
     (sys.stdin, sys.stdout)
",38,39,252
"#!/usr/bin/env python
 =100000
 def Solve(C,F,X):
     best_time=float('inf')
     for n in xrange(0,BIG_NUM):
         if n==0:
             farm_time=0
         else:
             farm_time += C/(2+(n-1)*F)
         if best_time<=farm_time: break
         cookie_time=X/(2+n*F)
 
         if farm_time+cookie_time<best_time:
             best_time=farm_time+cookie_time
 
     return '%.9f'%best_time
 
 
 
 def parse(infile):
     C,F,X=map(float, infile.readline().split() )
     return C,F,X
 
 
 
 class GCJ_Parser( object ):
     def __init__(self,fname):
         self.infile=open(fname,'r')
         self.NumCases=int(self.infile.readline().strip() )
         self.caseNum=0
 
     def __iter__(self): return self
 
     def next(self):
         if self.caseNum==self.NumCases: raise StopIteration
         self.caseNum += 1
         args=parse(self.infile)
         return self.caseNum , args
 
 
 def runmain():
     myCases=GCJ_Parser(sys.argv[1])
 
     #Open output file, but don't overwrite old ones (for comparison)
     outname=sys.argv[1].rstrip('.in')+'.out'
     if os.path.isfile(outname):
         oldout=outname+'.old'
         ii=0
         while os.path.isfile(oldout):
             ii+=1
             oldout=outname+'.old'+str(ii)
         os.rename(outname,oldout)
         print 'Rename: %s -> %s'%(outname,oldout)   
  
     outfile=open(outname,'w')
 
     for iCase, args in myCases:
         answer=Solve(*args)
 
         print 'Case #'+str(iCase)+':',answer
         print >> outfile, 'Case #'+str(iCase)+':',answer
 
 
 
 
 if __name__=='__main__':
     runmain()
",39,40,598
"#!/usr/bin/python3
 
 = int(sys.stdin.readline().strip())
 
 for t in range(1, ncases+1):
     values = sys.stdin.readline().split()
     c = float(values[0])
     f = float(values[1])
     x = float(values[2])
     r = 2
 
     time = 0
 
     while True:
         tdirect = x/r
         tfactory = c/r + x/(r+f)
 
         if tdirect<tfactory:
             time += tdirect
             break
         else:
             time += c/r
             r += f
 
     print(""Case #{0}: {1:.7f}"".format(t, time))
",40,41,187
"#!/usr/bin/env python
 
 (N, ns, ks):
     """"""Return Naomi's score in regular War
 
     Strategy: Naomi and Ken both play their smallest possible block. When Ken
     runs out of winning blocks, Naomi's score is the number of remaining blocks.
 
     Ken's strategy is to select the smallest block which will beat Naomi's
     choice, or if there is none, then his smallest block.
     """"""
     i = 0   # position through naomi's blocks
     j = 0   # position through ken's blocks
 
     # Play each of Naomi's blocks:
     while i < N:
         # Invariant: i <= j
         # Find a block for Ken to play
         while j < N and ks[j] < ns[i]:
             j += 1
 
         # If Ken is out of playable blocks, game is over.
         if j == N:
             break
 
         # Move on to the next block for each player
         i += 1
         j += 1
 
     return N - i
 
 def deceit(N, ns, ks):
     """"""Return Naomi's score in Deceitful War
 
     Strategy: Naomi selects the smallest block with size > min(ks), and sets
     Told_N > max(ks). Ken will choose to play min(ks), and lose the round.
     If all of Naomi's blocks are smaller than all of Ken's, she cannot win any
     more rounds, and her score is the number of blocks used (which is also equal
     to N - the number of remaining blocks).
 
     This happens to be the same strategy as regular war, with ks and ns swapped,
     and the final score subtracted from N. (At least, I'm pretty sure it'll work).
     """"""
     return N - war(N, ks, ns)
 
 
 def solve(N, ns, ks):
     ns.sort()
     ks.sort()
     return ""{} {}"".format(deceit(N, ns, ks), war(N, ns, ks))
 
 if __name__ == '__main__':
     fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin
     fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout
     with fin, fout:
         T = int(fin.readline())
         for case in xrange(1, T+1):
             n = int(fin.readline())
             ns = map(float, fin.readline().split())
             ks = map(float, fin.readline().split())
             soln = solve(n, ns, ks)
             print >> fout, ""Case #{0}: {1}"".format(case, soln)
 
",41,42,699
"#!/usr/bin/python
 
 (C, F, X):
     rate = 2.0
     time_to_win = X / rate
 
     time_used = C / rate
     rate += F
     time_to_win_new = time_used + X / rate
 
     while time_to_win_new < time_to_win:
         time_to_win = time_to_win_new
         
         time_used += C / rate
         rate += F
         time_to_win_new = time_used + X / rate
 
     return time_to_win
 
 def main():
     N = int(sys.stdin.readline()) # number of testcases
     for i in range(N):
         [C, F, X] = [float(x) for x in sys.stdin.readline().rstrip().split()]
 
         result = solve(C, F, X)
         print (""Case #%s: %.7f"" % (i+1, result))
 
 if __name__ == '__main__':
     main()
",42,43,264
"== ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         a1 = int(f.readline())
         l1 = [map(int, f.readline().split()) for _ in xrange(4)]
         a2 = int(f.readline())
         l2 = [map(int, f.readline().split()) for _ in xrange(4)]
 
         poss = list(set(l1[a1-1]) & set(l2[a2-1]))
 
         print ""Case #%d:"" % (_T + 1),
         if len(poss) == 0:
             print ""Volunteer cheated!""
         elif len(poss) == 1:
             print poss[0]
         else:
             print ""Bad magician!""
",43,44,249
"*
 
 class Test(unittest.TestCase):
 	def test_1(self):
 		self.assertEqual(main(1, 4), 2)
 	def test_2(self):
 		self.assertEqual(main(10, 120), 0)
 	def test_3(self):
 		self.assertEqual(main(100, 100000000000000), 2)
 
 tCase = int(sys.stdin.readline())
 
 
 def main(matriz, M, N):
 	#print matriz
 	
 	for i in xrange(M):
 		for j in xrange(N):
 			ana = matriz[i + 1, j + 1]
 			#print ana
 			maiores_linha = 0
 			for x in xrange(M + 2):
 				if matriz[x, j + 1] > ana:
 					maiores_linha += 1
 			
 			if maiores_linha == 0:
 				continue
 			
 			maiores_coluna = 0 
 			for y in xrange(N + 2):
 				if matriz[i + 1, y] > ana:
 					maiores_coluna += 1
 					
 			if maiores_linha >= 1 and maiores_coluna >= 1:
 				#print ana, maiores_linha, maiores_coluna
 				return 'NO'
 				
 	return 'YES'
 	
 
 
 	
 if __name__ == '__main__':
 	#unittest.main()
 	for i in xrange(tCase):	
 		##Numbers
 		N,M = [int(x) for x in sys.stdin.readline().split(' ')]
 		
 		matriz = zeros((N + 2, M + 2), dtype=int)
 		
 		for j in xrange(N + 2):
 			matriz[j][0] = 0
 			matriz[j][M + 1] = 0
 			
 		for j in xrange(M + 2):
 			matriz[0][j] = 0
 			matriz[N + 1][j] = 0
 		
 		for k in xrange(N):
 			j = 1
 			line = [str(x) for x in sys.stdin.readline().split(' ')]
 			for n in line:
 				matriz[k + 1][j] = n		
 				j += 1
 		#matriz = zeros((N + 2, M + 2), dtype=int)
 		
 		print ""Case #%d: %s"" % (i + 1, main(matriz, N, M))",44,45,814
"inputFile = open('C-small-attempt8.in', 'r')
 lines = inputFile.readlines()
 inputFile.close()
 
 outputFile = open('C-small-attempt8.out', 'w')
 
 numTests = int(lines[0])
 
 for i in range(1, numTests+1):
     [r, c, m] = map(lambda x: int(x), lines[i].split())
 
     openCells = r*c - m
 
     works = False
     matrix = [['*']*c for j in range(r)]
     # Try case analysis first, see if my knowledge of minesweeper can cover everything
     # This is getting painful :(
     if r >= 3 and c >= 3:
         order = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2),
                  (2,0), (2,1)]
         if openCells == 1 or openCells == 4 or openCells == 6:
             works = True
             for (x,y) in order[:openCells]:
                 matrix[x][y] = '.'
             matrix[0][0] = 'c'
             
         elif openCells >= 8:
             works = True
             filledRows = openCells / c
             if filledRows >= 2:
                 if filledRows == r:
                     matrix = [['.']*c for j in range(r)]
                     matrix[0][0] = 'c'
                 else:
                     remainder = openCells%c
                     if not remainder == 1:
                         for j in range(filledRows):
                             matrix[j] = ['.']*c
                         matrix[filledRows] = ['.']*remainder + ['*'] * (c-remainder)
                     elif filledRows > 2:
                         for j in range(filledRows-1):
                             matrix[j] = ['.']*c
                         matrix[filledRows-1] = ['.']*(c-1) + ['*']
                         matrix[filledRows] = ['.', '.'] + ['*']*(c-2)
                     else:
                         matrix[0] = ['.']*(c-1) + ['*']                        
                         matrix[1] = ['.']*(c-1) + ['*']
                         matrix[2] = ['.', '.', '.'] + ['*']*(c-3)
                     matrix[0][0] = 'c'
                 
             else:
                 for (x,y) in order:
                     matrix[x][y] = '.'
                 remainingOpen = openCells - 8
                 if remainingOpen % 2 == 0:
                     for j in range(remainingOpen/2):
                         matrix[0][j+3] = '.'
                         matrix[1][j+3] = '.'
                 else:
                     matrix[2][2] = '.'
                     remainingOpen -= 1
                     for j in range(remainingOpen/2):
                         matrix[0][j+3] = '.'
                         matrix[1][j+3] = '.'
                 matrix[0][0] = 'c'
 
     elif r == 1:
         works = True
         matrix[0] = ['.']*(c-m) + ['*']*m
         matrix[0][0] = 'c'
     elif c == 1:
         works = True
         for j in range(r-m):
             matrix[j][0] = '.'
         matrix[0][0] = 'c'
 
     #Only cases left are one or both dimensions being two
     elif r == 2 and c == 2:
         if m == 3:
             works = True
             matrix[0][0] = 'c'
         elif m == 0:
             works = True
             matrix = [['c', '.'], ['.', '.']]
     elif r == 2:
         if m % 2 == 0 and r*c-m > 2:
             works = True
             matrix[0] = ['.']*(c-m/2) + ['*']*(m/2)
             matrix[1] = ['.']*(c-m/2) + ['*']*(m/2)
             matrix[0][0] = 'c'
         elif r*c-m == 1:
             works = True
             matrix[0][0] = 'c'
     elif c == 2:
         if m % 2 == 0 and r*c-m > 2:
             works = True
             for j in range((r*c-m)/2):
                 matrix[j] = ['.', '.']
             matrix[0][0] = 'c'
         elif r*c-m == 1:
             works = True
             matrix[0][0] = 'c'
     
 
     outputFile.write('Case #'+str(i)+':\n')
     '''if len(matrix) != r:
         print i, matrix
     count = 0
     for j in range(len(matrix)):
         for k in range(len(matrix[j])):
             if matrix[j][k] == '*':
                 count += 1
     if count != m:
         print i, matrix'''
     if not works:
         outputFile.write('Impossible\n')
     else:
         for x in range(len(matrix)):
             for y in range(len(matrix[0])):
                 outputFile.write(matrix[x][y])
             outputFile.write('\n')
 outputFile.close()
             
",45,46,1365
"# Making up a dictionary
 # Sample
 googlerese = ""ejp mysljylc kd kxveddknmc re jsicpdrysi rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd de kr kd eoya kw aej tysr re ujdr lkgc jv""
 english = ""our language is impossible to understand there are twenty six factorial possibilities so it is okay if you want to just give up""
 # Hints
 d = {""y"":""a"", ""e"":""o"", ""q"":""z""}
 
 for i in xrange(len(googlerese)):
 	d[googlerese[i]] = english[i]
 
 # One letter still missing: z:q
 d[""z""] = ""q""
 
 inp = file(""input.in"")
 n = eval(inp.readline())
 out = file(""output.txt"", ""w"")
 
 for i in xrange(n):
 	G = inp.readline().strip()
 	S = """"
 	for letter in G:
 		S += d[letter]
 	out.write(""Case #%d: "" %(i + 1) + S + ""\n"")
",46,47,299
"'''
 ...
 ...
 ...
 ...
 ...
 '''
 
 for i in range(int(input())):
 
     r, c, m = tuple(map(int, str.split(input())))
     count = r * c - m
     field = dict(map(lambda c: (c, ""*""), itertools.product(range(c), range(r))))
     answer = ""Impossible""
 
     if m == 0:
 
         answer = field
 
     elif 1 in (r, c):
 
         for p in itertools.islice(itertools.product(range(c), range(r)), count):
 
             field[p] = "".""
 
         answer = field
 
     elif count in (0, 2, 3, 5, 7):
 
         pass
 
     elif count == 1:
 
         answer = field
 
     elif count // 2 < c or count == c * 2 + 1:
 
         if count % 2 != 0:
 
             tail = 3
             ncount = count - 3
 
         else:
 
             tail = 0
             ncount = count
 
         for x in range(ncount // 2):
 
             field[(x, 0)] = field[(x, 1)] = "".""
 
         for x in range(tail):
 
             field[(x, 2)] = "".""
 
         answer = field
 
     elif not (c == 2 and count % c == 1):
 
         for x in range(c):
 
             field[(x, 0)] = field[(x, 1)] = "".""
 
         count -= 2 * c
         tail = 0
         if count % c == 1:
 
             tail = 2
             count -= 1
 
         y = 2
         while count > 0:
 
             rx = min(count, c)
             for x in range(rx):
 
                 field[(x, y)] = "".""
 
             count -= rx
             y += 1
 
         for x in range(tail):
 
             field[(x, y)] = "".""
 
         answer = field
 
     field[(0, 0)] = ""c""
     print(str.format(""Case #{}:"", i + 1))
     if isinstance(answer, dict):
 
         for y in range(r):
 
             print(str.join("""", map(lambda x: field[(x, y)], range(c))))
 
     else:
 
         print(answer)
",47,48,639
"'''
 Created on 13 Apr 2013
 
 @author: mengda
 '''
 board = []
 
 def whoIsWinner(num):
     if num == 4000 or num == 3010:
         return 'X'
     if num == 400 or num == 310:
         return 'O'
     return False
 
 def process(board):
     full = True
     newboard = []
     for i in range(4):
         line = []
         for j in range(4):
             c = board[i][j]
             if   c == 'X':
                 line.append(1000)
             elif c == 'O':
                 line.append(100)
             elif c == 'T':
                 line.append(10)
             elif c == '.':
                 line.append(1)
                 full = False
         newboard.append(line)
     board = newboard
     for i in range(4):
         sumH = 0
         sumV = 0
         for j in range(4):
             sumH += board[i][j]
             sumV += board[j][i]
         winner = whoIsWinner(sumH)
         if winner:
             return winner + ' won'
         winner = whoIsWinner(sumV)
         if winner:
             return winner + ' won'
     sumD0 = board[0][0] + board[1][1] + board[2][2] + board[3][3]
     winner = whoIsWinner(sumD0)
     if winner:
         return winner + ' won'
     sumD1 = board[3][0] + board[2][1] + board[1][2] + board[0][3]
     winner = whoIsWinner(sumD1)
     if winner:
         return winner + ' won'
     if full:
         return 'Draw'
     return 'Game has not completed'
 
 f = open('A-small-attempt0.in', 'r')
 N = int(f.readline())
 outLine = []
 
 for i in range(1, N + 1):
     board = []
     for j in range(4):
         board.append(f.readline())
     outLine.append('Case #%d: %s\n' % (i, process(board)))
     f.readline()
     print outLine[-1],
 
 f.close()
 outFile = open('1.out', 'w')
 outFile.writelines(outLine)
 outFile.close()
",48,49,629
"#!/usr/bin/env python
 
 
 _inp = (
     'ejp mysljylc kd kxveddknmc re jsicpdrysi',
     'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',
     'de kr kd eoya kw aej tysr re ujdr lkgc jv',
 )
 
 _out = (
     'our language is impossible to understand',
     'there are twenty six factorial possibilities',
     'so it is okay if you want to just give up',
 )
 
 def compute_lang_map(inp, out):
     lang_map = {}
     for gs, ss in zip(inp, out):
         for gl, sl in zip(gs, ss):
             lang_map[gl] = sl
     lang_map['q'] = 'z'
     lang_map['z'] = 'q'
     return lang_map
 
 _lang_map = compute_lang_map(_inp, _out)
 def conv(s):
     out = ''
     for l in s:
         out += _lang_map[l]
     return out
 
 def main():
     with open('input-file', 'r') as f:
         f.readline()            # skip T
         n = 0
         for line in f:
             n += 1
             print 'Case #%d: %s' % (n, conv(line.strip()))
 
 if __name__ == '__main__':
     main()
",49,50,376
"#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013
 #for the Google Code Jam programming contest
 
 ###############################################################################
 # Imports go here
 ###############################################################################
 
 ###############################################################################
 # Global variables (for caching, etc.) go here
 ###############################################################################
 
 #Set up the input/output files: problem-tagsuffix.in / *.out
 problem = ""B""
 tag = ""small"" #commonly sample, small, or large
 #tag = ""large""
 #tag = ""sample""
 suffix = ""-attempt0"" #used sometimes for indexing later input files
 #suffix = """"
 
 ###############################################################################
 # Helper functions go here
 ###############################################################################
 
 
 def read_input(infile):
     """"""This function should take an open input file, load in all of the
     relevant information for a single case of the problem, and output it
     as a single object.    
     """"""
     #Some utility functions to read in particular types of input
     def read_int():
         return int(infile.readline().strip())
     def read_ints():
         return np.array(infile.readline().split(), dtype=int)
     def read_float():
         return float(infile.readline().strip())
     def read_floats():
         return np.array(infile.readline().split(), dtype=float)
     def read_string():
         return infile.readline().strip()
     def read_strings():
         return np.array(infile.readline().split(), dtype=object) #change the dtype?
     
     N, M = read_ints()
     
     lawn = np.empty((N, M), dtype=int)
     for i in range(N):
         row = read_ints()
         assert len(row) == M
         lawn[i,:] = row
     
     return lawn
 
 def solve_case(case):
     """"""Take the input data (structured in case) and perform any necessary
     calculations to obtain the desired output, formatted as the appropriate
     string.    
     """"""
     
     lawn = case
     undefined = np.zeros(lawn.shape, dtype=bool)
     
     colvals, rowvals = np.meshgrid(range(lawn.shape[1]), range(lawn.shape[0]))
     
     while not undefined.all():
         #Find the lowest still-defined point in the lawn
         valid = undefined == False
         minval = lawn[valid].min()
     
         minindex = np.where(lawn[valid] == minval)[0][0]
         minrow = rowvals[valid][minindex]
         mincol = colvals[valid][minindex]
         #Check to see if this point's row could have been mowed
         if (lawn[minrow,:][valid[minrow,:]] == minval).all():
             #Undefine this row
             undefined[minrow,:] = True
             continue
         
         #Otherwise, check to see if this point's column could have been mowed
         if (lawn[:,mincol][valid[:,mincol]] == minval).all():
             #Undefine this column
             undefined[:,mincol] = True
             continue
         
         #Otherwise, it's invalid!
         return ""NO""
     
     return ""YES""
 
 ###############################################################################
 # Main execution path
 ###############################################################################
 
 if __name__ == ""__main__"":
     #Open up the input & output files
     infile = open(""%s-%s%s.in"" % (problem, tag, suffix), 'r')
     outfile = open(""%s-%s%s.out"" % (problem, tag, suffix), 'w')
     
     #Read in the number of cases (the first input line) to iterate through
     cases = int(infile.readline().strip('\n'))
     for i in range(cases):
         
         #Read in the input data for this case
         case = read_input(infile)
         
         #Solve the problem for this case
         output = solve_case(case)
         
         #Write out the output of this case
         outfile.write('Case #%i: %s\n' % (i+1, output))
         print 'Case #%i: %s\n' % (i+1, output)
     
     #Close files
     infile.close()
     outfile.close()",50,51,1110
"():
 	a = int(sys.stdin.readline().strip())
 	for j in range(a - 1):
 		sys.stdin.readline()
 	read_set = set(sys.stdin.readline().strip().split("" ""))
 	for j in range(5 - a - 1):
 		sys.stdin.readline()
 		
 	return read_set
 
 
 t = int(sys.stdin.readline().strip())
 
 for i in range(t):
 	print ""Case #"" + str(i + 1) + "":"",
 
 	set1 = read_row()
 	set2 = read_row()
 	
 	intersect = set1.intersection(set2)
 	
 	if 1 == len(intersect):
 		print intersect.pop()
 	elif 0 == len(intersect):
 		print ""Volunteer cheated!""
 	else:
 		print ""Bad magician!""
",51,52,257
"== ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in range(t):
 
         R, C, M = [int(x) for x in f.readline().split()]
         free_spots = R * C - M - 1
 
         if M == 0:
             answer = [[""."" for x in range(C)] for y in range(R)]
             answer[0][0] = ""c""
         elif R == 1:
             answer = [[""c""] + [""."" for x in range(free_spots)] + [""*"" for m in range(M)]]
         elif C == 1:
             answer = [[""c""] + [""."" for x in range(free_spots)] + [""*"" for m in range(M)]]
             answer = zip(*answer[::-1])
         elif free_spots >= 3: # and M % R >= 2:
             answer = [[""*"" for x in range(C)] for y in range(R)]
             answer[0][0] = ""c""
             answer[0][1] = "".""
             answer[1][1] = "".""
             answer[1][0] = "".""
             free_spots -= 3
             tr, br, c = 0, 1, 2
             if c >= C:
                 tr, br, c = 2, 3, 0
             for _i in range(free_spots):
                 #pprint.pprint(answer)
                 if answer[tr][c] == ""*"":
                     answer[tr][c] = "".""
                 elif answer[br][c] == ""*"":
                     answer[br][c] = "".""
                     if c < C-1:
                         c+=1
                     else:
                         tr, br = tr + 2, br + 2
                         c = 0
                         if br == R:
                             br, tr = br-1, tr-1
                 
         else:
             answer = [""Impossible"",]
 
         
         
         print (""Case #"" + str(_t+1) + "":"")
         for _i in answer:
             print """".join(_i)
     
 
",52,53,586
"# !/usr/bin/python
 #solve case function
 def solve_case(naomi_blocks, ken_blocks, case_number):
     naomi_blocks_for_deceitful = naomi_blocks[:]
     ken_blocks_for_deceitful = ken_blocks[:]
     deceitful_war_point = 0
     while len(naomi_blocks_for_deceitful) > 0:
         naomi_call = naomi_blocks_for_deceitful.pop(0)
         min_ken_call = ken_blocks_for_deceitful[0]
         if naomi_call < min_ken_call:
             naomi_call = ken_blocks_for_deceitful[-1] - 0.000001
         else:
             # Naomi may call the same kg many times but Ken should not realize it ;)
             # The important point is that she must call heavier than Ken's max.
             naomi_call = ken_blocks_for_deceitful[-1] + 0.000001
 
         ken_candidate = filter(lambda x: x > naomi_call, ken_blocks_for_deceitful)
         if len(ken_candidate) > 0:
             ken_call = ken_blocks_for_deceitful.pop(ken_blocks_for_deceitful.index(ken_candidate.pop(0)))
         else:
             ken_call = ken_blocks_for_deceitful.pop(0)
 
         if naomi_call > ken_call:
             deceitful_war_point += 1
 
     war_point = 0
     while len(naomi_blocks) > 0:
         naomi_call = naomi_blocks.pop(0)
         ken_candidate = filter(lambda x: x > naomi_call, ken_blocks)
         if len(ken_candidate) > 0:
             ken_call = ken_blocks.pop(ken_blocks.index(ken_candidate.pop(0)))
         else:
             ken_call = ken_blocks.pop(0)
 
         if naomi_call > ken_call:
             war_point += 1
 
     print ""Case #%d: %d %d"" % (case_number, deceitful_war_point, war_point)
 
 #main
 r_file = sys.stdin
 
 if len(sys.argv) > 1:
     r_file = open(sys.argv[1], 'r')
 
 total_cases = r_file.readline()
 for case_number in range(1, int(total_cases) + 1):
     r_file.readline()
     n_values = map(float, r_file.readline().split(' '))
     k_values = map(float, r_file.readline().split(' '))
     solve_case(sorted(n_values), sorted(k_values), case_number)
 
",53,54,782
"(sys.argv) == 1:
     sys.stdin = open(""C.in"")
 else:
     sys.stdin = open(sys.argv[1])
 
 def to_ints(s):
     return map(int, s.split())
 
 def get_ints():
     return to_ints(raw_input())
 
 sys.setrecursionlimit(4000)
 
 def fill(rows, cols, mines):
     seen = set()
     visited = set()
 
     # we are trying to carve through a mountain 
     # and leave 'mine' squares unseen
     def search(numbered, zeros, min_numbered):
         left = (rows * cols - mines) - len(numbered)
         #print left, numbered,  min_numbered, zeros
         if left == 0:
             raise StopIteration((numbered, zeros))
         if left < 0:
             return
         for n in xrange(min_numbered, len(numbered)):
             number = numbered[n]
             if number in zeros:
                 continue
             row, col = number
             neigh = []
             if row > 0:
                 if col > 0: neigh.append((row - 1, col - 1))
                 neigh.append((row - 1, col))
                 if col < cols - 1: neigh.append((row - 1, col + 1))
             if col > 0: neigh.append((row, col - 1))
             if col < cols - 1: neigh.append((row, col + 1))
             if row < rows - 1:
                 if col > 0: neigh.append((row + 1, col - 1))
                 neigh.append((row + 1, col))
                 if col < cols - 1: neigh.append((row + 1, col + 1))
             # BUG: we might try to walk to a diagonal, oh well
             neigh = list(set(neigh) - set(numbered))
             zeros.add(number)
             search(numbered + neigh, zeros, n + 1)
             zeros.remove(number)
 
     try:
         for row in xrange(rows):
             for col in xrange(cols):
                 search([(row, col)], set(), 0)
     except StopIteration, e:
         numbered, zeros = e.message
         board = {}
         for row, col in numbered + list(zeros):
             board[row, col] = '.'
         if zeros:
             board[zeros.pop()] = 'c'
         else: # case where first click is on a number
             board[0, 0] = 'c'
         out = ''
         for row in xrange(rows):
             for col in xrange(cols):
                 out += board.get((row, col), '*')
             out += '\n'
         return out.strip()
     return 'Impossible'
 
 n_cases = input()
 for case in xrange(1, n_cases + 1):
     rows, cols, mines = get_ints()
 
     result = fill(rows, cols, mines)
 
     print ""Case #%d:"" % case
     print result
",54,55,782
"= Test {
       cout     :: Double
     , bonus    :: Double
     , objectif :: Double
     } deriving Show
 
 newtype Solution = Solution { temps :: Double }
 
 instance Show Solution where
     show (Solution t) = show t
 
 main = do
     interact (unlines . map showCase . zip [1..] . map resoudre . goTest . tail . lines)
 
   where
     goTest [] = []
     goTest (l:ls) =
         let [c, f, x] = map read $ words l
         in Test c f x : goTest ls
 
     showCase :: (Int, Solution) -> String
     showCase (i, s) = printf ""Case #%d: %s"" i (show s)
 
 resoudre :: Test -> Solution
 resoudre Test {..} | premierAchat > sansAchat = Solution sansAchat
                    | otherwise                = go premierAchat 2
   where
     go t prod | tempsAvecAchat >= tempsSansAchat = Solution (t + tempsSansAchat)
               | otherwise                        =
                   go (t + delaiProchainAchat) prod'
       where
         prod' = prod + bonus
 
         tempsAvecAchat = objectif / prod'
         tempsSansAchat = (objectif - cout) / prod
 
         delaiProchainAchat = cout / prod'
 
     premierAchat = cout / 2
     sansAchat    = objectif / 2
",55,56,363
"def PlayDevious(list1, list2):
     Ret = 0;
     i = 0;
     j = 0;
     while (i < len(list1)):
         if list1[i] > list2[j]:
             j += 1;
         i += 1;
     return j;
 
 def PlayWar(list1, list2):
     j = 0;      Score = 0;
     for entry in list1:
         winner = False;
         while (not winner):
             if j != len(list2):
                 if list2[j] > entry:
                     winner = True;
                 j += 1;
             else:
                 Score += 1;
                 winner = True;
 
     return Score;
 
 def PlayWar2(list1, list2):
     L1 = [];        L2 = [];        Score = 0;
 
     for i in range(len(list1)):
         L1.append(list1[i]);        L2.append(list2[i]);
     L1.reverse();
 
     Score = 0;
     for play in L1:
         index =  0;
         for i in range(1, len(L2)):
             if L2[i] > play > L2[i-1]:
                 index = i;
 
         if play > L2[index]:
             Score += 1;
         L2.pop(index);
     return Score           
 
 
 T = int(raw_input());
 for q in range(T):
     N = int(raw_input());
     Nlist = map(float, raw_input().split());
     Klist = map(float, raw_input().split());
 
     Nlist.sort();
     Klist.sort();
     
     print ""Case #%d:"" % (q+1),
     print PlayDevious(Nlist, Klist), PlayWar(Nlist, Klist)#, PlayWar2(Nlist, Klist);
",56,57,491
"= input()
 for case in range( 1, numCases + 1 ):
   C, F, X = raw_input().split()
   C = float(C)
   F = float(F)
   X = float(X)
   time = 0.0
   rate = 2.0
   
   while ( True ):
     timeToFinish = X / rate
     timeToFarm   = C / rate
     farmPayoffTime = C / F
 
     if timeToFinish < ( timeToFarm + farmPayoffTime ):
       time += timeToFinish
       break
     else:
       time += timeToFarm
       rate += F
 
 
   output = '{0:0.15f}'.format( time )
 
   print 'Case #' + str( case ) + ': ' + str( output )
",57,58,210
"INPUT = 'C-small-attempt0.in'
 OUTPUT = 'C-small-attempt0.out'
 
 
 def solve(R, C, M):
     grid = [[0 for c in range(C)] for r in range(R)]
 
     def get_cell(cell_r, cell_c):
         if not(0 <= cell_r < R):
             return None
         if not(0 <= cell_c < C):
             return None
         return grid[cell_r][cell_c]
 
     def for_each_neighbour(cell_r, cell_c, func):
         ret = []
         coords = (
             (cell_r - 1, cell_c - 1), (cell_r - 1, cell_c), (cell_r - 1, cell_c + 1),
             (cell_r, cell_c - 1), (cell_r, cell_c + 1),
             (cell_r + 1, cell_c - 1), (cell_r + 1, cell_c), (cell_r + 1, cell_c + 1)
         )
         for nb in coords:
             if get_cell(nb[0], nb[1]) is not None:
                 ret.append(func(nb[0], nb[1]))
         return ret
 
     def mark_dirty(cell_r, cell_c):
         if grid[cell_r][cell_c] != '*':
             grid[cell_r][cell_c] += 1
     
     def unmark_dirty(cell_r, cell_c):
         if grid[cell_r][cell_c] != '*':
             grid[cell_r][cell_c] -= 1
 
     def check_empty_neighbours(cell_r, cell_c):
         return (0 in for_each_neighbour(cell_r, cell_c, lambda r, c: get_cell(r, c)))
 
     def click():
         for i, row in enumerate(grid):
             for j, cell in enumerate(row):
                 if cell != '*':
                     if cell == 0 or ((R * C - M) == 1):
                         grid[i][j] = 'c'
                         return
 
     def place_mine():
         for i, row in enumerate(grid):
             for j, cell in enumerate(row):
                 if cell == '*':
                     continue
                 prevstate = grid[i][j]
                 grid[i][j] = '*'
                 for_each_neighbour(i, j, mark_dirty)
                 if not (True in for_each_neighbour(i, j, check_empty_neighbours)):
                     grid[i][j] = prevstate
                     for_each_neighbour(i, j, unmark_dirty)
                 else:
                     return True
         return False
 
     for m in range(M):
         if not place_mine():
             return 'Impossible\n'
 
     click()
 
     ret = ''
     for row in grid:
         ret = ret + ''.join(map(lambda c: '.' if isinstance(c, int) else c, row)) + '\n'
 
     return ret
 
 
 if __name__ == '__main__':
     inp = open(INPUT)
     out = open(OUTPUT, 'w')
     
     T = int(inp.readline())
 
     for case in range(T):
         sol = solve(*map(int, inp.readline().split()))
         out.write('Case #%i:\n%s' % (case + 1, sol))",58,59,911
"def solve_case(t):
     interested_row = int(raw_input().strip())
     i = 1
     while i <= 4:
         row = raw_input()
         if i == interested_row:
             first_set = set(row.strip().split())
         i += 1
     interested_row = int(raw_input().strip())
     i = 1
     while i <= 4:
         row = raw_input()
         if i == interested_row:
             second_set = set(row.strip().split())
         i += 1
     ans_set = first_set & second_set
     if len(ans_set) == 1:
         print 'Case #%d: %s' % (t, ans_set.pop(),)
     elif len(ans_set) > 1:
         print 'Case #%d: Bad magician!' % (t,)
     else:
         print 'Case #%d: Volunteer cheated!' % (t,)
 
 def main():
     t = int(raw_input().strip())
     for i in range(1, t + 1):
         solve_case(i)
 
 if __name__ == '__main__':
     main()
",59,60,299
"#
 # Google Code Jam 2014
 # Roaund 0: B. Cookie Clicker Alpha
 # submission by EnTerr
 #
 
 '''
 Input
 The first line of the input gives the number of test cases, T. T lines follow. 
 Each line contains three space-separated real-valued numbers: C, F and X.
 
 Output
 For each test case, output one line containing ""Case #x: y"", where x is 
 the test case number (starting from 1) and y is the minimum number of seconds 
 it takes before you can have X delicious cookies.
 
 We recommend outputting y to 7 decimal places, but it is not required. 
 y will be considered correct if it is close enough to the correct number: 
 within an absolute or relative error of 10^-6. 
 
 Limits
 1 <= T <= 100.
 
 Small dataset
 1 <= C <= 500.
 1 <= F <= 4.
 1 <= X <= 2000.
 
 Large dataset
 1 <= C <= 10000.
 1 <= F <= 100.
 1 <= X <= 100000.
 
 
 ---Input  
 4
 30.0 1.0 2.0
 30.0 2.0 100.0
 30.50000 3.14159 1999.19990
 500.0 4.0 2000.0
 
 ---Output 
 Case #1: 1.0000000
 Case #2: 39.1666667
 Case #3: 63.9680013
 Case #4: 526.1904762
 
 '''
 
 
 
 = open(sys.argv[1])
 def input(): return f.readline().strip();
 
 def bestTime(C, F, X):
     #C= cost of cookie farm, ck
     #F= farm production, ck/sec
     #X= goal, ck
     v = 2   #speed of production, cookies/sec
     t = 0   #total time of production, sec
     while True:
         tX = X / v          #time to reach goal at current speed
         tC = C / v          #time to buy farm
         tXc = X / (v + F)   #time to reach goal after adding farm
         if tX <= tC + tXc:
             #no more farms
             break
         #we are buying farm
         t += tC
         v += F
     #finishing at current speed
     t += tX
     return t
 
 #clk = clock()
 
 for caseNo in xrange(1, int(input())+1):
     C, F, X = map(float, input().split())
     #print >>sys.stderr, caseNo
     print 'Case #%d: %.7f' % (caseNo, bestTime(C, F, X))
     
 #print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )
 
 
",60,61,788
"():
     return int(sys.stdin.readline())
 
 def readfloatarray():
     return map(float, sys.stdin.readline().strip().split())
 
 def readintarray():
     return map(int, sys.stdin.readline().strip().split())
 
 def readpairs(start=0):
     elems = readintarray()[start:]
     return [elems[i:i+2] for i in xrange(0, len(elems), 2)]
 
 def readstring():
     return sys.stdin.readline()[:-1]
 
",61,62,147
"fin = open('A-small-attempt0.in', 'r')
 fout = open('A-output.txt', 'w')
 
 translation = {'y': 'a', 'e': 'o', 'q': 'z'}
 
 knownresults = {
     'ejp mysljylc kd kxveddknmc re jsicpdrysi': 'our language is impossible to understand',
     'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd': 'there are twenty six factorial possibilities',
     'de kr kd eoya kw aej tysr re ujdr lkgc jv': 'so it is okay if you want to just give up'
     }
 
 for key in knownresults :
     for letter in range(len(key)) :
         translation[key[letter]] = knownresults[key][letter]
 
 missingkey = [i for i in translation.values() if i not in translation.keys()][0]
 missingvalue = [i for i in translation.keys() if i not in translation.values()][0]
 
 translation[missingkey] = missingvalue
 
 cases = int(fin.readline()[:-1])
 
 for case in range(cases) :
     line = fin.readline()[:-1]
     res = [translation[line[i]] for i in range(len(line))]
     res = ''.join(res)
     fout.write('Case #' + str(case+1) + ': ' + res + '\n')
     
 fin.close()
 fout.close()
",62,63,383
"(f):
     return next(f).strip()
 
 def read_int(f, b=10):
     return int(read_word(f), b)
 
 def read_letters(f):
     return list(read_word(f))
 
 def read_digits(f, b=10):
     return [int(x, b) for x in read_letters(f)]
 
 def read_words(f, d=' '):
     return read_word(f).split(d)
 
 def read_ints(f, b=10, d=' '):
     return [int(x, b) for x in read_words(f, d)]
 
 def read_floats(f, d=' '):
     return [float(x) for x in read_words(f, d)]
 
 def read_arr(f, R, reader=read_ints, *args, **kwargs):
     return [reader(f, *args, **kwargs) for i in range(R)]
 
 def solve(solver, fn, out_fn=None):
     in_fn = fn + '.in'
     if out_fn is None:
         out_fn = fn + '.out'
     with open(in_fn, 'r') as fi:
         with open(out_fn, 'w') as fo:
             T = read_int(fi)
             for i in range(T):
                 case = read_case(fi)
                 res = solver(case)
                 write_case(fo, i, res)
 
 ################################################################################
 
 def read_case(f):
     N = read_int(f)
     MN = read_floats(f)
     MK = read_floats(f)
     return (N, MN, MK)
 
 def write_case(f, i, res):
     f.write('Case #%d: '%i)
     f.write('%d %d'%res)
     f.write('\n')
 
 ################################################################################
 
 def solve_small(case):
     (N, MN, MK) = case
     MN = sorted(MN)
     MK = sorted(MK)
     y = 0
     i = 0
     for j in range(N):
         while i < N and MN[i] < MK[j]:
             i += 1
         if i < N:
             y += 1
             i += 1
     z = N
     j = 0
     for i in range(N):
         while j < N and MN[i] > MK[j]:
             j += 1
         if j < N:
             z -= 1
             j += 1
     return (y, z)
 
 def solve_large(case):
     return solve_small(case)
 
 DEBUG = 'i'
 
 from run import *
",63,64,716
"directory = 'C:/users/hai/my projects/google code jam/2013/qualification/C/'
 
 
 def is_palindrome (n):
     l = list(str(n))
     return list(reversed(l)) == l
 
 def prepare ():
     global fair_and_squares
     fair_and_squares = []
     
     for i in range(1,10**7):
         if is_palindrome(i):
             sqr = i**2
             if is_palindrome(sqr):
                 fair_and_squares.append(sqr)
     return
 
         
 def solve (f_in, f_out):
     prepare()
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         A,B = [int(x) for x in f_in.readline().split()]
         count = len([x for x in fair_and_squares if (x>=A and x<=B)])
         f_out.write('Case #' + str(testcase) + ': ' + str(count) + '\n')
 
 
 
 def main_run():
     = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
",64,65,522
"'''
 Created on Apr 14, 2012
 
 @author: moatasem
 '''
 lan={'z':'q','q':'z',' ':' '}
 
 s1=list(""ejp mysljylc kd kxveddknmc re jsicpdrysi"")
 e1=list (""our language is impossible to understand"")
 s2=list(""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"")
 e2=list (""there are twenty six factorial possibilities"")
 s3=list(""de kr kd eoya kw aej tysr re ujdr lkgc jv"")
 e3=list (""so it is okay if you want to just give up"")
 for i in xrange(len(s1)):
     if(lan.get(s1[i])==None and s1[i]!="" ""):
         lan[s1[i]]=e1[i]
     if(lan.get(s2[i])==None and s2[i]!="" ""):
         lan[s2[i]]=e2[i]
     if(lan.get(s3[i])==None and s3[i]!="" ""):
         lan[s3[i]]=e3[i]
         
 f = open(""A-small-attempt0.in"", ""r"")
 n=int(f.readline().strip())
 for i  in xrange(n):
     line=f.readline().strip()
     res='Case #'+str((i+1))+"": ""
     for j in xrange(len(line)):
         res+=str(lan.get(line[j]))
     print res
         
     
 
",65,66,416
"""""""
 Google Code Jam 2014 Qualification Problem A
 Usage:
     python a.py < input.txt > output.txt
 """"""
 (first, first_rows, second, second_rows):
     intersection = set(first_rows[first - 1]) & set(second_rows[second - 1])
 
     if not intersection:
         return ""Volunteer cheated!""
     elif len(intersection) > 1:
         return ""Bad magician!""
     else:
         return intersection.pop()
 
 
 
 if __name__ == ""__main__"":
     num_of_cases = int(sys.stdin.readline().strip())
 
     for i in xrange(1, num_of_cases + 1):
         first_answer = int(sys.stdin.readline().strip())
         first_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]
 
         second_answer = int(sys.stdin.readline().strip())
         second_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]
 
         print ""Case #{0}: {1}"".format(i, solve_problem(first_answer, first_arrangement, second_answer, second_arrangement))
",0,67,329
"#!/usr/bin/env python
 (lawn, size_x, size_y):
     for i in xrange(size_x):
         for k in xrange(size_y):
             elem = lawn[i][k]
             if max(lawn[i]) > elem and max([lawn[j][k] for j in xrange(size_x)]) > elem:
                 return 'NO'
 
     return 'YES'
 
 def read_lawn(stdin, size_x, size_y):
     lawn = []
     for i in xrange(size_x):
         line = map(int, sys.stdin.readline().strip().split(' '))
         lawn.append(line)
     return lawn
 
 
 if __name__ == '__main__':
     num_of_cases = int(sys.stdin.readline())
     for i in xrange(1, num_of_cases + 1):
         size_x, size_y = map(int, sys.stdin.readline().strip().split(' '))
         lawn = read_lawn(sys.stdin, size_x, size_y)
         print 'Case #{0}: {1}'.format(i, solve_problem(lawn, size_x, size_y))
",0,68,314
"""""""
 Google Code Jam 2012 Problem C
 Usage:
     python problem_c.py < input.txt > output.txt
 """"""
 (n, m, _cache={}, _cache_sorted={}, _cache_length={}):
     if not n in _cache:
         _cache[n] = str(n)
 
     if not m in _cache:
         _cache[m] = str(m)
 
     str_n = _cache[n]
     str_m = _cache[m]
 
     if not n in _cache_sorted:
         _cache_sorted[n] = sorted(str_n)
 
     if not m in _cache_sorted:
         _cache_sorted[m] = sorted(str_m)
 
     if _cache_sorted[n] != _cache_sorted[m]:
         return False
 
     if not n in _cache_length:
         _cache_length[n] = len(str_n)
 
     for i in xrange(_cache_length[n] + 1):
         if str_m == str_n[i:] + str_n[:i]:
             return True
 
     return False
 
 
 def solve_problem():
     number_of_cases = int(sys.stdin.readline())
 
     for i in xrange(1, number_of_cases + 1):
         case = sys.stdin.readline().strip()
         A, B = map(int, case.split())
         result = sum(itertools.imap(lambda (n, m): is_recycled(n, m),
                                     itertools.combinations(xrange(A, B + 1), 2)))
 
         sys.stdout.write('Case #{0}: {1}\n'.format(i, result))
 
 if __name__ == '__main__':
     solve_problem()
",0,69,460
"""""""
 Google Code Jam 2012 Problem B
 Usage:
     python problem_b.py < input.txt > output.txt
 """"""
 (n):
     combinations = itertools.combinations_with_replacement(range(n), 3)  # 3 scores
     return itertools.ifilter(lambda (x, y, z): x + y + z == n, combinations)
 
 
 def calc_surprising(n):
     results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) == 2, calc_possible(n)))
     return results[0] if results else None
 
 
 def calc_normal(n):
     results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) <= 1, calc_possible(n)))
     return results[0] if results else None
 
 
 def solve_problem():
     number_of_cases = int(sys.stdin.readline())
 
     for i in xrange(1, number_of_cases + 1):
 
         case = sys.stdin.readline().strip()
         result = 0
         num_of_googlers, num_of_surprising, desired_score, scores = case.split(' ', 3)
         num_of_googlers = int(num_of_googlers)
         num_of_surprising = int(num_of_surprising)
         desired_score = int(desired_score)
         scores = map(int, scores.split())
 
         possible_scores = []
 
         for k in xrange(num_of_googlers):
 
             normal = calc_normal(scores[k])
             surprising = calc_surprising(scores[k])
 
             possible_scores.append(((normal if normal else (0, 0, 0), 0), (surprising if surprising else (0, 0, 0), 1)))
 
         possible = list(itertools.ifilter(lambda scores: sum(map(lambda x: x[1], scores)) == num_of_surprising, itertools.product(*possible_scores)))
         result = max(map(lambda scores: sum(map(lambda x: int(max(x[0]) >= desired_score), scores)) if scores else 0, possible))
 
         sys.stdout.write('Case #{0}: {1}\n'.format(i, result))
 
 
 if __name__ == '__main__':
     solve_problem()
",0,70,627
"""""""
 Google Code Jam 2014 Qualification Problem D
 Usage:
     python d.py < input.txt > output.txt
 """"""
 (func):
     cache = {}
     def wrapped(*args):
         if not args in cache:
             cache[args] = func(*args)
         return cache[args]
     return wrapped
 
 
 @memoized
 def play_dwar(naomi_blocks, ken_blocks):
     if not naomi_blocks:
         return 0
 
     max_score = 0
 
     for naomi_choice in naomi_blocks:
         naomi_remaining = tuple(b for b in naomi_blocks if b != naomi_choice)
 
         ken_better = tuple(b for b in ken_blocks if b > naomi_choice)
         ken_worse = tuple(b for b in ken_blocks if b < naomi_choice)
 
         if ken_better and not ken_worse:
             ken_choice = max(ken_better)
             ken_remaining = tuple(b for b in ken_blocks if b != ken_choice)
             score = 0 + play_dwar(naomi_remaining, ken_remaining)
         else:
             ken_remaining = tuple(b for b in ken_blocks if b != min(ken_blocks))
             score = 1 + play_dwar(naomi_remaining, ken_remaining)
 
         max_score = max(max_score, score)
 
     return max_score
 
 
 @memoized
 def play_war(naomi_blocks, ken_blocks):
     if not naomi_blocks:
         return 0
 
     max_score = 0
 
     for naomi_choice in naomi_blocks:
         naomi_remaining = tuple(b for b in naomi_blocks if b != naomi_choice)
 
         ken_better = tuple(b for b in ken_blocks if b > naomi_choice)
 
         if ken_better:
             ken_choice = min(ken_better)
             ken_remaining = tuple(b for b in ken_blocks if b != ken_choice)
             score = 0 + play_war(naomi_remaining, ken_remaining)
         else:
             ken_remaining = tuple(b for b in ken_blocks if b != min(ken_blocks))
             score = 1 + play_war(naomi_remaining, ken_remaining)
 
         max_score = max(max_score, score)
 
     return max_score
 
 
 def solve_problem(naomi_blocks, ken_blocks):
     return play_dwar(naomi_blocks, ken_blocks), play_war(naomi_blocks, ken_blocks)
 
 
 if __name__ == ""__main__"":
     num_of_cases = int(sys.stdin.readline().strip())
     for i in xrange(1, num_of_cases + 1):
 
         num_of_blocks = int(sys.stdin.readline().strip())
 
         naomi_blocks = tuple(map(float, sys.stdin.readline().strip().split()))
         ken_blocks = tuple(map(float, sys.stdin.readline().strip().split()))
 
         print ""Case #{0}: {1} {2}"".format(i, *solve_problem(naomi_blocks, ken_blocks))
",0,71,904
"#!/usr/bin/env python
 (a):
     return str(a) == ''.join(reversed(str(a)))
 
 
 def solve_problem(min_num, max_num):
     count = 0
     for i in xrange(min_num, max_num + 1):
         if is_palindrome(i):
             sqrt = math.sqrt(i)
             if int(sqrt) == sqrt and is_palindrome(int(sqrt)):
                 count += 1
     return count
 
 
 if __name__ == '__main__':
     num_of_cases = int(sys.stdin.readline())
     for i in xrange(1, num_of_cases + 1):
         min_num, max_num = map(int, sys.stdin.readline().strip().split(' '))
         print 'Case #{0}: {1}'.format(i, solve_problem(min_num, max_num))
",0,72,236
"""""""
 Google Code Jam 2012 Problem A
 Usage:
     python problem_a.py < input.txt > output.txt
 """"""
 = {
     'ejp mysljylc kd kxveddknmc re jsicpdrysi': 'our language is impossible to understand',
     'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd': 'there are twenty six factorial possibilities',
     'de kr kd eoya kw aej tysr re ujdr lkgc jv': 'so it is okay if you want to just give up',
 }
 
 mapping = {'q': 'z', 'z': 'q'}
 
 for k, v in hints.items():
     for from_char, to_char in zip(k, v):
         mapping[from_char] = to_char
 
 def solve_problem():
     number_of_cases = int(sys.stdin.readline())
     for i in xrange(1, number_of_cases + 1):
         case = sys.stdin.readline().strip()
         translated = ''.join(map(lambda c: mapping.get(c, c), case))
         sys.stdout.write('Case #{0}: {1}\n'.format(i, translated))
 
 if __name__ == '__main__':
     solve_problem()
",0,73,330
"""""""
 Google Code Jam 2014 Qualification Problem C
 Usage:
     python c.py < input.txt > output.txt
 """"""
 (x, y, cells):
     columns = len(cells[0])
     rows = len(cells)
 
     if y > 0:
         if x > 0:
             yield x - 1, y - 1
         yield x, y - 1
 
         if x + 1 < columns:
             yield x + 1, y - 1
 
     if x > 0:
         yield x - 1, y
 
     if x + 1 < columns:
         yield x + 1, y
 
     if y + 1 < rows:
         if x > 0:
             yield x - 1, y + 1
 
         yield x, y + 1
 
         if x + 1 < columns:
             yield x + 1, y + 1
 
 
 def try_to_click(x, y, cells, remaining):
     if remaining == 0:
         return cells
 
     recent = []
 
     opened = 0
 
     for n_x, n_y in iter_neighbors(x, y, cells):
         if cells[n_y][n_x] == ""?"":
             cells[n_y][n_x] = "".""
             opened += 1
             recent.append((n_x, n_y))
 
     if opened == remaining:
         return cells
 
     if opened > remaining:
         return []
 
     for n_x, n_y in recent:
         solution = try_to_click(n_x, n_y, copy.deepcopy(cells), remaining - opened)
         if solution:
             return solution
 
     return []
 
 
 def solve_problem(rows, columns, mines):
 
     for x in xrange(columns):
         for y in xrange(rows):
             cells = [[""?"" for i in xrange(columns)] for j in xrange(rows)]
             cells[y][x] = ""c""
             solution = try_to_click(x, y, cells, rows * columns - mines - 1)
 
             if solution:
                 return ""\n"".join(["""".join(row) for row in solution]).replace(""?"", ""*"")
 
     return ""Impossible""
 
 
 if __name__ == ""__main__"":
     num_of_cases = int(sys.stdin.readline().strip())
     for i in xrange(1, num_of_cases + 1):
 
         rows, columns, mines = map(int, sys.stdin.readline().strip().split())
 
         print ""Case #{0}:\n{1}"".format(i, solve_problem(rows, columns, mines))
",0,74,693
"""""""
 Google Code Jam 2014 Qualification Problem B
 Usage:
     python b.py < input.txt > output.txt
 """"""
 (farm_cost, farm_rate, target):
     rate = 2.0
     farms = 0.0
 
     while (farms + target / rate) > (farms + farm_cost / rate + target / (rate + farm_rate)):
         farms = farms + farm_cost / rate
         rate = rate + farm_rate
 
     return farms + target / rate
 
 
 if __name__ == ""__main__"":
     num_of_cases = int(sys.stdin.readline().strip())
     for i in xrange(1, num_of_cases + 1):
         farm_cost, farm_rate, target = map(float, sys.stdin.readline().strip().split())
         print ""Case #{0}: {1:9.7f}"".format(i, solve_problem(farm_cost, farm_rate, target))
",0,75,249
"# coding: cp932
 = file(sys.argv[1])
 out = file(sys.argv[2], 'w')
 
 caseCnt = int(f.readline())
 
 for case in range(1, caseCnt+1):
 	V, H = f.readline().split()
 	V = int(V); H = int(H)
 	
 	field = [map(int, list(f.readline().split())) for _ in range(V)]
 	#print field
 	
 	rowMax = [max(row) for row in field]
 	colMax = [max([row[i] for row in field]) for i in range(H)]
 	#print rowMax, colMax
 		
 	result = 'YES'
 	for row in range(V):
 		for col in range(H):
 			if field[row][col] < rowMax[row] and field[row][col] < colMax[col]:
 				result = 'NO'
 				break
 		else:
 			continue
 		break
 	print>>out, 'Case #%d:'%case, result
 
 out.close()
",1,76,303
"# coding: shift-jis
 
 #f = file(""test.in"")
 #w = sys.stdout
 f = file(""C-small-attempt0.in"")
 w = file(""answer.txt"", ""w"")
 cnt = int(f.readline()[:-1])
 (cnt):
 	A, B = map(int, f.readline()[:-1].split())
 	
 	count = 0
 	for n in range(A, B):
 		d = int(log(n, 10))+1
 		s = set()
 		for e in range(1, d):
 			c = 10**e
 			r = (n % c)*10**(d-e)
 			b = n / c
 			if r+b>n and r+b<=B and (n, r+b) not in s:
 				s.add((n, r+b))
 				count += 1
 				
 	print>>w, ""Case #%d:""%(no+1), count
 
 
",1,77,283
"# coding: cp932
 = file(sys.argv[1])
 out = file(sys.argv[2], 'w')
 
 caseCnt = int(f.readline())
 
 for case in range(1, caseCnt+1):
 	board = [
 		f.readline()[:4],
 		f.readline()[:4],
 		f.readline()[:4],
 		f.readline()[:4],
 	]
 	f.readline()
 	xwin = False
 	owin = False
 	rest = False
 	# 
 	for row in board:
 		if row.replace('T', 'X') == 'XXXX':
 			xwin = True
 		elif row.replace('T', 'O') == 'OOOO':
 			owin = True
 		if '.' in row: rest = True
 	# c
 	for i in range(4):
 		col = ''.join([row[i] for row in board])
 		if col.replace('T', 'X') == 'XXXX':
 			xwin = True
 		elif col.replace('T', 'O') == 'OOOO':
 			owin = True
 	# ÈÈ
 	up = ''.join([row[i] for i, row in enumerate(board)])
 	if up.replace('T', 'X') == 'XXXX':
 		xwin = True
 	elif up.replace('T', 'O') == 'OOOO':
 		owin = True
 	down = ''.join([row[3-i] for i, row in enumerate(board)])
 	if down.replace('T', 'X') == 'XXXX':
 		xwin = True
 	elif down.replace('T', 'O') == 'OOOO':
 		owin = True
 	
 	assert not (xwin==owin==True)
 	
 	if xwin:
 		result = 'X won'
 	elif owin:
 		result = 'O won'
 	elif rest:
 		result = 'Game has not completed'
 	else:
 		result = 'Draw'
 		
 	print>>out, 'Case #%d:'%case, result
 
 out.close()
",1,78,598
"# coding: shift-jis
 
 = file(""B-small-attempt0.in"")
 #f = file(""test.in"")
 #w = sys.stdout
 w = file(""answer.txt"", ""w"")
 cnt = int(f.readline()[:-1])
 for no in range(cnt):
 	l = f.readline()[:-1].split()
 	T, s, p = map(int, l[:3])
 	ts = map(int, l[3:])
 	ns = p*3-2 if p*3-2 > 0 else 0
 	ss = p*3-4 if p*3-4 > 0 else 31
 	l = filter(lambda x: x<ns, ts)
 	c = min([len(filter(lambda x: x>=ss, l)), s])
 	
 	print>>w, ""Case #%d:""%(no+1), T-len(l)+c
 
 
",1,79,239
"# coding: cp932
 
 
 lines = iter('''
 4
 1
 0.5
 0.6
 2
 0.7 0.2
 0.8 0.3
 3
 0.5 0.1 0.9
 0.6 0.4 0.3
 9
 0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899
 0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458
 '''.splitlines(False)[1:])
 = sys.stdout
 
 sys.setrecursionlimit(1500)
 
 lines = iter(open(r'D-small-attempt2.in').readlines(False))
 out = open('d-small.answer', 'w')
 
 #lines = iter(open(r'D-large.in').readlines(False))
 #out = open('d-large.answer', 'w')
 
 caseCnt = int(next(lines))
 
 def solve(N, K):
 	if N == [] and K == []:
 		return 0
 	if K[-1] > N[-1]:
 		return solve(N[:-1], K[1:])
 	else:
 		return solve(N[:-1], K[:-1])+1
 
 for case in range(1, caseCnt+1):
 	C = int(next(lines))
 	N = sorted(map(float, next(lines).split()), reverse=True)
 	K = sorted(map(float, next(lines).split()), reverse=True)
 	
 	# if C == 1:
 		# if N[0] > K[0]:
 			# print('Case #%d: 1 1'%case, file=out)
 		# else:
 			# print('Case #%d: 0 0'%case, file=out)
 		# continue
 	
 	W=0
 	k = 0
 	for i, n in enumerate(N):
 		if n < K[k]:
 			k += 1
 		else:
 			W += 1
 	
 	D = solve(N, K)
 	print('Case #%d: %d %d'%(case, D, W), file=out)
 	#;pdb.set_trace()
 	
",1,80,682
"# coding: cp932
 = file(sys.argv[1])
 out = file(sys.argv[2], 'w')
 
 caseCnt = int(f.readline())
 
 Num = [
 	0,
 	1,
 	4,
 	9,
 	121,
 	484,
 	10201,
 	12321,
 	14641,
 	40804,
 	44944,
 	1002001,
 	1234321,
 	4008004,
 	100020001,
 	102030201,
 	104060401,
 	121242121,
 	123454321,
 	125686521,
 	400080004,
 	404090404,
 	10000200001,
 	10221412201,
 	12102420121,
 	12345654321,
 	40000800004,
 	1000002000001,
 	1002003002001,
 	1004006004001,
 	1020304030201,
 	1022325232201,
 	1024348434201,
 	1210024200121,
 	1212225222121,
 	1214428244121,
 	1232346432321,
 	1234567654321,
 	4000008000004,
 	4004009004004,
 ]
 
 for case in range(1, caseCnt+1):
 	L, H = f.readline().split()
 	L = int(L); H = int(H)
 	assert L <= H
 	
 	for i in range(len(Num)):
 		if L <= Num[i]:
 			break
 	else:
 		print>>out, 'Case #%d:'%case, 0
 		continue
 
 	lb = i - 1
 
 	for i in range(1, len(Num)+1):
 		if H >= Num[len(Num)-i]:
 			break
 	else:
 		print>>out, 'Case #%d:'%case, 0
 		continue
 	ub = len(Num)-i
 		
 	print>>out, 'Case #%d:'%case, ub - lb
 
 out.close()
",1,81,798
"# coding: shift-jis
 
 a = ""abcdefghijklmnopqrstuvwxyz""
 d = {}
 for c in a:
 	d[c] = ""*""
 
 i = ""ejp mysljylc kd kxveddknmc re jsicpdrysi""
 o = ""our language is impossible to understand""
 for k, v in zip(i, o):
 	d[k] = v
 i = ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd""
 o = ""there are twenty six factorial possibilities""
 for k, v in zip(i, o):
 	d[k] = v
 i = ""de kr kd eoya kw aej tysr re ujdr lkgc jv""
 o = ""so it is okay if you want to just give up""
 for k, v in zip(i, o):
 	d[k] = v
 
 
 i = ""y qee""
 o = ""a zoo""
 for k, v in zip(i, o):
 	d[k] = v
 d['z'] = 'q'
 = file(""A-small-attempt1.in"")
 #w = sys.stdout
 w = file(""answer.txt"", ""w"")
 cnt = int(f.readline()[:-1])
 for no in range(cnt):
 	i = f.readline()[:-1]
 	o = """"
 	for k in i:
 		o += d[k]
 	print>>w, ""Case #%d:""%(no+1), o
 
 
",1,82,400
"# coding: cp932
 
 lines = iter('''
 13
 5 5 23
 3 1 1
 1 3 1
 2 2 1
 4 7 3
 10 10 82
 10 1 4
 1 10 5
 2 10 8
 10 2 8
 2 10 9
 10 2 7
 5 3 3
 '''.splitlines(False)[1:])
 = sys.stdout
 
 sys.setrecursionlimit(1500)
 
 
 class MyException(Exception):
 	pass
 lines = iter(open(r'C-small-attempt7.in').readlines(False))
 out = open('c-small.answer', 'w')
 
 #lines = iter(open(r'C-large.in').readlines(False))
 #out = open('c-large.answer', 'w')
 def solve(C, R, M):
 	board = [['.']*C for _ in range(R)]
 	board[-1][-1] = 'c'
 	try:
 		for r in range(R-2):
 			for c in range(C-2):
 				if r == R-3 and c == C-3:
 					raise StopIteration()
 				board[r][c] = '*'
 				M -= 1
 				if M == 0:
 					return board 
 	except StopIteration:
 		pass
 		
 	if M % 2 == 0:
 		for r in range(R-3):
 			board[r][C-1] = '*'
 			board[r][C-2] = '*'
 			M -= 2
 			if M == 0:
 				return board
 		for c in range(C-3):
 			board[R-1][c] = '*'
 			board[R-2][c] = '*'
 			M -= 2
 			if M == 0:
 				return board
 		
 		
 		raise MyException()
 	else:
 		board[R-3][C-3] = '*'
 		M -= 1
 		if M == 0:
 			return board
 		for r in range(R-2):
 			board[r][C-1] = '*'
 			board[r][C-2] = '*'
 			M -= 2
 			if M == 0:
 				return board
 		for c in range(C-2):
 			board[R-1][c] = '*'
 			board[R-2][c] = '*'
 			M -= 2
 			if M == 0:
 				return board
 		
 		raise MyException()
 		
 	
 caseCnt = int(next(lines))
 
 for case in range(1, caseCnt+1):
 	R,C,M = map(int, next(lines).split())
 	
 	print('Case #%d:'%case, file=out)
 	if M == 0:
 		print('c' + '.'*(C-1), file=out)
 		for _ in range(R-1):
 			print('.'*C, file=out)
 	elif R*C==M+1:
 		print('c' + '*'*(C-1), file=out)
 		for _ in range(R-1):
 			print('*'*C, file=out)
 	elif C == 1 and R == 1:
 		print('Impossible', file=out)
 	elif C == 1:
 		if M > R-1:
 			print('Impossible', file=out)
 		else:
 			print('c', file=out)
 			for _ in range(R-M-1):
 				print('.', file=out)
 			for _ in range(M):
 				print('*', file=out)
 	elif R == 1:
 		if M > C-1:
 			print('Impossible', file=out)
 		else:
 			print('c' + '.'*(C-M-1) + '*'*M, file=out)
 	elif C == 2:
 		if M %2 or M//2 > R-2:
 			print('Impossible', file=out)
 		else:
 			print('c.', file=out)
 			for _ in range(R-M//2-1):
 				print('..', file=out)
 			for _ in range(M//2):
 				print('**', file=out)
 	elif R == 2:
 		if M %2 or M//2 > C-2:
 			print('Impossible', file=out)
 		else:
 			print('c' + '.'*(C-M//2-1) + '*'*(M//2), file=out)
 			print(      '.'*(C-M//2)   + '*'*(M//2), file=out)
 	elif M > R*C-4:
 		print('Impossible', file=out)
 	else:
 		try:
 			board = solve(C, R, M)
 			for line in board:
 				print(''.join(line), file=out)
 		except MyException:
 			print('Impossible', file=out)
 	# if C == 1:
 		# if N[0] > K[0]:
 			# print('Case #%d: 1 1'%case, file=out)
 		# else:
 			# print('Case #%d: 0 0'%case, file=out)
 		# continue
 	
 	#;pdb.set_trace()
 	
",1,83,1636
"# coding: cp932
 
 
 lines = iter('''
 5
 30.0 1.0 2.0
 30.0 2.0 100.0
 30.50000 3.14159 1999.19990
 500.0 4.0 2000.0
 100.0 1.0 100000.0
 '''.splitlines(False)[1:])
 
 lines = iter(open(r'B-small-attempt0.in').readlines(False))
 
 caseCnt = int(next(lines))
 
 for case in range(1, caseCnt+1):
 	C, F, X = map(float, next(lines).split())
 	
 	v = 2.0
 	total = 0.0
 	goal = X/v
 	while 1:
 		farm = C/v + total
 		if farm >= goal:
 			answer = goal
 			break
 		v += F
 		total = farm
 		if goal > X/v + total:
 			goal = X/v + total	
 	print('Case #%d: %0.6lf'%(case, answer))
 	#;pdb.set_trace()
 	
 
",1,84,354
"""""""Usage:
     pypy X.py < X-size.in > X-size.out
 or sometimes
     python X.py < X-size.in > X-size.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, C=None, **ignore):
     N = int(infile.next())
     #P = int(infile.next())
     #P = map(int, infile.next().split())
     I = [map(int, infile.next().split()) for i in range(4)]
     T = int(infile.next())
     #T = infile.next().split()
     S = [map(int, infile.next().split()) for i in range(4)]
     return locals()
 
 def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #########= set(I[N-1]) & set(S[T-1])
     if len(res) == 1:
         res = res.pop()
     elif len(res) > 1:
         res = 'Bad magician!'
     else:
         res = 'Volunteer cheated!'
     return 'Case #%s: %s\n' % (testcase, res)
 
 if __name__ == '__main__':
     = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",2,85,405
"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, **ignore):
     #N = int(infile.next())
     P = map(int, infile.next().split())
     #I = map(int, infile.next().split())
     #T = infile.next().split()
     S = [map(int, infile.next().split()) for i in range(P[0])]
     return locals()
 
 def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     ########= np.array(S)
     done = np.zeros(P, dtype=int)
     for row in range(P[0]):
         m = S[row].max()
         done[row][S[row]==m] = 1
 
     for col in range(P[1]):
         m = S[:,col].max()
         done[:,col][S[:,col]==m] = 1
 
     res = 'YES' if done.sum() == P[0]*P[1] else 'NO'
     return 'Case #%s: %s\n' % (testcase, res)
 
 if __name__ == '__main__':
     = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",2,86,407
"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, **ignore):
     #N = int(infile.next())
     #P = map(int, infile.next().split())
     #I = map(int, infile.next().split())
     #T = infile.next().split()
     S = [infile.next().strip() for i in range(5)]
     return locals()
 
 def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     ########= False
     for line in S[:4]:
         not_win = set()
         if '.' in line:
             not_draw = True
             continue
         if 'O' in line:
             not_win.add('X')
         if 'X' in line:
             not_win.add('O')
         if len(not_win) == 1:
             return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')
 
     ST = []
     for j in range(4):
         ST.append(''.join(S[i][j] for i in range(4)))
     for line in ST:
         not_win = set()
         if '.' in line:
             continue
         if 'O' in line:
             not_win.add('X')
         if 'X' in line:
             not_win.add('O')
         if len(not_win) == 1:
             return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')
 
     line = ''.join(S[i][i] for i in range(4))
     not_win = set()
     if '.' not in line:   
         if 'O' in line:
             not_win.add('X')
         if 'X' in line:
             not_win.add('O')
         if len(not_win) == 1:
             return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')
 
     line = ''.join(S[i][3-i] for i in range(4))
     not_win = set()
     if '.' not in line:
         if 'O' in line:
             not_win.add('X')
         if 'X' in line:
             not_win.add('O')
         if len(not_win) == 1:
             return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')
 
     if not_draw:
         return 'Case #%s: %s\n' % (testcase, 'Game has not completed')
     else:
         return 'Case #%s: %s\n' % (testcase, 'Draw')
 
 if __name__ == '__main__':
     = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",2,87,846
"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 (object):
     cache = {}
 
     def __init__(self, infile, testcase):
         self.testcase = testcase
         self.P = P = map(int, infile.next().split())
 
     def init_cache(self):
         if 'main' in self.cache:
             return
         #self.cache['main'] = res
 
     def solve(self):
 
         N, S, p = self.P[:3]
         G = sorted(self.P[3:], reverse=True)
 
         r = 0
         s = 0
         for g in G:
             if g >= 3 * p - 2 and g >= p:
                 r += 1
             elif g >= 3 * p - 4 and g >= p:
                 if s == S:
                     break
                 r += 1
                 s += 1
 
         return r
 
 
 def main():
     T = int(sys.stdin.next())
     for t in xrange(T):
         sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))
 
 
 if __name__ == '__main__':
     main()
",2,88,330
"""""""Usage:
     pypy X.py < X-size.in > X-size.out
 or sometimes
     python X.py < X-size.in > X-size.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, C=None, **ignore):
     N = int(infile.next())
     P = map(float, infile.next().split())
     I = map(float, infile.next().split())
     #T = infile.next().split()
     #S = [infile.next().strip() for i in range(N)]
     return locals()
 
 def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #########= sorted(P)
     K = sorted(I)
 
     W = 0
     ik = 0
     for n in N:
         while ik < len(K) and K[ik] < n:
             ik += 1
             W += 1
         ik += 1
 
     D = 0
     i = 0
     for k in K:
         while i < len(N) and N[i] < k:
             i += 1
         i += 1
         if i <= len(N):
             D += 1
 
     return 'Case #%s: %s %s\n' % (testcase, D, W)
 
 if __name__ == '__main__':
     = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",2,89,438
"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 # http://code.activestate.com/recipes/577821-integer-square-root-function/
 def isqrt(x):
     ""returns int(floor(sqrt(x))) using only integer math""
     assert x >= 0, 'Undefined %r' % locals()
     n = int(x)
     if n == 0:
         return 0
     a, b = divmod(n.bit_length(), 2)
     x = 2**(a+b)
     while True:
         y = (x + n//x)//2
         if y >= x:
             return x
         x = y
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, **ignore):
     #N = int(infile.next())
     P = map(int, infile.next().split())
     #I = map(int, infile.next().split())
     #T = infile.next().split()
     #S = [infile.next().strip() for i in range(N)]
     return locals()
 
 def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #########= isqrt(P[0])
     high = isqrt(P[1])+1
 
     def is_pal(n):
         n = str(n)
         for i in range(len(n)/2+1):
             if n[i]!=n[len(n)-1-i]:
                 return False
         return True
 
     res = 0
     for i in range(low, high+1):
         if P[0]<=i*i<=P[1] and is_pal(i) and is_pal(i*i):
             res += 1
 
     return 'Case #%s: %s\n' % (testcase, res)
 
 if __name__ == '__main__':
     = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",2,90,575
"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 = """"""ejp mysljylc kd kxveddknmc re jsicpdrysi
 rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
 de kr kd eoya kw aej tysr re ujdr lkgc jvqz
 """"""
 
 outs = """"""our language is impossible to understand
 there are twenty six factorial possibilities
 so it is okay if you want to just give upzq
 """"""
 
 class Solver(object):
     cache = {}
 
     def __init__(self, infile, testcase):
         self.testcase = testcase
         self.S = S = infile.next().strip()
 
         self.init_cache()
 
     def init_cache(self):
         if 'main' in self.cache:
             return
         t = {}
         for i in xrange(len(ins)):
             t[ins[i]] = outs[i]
         print t
         self.cache['main'] = t
 
     def solve(self):
 
         S = self.S
         
 
         return ''.join(self.cache['main'][c] for c in list(S))
 
 
 def main():
     T = int(sys.stdin.next())
     for t in xrange(T):
         sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))
 
 
 if __name__ == '__main__':
     main()
",2,91,400
"""""""Usage:
     pypy X.py < X-size.in > X-size.out
 or sometimes
     python X.py < X-size.in > X-size.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, C=None, **ignore):
     #N = int(infile.next())
     P = map(int, infile.next().split())
     #I = map(int, infile.next().split())
     #T = infile.next().split()
     #S = [infile.next().strip() for i in range(N)]
     return locals()
 
 def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     ########= P
     #print '--', R, C, M
     MM = M
 
     F = np.array([['.'] * C] * R)
     while M > 0:
         # reduce if possible
         if R >= C and M >= C and R > 2:
             M -= C
             R -= 1
             F[R] = '*'
         elif C > R  and M >= R and C > 2:
             M -= R
             C -= 1
             F[:, C] = '*'
         # solve simple
         elif R > 2 and C > 2 and (R > 3 or C > 3 or M == 1):
             if M < C - 1:
                 R -= 1
                 F[R, C - M:C] = '*'
             elif M < R - 1:
                 C -= 1
                 F[R - M:R, C] = '*'
             elif M == C - 1:
                 R -= 1
                 F[R, C - M + 1:C] = '*'
                 F[R - 1, C - 1] = '*'
             else:
                 C -= 1
                 F[R - M + 1:R, C] = '*'
                 F[R - 1, C - 1] = '*'
             M = 0
         #Â special cases
         elif M == R * C - 1:
             F[:, :] = '*'
             M = 0
         else:
             #print F
             #print R, C, M
             return 'Case #%s:\n%s\n' % (testcase, 'Impossible')
 
     F[0, 0] = 'c'
     assert (F == '*').sum() == MM
     return 'Case #%s:\n%s\n' % (testcase, '\n'.join(''.join(f.tolist()) for f in F))
 
 if __name__ == '__main__':
     = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",2,92,755
"""""""Usage:
     pypy X.py < X-size.in > X-size.out
 or sometimes
     python X.py < X-size.in > X-size.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, C=None, **ignore):
     #N = int(infile.next())
     #P = map(int, infile.next().split())
     I = map(float, infile.next().split())
     #T = infile.next().split()
     #S = [infile.next().strip() for i in range(N)]
     return locals()
 
 def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #########= I
     n = [0]
     r = 2.
 
     res = X / r
     while True:
         n.append(n[-1] + C / r)
         r += F
         nres = n[-1] + X / r
         if nres >= res:
             break
         res = nres
 
     return 'Case #%s: %s\n' % (testcase, res)
 
 if __name__ == '__main__':
     = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",2,93,382
"f = open('A.in', 'r')
 g = open('outputA.txt', 'w')
 data = [[int(e) for e in line.strip(""\n"").split(' ')] for line in f]
 T = data[0][0]
 c = 0
 for i in xrange(1, T*10 + 1, 10):
     c += 1
     choice1 = data[i][0]
     choice2 = data[i+5][0]
     grid1, grid2 = [], []
     for j in xrange(1,5):
         grid1.append(data[i+j])
 
     for j in xrange(6, 10):
         grid2.append(data[i+j])
 
     s1 = set(grid1[choice1-1])
     s2 = set(grid2[choice2-1])
 
     s = s1 & s2
     if len(s) == 1:
         g.write(""Case #%i: %i\n"" %(c, s.pop()))
     elif not s:
         g.write(""Case #%i: Volunteer cheated!\n"" %(c))
     else:
         g.write(""Case #%i: Bad magician!\n"" %(c))
 
 f.close()
 g.close()
     
",3,94,326
"def check(grid, n, m):
     for i in range(n):
         for j in range(m):
             if neighbor(grid,i,j,n,m):
                 return False
     return True
 
 def neighbor(grid,i,j,n,m):
     u = not i
     d = not (n-i-1)
     l = not j
     r = not (m-j-1)
     if n == 1:
         return False
     if m == 1:
         return False
     if i > 0:
         for k in range(i,-1,-1):
             if grid[k][j] > grid[i][j]:
                 u = 1
             
     if i < n-1:
         for k in range(i,n):
             if grid[k][j] > grid[i][j]:
                 d = 1
         
     if j > 0:
         for k in range(j,-1,-1):
             if grid[i][k] > grid[i][j]:
                 l = 1
         
     if j < m-1:
         for k in range(j,m):
             if grid[i][k] > grid[i][j]:
                 r = 1
     return (u*d*l*r)
         
 
 dat = raw_input().split()
 c = int(dat.pop(0))
 data = [int(e) for e in dat]
 index = 0
 t = 0
 while t < c:
     n = data[index]
     m = data[index+1]
     index += 2
     grid = []
     for i in range(n):
         grid.append(data[index:index+m])
         index += m
     if check(grid, n, m):
         print 'Case #%i: YES'%(t+1)
     else:
         print 'Case #%i: NO'%(t+1)
     t += 1
",3,95,480
"= open('csmall.in','r')
 out = open('out3.txt','w')
 inp = [[int(n) for n in s.split()] for s in f.readlines()]
 count = 1
 
 for e in inp[1:len(inp)]:
     interval = xrange(e[0],e[1]+1)
     exp = xrange(1, int(math.log(interval[-1],10))+1)
     skip = []
     pairs = []
     for i in interval:
         if str(i)[::-1] == str(i):
             continue
         for j in exp:
             val = int(str(i%10**j)+str(i/10**j))
             if val in skip:
                 continue
             elif val >= interval[0] and val <= interval[-1] and not val == i:
                 skip.append(i)
     out.write('Case #'+str(count)+': '+str(len(skip))+'\n')
     count += 1
 
 f.close()
 out.close()
",3,96,265
"def checkRow(d, t):
     g = 0
     for row in d:
         a = list(row)
         a.sort()
         a = ''.join(a)
         if 'TXXX' in a or 'XXXX' in a:
             print 'Case #%i: X won' %(t/4+1)
             return 1
         if 'OOOT' in a or 'OOOO' in a:
             print 'Case #%i: O won' %(t/4+1)
             return 1
         if '.' in a:
             g = 10
     return g
 
 def checkCol(d, t):
     for j in range(4):
         col = []
         for row in d:
             col.append(row[j])
         a = list(col)
         a.sort()
         a = ''.join(a)
         if 'TXXX' in a or 'XXXX' in a:
             print 'Case #%i: X won' %(t/4+1)
             return 1
         if 'OOOT' in a or 'OOOO' in a:
             print 'Case #%i: O won' %(t/4+1)
             return 1
     return 0
 
 def checkDiag(d1, d2, t):
     a = list(d1)
     b = list(d2)
     a.sort()
     b.sort()
     a = ''.join(a)
     b = ''.join(b)
 
     if 'TXXX' in a or 'XXXX' in a:
         print 'Case #%i: X won' %(t/4+1)
         return 1
     if 'OOOT' in a or 'OOOO' in a:
         print 'Case #%i: O won' %(t/4+1)
         return 1
 
     if 'TXXX' in b or 'XXXX' in b:
         print 'Case #%i: X won' %(t/4+1)
         return 1
     if 'OOOT' in b or 'OOOO' in b:
         print 'Case #%i: O won' %(t/4+1)
         return 1
     return 0
 
 dat = raw_input()
 
 data = dat.split()
 c = int(data.pop(0))
 
 for t in range(0, 4*c, 4):
     a = checkRow(data[t:t+4],t)
     if a == 1:
         continue
     b = checkCol(data[t:t+4],t)
     if b:
         continue
     d1 = data[t][0]+data[t+1][1]+data[t+2][2]+data[t+3][3]
     d2 = data[t][3]+data[t+1][2]+data[t+2][1]+data[t+3][0]
     c = checkDiag(d1, d2,t)
     if c:
         continue
     if (a+b+c) == 0:
         print 'Case #%i: Draw' %(t/4+1)
     if a == 10:
         print 'Case #%i: Game has not completed' %(t/4+1)   
",3,97,814
"f = open('cj2.in','r')
 out = open('out1.txt','w')
 inp = [[int(n) for n in s.split()] for s in f.readlines()]
 
 def score_partition(score):
     poss = []
     if score == 0:
         return [[0,0,0]]
     if score == 1:
         return [[0,0,1]]
     if score % 3 == 0:
         poss.append([score/3,score/3,score/3])
         poss.append([score/3-1,score/3,score/3+1])
     if score % 3 == 1:
         poss.append([score/3, score/3,score/3+1])
         poss.append([score/3-1,score/3+1,score/3+1])
     if score % 3 == 2:
         poss.append([score/3,score/3+1,score/3+1])
         poss.append([score/3,score/3,score/3+2])
 
     return poss
 
 
 s = 0
 c = 1
 for e in inp[1:len(inp)]:
     count = 0
     surprises = e[1]
     s = 0
     p = e[2]
     for i in e[3:len(e)]:
         scores = score_partition(i)
         for j in scores: 
             if max(j) >= p:
                 if max(j)-min(j) == 2:
                     if s < surprises:
                         s +=1
                         count +=1
                         break
                 else:
                     count += 1
                     break
                 
     out.write('Case #'+str(c)+': '+str(count)+'\n')
     c += 1
 
 out.close()
 f.close()
                 
         
     
     
 
     
",3,98,479
"def check(a,b):
     c = 0
     n = 1
     for i in range(1,4):
         if i**2 >= a and i**2 <=b:
             c += 1
     if 44944 >= a and 44944 <= b:
         c += 1
     while n < 10:
         p1 = int('1'+'1'*n)**2
         if p1 >= a and p1 <=b:
             c += 1
         n += 1
 
 
     if 484 >= a and 484 <= b:
         c += 1
 
     n = 1
     while True:
         p2 = int('1'+'0'*n+'1')**2
         p3 = int('2'+'0'*n+'2')**2
         if p2 >= a and p2 <= b:
             c += 1
         else:
             break
         if p3 >= a and p3 <= b:
             c += 1
         else:
             continue
         n += 1
 
     n = 1
     while True:
         t = False
         for m in range(2,5):
             p4 = int('1'*m+'0'*n+'1'*m)**2
             if p4 >= a and p4 <= b:
                 c += 1
             else:
                 t = True
                 break
         if t:
             break
             
         n += 1
     return c
                 
 dat = raw_input().split()
 n = int(dat.pop(0))
 data = [int(e) for e in dat]
 
 for i in range(0, n*2, 2):
     a, b = data[i], data[i+1]
     print 'Case #%i: '%(i/2+1) + str(check(a,b)) 
 
     
",3,99,470
"mapping = {'y':'a','n':'b','f':'c','i':'d','c':'e','w':'f','l':'g','b':'h','k':'i','u':'j','o':'k','m':'l','x':'m','s':'n','e':'o','v':'p','p':'r','d':'s','r':'t','j':'u','g':'v','t':'w','h':'x','a':'y','q':'z','z':'q',' ':' ','\n':'\n'}
 
 f = open('cj.in','r')
 out = open('out.txt','w')
 inp = [line for line in f]
 
 i = 1
 for G in inp[1:len(inp)]:
     string = ''
     for e in G:
         string+=mapping[e]
     out.write('Case #'+str(i)+': '+string)
     i+=1
 
 f.close()
 out.close()
",3,100,231
"def make_string(R, C, M):
     grid = [['.' for j in xrange(C)] for i in xrange(R)]
     grid[-1][-1] = 'c'
     t = M
     for i in xrange(R):
         for j in xrange(C):
             if M:
                 if forbidden(R, C, t, i, j):
                     continue
                 grid[i][j] = '*'
                 M -= 1
             else:
                 break
     s = ''
     if M:
         return 'Impossible'
     for r in grid:
         s += ''.join(r)+'\n'
     return s[:-1]
 
 def forbidden(R, C, M, i, j):
     a = M / C
     b = M % C
     if (R*C - M == 1):
         return False
 
     if i >= (R-2) and j >= (C-2):
         return True
 
     if i >= (R-2) and b:
         if b % 2:
             return True
         if j < b/2:
             return False
         else:
             return True
     return False
         
 
 f = open('Csmall.in', 'r')
 ##f = open('test.txt', 'r')
 g = open('outputC.txt', 'w')
 
 data = [[int(e) for e in line.strip(""\n"").split(' ')] for line in f]
 T = int(data.pop(0)[0])
 for i, case in enumerate(data):
     R, C, M = case[0], case[1], case[2]
     num_cells = R*C
     if (R-1) == 0 or (C-1) == 0:
         s = make_string(R, C, M)
         g.write('Case #%i:\n%s\n' %(i+1,s))
         continue
     else:
         s = make_string(R, C, M)
         g.write('Case #%i:\n%s\n' %(i+1, s))
         
 
 f.close()
 g.close()
",3,101,536
"f = open('Bsmall.in', 'r')
 ##f = open('test.txt', 'r')
 g = open('outputB.txt', 'w')
 
 data = [[float(e) for e in line.strip(""\n"").split(' ')] for line in f]
 T = int(data.pop(0)[0])
 
 for i, case in enumerate(data):
     C, F, X = case[0], case[1], case[2]
     n = 1
     t = X/2
     t_next = X/(2 + F) + C/2
     metric = (t_next < t)
     while metric:
         n += 1
         t = t_next
         t_next = t_next - X/(2 + F*(n-1)) + C/(2 + F*(n-1)) + X/(2 + F*n)
         metric = (t_next < t)
     g.write('Case #%i: %f\n' %(i+1, t))
 f.close()
 g.close()
",3,102,255
"__author__ = 'jrokicki'
 
 = lambda: sys.stdin.readline().strip()
 IA = lambda: map(int, RL().split("" ""))
 LA = lambda: map(long, RL().split("" ""))
 
 T = int(sys.stdin.readline())
 
 for CASE in range(T):
     g1 = IA()[0]-1
     board1 = []
     for i in range(4):
         board1.append(IA())
     g2 = IA()[0]-1
     board2 = []
     for i in range(4):
         board2.append(IA())
 
     r1 = board1[g1]
     r2 = board2[g2]
 
     answer = set(r1).intersection(r2)
     if len(answer) > 1:
         answer = ""Bad magician!""
     elif len(answer) == 0:
         answer = ""Volunteer cheated!""
     else:
         answer = list(answer)[0]
 
     print ""Case #%d: %s"" % (CASE+1, answer)
 
",4,103,279
"= sys.stdin.readlines()
 def parseCase(lines):
     dims = map(int,lines[0].split("" ""))
     return dims[0]+1, [map(int,l.split("" "")) for l in lines[1:dims[0]+1]]
 
 
 def getCases(lines):
     i =0
     while i < len(lines):
         lines_used, case = parseCase(lines[i:])
         i += lines_used
         yield case
 
         
 cNum =0
 for c in getCases(lines[1:]):
     cNum += 1
     answer = None
     for i in range(len(c)):
         if answer: break
         for j in range(len(c[i])):
             if answer: break
             answer = max(c[i]) > c[i][j] and max([c[k][j] for k in range(len(c))]) > c[i][j]
     print ""Case #%d: %s"" % ( cNum, ""NO"" if answer else ""YES"")
 
 
     
 
 
",4,104,272
"""""""
 GCJ framework (gcj.fw.framework)
  - Command Line and Package interface
  - output redirection
  - parsing case input
  - executing problem code against cases
  - testing framework
 """"""
 (object):
     class Case(object):
         def __init__(self, caseNumber, caseData=None):
             self.number = caseNumber
             self.data = caseData
             self.result = None
     
         @classmethod
         def parser(cls, f_in):
             pass
     
         def run(self):
             pass
     
         def execute(self, f_in=None):
             if self.data is None:
                 self.data = self.parser(f_in)
             self.result = self.run(**self.data)
     
         def __str__(self):
             return ""Case #%d: %s"" % (self.number, self.result)
     
     
     class Result(object):
         def __init__(self, resultData):
             self.data = resultData
     
         def __str__(self):
             return str(self.ata)
 
     def __init__(self, f_in, f_out):
         sys.stdout = f_out
         self.f_in = f_in if f_in is not None else sys.stdin
 
     def run(self):
         nCases = int(self.f_in.readline().strip())
         for num in xrange(nCases):
             case = type(self).Case(num+1)
             case.execute( f_in=self.f_in)
             print case
 
 
     @classmethod
     def __main__(cls):
         f_in = sys.stdin
         if len(sys.argv) > 1:
             if sys.argv[1] == ""-t"":
                 unittest.main()
                 sys.exit()
             f_in = open(sys.argv[1])
         framework = cls(f_in, sys.stdout)
         framework.run()
     
 class Test(unittest.TestCase):
     cases = []
     case = None
     c=[]
     
     def setUp(self):
         self.c = []
         self.defineCases()
         counter = 1
         self.cases = []
         for c in self.c:
             case = self.case(counter)
             case.data = case.parser(StringIO.StringIO(c[0]))
             self.cases.append( [case, c[1]])
     
     def defineCases(self):
         pass
     
     def tearDown(self):
         pass 
 
     def test_Name(self):
         self.setUp()
         for case in self.cases:
             print case[0].data, case[1]
             case[0].execute()
             self.assertEqual(case[0].result, case[1])
 '''
 Created on Apr 8, 2012
 
 @author: Joe
 '''
 
 (Framework):
     class Case(Framework.Case):
         def parser(self, fh):
             args = map(int, fh.readline().strip().split("" ""))
             A,B = args[:2]
             return {""A"":A,""B"":B}
         
         def run(self,A=None,B=None):
             ret = 0
             found = set()
             for i in range(A,B+1):
                 if i in found: continue
                 n = int(log(i,10))
                 nums = set([i])
                 tmp = i
                 for j in range(n):
                     tmp = tmp / 10 + (tmp%10)*10**(n)
                     if tmp <= B and tmp>= A:
                         nums.add(tmp)
                         found.add(tmp)
                 ret += len(nums)*(len(nums)-1)/2
             return str(ret)
             
 class Test(Test):
     def defineCases(self):
         self.case = C.Case
         self.c = [
                   [""1 9"", ""0""],
                   [""10 40"", ""3"",                   ],
                   [""10 99"", ""36""],
                   [""100 500"", ""156""],
                   [""1111 2222"", ""287""],
                   [""1000000 2000000"", ""2000000""]
                   ]
 
 if __name__ == ""__main__"":
     C.__main__()
     
",4,105,1126
"= sys.stdin.readlines()
 def parseCase(lines):
     return 5,lines[0:4]
 
 def getCases(lines):
     i =0
     while i < len(lines):
         lines_used, case = parseCase(lines[i:])
         i += lines_used
         yield case
 
 def test(r):
     if 'O' in r and '.' not in r and 'X' not in r: 
         return ""O won""
     elif 'X' in r and '.' not in r and 'O' not in r: 
         return ""X won""
     return None
         
 cNum =0
 for c in getCases(lines[1:]):
     cNum += 1
     answer = None
     for i in range(0,4):
         if answer: break
         r = c[i]
         answer = test(r) \
             or test("""".join(c[j][i] for j in range(4)))
 
     if not answer:
         answer = test("""".join([c[j][3-j] for j in range(4)])) \
             or test("""".join(c[j][j] for j in range(4)))
             
     if not answer:
         answer = any([""."" in c[i] for i in range(4)]) and ""Game has not completed""
     if not answer:
         answer = ""Draw""
     print ""Case #%d: %s"" % ( cNum, answer)
 
 
 
 
 
 
 
 
 
 
 
     
 
 
",4,106,390
"__author__ = 'jrokicki'
 
 = lambda: sys.stdin.readline().strip()
 IA = lambda: map(int, RL().split("" ""))
 LA = lambda: map(long, RL().split("" ""))
 FA = lambda: map(float, RL().split("" ""))
 
 T = int(sys.stdin.readline())
 
 def war(N,K):
     """"""
     strategy: N plays lowest number first, K chooses next best number
     """"""
     if len(N) == 0: return 0
     n = N[0]
     if K[-1] > n:
         # ken wins
         k = len(K)-1
         for k in range(len(K)-1):
             if K[k] > n and K[k+1] > n:
                 break
         if K[k] < n: k += 1
         K = K[:k] + K[k+1:]
         return war(N[1:],K)
     else:
         ## N wins they both play their lowest numbers
         return 1 + war(N[1:], K[1:])
 
 def beawoman(N,K):
     if len(N) == 0: return 0
     n = N[0]
     bad = False
     for i in range(len(N)):
         if N[i] < K[i]:
             bad = True
     if bad:
         return beawoman(N[1:], K[:-1])
     else:
         return 1 + beawoman(N[:-1], K[:-1])
 
 for CASE in range(T):
     RL()
     N = FA()
     K = FA()
     N.sort()
     K.sort()
     answer = ""%d %d"" % (beawoman(N,K), war(N,K))
     print ""Case #%d: %s"" % (CASE+1, answer)
 
",4,107,477
"= sys.stdin.readlines()
 def parseCase(lines):
     dims = map(int,lines[0].split("" ""))
     return 1, dims
 
 def getCases(lines):
     i =0
     while i < len(lines):
         lines_used, case = parseCase(lines[i:])
         i += lines_used
         yield case
 
 = []
 phash = {1:True}
 def isPalindrome(p):
     return p in phash
 
 def test(p):
     square = p**.5
     return square == int(square) and isPalindrome(int(square))
 
 for i in range(1,10**5):
     if i > 9:
         small_p = int(i * 10 ** int(math.log(i,10)) + int("""".join(reversed(str(i)[:-1]))))
     else: small_p = i
     phash[small_p]= test(small_p)
     if phash[small_p]: fands.append(small_p)
     big_p = int(i * 10 ** int(math.log(i,10)+1) + int("""".join(reversed(str(i)))))
     phash[big_p] = test(big_p)
     if phash[big_p]: fands.append(big_p)
 cNum =0
 
 for c in getCases(lines[1:]):
     cNum += 1
     answer = []
     for i in fands:
         if i < c[0]: continue
         if i > c[1]: break
         if phash[i]: answer.append(i)
     answer = str(len(answer))
     print ""Case #%d: %s"" % ( cNum, answer)
 
 
     
 
 
",4,108,458
"""""""
 GCJ framework (gcj.fw.framework)
  - Command Line and Package interface
  - output redirection
  - parsing case input
  - executing problem code against cases
  - testing framework
 """"""
 (object):
     class Case(object):
         def __init__(self, caseNumber, caseData=None):
             self.number = caseNumber
             self.data = caseData
             self.result = None
     
         @classmethod
         def parser(cls, f_in):
             pass
     
         def run(self):
             pass
     
         def execute(self, f_in=None):
             if self.data is None:
                 self.data = self.parser(f_in)
             self.result = self.run(**self.data)
     
         def __str__(self):
             return ""Case #%d: %s"" % (self.number, self.result)
     
     
     class Result(object):
         def __init__(self, resultData):
             self.data = resultData
     
         def __str__(self):
             return str(self.ata)
 
     def __init__(self, f_in, f_out):
         sys.stdout = f_out
         self.f_in = f_in if f_in is not None else sys.stdin
 
     def run(self):
         nCases = int(self.f_in.readline().strip())
         for num in xrange(nCases):
             case = type(self).Case(num+1)
             case.execute( f_in=self.f_in)
             print case
 
 
     @classmethod
     def __main__(cls):
         f_in = sys.stdin
         if len(sys.argv) > 1:
             if sys.argv[1] == ""-t"":
                 unittest.main()
                 sys.exit()
             f_in = open(sys.argv[1])
         framework = cls(f_in, sys.stdout)
         framework.run()
     
 class Test(unittest.TestCase):
     cases = []
     case = None
     c=[]
     
     def setUp(self):
         self.c = []
         self.defineCases()
         counter = 1
         self.cases = []
         for c in self.c:
             case = self.case(counter)
             case.data = case.parser(StringIO.StringIO(c[0]))
             self.cases.append( [case, c[1]])
     
     def defineCases(self):
         pass
     
     def tearDown(self):
         pass 
 
     def test_Name(self):
         self.setUp()
         for case in self.cases:
             print case[0].data, case[1]
             case[0].execute()
             self.assertEqual(case[0].result, case[1])
 
 D={'a':'y','o':'e','z':'q','q':'z'}
 
 a=[""ejp mysljylc kd kxveddknmc re jsicpdrysi"",
    ""our language is impossible to understand"",
    ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"",
    ""there are twenty six factorial possibilities"",
    ""de kr kd eoya kw aej tysr re ujdr lkgc jv"",
    ""so it is okay if you want to just give up""]
 
 for i in range(0,len(a),2):
     for j in range(0,len(a[i])):
         D[a[i][j]] = a[i+1][j]
 
 class A(Framework):
     class Case(Framework.Case):
         def parser(self, fh):
             statement = fh.readline().strip() 
             return {'secret': statement}
         
         def run(self, secret=None):
             word = """"
             for i in range(0,len(secret)):
                 word += D[secret[i]]
             return word
         
 class Test(Test):
     def defineCases(self):
         self.case = A.Case
         self.c = [[""ejp mysljylc kd kxveddknmc re jsicpdrysi"",
    ""our language is impossible to understand""],
                   [   ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"",
    ""there are twenty six factorial possibilities"",],
                   [ ""de kr kd eoya kw aej tysr re ujdr lkgc jv"",
    ""so it is okay if you want to just give up""],
                   ]
 
 if __name__ == ""__main__"":
     A.__main__()
     
",4,109,1164
"__author__ = 'jrokicki'
 
 = lambda: sys.stdin.readline().strip()
 IA = lambda: map(int, RL().split("" ""))
 LA = lambda: map(long, RL().split("" ""))
 FA = lambda: map(float, RL().split("" ""))
 
 T = int(sys.stdin.readline())
 
 def clear(R,C,b, x, y):
     b = b[:]
     n = 0
     for i in range(max(0,x-1), min(R,x+2)):
         for j in range(max(0,y-1), min(C, y+2)):
             if b[C*i+j] == '*':
                 n += 1
                 b = b[:C*i+j] + '.' + b[C*i+j+1:]
     return b, n
 mem = dict()
 def pb(R,C,b):
     for x in range(R):
         print b[x*C:x*C+C]
 
 def board(R,C,b,x,y,M,m):
     global mem
     print x
     key = (R,C,b,M,x,y,m)
     if key in mem: return mem[key]
     if x >= R or y >= C:
         mem[key] = None
     else:
         lb = b
         n = 0
         good = False
         for i in range(y,C):
             nb,nn = clear(R,C, lb, x, i)
             n += nn
             if m - n - M == 0:
                 mem[key] = nb
                 good = True
                 break
             elif m - n - M < 0:
                 break
             lb = bb
         mem[key] = board(R,C,bb,M,x+1,0,m-n)
     return mem[key]
 
 for CASE in range(T):
     R,C,M = IA()
     IMPOSSIBLE = ""Impossible""
 
     b = """"
     cleared = R*C-M
     for x in range(R):
         b += ""*"" * C
     if M == R*C-1:
         b = ""c"" + b[1:]
         answer = b
     else:
         good = False
         x,y = 0,0
         q = [(b,0,0,0)]
         mem = {}
         while not good and q:
             board,total_cleared,x,y = q.pop(0)
             if (board,total_cleared,x,y) in mem:
                 continue
             mem[(board,total_cleared,x,y)] = True
             if x >= R: continue
             if y >= C:
                 q.append((last_board,total_cleared,x+1,0))
                 continue
             last_board = board
             new_board, cleared_mines = clear(R,C,last_board,x,y)
             total_cleared += cleared_mines
 
             if total_cleared == cleared:
                 good = True
                 last_board = new_board
                 q = []
                 break
             elif total_cleared - cleared == -1:
                 q.append((new_board,total_cleared,x,y+1))
                 q.append((new_board,total_cleared,x+1,0))
                 q.append((last_board,total_cleared-cleared_mines,x+1,0))
             elif total_cleared > cleared:
                 q.append((last_board,total_cleared-cleared_mines,x+1,0))
             else:
                 q.append((new_board,total_cleared,x,y+1))
             last_board = new_board
         if good:
             answer = last_board
         else:
             answer = None
     if not answer:
         answer = ""Impossible""
     else:
         b = """"
         for x in range(R):
             b += answer[x*C:x*C+C] + ""\n""
         answer = ""c"" + b[1:-1]
     print ""Case #%d:\n%s"" % (CASE+1, answer)
 
",4,110,1052
"__author__ = 'jrokicki'
 
 = lambda: sys.stdin.readline().strip()
 IA = lambda: map(int, RL().split("" ""))
 LA = lambda: map(long, RL().split("" ""))
 FA = lambda: map(float, RL().split("" ""))
 
 T = int(sys.stdin.readline())
 
 for CASE in range(T):
     C,F,X = FA()
     tick = 2.
     answer = X/tick
 
     game = 0
     while True:
         span = C / tick
         tick += F
         test = game + span + X/tick
         game = game + span
 
         if test < answer:
             answer = test
         else:
             if tick > X:
                 break
 
     print ""Case #%d: %s"" % (CASE+1, answer)
 
",4,111,219
"# -*- coding: utf-8 -*-
 
 = int(sys.stdin.readline())
 
 for T in range(1, N+1):
     first_ans = int(sys.stdin.readline())
     first_grid = []
     for i in range(4):
         row = [int(v) for v in sys.stdin.readline().split(' ')]
         first_grid.append(row)
     first_list = set(first_grid[first_ans-1])
     
     second_ans = int(sys.stdin.readline())
     second_grid = []
     for i in range(4):
         row = [int(v) for v in sys.stdin.readline().split(' ')]
         second_grid.append(row)
     second_list = set(second_grid[second_ans-1])
 
     intersection = first_list.intersection(second_list)
 
     if len(intersection) == 1:
         ans = intersection.pop()
     elif len(intersection) == 0:
         ans = 'Volunteer cheated!'
     else:
         ans = 'Bad magician!'
 
     print 'Case #%(T)s: %(ans)s' % locals()
",5,112,310
"# -*- coding: utf-8 -*-
 
 (grass, goal, elems):
     while elems:
         val = elems[0]
         for n in range(len(goal)):
             for m in range(len(goal[0])):
                 if goal[n][m] == val and goal[n][m] < grass[n][m]:
                     return (n, m)
         elems.remove(val)
     return None
 
 def check(grass, goal):
     possible = True
     completed = True
     for n in range(len(grass)):
         for m in range(len(grass[0])):
             if grass[n][m] > goal[n][m]:
                 completed = False
             elif grass[n][m] < goal[n][m]:
                 possible = False
 
     return possible, completed
 
 def cut(grass, goal, pos, h, elems):
     
     def _cut(grass, goal, pos, h, is_horizontal):
         if is_horizontal:
             for m in range(len(grass[0])):
                 grass[pos[0]][m] = h
         else:
             for n in range(len(grass)):
                 grass[n][pos[1]] = h
         possible, completed = check(grass, goal)
         if completed and possible:
             return 'YES'
         elif not completed and possible:
             pos = next_pos(grass, goal, elems)
             if not pos:
                 return 'NO'
             h = goal[pos[0]][pos[1]]
             return cut(grass, goal, pos, h, elems)
         elif not possible:
             return 'NO'
 
     ans1 = _cut(copy.deepcopy(grass), goal, pos, h, is_horizontal=True)
     if ans1 == 'YES':
         return 'YES'
     ans2 = _cut(copy.deepcopy(grass), goal, pos, h, is_horizontal=False)
     if ans2 == 'YES':
         return 'YES'
     return 'NO'
 
 
 def calc(grass, goal):
     def _elems(goal):
         elems = set()
         for n in range(len(goal)):
             for m in range(len(goal[0])):
                 elems.add(goal[n][m])
         return sorted(list(elems), reverse=True)
 
     elems = _elems(goal)
     pos = next_pos(grass, goal, elems)
     h = goal[pos[0]][pos[1]]
     return cut(grass, goal, pos, h, elems)
 
 
 N = int(sys.stdin.readline())
 for T in range(1, N+1):
     N, M = map(int, sys.stdin.readline().strip().split())
 
     goal = []
     for i in range(N):
         goal.append(map(int, sys.stdin.readline().strip().split()))
 
     grass = []
     for i in range(N):
         line = [100] * M
         grass.append(line)
 
     ans = calc(grass, goal)
     print 'Case #%(T)s: %(ans)s' % locals()
",5,113,813
"#!/usr/bin/python
 # -*- coding: utf-8 -*-
 
 (num):
     result = []
     num_text = str(num)
     for i in range(1, len(num_text)):
         rotated = int(num_text[i:] + num_text[:i])
         if num != rotated:
             result.append(rotated)
     return result
 
 for T, line in enumerate(sys.stdin):
     if T == 0:
         continue
 
     results = []
     params = [int(n) for n in line.split(' ')]
     (A, B) = params
     for i in range(A, B):
         candidates = recycled_numbers(i)
         for c in candidates:
             pair = (i, c)
             if pair not in results and A <= c and c <= B and i < c:
                 results.append(pair)
     # print results
     ans = len(results)
     print 'Case #%(T)s: %(ans)s' % locals()
",5,114,259
"# -*- coding: utf-8 -*-
 
 = int(sys.stdin.readline())
 
 for T in range(1, N+1):
     lines = []
     completed = True
     for i in range(4):
         line = sys.stdin.readline().strip()
         if '.' in line:
             completed = False
         lines.append(line)
     sys.stdin.readline() # empty line
 
     ans = 'Draw' if completed else 'Game has not completed'
     # horizontal
     for row in range(4):
         X, O = 0, 0
         for col in range(4):
             spot = lines[row][col]
             if spot == 'O':
                 O += 1
             elif spot == 'X':
                 X += 1
             if spot == 'T':
                 O += 1
                 X += 1
         if X == 4:
             ans = 'X won'
         elif O == 4:
             ans = 'O won'
 
     # vertical
     for col in range(4):
         X, O = 0, 0
         for row in range(4):
             spot = lines[row][col]
             if spot == 'O':
                 O += 1
             elif spot == 'X':
                 X += 1
             if spot == 'T':
                 O += 1
                 X += 1
         if X == 4:
             ans = 'X won'
         elif O == 4:
             ans = 'O won'
 
     # diagonal
     X1, X2, O1, O2 = 0, 0, 0, 0
     for i in range(4):
         spot1 = lines[i][i]
         spot2 = lines[4-i-1][i]
 
         if spot1 == 'O':
             O1 += 1
         elif spot1 == 'X':
             X1 += 1
         elif spot1 == 'T':
             O1 += 1
             X1 += 1
 
         if spot2 == 'O':
             O2 += 1
         elif spot2 == 'X':
             X2 += 1
         elif spot2 == 'T':
             O2 += 1
             X2 += 1
 
     if X1 == 4 or X2 == 4:
         ans = 'X won'
     elif O1 == 4 or O2 == 4:
         ans = 'O won'
     
     
     print 'Case #%(T)s: %(ans)s' % locals()
",5,115,628
"#!/usr/bin/python
 # -*- coding: utf-8 -*-
 
 (sys.stdin):
     if i == 0:
         continue
 
     params = [int(n) for n in line.split(' ')]
     (N, S, p) = params[:3]
     scores = params[3:]
 
     (clear, possible) = (0, 0)
     normal_min = max(p * 3 - 2, 0)
     suprising_min = max(p * 3 - 4, 0)
     for score in scores:
         if p > score:
             continue
         elif score >= normal_min:
             clear += 1
         elif score >= suprising_min:
             possible += 1
 
     ans = clear + min(possible, S)
     print 'Case #%(i)s: %(ans)s' % locals()
",5,116,223
"# -*- coding: utf-8 -*-
 
 = int(sys.stdin.readline())
 
 for T in range(1, T+1):
     N = int(sys.stdin.readline())
     naomi_blocks = map(float, sys.stdin.readline().split(' '))
     ken_blocks = map(float, sys.stdin.readline().split(' '))
 
     # # War
     naomi_blocks_w = sorted(copy.deepcopy(naomi_blocks))
     ken_blocks_w = sorted(copy.deepcopy(ken_blocks))
     naomi_score_w, ken_score_w = (0, 0)
     for i in range(N):
         naomi = naomi_blocks_w.pop()
 
         ken = None
         for k in ken_blocks_w:
             if k > naomi:
                 ken = k
                 break
         if not ken:
             ken = ken_blocks_w[0]
         ken_blocks_w.remove(ken)
 
         if naomi > ken:
             naomi_score_w += 1
         else:
             ken_score_w += 1
     
     # Deceitful War    
     naomi_blocks_dw = sorted(copy.deepcopy(naomi_blocks), reverse=True)
     ken_blocks_dw = sorted(copy.deepcopy(ken_blocks))
     naomi_score_dw, ken_score_dw = (0, 0)
     for i in range(N):
         naomi = naomi_blocks_dw.pop()
         ken = min(ken_blocks_dw)
         if ken > naomi:
             ken = max(ken_blocks_dw)
         ken_blocks_dw.remove(ken)            
         if naomi > ken:
             naomi_score_dw += 1
         else:
             ken_score_dw += 1
     
     ans = '%s %s' % (naomi_score_dw, naomi_score_w)
     print 'Case #%(T)s: %(ans)s' % locals()
",5,117,554
"# -*- coding: utf-8 -*-
 
 (num):
     s1 = str(num)
     s2 = s1[::-1]
     return s1 == s2
 
 fair_numbers = []
 for i in range(pow(10, 7)+1):
     if is_palindrome(i):
         num = i*i
         if is_palindrome(num):
             fair_numbers.append(num)
 
 N = int(sys.stdin.readline())
 for T in range(1, N+1):
     min_val, max_val = map(int, sys.stdin.readline().strip().split())
 
     ans = 0
     for num in fair_numbers:
         if num < min_val:
             continue
         if num > max_val:
             break
         ans += 1
     print 'Case #%(T)s: %(ans)s' % locals()
",5,118,233
"# -*- coding: utf-8 -*-
 
 (board):
     for row in board:
         print ''.join(row)
 
 
 N = int(sys.stdin.readline())
 
 for T in range(1, N+1):
     (R, C, M) = map(int, sys.stdin.readline().split(' '))
     E = R*C-M # empty
     possible, reverse, need_adjust, column_base = (False, False, False, False)
     if C > R:
         (R, C) = (C, R)
         reverse = True
 
     #
     # judgement
     #
     W = 0
     lastRow = 0
     if E == 0:
         pass
     elif E == 1 or M == 0:
         W = C
         possible = True
     elif C == 1:
         W = 1
         if E > 0:
             possible = True
     elif C == 2:
         W = 2
         lastRow = int(E / 2) + 1   # 1 base
         if E % 2 == 0 and E >= 4:
             possible = True
     elif C >= 3:
         for w in range(2, C+1):
             lastRow = int(E / w) + 1   # 1 base
             if lastRow > R: continue
             lastRowNum = E % w
             
             if lastRow == 2 and lastRowNum == 0:
                 pass
             elif lastRow == 2:   # lastRow == 1 => impossible
                 if lastRowNum == 0:
                     W = w
                     possible = True
                     break
             elif lastRow >= 3:
                 if lastRowNum >= 2 or lastRowNum == 0:
                     W = w
                     possible = True
                     break
                 elif C >= 4 and lastRowNum == 1 and R >= 3:
                     W = w
                     possible = True
                     need_adjust = True
                     break
         if not possible:
             for w in range(2, R+1):
                 lastRow = int(E / w) + 1   # 1 base
                 if lastRow > R: continue
                 lastRowNum = E % w
                 if lastRow == 2 and lastRowNum == 0:
                     pass
                 elif lastRow == 2:   # lastRow == 1 => impossible
                     if lastRowNum == 0:
                         W = w
                         possible = True
                         column_base = True
                         break
                 elif lastRow >= 3:
                     if lastRowNum >= 2 or lastRowNum == 0:
                         W = w
                         possible = True
                         column_base = True
                         break
                     elif C >= 4 and lastRowNum == 1 and R >= 3:
                         W = w
                         possible = True
                         need_adjust = True
                         column_base = True
                         break
                                 
     if not possible:
         if reverse:
             R, C = (C, R)        
         ans = 'Impossible %sx%s M=%s' % (R, C, M)
         # ans = 'Impossible'
         print 'Case #%(T)s: %(ans)s' % locals()
         continue
 
     #
     # make board
     #
     board = [['*'] * C for i in range(R)]
     for i in range(E):
         if not column_base:
             c = i % W
             r = i / W
         else:
             r = i % W
             c = i / W            
         board[r][c] = '.'
     if need_adjust:
         board[lastRow-1][1], board[lastRow-2][-1] = board[lastRow-2][-1], board[lastRow-1][1]
     if reverse:
         board = map(list, zip(*board))
         R, C = (C, R)
 
     clicked = False
     for r in range(R):
         if clicked: break
         for c in range(C):
             cell = board[r][c]
             if cell != '.': continue
             if E == 1:
                 board[r][c] = 'c'
                 clicked = True
                 break
             
             if r >= 1  and c >= 1  and board[r-1][c-1] == '*': continue
             if r >= 1              and board[r-1][c]   == '*': continue
             if r >= 1  and c < C-1 and board[r-1][c+1] == '*': continue
             if             c >= 1  and board[r][c-1]   == '*': continue
             if             c < C-1 and board[r][c+1]   == '*': continue
             if r < R-1 and c >= 1  and board[r+1][c-1] == '*': continue
             if r < R-1             and board[r+1][c]   == '*': continue
             if r < R-1 and c < C-1 and board[r+1][c+1] == '*': continue
             board[r][c] = 'c'
             clicked = True
             break
 
     #
     # show answer
     #
     ans = 'Possible' if possible else 'Impossible'
     print 'Case #%(T)s:' % locals()
     show_board(board)
",5,119,1358
"# -*- coding: utf-8 -*-
 
 = int(sys.stdin.readline())
 
 for T in range(1, N+1):
     C, F, X = map(float, sys.stdin.readline().split(' '))
 
     # find N
     N = 0
     for i in range(int(X)):
         diff = (2 + F * i) * C - F * X
         if diff >= 0: break
         N = i
 
     # calc seconds
     total = 0
     for i in range(N):
         val = C / (2 + i * F)
         total += val
     val = X / (2.0 + N * F)
     total += val
         
     ans = '%s' % (total)
     print 'Case #%(T)s: %(ans)s' % locals()
",5,120,215
"(infile=""B-small-attempt0.in"", outfile=""B-small-attempt0.out""):
 	inF = open(infile, 'r')
 	outF = open(outfile, 'w')
 	
 	for t in range(1, int(inF.readline().strip()) + 1):
 		#read grid size
 		temp = inF.readline().strip().split()
 		N = int(temp[0])
 		M = int(temp[1])
 		L = []
 		
 		for i in range(N):
 			L.append(inF.readline().strip().split()) #using an array should speed up the lookups
 			for j in range(M):
 				L[i][j] = int(L[i][j])
 		
 		for y in range(N):
 			for x in range(M):
 				# check horizontal
 				for i in range(M):
 					if L[y][i] > L[y][x]:
 						break
 				else:
 					continue
 				
 				# check vertical
 				for i in range(N):
 					if L[i][x] > L[y][x]:
 						break
 				else:
 					continue
 				break
 			else:
 				continue
 			break
 		else:
 			#good
 			outF.write(""Case #"" + str(t) + "": YES\n"")
 			continue
 		#bad
 		outF.write(""Case #"" + str(t) + "": NO\n"")
 	
 	#closing files
 	inF.close()
 	outF.close()
 	
 	#so I dont need to cat the file after
 	f = open(outfile, 'r')
 	print f.read()
 	f.close()
 	
 	
 if __name__ == ""__main__"":
     Lawnmower()",6,121,577
"#!/usr/bin/env python
 
 def partCa(infile=""C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/C-small-attempt0.in"",\
               outfile=""C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/output.txt""):
     
     #if not init:
         #build_dict()
     
     #Reading input
     linesA = []
     for line in open(infile, 'r'):
         linesA.append(line.strip())
 
     outA = []
         
     #Parsing Input
     T = int(linesA[0])
     for i in range(1, 1 + T):
         caseA = linesA[i].split()
         A = int(caseA[0])
         B = int(caseA[1])
         
         
         outA.append(0)
         #Calculating answer
         for i in range(A,B):
             for j in range(i + 1, B + 1):
                 #testing pair (i, j)
                 outA[-1] += int(isRecycled(i, j))
     
     #Writing Output
     out = open(outfile, 'w')
     print ""\nOUTPUT""
     for i in range(1, 1 + T):
         if i != 1:
             out.write(""\n"")
         print ""Case #"" + str(i) + "": "" +str(outA[i-1])
         out.write(""Case #"" + str(i) + "": "" +str(outA[i-1]))
     out.close()
     
 def isRecycled(n,m):
     '''
     Takes 2 integers and tells you if they are recycled
     '''
     a = str(n)
     b = str(m)
     if len(a) == len(b):
         for i in range(len(a)):
             if (a[i:] + a[:i]) == b:
                 return True
         
     return False
     
 if __name__ == ""__main__"":
     partCa()
",6,122,530
"def checkRow(r):
 	c = r[0];
 	
 	# making sure it isnt an empty line
 	if (c == '.'):
 		return (False, None)
 		
 	for i in range(1,4):
 		if not (r[i] == c or r[i] == 'T'):
 			return (False, None)
 	
 	# if it got this far it must be right
 	return (True, c)
 
 def checkCol(L, col):
 	c = L[0][col];
 	
 	# making sure it isnt an empty line
 	if (c == '.'):
 		return (False, None)
 		
 	for i in range(1,4):
 		if not (L[i][col] == c or L[i][col] == 'T'):
 			return (False, None)
 	
 	# if it got this far it must be right
 	return (True, c)
 	
 def checkDiag(L):
 	c = L[0][0];
 	
 	for i in range(1,4):
 		if not (L[i][i] == c or L[i][i] == 'T'):
 			break
 	else:
 		if (c != '.'):
 			# if it got this far it must be right
 			return (True, c)
 	
 	#first diag failed
 	c = L[0][3];
 	
 	# making sure it isnt an empty line
 	if (c == '.'):
 		return (False, None)
 		
 	for i in range(1,4):
 		if not (L[i][3-i] == c or L[i][3-i] == 'T'):
 			break
 	else:
 		# if it got this far it must be right
 		return (True, c)
 		
 	return (False, None)
 		
 def checkComplete(L):
 	for i in range(4):
 		if '.' in L[i]:
 			return False
 	return True
 
 def TicTacToeTomek(infile=""A-small-attempt0.in"", outfile=""A-small-attempt0.out""):
 	f = open(infile, 'r')
 	out = open(outfile, 'w')
 	
 	# get the number of tests
 	n = int(f.readline().strip())
 	
 	for t in range(1, n + 1):
 		L = []
 		# loading game
 		for i in range(4):
 			L.append(f.readline().strip());
 		
 		# checking game state
 		for i in range(4):
 			#checking row
 			result = checkRow(L[i])
 			if result[0]:
 				out.write(""Case #"" + str(t) + "": "" + result[1] + "" won\n"")
 				break
 			#checking column
 			result = checkCol(L,i)
 			if result[0]:
 				out.write(""Case #"" + str(t) + "": "" + result[1] + "" won\n"")
 				break
 		else:
 			#checking column
 			result = checkDiag(L)
 			if result[0]:
 				out.write(""Case #"" + str(t) + "": "" + result[1] + "" won\n"")
 			else:
 				if checkComplete(L):
 					out.write(""Case #"" + str(t) + "": Draw\n"")
 				else:
 					out.write(""Case #"" + str(t) + "": Game has not completed\n"")
 				
 		f.readline() #skipping empty line
 	
 	#closing files
 	f.close()
 	out.close()
 	
 	#so I dont need to cat the file after
 	f = open(outfile, 'r')
 	print f.read()
 	f.close()
 	
 	
 if __name__ == ""__main__"":
     TicTacToeTomek()",6,123,1151
"data_dict = {}
 init = False
 
 
 def partB(infile=""C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/input3.txt"",\
               outfile=""C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/output.txt""):
     
     #Reading input
     linesA = []
     for line in open(infile, 'r'):
         linesA.append(line.strip())
 
     outA = []
         
     #Parsing Input
     T = int(linesA[0])
     for i in range(1, 1 + T):
         caseA = linesA[i].split()
         N = int(caseA[0])
         S = int(caseA[1])
         P = int(caseA[2])
         
         #these will be exclusive
         over_norm = 0
         over_supr = 0
         
         #Calculating answer
         for t in [int(conv) for conv in caseA[3:3+N]]:
             if data_dict[t][0] >= P:
                 over_norm += 1
             elif data_dict[t][1] >= P:
                 over_supr += 1
         
         outA.append(over_norm + min(over_supr, S))
             
             
         
     
     #Writing Output
     out = open(outfile, 'w')
     print ""\nOUTPUT""
     for i in range(1, 1 + T):
         if i != 1:
             out.write(""\n"")
         print ""Case #"" + str(i) + "": "" +str(outA[i-1])
         out.write(""Case #"" + str(i) + "": "" +str(outA[i-1]))
     out.close()
 
 def dict_helper(total, depth=0, lowest=10):
     pass
 
 #Brute forcing this because my girlfriend is in my bed right now waiting for me
 #Its also running fast enough that it doesnt seem worth being clever
 def build_dict():
     for i in range(31):
         fullA = []
         maxN = 0
         maxS = 0
         print str(i) + "": ""
         for a1 in range(0,11):
             for a2 in range(0,11):
                 for a3 in range(0,11):
                     if (a1 + a2 + a3 == i) and (max(a1,a2,a3)-min(a1,a2,a3) <3):
                         fullA.append((a1,a2,a3))
                         
                         print ""\t"", fullA[-1],
                         if max(a1,a2,a3)-min(a1,a2,a3) == 2:
                             print ""*""
                             maxS = max(maxN, max(a1,a2,a3))
                         else:
                             print
                             maxN = max(maxN, max(a1,a2,a3))
         data_dict[i]=[maxN, maxS]
     init = True
     
 if __name__ == ""__main__"":
     build_dict()
     partB()
",6,124,812
"__author__ = 'Jeffrey'
 
 # inFileName = ""C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\D-sample.in""
 inFileName = ""C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\D-small-attempt0.in""
 # inFileName = ""C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\D-large.in""
 
 outFileName = inFileName[: -2] + ""out""
 
 
 def parseInput(f):
     T = int(f.readline())
     L = []
 
     for i in range(T):
         f.readline()
         L.append(([float(j) for j in f.readline().split()], [float(j) for j in f.readline().split()]))
         L[-1][0].sort()
         L[-1][1].sort()
 
     return T, L
 
 
 def calculateScores(naomi, ken):
     return [calcDeceit(naomi, ken), calcHonest(naomi, ken)]
 
 def calcDeceit(naomi, ken):
     wins = 0
     while len(naomi) > 0:
         if naomi[-1] > ken[-1]:
             naomi = naomi[ : -1]
             ken = ken[ : -1]
             wins += 1
         else:
             naomi = naomi[1: ]
             ken = ken[ : -1]
     return wins
 
 def calcHonest(naomi, ken):
     wins = 0
     while len(naomi) > 0:
         n = naomi.pop(0)
         k = ken[0]
         for i in range(len(ken)):
             kTemp = ken[i]
             if kTemp > n:
                 k = ken.pop(i)
                 break
         else:
             ken.pop(0)
             wins += 1
     return wins
 
 
 
 def playGame(T, L):
     for i in range(T):
         result = calculateScores(L[i][0], L[i][1])
         yield ""Case #{}: {} {}"".format(i + 1, result[0], result[1])
 
 
 if __name__ == ""__main__"":
     iF = open(inFileName, 'r')
     T, L = parseInput(iF)
     iF.close()
 
     print(T)
     for l in L:
         print()
         for k in l:
             print(k)
 
     oF = open(outFileName, ""wb"")
     for out in playGame(T, L):
         print(out)
         # print(bytes(out, 'utf-8'), file=oF)
         oF.write(bytes(out + ""\n"", 'utf-8'))
     oF.close()
",6,125,740
"#wont help, runs out of memory for 10^100
 # palindromeCache = {} #ideally this is precalculated
 
 # def isPalindrome(S):
 	# s = str(S) #so I dont need to make sure its a string
 	# if s in palindromeCache:
 		# return palindromeCache[s]
 		
 	# palindromeCache[s] = True
 	# for i in range(len(s)//2):
 		# if not s[i] == s[-1 - i]:
 			# palindromeCache[s] = False
 			# break
 	# return palindromeCache[s]
 	
 def isPalindrome(S):
 	s = str(S) #so I dont need to make sure its a string
 	for i in range(len(s)//2):
 		if not s[i] == s[-1 - i]:
 			return False
 	return True
 
 def FairAndSquare(infile=""C-small-attempt0.in"", outfile=""C-small-attempt0.out""):
 	inF = open(infile, 'r')
 	outF = open(outfile, 'w')
 	
 	for t in range(1, int(inF.readline().strip()) + 1):
 		temp = inF.readline().strip().split()
 		A = long(temp[0])
 		B = long(temp[1])
 		count = long(0)
 		
 		i = long(math.ceil(math.sqrt(A)))
 		m = long(math.floor(math.sqrt(B)))
 		while i <= m:
 			if isPalindrome(i):
 				if isPalindrome(i**2):
 					count += 1
 			i += 1
 					
 		outF.write(""Case #"" + str(t) + "": "" + str(count) + ""\n"")
 	
 	#closing files
 	inF.close()
 	outF.close()
 	
 	#so I dont need to cat the file after
 	f = open(outfile, 'r')
 	print f.read()
 	f.close()
 	
 	
 if __name__ == ""__main__"":
     FairAndSquare()",6,126,621
"= ""abcdefghijklmnopqrstuvwxyz""
 o = ""ynficwlbkuomxsevzpdrjgthaq""
         
 def partAfile(infile=""C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/input.txt"",\
               outfile=""C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/output.txt""):
     tempF = open(infile, 'r')
     tempA = []
     for line in tempF:
         tempA.append(line.strip())
         
     N = int(tempA[0])
     
     out = open(outfile, 'w')
     for i in range(1, 1+N):
         if i != 1:
             out.write(""\n"")
         print ""Case #"" + str(i) + "": "" +tempA[i].translate(maketrans(o,f))
         out.write(""Case #"" + str(i) + "": "" +tempA[i].translate(maketrans(o,f)))
         
     
 if __name__ == ""__main__"":
     partAfile()
",6,127,292
"__author__ = 'Jeffrey'
 
 # inFileName = ""C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\C-sample.in""
 inFileName = ""C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\C-small-attempt0.in""
 # inFileName = ""C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\C-large.in""
 
 outFileName = inFileName[: -2] + ""out""
 
 
 def parseInput(f):
     T = int(f.readline())
     L = []
 
     for i in range(T):
         L.append([int(i) for i in f.readline().split()])
 
     return T, L
 
 
 def calculateOneClick(R, C, M):
     size = R * C
     if R == 1 or C == 1 and M < size:
         return generateWinBoardBaseCase(R, C, M)
     elif size - M == 1:
         return generateWinBoardBaseCase(R, C, M)
     elif size - M >= 4:
         return generateWinBoard(R, C, M)
     return ""Impossible""
 
 def generateWinBoard(R,C,M):
     emptySpace = R * C - M - 4
     out = ""c""
     if C > 1:
         out += "".""
         for i in range(2,C):
             if emptySpace > 0:
                 out += "".""
                 emptySpace -= 1
             else:
                 out += ""*""
                 # out += '\n'
     if R > 1:
         out += '\n'
         out += "".""
         if C > 1:
             out += "".""
         for i in range(2,C):
             if emptySpace > 0:
                 out += "".""
                 emptySpace -= 1
             else:
                 out += ""*""
     for r in range(2,R):
         out += '\n'
         for c in range(C):
             if emptySpace > 0:
                 out += "".""
                 emptySpace -= 1
             else:
                 out += ""*""
     return out
 
 def generateWinBoardBaseCase(R,C,M):
     emptySpace = R * C - M - 1
     out = ""c""
     if C > 1:
         for c in range(1,C):
             if emptySpace > 0:
                 out += "".""
                 emptySpace -= 1
             else:
                 out += ""*""
     for r in range(1,R):
         out += '\n'
         for c in range(C):
             if emptySpace > 0:
                 out += "".""
                 emptySpace -= 1
             else:
                 out += ""*""
     return out
 
 
 def playGame(T, L):
     for i in range(T):
         result = calculateOneClick(L[i][0], L[i][1], L[i][2])
         yield ""Case #"" + str(i + 1) + "":\n"" + str(result)
 
 
 if __name__ == ""__main__"":
     iF = open(inFileName, 'r')
     T, L = parseInput(iF)
     iF.close()
 
     print(T)
     print(L)
 
     oF = open(outFileName, ""wb"")
     for out in playGame(T, L):
         print(out)
         # print(bytes(out, 'utf-8'), file=oF)
         oF.write(bytes(out + ""\n"", 'utf-8'))
     oF.close()
",6,128,913
"__author__ = 'Jeffrey'
 
 inFileName = ""C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\B-small-attempt0.in""
 outFileName = inFileName[ : -2] + ""out""
 
 
 def parseInput(f):
     T = int(f.readline())
     L = []
 
     for i in range(T):
         L.append([float(i) for i in f.readline().split()])
 
     return T, L
 
 
 def calculateWinTime(C, F, X):
     R = 2.0 # rate of cookie profit (cookies/s)
     totalTime = 0.0
     while (X / R >= C/R + X/(R + F)):
         totalTime += C / R
         R += F
     return totalTime + X / R
 
 
 def playGame(T,L):
     for i in range(T):
         result = calculateWinTime(L[i][0], L[i][1], L[i][2])
         yield ""Case #"" + str(i + 1) + "": "" + ""{:0.7f}"".format(result)
 
 
 if __name__==""__main__"":
     iF = open(inFileName, 'r')
     T, L = parseInput(iF)
     iF.close()
 
     print(T)
     print(L)
 
     oF = open(outFileName, ""wb"")
     for out in playGame(T, L):
         print(out)
         # print(bytes(out, 'utf-8'), file=oF)
         oF.write(bytes(out + ""\n"",'utf-8'))
     oF.close()
",6,129,433
"T = int(raw_input())
 for i in range(T):
   index = int(raw_input())
   X = []
   for j in range(4):
     X.append(map(int, raw_input().split()))
   x1 = X[index-1]
   index = int(raw_input())
   X = []
   for j in range(4):
     X.append(map(int, raw_input().split()))
   x2 = X[index-1]
   ans = set(x1).intersection(set(x2))
   if len(ans) == 0:
     print 'Case #%i: Volunteer cheated!' % (i+1)
   elif len(ans) == 1:
     print 'Case #%i: %i' % (i+1, ans.pop())
   else:
     print 'Case #%i: Bad magician!' % (i+1)
",7,130,224
"def up_down(board, height, y, x):
   # Move up from (x, y).
   above = y - 1
   while above >= 0:
     if board[above][x] > board[y][x]: 
       return False
     above -= 1
   # Move down from (x, y).
   below = y + 1
   while below < height:
     if board[below][x] > board[y][x]: 
       return False
     below += 1
   return True
   
 def left_right(board, width, y, x):
   # Move left from (x, y).
   before = x - 1
   while before >= 0:
     if board[y][before] > board[y][x]: 
       return False
     before -= 1
   # Move right from (x, y).
   after = y + 1
   while after < width:
     if board[y][after] > board[y][x]: 
       return False
     after += 1
   return True
   
 def check(board, height, width):
   if height == 1 or width == 1:
     return 'YES'
   for i in range(height):
     for j in range(width):
       if (not up_down(board, height, i, j)) and (not left_right(board, width, i, j)):
         return 'NO'
   return 'YES'
 
 n = int(raw_input().strip())
 for i in range(n):
   height, width = map(int,  raw_input().strip().split(' '))
   board = []
   for _ in range(height):
     row = map(int, raw_input().strip().split(' '))
     board.append(row)
   print 'Case #%i: %s' % (i+1, check(board, height, width))
",7,131,453
"(n, m):
     m = str(m)
     for i in range(len(m)):
         m = m[-1] + m[:-1]
         if n == int(m):
             return True
     return False
 
 T = int(sys.stdin.readline())
 for i in range(T):
     [A, B] = map(int, sys.stdin.readline().strip().split(' '))
     count = 0
     for n in range(A, B+1):
         for m in range(n, B+1):
             if n != m and isRecycledPair(n, m):
                 count += 1
     print 'Case #%s: %s' % (i + 1, count)
",7,132,181
"def check(board):
   # Check rows.
   for i in range(4):
     row = board[i]
     if set(row) in [set(['X', 'T']), set(['X'])]:
       return 'X won'
     if set(row) in [set(['O', 'T']), set(['O'])]:
       return 'O won'
   
   # Check columns.
   for i in range(4):
     column = []
     for j in range(4):
       column.append(board[j][i])
     if set(column) in [set(['X', 'T']), set(['X'])]:
       return 'X won'
     if set(column) in [set(['O', 'T']), set(['O'])]:
       return 'O won'
   
   # Check diagonal top_left->bottom_right
   diag1 = [board[0][0], board[1][1], board[2][2], board[3][3]]
   if set(diag1) in [set(['X', 'T']), set(['X'])]:
       return 'X won'
   if set(diag1) in [set(['O', 'T']), set(['O'])]:
     return 'O won'
   
   # Check diagonal top_right->bottom_left
   diag2 = [board[3][0], board[2][1], board[1][2], board[0][3]]
   if set(diag2) in [set(['X', 'T']), set(['X'])]:
       return 'X won'
   if set(diag2) in [set(['O', 'T']), set(['O'])]:
     return 'O won'
   
   for i in range(4):
     for j in range(4):
       if board[i][j] == '.':
         return 'Game has not completed'
   return 'Draw'
 
 n = int(raw_input().strip())
 for i in range(n):
   board = []
   for j in range(4):
     line = raw_input()
     board.append([c for c in line])
   raw_input()
   print 'Case #%i: %s' % (i+1, check(board))
",7,133,538
"(N, K):
   N = sorted(N)
   K = sorted(K)
   
   naomi = 0
   
   #if naomi can win then she should lose her lowest piece to do so
   #if kevin can win then he should lose his highest piece
   while len(N) > 0:
     # Naomi can win.
     if N[-1] > K[-1]:
       # Kevin loses highest piece.
       k = K.pop()
       # Naomi loses lowest piece necessary.
       for i, n in enumerate(N):
         if N[i] > k:
           choosen = i
           break
       del(N[choosen])
       naomi += 1
     # Naomi cannot win.
     else:
       # Naomi loses lowest piece.
       N = N[1:]
       k = K.pop()
   return naomi
 
 def war(N, K):
   N = sorted(N)
   K = sorted(K)
   
   naomi = 0
   while len(N) > 0:
     n = N.pop()
     chosen = None
     for i, k in enumerate(K):
       if k > n:
         chosen = i
         break
     if not chosen == None:
       del(K[chosen])
     else:
       naomi += 1
   return naomi
 
 T = int(raw_input())
 for t in range(T):
   _ = raw_input()
   N = map(float, raw_input().split())
   K = map(float, raw_input().split())
   
   print 'Case #%i: %i %i' % (t+1, dwar(N, K), war(N, K))
",7,134,422
"(s):
   length = len(s)
   for i in xrange(length / 2):
     if s[i] != s[length - 1 - i]: 
       return False
   return True
 
 n = int(raw_input())
 for i in range(n):
   a, b = map(int, raw_input().strip().split(' '))
   count = 0
   for j in range(a, b+1):
     if isPalindrome(str(j)):
       s = math.sqrt(j)
       if s == int(s) and isPalindrome(str(int(s))):
         count += 1
   print 'Case #%i: %i' % (i+1, count)
",7,135,179
"= [
     ['ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand'],
     ['rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities'],
     ['de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up']]
 
 trans = {'y': 'a', 'e': 'o', 'q': 'z', 'z': 'q'}
 for row in data:
     [googlerese, english] = row
     for i in range(0, len(googlerese)):
         if not googlerese[i] in trans:
             trans[googlerese[i]] = english[i]
 
 def translate(googlerese):
     english = ''
     for c in googlerese:
         english += trans[c]
     return english
 
 T = int(sys.stdin.readline())
 for i in range(T):
     print 'Case #%s: %s' % (i+1, translate(sys.stdin.readline().strip()))
",7,136,299
"(W, H, M):
   board = [['*' for x in xrange(H)] for x in xrange(W)]
   board[0][0] = 'c'
   
   S = [((H*W)-1, board, 0, 0, set())]
   H -= 1
   W -= 1
   while len(S) > 0:
     state = S.pop()
     mines = state[0]
     board = deepcopy(state[1])
     x = state[2]
     y = state[3]
     visited = deepcopy(state[4])
     visited.add((x, y))
     
     if mines == M:
       s = ''
       for row in board:
         s += ''.join(row)
         s += '\n'
       return s
     
     elif mines > M:
       # Up
       if x > 0 and board[x-1][y] == '*':
         board[x-1][y] = '.'
         mines -= 1
       
       # Down
       if x < W and board[x+1][y] == '*':
         board[x+1][y] = '.'
         mines -= 1
       
       # Left
       if y > 0 and board[x][y-1] == '*':
         board[x][y-1] = '.'
         mines -= 1
       
       # Right
       if y < H and board[x][y+1] == '*':
         board[x][y+1] = '.'
         mines -= 1
       
       # Up and Left
       if x > 0 and y > 0 and board[x-1][y-1] == '*':
         board[x-1][y-1] = '.'
         mines -= 1
       
       # Up and Right
       if x > 0 and y < H and board[x-1][y+1] == '*':
         board[x-1][y+1] = '.'
         mines -= 1
       
       # Down and Left
       if x < W and y > 0 and board[x+1][y-1] == '*':
         board[x+1][y-1] = '.'
         mines -= 1
       
       # Down and Right
       if x < W and y < H and board[x+1][y+1] == '*':
         board[x+1][y+1] = '.'
         mines -= 1
       
       # Up
       if x > 0 and not (x-1, y) in visited:
         S.append((mines, board, x-1, y, visited))
       
       # Down
       if x < W and not (x+1, y) in visited:
         S.append((mines, board, x+1, y, visited))
       
       # Left
       if y > 0 and not (x, y-1) in visited:
         S.append((mines, board, x, y-1, visited))
       
       # Right
       if y < H and not (x, y+1) in visited:
         S.append((mines, board, x, y+1, visited))
       
       # Up and Left
       if x > 0 and y > 0 and not (x-1, y-1) in visited:
         S.append((mines, board, x-1, y-1, visited))
       
       # Up and Right
       if x > 0 and y < H and not (x-1, y+1) in visited:
         S.append((mines, board, x-1, y+1, visited))
       
       # Down and Left
       if x < W and y > 0 and not (x+1, y-1) in visited:
         S.append((mines, board, x+1, y-1, visited))
       
       # Down and Right
       if x < W and y < H and not (x+1, y+1) in visited:
         S.append((mines, board, x+1, y+1, visited))
   return 'Impossible'
 
 T = int(raw_input())
 for t in range(T):
   W, H, M = map(int, raw_input().split())
   print 'Case #%i:\n%s' % (t+1, solve(W, H, M).strip())
",7,137,1066
"(15000)
 
 def solve(C, F, X, rate, time):
   if (time + (X / rate)) < ((C / rate) + ((X / (rate+F)) + time)):
     return time + (X / rate)
   else:
     return solve(C, F, X, rate+F, time + (C / rate))
 
 T = int(raw_input())
 for t in range(T):
   C, F, X = map(float, raw_input().split())
   print 'Case #%i: %.7f' % (t+1, solve(C, F, X, 2, 0))
",7,138,159
"T = int(input())
 for case in range(1,T+1):
     row1 = int(input())
     for i in range(1,5):
         l = input()
         if i==row1:
             first = set(int(x) for x in l.split())
     row2 = int(input())
     for i in range(1,5):
         l = input()
         if i==row2:
             second = set(int(x) for x in l.split())
     poss = first & second
     if len(poss) ==0:
         ans = 'Volunteer cheated!'
     elif len(poss) >1:
         ans = 'Bad magician!'
     else:
         ans = min(poss)
     print(""Case #"",case,"": "",ans,sep = '')
",8,139,196
"T=int(input())
 for t in range(T):
     a,b = [int(x) for x in input().split()]
     count = 0
     l = [0 for i in range(a,b+1)]
     for n in range(a,b):
         if l[n-a]:
             continue
         l[n-a]=1
         ms = set()
         s = str(n)
         for i in range(len(s)):
             m = int(s[i:]+s[:i])
             if n<m<=b:
                 l[m-a]=1
                 ms.add(m)
         case = len(ms)
         count+= (case*(case+1))//2
     print('Case #',t+1,': ',count,sep = '')
",8,140,194
"T = int(input().strip())
 
 def check(s,ans):
     #print(s,ans)
     if '.' in s:
         return ans if ans < 2 else 3
     if 'O' not in s:
         return 0
     if 'X' not in s:
         return 1
     return ans
 
 for case in range(1,T+1):
     ans = 2
     answers = [""X won"", ""O won"", ""Draw"", ""Game has not completed""]
     board = [0]*4
     for r in range(4):
         board[r] = input().strip()
     input()
     for row in board:
         ans = check(row,ans)
     for c in range(4):
         col = ''.join(board[r][c] for r in range(4))
         ans = check(col,ans)
     diag = ''.join(board[r][r] for r in range(4))
     ans = check(diag,ans)
     diag = ''.join(board[r][3-r] for r in range(4))
     ans = check(diag,ans)
     print(""Case #"",case,"": "",answers[ans],sep = '')
",8,141,297
"T=int(input())
 for t in range(T):
   l = [int(x) for x in input().split()]
   n,huh,p = l[:3]
   ss = l[3:]
   nice, maybe = 0,0
   for s in ss:
     if s>= p+2*max(p-1,0):
       nice += 1
     elif s>= p+2*max(p-2,0):
       maybe += 1
   y = nice + min(maybe,huh)
   print('Case #',t+1,': ',y,sep = '')
 
 
",8,142,151
"def findmin(l,y):
     for (i,x) in enumerate(l):
         if x>y:
             return i
     return None
 
 T = int(input())
 for case in range(1,T+1):
     N = int(input())
     Ns = [float(x) for x in input().split()]
     Ks = [float(x) for x in input().split()]
 
     Ns.sort()
     Ks.sort()
     bad = 0
 
     Ns1 = Ns[:]
     Ks1 = Ks[:]
     while Ns1:
         y = Ks1.pop()
         if Ns1[-1]>y:
             i = findmin(Ns1,y)
             Ns1[i:i+1]=[]
             bad += 1
         else:
             Ns1[:1] = []
 
     good = 0
     Ns2 = Ns[:]
     Ks2 = Ks[:]
     for x in Ns2:
         if Ks2[-1]>x:
             i = findmin(Ks2,x)
             Ks2[i:i+1]=[]
         else:
             Ks2[:1]=[]
             good += 1
 
     print(""Case #"",case,"": "",bad,' ',good,sep = '')
",8,143,336
"def checkpalin(s):
     k = len(s)//2
     for i in range(k):
         if s[i]!= s[-1-i]:
             return False
     return True
 
 goods = [1,2,3]
 
 for i in range(1000):
     for j in ['']+list(range(10)):
         test = str(i)+str(j)+(str(i)[::-1])
         if checkpalin(str(int(test)**2)):
             goods.append(int(test))
 goods = list(set(goods))
 goods.sort()
 
 T = int(input())
 
 for case in range(1,T+1):
     A,B = [int(x) for x in input().split()]
     ans = 0
     for n in goods:
         if A <= n*n <= B:
             ans += 1
     print(""Case #"",case,"": "",ans,sep='')
",8,144,239
"sub = {}
 sub['y']='a'
 sub['e']='o'
 sub['q']='z'
 sub[' ']=' '
 sub['z'] = 'q'
 
 pairs = [('ejp mysljylc kd kxveddknmc re jsicpdrysi','our language is impossible to understand'), ('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd','there are twenty six factorial possibilities'), ('de kr kd eoya kw aej tysr re ujdr lkgc jv','so it is okay if you want to just give up')]
 
 for (j,(a,b)) in enumerate(pairs):
   for i in range(len(a)):
     sub[a[i]] = b[i]
     #print(a[i],b[i])
 
 #print(''.join(sorted(sub.keys())))
 #print(''.join(sorted(sub.values())))
 
 T=int(input())
 for i in range(T):
   s = input().strip()
   new = ''.join([sub[c] for c in s])
   print('Case #',i+1,': ',new,sep = '')
 
 
",8,145,298
"T = int(input())
 
 def solve(R,C,M):
     # print('solving',R,C,M)
     if R>C:
         flipboard = solve(C,R,M)
         if flipboard:
             return [[flipboard[j][i] for j in range(C)] for i in range(R)]
         else:
             return
     if M==0:
         board = [['.']*C for i in range(R)]
         board[-1][-1] = 'c'
         return board
     if R == 1:
         board = ['*' if i<M else '.' for i in range(R*C)]
         board[-1] = 'c'
         return [board]
     if R == 2:
         if R*C==M+1:
             board = [['*']*C for i in range(R)]
             board[-1][-1] = 'c'
             return board
         if (M%2) or (M+2)==(R*C):
             return
         board = [['*' if i<(M/2) else '.' for i in range(C)] for j in range(R)]
         board[-1][-1] = 'c'
         return board
     if M>=R:
         subboard = solve(R,C-1,M-R)
         if subboard:
             return [['*']+r for r in subboard]
         return
     if (R,C,M) == (3,3,2):
         return
     k = min(M,C-2)
     board = [['*']*k+['.']*(C-k)]
     for i in range(M-k):
         board.append(['*']+['.']*(C-1))
     while len(board)<R:
         board.append(['.']*(C))
     board[-1][-1] = 'c'
     return board
     
          
     
 
 for case in range(1,T+1):
     print(""Case #"",case,"": "",sep='')
     R,C,M = (int(x) for x in input().split())
     ans = solve(R,C,M)
     if ans:
         for r in ans:
             print(''.join(r))
     else:
         print('Impossible')
 
 
 # for M in range(36):
 #     ans = solve(6,6,M)
 #     if ans:
 #         for r in ans:
 #             print(''.join(r))
 #     else:
 #         print('Impossible')
",8,146,636
"= int(input())
 for case in range(1,T+1):
     C,F,X = (Decimal(x) for x in input().split())
     
     ans = X/2
     time,rate = 0,2
     while True:
         if time >= ans:
             break
         ans = min(ans,(X/rate)+time)
         time,rate = time+(C/rate),rate+F
     print(""Case #"",case,"": "",ans,sep = '')
",8,147,117
"def solve():
     r1 = int(raw_input())
     a1 = [map(int, raw_input().split()) for i in xrange(4)]
     r2 = int(raw_input())
     a2 = [map(int, raw_input().split()) for i in xrange(4)]
     ans = -1
     for i in xrange(1, 17):
         if i in a1[r1-1] and i in a2[r2-1]:
             if ans != -1:
                 return ""Bad magician!""
             ans = i
     if ans == -1:
         return ""Volunteer cheated!""
     return ans
 for t in xrange(int(raw_input())):
     print ""Case #%d:"" % (t + 1), solve()
",9,148,193
"def solve(pre):
     read_ints = lambda: map(int, raw_input().split())
     h, w = read_ints()
     to = [read_ints() for _ in xrange(h)]
     lawn = [[100] * w for _ in xrange(h)]
     for i, r in enumerate(to):
         cut = max(r)
         for j in xrange(w):
             lawn[i][j] = min(lawn[i][j], cut)
     for i, c in enumerate(zip(*to)):
         cut = max(c)
         for j in xrange(h):
             lawn[j][i] = min(lawn[j][i], cut)
     if lawn == to:
         print pre, ""YES""
     else:
         print pre, ""NO""
 
 n = int(raw_input())
 for i in xrange(n):
     solve(""Case #%d:"" % (i + 1))
",9,149,237
"def solve(a, b):
     n = len(str(a))
     N = 10 ** n
     cnt = 0
     for x in xrange(a, b):
         y = x
         S = set([y])
         for j in xrange(n-1):
             y = y * 10
             y += y / N
             y %= N
             if a <= x < y <= b and y not in S:
                 cnt += 1
                 S.add(y)
     return cnt
 
 T = int(raw_input())
 for t in xrange(T):
     a, b = map(int, raw_input().split())
     print ""Case #%d: %d"" % (t + 1, solve(a, b))
",9,150,190
"T = int(raw_input())
 for t in xrange(T):
     line = map(int, raw_input().split())
     N, S, p = line[0:3]
     a = line[3:]
     cnt = 0
     a.sort(reverse=True)
     for x in a:
         if (x + 2) / 3 >= p:
             cnt += 1
         elif S > 0 and 2 <= x <= 28 and (x + 4) / 3 >= p:
             cnt += 1
             S -= 1
         else:
             break
     print ""Case #%d: %d"" % (t + 1, cnt)
",9,151,171
"*
 def solve():
     n = int(raw_input())
     a = map(float, raw_input().split())
     b = map(float, raw_input().split())
     a.sort()
     b.sort()
     da = deque(a)
     db = deque(b)
     k = 0
     while da:
         if da[0] < db[0]:
             da.popleft()
             db.pop()
         else:
             da.popleft()
             db.popleft()
             k += 1
     print k,
     k = 0
     for i, x in enumerate(a):
         j = bisect(b, x)
         k = max(k, j - i)
     print k
 for t in xrange(int(raw_input())):
     print ""Case #%d:"" % (t+1),
     solve()
",9,152,216
"from bisect import *
 a = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004, 100000020000001]
 A = a[:10]
 def subdfs(pre, mid, d, t, n):
     if d == t:
         k = long(''.join([pre, mid, pre[::-1]]))
         k = k * k
         if k > n:
             return [1, 0]
         sqk = str(k)
         if sqk == sqk[::-1]:
             A.append(k)
             return [0, 1]
         else:
             return [0, 0]
     res = subdfs(pre + '0', mid, d + 1, t, n)
     if res[0]: return res
     if not res[1]: return res
     res2 = subdfs(pre + '1', mid, d + 1, t, n)
     if res2[0]: return [1, res[1] + res2[1]]
     return [0, res[1] + res2[1]]
 
 def dfs(d, n):
     subdfs('1', '', 0, d, n)
     subdfs('2' + '0' * d, '', d, d, n)
     subdfs('1', '0', 0, d, n)
     subdfs('1', '1', 0, d, n)
     subdfs('1', '2', 0, d, n)
     subdfs('2' + '0' * d, '0', d, d, n)
     subdfs('2' + '0' * d, '1', d, d, n)
 
 def solve(pre):
     read_ints = lambda: map(int, raw_input().split())
     l, r = read_ints()
     cl = bisect_left(A, l)
     cr = bisect_right(A, r)
     cl_ = cr_ = 0
     for i in xrange(40):
         if a[i] < l: cl_ += 1
     for i in xrange(40):
         if a[i] <= r: cr_ += 1
     #print pre, cr_ - cl_
     print pre, cr - cl
 
 for k in xrange(1, 48):
     dfs(k, 10 ** 100 + 1)
 A.sort()
 N = int(raw_input())
 for i in xrange(1, N + 1):
     solve(""Case #%d:"" % i)
",9,153,1045
"= int(raw_input())
 S = """"""
 y qee
 ejp mysljylc kd kxveddknmc re jsicpdrysi
 rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
 de kr kd eoya kw aej tysr re ujdr lkgc jv
 z
 """"""
 T = """"""
 a zoo
 our language is impossible to understand
 there are twenty six factorial possibilities
 so it is okay if you want to just give up
 q
 """"""
 trans = {}
 for i in xrange(len(S)):
     trans[S[i]] = T[i]
 A = """"
 B = """"
 for (c, d) in trans.items():
     A += c
     B += d
 for i in xrange(n):
     print ""Case #%d: %s"" % (i + 1, raw_input().strip().translate(string.maketrans(A, B)))
",9,154,232
"():
     h, w, m = map(int, raw_input().split())
     if h == 1:
         print 'c' + '.' * (h * w - m - 1) + '*' * m
     elif w == 1:
         for c in 'c' + '.' * (h * w - m - 1) + '*' * m:
             print c
     elif h * w - m == 1:
         print 'c' + '*' * (w - 1)
         for _ in xrange(h-1):
             print '*' * w
     else:
         m = h * w - m
         for i in xrange(h-1):
             for j in xrange(w-1):
                 t = (i + 2) * 2 + (j + 2) * 2 - 4
                 r = (i + 2) * (j + 2)
                 if t <= m <= r:
                     a = [['*'] * w for _ in xrange(h)]
                     for k in xrange(i+2):
                         a[k][0] = '.'
                         a[k][1] = '.'
                     for k in xrange(j+2):
                         a[0][k] = '.'
                         a[1][k] = '.'
                     for y, x in product(range(2, i+2), range(2, j+2)):
                         if y == 1 and x == 1:
                             continue
                         if t >= m:
                             break
                         a[y][x] = '.'
                         t += 1
                     a[0][0] = 'c'
                     for s in a:
                         print ''.join(s)
                     return
         print 'Impossible'
 for t in xrange(int(raw_input())):
     print ""Case #%d:"" % (t + 1)
     solve()
",9,155,478
"def solve():
     c, f, x = map(float, raw_input().split())
     ans = 1e40
     cur = 0.0
     psp = 2.0
     while cur < ans + 1e-8:
         ans = min(ans, cur + x / psp)
         cur += c / psp
         psp += f
     return ans
 for t in xrange(int(raw_input())):
     print ""Case #%d: %.7f"" % (t + 1, solve())
",9,156,130
"= [map(int, line.strip().split("" "")) for line in open(sys.argv[1]).readlines()]
 [count] = lines[0]
 assert count * 10 + 1 == len(lines)
 
 for i in xrange(count):
     base = i*10
     [n1] = lines[base+1]
     [n2] = lines[base+6]
     row1 = set(lines[base+1+n1])
     row2 = set(lines[base+6+n2])
     common = row1.intersection(row2)
     print ""Case #%s:"" % (i+1),
     if len(common) == 1:
         print list(common)[0]
     elif not common:
         print ""Volunteer cheated!""
     else:
         print ""Bad magician!""
",10,157,207
"= sys.stdin
 for c in xrange(int(stdin.readline())):
     n,m = map(int, stdin.readline().split())
     rows = [map(int, stdin.readline().split()) for i in xrange(n)]
     cols = [[row[i] for row in rows] for i in xrange(m)]
 
     rowmaxs = [max(x) for x in rows]
     colmaxs = [max(x) for x in cols]
 
     verdict = ""YES""
     for i in xrange(n):
         for k in xrange(m):
             if min(rowmaxs[i], colmaxs[k]) > rows[i][k]:
                 verdict = ""NO""
                 break
 
         if verdict == ""NO"": break
 
     print ""Case #%i: %s"" % (c+1, verdict)
",10,158,221
"= [int(10**k) for k in xrange(0,16)]
 
 T = int(stdin.readline())
 
 for i in xrange(1,T+1):
 	a,b = map(int, stdin.readline().split())
 	t = 0
 	m = len(str(a))
 
 	pp = int(10**m)
 
 	for n in xrange(a,b):
 		ss = []
 		q = 1
 		p = pp
 		for j in xrange(1,m):
 			q *= 10
 			p /= 10
 			r = (n % p) * q + (n /p)
 			if n < r and r <= b and not r in ss: 
 				ss.append(r)
 				t += 1
 
 
 	print ""Case #%d: %d"" % (i,t)
 
",10,159,260
"= sys.stdin
 ixs = range(4)
 for i in xrange(int(stdin.readline())):
     print ""Case #%i: "" % (i+1),
     rows = [stdin.readline()[:4] for i in ixs]
 
     cols = [[row[i] for row in rows] for i in ixs]
     diags = [
         [rows[i][i] for i in ixs],
         [rows[i][3-i] for i in ixs]
     ]
     notdone = False
     for row in rows + cols + diags:
         x = None
         for t in row:
             if t == '.':
                 notdone = True
                 break
             elif t == 'T':
                 continue
             elif x is not None and x != t:
                 break
             else:
                 x = t
         else:
             print x, ""won""
             break
     else:
         if notdone: print ""Game has not completed""
         else:       print ""Draw""
 
     stdin.readline()
",10,160,261
"= open(sys.argv[1])
 count = int(f.readline())
 
 for i in xrange(0, count):
     n = int(f.readline())
     naomis = sorted(map(float, f.readline().split()))
     kens = sorted(map(float, f.readline().split()))
     assert len(naomis) == n and len(kens) == n
 
     naomis_w = set(naomis)
     kens_w = set(kens)
     naomi_war_wins = 0
     while naomis_w:
         nao = max(naomis_w)
         try:
             ken = min(w for w in kens_w if w > nao)
         except ValueError:
             ken = min(kens_w)
             naomi_war_wins += 1
         naomis_w.remove(nao)
         kens_w.remove(ken)
 
     naomi_deceit_wins = 0
     naomis_w = set(naomis)
     kens_w = set(kens)
     while naomis_w:
         ken = min(kens_w)
         try:
             nao = min(w for w in naomis_w if w > ken)
             naomi_deceit_wins += 1
         except ValueError:
             nao = min(naomis_w)
         naomis_w.remove(nao)
         kens_w.remove(ken)
 
     print ""Case #%s: %s %s"" % (i+1, naomi_deceit_wins, naomi_war_wins)
",10,161,422
"(n):
     s = str(n)
     return s == s[::-1] 
 
 palindromes = [[], [1,2,3,4,5,6,7,8,9], [11,22,33,44,55,66,77,88,99]]
 all_palindromes = palindromes[1] + palindromes[2]
 limit = [100]
 
 palindromic_squares = []
 psqtop = 0
 psqix = 0
 
 stdin = sys.stdin
 for c in xrange(int(stdin.readline())):
     a,b = map(int, stdin.readline().split())
 
     while psqtop < b:
         while psqix >= len(all_palindromes):
             ps = []
             pp = 10 ** (len(palindromes)-1) + 1
             for i in range(1,10):
                 for p in palindromes[-2]:
                     ps.append(i * pp + 10 * p) 
             palindromes.append(ps)
             all_palindromes.extend(ps)
 
         sq = all_palindromes[psqix] * all_palindromes[psqix]
         if is_palindrome(sq):
             palindromic_squares.append(sq)
         psqix  += 1
         psqtop = sq
 
     aix = bisect.bisect_left(palindromic_squares, a)
     bix = bisect.bisect_right(palindromic_squares, b)
 
     print ""Case #%i: %i"" % (c+1, bix-aix) 
",10,162,445
"= """"""
 y qee
 ejp mysljylc kd kxveddknmc re jsicpdrysi
 rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
 de kr kd eoya kw aej tysr re ujdr lkgc jv
 z
 """"""
 
 plain = """"""
 a zoo
 our language is impossible to understand
 there are twenty six factorial possibilities
 so it is okay if you want to just give up
 q
 """"""
 
 gtos = {}
 stog = {}
 
 for s,g in zip(plain, googlerese):
 	gtos[g] = s
 	stog[s] = g
 
 #for c in ""abcdefghijklmnopqrstuvwxyz"":
 #	print c, stog.get(c, None), gtos.get(c,None)
 
 f = sys.stdin
 
 t = int(f.readline())
 
 for i in xrange(0,t):
 	line = f.readline().strip()
 	print ""Case #%d: %s"" % (i+1, """".join([gtos.get(c,c) for c in line]))
 
",10,163,301
"= [line.strip() for line in open(sys.argv[1])]
 count = int(lines[0])
 
 for i in xrange(count):
     R,C,M = map(int, lines[i+1].split())
     print ""Case #%s:"" % (i+1)
 
     w = max(R,C)
     h = min(R,C)
     X = R*C - M
     assert X > 0
 
     if X == 1:
         rows = ['c' + ('*' * (w-1))] + (h-1) * ['*' * w]
     elif h == 1:
         rows = ['c' + '.' * (X-1) + '*' * M]
     elif X == 4:
             rows = [
                 'c.' + '*' * (w-2),
                 '..' + '*' * (w-2),
             ] + ['*' * w] * (h-2)
     elif h == 2:
         if X%2 == 1 or X == 2:
             rows = None
         else:
             rows = [
                 'c' + '.' * (X/2-1) + '*' * (M/2),
                 '.' + '.' * (X/2-1) + '*' * (M/2)
             ]
     elif X <= 5 or X == 7:
         rows = None
 
     elif X%2 == 0 and X <= w*2:
         r = X/2
         rows = [
             'c' + '.' * (r - 1) + '*' * (w-r),
                   '.' * r       + '*' * (w-r),
         ] + ['*' * w] * (h-2)
 
     elif X <= w*3 and (X % 3) != 1:
         n = (X+1) / 3
         t = X - 2*n
         rows = [
             'c' + '.' * (n-1) + '*' * (w-n),
                   '.' * n     + '*' * (w-n),
                   '.' * t     + '*' * (w-t)
         ] + ['*' * w] * (h-3)
     else:
         n = X / w
         t = X % w
         if t == 1:
             rows = (
                     ['c' + (w-1) * '.']
                 +   ['.' * w] * (n-2)
                 +   ['.' * (w-1) + '*']
                 +   ['..' + '*' * (w-2)]
                 +   ['*' * w] * (h - n - 1)
             )
         else:
             k = 1 if t == 0 else 0
             rows = (
                     ['c' + (w-1) * '.']
                 +   ['.' * w] * (n-1)
                 +   ['.' * t + '*' * (w-t)] * (1 - k)
                 +   ['*' * w] * (h - n - 1 + k)
             )
 
     if rows:
         if R > C:
             rows = ["""".join(row[i] for row in rows) for i in xrange(R)]
 
         for row in rows:
             print row
 
         assert len(rows) == R
         assert len(rows[0]) == C
         assert sum(1 for row in rows for col in row if col == '*') == M
 
     else:
         print ""Impossible""
 
",10,164,896
"= [line.strip() for line in open(sys.argv[1])]
 count = int(lines[0])
 
 for i in xrange(count):
     farm_cost,farm_production,target = map(float, lines[i+1].split())
     seconds = 0
     production = 2
     best = float(""inf"")
     while True:
         best = min(best, seconds + target / production)
         seconds += farm_cost / production
         if seconds >= best: break
         production += farm_production
 
     print ""Case #%s: %.7f"" % (i+1, best)
",10,165,150
"== ""__main__"":
 	f = open( sys.argv[1] )
 	int(f.readline())
 		
 	num = 1
 	l = f.readline()
 	while l != """":
 		row1 = int(l)
 		rows = [ f.readline() for x in range(4) ]
 		row1 = [int(x) for x in rows[row1-1].split()]
 
 		row2 = int(f.readline())
 		rows = [f.readline() for x in range(4)]
 		row2 = [int(x) for x in rows[row2-1].split()]
 
 		result = set(row1) & set(row2)
 		if len(result) == 1:
 			output = str(result.pop())
 		elif len(result) > 1:
 			output = ""Bad magician!""
 		else:
 			output = ""Volunteer cheated!""
 
 		print ""Case #""+str(num)+"": ""+output
 		num += 1
 		l = f.readline()
 		",11,166,306
"= open( sys.argv[1] )
 t = int(f.readline())
 
 t = 1
 l = f.readline()
 while l != """":
     n,m = [int(x) for x in l.split()]
     lawn = [ [int(x) for x in f.readline().split()] for y in range(n)]
 
     rowMax = [ max(x) for x in lawn ]
     colMax = [ max([x[y] for x in lawn]) for y in range(m) ]
 
     output = ""YES""
 
     for i in range(n):
         for j in range(m):
             if lawn[i][j] < rowMax[i]:
                 if lawn[i][j] < colMax[j]:
                     output = ""NO""
     
     print ""Case #%s: %s""%(t,output)
     t += 1
     l = f.readline()
",11,167,238
"== ""__main__"":
     f = open( ""C-small-attempt0.in.txt"" )
     g = open( ""output_small.txt"", ""w"" )
 
     numcases = int(f.readline())
 
     caseI = 1
     line = f.readline()
     while line != """":
         A,B = [int(x) for x in line.split()]
 
         matched = [0]*(B+1)
         pairs = deque()
 
         for x in range(A,B+1):
             if matched[x]:
                 continue
             a = str(x)
             allcycle = deque()
             allcycle.append(x)
             for i in range(1,len(a)):
                 yL,yR = a[:i],a[i:]
                 y = int( yR+yL )
                 if y >= A and y <= B:
                     allcycle.append(y)
             allcycle = list(set(allcycle))
             allcycle.sort()
             for y in allcycle:
                 matched[y] = 1
             for i in range(len(allcycle)):
                 for j in range(i+1,len(allcycle)):
                     pairs.append( (allcycle[i],allcycle[j]) )
         g.write( ""Case #%s: %s\n""%(caseI,len(pairs)) )
         line = f.readline()
         caseI += 1
     f.close()
     g.close()
",11,168,374
"= open( sys.argv[1] )
 t = f.readline()
 
 t = 1
 line = f.readline()
 while line != """":
     board = [line.strip(),
              f.readline().strip(),
              f.readline().strip(),
              f.readline().strip()]
 
     output = """"
 
     cols = [ """".join([x[y] for x in board]) for y in range(4)]
     diags = ["""".join([x[y] for x,y in zip(board,range(4))]),
              """".join([x[y] for x,y in zip(board,range(-1,-5,-1))])]
     
     rows = board + cols + diags
 
     for row in rows:
         x = [1 for z in row if z is ""X"" or z is ""T""]
         if sum(x) == 4:
             output = ""X won""
             break
         o = [1 for z in row if z is ""O"" or z is ""T""]
         if sum(o) == 4:
             output = ""O won""
             break
     if output == """":
         finished = sum([ y.count(""."") for y in board ])
         if finished == 0:
             output = ""Draw""
         else:
             output = ""Game has not completed""
     
     print ""Case #%s: %s""%(t,output)
     t += 1
     line = f.readline()
     line = f.readline()
",11,169,373
"##all_trips = {}
 ##
 ##for i in range(10+1):
 ##    for j in range(i,min(i+3,10+1)):
 ##        for k in range(i,min(i+3,10+1)):
 ##            trip = [i,j,k]
 ##            trip.sort()
 ##            trip = tuple(trip)
 ##            isSurp = 0
 ##            if max(trip)-min(trip) > 2:
 ##                sys.stderr.write( ""Err in trip."")
 ##                break
 ##            if max(trip)-min(trip) == 2:
 ##                isSurp = 1
 ##            points = sum(trip)
 ##            try:
 ##                all_trips[points].add( (max(trip),isSurp,trip) )
 ##            except KeyError:
 ##                all_trips[points] = set()
 ##                all_trips[points].add( (max(trip),isSurp,trip) )
 ##
 ##for x in all_trips:
 ##    all_trips[x] = list(all_trips[x])
 ##    all_trips[x].sort()
 ##    print x, (x+2)/3, (x+2)%3, all_trips[x]
 
 if __name__ == ""__main__"":
 
     f = open( ""B-small-attempt1.in.txt"" )
     g = open( ""output_small.txt"", ""w"" )
 
     f.readline()
     line = f.readline()
     caseI = 1
     while line != """":
         line = [ int(x) for x in line.split() ]
         N = line[0]
         surprise = line[1]
         p = line[2]
         points = line[3:]
         points.sort()
         points.reverse()
 
         maxp = 0
         either = 0
         make_surprise = 0
         for x in points:
             this_p = (x+2)/3
             if x in [0,1,29,30]:
                 if this_p >= p:
                     maxp += 1
             elif this_p >= p:
                 either += 1
                 maxp += 1
             elif this_p == p-1 and (x+2)%3 > 0:
                 make_surprise += 1
             else:
                 either += 1
 
         if make_surprise >= surprise:
             make_surprise -= surprise
             maxp += surprise
             make_surprise = 0
         else:
             maxp += make_surprise
 
         g.write( ""Case #%s: %s\n""%(caseI,maxp) )
 
         line = f.readline()
         caseI += 1
 
     f.close()
     g.close()
     
",11,170,719
"= open(sys.argv[1])
 f.readline()
 
 numCase = 1
 l = f.readline()
 while l != """":
 	n = [float(x) for x in f.readline().split()]
 	k = [float(x) for x in f.readline().split()]
 
 	n.sort()
 	nd = deque(n)
 	k.sort()
 	kd = deque(k)
 
 	war = 0
 	while len(nd) > 0:
 		nblock = nd.pop()
 		if nblock > kd[-1]:
 			kd.popleft()
 			war += 1
 		else:
 			kd.pop()
 
 	all = [ (x,1) for x in n ]
 	all.extend( [(x,2) for x in k] )
 	all.sort()
 
 	dwar = 0
 	nd = deque(n)
 	kd = deque(k)
 	while len(nd) > 0:
 		if nd[0] < kd[0]:
 			kd.pop()
 		else:
 			kd.popleft()
 			dwar += 1
 		nd.popleft()
 		
 	print ""Case #""+str(numCase)+ "": ""+str(dwar)+"" ""+str(war)
 	
 
 	numCase += 1
 	l = f.readline()",11,171,399
"(x):
     x = str(x)
     if x[0] != x[-1]:
         return 0
     y = x[::-1]
     if x == y:
         return 1
     return 0
 
 def generate():
     digits = [str(x) for x in range(0,10)]
     dplus = digits + [""""]
 
     for x in range(1,10):
         y = x**2
         if isPalindrome(y):
             print y
 
     for x in range(1,10**4):
         x = str(x)
         y = x[::-1]
         pals = [ int(x+z+y)**2 for z in dplus ]
         for p in pals:
             if isPalindrome(p):
                 print p
 
 if __name__ == ""__main__"":
     #generate()
     #break
     f = open( sys.argv[1] )
     sqpals = np.array([int(l) for l in f])
     sqpals.sort()
     f.close()
 
     f = open( sys.argv[2] )
     t = int(f.readline())
     t = 1
     for l in f:
         a,b = [int(x) for x in l.split()]
         mt = sqpals >= a
         lt = sqpals <= b
         output = sum( mt&lt )
         print ""Case #%s: %s""%(t,output)
         t += 1
     
",11,172,386
"= ""ejp mysljylc kd kxveddknmc re jsicpdrysi rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcdde kr kd eoya kw aej tysr re ujdr lkgc jvyeqz""
 s2 = ""our language is impossible to understand there are twenty six factorial possibilitiesso it is okay if you want to just give upaozq""
 
 mapd = string.maketrans(s1,s2)
 #print ""abcdefghijklmnopqrstuvwxyz""
 #print ""abcdefghijklmnopqrstuvwxyz"".translate(mapd)
 
 f = open( ""A-small-attempt0.in.txt"" )
 g = open( ""output_small.txt"",""w"")
 
 f.readline()
 l = f.readline()
 caseI = 1
 while l != """":
     output = l.translate(mapd)
 
     g.write( ""Case #%s: %s""%(caseI,output) )
     l = f.readline()
     caseI += 1
 f.close()
 g.close()
",11,173,291
"(b):
 	numR, numC, numMines, filledR, filledC = b
 	q = numMines / numR
 	r = numMines % numR
 
 	if q <= numC-2 and r == 0:
 		board = [""*""*(filledC + numC) for x in range (filledR)]
 		board.append( ""*""*(filledC+q)+"".""*(numC-q) )
 		board.append( ""*""*(filledC+q)+"".""*(numC-q-1)+""c"" )
 		output = ""\n"".join(board)
 	elif numMines == numR * numC - 1:
 		board = [""*""*(filledC + numC) for x in range (filledR+1)]
 		board.append( ""*""*(filledC+numC-1)+""c"" )
 		output = ""\n"".join(board)
 	else:
 		output = ""Impossible""
 
 	return output
 
 def makeBoardC(b):
 	numR, numC, numMines, filledR, filledC = b
 	q = numMines / numC
 	r = numMines % numC
 
 	if q <= numR-2 and r == 0:
 		board = [""*""*(filledC+numC) for x in range(filledR+q)]
 		for x in range( numR-1-q ):
 			board.append( ""*""*filledC + "".."" )
 		board.append( ""*""*filledC + "".c"" )
 		output = ""\n"".join(board)
 	elif numMines == numR * numC - 1:
 		board = [""*""*(filledC+numC) for x in range(filledR+numR-1)]
 		board.append( ""*""*(filledC+numC-1) + ""c"" )
 		output = ""\n"".join(board)
 	else:
 		output = ""Impossible""
 	return output
 
 def makeBoard(b):
 	numR, numC, numMines, filledR, filledC = b
 	q = numMines / (numC-2)
 	r = numMines % (numC-2)
 
 	board = [""*""*(numC+filledC) for x in range(filledR)]
 	for x in range(q):
 		board.append( ""*""*(numC-2+filledC)+"".."" )
 	board.append( ""*""*(r+filledC)+"".""*(numC-r) )
 	for x in range(numR-q-2):
 		board.append( ""*""*filledC+"".""*numC )
 	board.append( ""*""*filledC + "".""*(numC-1) + ""c"" )
 	return ""\n"".join(board)
 
 def makeBoard0(b):
 	numR,numC,numMines,filledR,filledC = b
 	board = [""*""*(numC+filledC) for x in range(filledR)]
 	for x in range(numR-1):
 		board.append( ""*""*(filledC)+"".""*numC )
 	board.append( ""*""*(filledC) + "".""*(numC-1) + ""c"" )
 	return ""\n"".join(board)
 
 f = open( sys.argv[1] )
 f.readline()
 
 numCase = 1
 l = f.readline()
 while l != """":
 	numR, numC, numMines = [int(x) for x in l.split()]
 
 	boards = deque()
 	if numR == 1:
 		if numC == 1 and numMines == 0:
 			output = ""c""
 		elif numC == 1 and numMines > 0:
 			output = ""Impossible""
 		else:
 			output = ""*""*numMines + "".""*(numC-numMines-1) + ""c""
 	elif numC == 1:
 		output = ""\n"".join(""*""*numMines + "".""*(numR-numMines-1) + ""c"")
 	else:
 		boards.append( (numR,numC,numMines,0,0) )
 		output = ""Impossible""
 
 	while output == ""Impossible"" and len(boards) > 0:
 		b = boards.popleft()
 		#print b
 		numR,numC,numMines,filledR,filledC = b
 		if numMines == 0:
 			output = makeBoard0(b)
 			break
 
 		if numMines >= numC and numR > 2:
 			boards.append( (numR-1,numC,numMines-numC,filledR+1,filledC) )
 		if numMines >= numR and numC > 2:
 			boards.append( (numR,numC-1,numMines-numR,filledR,filledC+1) )
 
 		if numMines <= (numR-2)*(numC-2):
 			output = makeBoard(b)
 
 		if numR == 2:
 			output = makeBoardR(b)
 
 		if numC == 2:
 			output = makeBoardC(b)
 		
 	print ""Case #""+str(numCase)+"":\n""+output
 	#print ""Case #""+str(numCase)+"": "" +l+output
 	l = f.readline()
 	numCase += 1
",11,174,1461
"#!/usr/bin/python
 
 = open(sys.argv[1],'r')
 
 num = int(f.readline())
 
 for i in range(num):
     q1 = int(f.readline())
     for j in range(4):
         if j+1 == q1:
             line1 = f.readline()
         else:
             f.readline()
     q2 = int(f.readline())
     for j in range(4):
         if j+1 == q2:
             line2 = f.readline()
         else:
             f.readline()
     line1 = [int(x) for x in line1.split()]
     line2 = [int(x) for x in line2.split()]
     count = 0
     for x in line1:
         if x in line2:
             count += 1
             y = x
     if count == 0:
         print 'Case #{}: Volunteer cheated!'.format(i+1)
     elif count == 1:
         print 'Case #{}: {}'.format(i+1, y)
     else:
         print 'Case #{}: Bad magician!'.format(i+1)
",12,175,294
"#!/usr/bin/python
 
 = open(sys.argv[1],'r')
 
 num = int(f.readline())
 
 for i in range(num):
     l = f.readline()
     n,m = l.split()
     n = int(n)
     m = int(m)
     lawn = []
     seen = []
     for j in range(n):
         l = f.readline()
         lawn.append([int(x) for x in l.split()])
         seen.append([False]*m)
     #print lawn
     l = []
     for j in range(n):
         for k in range(m):
             l.append((lawn[j][k], (j,k)))
     l.sort(key=operator.itemgetter(0))
     #print l
     ok = True
     for x in l:
         if seen[x[1][0]][x[1][1]]:
             continue
         row = True
         for j in range(n):
             if not (seen[j][x[1][1]] or lawn[j][x[1][1]] <= lawn[x[1][0]][x[1][1]]):
                 row = False
                 break
         if(row):
             for j in range(n):
                 seen[j][x[1][1]] = True
             continue
         col = True
         for j in range(m):
             if not (seen[x[1][0]][j] or lawn[x[1][0]][j] <= lawn[x[1][0]][x[1][1]]):
                 col = False
                 break
         if(col):
             for j in range(m):
                 seen[x[1][0]][j] = True
             continue
         ok = False
         break
     if ok:
         print 'Case #{}: YES'.format(i+1)
     else:
         print 'Case #{}: NO'.format(i+1)
",12,176,487
"#!/usr/bin/python
 
 (x, d):
     perm = []
     for i in range(1,d):
         n = x / 10**i
         r = x % 10**i
         #print 'p', i, n, r
         if r >= 10**(i-1):
             perm.append(r * 10**(d-i) + n)
     perm = list(set(perm))
     while x in perm:
         perm.remove(x)
     return perm
 
 f = open(sys.argv[1],'r')
 
 num = int(f.readline())
 
 for i in range(num):
     n1, n2 = [int(x) for x in f.readline().split()]
     d = int(math.floor(math.log10(n1))) + 1
     rec = 0
     for j in range(n1,n2+1):
         p = permute(j, d)
         #print j,p
         rec += sum([1 for x in p if x >= n1 and x <= n2])
         #print rec
     print 'Case #{}:'.format(i+1), rec/2
",12,177,295
"#!/usr/bin/python
 
 = open(sys.argv[1],'r')
 
 num = int(f.readline())
 
 def check(x, mat):
     for i in range(4):
         row = True
         col = True
         for j in range(4):
             if not (mat[i][j] == x or mat[i][j] == 'T'):
                 row = False
             if not (mat[j][i] == x or mat[j][i] == 'T'):
                 col = False
         if row or col:
             return True
     diag1 = True
     diag2 = True
     for i in range(4):
         if not (mat[i][i] == x or mat[i][i] == 'T'):
             diag1 = False
         if not (mat[3-i][i] == x or mat[3-i][i] == 'T'):
             diag2 = False
     if diag1 or diag2:
         return True
     return False
 
 def fin(mat):
     for i in range(4):
         for j in range(4):
             if mat[i][j] == '.':
                 return False
     return True
 
 for i in range(num):
     mat = []
     for j in range(4):
         mat.append(list(f.readline().strip()))
     f.readline()
     #print mat
     #print check('X', mat), check('O', mat)
     if check('X', mat):
         print 'Case #{}: X won'.format(i+1)
     elif check('O', mat):
         print 'Case #{}: O won'.format(i+1)
     elif fin(mat):
         print 'Case #{}: Draw'.format(i+1)
     else:
         print 'Case #{}: Game has not completed'.format(i+1)
",12,178,450
"#!/usr/bin/python
 
 = open(sys.argv[1],'r')
 
 num = int(f.readline())
 
 for i in range(num):
     res = [int(x) for x in f.readline().split()]
     nrg, nrsup, score = res[0:3]
     del res[0:3]
     #print nrg, nrsup, score, res
     nrpass = 0
     nrsuppass = 0
     for x in res:
         if score > 1:
             if x >= 3*score-2:
                 nrpass += 1
             elif x >= 3*score-4:
                 nrsuppass += 1
         elif score == 1:
             if x > 0:
                 nrpass += 1
         else:
             nrpass +=1
     print 'Case #{}:'.format(i+1), nrpass + min(nrsup, nrsuppass)
",12,179,233
"#!/usr/bin/python
 
 = open(sys.argv[1],'r')
 
 num = int(f.readline())
 
 for i in range(num):
     f.readline()
     na = [float(x) for x in f.readline().split()]
     ke = [float(x) for x in f.readline().split()]
     na.sort()
     ke.sort()
     dw = 0
     index = 0
     for x in ke:
         while index < len(na) and na[index] <= x:
             index += 1
         if index == len(na):
             break
         dw += 1
         index += 1
     w = 0
     index = 0
     na.reverse()
     ke.reverse()
     for x in na:
         if ke[index] > x:
             index += 1
         else:
             w += 1
     print 'Case #{}: {} {}'.format(i+1, dw, w)
",12,180,246
"#!/usr/bin/python
 
 = open(sys.argv[1],'r')
 
 num = int(f.readline())
 
 def pal(x):
     l = list(str(x))
     l2 = copy.copy(l)
     l2.reverse()
     return l == l2
 
 for i in range(num):
     count = 0
     line = f.readline()
     a,b = line.split()
     a = int(a)
     b = int(b)
     ma = int(math.sqrt(a))
     mb = int(math.sqrt(b))+1
     #print a,b
     for j in range(ma,mb+1):
         q = j*j
         if q < a or q > b:
             continue
         #print i*i
         if pal(j) and pal(q):
             #print i,q
             count += 1
     print 'Case #{}:'.format(i+1), count
",12,181,243
"#!/usr/bin/python
 
 = open(sys.argv[1],'r')
 
 num = int(f.readline())
 
 for i in range(num):
     s = f.readline().strip()
     t = s.translate(string.maketrans(""yeqjpmslckdxvnribtahwfougz"",
         ""aozurlngeismpbtdhwyxfckjvq""))
     #print 'Case #{}:'.format(i+1), s
     print 'Case #{}:'.format(i+1), t
",12,182,137
"#!/usr/bin/python
 
 = open(sys.argv[1],'r')
 
 num = int(f.readline())
 
 for i in range(num):
     c, e, x = [float(x) for x in f.readline().split()]
     n = int((x*e-2*c)/(c*e))
     if n < 0:
         n = 0
     t = 0
     for j in range(n):
         t += c/(2+j*e)
     t += x/(2+n*e)
     print 'Case #{}: {}'.format(i+1, t)
",12,183,157
"T = int(input())
 
 for i in range(T):
     a1 = int(input())
     mat1 = [list(map(int, input().split())) for k in range(4)]
     a2 = int(input())
     mat2 = [list(map(int, input().split())) for k in range(4)]
     final_set = set(mat1[a1 - 1]) & set(mat2[a2 - 1])
     if not len(final_set):
         s = 'Volunteer cheated!'
     elif len(final_set) > 1:
         s = 'Bad magician!'
     else:
         s = list(final_set)[0]
     print('Case #{}: {}'.format(i + 1, s))
",13,184,187
"#!/usr/bin/env python3
 # -*- encoding: utf-8 -*-
 
 
 def f(m):
     max_cols = []
     for e in zip(*m):
         max_cols.append(max(e))
 
     for r in m:
         max_row = max(r)
         for y, c in enumerate(r):
             if c != max_row and c != max_cols[y]:
                 return 'NO'
     return 'YES'
 
 if __name__ == '__main__':
     T = int(input())
     for i in range(T):
         n, m = map(int, input().split())
         r = f([input().split() for i in range(n)])
         print('Case #{}: {}'.format(i+1, r))
",13,185,198
"#!/usr/bin/env python2.7
 
 T = int(raw_input())
 for i in xrange(T):
     values = map(int, raw_input().split())
     [N,s,p] = values[0:3]
     t = values[3:]
     answer = 0
     for note in t:
         if note < 2:
             if note >= p:
                 answer += 1
         elif note % 3 == 1 and (note-1) / 3 + 1 >= p:
             answer += 1
         elif note % 3 == 0:
             n = note / 3
             if n >= p:
                 answer += 1
             elif s > 0 and n + 1 >= p:
                 answer += 1
                 s -= 1
         elif note % 3 == 2:
             n = (note - 2) / 3
             if n + 1 >= p:
                 answer += 1
             elif s > 0 and n + 2 >= p:
                 answer += 1
                 s -= 1
     print 'Case #{0}: {1}'.format(i+1, answer)
",13,186,280
"#!/usr/bin/env python3
 # -*- encoding: utf-8 -*-
 
 
 def who_won(l):
     current = None
     for i in l:
         if i == '.':
             return None
         if not current and i in 'OX':
             current = i
         if current and current != i and i != 'T':
             return None
     return current
 
 
 def f(m):
     still = False
     for i in m:
         for j in i:
             if j == '.':
                 still = True
 
     rows = m # [[m[i][j] for i in range(4)] for j in range(4)]
     cols = [[m[i][j] for i in range(4)] for j in range(4)]
     diag = [[m[i][i] for i in range(4)], [m[3-i][i] for i in range(4)]]
 
     winner = None
 
     for l in rows + cols + diag:
         c = who_won(l)
         if c:
             winner = c + ' won'
 
     if not winner:
         if still:
             winner = 'Game has not completed'
         else:
             winner = 'Draw'
     return winner
 
 if __name__ == '__main__':
     T = int(input())
     for i in range(T):
         m = [list(input()) for k in range(4)]
         if i != T- 1:
             input()
         r = f(m)
         print('Case #{}: {}'.format(i+1, r))
",13,187,394
"#!/usr/bin/env python2.7
 
 T = int(raw_input())
 for i in xrange(T):
     values = map(int, raw_input().split())
     [N,s,p] = values[0:3]
     t = values[3:]
     answer = 0
     for note in t:
         if note < 2:
             if note >= p:
                 answer += 1
         elif note % 3 == 1 and (note-1) / 3 + 1 >= p:
             answer += 1
         elif note % 3 == 0:
             n = note / 3
             if n >= p:
                 answer += 1
             elif s > 0 and n + 1 >= p:
                 answer += 1
                 s -= 1
         elif note % 3 == 2:
             n = (note - 2) / 3
             if n + 1 >= p:
                 answer += 1
             elif s > 0 and n + 2 >= p:
                 answer += 1
                 s -= 1
     print 'Case #{0}: {1}'.format(i+1, answer)
",13,188,280
"#!/usr/bin/env python3
 # -*- encoding: utf-8 -*-
 
 (i):
     n = i
     rev = 0
     while i > 0:
         dig = i % 10
         rev = rev * 10 + dig
         i = i // 10
     return n == rev
 
 def is_square(i):
     if i == 1:
         return True
     x = i // 2
     seen = set([x])
     while x * x != i:
         x = (x + (i // x)) // 2
         if x in seen:
             return False
         seen.add(x)
     return True
 
 def f(a, b):
     tot = 0
 
     sra = a
     while not is_square(sra):
         sra += 1
     srb = b
     while not is_square(srb):
         srb -= 1
 
     sra = int(sqrt(sra))
     srb = int(sqrt(srb))
 
     for i in range(sra, srb+1):
         if is_palindromic(i) and is_palindromic(i ** 2):
             tot += 1
 
     return tot
 
 if __name__ == '__main__':
     T = int(input())
     for i in range(T):
         a, b = map(int, input().split())
         r = f(a, b)
         print('Case #{}: {}'.format(i+1, r))
",13,189,384
"#!/usr/bin/env python2.6
 
 translate = {'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'q': 'z', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm', 'z': 'q'}
 
 nb = int(raw_input())
 for i in xrange(nb):
     s = ''.join([translate[char] if char in translate.keys() else char for char in str(raw_input())])
     print 'Case #{0}:'.format(i+1), s
",13,190,240
"CACHE = {(1, 1, 0): ['c'],
  (1, 2, 0): ['c.'],
  (1, 2, 1): ['*c'],
  (1, 3, 0): ['c..'],
  (1, 3, 1): ['*.c'],
  (1, 3, 2): ['**c'],
  (1, 4, 0): ['c...'],
  (1, 4, 1): ['*.c.'],
  (1, 4, 2): ['**.c'],
  (1, 4, 3): ['***c'],
  (1, 5, 0): ['c....'],
  (1, 5, 1): ['*.c..'],
  (1, 5, 2): ['**.c.'],
  (1, 5, 3): ['***.c'],
  (1, 5, 4): ['****c'],
  (2, 1, 0): ['c', '.'],
  (2, 1, 1): ['*', 'c'],
  (2, 2, 0): ['c.', '..'],
  (2, 2, 1): None,
  (2, 2, 2): None,
  (2, 2, 3): ['**', '*c'],
  (2, 3, 0): ['c..', '...'],
  (2, 3, 1): None,
  (2, 3, 2): ['*.c', '*..'],
  (2, 3, 3): None,
  (2, 3, 4): None,
  (2, 3, 5): ['***', '**c'],
  (2, 4, 0): ['c...', '....'],
  (2, 4, 1): None,
  (2, 4, 2): ['*.c.', '*...'],
  (2, 4, 3): None,
  (2, 4, 4): ['**.c', '**..'],
  (2, 4, 5): None,
  (2, 4, 6): None,
  (2, 4, 7): ['****', '***c'],
  (2, 5, 0): ['c....', '.....'],
  (2, 5, 1): None,
  (2, 5, 2): ['*.c..', '*....'],
  (2, 5, 3): None,
  (2, 5, 4): ['**.c.', '**...'],
  (2, 5, 5): None,
  (2, 5, 6): ['***.c', '***..'],
  (2, 5, 7): None,
  (2, 5, 8): None,
  (2, 5, 9): ['*****', '****c'],
  (3, 1, 0): ['c', '.', '.'],
  (3, 1, 1): ['*', '.', 'c'],
  (3, 1, 2): ['*', '*', 'c'],
  (3, 2, 0): ['c.', '..', '..'],
  (3, 2, 1): None,
  (3, 2, 2): ['**', '..', 'c.'],
  (3, 2, 3): None,
  (3, 2, 4): None,
  (3, 2, 5): ['**', '**', '*c'],
  (3, 3, 0): ['c..', '...', '...'],
  (3, 3, 1): ['*.c', '...', '...'],
  (3, 3, 2): None,
  (3, 3, 3): ['***', '...', 'c..'],
  (3, 3, 4): None,
  (3, 3, 5): ['***', '*..', '*.c'],
  (3, 3, 6): None,
  (3, 3, 7): None,
  (3, 3, 8): ['***', '***', '**c'],
  (3, 4, 0): ['c...', '....', '....'],
  (3, 4, 1): ['*.c.', '....', '....'],
  (3, 4, 2): ['**.c', '....', '....'],
  (3, 4, 3): ['*.c.', '*...', '*...'],
  (3, 4, 4): ['****', '....', 'c...'],
  (3, 4, 5): None,
  (3, 4, 6): ['****', '*...', '*.c.'],
  (3, 4, 7): None,
  (3, 4, 8): ['****', '**..', '**.c'],
  (3, 4, 9): None,
  (3, 4, 10): None,
  (3, 4, 11): ['****', '****', '***c'],
  (3, 5, 0): ['c....', '.....', '.....'],
  (3, 5, 1): ['*.c..', '.....', '.....'],
  (3, 5, 2): ['**.c.', '.....', '.....'],
  (3, 5, 3): ['***.c', '.....', '.....'],
  (3, 5, 4): ['**.c.', '*....', '*....'],
  (3, 5, 5): ['*****', '.....', 'c....'],
  (3, 5, 6): ['**.c.', '**...', '**...'],
  (3, 5, 7): ['*****', '*....', '*.c..'],
  (3, 5, 8): None,
  (3, 5, 9): ['*****', '**...', '**.c.'],
  (3, 5, 10): None,
  (3, 5, 11): ['*****', '***..', '***.c'],
  (3, 5, 12): None,
  (3, 5, 13): None,
  (3, 5, 14): ['*****', '*****', '****c'],
  (4, 1, 0): ['c', '.', '.', '.'],
  (4, 1, 1): ['*', '.', 'c', '.'],
  (4, 1, 2): ['*', '*', '.', 'c'],
  (4, 1, 3): ['*', '*', '*', 'c'],
  (4, 2, 0): ['c.', '..', '..', '..'],
  (4, 2, 1): None,
  (4, 2, 2): ['**', '..', 'c.', '..'],
  (4, 2, 3): None,
  (4, 2, 4): ['**', '**', '..', 'c.'],
  (4, 2, 5): None,
  (4, 2, 6): None,
  (4, 2, 7): ['**', '**', '**', '*c'],
  (4, 3, 0): ['c..', '...', '...', '...'],
  (4, 3, 1): ['*.c', '...', '...', '...'],
  (4, 3, 2): ['*.c', '*..', '...', '...'],
  (4, 3, 3): ['***', '...', 'c..', '...'],
  (4, 3, 4): ['***', '*..', '..c', '...'],
  (4, 3, 5): None,
  (4, 3, 6): ['***', '***', '...', 'c..'],
  (4, 3, 7): None,
  (4, 3, 8): ['***', '***', '*..', '*.c'],
  (4, 3, 9): None,
  (4, 3, 10): None,
  (4, 3, 11): ['***', '***', '***', '**c'],
  (4, 4, 0): ['c...', '....', '....', '....'],
  (4, 4, 1): ['*.c.', '....', '....', '....'],
  (4, 4, 2): ['**.c', '....', '....', '....'],
  (4, 4, 3): ['**.c', '*...', '....', '....'],
  (4, 4, 4): ['****', '....', 'c...', '....'],
  (4, 4, 5): ['****', '*...', '..c.', '....'],
  (4, 4, 6): ['****', '**..', '...c', '....'],
  (4, 4, 7): ['****', '*...', '*.c.', '*...'],
  (4, 4, 8): ['****', '****', '....', 'c...'],
  (4, 4, 9): None,
  (4, 4, 10): ['****', '****', '*...', '*.c.'],
  (4, 4, 11): None,
  (4, 4, 12): ['****', '****', '**..', '**.c'],
  (4, 4, 13): None,
  (4, 4, 14): None,
  (4, 4, 15): ['****', '****', '****', '***c'],
  (4, 5, 0): ['c....', '.....', '.....', '.....'],
  (4, 5, 1): ['*.c..', '.....', '.....', '.....'],
  (4, 5, 2): ['**.c.', '.....', '.....', '.....'],
  (4, 5, 3): ['***.c', '.....', '.....', '.....'],
  (4, 5, 4): ['***.c', '*....', '.....', '.....'],
  (4, 5, 5): ['*****', '.....', 'c....', '.....'],
  (4, 5, 6): ['*****', '*....', '..c..', '.....'],
  (4, 5, 7): ['*****', '**...', '...c.', '.....'],
  (4, 5, 8): ['*****', '***..', '....c', '.....'],
  (4, 5, 9): ['*****', '**...', '*..c.', '*....'],
  (4, 5, 10): ['*****', '*****', '.....', 'c....'],
  (4, 5, 11): ['*****', '**...', '**.c.', '**...'],
  (4, 5, 12): ['*****', '*****', '*....', '*.c..'],
  (4, 5, 13): None,
  (4, 5, 14): ['*****', '*****', '**...', '**.c.'],
  (4, 5, 15): None,
  (4, 5, 16): ['*****', '*****', '***..', '***.c'],
  (4, 5, 17): None,
  (4, 5, 18): None,
  (4, 5, 19): ['*****', '*****', '*****', '****c'],
  (5, 1, 0): ['c', '.', '.', '.', '.'],
  (5, 1, 1): ['*', '.', 'c', '.', '.'],
  (5, 1, 2): ['*', '*', '.', 'c', '.'],
  (5, 1, 3): ['*', '*', '*', '.', 'c'],
  (5, 1, 4): ['*', '*', '*', '*', 'c'],
  (5, 2, 0): ['c.', '..', '..', '..', '..'],
  (5, 2, 1): None,
  (5, 2, 2): ['**', '..', 'c.', '..', '..'],
  (5, 2, 3): None,
  (5, 2, 4): ['**', '**', '..', 'c.', '..'],
  (5, 2, 5): None,
  (5, 2, 6): ['**', '**', '**', '..', 'c.'],
  (5, 2, 7): None,
  (5, 2, 8): None,
  (5, 2, 9): ['**', '**', '**', '**', '*c'],
  (5, 3, 0): ['c..', '...', '...', '...', '...'],
  (5, 3, 1): ['*.c', '...', '...', '...', '...'],
  (5, 3, 2): ['*.c', '*..', '...', '...', '...'],
  (5, 3, 3): ['***', '...', 'c..', '...', '...'],
  (5, 3, 4): ['***', '*..', '..c', '...', '...'],
  (5, 3, 5): ['***', '*..', '*.c', '...', '...'],
  (5, 3, 6): ['***', '***', '...', 'c..', '...'],
  (5, 3, 7): ['***', '***', '*..', '..c', '...'],
  (5, 3, 8): None,
  (5, 3, 9): ['***', '***', '***', '...', 'c..'],
  (5, 3, 10): None,
  (5, 3, 11): ['***', '***', '***', '*..', '*.c'],
  (5, 3, 12): None,
  (5, 3, 13): None,
  (5, 3, 14): ['***', '***', '***', '***', '**c'],
  (5, 4, 0): ['c...', '....', '....', '....', '....'],
  (5, 4, 1): ['*.c.', '....', '....', '....', '....'],
  (5, 4, 2): ['**.c', '....', '....', '....', '....'],
  (5, 4, 3): ['**.c', '*...', '....', '....', '....'],
  (5, 4, 4): ['****', '....', 'c...', '....', '....'],
  (5, 4, 5): ['****', '*...', '..c.', '....', '....'],
  (5, 4, 6): ['****', '**..', '...c', '....', '....'],
  (5, 4, 7): ['****', '**..', '*..c', '....', '....'],
  (5, 4, 8): ['****', '****', '....', 'c...', '....'],
  (5, 4, 9): ['****', '****', '*...', '..c.', '....'],
  (5, 4, 10): ['****', '****', '**..', '...c', '....'],
  (5, 4, 11): ['****', '****', '*...', '*.c.', '*...'],
  (5, 4, 12): ['****', '****', '****', '....', 'c...'],
  (5, 4, 13): None,
  (5, 4, 14): ['****', '****', '****', '*...', '*.c.'],
  (5, 4, 15): None,
  (5, 4, 16): ['****', '****', '****', '**..', '**.c'],
  (5, 4, 17): None,
  (5, 4, 18): None,
  (5, 4, 19): ['****', '****', '****', '****', '***c'],
  (5, 5, 0): ['c....', '.....', '.....', '.....', '.....'],
  (5, 5, 1): ['*.c..', '.....', '.....', '.....', '.....'],
  (5, 5, 2): ['**.c.', '.....', '.....', '.....', '.....'],
  (5, 5, 3): ['***.c', '.....', '.....', '.....', '.....'],
  (5, 5, 4): ['***.c', '*....', '.....', '.....', '.....'],
  (5, 5, 5): ['*****', '.....', 'c....', '.....', '.....'],
  (5, 5, 6): ['*****', '*....', '..c..', '.....', '.....'],
  (5, 5, 7): ['*****', '**...', '...c.', '.....', '.....'],
  (5, 5, 8): ['*****', '***..', '....c', '.....', '.....'],
  (5, 5, 9): ['*****', '***..', '*...c', '.....', '.....'],
  (5, 5, 10): ['*****', '*****', '.....', 'c....', '.....'],
  (5, 5, 11): ['*****', '*****', '*....', '..c..', '.....'],
  (5, 5, 12): ['*****', '*****', '**...', '...c.', '.....'],
  (5, 5, 13): ['*****', '*****', '***..', '....c', '.....'],
  (5, 5, 14): ['*****', '*****', '**...', '*..c.', '*....'],
  (5, 5, 15): ['*****', '*****', '*****', '.....', 'c....'],
  (5, 5, 16): ['*****', '*****', '**...', '**.c.', '**...'],
  (5, 5, 17): ['*****', '*****', '*****', '*....', '*.c..'],
  (5, 5, 18): None,
  (5, 5, 19): ['*****', '*****', '*****', '**...', '**.c.'],
  (5, 5, 20): None,
  (5, 5, 21): ['*****', '*****', '*****', '***..', '***.c'],
  (5, 5, 22): None,
  (5, 5, 23): None,
  (5, 5, 24): ['*****', '*****', '*****', '*****', '****c']}
 
 
 T = int(input())
 for i in range(T):
 	R, C, M = map(int, input().split())
 	print('Case #{}:'.format(i + 1))
 	try:
 		print('\n'.join(CACHE[(R, C, M)]))
 	except:
 		print('Impossible')
",13,191,4899
"(9299999)
 
 def min_time(C, F, X, speed, nb_cookies):
 	if (X - nb_cookies) / speed < (X - (nb_cookies - C)) / (speed + F):
 		return (X - nb_cookies) / speed
 	elif nb_cookies >= C:
 		return min_time(C, F, X, speed + F, nb_cookies - C)
 	else:
 		return (C - nb_cookies) / speed + min_time(C, F, X, speed, C)
 
 T = int(raw_input())
 for i in range(T):
 	C, F, X = map(float, raw_input().split())
 	print 'Case #%d: %f' % (i + 1, min_time(C, F, X, 2, 0))
",13,192,230
"def solve(c1, g1, c2, g2):
     row_1 = g1[c1-1]
     row_2 = g2[c2-1]
     inter = set(row_1) & set(row_2)
     if len(inter) == 0:
         return ""Volunteer cheated!""
     if len(inter) > 1:
         return ""Bad magician!""
     return str(inter.pop())
 
 if __name__ == ""__main__"":
     T = int(raw_input())
     for i in range(1,T+1):
         c1 = int(raw_input())
         g1 = []
         for j in range(4):
             g1.append(map(int, raw_input().split()))
         c2 = int(raw_input())
         g2 = []
         for j in range(4):
             g2.append(map(int, raw_input().split()))
         print ""Case #%d: %s"" % (i, solve(c1,g1,c2,g2)) 
         
     
",14,193,267
"def num_rotations(n, A, B):
     # I'm sure there's a better way to do this
     # but this works fast enough so who cares
     s = str(n)
     a = set()
     for i in range(len(s)):
         rotated = s[i:] + s[:i]
         r = int(rotated)
         if rotated[0] != '0' and A <= r <= B:
             a.add(rotated)
     return len(a) -1
 
 def solve(A,B):
     t  = 0
     for i in range(A, B+1):
         t += num_rotations(i, A, B)
     if t % 2 != 0:
         print ""WTF"", A, B, t
     return t//2
 
 if __name__ == ""__main__"":
     T = int(raw_input())
     for i in range(1, T+1):
         A,B = map(int, raw_input().strip().split())
         print ""Case #%d: %d"" % (i, solve(A,B))
",14,194,276
"def line_status(line):
     s = set(line)
     if '.' in s:
         return 'I'
     if len(s) == 1 or (len(s) == 2 and 'T' in s):
         player = s.pop()
         while player == ""T"":
             player = s.pop()
         return player
     return 'D'
 
 def grid_status(grid):
     lines = grid
     columns = []
     for i in range(4):
         columns.append([])
         for j in range(4):
             columns[-1].append(grid[j][i])
     lines.extend(columns)
     lines.append([grid[i][i] for i in range(4)])
     lines.append([grid[i][3-i] for i in range(4)])
     incomplete = False
     for l in lines:
         s = line_status(l)
         if s == 'I':
             incomplete = True
         elif s in ('X', 'O'):
             return s + "" won""
     if incomplete:
         return ""Game has not completed""
     return ""Draw""
 
 if __name__ == ""__main__"":
     T = int(raw_input())
     for i in range(1, T+1):
         grid = [raw_input() for j in range(4)]
         if i < T:
             raw_input()
         print ""Case #%d: %s"" % (i, grid_status(grid))
     
",14,195,362
"def max_of_triplets(n):
     a = n//3
     if (n % 3) == 0:
         if a == 0 : return (0,0)
         return (a, a+1)
     if (n % 3) == 1:
         return (a+1, a+1)
     if a == 9: return (10, 10)
     return (a+1, a+2)
 
 def solve(scores, S, p):
     t = 0
     for s in scores:
         a,b = max_of_triplets(s)
         if a >= p:
             t += 1
         elif b >= p and S > 0:
             t += 1
             S -= 1
     return t
 
 if __name__ == ""__main__"":
     T = int(raw_input())
     for i in range(1, T+1):
         nums = map(int, raw_input().strip().split())
         N = nums[0]
         S = nums[1]
         p = nums[2]
         scores = nums[3:]
         if len(scores) != N:
             #sanity check
             print ""WTF"", i
         print ""Case #%d: %d"" % (i, solve(scores, S, p))
     
",14,196,334
"def solve(naomi, ken):
     N = list(sorted(naomi))
     K = list(sorted(ken))
     pd = 0
     while len(N) > 0:
         if N[0] > K[0]:
             pd += 1
             N.pop(0)
             K.pop(0)
         else:
             N.pop(0)
             K.pop(-1)
     pn = 0
     N = list(sorted(naomi))
     K = list(sorted(ken))
     while len(N) > 0:
         n = N.pop(0)
         if n < K[0]:
             K.pop(0)
         else:
             found = None
             for i,k in enumerate(K):
                 if k > n:
                     found = i
                     break
             if found is not None:
                 K.pop(found)
             else:
                 K.pop(0)
                 pn += 1
     return pd,pn
 
 if __name__==""__main__"":
     T = int(raw_input())
     for i in range(1,T+1):
         raw_input()
         naomi = map(float, raw_input().split())
         ken = map(float, raw_input().split())
         x,y = solve(naomi,ken)
         print ""Case #%d: %d %d"" %(i,x,y)
",14,197,352
"(num):
     return int(sqrt(num))
 
 def is_square(num):
     return isqrt(num)**2 == num
 
 def is_palindrome(num):
     return str(num) == """".join(reversed(str(num)))
 
 def is_fair_and_square(num):
     return is_square(num) and is_palindrome(num) and is_palindrome(isqrt(num))
 
 def solve(A,B):
     count = 0
     for i in range(A,B+1):
         if is_fair_and_square(i):
             count += 1
     return count
 
 if __name__ == ""__main__"":
     T = int(raw_input())
     for i in range(1, T+1):
         A,B = [int(x) for x in raw_input().split()]
         print ""Case #%d: %d"" % (i, solve(A,B))
         
",14,198,248
"mapping = {' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's',
            'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u',
            'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n',
            'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a',
            'x': 'm', 'z': 'q', 'q': 'z'}
 
 def translate(s):
     return """".join(map(lambda a: mapping[a], s))
 
 if __name__ == ""__main__"":
     T = int(raw_input())
     for i in range(1, T+1):
         s = translate(raw_input().strip())
         print ""Case #%d: %s"" %(i, s)
 
         
",14,199,268
"(R,C,M, lp=0,placed=0):
     rem = R*C-lp
     if M-placed >= rem:
         if M-placed > rem:
             return None
         
         res = set()
         for i in range(lp, R*C):
             res.add(i)
         return [res]
         
     if placed == M:
         return [set()]
 
     res = []
     for i in range(lp, R*C):
         sub_sol = all_grids(R,C,M,i+1, placed+1)
         if sub_sol is None:
             continue
             
         for s in sub_sol:
             s.add(i)
             res.append(s)
     return res
 
 def adj(R,C,i):
     
     res = []
     left_edge = i % C == 0
     top_edge = i // C == 0
     right_edge = (i+1) % C == 0
     bottom_edge = i // C == R-1
     
     if not left_edge:
         res.append(i-1)
         if not top_edge:
             res.append(i-1-C)
         if not bottom_edge:
             res.append(i+C-1)
             
     if not right_edge:
         res.append(i+1)
         if not top_edge:
             res.append(i+1-C)
         if not bottom_edge:
             res.append(i+1+C)
             
     if not bottom_edge:
         res.append(i+C)
     if not top_edge:
         res.append(i-C)
     return res
         
     
     
     
 def solution(R,C,g):
     M = R*C
     res = []
     num_zeroes = 0
     for i in range(M):
         if i in g:
             res.append('x')
             continue
         x = 0
         for a in adj(R,C,i):
             if a in g:
                 x += 1
         if x == 0:
             num_zeroes += 1
         res.append(x)
         
     for i in range(M):
         if i in g:
             continue
         r = res[i]
         if r == 0 and num_zeroes == 1:
             continue
         connected = False
         for a in adj(R,C,i):
             if res[a] == 0:
                 connected = True
                 break
         if not connected:
             return None
     
     return res.index(0)
 
 def transcribe(R,C, g, sol):
     res = []
     for i in range(R):
         r = []
         for j in range(C):
             x = i*C+j
             if x in g:
                 r.append('*')
             elif x == sol:
                 r.append('c')
             else:
                 r.append('.')
         res.append(r)
     return res
 
 def printed_sol(transcript):
     if transcript is None:
         return ""Impossible""
     else:
         return ""\n"".join("""".join(row) for row in transcript)
 
 def solve(R,C,M):
     if M == R*C-1:
         g = []
         for i in range(R*C-1):
             g.append(i)
         return transcribe(R,C, g, R*C-1)
     
     for g in all_grids(R,C,M):
         sol = solution(R,C,g)
         if sol is None:
             continue
         return transcribe(R,C, g, sol)
     return None
             
     
 def output_grid(R,C,g):
     for i in range(R):
         for j in range(C):
             if i*C+j not in g:
                 sys.stdout.write(""."")
             else:
                 sys.stdout.write(""*"")
         sys.stdout.write(""\n"")
 
 if __name__ == ""__main__"":
     T = int(raw_input())
     for i in range(1,T+1):
         R,C,M = map(int, raw_input().split())
         print ""Case #%d:"" % i
         print printed_sol(solve(R,C,M))
",14,200,1092
"def time_to_get(target, num_factories, factory_cost, factory_increase):
     rate = 2.0
     t = 0
     for i in range(num_factories):
         t += factory_cost/rate
         rate += factory_increase
     return t + target/rate
     
 def solve(C,F,X):
     min_sol = None
     num_fact = 0
     while True:
         t = time_to_get(X, num_fact, C, F)
         if min_sol is None or t < min_sol:
             min_sol = t
             num_fact += 1
         else:
             return min_sol
 
 if __name__ == ""__main__"":
     T = int(raw_input())
     for i in range(1, T+1):
         C,F,X = map(float, raw_input().split())
         print ""Case #%d: %.07f"" % (i, solve(C,F,X))
",14,201,249
"# python 3
 (row1, tab1, row2, tab2):
     s1 = set(tab1[row1])
     s2 = set(tab2[row2])
     xset = s1 & s2
     if len(xset) == 1:
         result = xset.pop()
     elif len(xset) == 0:
         result = 'Volunteer cheated!'
     else:
         result = 'Bad magician!'
     return result
 
 def result_gen(lines):
     ncases = int(next(lines))
     for ci in range(1,ncases+1):
         row1 = int(next(lines)) - 1
         tab1 = [line_of_numbers(next(lines)) for i in range(4)]
         row2 = int(next(lines)) - 1
         tab2 = [line_of_numbers(next(lines)) for i in range(4)]
         result = process_case(row1, tab1, row2, tab2)
         yield 'Case #{0}: {1}\n'.format(ci, result)
     
 def line_of_numbers(s):
     return [int(sub) for sub in s.split()]
 
 def input_gen(f_in):
     for line in f_in:
         if line.endswith('\n'):
             line = line[:-1]
         yield line
 
 def start(basename):
     infile = basename + '.in'
     outfile = basename + '.out'
     f_in = open(infile, 'r')
     f_out = open(outfile, 'w')
     f_out.writelines(result_gen(input_gen(f_in)))
     f_in.close()
     f_out.close()
 
 ##start('A-test')
 start('A-small-attempt0')
 ##start('A-large')
",15,202,461
"# python 3
 (height, max1, max2):
     if height < max1 and height < max2:
         return False
     return True
 
 def process_case(heights):
     nrows = len(heights)
     ncols = len(heights[0])
     col_max_vals = [max((heights[r][c] for r in range(nrows)))
                     for c in range(ncols)]
     row_max_vals = [max((heights[r][c] for c in range(ncols)))
                     for r in range(nrows)]
     for r in range(nrows):
         for c in range(ncols):
             if not is_valid(heights[r][c], row_max_vals[r], col_max_vals[c]):
                 return 'NO'
     return 'YES'
 
 def result_gen(lines):
     ncases = int(next(lines))
     for ci in range(1,ncases+1):
         nrows, ncols = line_of_numbers(next(lines))
         heights = [line_of_numbers(next(lines)) for r in range(nrows)]
         result = process_case(heights)
         yield 'Case #{0}: {1}\n'.format(ci, result)
     
 def line_of_numbers(s):
     return [int(sub) for sub in s.split()]
 
 def input_gen(f_in):
     for line in f_in:
         if line.endswith('\n'):
             line = line[:-1]
         yield line
 
 def start(basename):
     infile = basename + '.in'
     outfile = basename + '.out'
     f_in = open(infile, 'r')
     f_out = open(outfile, 'w')
     f_out.writelines(result_gen(input_gen(f_in)))
     f_in.close()
     f_out.close()
 
 ##start('B-test')
 start('B-small-attempt0')
 ##start('B-large')
",15,203,515
"# python 3
 (num):
     digits = [ch for ch in str(num)]
     for i in range(1, len(digits)):
         if digits[i] != '0':
             result = 0
             for d in digits[i:]:
                 result = 10*result + ord(d) - ord('0')
             for d in digits[:i]:
                 result = 10*result + ord(d) - ord('0')
             if result == num:
                 return
             yield result
     
 def process_case(a,b):
     result = 0
     for n in range(a,b+1):
         for m in gen_rotations(n):
             if (n < m <= b):
                 result += 1
     return result
 
 def result_gen(lines):
     ncases = int(next(lines))
     for ci in range(1,ncases+1):
         a,b = line_of_numbers(next(lines))
         result = process_case(a,b)
         yield 'Case #{0}: {1}\n'.format(ci, result)
     
 def line_of_numbers(s):
     return [int(sub) for sub in s.split()]
 
 def input_gen(f_in):
     for line in f_in:
         if line.endswith('\n'):
             line = line[:-1]
         yield line
 
 def start(basename):
     infile = basename + '.in'
     outfile = basename + '.out'
     f_in = open(infile, 'r')
     f_out = open(outfile, 'w')
     f_out.writelines(result_gen(input_gen(f_in)))
     f_in.close()
     f_out.close()
 
 ##start('C-test')
 start('C-small-attempt0')
 ##start('C-large')
",15,204,466
"# python 3
 = 'X'
 P2 = 'O'
 PA = 'T'
 EMPTY = '.'
 
 def no_empty_fields(board):
     for row in board:
         for field in row:
             if field==EMPTY:
                 return False
     return True
 
 def is_winning_series(board, r0, c0, dr, dc, player):
     r,c = r0,c0
     for i in range(4):
         if board[r][c] != player and board[r][c] != PA:
             return False
         r,c = r+dr,c+dc
     return True
 
 def win_condition(board, player):
     if is_winning_series(board, 0,0, 1,1, player):
         return True
     if is_winning_series(board, 0,3, 1,-1, player):
         return True
     for i in range(4):
         if is_winning_series(board, 0,i, 1,0, player):
             return True
         if is_winning_series(board, i,0, 0,1, player):
             return True
     return False
 
 def process_case(board):
     for player in {P1, P2}:
         if win_condition(board, player):
             return '{0} won'.format(player)
     if no_empty_fields(board):
         return 'Draw'
     return 'Game has not completed'
 
 def result_gen(lines):
     ncases = int(next(lines))
     for ci in range(1,ncases+1):
         board = [[ch for ch in next(lines)] for i in range(4)]
         next(lines)
         result = process_case(board)
         yield 'Case #{0}: {1}\n'.format(ci, result)
     
 def line_of_numbers(s):
     return [int(sub) for sub in s.split()]
 
 def input_gen(f_in):
     for line in f_in:
         if line.endswith('\n'):
             line = line[:-1]
         yield line
 
 def start(basename):
     infile = basename + '.in'
     outfile = basename + '.out'
     f_in = open(infile, 'r')
     f_out = open(outfile, 'w')
     f_out.writelines(result_gen(input_gen(f_in)))
     f_in.close()
     f_out.close()
 
 ##start('A-test')
 start('A-small-attempt0')
 ##start('A-large')
",15,205,655
"# python 3
 (p, maxdiff):
     minval = max(p - maxdiff, 0)
     return p + minval + minval
 
 def process_case(numdata):
     N,S,p = numdata[0:3]
     scores = numdata[3:]
     thre_normal = threshold(p, 1)
     thre_surprise = threshold(p, 2)
     result = 0
     for tot in scores:
         if tot >= thre_normal:
             result += 1
         elif S > 0 and tot >= thre_surprise:
             result += 1
             S -= 1
     return result
 
 def result_gen(lines):
     ncases = int(next(lines))
     for ci in range(1,ncases+1):
         result = process_case(line_of_numbers(next(lines)))
         yield 'Case #{0}: {1}\n'.format(ci, result)
     
 def line_of_numbers(s):
     return [int(sub) for sub in s.split()]
 
 def input_gen(f_in):
     for line in f_in:
         if line.endswith('\n'):
             line = line[:-1]
         yield line
 
 def start(basename):
     infile = basename + '.in'
     outfile = basename + '.out'
     f_in = open(infile, 'r')
     f_out = open(outfile, 'w')
     f_out.writelines(result_gen(input_gen(f_in)))
     f_in.close()
     f_out.close()
 
 ##start('B-test')
 start('B-small-attempt0')
 ##start('B-large')
",15,206,427
"# python 3
 (N, naomi_sorted, ken_sorted):
     j=0
     naomi_points = 0
     for i in range(N):
         while j < N and naomi_sorted[i] > ken_sorted[j]:
             j += 1
         if j < N:
             j += 1
         else:
             naomi_points += 1
     return naomi_points
     
 def deceitful_war_points(N, naomi_sorted, ken_sorted):
     j=0
     naomi_points = 0
     for i in range(N):
         while j < N and ken_sorted[i] > naomi_sorted[j]:
             j += 1
         if j < N:
             naomi_points += 1
             j += 1
     return naomi_points
 
 def process_case(N, naomi_sorted, ken_sorted):
     x1 = deceitful_war_points(N, naomi_sorted, ken_sorted)
     x2 = war_points(N, naomi_sorted, ken_sorted)
     return (x1, x2)
 
 def result_gen(lines):
     ncases = int(next(lines))
     for ci in range(1,ncases+1):
         N = int(next(lines))
         naomi_sorted = line_of_floats_sorted(next(lines))
         ken_sorted = line_of_floats_sorted(next(lines))
         x1, x2 = process_case(N, naomi_sorted, ken_sorted)
         yield 'Case #{0}: {1} {2}\n'.format(ci, x1, x2)
     
 def line_of_floats_sorted(s):
     fv = [float(sub) for sub in s.split()]
     fv.sort()
     return fv
 
 def input_gen(f_in):
     for line in f_in:
         if line.endswith('\n'):
             line = line[:-1]
         yield line
 
 def start(basename):
     infile = basename + '.in'
     outfile = basename + '.out'
     f_in = open(infile, 'r')
     f_out = open(outfile, 'w')
     f_out.writelines(result_gen(input_gen(f_in)))
     f_in.close()
     f_out.close()
 
 ##start('D-test')
 start('D-small-attempt0')
 ##start('D-large')
",15,207,635
"# python 3
 
 (num):
     s = str(num)
     end_idx = len(s)-1
     for i in range(len(s)//2):
         if s[i] != s[end_idx-i]:
             return False
     return True
 
 def is_valid_base(base):
     return is_palindrome(base) and is_palindrome(base*base)
 
 def process_case(lo, hi):
     cnt = 0
     base_lo = math.ceil(math.sqrt(lo))
     base_hi = math.floor(math.sqrt(hi))
     for base in range(base_lo, base_hi+1):
         if is_valid_base(base):
             cnt += 1
     return cnt
 
 def result_gen(lines):
     ncases = int(next(lines))
     for ci in range(1,ncases+1):
         lo,hi = line_of_numbers(next(lines))
         result = process_case(lo, hi)
         yield 'Case #{0}: {1}\n'.format(ci, result)
     
 def line_of_numbers(s):
     return [int(sub) for sub in s.split()]
 
 def input_gen(f_in):
     for line in f_in:
         if line.endswith('\n'):
             line = line[:-1]
         yield line
 
 def start(basename):
     infile = basename + '.in'
     outfile = basename + '.out'
     f_in = open(infile, 'r')
     f_out = open(outfile, 'w')
     f_out.writelines(result_gen(input_gen(f_in)))
     f_in.close()
     f_out.close()
 
 ##start('C-test')
 start('C-small-attempt0')
 ##start('C-large')
",15,208,472
"# python 3
 = [('a zoo',
             'y qee'),
            ('our language is impossible to understand',
             'ejp mysljylc kd kxveddknmc re jsicpdrysi'),
            ('there are twenty six factorial possibilities',
             'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd'),
            ('so it is okay if you want to just give up',
             'de kr kd eoya kw aej tysr re ujdr lkgc jv')]
            
 def process_case(line, trans):
     return ''.join(trans[ch] for ch in line)
 
 def prepare_translation():
     trans = {}
     for eg_seqs in samples:
         for echar,gchar in zip(*eg_seqs):
             trans[gchar] = echar
     miss_g = set(string.ascii_lowercase) - set(trans.keys())
     miss_e = set(string.ascii_lowercase) - set(trans.values())
     if (len(miss_g) == 1 and len(miss_e) == 1):
         trans[miss_g.pop()] = miss_e.pop();
     return trans
 
 def result_gen(lines):
     trans = prepare_translation()
     ncases = int(next(lines))
     for ci in range(1,ncases+1):
         result = process_case(next(lines), trans)
         yield 'Case #{0}: {1}\n'.format(ci, result)
     
 def line_of_numbers(s):
     return [int(sub) for sub in s.split()]
 
 def input_gen(f_in):
     for line in f_in:
         if line.endswith('\n'):
             line = line[:-1]
         yield line
 
 def start(basename):
     infile = basename + '.in'
     outfile = basename + '.out'
     f_in = open(infile, 'r')
     f_out = open(outfile, 'w')
     f_out.writelines(result_gen(input_gen(f_in)))
     f_in.close()
     f_out.close()
 
 ##start('A-test')
 start('A-small-attempt0')
 ##start('A-large')
",15,209,578
"# python 3
 = 2.0
 
 def process_case(C, F, X):
     rate = BASE_RATE
     total_time = 0.0
     while True:        
         xtime = X / rate
         ctime = C / rate
         ext_rate = rate + F
         ext_time = ctime + (X / ext_rate)
         if xtime <= ext_time:
             total_time += xtime
             break
         total_time += ctime
         rate = ext_rate
     return total_time
 
 def result_gen(lines):
     ncases = int(next(lines))
     for ci in range(1,ncases+1):
         C, F, X = line_of_floats(next(lines))
         result = process_case(C, F, X)
         yield 'Case #{0}: {1:.7f}\n'.format(ci, result)
 
 def line_of_floats(s):
     return [float(sub) for sub in s.split()]
 
 def input_gen(f_in):
     for line in f_in:
         if line.endswith('\n'):
             line = line[:-1]
         yield line
 
 def start(basename):
     infile = basename + '.in'
     outfile = basename + '.out'
     f_in = open(infile, 'r')
     f_out = open(outfile, 'w')
     f_out.writelines(result_gen(input_gen(f_in)))
     f_in.close()
     f_out.close()
 
 ##start('B-test')
 start('B-small-attempt0')
 ##start('B-large')
",15,210,426
"= open(sys.argv[1])
 T = int(f.readline())
 for test in range(T):
     first_row_index = int(f.readline())
     first_row = []
     for ii in range(4):
         if (ii + 1) == first_row_index:
             first_row = f.readline().strip().split()
         else:
             f.readline()
     second_row_index = int(f.readline())
     second_row = []
     for ii in range(4):
         if (ii + 1) == second_row_index:
             second_row = f.readline().strip().split()
         else:
             f.readline()
     combined = [val for val in first_row if val in second_row]
 
     print ""Case #%d:"" % (test + 1), ""Bad magician!"" if len(combined) > 1 else ""Volunteer cheated!"" if len(combined) == 0 else combined[0]
 
 
",16,211,251
"= open(sys.argv[1])
 T = int(f.readline())
 for t in range(T):
     N, M = map(int, f.readline().strip().split())
     grass_lengths = []
     for nn in range(N):
         grass_lengths.append(map(int, f.readline().strip().split())) # Read in all grass heights
 
     x_max = [0] * M
     y_max = [0] * N
     for xx in range(M):
         for yy in range(N):
             height = grass_lengths[yy][xx]
             x_max[xx] = max(x_max[xx], height)  # Update the max required height for column x
             y_max[yy] = max(y_max[yy], height)  # Update the max required height for row y
 
     impossible = False
     for xx in range(M):
         for yy in range(N):
             height = grass_lengths[yy][xx]
             if (x_max[xx] > height and y_max[yy] > height): # Can we cut this row down to this level?
                 impossible = True
 
     print ""Case #%d:"" % (t + 1), ""NO"" if impossible else ""YES""
",16,212,312
"(num):
     x = str(num)
     recycles = []
     for ii in range(1, len(x)):
         recycles.append(x[ii:] + x[:ii])    
     return recycles
 
 f = open(sys.argv[1])
 T = int(f.readline())
 for t in range(T):
     A, B = map(int, f.readline().split())
     total = 0
     debugs = []
     for ii in range(A,B):
         recycles_ii = recycle(ii)
         recycles_ii = (filter(lambda x: int(x) > ii and int(x) <= B, recycles_ii))
         total += len(recycles_ii)
         for elem in recycles_ii:
             debugs.append((ii, int(elem)))   
     print ""Case #%d:"" % (t + 1), len(set(debugs))
",16,213,234
"(game, player):
     for ii in range(4):
         success = True
         for jj in range(4): # Has the player won in row ii
             if game[4*ii + jj] != player and game[4*ii + jj] != ""T"":
                 success = False
         if success: return True
         success = True
         for jj in range(4): # Has the player won in column ii
             if game[4*jj + ii] != player and game[4*jj + ii] != ""T"":
                 success = False
         if success: return True
     
     success = True
     for ii in range(4):
         if game[ii*5] != player and game[ii*5] != ""T"":
             success = False
     if success: return True
     success = True
     for ii in range(4):
         if game[3+ii*3] != player and game[3+ii*3] != ""T"":
             success = False
     if success: return True
     return False
 
 def gameOver(game):
     ret_val = True
     for ii in range(16):
         if game[ii] == ""."":
             ret_val = False
     return ret_val
 
 f = open(sys.argv[1])
 T = int(f.readline())
 for t in range(T):
     game = []
     for ii in range(4):
         for elem in f.readline().strip():
             game.append(elem)
 
     if hasWon(game, ""O""):
         print ""Case #%d:"" % (t + 1), ""O won""
     elif hasWon(game, ""X""):
         print ""Case #%d:"" % (t + 1), ""X won""
     elif gameOver(game):
         print ""Case #%d:"" % (t + 1), ""Draw""
     else:
         print ""Case #%d:"" % (t + 1), ""Game has not completed""
 
     f.readline()
",16,214,491
"= open(sys.argv[1])
 T = int(f.readline())
 for t in range(T):
     temp = map(int, f.readline().split())
     N = temp[0]
     S = temp[1]
     p = temp[2]
     scores = temp[3:]
     non_surprising_scores = len(filter(lambda x: x >= (3*p-2), scores))
     if (p<=1):
         surprising_scores = 0
     else:
         surprising_scores = len(filter(lambda x: (x >= (3*p-4) and x < (3*p-2)), scores))
     num_scores = non_surprising_scores + min(surprising_scores, S)   
     print ""Case #%d:"" % (t + 1), num_scores
",16,215,209
"= open(sys.argv[1])
 T = int(f.readline())
 for test in range(T):
     N = int(f.readline())
     naomi_blocks = map(float, f.readline().strip().split("" ""))
     ken_blocks = map(float, f.readline().strip().split("" ""))
     naomi_blocks.sort()
     ken_blocks.sort()
     naomi_clone = list(naomi_blocks)
     ken_clone = list(ken_blocks)
 
     naomi_standard_score = 0
     while naomi_blocks != []:
         naomi_new_val = naomi_blocks.pop()
         if naomi_new_val > ken_blocks[-1]:
             naomi_standard_score += 1
             ken_blocks.pop(0)
         else:
             ii = 0
             while ken_blocks[ii] < naomi_new_val:
                 ii += 1
             ken_blocks.pop(ii)
 
     assert(ken_blocks == [])
 
     naomi_blocks = naomi_clone
     ken_blocks = ken_clone
     naomi_blocks.sort(reverse=True)
     ken_blocks.sort(reverse=True)
     deceiving_strat_score = 0
     while naomi_blocks != []:
         naomi_new_val = naomi_blocks.pop()
         if naomi_new_val > ken_blocks[-1]:
             ken_blocks.pop()
             deceiving_strat_score += 1
 
     print ""Case #%d: "" % (test + 1), deceiving_strat_score, naomi_standard_score
 
 
 
",16,216,449
"(letter):
     input =  ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
     output = ['y', 'h', 'e', 's', 'o', 'c', 'v', 'x', 'd', 'u', 'i', 'g', 'l', 'b', 'k', 'r', 'z', 't', 'n', 'w', 'j', 'p', 'f', 'm', 'a', 'q']
     index = input.index(letter)
     return output[index]
 
 f = open(sys.argv[1])
 T = int(f.readline())
 for t in range(T):
     string = []
     A = f.readline().split()
     for elem in A:
         for ii in range(len(elem)):
             string.append(translate(elem[ii]))
         string.append(' ')           
     print ""Case #%d:"" % (t + 1), ''.join(elem for elem in string)
",16,217,297
"= open(sys.argv[1])
 T = int(f.readline())
 for test in range(T):
     R, C, M = map(int, f.readline().strip().split())
     Rorig = R
     Corig = C
     impossible = False
     grid = [['.' for i in range(C)] for j in range(R)]
     #print grid
 
     curr_coord = [0,0]
     while M > 0 and not impossible:
         #print curr_coord, M, grid
         if (C > R): # more columns - fill one in
             num_mines_in_column = R
             if M < R:
                 num_mines_in_column = min(R - 2, M)
             if num_mines_in_column <= 0:
                 impossible = True
                 break
             for ii in range(num_mines_in_column):
                 grid[curr_coord[0] + ii][curr_coord[1]] = '*'
             C -= 1
             curr_coord[1] += 1
             M -= num_mines_in_column
         else:
             num_mines_in_row = C
             if M < C:
                 num_mines_in_row = min(C - 2, M)
             if num_mines_in_row <= 0:
                 impossible = True
                 break
             for ii in range(num_mines_in_row):
                 grid[curr_coord[0]][curr_coord[1] + ii] = '*'
             R -= 1
             curr_coord[0] += 1
             M -= num_mines_in_row
 
     #print grid
     print ""Case #%d:"" % (test + 1)
     if impossible:
         print ""Impossible""
     else:
         for ii in range(Rorig):
             for jj in range(Corig):
                 if grid[ii][jj] == '.':
                     if ii - 1 >= 0 and grid[ii-1][jj] == '*':
                         grid[ii][jj] = 'dirty'
                     elif jj - 1 >= 0 and grid[ii][jj-1] == '*':
                         grid[ii][jj] = 'dirty'
                     elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':
                         grid[ii][jj] = 'dirty'
         #print grid
 
         for ii in range(Rorig):
             for jj in range(Corig):
                 if grid[ii][jj] == 'dirty':
                     if ii + 1 < Rorig and grid[ii+1][jj] == '.':
                         grid[ii][jj] = '.'
                     elif jj + 1 < Corig and grid[ii][jj+1] == '.':
                         grid[ii][jj] = '.'
                     elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':
                         grid[ii][jj] = '.'
                     else:
                         if ii != Rorig - 1 or jj != Corig - 1:
                             impossible = True
         #print grid
 
         if impossible:
             print ""Impossible""
         else:
             grid[Rorig-1][Corig-1] = 'c'
 
             for ii in range(Rorig):
                 print "" "".join([val for val in grid[ii]])
 
 
",16,218,890
"*
 
 f = open(sys.argv[1])
 T = int(f.readline())
 for test in range(T):
     data = f.readline().split()
     C = Decimal(data[0])
     F = Decimal(data[1])
     X = Decimal(data[2])
     curr_rate = Decimal(2)
     best_time = Decimal(10**100)
     curr_time = Decimal(0)
     while curr_time < best_time:
         poss_finish_time = curr_time + X / curr_rate
         if poss_finish_time < best_time:
             best_time = poss_finish_time
 
         curr_time += C / curr_rate
         curr_rate += F
 
     print ""Case #%d: %.7f"" % (test + 1, best_time)
",16,219,216
"# coding: utf-8
 (v):
     pass #print(v)
 
 def read(f):
     t = tuple(int(v) for v in f.readline().split())
     debug(t)
     return t
 
 def answer(f, X, ans):
     out = ""Case #{}: {}"".format(X, ans)
     f.write(out)
     f.write(""\n"")
     print(out)
 
 
 
 def main(inf, outf):
     T, = read(inf)
     for X in range(1, T + 1):
         row1, = read(inf)
         cards1 = tuple(read(inf) for i in range(4))
         row2, = read(inf)
         cards2 = tuple(read(inf) for i in range(4))
 
         kouho = set(cards1[row1 - 1]).intersection(cards2[row2 - 1])
 
         if kouho:
             if len(kouho) == 1:
                 ans = kouho.pop()
             else:
                 ans = ""Bad magician!""
         else:
             ans = ""Volunteer cheated!""
 
         answer(outf, X, ans)
 
 
 if __name__==""__main__"":
     infname = sys.argv[1]
     outfname = os.path.splitext(infname)[0] + "".out""
     with open(infname, ""r"") as inf:
         with open(outfname, ""w"") as outf:
             main(inf, outf)
",17,220,391
"# coding: utf-8
 (f):
     return list( int(v) for v in f.readline().split() )
 
 def answer(f, X, ans):
     out = ""Case #{}: {}"".format(X, ans)
     f.write(out)
     f.write(""\n"")
     print(out)
 
 def testcases(f):
     T = int(f.readline())
     for X in range(1, T + 1):
         N, M = read(f)
         GRASS = []
         for n in range(N):
             GRASS.append( read(f) )
         result = yield X, N, M, GRASS
 
 def main(inf, outf):
     for X, N, M, GRASS in testcases(inf):
         maxN = list( max(gn) for gn in GRASS )
         maxM = list( max( gn[m] for gn in GRASS ) for m in range(M) )
 
         ans = ""YES""
         for n, m in ( (n, m) for m in range(M) for n in range(N) ):
             if ( GRASS[n][m] < maxN[n] and
                  GRASS[n][m] < maxM[m] ):
                 ans = ""NO""
                 break
         
         answer(outf, X, ans)
 
 if __name__==""__main__"":
     infname = sys.argv[1]
     outfname = os.path.splitext(infname)[0] + "".out""
     with open(infname, ""r"") as inf:
         with open(outfname, ""w"") as outf:
             main(inf, outf)
",17,221,430
"():
     with open(sys.argv[1], ""r"") as f:
         f.readline()  # skip number of testcases
         for X, T in enumerate(f, 1):
             yield X, [int(t) for t in T.split()]
 
 def main():
     for X, T in testcases():
         A = T[0]
         B = T[1]
         y = 0
         strA = str(A)
         for n in range(B, A - 1, - 1):
             b = str(n)
             chk = set()
             for i in range(1, len(b)):
                 a = b[i:] + b[:i]
                 if a not in chk and strA <= a < b:
                     chk.add(a)
                     y += 1
 
         print(""Case #{:d}: {:d}"".format(X, y))
 
 if __name__==""__main__"":
     main()
",17,222,242
"# coding: utf-8
 ():
     with open(sys.argv[1], ""r"") as f:
         T = int(f.readline())
         for X in range(1, T + 1):
             BOARD = [
                 f.readline().strip(),
                 f.readline().strip(),
                 f.readline().strip(),
                 f.readline().strip(),
             ]
             f.readline()
             yield X, BOARD
 
 def main():
     for X, BOARD in testcases():
         points = [0] * 10
         for iR, cols in enumerate(BOARD):
             cols = list( p(c) for c in cols )
 
             # 
             points[iR] = sum(cols)
 
             # c
             for iC, c in enumerate(cols):
                 points[4 + iC] += c  # c
 
             # Î
             points[8] += cols[0 + iR]
             points[9] += cols[3 - iR]
 
         status = ""Draw""
         for pp in points:
             if pp >= 1000:
                 status = ""Game has not completed""
             elif pp in (4, 103):
                 status = ""X won""
                 break
             elif pp in (40, 130):
                 status = ""O won""
                 break
 
         print(""Case #{}: {}"".format(X, status))
 
 
 def p(c):
     if  c == 'X':
         return 1
     elif c == 'O':
         return 10
     elif c == 'T':
         return 100
     else:
         return 1000
 
 if __name__==""__main__"":
     main()
",17,223,436
"# coding:utf-8
 ():
     with open(sys.argv[1], ""r"") as f:
         f.readline()  # skip number of testcases
         for X, T in enumerate(f, 1):
             yield X, [int(t) for t in T.split()]
 
 def main():
     for X, T in testcases():
         N = T[0]   # the number of Googlers
         S = T[1]   # the number of surprising triplets of scores
         p = T[2]   # best result of at least
 
         y = 0
 
         for t in T[3:]:
             d, m = divmod(t, 3)
             if m == 0:
                 if p <= d:
                     y += 1
                 elif 0 <= d - 1 <= p <= d + 1 <= 10 and S:
                     y += 1
                     S -= 1
             elif m == 1:
                 if p <= d + 1:
                     y += 1
             else:
                 if p <= d + 1:
                     y += 1
                 elif p <= d + 2 and S:
                     y += 1
                     S -= 1
 
         print(""Case #{:d}: {:d}"".format(X, y))
 
 if __name__==""__main__"":
     main()
",17,224,341
"# coding: utf-8
 (v):
     pass#print(v)
 
 def read(f):
     t = tuple(int(v) for v in f.readline().split())
     debug(t)
     return t
 
 def readf(f):
     t = tuple(float(v) for v in f.readline().split())
     debug(t)
     return t
 
 def answer(f, X, Y, Z):
     out = ""Case #{}: {} {}"".format(X, Y, Z)
     f.write(out)
     f.write(""\n"")
     print(out)
 
 
 
 def main(inf, outf):
     T, = read(inf)
     for casenmbr in range(1, T + 1):
         N = read(inf)
         naomi_blks = sorted(readf(inf))
         ken_blks = sorted(readf(inf))
         # print(""------"")
         # print(naomi_blks)
         # print(ken_blks)
 
         y = len([None for naomi in naomi_blks if ken_blks[0] < naomi])
 
         z = 0
         for naomi in naomi_blks:
             for i in range(len(ken_blks)):
                 if naomi < ken_blks[i]:
                     del ken_blks[i]
                     break
             else:
                 z += 1
                 del ken_blks[0]
 
         answer(outf, casenmbr, y, z)
 
 
 if __name__==""__main__"":
     infname = sys.argv[1]
     outfname = os.path.splitext(infname)[0] + "".out""
     with open(infname, ""r"") as inf:
         with open(outfname, ""w"") as outf:
             main(inf, outf)
",17,225,479
"# coding: utf-8
 (f):
     return list( int(v) for v in f.readline().split() )
 
 def answer(f, X, ans):
     out = ""Case #{}: {}"".format(X, ans)
     f.write(out)
     f.write(""\n"")
     print(out)
 
 def testcases(f):
     T = int(f.readline())
     for X in range(1, T + 1):
         A, B = read(f)
         yield X, A, B
 
 def ispalindrome(v):
     s = str(v)
     for i in range(len(s) // 2):
         if s[i] != s[-i-1]:
             return False
     return True
 
 def main(inf, outf):
     MAX = 1000
     fslst = []
     for i in itertools.count():
         if ispalindrome(i):
             squere = i * i
             print(MAX, squere, ispalindrome(squere))
             if squere > MAX:
                 break
             if ispalindrome(squere):
                 fslst.append(squere)
     for X, A, B in testcases(inf):
         cnt = 0
         for fs in fslst:
             if A <= fs <= B:
                 cnt += 1
         answer(outf, X, cnt)
 
 if __name__==""__main__"":
     infname = sys.argv[1]
     outfname = os.path.splitext(infname)[0] + "".out""
     with open(infname, ""r"") as inf:
         with open(outfname, ""w"") as outf:
             main(inf, outf)
",17,226,437
"():
     with open(sys.argv[1], ""r"") as f:
         f.readline()  # skip number of testcases
         for X, T in enumerate(f, 1):
             yield X, T[:-1]
 
 def main():
     for X, T in testcases():
         tbl = str.maketrans(""abcdefghijklmnopqrstuvwxyz"",
                             ""yhesocvxduiglbkrztnwjpfmaq"")
         S = T.translate(tbl)
         print(""Case #{:d}: {}"".format(X, S))
 
 if __name__==""__main__"":
   main()
   
",17,227,165
"# coding: utf-8
 (v):
     pass#print(v)
 
 def read(f):
     t = tuple(int(v) for v in f.readline().split())
     debug(t)
     return t
 
 def readf(f):
     t = tuple(float(v) for v in f.readline().split())
     debug(t)
     return t
 
 def answer(f, X, ans):
     out = ""Case #{}: {}"".format(X, ans)
     f.write(out)
     f.write(""\n"")
     print(out)
 
 
 
 def main(inf, outf):
     T, = read(inf)
     for casenmbr in range(1, T + 1):
         C, F, X = readf(inf)
 
         power = 2
         farmtime = round(C / power, 7)
         keikatime = 0
         totaltime = round(X / power, 7)
 
         while True:
             keikatime += farmtime
             power += F
             farmtime = round(C / power, 7)
             nokoritime = round(X / power, 7)
             if keikatime + nokoritime > totaltime:
                 break
             totaltime = keikatime + nokoritime
 
         answer(outf, casenmbr, totaltime)
 
 
 if __name__==""__main__"":
     infname = sys.argv[1]
     outfname = os.path.splitext(infname)[0] + "".out""
     with open(infname, ""r"") as inf:
         with open(outfname, ""w"") as outf:
             main(inf, outf)
",17,228,437
"T = int(raw_input().strip())
 
 for j in xrange(T):
 	row_num1 = int(raw_input().strip())
 	for i in xrange(4):
 		if i + 1 == row_num1:
 			row1 = set(map(int, raw_input().strip().split(' ')))
 		else:
 			raw_input()
 	row_num2 = int(raw_input().strip())
 	for i in xrange(4):
 		if i + 1 == row_num2:
 			row2 = set(map(int, raw_input().strip().split(' ')))
 		else:
 			raw_input()
 	common = row1 & row2
 	lc = len(common)
 	if lc == 1:
 		stuff = list(common)[0]
 	elif lc > 1:
 		stuff = ""Bad magician!""
 	else:
 		stuff = ""Volunteer cheated!""
 
 	print ""Case #%s: %s"" % (j + 1, stuff)
",18,229,292
"(x):
 	if x < 2:
 		return 0
 	return x * (x - 1) / 2
 
 def solve(low, high):
 	was = [0 for i in range(low, high + 1)]
 	total = 0
 
 	for i in xrange(low, high + 1):
 		if was[i - low] == 0:
 			was[i - low] = 1
 			variations = set([i])
 			
 			if global_variations[i] != []:
 				for j in global_variations[i]:
 					if j >= low and j <= high:
 						was[j - low] = 1
 						variations.add(j)
 			else:
 				curr = i
 				clen = int(floor(log10(i)))
 				pow10 = pow(10, clen)
 				cgvariations = set(list(variations))
 				for i in range(clen):
 					pre = curr % 10
 					curr = pow10 * pre + (curr - (curr % 10)) / 10
 					if pre != 0 and curr not in variations and curr >= low and curr <= high:
 						variations.add(curr)
 						was[curr - low] = 1
 					if pre != 0 and curr < ma and curr not in cgvariations:
 						cgvariations.add(curr)
 
 				for cg in cgvariations:
 					global_variations[cg] = list(cgvariations)
 
 			total += grab2(len(variations))
 
 
 	return total
 
 f = open(argv[1], 'r')
 T = int(f.readline().strip('\n'))
 mi = 2000000
 ma = 1
 ab = []
 for i in range(T):
 	ab.append(map(int, f.readline().strip('\n').split(' ')))
 	if ab[-1][1] > ma:
 		ma = ab[-1][1]
 
 global_variations = [[] for i in range(ma + 2)]
 
 i = 1
 for x in ab:
 	print ""Case #%s: %s"" % (i, solve(x[0],x[1]))
 	i += 1",18,230,680
"X_WON = 0
 O_WON = 1
 DRAW = 2
 NEITHER = 3
 
 messages = [
     ""X won"",
     ""O won"",
     ""Draw"",
     ""Game has not completed""
 ]
 
 
 def check_win(state):
     if state['X'] == 4 or state['X'] == 3 and state['T'] == 1:
         return X_WON
     elif state['O'] == 4 or state['O'] == 3 and state['T'] == 1:
         return O_WON
     else:
         return -1
 
 def check_state(table):
 
     # Check rows
     for i in xrange(4):
         state = {'T': 0, 'X': 0, 'O': 0, '.': 0}
         for j in xrange(4):
             state[table[i][j]] += 1
         res = check_win(state)
         if res != -1:
             return res
 
     # Check cols
     for i in xrange(4):
         state = {'T': 0, 'X': 0, 'O': 0, '.': 0}
         for j in xrange(4):
             state[table[j][i]] += 1
         res = check_win(state)
         if res != -1:
             return res
 
     # Check diags
     # Normal
     state = {'T': 0, 'X': 0, 'O': 0, '.': 0}
     for i in xrange(4):
         state[table[i][i]] +=  1
     res = check_win(state)
     if res != -1:
         return res
 
     # Cross
     state = {'T': 0, 'X': 0, 'O': 0, '.': 0}
     for i in xrange(4):
         state[table[i][3 - i]] +=  1
     res = check_win(state)
     if res != -1:
         return res
 
     # Check not full
     for i in xrange(4):
         for j in xrange(4):
             if table[i][j] == '.':
                 return NEITHER
 
     # It's a draw
     return DRAW
 
 T = int(raw_input().strip())
 for i in xrange(T):
     table = [[] for _ in xrange(4)]
     for j in xrange(4):
         table[j] = list(raw_input().strip())
     # print ""table: %s"" % table
     if i != T - 1:
         raw_input()
     print ""Case #%s: %s"" % (i + 1, messages[check_state(table)])",18,231,682
"= [[], [], [(0, 0, 2)], [(0, 1, 2)], [(0, 2, 2)], [(1, 1, 3)], [(1, 2, 3)], [(1, 3, 3)], [(2, 2, 4)], [(2, 3, 4)], [(2, 4, 4)], [(3, 3, 5)], [(3, 4, 5)], [(3, 5, 5)], [(4, 4, 6)], [(4, 5, 6)], [(4, 6, 6)], [(5, 5, 7)], [(5, 6, 7)], [(5, 7, 7)], [(6, 6, 8)], [(6, 7, 8)], [(6, 8, 8)], [(7, 7, 9)], [(7, 8, 9)], [(7, 9, 9)], [(8, 8, 10)], [(8, 9, 10)], [(8, 10, 10)], [], []]
 regular = [[(0, 0, 0)], [(0, 0, 1)], [(0, 1, 1)], [(1, 1, 1)], [(1, 1, 2)], [(1, 2, 2)], [(2, 2, 2)], [(2, 2, 3)], [(2, 3, 3)], [(3, 3, 3)], [(3, 3, 4)], [(3, 4, 4)], [(4, 4, 4)], [(4, 4, 5)], [(4, 5, 5)], [(5, 5, 5)], [(5, 5, 6)], [(5, 6, 6)], [(6, 6, 6)], [(6, 6, 7)], [(6, 7, 7)], [(7, 7, 7)], [(7, 7, 8)], [(7, 8, 8)], [(8, 8, 8)], [(8, 8, 9)], [(8, 9, 9)], [(9, 9, 9)], [(9, 9, 10)], [(9, 10, 10)], [(10, 10, 10)]]
 
 f = open(argv[1], 'r')
 T = int(f.readline().strip('\n'))
 for i in range(T):
 	both = 0
 	surp_only = 0
 	line = f.readline().strip('\n').split(' ')
 	N = int(line[0]) # What for?
 	S = int(line[1])
 	p = int(line[2])
 	ts = map(int, line[3:])
 	for t in ts:
 		if reduce(max, map(max, regular[t])) >= p:
 			both += 1
 		elif surprising[t] != [] and reduce(max, map(max, surprising[t])) >= p:
 			surp_only += 1
 
 	print ""Case #%s: %s"" % (i + 1, both + min(surp_only, S))",18,232,831
"T = int(raw_input().strip())
 
 for i in xrange(T):
 	N = int(raw_input().strip())
 	naomi = sorted(map(float, raw_input().strip().split(' ')))
 	# print ""naomi: %s""  % naomi
 	ken = sorted(map(float, raw_input().strip().split(' ')))
 	# print ""ken: %s"" % ken
 
 	war_score = N
 	np = 0
 	kp = 0
 	while np < N and kp < N:
 		while kp < N and naomi[np] >= ken[kp]:
 			kp += 1
 		if kp < N:
 			kp += 1
 			np += 1
 			war_score -= 1
 
 	d_war_score = N
 	best = None
 	for start_from in xrange(N):
 		j = 0
 		good = True
 		while start_from + j < N:
 			if ken[j] >= naomi[start_from + j]:
 				good = False
 				break
 			j += 1
 		if good:
 			best = N - start_from
 			break
 	if best is not None:
 		d_war_score = best
 	else:
 		d_war_score = 0
 
 	print ""Case #%s: %s %s"" % (i + 1, d_war_score, war_score)
",18,233,419
"# In general 1[10]*1 square is always a palindrome and some subset of [12][012]*[12] is also good but it's just
 # too much hassle to figure that out. Also needs a more complex generator for ranges. 55p is hard...
 
 
 LIMIT = 10
 
 def check_palindrome(number):
     rev = 0
     runner = number
     while runner > 0:
         rev = rev * 10 + (runner % 10)
         runner /= 10
     if rev == number:
         return True
     else:
         return False
 
 def list_to_number(number_list):
     l = len(number_list)
     res = 0; rres = 0
     multi = 1
     for i in xrange(1, l + 1):
         res += number_list[l - i] * multi
         rres += number_list[i - 1] * multi
         multi *= 10
     return (res, rres)
 
 def gen_one_side(side_length):
     state = [0 for _ in xrange(side_length)]
     done = False
 
     while not done:
         if state[-1] != 0:
             yield state
         state[-1] += 1
         curr = side_length - 1
         while state[curr] == LIMIT:
             if curr == 0:
                 done = True
                 break
             state[curr] = 0
             curr -= 1
             state[curr] += 1
 
 def gen_odd_palindrome(side_length):
     if side_length == 0:
         for i in xrange(1, 10):
             yield i
     else:
         multi = 10**side_length
         for one_side in gen_one_side(side_length):
             number, rnumber = list_to_number(one_side)
             for i in xrange(LIMIT):
                 yield number + i * multi + rnumber * multi * 10
 
 def gen_even_palindrome(side_length):
     multi = 10**side_length
     for one_side in gen_one_side(side_length):
         number, rnumber = list_to_number(one_side)
         yield number + rnumber * multi
 
 
 def gen_palindrome():
     l = 1
 
     while True:
         if l % 2 == 1:
             for odd_pal in gen_odd_palindrome((l - 1) / 2):
                 yield odd_pal
         else:
             for even_pal in gen_even_palindrome(l / 2):
                 yield even_pal
         l += 1
 
 
 cache = []
 upper = 10**14
 for pal in gen_palindrome():
     pal2 = pal**2
     if pal2 > upper:
         break
     if check_palindrome(pal2):
         cache.append(pal2)
 
 cl = len(cache)
 T = int(raw_input().strip())
 for i in xrange(T):
     low_ind = 0
     high_ind = cl - 1
     A, B = map(int, raw_input().strip().split(' '))
 
     # The cache is small for 10**14
     while cache[low_ind] < A:
         low_ind += 1
     while cache[high_ind] > B:
         high_ind -= 1
 
 
     if low_ind <= high_ind:
         print ""Case #%s: %s"" % (i + 1, high_ind - low_ind + 1)
     else:
         print ""Case #%s: 0"" % (i + 1)
",18,234,937
"= { ""a"": ""y"", ""c"": ""e"", ""b"": ""h"", ""e"": ""o"", ""d"": ""s"", ""g"": ""v"", ""f"": ""c"", ""i"": ""d"", ""h"": ""x"", ""k"": ""i"", ""j"": ""u"", ""m"": ""l"", ""l"": ""g"", ""o"": ""k"", ""n"": ""b"", ""p"": ""r"", ""s"": ""n"", ""r"": ""t"", ""u"": ""j"", ""t"": ""w"", ""w"": ""f"", ""v"": ""p"", ""y"": ""a"", ""x"": ""m"", ""q"": ""z"", ""z"": ""q""}
 
 def translator(s):
 	ret = []
 	for c in s:
 		if ord(c) > 96 and ord(c) < 123:
 			ret.append(mapping[c])
 		else:
 			ret.append(c)
 
 	return ''.join(ret)
 
 f = open(argv[1], 'r')
 T = int(f.readline().strip('\n'))
 for i in range(T):
 	line = f.readline().strip('\n')
 	print ""Case #%s: %s"" % (i + 1, translator(line))",18,235,322
"T = int(raw_input().strip())
 misses = set()
 
 for i in xrange(T):
 	R, C, M = map(int, raw_input().strip().split(' '))
 	F = R * C - M
 	# print ""F: %s, R: %s, C: %s, M: %s"" % (F, R, C, M)
 	impossible = False
 	if F == 1:
 		matrix = [""c"" + ""*"" * (C - 1)]
 		for _ in xrange(R - 1):
 			matrix.append(""*"" * C)
 	elif R == 1:
 		matrix = [""c"" + ""."" * (F - 1) + ""*"" * (C - F)]
 	elif C == 1:
 		matrix = [""c""]
 		for _ in xrange(F - 1):
 			matrix.append(""."")
 		for _ in xrange(R - F):
 			matrix.append(""*"")
 	elif R == 2:
 		if F % 2 == 0 and (C > 1 and F != 2 or C == 1 and F <= 2):
 			matrix = [
 				""c"" + ""."" * (F / 2 - 1) + ""*"" * (C - F / 2),	
 				""."" * (F / 2) + ""*"" * (C - F / 2)
 			]
 		else:
 			matrix = []
 			impossible = True
 	else:
 		stack = []
 		matrix = []
 		for j in xrange(C, 1, -1):
 			if F - 2 * j >= 0 and (R - 2) * j >= F - 2 * j:
 				stack.append([j, j])
 
 		while stack:
 			# print ""stack: %s"" % stack
 			elems = stack.pop()
 			se = sum(elems)
 			if se == F:
 				for count in elems:
 					matrix.append(""."" * count + ""*"" * (C - count))
 				for _ in xrange(R - len(elems)):
 					matrix.append(""*"" * C)
 				matrix[0] = ""c"" + matrix[0][1:]
 				break
 			elif len(elems) < R:
 				for j in xrange(elems[-1], 1, -1):
 					if F - se - j >= 0 and (R - len(elems)) * j >= F - se:
 						stack.append(elems[::] + [j])
 
 		if matrix == []:
 			impossible =True
 
 	print ""Case #%s:"" % (i + 1)
 	if impossible:
 		print ""Impossible""
 	else:
 		for row in matrix:
 			print row
",18,236,810
"T = int(raw_input().strip())
 
 for i in xrange(T):
 	C, F, X = map(float, raw_input().strip().split(' '))
 	best = X / 2.0
 	c_sum = 0
 	factories = 1
 	n_sum = c_sum + C / (2.0 + (factories - 1) * F)
 	while n_sum + X / (2.0 + factories * F) < best:
 		best = n_sum + X / (2.0 + factories * F)
 		c_sum = n_sum
 		factories += 1
 		n_sum = c_sum + C / (2.0 + (factories - 1) * F)
 
 	print ""Case #%s: %s"" % (i + 1, best)
",18,237,219
"T = int(raw_input())
 
 def readMatrix(nlines):
     return [map(int, raw_input().split(' ')) for i in xrange(nlines)]
 
 def transpose(A):
     return map(lambda i: map(lambda line: line[i], A), xrange(len(A[0])))
 
 for z in xrange(T):
     M, N = map(int, raw_input().split(' '))
     A = readMatrix(M)
     b = map(max, A)
     c = map(max, transpose(A))
     fl = True
     for i in xrange(M):
         for j in xrange(N):
             if A[i][j] != min(b[i], c[j]):
                 fl = False
     print ""Case #%d: %s"" % (z+1, ""YES"" if fl else ""NO"")",19,238,220
"T = int(raw_input())
 
 def isRecycle(x, y, d):
     k = 10**(d-1)
     for i in xrange(ndigits):
         y = k*(y%10) + y/10
         if x == y:
             return True
     return False
 
 for z in xrange(1, T+1):
     res = 0
     A, B = map(int, raw_input().split())
     ndigits = len(str(A))
     for i in xrange(A, B):
         for j in xrange(i+1, B+1):
            if isRecycle(i, j, ndigits):
                res += 1
     print ""Case #%d:"" % z, res",19,239,190
"n = int(raw_input())
 
 d = {'X':2, 'O': 0, 'T':1, '.':-10}
 
 def readGame():
     return [map(lambda c:d[c], raw_input().strip()) for i in xrange(4)]
 
 def check(game):
     s = []
     for i in xrange(4): # horizontal
         s.append(sum(game[i]))
     for i in xrange(4): # vertical
         s.append(sum(map(lambda li: li[i], game)))
     d1 = d2 = 0 # diagonal
     for i in xrange(4):
         d1 += game[i][i]
         d2 += game[i][3-i]
     s.append(d1)
     s.append(d2)
     if max(s) >= 7:
         return ""X won"";
     gr0 = filter(lambda n: n >= 0, s)
     if len(gr0) > 0 and min(gr0) <= 1:
         return ""O won""
     if min(s) < 0:
         return ""Game has not completed""
     return ""Draw""
 
 for i in xrange(n):
     game = readGame()
     if i + 1 < n:
         raw_input()
 
     print ""Case #%d: %s"" % (i+1, check(game))",19,240,348
"T = int(raw_input())
 
 for z in xrange(1, T+1):
     a = map(int, raw_input().split())
     s, p = a[1:3]
     a = a[3:]
     A = 0 if p == 0 else 3*p - 2
     B = 0 if p == 0 else 1 if p == 1 else 3*p-4
     x = len(filter(lambda x: x >= A, a))
     y = len(filter(lambda x: x >= B, a)) - x
     res = x + min(s, y)
     print ""Case #%d:"" % z, res",19,241,163
"T = int(raw_input())
 
 def solve(a, b):
     n = len(a)
     a.sort()
     b.sort()
     i = j = m = M = 0
     while i < n:
         if a[i] > b[j]:
             M += 1
             i += 1
             j += 1
         else:
             i += 1
     i = j = 0
     while j < n:
         if b[j] > a[i]:
             m += 1
             i += 1
             j += 1
         else:
             j += 1
     return str(M) + "" "" + str(n-m)
 
 for z in xrange(T):
     n = int(raw_input())
     a = map(float, raw_input().split())
     b = map(float, raw_input().split())
     print ""Case #%d: %s"" % (z+1, solve(a, b))",19,242,242
"(N):
     msq = range(1, 4) + [11, 22] + [101, 111, 121, 202, 212]
     nums = revnums = [1, 2]
 
     digsums = [1, 4]
 
     for i in xrange(2, N+1):
         a, b, d = [], [], []
         p = 10**(i-1)
         for j in xrange(len(nums)):
             for k in xrange(3):
                 n, rn, ds = 10*nums[j] + k, revnums[j] + k*p, digsums[j] + k*k
                 if ds < 5:
                     a.append(n)
                     b.append(rn)
                     d.append(ds)
                     msq.append(10*p*n + rn) # even length
                     if i == N:
                         continue
                     for l in xrange(3): # odd length
                         if 2*ds + l*l < 10:
                             msq.append(100*p*n + 10*p*l + rn)
         nums, revnums, digsums = a, b, d
 
     msq.sort()
     return msq
 
 def getNum(A, B):
     return bisect_right(tab2, B) - bisect_right(tab2, A-1)
 
 N = 10
 tab = generateTable(N)
 tab2 = map(lambda n: n**2, tab)
 
 T = int(raw_input())
 for z in xrange(T):
     A, B = map(int, raw_input().split())
     print ""Case #%d: %d"" % (z+1, getNum(A, B))
",19,243,472
"inps = [""ejp mysljylc kd kxveddknmc re jsicpdrysi"", ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"", ""de kr kd eoya kw aej tysr re ujdr lkgc jv""]
 outs = [""our language is impossible to understand"",""there are twenty six factorial possibilities"", ""so it is okay if you want to just give up""]
 
 d = {'z':'q', 'q':'z'}
 
 for i in xrange(3):
     inp, out = inps[i], outs[i]
     for j in xrange(len(inp)):
         d[inp[j]] = out[j]
 
 n = int(raw_input())
 for i in xrange(n):
     s = raw_input()
     print ""Case #%d:"" % (i+1), """".join(map(lambda c: d[c], s))",19,244,236
"= int(raw_input())
 
 def generate(R, C, a, sw):
     if sw:
         R, C = C, R
     res = [['*']*C for i in xrange(R)]
     for i in xrange(len(a)):
         for j in xrange(a[i]):
             if sw:
                 res[j][i] = '.'
             else:
                 res[i][j] = '.'
     res[0][0] = 'c'
     return str(res)[2:-2].replace(' ', '').replace(""'"",'').replace('[', '').replace('],','\n').replace(',', '')
 
 
 def solveEq(k, s, x1):
     if 2*(x1 + k - 2) > s or k*x1 < s:
         return None
     r = [0]*k
     r[0] = r[1] = x1
     s -= 2*x1
     for i in xrange(k-2, 0, -1):
         t = min(x1, s - 2*i + 2)
         r[k-i] = t
         s -= t
     return r
 
 def solve(R, C, M):
     S = R*C
     nm = S - M
     if R == 1 or C == 1:
         if R == 1:
             return '*'*M + '.'*(S-M-1) + 'c'
         else:
             return '*\n'*M + '.\n'*(S-M-1) + 'c'
     else:
         sw = False
         if R > C:
             R, C = C, R
             sw = True
         if nm == 2 or nm == 3 or nm == 5 or nm == 7 or (R == 2 and nm%2 == 1 and nm > 1):
             return ""Impossible""
         if nm == 1:
             return generate(R, C, [1], sw)
         for k in xrange(2, R+1):
             for x1 in xrange(2, C+1):
                 r = solveEq(k, nm, x1)
                 if r != None:
                     return generate(R, C, r, sw)
         return ""Something wrong""
 
 for z in xrange(T):
     c, f, x = map(int, raw_input().split())
     print ""Case #%d:\n%s"" % (z+1, solve(c, f, x))",19,245,625
"T = int(raw_input())
 
 def solve(C, F, X):
     best = x/2
     buildTime, speed = 0, 2
     while True:
         buildTime += C/speed
         if buildTime > best:
             break
         speed += F
         best = min(best, buildTime + X/speed)
     return best
 
 for z in xrange(T):
     c, f, x = map(float, raw_input().split())
     print ""Case #%d: %.7f"" % (z+1, solve(c, f, x))",19,246,143
"#!/usr/bin/env python
 
 = ""tiny""
 if 1:
     INPUT = ""A-large.in""
     INPUT = ""A-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(a1, r1, a2, r2):
     p1 = set(r1[a1-1])
     p2 = set(r2[a2-1])
     u = p1.intersection(p2)
     if len(u) < 1:
         return ""Volunteer cheated!""
     if len(u) > 1:
         return ""Bad magician!""
     return list(u)[0]
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     rows1 = []
     a1 = int(f.readline()[:-1])
     for r in range(4):
         rows1.append([int(x) for x in f.readline().split()])
     a2 = int(f.readline()[:-1])
     rows2 = []
     for r in range(4):
         rows2.append([int(x) for x in f.readline().split()])
     v = do_trial(a1, rows1, a2, rows2)
     print ""Case #%d: %s"" % (i+1, v)
",20,247,518
"#!/usr/bin/env python
 
 = ""tiny""
 if 1:
     INPUT = ""B-small-attempt0.in""
 
 def debug(*args):
     pass #print str(args)
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args
 
 def do_trial(lawn):
     w = len(lawn[0])
     h = len(lawn)
     x_maxes = [max(lawn_row) for lawn_row in lawn]
     y_maxes = [max(lawn[y][x] for y in range(h)) for x in range(w)]
     def lawn_row(y):
         x_max = x_maxes[y]
         return tuple([min(y_maxes[x], x_max) for x in range(w)])
     new_lawn = tuple([lawn_row(y) for y in range(h)])
     #; pdb.set_trace()
     if new_lawn == lawn:
         return ""YES""
     return ""NO""
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     w, h = [int(x) for x in f.readline().split()]
     lawn = []
     for k in range(w):
         lawn.append(tuple([int(x) for x in f.readline().split()]))
     lawn = tuple(lawn)
     #if i==2:
     #    ; pdb.set_trace()
     v = do_trial(lawn)
     print ""Case #%d: %s"" % (i+1, v)
",20,248,551
"#!/usr/bin/env python
 
 = ""tiny""
 
 INPUT = ""C-small-attempt0.in.txt""
 
 def debug(*args):
     pass #print str(args)
 
 if 0:
     def debug(*args):
         sys.stderr(''.join(str(s) for s in args) + ""\n"")
 
 def recycleables(N, A, B):
     t = set()
     s = str(N)
     for i in range(len(s)):
         s1 = int(s[i:] + s[:i])
         if A <= s1 <= B:
             t.add(s1)
     return t
 
 def do_trial(A, B):
     total = 0
     seen = set()
     for i in xrange(A, B+1):
         if i not in seen:
             t = recycleables(i, A, B)
             z = len(t)
             total += z * (z-1) / 2
             seen.update(t)
     return total
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     A, B = [int(x) for x in f.readline()[:-1].split()]
     v = do_trial(A, B)
     print ""Case #%d: %s"" % (i+1, v)
",20,249,352
"#!/usr/bin/env python
 
 = ""tiny""
 if 1:
     INPUT = ""A-small-attempt0.in""
 
 def debug(*args):
     pass #print str(args)
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def check(board, x, y, dx, dy):
     #; pdb.set_trace()
     c = collections.Counter((board[x+dx*i][y+dy*i] for i in range(4)))
     if c.get(""X"", 0) + c.get(""T"", 0) == 4: return ""X won""
     if c.get(""O"", 0) + c.get(""T"", 0) == 4: return ""O won""
 
 def do_trial(board):
     #return ""X won"" #(the game is over, and X won)
     #""O won"" (the game is over, and O won)
     #""Draw"" (the game is over, and it ended in a draw)
     #""Game has not completed"" (the game is not over yet)
     for x in range(4):
         v = check(board, x, 0, 0, 1)
         if v: return v
         v = check(board, 0, x, 1, 0)
         if v: return v
     v = check(board, 0, 0, 1, 1)
     if v: return v
     v = check(board, 3, 0, -1, 1)
     if v: return v
     if '.' in ''.join(board):
         return ""Game has not completed""
     return ""Draw""
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     lines = [f.readline()[:-1] for j in range(4)]
     f.readline()
     v = do_trial(lines)
     print ""Case #%d: %s"" % (i+1, v)
",20,250,636
"#!/usr/bin/env python
 
 = ""tiny""
 
 INPUT = ""B-small-attempt0.in.txt""
 
 def debug(*args):
     pass #print str(args)
 
 def zdebug(*args):
     print ''.join(str(s) for s in args)
 
 def can_score_p(N, p):
     low_p = max(p-1, 0)
     if low_p + low_p + p <= N:
         return ""Y""
     low_p = max(p-2, 0)
     if low_p + low_p + p <= N:
         return ""S""
     return ""N""
 
 def do_trial(N, S, p, *scores):
     d = { ""Y"" : 0, ""N"" : 0, ""S"" : 0 }
     for s in scores:
         v = can_score_p(s, p)
         debug(""score %s p=%s : %s"" % (s, p, v))
         d[v] = d[v] + 1
     return d[""Y""] + min(d[""S""], S)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     l = [int(x) for x in f.readline()[:-1].split()]
     v = do_trial(*l)
     print ""Case #%d: %s"" % (i+1, v)
",20,251,373
"#!/usr/bin/env python
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""D-small-attempt0.in""
 #INPUT = ""D-large.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def war_wins(N, K):
     wins = 0
     debug(N, K)
     #; pdb.set_trace()
     while 1:
         if len(N) == 0:
             return wins
         N,n = N[:-1], N[-1]
         if n > K[-1]:
             wins += 1
             K = K[1:]
             continue
         for idx, v in enumerate(K):
             if v > n:
                 break
         K = K[:idx] + K[idx+1:]
 
 def dwar_wins(N, K):
     wins = 0
     while 1:
         if len(N) == 0:
             return wins
         n, N = N[0], N[1:]
         if n > K[0]:
             wins += 1
             K = K[1:]
         else:
             K = K[:-1]
 
 
 def do_trial(N, K):
     N.sort()
     K.sort()
     dww = dwar_wins(N, K)
     ww = war_wins(N, K)
     return ""%d %d"" % (dww, ww)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     f.readline()
     N = [float(x) for x in f.readline().split()]
     K = [float(x) for x in f.readline().split()]
     v = do_trial(N, K)
     print ""Case #%d: %s"" % (i+1, v)
",20,252,646
"#!/usr/bin/env python
 
 = ""tiny""
 if 1:
     INPUT = ""A-small-attempt2.in.txt""
 
 I=re.sub("" "", """", ""ejp mysljylc kd kxveddknmc re jsicpdrysirbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcdde kr kd eoya kw aej tysr re ujdr lkgc jv"")
 O=re.sub("" "", """", ""our language is impossible to understandthere are twenty six factorial possibilitiesso it is okay if you want to just give up"")
 
 #print I, O
 
 MAP={ 'z' : 'q', 'q' : 'z' }
 for i,o in zip(I,O):
     MAP[i] = o
 
 def debug(*args):
     pass #print str(args)
 
 def debug(*args):
     print str(args)
 
 def do_trial(l):
     t = list(l)
     t1 = [MAP.get(x, x) for x in t]
     return ''.join(t1)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     l = f.readline()[:-1]
     v = do_trial(l)
     print ""Case #%d: %s"" % (i+1, v)
",20,253,358
"#!/usr/bin/env python
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 #INPUT = ""C-large.in""
 INPUT = ""C-small-attempt1.in""
 
 def debug(*args):
     #return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 IMPOSSIBLE = set([(2,2,2), (2,2,1), (2,3,1), (2,4,1), (2,5,1)])
 
 for i in range(2,51):
     IMPOSSIBLE.add((2,i,1))
     IMPOSSIBLE.add((i,2,1))
 
 SOLN = {
     (1,2,1) : [""c*""],
     (2,1,1) : [""c"", ""*""],
     (2,2,3) : [""c*"", ""**""],
 }
 
 def solve(R, C, M):
     if M == 0:
         s = [""c%s"" % ('.' * (C-1))]
         for i in range(R-1):
             s.append('.' * C)
         return s
     t = (R, C, M)
     if t in IMPOSSIBLE:
         debug(""** %s %s %s"" % t)
         raise ValueError
     if t in SOLN:
         return SOLN[t]
 
     # last row?
     if C < M and R > 2:
         try:
             return solve(R-1, C, M-C) + [""*"" * C]
         except ValueError:
             pass
 
     if C <= R:
         if M >= C and R > 2:
             return solve(R-1, C, M-C) + [""*"" * C]
     else:
         if M >= R and C > 2:
             return [""%s*"" % s for s in solve(R, C-1, M-R)]
     if R > 2:
         # fill in last row
         mines = min(C, M)
         if mines == C - 1:
             mines -= 1
         try:
             return solve(R-1, C, M-mines) + [(""."" * (C - mines)) + (""*"" * mines)]
         except ValueError:
             if C > 2:
                 mines = min(R, M)
             if mines == R - 1:
                 mines -= 1
             s = [""%s%s"" % (s, '*' if k > C-mines else '.') for k, s in enumerate(solve(R, C-1, M-mines))]
             return s
     debug(R, C, M)
     return []
 
 def do_trial(R, C, M):
     try:
         r = solve(R,C,M)
         s = ""\n"" + '\n'.join(r)
         assert len(r) == R
         for r1 in r:
             assert len(r1) == C
         assert len(''.join(k for k in s if k == '*')) == M
         return s
     except ValueError:
         return ""\nImpossible""
 
 
 def all():
     for R in range(1,50):
         for C in range(1,50):
             for M in range(R*C):
                 print(R, C, M)
                 print(do_trial(R, C, M))
     sys.exit(0)
 
 #all()
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     R, C, M = [int(x) for x in f.readline().split()]
     #; pdb.set_trace()
     v = do_trial(R, C, M)
     print ""Case #%d: %s"" % (i+1, v)
",20,254,1129
"#!/usr/bin/env python
 
 (5000)
 
 INPUT = ""tiny""
 INPUT = ""B-large.in""
 INPUT = ""B-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(C, F, X, rate=2.0):
     #; pdb.set_trace()
     win_time_wait = X / rate
     buy_time = C / rate
     win_time_buy_1 = buy_time + X / (rate+F)
     if win_time_wait < win_time_buy_1:
         return win_time_wait
     return buy_time + do_trial(C, F, X, rate+F)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     C, F, X = [float(x) for x in f.readline().split()]
     v = do_trial(C, F, X)
     print ""Case #%d: %s"" % (i+1, v)
",20,255,443
"t = int(raw_input())
 
 for case in range(t):
 	r1 = int(raw_input())
 	c1 = []
 	for j in range(4):
 		c1.append([int(i) for i in raw_input().split()])
 
 	r2 = int(raw_input())
 	c2 = []
 	for j in range(4):
 		c2.append([int(i) for i in raw_input().split()])
 
 	num = -1
 	possibles = 0
 	for j in c1[r1-1]:
 		if c2[r2-1].count(j) == 1:
 			num = j
 			possibles += 1
 
 	if possibles > 1:
 		print 'Case #'+str(case+1)+': Bad magician!'
 	elif possibles == 0:
 		print 'Case #'+str(case+1)+': Volunteer cheated!'
 	else:
 		print 'Case #'+str(case+1)+': '+str(num)
",21,256,286
"t = int(raw_input())
 
 for case in range(t):
 	line = raw_input().split(' ')
 	n = int(line[0])
 	m = int(line[1])
 
 	l = []
 	for j in range(n):
 		a = raw_input().split(' ')
 		b = []
 		for x in a:
 			b.append(int(x))
 		l.append(b)
 
 	# para cada valor, revisar que la fila o columna que lo contenga sea de alto menor o igual
 
 	cumple = True
 	for i in range(n):
 		for j in range(m):
 			col = True
 			fil = True
 			for x in range(n):
 				if l[x][j] > l[i][j]:
 					col = False
 					break
 			for x in range(m):
 				if l[i][x] > l[i][j]:
 					fil = False
 					break
 
 			if not col and not fil:
 				cumple = False
 				break
 
 		if not cumple:
 			break
 
 	if cumple:
 		print 'Case #'+str(case+1)+': YES'
 	else:
 		print 'Case #'+str(case+1)+': NO'
",21,257,400
"t = int(raw_input())
 
 def mover(n, i):
 	s = str(n)
 	return int(s[i:] + s[:i])
 
 for i in range(t):
 	s = raw_input().split(' ')
 	a = int(s[0])
 	b = int(s[1])
 	total = 0
 	for n in range(a, b):
 		ms = []
 		for k in range(len(s[0])):
 			m = mover(n, k+1)
 			if m <= b and m > n and not m in ms:
 			#	print n, mover(n, k+1), k+1
 				ms.append(m)
 				total +=1
 
 
 	print 'Case #'+str(i+1)+':', total",21,258,228
"t = int(raw_input())
 
 code = 'yhesocvxduiglbkrztnwjpfmaq'
 
 for i in range(t):
 	l = []
 	for j in range(4):
 		l.append(raw_input())
 	if i != t-1:
 		raw_input()
 
 	# filas
 	v = False
 	fin = False
 	for li in l:
 		x = True
 		o = True
 		for c in li:
 			if c != 'X' and c != 'T':
 				x = False
 			if c != 'O' and c != 'T':
 				o = False
 			if c == '.':
 				v = True
 		if x:
 			print 'Case #'+str(i+1)+': X won'
 			fin = True
 		if o:
 			print 'Case #'+str(i+1)+': O won'
 			fin = True
 
 	if fin:
 		continue
 
 	#columnas
 	for a in range(4):
 		x = True
 		o = True
 		for b in range(4):
 			if l[b][a] != 'X' and l[b][a] != 'T':
 				x = False
 			if l[b][a] != 'O' and l[b][a] != 'T':
 				o = False
 		if x:
 			print 'Case #'+str(i+1)+': X won'
 			fin = True
 		if o:
 			print 'Case #'+str(i+1)+': O won'
 			fin = True
 	if fin:
 		continue
 
 	#diagonales
 	x = True
 	o = True
 	for j in range(4):
 		if l[j][j] != 'X' and l[j][j] != 'T':
 			x = False
 		if l[j][j] != 'O' and l[j][j] != 'T':
 			o = False
 	if x:
 		print 'Case #'+str(i+1)+': X won'
 		continue
 	if o:
 		print 'Case #'+str(i+1)+': O won'
 		continue
 	x = True
 	o = True
 	for j in range(4):
 		if l[3-j][j] != 'X' and l[3-j][j] != 'T':
 			x = False
 		if l[3-j][j] != 'O' and l[3-j][j] != 'T':
 			o = False
 	if x:
 		print 'Case #'+str(i+1)+': X won'
 		continue
 	if o:
 		print 'Case #'+str(i+1)+': O won'
 		continue
 
 	if v:
 		print 'Case #'+str(i+1)+': Game has not completed'
 	else:
 		print 'Case #'+str(i+1)+': Draw'
",21,259,858
"t = int(raw_input())
 
 max = [0, 1, 1, 2, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 7, 6, 7, 8, 7, 8, 9, 8, 9, 10, 9, 10, 10, 10]
 
 for i in range(t):
 	line = raw_input().split(' ')
 	n = int(line[0])
 	s = int(line[1])
 	p = int(line[2])
 
 	total = 0
 
 	for j in range(3, len(line)):
 		t = int(line[j])
 		if t == 0:
 			if p == 0:
 				total += 1
 		elif t%3 == 0:
 			if t/3 >= p:
 				total +=1
 			elif t/3 + 1 >= p and s>0:
 				total +=1
 				s -=1
 		elif t%3 == 1:
 			if (t+2)/3 >= p:
 				total +=1
 		else:
 			if (t+1)/3 >= p:
 				total +=1
 			elif (t+1)/3 + 1 >= p and s>0:
 				total +=1
 				s -=1
 
 
 
 	print 'Case #'+str(i+1)+':', total
 
 
",21,260,437
"t = int(raw_input())
 
 for case in range(t):
 	n = int(raw_input())
 	naomi = [float(i) for i in raw_input().split()]
 	ken = [float(i) for i in raw_input().split()]
 
 	naomi.sort()
 	ken.sort()
 	y = 0
 	z = 0
 
 	#print naomi
 	#print ken
 
 	na = naomi[:]
 	ke = ken[:]
 	while len(na) > 0:
 		nc = na.pop(0)
 		kc = -1
 		for i in range(len(ke)):
 			if ke[i] > nc:
 				kc = ke.pop(i)
 				break
 		if kc == -1:
 			kc = ke.pop(0)
 		if nc > kc:
 			z += 1
 
 
 	na = naomi[:]
 	ke = ken[:]
 	while len(ke) > 0:
 		kc = ke.pop(0)
 		nc = -1
 		for i in range(len(na)):
 			if na[i] > kc:
 				nc = na.pop(i)
 				break
 		if nc == -1:
 			nc = na.pop(0)
 		if nc > kc:
 			y += 1
 		#print nc, kc
 
 	print 'Case #'+str(case+1)+':', y, z
 	#print ''
",21,261,446
"t = int(raw_input())
 
 code = ['y', 'h', 'e', 's', 'o', 'c', 'v', 'x', 'd', 'u', 'i', 'g', 'l', 'b', 'k', 'r', 'z', 't', 'n', 'w', 'j', 'p', 'f', 'm', 'a', 'q']
 
 for i in range(t):
 	line = raw_input()
 	decoded = ''
 
 	for c in line:
 		if c==' ':
 			decoded += c
 		else:
 			decoded += code[ord(c)-97]
 
 	print 'Case #'+str(i+1)+':', decoded
",21,262,190
"t = int(raw_input())
 
 for case in range(t):
 	print 'Case #'+str(case+1)+':'
 	r, c, m = raw_input().split()
 	r = int(r)
 	c = int(c)
 	m = int(m)
 
 	if m==0:
 		print 'c' + ('.'*(c-1))
 		for i in range(r-1):
 			print '.'*c
 	elif r == 1:
 		print 'c'+('.'*(c-m-1))+('*'*(m))
 	elif c == 1:
 		print 'c'
 		for i in range(r-m-1):
 			print '.'
 		for i in range(m):
 			print '*'
 	elif r == 2:
 		if m%2==0 and c>2 and m<r*c-2:
 			print 'c'+('.'*(c-m/2-1))+('*'*(m/2))
 			print ('.'*(c-m/2))+('*'*(m/2))
 		elif m == r*c - 1:
 			print 'c'+('*'*(c-1))
 			print '*'*c
 		else:
 			print 'Impossible'
 	elif c == 2:
 		if m%2==0 and r>2 and m<r*c-2:
 			print 'c.'
 			for i in range(r-m/2-1):
 				print '..'
 			for i in range(m/2):
 				print '**'
 		elif m == r*c - 1:
 			print 'c*'
 			for i in range(r-1):
 				print '**'
 		else:
 			print 'Impossible'
 	elif c == 3 and r == 3:
 		if m == 1:
 			print 'c..'
 			print '...'
 			print '..*'
 		elif m == 2:
 			print 'Impossible'
 		elif m == 3:
 			print 'c..'
 			print '...'
 			print '***'
 		elif m == 4:
 			print 'Impossible'
 		elif m == 5:
 			print 'c.*'
 			print '..*'
 			print '***'
 		elif m == 6:
 			print 'Impossible'
 		elif m == 7:
 			print 'Impossible'
 		elif m == 8:
 			print 'c**'
 			print '***'
 			print '***'
 	elif c == 3 and r == 4:
 		if m == 1:
 			print 'c..'
 			print '...'
 			print '...'
 			print '..*'
 		elif m == 2:
 			print 'c..'
 			print '...'
 			print '..*'
 			print '..*'
 		elif m == 3:
 			print 'c..'
 			print '...'
 			print '...'
 			print '***'
 		elif m == 4:
 			print 'c.*'
 			print '..*'
 			print '..*'
 			print '..*'
 		elif m == 5:
 			print 'Impossible'
 		elif m == 6:
 			print 'c..'
 			print '...'
 			print '***'
 			print '***'
 		elif m == 7:
 			print 'Impossible'
 		elif m == 8:
 			print 'c.*'
 			print '..*'
 			print '***'
 			print '***'
 		elif m == 9:
 			print 'Impossible'
 		elif m == 10:
 			print 'Impossible'
 		elif m == 11:
 			print 'c**'
 			print '***'
 			print '***'
 			print '***'
 	elif c == 3 and r == 5:
 		if m == 1:
 			print 'c..'
 			print '...'
 			print '...'
 			print '...'
 			print '..*'
 		elif m == 2:
 			print 'c..'
 			print '...'
 			print '...'
 			print '..*'
 			print '..*'
 		elif m == 3:
 			print 'c..'
 			print '...'
 			print '..*'
 			print '..*'
 			print '..*'
 		elif m == 4:
 			print 'c..'
 			print '...'
 			print '...'
 			print '..*'
 			print '***'
 		elif m == 5:
 			print 'c.*'
 			print '..*'
 			print '..*'
 			print '..*'
 			print '..*'
 		elif m == 6:
 			print 'c..'
 			print '...'
 			print '...'
 			print '***'
 			print '***'
 		elif m == 7:
 			print 'c..'
 			print '...'
 			print '..*'
 			print '***'
 			print '***'
 		elif m == 8:
 			print 'Impossible'
 		elif m == 9:
 			print 'c..'
 			print '...'
 			print '***'
 			print '***'
 			print '***'
 		elif m == 10:
 			print 'Impossible'
 		elif m == 11:
 			print 'c.*'
 			print '..*'
 			print '***'
 			print '***'
 			print '***'
 		elif m == 12:
 			print 'Impossible'
 		elif m == 13:
 			print 'Impossible'
 		elif m == 14:
 			print 'c**'
 			print '***'
 			print '***'
 			print '***'
 			print '***'
 	elif c == 4 and r == 3:
 		if m == 1:
 			print 'c...'
 			print '....'
 			print '...*'
 		elif m == 2:
 			print 'c...'
 			print '...*'
 			print '...*'
 		elif m == 3:
 			print 'c..*'
 			print '...*'
 			print '...*'
 		elif m == 4:
 			print 'c...'
 			print '....'
 			print '****'
 		elif m == 5:
 			print 'Impossible'
 		elif m == 6:
 			print 'c.**'
 			print '..**'
 			print '..**'
 		elif m == 7:
 			print 'Impossible'
 		elif m == 8:
 			print 'c.**'
 			print '..**'
 			print '****'
 		elif m == 9:
 			print 'Impossible'
 		elif m == 10:
 			print 'Impossible'
 		elif m == 11:
 			print 'c***'
 			print '****'
 			print '****'
 	elif c == 4 and r == 4:
 		if m == 1:
 			print 'c...'
 			print '....'
 			print '....'
 			print '...*'
 		elif m == 2:
 			print 'c...'
 			print '....'
 			print '....'
 			print '..**'
 		elif m == 3:
 			print 'c...'
 			print '....'
 			print '...*'
 			print '..**'
 		elif m == 4:
 			print 'c...'
 			print '....'
 			print '....'
 			print '****'
 		elif m == 5:
 			print 'c...'
 			print '....'
 			print '...*'
 			print '****'
 		elif m == 6:
 			print 'c...'
 			print '....'
 			print '..**'
 			print '****'
 		elif m == 7:
 			print 'c..*'
 			print '...*'
 			print '...*'
 			print '****'
 		elif m == 8:
 			print 'c...'
 			print '....'
 			print '****'
 			print '****'
 		elif m == 9:
 			print 'Impossible'
 		elif m == 10:
 			print 'c.**'
 			print '..**'
 			print '..**'
 			print '****'
 		elif m == 11:
 			print 'Impossible'
 		elif m == 12:
 			print 'c.**'
 			print '..**'
 			print '****'
 			print '****'
 		elif m == 13:
 			print 'Impossible'
 		elif m == 14:
 			print 'Impossible'
 		elif m == 15:
 			print 'c***'
 			print '****'
 			print '****'
 			print '****'
 	elif c == 4 and r == 5:
 		if m == 1:
 			print 'c...'
 			print '....'
 			print '....'
 			print '....'
 			print '...*'
 		elif m == 2:
 			print 'c...'
 			print '....'
 			print '....'
 			print '....'
 			print '..**'
 		elif m == 3:
 			print 'c...'
 			print '....'
 			print '...*'
 			print '...*'
 			print '...*'
 		elif m == 4:
 			print 'c...'
 			print '....'
 			print '....'
 			print '....'
 			print '****'
 		elif m == 5:
 			print 'c..*'
 			print '...*'
 			print '...*'
 			print '...*'
 			print '...*'
 		elif m == 6:
 			print 'c...'
 			print '....'
 			print '....'
 			print '..**'
 			print '****'
 		elif m == 7:
 			print 'c..*'
 			print '...*'
 			print '...*'
 			print '..**'
 			print '..**'
 		elif m == 8:
 			print 'c...'
 			print '....'
 			print '....'
 			print '****'
 			print '****'
 		elif m == 9:
 			print 'c..*'
 			print '...*'
 			print '...*'
 			print '..**'
 			print '****'
 		elif m == 10:
 			print 'c.**'
 			print '..**'
 			print '..**'
 			print '..**'
 			print '..**'
 		elif m == 11:
 			print 'c..*'
 			print '...*'
 			print '...*'
 			print '****'
 			print '****'
 		elif m == 12:
 			print 'c...'
 			print '....'
 			print '****'
 			print '****'
 			print '****'
 		elif m == 13:
 			print 'Impossible'
 		elif m == 14:
 			print 'c..*'
 			print '...*'
 			print '****'
 			print '****'
 			print '****'
 		elif m == 15:
 			print 'Impossible'
 		elif m == 16:
 			print 'c.**'
 			print '..**'
 			print '****'
 			print '****'
 			print '****'
 		elif m == 17:
 			print 'Impossible'
 		elif m == 18:
 			print 'Impossible'
 		elif m == 19:
 			print 'c***'
 			print '****'
 			print '****'
 			print '****'
 			print '****'
 	elif c == 5 and r == 3:
 		if m == 1:
 			print 'c....'
 			print '.....'
 			print '....*'
 		elif m == 2:
 			print 'c....'
 			print '.....'
 			print '...**'
 		elif m == 3:
 			print 'c....'
 			print '.....'
 			print '..***'
 		elif m == 4:
 			print 'c...*'
 			print '....*'
 			print '...**'
 		elif m == 5:
 			print 'c....'
 			print '.....'
 			print '*****'
 		elif m == 6:
 			print 'c..**'
 			print '...**'
 			print '...**'
 		elif m == 7:
 			print 'c..**'
 			print '...**'
 			print '..***'
 		elif m == 8:
 			print 'Impossible'
 		elif m == 9:
 			print 'c.***'
 			print '..***'
 			print '..***'
 		elif m == 10:
 			print 'Impossible'
 		elif m == 11:
 			print 'c.***'
 			print '..***'
 			print '*****'
 		elif m == 12:
 			print 'Impossible'
 		elif m == 13:
 			print 'Impossible'
 		elif m == 14:
 			print 'c****'
 			print '*****'
 			print '*****'
 	elif c == 5 and r == 4:
 		if m == 1:
 			print 'c....'
 			print '.....'
 			print '.....'
 			print '....*'
 		elif m == 2:
 			print 'c....'
 			print '.....'
 			print '.....'
 			print '...**'
 		elif m == 3:
 			print 'c....'
 			print '.....'
 			print '.....'
 			print '..***'
 		elif m == 4:
 			print 'c...*'
 			print '....*'
 			print '....*'
 			print '....*'
 		elif m == 5:
 			print 'c....'
 			print '.....'
 			print '.....'
 			print '*****'
 		elif m == 6:
 			print 'c...*'
 			print '....*'
 			print '....*'
 			print '..***'
 		elif m == 7:
 			print 'c....'
 			print '.....'
 			print '...**'
 			print '*****'
 		elif m == 8:
 			print 'c..**'
 			print '...**'
 			print '...**'
 			print '...**'
 		elif m == 9:
 			print 'c...*'
 			print '....*'
 			print '...**'
 			print '*****'
 		elif m == 10:
 			print 'c....'
 			print '.....'
 			print '*****'
 			print '*****'
 		elif m == 11:
 			print 'c..**'
 			print '...**'
 			print '...**'
 			print '*****'
 		elif m == 12:
 			print 'c.***'
 			print '..***'
 			print '..***'
 			print '..***'
 		elif m == 13:
 			print 'Impossible'
 		elif m == 14:
 			print 'c.***'
 			print '..***'
 			print '..***'
 			print '*****'
 		elif m == 15:
 			print 'Impossible'
 		elif m == 16:
 			print 'c.***'
 			print '..***'
 			print '*****'
 			print '*****'
 		elif m == 17:
 			print 'Impossible'
 		elif m == 18:
 			print 'Impossible'
 		elif m == 19:
 			print 'c****'
 			print '*****'
 			print '*****'
 			print '*****'
 	elif c == 5 and r == 5:
 		if m == 1:
 			print 'c....'
 			print '.....'
 			print '.....'
 			print '.....'
 			print '....*'
 		elif m == 2:
 			print 'c....'
 			print '.....'
 			print '.....'
 			print '.....'
 			print '...**'
 		elif m == 3:
 			print 'c....'
 			print '.....'
 			print '.....'
 			print '.....'
 			print '..***'
 		elif m == 4:
 			print 'c....'
 			print '.....'
 			print '.....'
 			print '...**'
 			print '...**'
 		elif m == 5:
 			print 'c....'
 			print '.....'
 			print '.....'
 			print '.....'
 			print '*****'
 		elif m == 6:
 			print 'c....'
 			print '.....'
 			print '.....'
 			print '..***'
 			print '..***'
 		elif m == 7:
 			print 'c....'
 			print '.....'
 			print '.....'
 			print '...**'
 			print '*****'
 		elif m == 8:
 			print 'c....'
 			print '.....'
 			print '.....'
 			print '..***'
 			print '*****'
 		elif m == 9:
 			print 'c...*'
 			print '....*'
 			print '....*'
 			print '....*'
 			print '*****'
 		elif m == 10:
 			print 'c....'
 			print '.....'
 			print '.....'
 			print '*****'
 			print '*****'
 		elif m == 11:
 			print 'c....'
 			print '.....'
 			print '....*'
 			print '*****'
 			print '*****'
 		elif m == 12:
 			print 'c....'
 			print '.....'
 			print '...**'
 			print '*****'
 			print '*****'
 		elif m == 13:
 			print 'c....'
 			print '.....'
 			print '..***'
 			print '*****'
 			print '*****'
 		elif m == 14:
 			print 'c..**'
 			print '...**'
 			print '...**'
 			print '..***'
 			print '*****'
 		elif m == 15:
 			print 'c....'
 			print '.....'
 			print '*****'
 			print '*****'
 			print '*****'
 		elif m == 16:
 			print 'c..**'
 			print '...**'
 			print '...**'
 			print '*****'
 			print '*****'
 		elif m == 17:
 			print 'c..**'
 			print '...**'
 			print '..***'
 			print '*****'
 			print '*****'
 		elif m == 18:
 			print 'Impossible'
 		elif m == 19:
 			print 'c..**'
 			print '...**'
 			print '*****'
 			print '*****'
 			print '*****'
 		elif m == 20:
 			print 'Impossible'
 		elif m == 21:
 			print 'c.***'
 			print '..***'
 			print '*****'
 			print '*****'
 			print '*****'
 		elif m == 22:
 			print 'Impossible'
 		elif m == 23:
 			print 'Impossible'
 		elif m == 24:
 			print 'c****'
 			print '*****'
 			print '*****'
 			print '*****'
 			print '*****'
 	else:
 		print 'Impossible'
 
",21,263,6509
"t = int(raw_input())
 
 for case in range(t):
 
 	c, f, x = raw_input().split()
 	c = float(c)
 	f = float(f)
 	x = float(x)
 
 	t = 0
 	cps = 2.0
 	while c/cps < x/cps and t+x/cps > t+c/cps + x/(cps+f):
 		# print t, c/cps, x/cps
 		t += c/cps
 		cps += f
 		# raw_input()
 
 	t += x/cps
 
 	print 'Case #'+str(case+1)+':', t
",21,264,191
"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parseBoard(inp):
 	rowSel, = (int(x) for x in inp.readline().split())
 	board = tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for _ in xrange(4)
 		)
 	return board, rowSel - 1
 
 def parse(inp):
 	before, beforeSel = parseBoard(inp)
 	after, afterSel = parseBoard(inp)
 	return before, beforeSel, after, afterSel
 
 def solve(before, beforeSel, after, afterSel):
 	candidates = set(before[beforeSel]) & set(after[afterSel])
 
 	if len(candidates) == 0:
 		return ""Volunteer cheated!""
 	elif len(candidates) == 1:
 		return candidates.pop()
 	else:
 		return ""Bad magician!""
 
 def main():
 	(RECURSION_LIMIT)
 
 	= resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		= Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",22,265,670
"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	rows, cols = (int(x) for x in inp.readline().split())
 	return tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for row in xrange(rows)
 		),
 
 def solve(lawn):
 	#print lawn
 
 	rowMax = tuple(max(row) for row in lawn)
 	colMax = tuple(max(row[i] for row in lawn) for i in xrange(len(lawn[0])))
 	#print rowMax, colMax
 
 	def possible():
 		for y, row in enumerate(lawn):
 			for x, cell in enumerate(row):
 				h = min(rowMax[y], colMax[x])
 				if cell != h:
 					return False
 		return True
 
 	return 'YES' if possible() else 'NO'
 
 def main():
 	(RECURSION_LIMIT)
 
 	= resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		= Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",22,266,671
"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-attempt0'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	a, b = (int(x) for x in inp.readline().split())
 	return a, b
 
 def solve(a, b):
 	count = 0
 	for i in xrange(a, b):
 		s = str(i)
 		recycled = set()
 		for d in xrange(1, len(s)):
 			r = s[d : ] + s[ : d]
 			if i < int(r) <= b:
 				recycled.add(r)
 		count += len(recycled)
 	return count
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		= Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",22,267,479
"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	board = tuple( inp.readline().rstrip() for _ in xrange(4) )
 	empty = inp.readline().rstrip()
 	assert empty == '', empty
 	return board,
 
 def solve(board):
 
 	def scan(start, delta):
 		x, y = start
 		dx, dy = delta
 		for _ in xrange(4):
 			yield board[y][x]
 			x += dx
 			y += dy
 
 	# Look for a winner.
 	for start, delta in (
 		# horizontal
 		((0, 0), (1, 0)),
 		((0, 1), (1, 0)),
 		((0, 2), (1, 0)),
 		((0, 3), (1, 0)),
 		# vertical
 		((0, 0), (0, 1)),
 		((1, 0), (0, 1)),
 		((2, 0), (0, 1)),
 		((3, 0), (0, 1)),
 		# diagonal
 		((0, 0), (1, 1)),
 		((3, 0), (-1, 1)),
 		):
 		chars = set(scan(start, delta))
 		if chars == set(['X']) or chars == set(['X', 'T']):
 			return 'X won'
 		elif chars == set(['O']) or chars == set(['O', 'T']):
 			return 'O won'
 
 	# No winner; draw or unfinished game?
 	if any('.' in row for row in board):
 		return 'Game has not completed'
 	else:
 		return 'Draw'
 
 def main():
 	(RECURSION_LIMIT)
 
 	= resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		= Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",22,268,894
"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	data = tuple(int(x) for x in inp.readline().split())
 	dancers, surprises, points = data[ : 3]
 	totals = data[3 : ]
 	assert len(totals) == dancers
 	return totals, surprises, points
 
 def totalAtDist():
 	'''
 	If a dancer's best result is b, the total can be:
 	  distance 0: 3b
 	  distance 1: [3b-2..3b-1]
 	  distance 2: [3b-4..3b-2]
 	Note: distance d is only possible if d <= b.
 
 	total 15:
 	b = 0..4:  impossible
 	b = 5:     dist = 0
 	b = 6:     dist = 2
 	b = 7..10: impossible
 
 	For every total we have a number of explanations, which are
 	(b, d) pairs where b is the best result and d is the distance.
 
 	The output of this function shows:
 
 	Except for 0, 1, 29 and 30, every total t has exactly 2 explanations:
 	  ((t+2) div 3, 0|1)  and  ((t+4) div 3, 2)
 	In other words, always one surprise option and one normal option.
 	The surprise option can have a result one higher than the normal one or
 	equal to it.
 	'''
 
 	print '  ',
 	for b in xrange(0, 11):
 		print 'b=%d' % b,
 	print
 	for total in xrange(0, 31):
 		print '%2d' % total,
 		for b in xrange(0, 11):
 			s = '0' if total == b * 3 else '.'
 			s += '1' if b >= 1 and b * 3 - 2 <= total <= b * 3 - 1 else '.'
 			s += '2' if b >= 2 and b * 3 - 4 <= total <= b * 3 - 2 else '.'
 			print s,
 		print
 
 #totalAtDist()
 
 def solve(totals, surprises, points):
 	countCertain = 0
 	countSurprise = 0
 	for total in totals:
 		if (total + 2) / 3 >= points:
 			# A non-surprising score has a best result >= p.
 			countCertain += 1
 		elif 2 <= total <= 28 and (total + 4) / 3 >= points:
 			# Only a surprising score has a best result >= p.
 			countSurprise += 1
 		else:
 			# The best result cannot be >= p.
 			pass
 
 	# Replacing a non-surprise interpretation of a total by a surprise
 	# interpretation is always possible for totals in [2..28] and will never
 	# lower the best result, so it will not put a score in a different
 	# category. Therefore, it is always possible to assign leftover surprise
 	# slots to dancers without changing the outcome.
 
 	return countCertain + min(countSurprise, surprises)
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		= Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",22,269,1189
"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'D-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 (inp):
 	numBlocks, = (int(x) for x in inp.readline().split())
 	naomiBlocks = tuple(sorted(float(x) for x in inp.readline().split()))
 	kenBlocks = tuple(sorted(float(x) for x in inp.readline().split()))
 	assert len(naomiBlocks) == numBlocks
 	assert len(kenBlocks) == numBlocks
 	return naomiBlocks, kenBlocks
 
 def solve(naomiBlocks, kenBlocks):
 	numBlocks = len(naomiBlocks)
 
 	# greedy strategy for honest play:
 	# play the block that is heavier by the smallest margin (if you have one)
 	# ('honest' meaning sticking to the rules; 'fair' is something else)
 	kenPointsHonest = 0
 	naomiLowerBlocks = 0
 	for _, owner in sorted(chain(
 			((b, 'n') for b in naomiBlocks),
 			((b, 'k') for b in kenBlocks)
 			)):
 		if owner == 'n':
 			naomiLowerBlocks += 1
 		elif naomiLowerBlocks != 0:
 			naomiLowerBlocks -= 1
 			kenPointsHonest += 1
 	naomiPointsHonest = numBlocks - kenPointsHonest
 
 	# strategy for deceitful play:
 	# moves:
 	# + lie and win:
 	#   when Ken can't match the told number, he'll play his lightest block
 	#   so you can lie and win if you play a block heavier than his lightest
 	# + lie and lose:
 	#   name a weight just below Ken's heaviest block, forcing him to play that
 	# - truth and win:
 	#   when you play a block that is actually heavier than anything Ken has
 	#   is just a special case of lie and win
 	# - truth and lose:
 	#   never optimal
 	# optimal order of play:
 	#   always play your lightest block: if it can't win now, it can never win
 	#   in the future either, nor can it be more effective in the future than
 	#   pulling his current heaviest block
 	naomiLoIdx = 0
 	naomiHiIdx = numBlocks - 1
 	kenLoIdx = 0
 	kenHiIdx = numBlocks - 1
 	naomiPointsDeceit = 0
 	while naomiLoIdx <= naomiHiIdx:
 		assert naomiHiIdx - naomiLoIdx == kenHiIdx - kenLoIdx
 		naomiLo = naomiBlocks[naomiLoIdx]
 		#naomiHi = naomiBlocks[naomiHiIdx]
 		kenLo = kenBlocks[kenLoIdx]
 		#kenHi = kenBlocks[kenHiIdx]
 		if naomiLo > kenLo:
 			naomiPointsDeceit += 1
 			kenLoIdx += 1
 		else:
 			kenHiIdx -= 1
 		naomiLoIdx += 1
 
 	#print naomiBlocks
 	#print kenBlocks
 	#print
 
 	return '%d %d' % (naomiPointsDeceit, naomiPointsHonest)
 
 def main():
 	(RECURSION_LIMIT)
 
 	= resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		= Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",22,270,1317
"#!/usr/bin/env python
 
 = 'C-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	a, b = (int(x) for x in inp.readline().split())
 	return a, b
 
 def isFair(x):
 	l1 = list(str(x))
 	l2 = list(l1)
 	l2.reverse()
 	return l1 == l2
 
 def solve(a, b):
 	c = 0
 	for i in xrange(a, b + 1):
 		r = int(sqrt(i))
 		if r * r == i and isFair(i) and isFair(r):
 			c += 1
 
 	return str(c)
 
 def main():
 	(RECURSION_LIMIT)
 
 	= resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		= Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",22,271,589
"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small'
 NUM_PROCESSES = 0
 
 def findMapping(knowledge):
 	# Build Googlerese to English mapping from example text.
 	mapping = {}
 	for english, googlerese in knowledge:
 		assert len(english) == len(googlerese)
 		for engChar, gooChar in zip(english, googlerese):
 			if ord('a') <= ord(engChar) <= ord('z'):
 				assert ord('a') <= ord(gooChar) <= ord('z')
 				if gooChar in mapping:
 					assert mapping[gooChar] == engChar
 				else:
 					mapping[gooChar] = engChar
 			else:
 				assert engChar == gooChar
 
 	# If one letter is not be specified in the example text, we can still
 	# complete the mapping.
 	alphabet = set(chr(i) for i in xrange(ord('a'), ord('z') + 1))
 	gooMissing = alphabet - set(mapping.iterkeys())
 	engMissing = alphabet - set(mapping.itervalues())
 	assert len(gooMissing) == len(engMissing)
 	if len(gooMissing) == 1:
 		gooChar, = gooMissing
 		engChar, = engMissing
 		mapping[gooChar] = engChar
 	else:
 		assert len(gooMissing) == 0
 
 	# Convert completed mapping to Python translate table.
 	assert len(mapping) == 26, mapping
 	return ''.join(mapping.get(chr(i), chr(i)) for i in xrange(256))
 
 def parse(inp):
 	return inp.readline().rstrip('\n'),
 
 def solve(line):
 	return line.translate(mapping)
 
 knowledge = (
 	( 'our language is impossible to understand',
 	  'ejp mysljylc kd kxveddknmc re jsicpdrysi' ),
 	( 'there are twenty six factorial possibilities',
 	  'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd' ),
 	( 'so it is okay if you want to just give up',
 	  'de kr kd eoya kw aej tysr re ujdr lkgc jv' ),
 	( 'a zoo',
 	  'y qee' ),
 	)
 
 mapping = findMapping(knowledge)
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		= Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",22,272,958
"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	rows, cols, mines = (int(x) for x in inp.readline().split())
 	return rows, cols, mines
 
 def search(rows, cols, mines):
 	# Boundary cases:
 	# TODO: Might be redundant once we have a generic solution.
 
 	# Mine count extremes.
 	assert 0 <= mines < rows * cols
 	if mines == 0:
 		return ['c' + '.' * (cols - 1)] + ['.' * cols] * (rows - 1)
 	if mines == rows * cols - 1:
 		return ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)
 
 	# One-dimensional board.
 	if rows == 1:
 		return ['c' + '.' * (cols - 1 - mines) + '*' * mines]
 	if cols == 1:
 		return ['c'] + ['.'] * (rows - 1 - mines) + ['*'] * mines
 
 	# Nearly-full two-dimensional board: the clicked cell must not have any
 	# mines as neighbours or the flooding won't start.
 	if mines > rows * cols - 4:
 		return None
 
 	# TODO: For now, we just give up.
 
 	return None
 
 class SearchBoard(object):
 
 	def __init__(self, rows, cols):
 		self.counts = [[0] * (cols + 2) for _ in xrange(rows + 2)]
 		self.mineCount = 0
 
 	def addMine(self, row, col):
 		counts = self.counts
 		assert counts[row + 1][col + 1] < 10
 		top = counts[row + 0]
 		top[col + 0] += 1
 		top[col + 1] += 1
 		top[col + 2] += 1
 		mid = counts[row + 1]
 		mid[col + 0] += 1
 		mid[col + 1] += 10
 		mid[col + 2] += 1
 		bot = counts[row + 2]
 		bot[col + 0] += 1
 		bot[col + 1] += 1
 		bot[col + 2] += 1
 		self.mineCount += 1
 
 	def removeMine(self, row, col):
 		counts = self.counts
 		assert counts[row + 1][col + 1] >= 10
 		top = counts[row + 0]
 		top[col + 0] -= 1
 		top[col + 1] -= 1
 		top[col + 2] -= 1
 		mid = counts[row + 1]
 		mid[col + 0] -= 1
 		mid[col + 1] -= 10
 		mid[col + 2] -= 1
 		bot = counts[row + 2]
 		bot[col + 0] -= 1
 		bot[col + 1] -= 1
 		bot[col + 2] -= 1
 		self.mineCount -= 1
 
 	def checkConnected(self):
 		counts = self.counts
 		cols = len(counts[0]) - 2
 		rows = len(counts) - 2
 
 		# Pick a cell to click on. Any zero cell will do: if all zeroes are
 		# connected, clicking on any zero will reveal them all.
 		for rowIdx, row in enumerate(counts):
 			if rowIdx == 0 or rowIdx > rows:
 				continue
 			try:
 				colIdx = row.index(0, 1, -1)
 			except ValueError:
 				pass
 			else:
 				click = (rowIdx, colIdx)
 				break
 		else:
 			return None
 
 		revealed = set()
 		def reveal(row, col):
 			if 1 <= row <= rows and 1 <= col <= cols:
 				pos = (row, col)
 				if pos not in revealed:
 					revealed.add(pos)
 					count = counts[row][col]
 					if count == 0:
 						for dr in (-1, 0, 1):
 							for dc in (-1, 0, 1):
 								if dr != 0 or dc != 0:
 									reveal(row + dr, col + dc)
 					else:
 						assert count < 10
 		reveal(*click)
 		numNonMines = rows * cols - self.mineCount
 		if len(revealed) != numNonMines:
 			assert len(revealed) < numNonMines
 			return None
 
 		# Construct a board in the solution syntax.
 		board = [
 				['.' if cell < 10 else '*' for cell in row[1 : -1]]
 				for row in counts[1 : -1]
 				]
 		board[click[0] - 1][click[1] - 1] = 'c'
 		return [''.join(row) for row in board]
 
 def searchBruteForce(rows, cols, mines):
 	# This is the only case where there are no zero cells but there is a
 	# solution.
 	if mines == rows * cols - 1:
 		return ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)
 
 	searchBoard = SearchBoard(rows, cols)
 
 	def searchRec(idx, remaining):
 		if remaining == 0:
 			return searchBoard.checkConnected()
 		elif idx < remaining:
 			return None
 		else:
 			pos = divmod(idx, cols)
 			searchBoard.addMine(*pos)
 			found = searchRec(idx - 1, remaining - 1)
 			searchBoard.removeMine(*pos)
 			if found is not None:
 				return found
 			return searchRec(idx - 1, remaining)
 
 	return searchRec(rows * cols - 1, mines)
 
 def solve(rows, cols, mines):
 	board = search(rows, cols, mines)
 
 	if board is None:
 		board = searchBruteForce(rows, cols, mines)
 		if board is None:
 			return '\n' + 'Impossible'
 		print 'ERROR: fast search missed solution for %dx%d board, %d mines:' \
 				% (rows, cols, mines)
 		for row in board:
 			print row
 		print
 
 	# Perform sanity checks.
 	assert len(board) == rows
 	assert all(len(row) == cols for row in board)
 	counts = { 'c': 0, '.': 0, '*': 0 }
 	for row in board:
 		for cell in row:
 			counts[cell] += 1
 	assert counts['c'] == 1
 	assert counts['*'] == mines
 
 	flowBoard = [
 			['.' if cell == 'c' else cell for cell in row]
 			for row in board
 			]
 	def countMinesOn(row, col):
 		if 0 <= row < rows and 0 <= col < cols:
 			return 1 if flowBoard[row][col] == '*' else 0
 		else:
 			return 0
 	def countMinesNear(row, col):
 		return sum(
 			countMinesOn(row + dr, col + dc)
 			for dr in (-1, 0, 1)
 			for dc in (-1, 0, 1)
 			)
 	def reveal(row, col):
 		if 0 <= row < rows and 0 <= col < cols:
 			assert flowBoard[row][col] != '*'
 			if flowBoard[row][col] == '.':
 				count = countMinesNear(row, col)
 				flowBoard[row][col] = str(count)
 				if count == 0:
 					for dr in (-1, 0, 1):
 						for dc in (-1, 0, 1):
 							reveal(row + dr, col + dc)
 	clickRow, = [i for i, row in enumerate(board) if 'c' in row]
 	clickCol = board[clickRow].index('c')
 	reveal(clickRow, clickCol)
 	assert all('.' not in row for row in flowBoard), flowBoard
 
 	assert all(type(row) == str for row in board)
 	return '\n' + ''.join('\n' + ''.join(row) for row in board)
 
 def main():
 	(RECURSION_LIMIT)
 
 	= resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		= Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",22,273,2926
"# -*- coding: utf-8 -*-
 
 T = int(raw_input())
 for test_case in xrange(1, T + 1):
     N1 = int(raw_input())
     for i in xrange(4):
         if i + 1 == N1:
             R1 = map(int, raw_input().split(' '))
         else:
             raw_input()
     N2 = int(raw_input())
     for i in xrange(4):
         if i + 1 == N2:
             R2 = map(int, raw_input().split(' '))
         else:
             raw_input()
     assert 1 <= N1 <= 4
     assert 1 <= N2 <= 4
     assert len(R1) == len(R2) == 4
 
     num = set(R1) & set(R2)
     if len(num) == 1:
         answer = num.pop()
     elif 1 < len(num):
         answer = 'Bad magician!'
     else:
         answer = 'Volunteer cheated!'
     print 'Case #{}: {}'.format(test_case, answer)
",23,274,284
"# -*- coding: utf-8 -*-
 
 T = int(raw_input())
 for test_case_id in xrange(1, T + 1):
     N, M = map(int, raw_input().split())
     A = []
     for i in xrange(N):
         A.append(map(int, raw_input().split()))
 
     heights = reduce(lambda a, b: a | b, (set(row) for row in A))
     for y in xrange(N):
         for x in xrange(M):
             if (
                 any(A[y][j] > A[y][x] for j in xrange(M)) and
                 any(A[i][x] > A[y][x] for i in xrange(N))
             ):
                 # Found a region surrounded by higher regions.
                 print 'Case #{}: NO'.format(test_case_id)
                 break
         else:
             continue
         break
     else:
         print 'Case #{}: YES'.format(test_case_id)
",23,275,257
"# -*- coding: utf-8 -*-
 
 
 def rotate(x, w):
     x = str(x)
     return int(x[-w:] + x[:-w])
 
 
 T = int(raw_input())
 for case in xrange(1, T + 1):
     A, B = map(int, raw_input().split())
 
     l = len(str(A))
     assert l == len(str(B))
 
     s = []
     for n in xrange(A, B + 1):
         for w in xrange(1, len(str(n))):
             m = int(rotate(n, w))
             if n < m <= B:
                 s.append((n, m))
 
     print 'Case #%d: %d' % (case, len(set(s)))
 
",23,276,210
"# -*- coding: utf-8 -*-
 
 T = int(raw_input())
 for test_case_id in xrange(1, T + 1):
     cells = []
     for i in xrange(4):
         cells.append(raw_input())
     raw_input()
 
     R = range(4)
     for c in 'XO':
         if (
             any(all(cells[i][j] in (c, 'T') for j in R) for i in R) or
             any(all(cells[i][j] in (c, 'T') for i in R) for j in R) or
             all(cells[i][i] in (c, 'T') for i in R) or
             all(cells[i][3 - i] in (c, 'T') for i in R)
         ):
             print 'Case #{}: {} won'.format(test_case_id, c)
             break
     else:
         if '.' in ''.join(cells):
             print 'Case #{}: Game has not completed'.format(test_case_id)
         else:
             print 'Case #{}: Draw'.format(test_case_id)
",23,277,291
"# -*- coding: utf-8 -*-
 
 = dict([(i, {}) for i in xrange(0, 30 + 1)])
 for a, b, c in itertools.product(range(10 + 1), repeat=3):
     if a <= b <= c and c - a <= 2:
         n = a + b + c
         if c - a == 2:
             poss[n]['s'] = tuple(sorted((a, b, c)))
         else:
             poss[n]['n'] = tuple(sorted((a, b, c)))
 
 
 T = int(raw_input())
 for case in xrange(1, T + 1):
     div = map(int, raw_input().split())
     N, S, p = div[:3]
     t = div[3:]
 
     ans = 0
     t.sort(reverse=True)
     for i in xrange(len(t)):
         na, nb, nc = poss[t[i]]['n']
         sa, sb, sc = poss[t[i]].get('s', (-1, -1, -1))
         if p <= nc:
             ans += 1
         elif 0 < S and p <= sc:
             ans += 1
             S -= 1
 
     print 'Case #%d: %d' % (case, ans)
 
",23,278,340
"# -*- coding: utf-8 -*-
 
 = int(raw_input())
 for test_case in xrange(1, T + 1):
     N = int(raw_input())
     W1 = sorted(map(float, raw_input().split()))
     W2 = sorted(map(float, raw_input().split()))
 
     y = 0
     c1 = c2 = 0
     while c1 < N and c2 < N:
         if W2[c2] < W1[c1]:
             y += 1
             c1 += 1
             c2 += 1
         while c1 < N and c2 < N and W1[c1] < W2[c2]:
             c1 += 1
 
     z = N
     c1 = c2 = 0
     while c1 < N and c2 < N:
         if W1[c1] < W2[c2]:
             z -= 1
             c1 += 1
             c2 += 1
         while c1 < N and c2 < N and W2[c2] < W1[c1]:
             c2 += 1
 
     print 'Case #{}: {} {}'.format(test_case, y, z)
",23,279,304
"# -*- coding: utf-8 -*-
 
 N_MAX = 10 ** 7  # for First large dataset
 
 
 def is_palindrome(n):
     s = str(n)
     for i in xrange(len(s) / 2):
         if s[i] != s[-1 - i]:
             return False
     return True
 
 palindromes = [x for x in xrange(N_MAX) if is_palindrome(x)]
 palindrome_squares = [x ** 2 for x in palindromes]
 fair_and_square_palindromes = filter(is_palindrome, palindrome_squares)
 
 
 T = int(raw_input())
 for test_case_id in xrange(1, T + 1):
     A, B = map(int, raw_input().split())
     answer = len([x for x in fair_and_square_palindromes if A <= x <= B])
     print 'Case #{}: {}'.format(test_case_id, answer)
",23,280,262
"# -*- coding: utf-8 -*-
 
 = '''
 ejp mysljylc kd kxveddknmc re jsicpdrysi
 rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
 de kr kd eoya kw aej tysr re ujdr lkgc jv
 '''.replace(' ', '').replace('\n', '')
 
 str_from = '''
 our language is impossible to understand
 there are twenty six factorial possibilities
 so it is okay if you want to just give up
 '''.replace(' ', '').replace('\n', '')
 
 conv = {}
 for i, c in enumerate(str_from):
     assert c not in conv or conv[c] == str_to[i]
     conv[c] = str_to[i]
 conv['z'] = 'q'
 conv['q'] = 'z'
 
 assert len(set(conv.keys())) == 26
 assert len(set(conv.values())) == 26
 mat = ['', '']
 for k, v in conv.items():
     mat[0] += v
     mat[1] += k
 
 T = int(raw_input())
 for case in xrange(1, T + 1):
     line = raw_input()
     ans = string.translate(line, string.maketrans(*mat))
     print 'Case #%d: %s' % (case, ans)
 
",23,281,351
"# -*- coding: utf-8 -*-
 
 T = int(raw_input())
 for test_case in xrange(1, T + 1):
     R, C, M = map(int, raw_input().split())
     N = R * C
     B = N - M
 
     W, H = (C, R) if R <= C else (R, C)
 
     if H == 1:
         answer = [['c'] + ['.'] * (B - 1) + ['*'] * M]
     elif M == N - 1:
         answer = [['*'] * W for r in xrange(H)]
         answer[0][0] = 'c'
     elif B < 4 or B in (5, 7):
         answer = None
     elif H == 2:
         if M % 2 == 0:
             bw = B / 2
             answer = [
                 ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),
                 ['.'] * bw + ['*'] * (W - bw),
             ]
         else:
             answer = None
     else:
         answer = [['*'] * W for y in xrange(H)]
         answer[0][0] = 'c'
         answer[0][1] = answer[1][0] = answer[1][1] = '.'
         left = B - 4
         if 2 <= left:
             answer[0][2] = answer[1][2] = '.'
             left -= 2
         if 2 <= left:
             answer[2][0] = answer[2][1] = '.'
             left -= 2
 
         x = y = 3
         while (x < W or y < H) and 2 <= left:
             if x < W and 2 <= left:
                 answer[0][x] = answer[1][x] = '.'
                 left -= 2
                 x += 1
             if y < H and 2 <= left:
                 answer[y][0] = answer[y][1] = '.'
                 left -= 2
                 y += 1
 
         y = 2
         while 0 < left and y < H:
             x = 2
             while 0 < left and x < W:
                 answer[y][x] = '.'
                 left -= 1
                 x += 1
             y += 1
 
     if answer is None:
         answer = 'Impossible'
     else:
         if W == R:
             answer = map(list, zip(*answer))
         assert len(answer) == R
         assert len(answer[0]) == C
         assert sum(row.count('*') for row in answer) == M
 #        # DEBUG
 #        h = len(answer)
 #        w = len(answer[0])
 #        for y in xrange(h):
 #            for x in xrange(w):
 #                if answer[y][x] in '.c':
 #                    count = 0
 #                    for dy in (-1, 0, 1):
 #                        for dx in (-1, 0, 1):
 #                            if (
 #                                0 <= x + dx < w and
 #                                0 <= y + dy < h and
 #                                answer[y + dy][x + dx] == '*'
 #                            ):
 #                                count += 1
 #                    answer[y][x] = str(count)
         answer = '\n'.join([''.join(row) for row in answer])
     print 'Case #{}:\n{}'.format(test_case, answer)
",23,282,887
"#use combinations!
 
 def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case
 	with file(filepath, 'rb') as f_in:
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			yield line_index, line.strip().split(' ')
 
 def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case
 	with file(filepath, 'rb') as f_in:
 		case_counter = 1
 		case = []
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			case.append(line.strip().split(' '))
 			if not line_index % n:
 				yield case_counter, case
 				case_counter += 1
 				case = []
 
 def iterate_cases_glpc(filepath):		#glpc - given lines per case
 	with file(filepath, 'rb') as f_in:
 		case_counter = 0
 		new_case = True
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			if new_case:
 				new_case = False
 				case_counter += 1
 				case = []
 				assert len(line.strip().split(' ')) == 1
 				lines_left = int(line.strip())
 				if not lines_left:
 					new_case = True
 					yield case_counter, case
 				continue
 			if lines_left:
 				lines_left -= 1
 				case.append(line.strip().split(' '))
 			if not lines_left:
 				new_case = True
 				yield case_counter, case
 			
 def part_of_list_to_int(array, flags):
 	assert len(array) == len(flags)
 	output = []
 	for index, elem in enumerate(array):
 		if flags[index]:
 			output.append(int(elem))
 		else:
 			output.append(elem)
 	return output
 
 def list_to_int(array):
 	return part_of_list_to_int(array, [True] * len(array))
 
 def part_of_list_to_float(array, flags):
 	assert len(array) == len(flags)
 	output = []
 	for index, elem in enumerate(array):
 		if flags[index]:
 			output.append(float(elem))
 		else:
 			output.append(elem)
 	return output
 
 def list_to_float(array):
 	return part_of_list_to_float(array, [True] * len(array))
 
 def get_max_array_on_index(array, index):
 	elem_len = len(array[0])
 	assert index < elem_len
 	for elem in array:
 		assert elem_len == len(elem)
 	max_sub = array[0][index]
 	max_elem = array[0]
 	for elem in array:
 		if elem[index] > max_sub:
 			max_sub = elem[index]
 			max_elem = elem
 	return max_elem
 
 def list_index_in_sorted_with_position(a_list, value, pos):
 	list_len = len(a_list)
 	if list_len == 1:
 		if a_list[0] == value:
 			return pos
 		return -1
 	if a_list[list_len/2] > value:
 		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)
 	else:
 		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))
 	
 def list_index_in_sorted_list(a_list, value):
 	return list_index_in_sorted_with_position(a_list, value, 0)
 
 def copy_list(list):
 	res = []
 	for elem in list:
 		res.append(elem)
 	return res	
 
 ############################################################
 #### add solution here 									####
 #### don't forget to change data from str to int/float  ####
 ############################################################
 
 def intersect(arr_A, arr_B):
 	print '\t\t%s\n\t\t%s' % (arr_A, arr_B)
 	res = []
 	for a in arr_A:
 		if arr_B.count(a):
 			res.append(a)
 	print '\t\t%s' % res
 	return res
 
 def solve(row_A_selected, board_A,
 		  row_B_selected, board_B):
 	res = intersect(board_A[row_A_selected - 1], 
 					board_B[row_B_selected - 1])
 	if len(res) == 0:
 		return 'Volunteer cheated!'
 	if len(res) == 1:
 		return res[0]
 	return 'Bad magician!'
 	
 def calc_result(case):
 	result = None
 	
 	row_A_selected = int(case[0][0])
 	row_B_selected = int(case[5][0])
 	board_A = case[1:5]
 	board_B = case[6:10]
 	
 	print ""row_A_selected: %s"" % row_A_selected
 	print ""row_B_selected: %s"" % row_B_selected
 	print 
 	print board_A
 	print 
 	print board_B
 	print
 	
 	result = solve(row_A_selected, board_A,
 				   row_B_selected, board_B)
 	print result
 	
 	
 	return result
 
 def main(filepath):
 	start_time = time.time()
 	with file('output.txt', 'wb') as f_out:
 		
 		######################################
 		#### select input iteration type: ####
 		####	- iterate_cases_1lpc	  ####
 		####	- iterate_cases_nlpc +n	  ####
 		####	- iterate_cases_glpc	  ####
 		######################################
 		for case_index, case in iterate_cases_nlpc(filepath, 10):
 			
 			print ""case #%d: time:%.02f"" % (case_index, time.time() - start_time)
 			result = calc_result(case)
 			
 			#######################
 			#### format output ####
 			#######################
 			f_out.write(""Case #%d: %s\n"" % (case_index, result))
 				
 if __name__ == '__main__':
 	main(sys.argv[1])
",24,283,1987
"#use combinations!
 
 def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case
 	with file(filepath, 'rb') as f_in:
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			yield line_index, line.strip().split(' ')
 
 def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case
 	with file(filepath, 'rb') as f_in:
 		case_counter = 1
 		case = []
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			case.append(line.strip().split(' '))
 			if not line_index % n:
 				yield case_counter, case
 				case_counter += 1
 				case = []
 
 def iterate_cases_glpc(filepath):		#glpc - given lines per case
 	with file(filepath, 'rb') as f_in:
 		case_counter = 0
 		new_case = True
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			if new_case:
 				new_case = False
 				case_counter += 1
 				case = []
 				assert len(line.strip().split(' ')) == 2
 				N = int(line.strip().split(' ')[0])
 				M = int(line.strip().split(' ')[1])
 				lines_left = N
 				case.append(N)
 				case.append(M)
 				if not lines_left:
 					new_case = True
 					yield case_counter, case
 				continue
 			if lines_left:
 				lines_left -= 1
 				case.append(line.strip().split(' '))
 			if not lines_left:
 				new_case = True
 				yield case_counter, case
 			
 def part_of_list_to_int(array, flags):
 	assert len(array) == len(flags)
 	output = []
 	for index, elem in enumerate(array):
 		if flags[index]:
 			output.append(int(elem))
 		else:
 			output.append(elem)
 	return output
 
 def list_to_int(array):
 	return part_of_list_to_int(array, [True] * len(array))
 
 def part_of_list_to_float(array, flags):
 	assert len(array) == len(flags)
 	output = []
 	for index, elem in enumerate(array):
 		if flags[index]:
 			output.append(float(elem))
 		else:
 			output.append(elem)
 	return output
 
 def list_to_float(array):
 	return part_of_list_to_float(array, [True] * len(array))
 
 def get_max_array_on_index(array, index):
 	elem_len = len(array[0])
 	assert index < elem_len
 	for elem in array:
 		assert elem_len == len(elem)
 	max_sub = array[0][index]
 	max_elem = array[0]
 	for elem in array:
 		if elem[index] > max_sub:
 			max_sub = elem[index]
 			max_elem = elem
 	return max_elem
 
 def list_index_in_sorted_with_position(a_list, value, pos):
 	list_len = len(a_list)
 	if list_len == 1:
 		if a_list[0] == value:
 			return pos
 		return -1
 	if a_list[list_len/2] > value:
 		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)
 	else:
 		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))
 	
 def list_index_in_sorted_list(a_list, value):
 	return list_index_in_sorted_with_position(a_list, value, 0)
 	
 ############################################################
 #### add solution here 									####
 #### don't forget to change data from str to int/float  ####
 ############################################################
 def test_row(row, value):
 	for elem in row:
 		if elem > value:
 			return False
 	return True
 
 def calc_result(case):
 	#print ""\t%s"" % case[2:]
 	N = case[0]
 	M = case[1]
 	rows = []
 	for str_row in case[2:]:
 		rows.append(list_to_int(str_row))
 	#print ""\trows: %s"" % rows
 	columns = []
 	for i in xrange(M):
 		column = []
 		for j in xrange(N):
 			column.append(rows[j][i])
 		columns.append(column)
 	#print ""\tcolumns: %s"" % columns
 	
 	for i in xrange(N):
 		for j in xrange(M):
 			if not (test_row(rows[i], rows[i][j]) or test_row(columns[j], rows[i][j])):
 				print ""i,j: %d,%d"" % (i, j)
 				result = ""NO""
 				print ""\t%s"" % result
 				return result
 	
 	result = ""YES""
 	print ""\t%s"" % result
 	return result
 
 def main(filepath):
 	start_time = time.time()
 	with file('output.txt', 'wb') as f_out:
 		
 		######################################
 		#### select input iteration type: ####
 		####	- iterate_cases_1lpc	  ####
 		####	- iterate_cases_nlpc +n	  ####
 		####	- iterate_cases_glpc	  ####
 		######################################
 		for case_index, case in iterate_cases_glpc(filepath):
 			
 			print ""case #%d: time:%.02f"" % (case_index, time.time() - start_time)
 			result = calc_result(case)
 			
 			#######################
 			#### format output ####
 			#######################
 			f_out.write(""Case #%d: %s\n"" % (case_index, result))
 				
 if __name__ == '__main__':
 	main(sys.argv[1])
",24,284,1926
"(in_str):
 	return ""%s%s"" % (in_str[-1], in_str[:-1])
 
 def get_cyclic_shifts(num):
 	results = []
 	str_num = str(num)
 	for _ in xrange(len(str_num) - 1):
 		str_num = cycle_shift(str_num)
 		if str_num[0] == '0':
 			continue
 		number = int(str_num)
 		if not number in results:
 			results.append(number)
 	return results
 	
 def get_rec_pairs(A, B):
 	rec_pairs = []
 	for i in xrange(A, B + 1):
 		shifts = get_cyclic_shifts(i)
 		for shift in shifts:
 			if (shift > i and
 				shift <= B):
 				rec_pairs.append((i, shift))
 	return rec_pairs
 	
 def main(filepath):
 	with file('numbers_output.txt', 'wb') as f_out:
 		with file(filepath, 'rb') as f_in:
 			for line_index, line in enumerate(f_in):
 				if line_index == 0: #T
 					continue
 				input_list = line.strip().split(' ')
 				A = int(input_list[0])
 				B = int(input_list[1])
 				
 				rec_pairs = get_rec_pairs(A, B)
 				result = len(rec_pairs)
 							
 				print
 				print line.strip()
 				print result
 				
 				f_out.write(""Case #%d: %d\n"" % (line_index, result))
 				
 if __name__ == '__main__':
 	main(sys.argv[1])",24,285,550
"#use combinations!
 
 def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case
 	with file(filepath, 'rb') as f_in:
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			yield line_index, line.strip().split(' ')
 
 def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case
 	with file(filepath, 'rb') as f_in:
 		case_counter = 1
 		case = []
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			case.append(line.strip().split(' '))
 			if not line_index % n:
 				yield case_counter, case
 				case_counter += 1
 				case = []
 
 def iterate_cases_glpc(filepath):		#glpc - given lines per case
 	with file(filepath, 'rb') as f_in:
 		case_counter = 0
 		new_case = True
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			if new_case:
 				new_case = False
 				case_counter += 1
 				case = []
 				assert len(line.strip().split(' ')) == 1
 				lines_left = int(line.strip())
 				if not lines_left:
 					new_case = True
 					yield case_counter, case
 				continue
 			if lines_left:
 				lines_left -= 1
 				case.append(line.strip().split(' '))
 			if not lines_left:
 				new_case = True
 				yield case_counter, case
 			
 def part_of_list_to_int(array, flags):
 	assert len(array) == len(flags)
 	output = []
 	for index, elem in enumerate(array):
 		if flags[index]:
 			output.append(int(elem))
 		else:
 			output.append(elem)
 	return output
 
 def list_to_int(array):
 	return part_of_list_to_int(array, [True] * len(array))
 
 def part_of_list_to_float(array, flags):
 	assert len(array) == len(flags)
 	output = []
 	for index, elem in enumerate(array):
 		if flags[index]:
 			output.append(float(elem))
 		else:
 			output.append(elem)
 	return output
 
 def list_to_float(array):
 	return part_of_list_to_float(array, [True] * len(array))
 
 def get_max_array_on_index(array, index):
 	elem_len = len(array[0])
 	assert index < elem_len
 	for elem in array:
 		assert elem_len == len(elem)
 	max_sub = array[0][index]
 	max_elem = array[0]
 	for elem in array:
 		if elem[index] > max_sub:
 			max_sub = elem[index]
 			max_elem = elem
 	return max_elem
 
 def list_index_in_sorted_with_position(a_list, value, pos):
 	list_len = len(a_list)
 	if list_len == 1:
 		if a_list[0] == value:
 			return pos
 		return -1
 	if a_list[list_len/2] > value:
 		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)
 	else:
 		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))
 	
 def list_index_in_sorted_list(a_list, value):
 	return list_index_in_sorted_with_position(a_list, value, 0)
 	
 ############################################################
 #### add solution here 									####
 #### don't forget to change data from str to int/float  ####
 ############################################################
 
 def check_row(row):
 	if row.count('X') == 4:
 		return 'X'
 	if row.count('O') == 4:
 		return 'O'
 	if row.count('X') == 3 and row.count('T') == 1:
 		return 'X'
 	if row.count('O') == 3 and row.count('T') == 1:
 		return 'O'
 	if row.count('.') > 0:
 		return '.'
 	return 'F'
 		
 
 def calc_result(case):
 	case = case[:-1]
 	print ""\t%s"" % case
 	
 	rows = []
 	for row in case:
 		#print ""\trow: '%s'"" % row[0]
 		rows.append(row[0])
 	
 	for i in xrange(4):
 		column = """"
 		for j in xrange(4):
 			column += case[j][0][i]
 		#print ""\trow: '%s'"" % column
 		rows.append(column)
 	
 	diag1 = """"
 	diag2 = """"
 	for i in xrange(4):
 		diag1 += case[i][0][i]
 		diag2 += case[3-i][0][i]
 	#print ""\trow: '%s'"" % diag1
 	#print ""\trow: '%s'"" % diag2
 	rows.append(diag1)
 	rows.append(diag2)
 	
 	res = []
 	for row in rows:
 		res.append(check_row(row))
 	
 	if res.count('X'):
 		if res.count('O'):
 			raise IOError('both X and O won')
 		else:
 			result = ""X won""
 	else:
 		if res.count('O'):
 			result = ""O won""
 		else:
 			if res.count('.'):
 				result = ""Game has not completed""
 			else:
 				result = ""Draw""
 	
 	print ""\t%s"" % res
 	print ""\t%s"" % result
 	
 	return result
 
 def main(filepath):
 	start_time = time.time()
 	with file('output.txt', 'wb') as f_out:
 		
 		######################################
 		#### select input iteration type: ####
 		####	- iterate_cases_1lpc	  ####
 		####	- iterate_cases_nlpc +n	  ####
 		####	- iterate_cases_glpc	  ####
 		######################################
 		for case_index, case in iterate_cases_nlpc(filepath, 5):
 			
 			print ""case #%d: time:%.02f"" % (case_index, time.time() - start_time)
 			result = calc_result(case)
 			
 			#######################
 			#### format output ####
 			#######################
 			f_out.write(""Case #%d: %s\n"" % (case_index, result))
 				
 if __name__ == '__main__':
 	main(sys.argv[1])
",24,286,2128
"(object):
 	def __init__(self, i, j, k):
 		self.i = i
 		self.j = j
 		self.k = k
 		self.max_diff = max((abs(i - j), abs(i - k), abs(j - k)))
 		self.valid = self.max_diff <= 2
 		self.surprise = self.max_diff == 2
 	
 	def get_tuple(self):
 		return (self.i, self.j, self.k)
 	
 	def get_redundancies(self):
 		return [(self.i, self.j, self.k),
 				(self.i, self.k, self.j),
 				(self.j, self.i, self.k),
 				(self.j, self.k, self.i),
 				(self.k, self.i, self.j),
 				(self.k, self.j, self.i)]
 
 class Googler(object):
 	def __init__(self, total_points):
 		self.total_points = total_points
 		self.regular_triplets = []
 		self.surprise_triplets = []
 		
 		for i in xrange(0, 11):
 			if i > total_points:
 				break
 			for j in xrange(i, 11):
 				if i + j > total_points:
 					break
 				k = total_points - i - j
 				if k > 10:
 					break
 				triplet = Triplet(i, j, k)
 				self.add(triplet)
 		
 		self.can_surprise = len(self.surprise_triplets) > 0
 		self.actual_triplet = None
 		self.best_result = -1
 		
 	def add(self, triplet):
 		if not triplet.valid:
 			return
 		if triplet.surprise:
 			self.add_uniquely(triplet, is_surprise=True)
 		else:
 			self.add_uniquely(triplet, is_surprise=False)
 			
 	def add_uniquely(self, triplet, is_surprise):
 		if is_surprise:
 			input_list = self.surprise_triplets
 		else:
 			input_list = self.regular_triplets
 		for triplet_redundancy in triplet.get_redundancies():
 			if triplet_redundancy in input_list:
 				return
 		input_list.append(triplet.get_tuple())
 	
 	def __str__(self):
 		return ""regular: %s\nsurprise: %s"" % (self.regular_triplets,
 											  self.surprise_triplets)
 	
 	def set_googler(self, is_surprise=False):
 		if not is_surprise:
 			self.actual_triplet = self.regular_triplets[0]
 		else:
 			self.actual_triplet = self.surprise_triplets[0]
 		self.calc_best_result()
 	
 	def calc_best_result(self):
 		self.best_result = max(self.actual_triplet)
 
 		
 class Contest(object):
 	def __init__(self, num_of_googlers, results):
 		self.num = num_of_googlers
 		self.googlers = []
 		for i in xrange(self.num):
 			self.googlers.append(Googler(results[i]))
 	
 	def calc(self, num_of_surprises, p):
 		max_googlers_over_p = 0
 		for surprise_perm in self.get_permutations(num_of_surprises):
 			if not self.validate_permutation(surprise_perm):
 				continue
 			count = 0
 			for index, googler in enumerate(self.googlers):
 				googler.set_googler(index in surprise_perm)
 				if googler.best_result >= p:
 					count += 1
 			if count >= max_googlers_over_p:
 				max_googlers_over_p = count
 		return max_googlers_over_p
 	
 	def get_permutations(self, num_of_surprises):
 		results = get_perms(0, self.num, num_of_surprises)
 		if not results:
 			return [[]]
 		return results
 	
 	def validate_permutation(self, perm):
 		for googler_index in perm:
 			if not self.googlers[googler_index].can_surprise:
 				return False
 		return True
 
 def get_perms(start_index, finish_index, amount):
 	if amount == 0:
 		return []
 	result_list = []
 	for i in xrange(start_index, finish_index):
 		if amount == 1:
 			result_list.append([i])
 			continue
 		for result in get_perms(i + 1, finish_index, amount - 1):
 			new_result = [i]
 			new_result.extend(result)
 			result_list.append(new_result)
 	return result_list
 		
 def main(filepath):
 	with file('dancing_output.txt', 'wb') as f_out:
 		with file(filepath, 'rb') as f_in:
 			for line_index, line in enumerate(f_in):
 				if line_index == 0: #T
 					continue
 				input_list = line.strip().split(' ')
 				num_of_googlers = int(input_list[0])
 				num_of_surprises = int(input_list[1])
 				p = int(input_list[2])
 				results = []
 				for res in input_list[3:]:
 					results.append(int(res))
 				contest = Contest(num_of_googlers, results)
 				result = contest.calc(num_of_surprises, p)
 				
 				print
 				print line.strip()
 				print result
 				
 				f_out.write(""Case #%d: %d\n"" % (line_index, result))
 				
 if __name__ == '__main__':
 	main(sys.argv[1])",24,287,1922
"#use combinations!
 (filepath):	#1lpc = 1 line per case
 	with file(filepath, 'rb') as f_in:
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			yield line_index, line.strip().split(' ')
 
 def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case
 	with file(filepath, 'rb') as f_in:
 		case_counter = 1
 		case = []
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			case.append(line.strip().split(' '))
 			if not line_index % n:
 				yield case_counter, case
 				case_counter += 1
 				case = []
 
 def iterate_cases_glpc(filepath):		#glpc - given lines per case
 	with file(filepath, 'rb') as f_in:
 		case_counter = 0
 		new_case = True
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			if new_case:
 				new_case = False
 				case_counter += 1
 				case = []
 				assert len(line.strip().split(' ')) == 1
 				lines_left = int(line.strip())
 				if not lines_left:
 					new_case = True
 					yield case_counter, case
 				continue
 			if lines_left:
 				lines_left -= 1
 				case.append(line.strip().split(' '))
 			if not lines_left:
 				new_case = True
 				yield case_counter, case
 			
 def part_of_list_to_int(array, flags):
 	assert len(array) == len(flags)
 	output = []
 	for index, elem in enumerate(array):
 		if flags[index]:
 			output.append(int(elem))
 		else:
 			output.append(elem)
 	return output
 
 def list_to_int(array):
 	return part_of_list_to_int(array, [True] * len(array))
 
 def part_of_list_to_float(array, flags):
 	assert len(array) == len(flags)
 	output = []
 	for index, elem in enumerate(array):
 		if flags[index]:
 			output.append(float(elem))
 		else:
 			output.append(elem)
 	return output
 
 def list_to_float(array):
 	return part_of_list_to_float(array, [True] * len(array))
 
 def get_max_array_on_index(array, index):
 	elem_len = len(array[0])
 	assert index < elem_len
 	for elem in array:
 		assert elem_len == len(elem)
 	max_sub = array[0][index]
 	max_elem = array[0]
 	for elem in array:
 		if elem[index] > max_sub:
 			max_sub = elem[index]
 			max_elem = elem
 	return max_elem
 
 def list_index_in_sorted_with_position(a_list, value, pos):
 	list_len = len(a_list)
 	if list_len == 1:
 		if a_list[0] == value:
 			return pos
 		return -1
 	if a_list[list_len/2] > value:
 		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)
 	else:
 		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))
 	
 def list_index_in_sorted_list(a_list, value):
 	return list_index_in_sorted_with_position(a_list, value, 0)
 
 def copy_list(list):
 	res = []
 	for elem in list:
 		res.append(elem)
 	return res	
 
 ############################################################
 #### add solution here 									####
 #### don't forget to change data from str to int/float  ####
 ############################################################
 
 def war_answer_simulator(blocks, choice):
 	over_arr = []
 	for elem in blocks:
 		if elem > choice:
 			over_arr.append(elem)
 	if not over_arr:
 		return min(blocks)
 	return min(over_arr)
 
 def war_counter(a, b):
 	count = 0
 	while len(a) and len(b):
 		if a[0] > b[0]:
 			count += 1
 		else:
 			b.pop(0)
 		a.pop(0)
 	return count
 
 def dec_counter(a, b):
 	count = 0
 	while len(a) and len(b):
 		if a[0] < b[0]:
 			pass
 		else:
 			b.pop(0)
 			count += 1
 		a.pop(0)
 	return count	
 	
 def solve(N, N_blocks, K_blocks):
 	res = None
 	
 	N_blocks.sort()
 	K_blocks.sort()
 	N_blocks_copy = copy_list(N_blocks)
 	K_blocks_copy = copy_list(K_blocks)
 	
 	N_blocks_copy.reverse()
 	K_blocks_copy.reverse()
 	
 	war_count = war_counter(N_blocks_copy, K_blocks_copy)
 	print 'war', war_count
 	
 	dec_count = dec_counter(N_blocks, K_blocks)
 	print 'dec', dec_count
 	
 	return '%d %d' % (dec_count, war_count)
 	
 	
 def calc_result(case):
 	result = None
 	
 	N = int(case[0][0])
 	N_blocks = list_to_float(case[1])
 	K_blocks = list_to_float(case[2])
 	print N
 	print N_blocks
 	print K_blocks
 	
 	result = solve(N, N_blocks, K_blocks)
 	print result
 	
 	return result
 
 def main(filepath):
 	start_time = time.time()
 	with file('output.txt', 'wb') as f_out:
 		
 		######################################
 		#### select input iteration type: ####
 		####	- iterate_cases_1lpc	  ####
 		####	- iterate_cases_nlpc +n	  ####
 		####	- iterate_cases_glpc	  ####
 		######################################
 		for case_index, case in iterate_cases_nlpc(filepath, 3):
 			
 			print ""case #%d: time:%.02f"" % (case_index, time.time() - start_time)
 			result = calc_result(case)
 			
 			#######################
 			#### format output ####
 			#######################
 			f_out.write(""Case #%d: %s\n"" % (case_index, result))
 				
 if __name__ == '__main__':
 	main(sys.argv[1])
",24,288,2143
"#use combinations!
 (filepath):	#1lpc = 1 line per case
 	with file(filepath, 'rb') as f_in:
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			yield line_index, line.strip().split(' ')
 
 def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case
 	with file(filepath, 'rb') as f_in:
 		case_counter = 1
 		case = []
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			case.append(line.strip().split(' '))
 			if not line_index % n:
 				yield case_counter, case
 				case_counter += 1
 				case = []
 
 def iterate_cases_glpc(filepath):		#glpc - given lines per case
 	with file(filepath, 'rb') as f_in:
 		case_counter = 0
 		new_case = True
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			if new_case:
 				new_case = False
 				case_counter += 1
 				case = []
 				assert len(line.strip().split(' ')) == 1
 				lines_left = int(line.strip())
 				if not lines_left:
 					new_case = True
 					yield case_counter, case
 				continue
 			if lines_left:
 				lines_left -= 1
 				case.append(line.strip().split(' '))
 			if not lines_left:
 				new_case = True
 				yield case_counter, case
 			
 def part_of_list_to_int(array, flags):
 	assert len(array) == len(flags)
 	output = []
 	for index, elem in enumerate(array):
 		if flags[index]:
 			output.append(int(elem))
 		else:
 			output.append(elem)
 	return output
 
 def list_to_int(array):
 	return part_of_list_to_int(array, [True] * len(array))
 
 def part_of_list_to_float(array, flags):
 	assert len(array) == len(flags)
 	output = []
 	for index, elem in enumerate(array):
 		if flags[index]:
 			output.append(float(elem))
 		else:
 			output.append(elem)
 	return output
 
 def list_to_float(array):
 	return part_of_list_to_float(array, [True] * len(array))
 
 def get_max_array_on_index(array, index):
 	elem_len = len(array[0])
 	assert index < elem_len
 	for elem in array:
 		assert elem_len == len(elem)
 	max_sub = array[0][index]
 	max_elem = array[0]
 	for elem in array:
 		if elem[index] > max_sub:
 			max_sub = elem[index]
 			max_elem = elem
 	return max_elem
 
 def list_index_in_sorted_with_position(a_list, value, pos):
 	list_len = len(a_list)
 	if list_len == 1:
 		if a_list[0] == value:
 			return pos
 		return -1
 	if a_list[list_len/2] > value:
 		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)
 	else:
 		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))
 	
 def list_index_in_sorted_list(a_list, value):
 	return list_index_in_sorted_with_position(a_list, value, 0)
 	
 ############################################################
 #### add solution here 									####
 #### don't forget to change data from str to int/float  ####
 ############################################################
 def check_palindrome(value):
 	val_str = str(value)
 	length = len(val_str)
 	for i in xrange(length):
 		if val_str[i] != val_str[length - 1 - i]:
 			return False
 	return True
 	#print ""\t\t%d: '%s'"" % (value, val_str)
 
 def calc_result(case):
 	A = int(case[0])
 	B = int(case[1])
 	
 	A_sqrt = int(math.ceil(math.sqrt(A)))
 	B_sqrt = int(math.floor(math.sqrt(B)))
 	
 	print ""\tinterval: %s"" % [A, B]
 	print ""\tsqrt_int: %s"" % [A_sqrt, B_sqrt]
 	
 	count = 0
 	for i in xrange(A_sqrt, B_sqrt + 1):
 		if check_palindrome(i):
 			if check_palindrome(i * i):
 				count += 1
 				print ""\tfound: %d, %d"" % (i, i * i)
 	
 	print ""\ttot: %d"" % count
 	print 
 	result = ""%s"" % count
 	return result
 
 def main(filepath):
 	start_time = time.time()
 	with file('output.txt', 'wb') as f_out:
 		
 		######################################
 		#### select input iteration type: ####
 		####	- iterate_cases_1lpc	  ####
 		####	- iterate_cases_nlpc +n	  ####
 		####	- iterate_cases_glpc	  ####
 		######################################
 		for case_index, case in iterate_cases_1lpc(filepath):
 			
 			print ""case #%d: time:%.02f"" % (case_index, time.time() - start_time)
 			result = calc_result(case)
 			
 			#######################
 			#### format output ####
 			#######################
 			f_out.write(""Case #%d: %s\n"" % (case_index, result))
 				
 if __name__ == '__main__':
 	main(sys.argv[1])
",24,289,1851
"(object):
 	def __init__(self):
 		self.letters = {}
 		self.letters['z'] = 'q'	# from text under 'Problem'
 		self.letters['q'] = 'z'
 		self.letters[' '] = ' '
 		self.count = 0
 	
 	def update_letter(self, source, image):
 		if source in self.letters.keys():
 			if self.letters[source] != image:
 				raise Exception('old: %s-->%s. new: %s-->%s' % (source, 
 																self.letters[source],
 																source,
 																image))
 		else:
 			self.letters[source] = image
 	
 	def update_word(self, source, image):
 		for char_index, _ in enumerate(source):
 			self.update_letter(source[char_index], image[char_index])
 	
 	def update_line(self, source, image):
 		for word_index, _ in enumerate(source.strip().split(' ')):
 			self.update_word(source.strip().split(' ')[word_index],
 							 image.strip().split(' ')[word_index])
 	
 	def print_dict(self):
 		for i in xrange(ord('a'), ord('z') + 1):
 			print ""%s-->%s"" % (chr(i), self.letters.get(chr(i), 'None'))
 	
 	def translate_line(self, line):
 		out = """"
 		for char in line:
 			out += self.letters[char]
 		return out
 		
 def main(filepath):
 	translation = Translation()
 	before = []
 	after = []
 	with file('tounges_before.txt', 'rb') as f_before:
 		for line in f_before:
 			before.append(line)
 		
 	with file('tounges_after.txt', 'rb') as f_after:
 		for line in f_after:
 			after.append(line)
 	
 	if len(before) != len(after):
 		raise Exception('the before and after files are not of the same size')
 	
 	for line_index in xrange(len(before)):
 		translation.update_line(before[line_index], after[line_index])
 	
 	translation.print_dict()
 	
 	with file('tounges_output.txt', 'wb') as f_out:
 		with file(filepath, 'rb') as f_in:
 			for line_index, line in enumerate(f_in):
 				if line_index == 0: #T
 					continue
 				result = translation.translate_line(line.strip())
 				print
 				print line.strip()
 				print result
 				f_out.write(""Case #%d: %s\n"" % (line_index, result))
 			
 if __name__ == '__main__':
 	main(sys.argv[1])",24,290,904
"#use combinations!
 
 def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case
 	with file(filepath, 'rb') as f_in:
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			yield line_index, line.strip().split(' ')
 
 def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case
 	with file(filepath, 'rb') as f_in:
 		case_counter = 1
 		case = []
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			case.append(line.strip().split(' '))
 			if not line_index % n:
 				yield case_counter, case
 				case_counter += 1
 				case = []
 
 def iterate_cases_glpc(filepath):		#glpc - given lines per case
 	with file(filepath, 'rb') as f_in:
 		case_counter = 0
 		new_case = True
 		for line_index, line in enumerate(f_in):
 			if line_index == 0: #T
 				continue
 			if new_case:
 				new_case = False
 				case_counter += 1
 				case = []
 				assert len(line.strip().split(' ')) == 1
 				lines_left = int(line.strip())
 				if not lines_left:
 					new_case = True
 					yield case_counter, case
 				continue
 			if lines_left:
 				lines_left -= 1
 				case.append(line.strip().split(' '))
 			if not lines_left:
 				new_case = True
 				yield case_counter, case
 			
 def part_of_list_to_int(array, flags):
 	assert len(array) == len(flags)
 	output = []
 	for index, elem in enumerate(array):
 		if flags[index]:
 			output.append(int(elem))
 		else:
 			output.append(elem)
 	return output
 
 def list_to_int(array):
 	return part_of_list_to_int(array, [True] * len(array))
 
 def part_of_list_to_float(array, flags):
 	assert len(array) == len(flags)
 	output = []
 	for index, elem in enumerate(array):
 		if flags[index]:
 			output.append(float(elem))
 		else:
 			output.append(elem)
 	return output
 
 def list_to_float(array):
 	return part_of_list_to_float(array, [True] * len(array))
 
 def get_max_array_on_index(array, index):
 	elem_len = len(array[0])
 	assert index < elem_len
 	for elem in array:
 		assert elem_len == len(elem)
 	max_sub = array[0][index]
 	max_elem = array[0]
 	for elem in array:
 		if elem[index] > max_sub:
 			max_sub = elem[index]
 			max_elem = elem
 	return max_elem
 
 def list_index_in_sorted_with_position(a_list, value, pos):
 	list_len = len(a_list)
 	if list_len == 1:
 		if a_list[0] == value:
 			return pos
 		return -1
 	if a_list[list_len/2] > value:
 		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)
 	else:
 		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))
 	
 def list_index_in_sorted_list(a_list, value):
 	return list_index_in_sorted_with_position(a_list, value, 0)
 
 def copy_list(list):
 	res = []
 	for elem in list:
 		res.append(elem)
 	return res	
 
 ############################################################
 #### add solution here 									####
 #### don't forget to change data from str to int/float  ####
 ############################################################
 
 def solve(C, F, X):
 	farms_num = 0
 	waiting_for_farms = 0
 	production_rate = 2
 	final_run_time = X / production_rate
 	result = final_run_time + waiting_for_farms
 	
 	print ""%d: prod_rate:%.02f, final_run:%.02f, farm_wait:%.02f, tot:%.06f"" % (farms_num,
 																				production_rate,
 																				final_run_time,
 																				waiting_for_farms,
 																				result)
 		
 
 	
 	while True:
 		farms_num += 1
 		waiting_for_farms += C / production_rate
 		production_rate += F
 		final_run_time = X / production_rate
 		new_result = final_run_time + waiting_for_farms
 		print ""%d: prod_rate:%.02f, final_run:%.02f, farm_wait:%.02f, tot:%.06f"" % (farms_num,
 																					production_rate,
 																					final_run_time,
 																					waiting_for_farms,
 																					new_result)
 		if new_result > result:
 			return result
 		result = new_result
 	
 def calc_result(case):
 	result = None
 	
 	C = float(case[0])
 	F = float(case[1])
 	X = float(case[2])
 	print C, F, X
 	
 	result = solve(C, F, X)
 	print result
 	
 	return result
 
 def main(filepath):
 	start_time = time.time()
 	with file('output.txt', 'wb') as f_out:
 		
 		######################################
 		#### select input iteration type: ####
 		####	- iterate_cases_1lpc	  ####
 		####	- iterate_cases_nlpc +n	  ####
 		####	- iterate_cases_glpc	  ####
 		######################################
 		for case_index, case in iterate_cases_1lpc(filepath):
 			
 			print ""case #%d: time:%.02f"" % (case_index, time.time() - start_time)
 			result = calc_result(case)
 			
 			#######################
 			#### format output ####
 			#######################
 			f_out.write(""Case #%d: %.07f\n"" % (case_index, result))
 				
 if __name__ == '__main__':
 	main(sys.argv[1])
",24,291,2156
"#!/usr/bin/env python
 # -*- coding:utf-8 -*-
 #
 # Problem *. 
 # https://code.google.com/codejam/contest/***
 #
 
 (arrange):
     board, row = arrange[0]
     before = board[row - 1]
     board, row = arrange[1]
     after = board[row - 1]
     dup = set(before) & set(after)
     if len(dup) == 1:
         return dup.pop()
     elif len(dup) >= 2:
         return 'Bad magician!'
     else:
         return 'Volunteer cheated!'
 
 
 def main(IN, OUT):
     T = int(IN.readline())
     for index in range(T):
         arrange = []
         for n in range(2):
             row = int(IN.readline())
             board = []
             for line in range(4):
                 board.append(map(int, IN.readline().split()))
             arrange.append((board, row))
         OUT.write('Case #%d: %s\n' % (index + 1, solve(arrange)))
 
 
 def makesample(T=100):
     (T):
         for n in range(2):
             print random.randint(1, 4)
             board = list(range(1, 16+1))
             random.shuffle(board)
             while board:
                 print ' '.join(map(str, board[:4]))
                 board = board[4:]
 
 
 if __name__ == '__main__':
     if '-makesample' in sys.argv[1:]:
         makesample()
     else:
         main(sys.stdin, sys.stdout)
 
",25,292,441
"#!/usr/bin/env python
 # -*- coding:utf-8 -*-
 #
 # Problem B. Lawnmower
 # https://code.google.com/codejam/contest/2270488/dashboard#s=p1
 #
 
 (board):
     vboard = []
     for m in range(len(board[0])):
         vboard.append([board[n][m] for n in range(len(board))])
 
     for n in range(len(board)):
         for m in range(len(board[n])):
             h = board[n][m]
             if h < max(board[n]) and h < max(vboard[m]):
                 return 'NO'
     return 'YES'
 
 
 def main(IN, OUT):
     T = int(IN.readline())
     for index in range(T):
         N, M = map(int, IN.readline().split())
         field = [map(int, IN.readline().split()) for n in range(N)]
         OUT.write('Case #%d: %s\n' % (index + 1, solve(field)))
 
 
 def makesample(NMmax=100, amax=100, T=100):
     (T):
         N = random.randint(1, NMmax)
         M = random.randint(1, NMmax)
         print N, M
         for n in range(N):
             print ' '.join(str(random.randint(1, amax)) for m in range(M))
 
 
 if __name__ == '__main__':
     if '-makesample' in sys.argv[1:]:
         makesample()
     else:
         main(sys.stdin, sys.stdout)
 
",25,293,446
"#!/usr/bin/env python
 # -*- coding:utf-8 -*-
 #
 # Problem C. Recycled Numbers
 # http://code.google.com/codejam/contest/1460488/dashboard#s=p2
 #
 
 (A, B):
 	# Given integers A and B with the same number of digits
 	# ãªã®ã§Aã¨Bã¯åãã±ã¿æ°ã®ã¯ã
 	top = str(B)[0]
 
 	count = 0
 	for n in xrange(A, B):		# n=B ã®ã±ã¼ã¹ã¯æ¤è¨¼ä¸è¦(n < m <= B ã«ãªãããªã)
 		digit = str(n)
 		found = set()
 		for index in range(1, len(digit)):
 			if digit[index] < digit[0]:
 				# m ã®åé ­ã n ã®åé ­ããå°ãã â n < m ã«ãªããªã
 				continue
 			if digit[index] > top:
 				# m ã®åé ­ã B ã®åé ­ããå¤§ãã â m <= B ã«ãªããªã
 				continue
 
 			m = int(digit[index:] + digit[:index])
 			if n < m and m <= B and m not in found:
 				found.add(m)		# distinct å¤å®(è¦ã¤ãããã®ã¯é¤å¤)
 				count += 1
 				#print n, m
 	return count
 
 
 def main(IN, OUT):
 	N = int(IN.readline())
 	for index in range(N):
 		A, B = map(int, IN.readline().strip().split())
 		OUT.write('Case #%d: %d\n' % (index + 1, solve(A, B)))
 
 
 def makesample(ABmax=2000000, T=50):
 	(T):
 		A = random.randint(1, ABmax)
 		B = random.randint(A, ABmax)
 		print A, B
 
 
 if __name__ == '__main__':
 	if '-makesample' in sys.argv[1:]:
 		makesample()
 	else:
 		main(sys.stdin, sys.stdout)
 
",25,294,816
"#!/usr/bin/env python
 # -*- coding:utf-8 -*-
 #
 # Problem A. Tic-Tac-Toe-Tomek
 # https://code.google.com/codejam/contest/2270488/dashboard#s=p0
 #
 
 (board):
     rows = [board[n:][:4] for n in range(0, len(board), 4)]
     cols = [''.join(board[step+n*4] for n in range(4)) for step in range(4)]
     corners = [''.join(board[n] for n in range(0, len(board), 5)),
                ''.join(board[n] for n in range(3, len(board)-1, 3))]
     lines = rows + cols + corners
 
     for line in lines:
         if line.replace('T', 'X') == 'XXXX':
             return 'X won'
         if line.replace('T', 'O') == 'OOOO':
             return 'O won'
     return 'Game has not completed' if '.' in board else 'Draw'
 
 
 def main(IN, OUT):
     T = int(IN.readline())
     for index in range(T):
         board = ''.join([IN.readline().strip() for row in range(4)])
         OUT.write('Case #%d: %s\n' % (index + 1, solve(board)))
         # empty line
         IN.readline()
 
 
 def makesample(T=1000):
     (T):
         board = []
         for row in range(4):
             board.append(''.join(random.choice('XO.') for col in range(4)))
         tcol = random.randint(0, 3)
         trow = random.randint(0, 3)
         board[trow] = board[trow][:tcol] + 'T' + board[trow][tcol+1:]
         print '\n'.join(board)
         print
 
 
 if __name__ == '__main__':
     if '-makesample' in sys.argv[1:]:
         makesample()
     else:
         main(sys.stdin, sys.stdout)
 
",25,295,557
"#!/usr/bin/env python
 # -*- coding:utf-8 -*-
 #
 # Problem B. Dancing With the Googlers
 # http://code.google.com/codejam/contest/1460488/dashboard#s=p1
 #
 
 # éå¸¸
 # t ã 3 ã®åæ°ã®ã¨ã â (t/3, t/3, t/3)
 # t ã 3 ã®åæ° +1 ã®ã¨ã â (t//3 + 1, t//3, t//3)
 # t ã 3 ã®åæ° +2 ã®ã¨ã â (t//3 + 1, t//3 + 1, t//3)
 
 # surprising ã®å ´å
 # t ã 3 ã®åæ°ã®ã¨ã â (t/3 + 1, t/3, t/3 - 1)
 # t ã 3 ã®åæ° +1 ã®ã¨ã â (t//3 + 1, t//3 + 1, t//3 - 1)
 # t ã 3 ã®åæ° +2 ã®ã¨ã â (t//3 + 2, t//3, t//3)
 
 
 def solve(S, p, tlist):
 	# ç¢ºå®ã« p ãè¶ãã
 	above = 0
 	# surprising ã§è¶ãããããããªã
 	consider = 0
 
 	for t in tlist:
 		avg = t / 3
 		mod = t % 3
 
 		if mod == 0:
 			# t ã 3 ã®åæ° â (t/3, t/3, t/3)
 			if avg >= p:
 				above += 1
 			elif avg + 1 >= p and t > 0:
 				# surprising â (t/3 + 1, t/3, t/3 - 1)
 				consider += 1
 
 		elif mod == 1:
 			# t ã 3 ã®åæ° +1 â (t//3+1, t//3, t//3)
 			if avg + 1 >= p:
 				above += 1
 			# surprising â (t//3 + 1, t//3 + 1, t//3 - 1)
 			# +1 ã§å¤ãããªãã®ã§NOP
 
 		elif mod == 2:
 			# t ã 3 ã®åæ° +2 â (t//3+1, t//3+1, t//3)
 			if avg + 1 >= p:
 				above += 1
 			elif avg + 2 >= p:
 				# surprising â (t//3 + 2, t//3, t//3)
 				consider += 1
 
 	return above + min(S, consider)
 
 
 def main(IN, OUT):
 	N = int(IN.readline())
 	for index in range(N):
 		data = map(int, IN.readline().strip().split())
 		(N, S, p), tlist = data[:3], data[3:]
 		OUT.write('Case #%d: %d\n' % (index + 1, solve(S, p, tlist)))
 
 
 if __name__ == '__main__':
 	main(sys.stdin, sys.stdout)
 
",25,296,1150
"#!/usr/bin/env python
 # -*- coding:utf-8 -*-
 #
 # Problem D. Deceitful War
 # https://code.google.com/codejam/contest/2974486/dashboard#s=p3
 #
 
 (naomi, ken):
     # Deceitful War
     win = 0
     while naomi:
         chosenK = max(ken)
         chosenN = min(filter(lambda mass: mass > chosenK, naomi) or naomi)
         if chosenN > chosenK:
             win += 1
         naomi.remove(chosenN)
         ken.remove(chosenK)
     return win
 
 
 def solve2(naomi, ken):
     # War
     win = 0
     while naomi:
         chosenN = min(naomi)
         chosenK = min(filter(lambda mass: mass > chosenN, ken) or ken)
         if chosenN > chosenK:
             win += 1
         naomi.remove(chosenN)
         ken.remove(chosenK)
     return win
 
 
 def main(IN, OUT):
     T = int(IN.readline())
     for index in range(T):
         N = int(IN.readline())
         naomi = map(float, IN.readline().split())
         ken = map(float, IN.readline().split())
         OUT.write('Case #%d: %d %d\n' % (index + 1, solve1(naomi[:], ken[:]), solve2(naomi[:], ken[:])))
 
 
 def makesample(maxN=1000, T=50):
     (T):
         N = random.randint(1, maxN)
         print N
         print ' '.join(map(str, (random.random() for n in range(N))))
         print ' '.join(map(str, (random.random() for n in range(N))))
 
 
 if __name__ == '__main__':
     if '-makesample' in sys.argv[1:]:
         makesample()
     else:
         main(sys.stdin, sys.stdout)
 
",25,297,546
"#!/usr/bin/env python
 # -*- coding:utf-8 -*-
 #
 # Problem C. Fair and Square
 # https://code.google.com/codejam/contest/2270488/dashboard#s=p2
 #
 
 (n):
     return str(n) == str(n)[::-1]
 
 
 def solve(A, B):
     solution = []
     for n in range(int(math.sqrt(A)), int(math.sqrt(B))+1):
         if ispalindrome(n):
             m = n ** 2
             if ispalindrome(m) and A <= m <= B:
                 solution.append(n)
     return len(solution)
 
 
 def main(IN, OUT):
     T = int(IN.readline())
     for index in range(T):
         A, B = map(int, IN.readline().split())
         OUT.write('Case #%d: %s\n' % (index + 1, solve(A, B)))
 
 
 def makesample(T=100, ABmax=1000):
     (T):
         A = random.randint(1, ABmax)
         B = random.randint(A, ABmax)
         print A, B
 
 
 if __name__ == '__main__':
     if '-makesample' in sys.argv[1:]:
         makesample()
     else:
         main(sys.stdin, sys.stdout)
 
",25,298,376
"#!/usr/bin/env python
 # -*- coding:utf-8 -*-
 #
 # Problem A. Speaking in Tongues
 # http://code.google.com/codejam/contest/1460488/dashboard#s=p0
 #
 
 = '''ejp mysljylc kd kxveddknmc re jsicpdrysi
 rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
 de kr kd eoya kw aej tysr re ujdr lkgc jv'''
 OUTPUT = '''our language is impossible to understand
 there are twenty six factorial possibilities
 so it is okay if you want to just give up'''
 
 
 class Table(dict):
 	TARGET = string.ascii_lowercase
 
 	def translate(self, msg):
 		return ''.join((self[c] if c in self.TARGET else c) for c in msg)
 
 	@classmethod
 	def maketable(cls, src, dst):
 		table = cls()
 		left = set(cls.TARGET)
 		for s, d in zip(src, dst):
 			if s in table:
 				if table[s] != d:
 					raise Exception('BAD MAPPING ""%s"" => ""%s""/""%s""' % (s, table[s], d))
 			elif s in cls.TARGET:
 				table[s] = d
 				left.remove(s)
 		if left:
 			if len(left) != 2:
 				raise Exception('left letter incorrect')
 			l1, l2 = left
 			table[l1] = l2
 			table[l2] = l1
 		return table
 
 
 def main():
 	table = Table.maketable(INPUT, OUTPUT)
 	N = int(sys.stdin.readline())
 	for index in range(N):
 		line = sys.stdin.readline().strip()
 		print 'Case #%d:' % (index + 1), table.translate(line)
 
 
 if __name__ == '__main__':
 	main()
 
",25,299,590
"#!/usr/bin/env python
 # -*- coding:utf-8 -*-
 #
 # Problem B. Cookie Clicker Alpha
 # https://code.google.com/codejam/contest/2974486/dashboard#s=p1
 #
 
 (C, F, X):
     def needtime(cookies, farm):
         speed = 2.0 + F * farm
         return cookies / speed
 
     farm = 0
     pasttime = 0
     while True:
         complete = needtime(X, farm)
         nextfarm = needtime(C, farm)
         nextchallenge = needtime(X, farm + 1)
         if complete <= nextfarm + nextchallenge:
             return pasttime + complete
         pasttime += nextfarm
         farm += 1
 
 
 def main(IN, OUT):
     T = int(IN.readline())
     for index in range(T):
         C, F, X = map(float, IN.readline().split())
         OUT.write('Case #%d: %.7f\n' % (index + 1, solve(C, F, X)))
 
 
 def makesample(maxC=500, maxF=4, maxX=2000, T=100):
     (T):
         print ' '.join('{0}'.format(random.randint(10000, maxvalue * 10000) / 10000.0)
                        for maxvalue in (maxC, maxF, maxX))
 
 
 if __name__ == '__main__':
     if '-makesample' in sys.argv[1:]:
         makesample()
     else:
         main(sys.stdin, sys.stdout)
 
",25,300,440
"(r1, m1, r2, m2):
     valid1 = set(m1[r1 - 1])
     valid2 = set(m2[r2 - 1])
     valid = valid1 & valid2
     if len(valid) == 0:
         return 'Volunteer cheated!'
     if len(valid) > 1:
         return 'Bad magician!'
     return valid.pop()
 
 
 def parse_single():
     r = int(sys.stdin.readline().strip())
     m = []
     for i in xrange(4):
         m.append(map(int, sys.stdin.readline().strip().split()))
     return r, m
 
 def parse():
     r1, m1 = parse_single()
     r2, m2 = parse_single()
     return r1, m1, r2, m2
 
 
 if __name__ == ""__main__"":
     sys.setrecursionlimit(100000)
     T = int(sys.stdin.readline().strip())
     for i in xrange(T):
         data = parse()
         result = compute(*data)
         print ""Case #%d: %s"" % (i + 1, result)
",26,301,308
"(N, M, a):
     rows = [0] * N
     cols = [0] * M
     for r in xrange(N):
         rows[r] = 0
         for c in xrange(M):
             if a[r][c] > rows[r]:
                 rows[r] = a[r][c]
     for c in xrange(M):
         cols[c] = 0
         for r in xrange(N):
             if a[r][c] > cols[c]:
                 cols[c] = a[r][c]
     for r in xrange(N):
         for c in xrange(M):
             if a[r][c] < rows[r] and a[r][c] < cols[c]:
                 return ""NO""
     return ""YES""
 
 
 def parse():
     N, M = map(int, sys.stdin.readline().strip().split())
     a = []
     for i in xrange(N):
         a.append(map(int, sys.stdin.readline().strip().split()))
     return N, M, a,
 
 
 if __name__ == ""__main__"":
     sys.setrecursionlimit(100000)
     T = int(sys.stdin.readline().strip())
     count = 1
     part = 0
     if len(sys.argv) == 3:
         part = int(sys.argv[1])
         count = int(sys.argv[2])
     for i in xrange(T):
         data = parse()
         if i * count >= part * T and i * count < (part + 1) * T:
             result = compute(*data)
             print ""Case #%d: %s"" % (i + 1, result)
",26,302,438
"= 2000000
 
 
 def get_min_mapped(n):
     n_min = n
     x = str(n)
     for i in xrange(1, len(x)):
         x = x[1:] + x[0]
         if x[0] == '0':
             continue
         n_min = min(n_min, int(x))
     return n_min
 
 
 if __name__ == ""__main__"":
     T = int(sys.stdin.readline().strip())
     min_mapped = [0] * (MAX_LIMIT + 1)
     for i in xrange(1, MAX_LIMIT + 1):
         min_mapped[i] = get_min_mapped(i)
 
     for r in xrange(T):
         values = map(int, sys.stdin.readline().strip().split(' '))
         A, B = values
         cnt_mapped = [0] * (B + 1)
         for i in xrange(A, B + 1):
             cnt_mapped[min_mapped[i]] += 1
         total = 0
         for i in xrange(B + 1):
             if cnt_mapped[i] > 1:
                 total += (cnt_mapped[i] * (cnt_mapped[i] - 1)) / 2
         print ""Case #%d: %s"" % (r + 1, total)
",26,303,366
"== ""__main__"":
     T = int(sys.stdin.readline().strip())
     for i in xrange(T):
         values = map(int, sys.stdin.readline().strip().split(' '))
         _N, S, p = values[0:3]
         t = values[3:]
         min_normal = p + 2 * max(0, p - 1)
         min_surprising = p + 2 * max(0, p - 2)
         cnt_normal = len(filter(lambda x : x >= min_normal, t))
         cnt_surprising = len(filter(lambda x : x >= min_surprising, t)) - cnt_normal
         print ""Case #%d: %s"" % (i + 1, cnt_normal + min(cnt_surprising, S))
",26,304,207
"(a, b):
     a = sorted(a)
     b = sorted(b)
     cnt = 0
     k = 0
     for i in a:
         if b[k] < i:
             cnt += 1
             k += 1
     return cnt
 
 
 def w(a, b):
     a = sorted(a, reverse=True)
     b = sorted(b, reverse=True)
     cnt = 0
     k = 0
     for i in a:
         if i > b[k]:
             cnt += 1
         else:
             k += 1
     return cnt
 
 
 def compute(a, b):
     x = dw(a, b)
     y = w(a, b)
     return ""%s %s"" % (x, y)
 
 
 def parse():
     N = int(sys.stdin.readline().strip())
     a = map(float, sys.stdin.readline().strip().split())
     b = map(float, sys.stdin.readline().strip().split())
     return a, b
 
 
 if __name__ == ""__main__"":
     sys.setrecursionlimit(100000)
     T = int(sys.stdin.readline().strip())
     for i in xrange(T):
         data = parse()
         result = compute(*data)
         print ""Case #%d: %s"" % (i + 1, result)
",26,305,366
"= []
 
 
 def read_fairsquares():
     global fairsquares
     f = open('fairsquares.txt')
     for x in f:
         fairsquares.append(int(x.strip()))
 
 
 def count_less_than(A):
     left = 0
     right = len(fairsquares)
     # fairsquares[left - 1] < A <= fairsquares[right]
     while left < right:
         middle = (left + right) // 2
         if fairsquares[middle] < A:
             left = middle + 1
         else:
             right = middle
     return left
 
 
 def compute(A, B):
     count_b = count_less_than(B + 1)
     count_a = count_less_than(A)
     return count_b - count_a
 
 
 def parse():
     return map(int, sys.stdin.readline().strip().split())
 
 
 if __name__ == ""__main__"":
     read_fairsquares()
     T = int(sys.stdin.readline().strip())
     count = 1
     part = 0
     if len(sys.argv) == 3:
         part = int(sys.argv[1])
         count = int(sys.argv[2])
     for i in xrange(T):
         data = parse()
         if i * count >= part * T and i * count < (part + 1) * T:
             result = compute(*data)
             print ""Case #%d: %s"" % (i + 1, result)
",26,306,398
"= {}
 
 def init_mapping():
     encoded = [""ejp mysljylc kd kxveddknmc re jsicpdrysi"",
             ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"",
             ""de kr kd eoya kw aej tysr re ujdr lkgc jv"",
             ""y qee z""
             ]
     decoded = [""our language is impossible to understand"",
             ""there are twenty six factorial possibilities"",
             ""so it is okay if you want to just give up"",
             ""a zoo q""
             ]
     for i in xrange(len(encoded)):
         for j in xrange(len(encoded[i])):
             if encoded[i][j] in mapping and mapping[encoded[i][j]] != decoded[i][j]:
                 raise Exception(""Multiple mapping for %s"" % encoded[i][j])
             mapping[encoded[i][j]] = decoded[i][j]
 
 
 def decode(sentence):
     return ''.join(map(lambda x : mapping.get(x, x), sentence))
 
 
 if __name__ == ""__main__"":
     init_mapping()
     T = int(sys.stdin.readline().strip())
     for i in xrange(T):
         result = decode(sys.stdin.readline().strip())
         print ""Case #%d: %s"" % (i + 1, result)
",26,307,360
"= (-1, -1, -1, 0, 1, 1, 1, 0)
 DY = (-1, 0, 1, 1, 1, 0, -1, -1)
 
 
 def compute(R, C, M):
     if M == 0:
         return empty(R, C)
     free = R * C - M
     if free == 1:
         return single_free(R, C)
     if R == 1:
         return single_row(C, M)
     if C == 1:
         return single_column(R, M)
     if R == 2:
         return two_rows(C, M)
     if C == 2:
         return two_columns(R, M)
     if free in (2,3,5,7):
         return ""\nImpossible""
     return at_least_three(R, C, M)
 
 
 def make_board(R, C, default='.'):
     return [[default for j in xrange(C)] for i in xrange(R)]
 
 
 def to_string(board):
     s = """"
     for i in xrange(len(board)):
         s += '\n' + ''.join(board[i])
     return s
 
         
 def empty(R, C):
     board = make_board(R, C)
     board[0][0] = 'c'
     return to_string(board)
 
 
 def single_free(R, C):
     board = make_board(R, C, default='*')
     board[0][0] = 'c'
     return to_string(board)
 
 
 def single_row(C, M):
     board = make_board(1, C)
     board[0][0] = 'c'
     for i in xrange(M):
         board[0][C - 1 - i] = '*'
     return to_string(board)
 
 
 def single_column(R, M):
     board = make_board(R, 1)
     board[0][0] = 'c'
     for i in xrange(M):
         board[R - 1 - i][0] = '*'
     return to_string(board)
 
 
 def two_rows(C, M):
     if M % 2 != 0:
         return ""\nImpossible""
     if 2 * C - M < 4:
         return ""\nImpossible""
     board = make_board(2, C)
     for i in xrange(M / 2):
         board[0][C - 1 - i] = '*'
         board[1][C - 1 - i] = '*'
     board[0][0] = 'c'
     return to_string(board)
 
 
 def two_columns(R, M):
     if M % 2 != 0:
         return ""\nImpossible""
     if 2 * R - M < 4:
         return ""\nImpossible""
     board = make_board(R, 2)
     for i in xrange(M / 2):
         board[R - 1 - i][0] = '*'
         board[R - 1 - i][1] = '*'
     board[0][0] = 'c'
     return to_string(board)
 
 
 def finalize(R, C, M, board):
     mines = 0
     for i in xrange(R):
         for j in xrange(C):
             if board[i][j] == '0':
                 continue
             empty = False
             for d in xrange(8):
                 if i + DX[d] < 0 or i + DX[d] >= R or j + DY[d] < 0 or j + DY[d] >= C:
                     continue
                 if board[i + DX[d]][j + DY[d]] == '0':
                     empty = True
                     break
             if empty:
                 board[i][j] = '.'
             else:
                 board[i][j] = '*'
                 mines += 1
     for i in xrange(R):
         for j in xrange(C):
             if board[i][j] == '0':
                 board[i][j] = '.'
     board[0][0] = 'c'
     if mines != M:
         sys.stderr.write(""mines:%s expected:%s\n"" % (mines, M))
     return to_string(board)
 
 
 def at_least_three(R, C, M):
     board = make_board(R, C)
     board[0][0] = '0'
     free = R * C - M
     count = 4
     if count == free:
         return finalize(R, C, M, board)
     board[0][1] = '0'
     count += 2
     if count == free:
         return finalize(R, C, M, board)
     board[1][0] = '0'
     count += 2
     if count == free:
         return finalize(R, C, M, board)
     for j in xrange(2, C - 1):
         if count + 2 > free:
             break
         board[0][j] = '0'
         count += 2
     for i in xrange(2, R - 1):
         if count + 2 > free:
             break
         board[i][0] = '0'
         count += 2
     for i in xrange(1, R - 1):
         for j in xrange(1, C - 1):
             if count == free:
                 return finalize(R, C, M, board)
             board[i][j] = '0'
             count += 1
     sys.stderr.write(""empty board?\n"")
     return finalize(board)
 
 
 def parse():
     R, C, M = map(int, sys.stdin.readline().strip().split())
     return R, C, M
 
 
 if __name__ == ""__main__"":
     sys.setrecursionlimit(100000)
     T = int(sys.stdin.readline().strip())
     for i in xrange(T):
         sys.stderr.write(""case:%s\n"" % (i + 1))
         data = parse()
         result = compute(*data)
         print ""Case #%d: %s"" % (i + 1, result)
",26,308,1618
"(C, F, X):
     k = int(math.floor(X / C - 2.0 / F))
     if k <= 0:
         return X / 2
     total = 0.0
     for i in xrange(k):
         total += 1.0 / (2.0 + i * F)
     return C * total + X / (2.0 + k * F)
 
 
 def parse():
     C, F, X = map(float, sys.stdin.readline().strip().split())
     return C, F, X
 
 
 if __name__ == ""__main__"":
     sys.setrecursionlimit(100000)
     T = int(sys.stdin.readline().strip())
     for i in xrange(T):
         data = parse()
         result = compute(*data)
         print ""Case #%d: %0.7f"" % (i + 1, result)
",26,309,234
"():
     return sys.stdin.readline().rstrip( '\n' )
 
 def read_integer():
     return int( read_line() )
 
 def read_integers():
     return [ int( x ) for x in read_line().split() ]
 
 def read_string():
     return read_line().strip()
 
 def read_strings():
     return read_line().split()
 
 def input_string_stack():
     data = []
     for line in sys.stdin.readlines():
         data.extend( line.split() )
     data.reverse()
     return data
 
 def input_integer_stack():
     return [ int( x ) for x in read_string_stack() ]
 
 class memoized( object ):
    def __init__( self, function ):
       self.function = function
       self.cache = {}
    def __call__( self, *arguments ):
       try:
          return self.cache[ arguments ]
       except KeyError:
          value = self.function( *arguments )
          self.cache[ arguments ] = value
          return value
 
 T = read_integer()
 for t in range( T ):
     row = read_integer()
     candidates = set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )
     row = read_integer()
     candidates &= set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )
     print 'Case #%i:' % ( t + 1 ), candidates.pop() if len( candidates ) == 1 else 'Bad magician!' if len( candidates ) > 1 else 'Volunteer cheated!'
",27,310,409
"from numpy import *
 
 def read_line():
     return raw_input().strip()
 
 def read_words():
     return read_line().split()
 
 def read_integer():
     return int( read_line() )
 
 def read_integers():
     return [ int( x ) for x in read_words() ]
 
 T = read_integer()
 for t in range( T ):
     N, M = read_integers()
     lawn = array( [ read_integers() for n in range( N ) ] )
     valid = zeros( lawn.shape, bool )
     for row in range( N ):
         valid[ row ][ lawn[ row ] == amax( lawn[ row ] ) ] = True
     for column in range( M ):
         valid[ :, column ][ lawn[ :, column ] == amax( lawn[ :, column ] ) ] = 1
     print 'Case #%i:' % ( t + 1 ), 'YES' if all( valid ) else 'NO'
",27,311,251
"def read_line():
     return raw_input().strip()
 
 def read_integer():
     return int( read_line() )
 
 T = read_integer()
 for t in range( T ):
     board = [ read_line() for index in range( 4 ) ]
     read_line()
     print 'Case #%i:' % ( t + 1 ),
     blank_count = 0
     for row, column, row_increment, column_increment in ( ( 0, 0, 0, 1 ),
                                                           ( 1, 0, 0, 1 ),
                                                           ( 2, 0, 0, 1 ),
                                                           ( 3, 0, 0, 1 ),
                                                           ( 0, 0, 1, 0 ),
                                                           ( 0, 1, 1, 0 ),
                                                           ( 0, 2, 1, 0 ),
                                                           ( 0, 3, 1, 0 ),
                                                           ( 0, 0, 1, 1 ),
                                                           ( 0, 3, 1, -1 ) ):
         O_count = 0
         X_count = 0
         for index in range( 4 ):
             value = board[ row ][ column ]
             if value == 'O':
                 O_count += 1
             elif value == 'X':
                 X_count += 1
             elif value == 'T':
                 O_count += 1
                 X_count += 1
             else:
                 blank_count += 1
             row += row_increment
             column += column_increment
         result = 'O' if O_count == 4 else 'X' if X_count == 4 else None
         if result:
             break
     else:
         print 'Game has not completed' if blank_count else 'Draw'
         continue
     print result, 'won'
",27,312,479
"def read_line():
     return raw_input().strip()
 
 def read_words():
     return read_line().split()
 
 def read_integer():
     return int( read_line() )
 
 def read_integers():
     return [ int( x ) for x in read_words() ]
 
 T = read_integer()
 for t in range( T ):
     print 'Case #%i:' % ( t + 1 ),
     line = iter( read_integers() )
     N = line.next()
     S = line.next()
     p = line.next()
     t = sorted( line )
     count = 0
     while t and ( t[ -1 ] + 2 )/3 >= p:
         t.pop()
         count += 1
     if p > 1:
         while S and t and ( t[ -1 ] + 4 )/3 >= p:
             t.pop()
             S -= 1
             count += 1
     print count
",27,313,243
"():
     return sys.stdin.readline().rstrip( '\n' )
 
 def read_integer():
     return int( read_line() )
 
 def read_floats():
     return [ float( x ) for x in read_line().split() ]
 
 T = read_integer()
 for t in range( T ):
     N = read_integer()
     naomi = sorted( read_floats() )
     ken = sorted( read_floats() )
     k = len( ken ) - 1
     h = 0
     for n in reversed( naomi ):
         if ken[ k ] > n:
             k -= 1
         else:
             h += 1
     d = 0
     n = len( naomi ) - 1
     for k in reversed( ken ):
         if naomi[ n ] > k:
             d += 1
             n -= 1
     print 'Case #%i:' % ( t + 1 ), d, h
",27,314,250
"from math import *
 
 def read_line():
     return raw_input().strip()
 
 def read_words():
     return read_line().split()
 
 def read_integer():
     return int( read_line() )
 
 def read_integers():
     return [ int( x ) for x in read_words() ]
 
 T = read_integer()
 for t in range( T ):
     A, B = read_integers()
     A_root = int( ceil( sqrt( A ) ) )
     B_root = int( floor( sqrt( B ) ) )
     count = 0
     for root in range( A_root, B_root + 1 ):
         word = str( root )
         if word == word[ : : -1 ]:
             word = str( root*root )
             if word == word[ : : -1 ]:
                 count += 1
     print 'Case #%i:' % ( t + 1 ), count
",27,315,238
"def read_line():
     return raw_input().strip()
 
 def read_words():
     return read_line().split()
 
 def read_integer():
     return int( read_line() )
 
 def read_integers():
     return [ int( x ) for x in read_words() ]
 
 
 ciphers = 'y qee', 'ejp mysljylc kd kxveddknmc re jsicpdrysi', 'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'de kr kd eoya kw aej tysr re ujdr lkgc jv'
 plaintexts = 'a zoo', 'our language is impossible to understand', 'there are twenty six factorial possibilities', 'so it is okay if you want to just give up'
 
 mapping = {}
 for cipher, plaintext in zip( ciphers, plaintexts ):
     for key, value in zip( cipher, plaintext ):
         mapping[ key.lower() ] = value.lower()
 mapping[ 'z' ] = 'q'
 
 T = read_integer()
 for t in range( T ):
     print 'Case #%i:' % ( t + 1 ), ''.join( mapping[ key.lower() ].upper() if key.isupper() else mapping[ key ] for key in read_line() )
",27,316,333
"():
     return sys.stdin.readline().rstrip( '\n' )
 
 def read_integer():
     return int( read_line() )
 
 def read_integers():
     return [ int( x ) for x in read_line().split() ]
 
 def flip( grid ):
     return [ bytearray( ''.join( chr( grid[ row ][ column ] ) for row in range( len( grid ) ) ) ) for column in range( len( grid[ 0 ] ) ) ]
 
 def grow( R, C, M ):
     grid = [ bytearray( C*[ '*' ] ) for row in range( R ) ]
     b = R*C - M
     if C > R:
         R, C, grid = C, R, flip( grid )
         flipped = True
     else:
         flipped = False
     if b < 2*C:
         if b == 1:
             grid[ 0 ][ 0 ] = 'c'
         elif b == 3 and C >= 3:
             grid[ 0 ][ : 3 ] = bytearray( '.c.' )
         elif b % 2:
             return
         else:
             grid[ 0 ][ : b//2 ] = bytearray( b//2*'.' )
             grid[ 1 ][ : b//2 ] = bytearray( b//2*'.' )
             grid[ 0 ][ 0 ] = 'c'
     else:
         r = 0
         while b >= C:
             grid[ r ] = bytearray( C*[ '.' ] )
             b -= C
             r += 1
         if b:
             if b >= 2:
                 grid[ r ][ : b ] = b*'.'
             elif C > 2 and r > 2:
                 grid[ r - 1 ][ -1 ] = '*'
                 grid[ r ][ : 2 ] = '..'
             else:
                 return
         grid[ 0 ][ 0 ] = 'c'
     return flip( grid ) if flipped else grid
     
 T = read_integer()
 for t in range( T ):
     print 'Case #%i:' % ( t + 1 )
     R, C, M = read_integers()
     grid = grow( R, C, M )
     print '\n'.join( str( row ) for row in grid ) if grid else 'Impossible'
",27,317,593
"():
     return sys.stdin.readline().rstrip( '\n' )
 
 def read_integer():
     return int( read_line() )
 
 def read_float():
     return float( read_line() )
 
 def read_floats():
     return [ float( x ) for x in read_line().split() ]
 
 T = read_integer()
 for t in range( T ):
     C, F, X = read_floats()
     rate = 2
     cookies = 0
     s = 0
     while True:
         t1 = X/rate
         t2 = C/rate + X/( rate + F )
         if t1 < t2:
             s += t1
             break
         s += C/rate
         rate += F
     print 'Case #%i: %.7f' % ( t + 1, s )
",27,318,215
"#!/usr/bin/python
 
 (puzutils.CodeJamProblem):
   def __init__(self, inputFilename):
     puzutils.CodeJamProblem.__init__(self, inputFilename)
 
     self.T = None
 
   def load(self):
     """"""
       input:
 
       T (number of test cases)
 
       A (answer to first question)
       x x x x
       x x x x
       x x x x
       x x x x
       B (answer to second question)
       x x x x
       x x x x
       x x x x
       x x x x
 
     """"""
 
     self.tests = []
 
     with open(self.inputFilename, ""rt"") as file:
       self.T = int(file.readline().strip())
 
       for i in xrange(self.T):
         a = int(file.readline().strip())
         test = {'a': a}
         board = []
         
         for j in xrange(4):
           line = file.readline().strip()
           row = set([int(x) for x in line.split(' ')])
           board.append(row)
 
         test['aboard'] = board
 
         b = int(file.readline().strip())
         test['b'] = b
         board = []
         
         for j in xrange(4):
           line = file.readline().strip()
           row = set([int(x) for x in line.split(' ')])
           board.append(row)
 
         test['bboard'] = board
 
         self.tests.append(test)
 
     return True
 
   def executeTest(self, test):
     """"""
       Run a test and return output.
     """"""
 
     #print ""Test: %s\n"" % (test, )
 
     rowA = test['aboard'][test['a'] - 1]
     rowB = test['bboard'][test['b'] - 1]
 
     #print ""rowA: %s\nrowB: %s\n"" % (rowA, rowB)
 
     intersect = rowA.intersection(rowB)
 
     #print ""intersect: %s\n"" % (intersect, )
 
     if (len(intersect) == 1):
       (element,) = intersect
       return element
     elif (len(intersect) == 0):
       return ""Volunteer cheated!""
     else:
       return ""Bad magician!""
 
 with Magic_2014_QA(sys.argv[1]) as problem:
   problem.load()
 
   problem.run()
",28,319,665
"#!/usr/bin/python
 
 def readfile(filename):
 	""""""
 	The first line of the input gives the number of test cases,
 	T. T test cases follow. Each test case consists of a single line
 	containing the integers A and B.
 	""""""
 
 	file = open(filename, ""rt"")
 
 	retval = {}
 
 	T = int(file.readline().strip())
 	retval['T'] = T
 
 	tests = []
 
 	for i in xrange(T):
 		line = file.readline().strip()
 
 		parts = line.split("" "")
 
 		A = int(parts[0])
 		B = int(parts[1])
 
 		test = {'A' : A, 'B' : B}
 
 		tests = tests + [test, ]
 
 	retval['tests'] = tests
 
 	return retval
 
 def isrecycled(n, m):
 	if (len(n) != len(m)):
 		return False
 
 	for i in range(len(n)):
 		left = n[:i]
 		right = n[i:]
 
 		flip = right + left
 
 		if (flip == m):
 			return True
 
 	return False
 
 def process(test):
 	count = 0
 
 	A = test['A']
 	B = test['B']
 
 	for n in xrange(A, B):
 		for m in xrange(n + 1, B):
 			if (isrecycled(str(n), str(m))):
 				count = count + 1
 
 	return count
 
 def process2(test):
 	count = 0
 
 	A = test['A']
 	B = test['B']
 
 	for n in xrange(A, B):
 		v = str(n)
 
 		found = set()
 
 		for i in xrange(len(v)):
 			left = v[:i]
 			right = v[i:]
 
 			flip = right + left
 			iflip = int(flip)
 
 			if ((iflip > n) and (iflip <= B)):
 				if (not iflip in found):
 					count = count + 1
 					found.add(iflip)
 
 	return count
 
 data = readfile(""C-small-attempt0.in"")
 
 for i in xrange(data['T']):
 	test = data['tests'][i]
 
 	result = process2(test)
 
 	print ""Case #%d: %d"" % (i + 1, result)
",28,320,744
"#!/usr/bin/python
 
 (file):
   """"""
     input:
 
 		T (number of test cases)
 
 		xxxx
 		xxxx
 		xxxx
 		xxxx	(T boards, where x in [X,O,T,.]
 
   """"""
 
   tests = []
 
   T = int(file.readline().strip())
 
   for i in xrange(T):
 		board = """"
     
 		for j in xrange(4):
 			line = file.readline().strip()
 
 			board = board + line
 
 		file.readline()
 
 		tests.append(board)
 
   return tests
 
 def fourInARow(who, test):
 	""""""
 		Find four of 'who' in a row (T wild).
 	""""""
 
 	target = (who, 'T')
 
 	# Horizontal/Vertical
 	for i in range(4):
 		horzWin = True
 		vertWin = True
 
 		for j in range(4):
 			horzIndex = i * 4 + j
 			vertIndex = j * 4 + i
 
 			if not (test[horzIndex] in target):
 				horzWin = False
 
 			if not (test[vertIndex] in target):
 				vertWin = False
 
 		if horzWin or vertWin:
 			return True
 
 	# Diagonal
 	slashWin = True
 	bslashWin = True
 
 	for i in range(4):
 		x = y = i
 
 		slashIndex = y * 4 + x
 		bslashIndex = y * 4 + (3 - x)
 
 		#print ""Checking (%d,%d) = %s and (%d,%d) = %s"" % (x, y, test[slashIndex], 3-x, y, test[bslashIndex])
 
 		if not (test[slashIndex] in target):
 			slashWin = False
 
 		if not (test[bslashIndex] in target):
 			bslashWin = False
 
 	if slashWin or bslashWin:
 		return True
 
 	return False
 
 def run(test):
 	""""""
 		Run a test and return output.
 	""""""
 
 	if fourInARow('X', test):
 		return ""X won""
 	elif fourInARow('O', test):
 		return ""O won""
 	elif '.' in test:
 		return ""Game has not completed""
 	else:
 		return ""Draw""
 
 file = open(sys.argv[1], ""rt"")
 
 tests = readfile(file)
 
 file.close()
 
 case = 1
 
 for test in tests:
 #if True:
   #test = tests[0]
   result = run(test)
   print ""Case #%d: %s"" % (case, result)
   case = case + 1
",28,321,815
"#!/usr/bin/python
 
 def readfile(filename):
 	""""""
 		The first line of the input gives the number of test
 		cases, T. T test cases follow. Each test case consists of
 		a single line containing integers separated by single
 		spaces. The first integer will be N, the number of
 		Googlers, and the second integer will be S, the number
 		of surprising triplets of scores. The third integer will
 		be p, as described above. Next will be N integers ti:
 		the total points of the Googlers.
 	""""""
 
 	file = open(filename, ""rt"")
 
 	retval = {}
 
 	T = int(file.readline().strip())
 	retval['T'] = T
 
 	tests = []
 
 	for i in xrange(T):
 		line = file.readline().strip()
 
 		parts = line.split("" "")
 
 		N = int(parts[0])
 		S = int(parts[1])
 		p = int(parts[2])
 		t = []
 
 		for j in xrange(N):
 			t = t + [int(parts[3 + j]), ]
 
 		test = { 'N' : N, 'S': S, 'p' : p, 't' : t }
 		tests = tests + [test, ]
 
 	retval['tests'] = tests
 	return retval
 
 def spread(triplet):
 	return max(abs(triplet[0] - triplet[1]), abs(triplet[1] - triplet[2]), abs(triplet[2] - triplet[0]))
 
 def bestresult(triplet):
 	if triplet:
 		return max(triplet)
 	return 0
 
 def getcombos(points):
 	""""""
 		Returns ([unsurprising possibilities, ], [surprising possibilities])
 	""""""
 
 	unsurps = []
 	surps = []
 
 	avg = points / 3.0
 
 	# Go from (avg-2) to (avg+3) to account for rounding
 	avg = int(avg)
 
 	tested = []
 
 	for i in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):
 		for j in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):
 			for k in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):
 				if (i + j + k) != points:
 					continue
 
 				scores = (i,j,k)
 				scores = sorted(scores)
 
 				if scores in tested:
 					continue
 				tested.append(scores)
 
 				s = spread((i,j,k))
 
 				if (s < 2):
 					unsurps.append(scores)
 				elif (s == 2):
 					surps.append(scores)
 				else:
 					continue
 
 	return (unsurps, surps)
 
 def getbesttriplet(triplets):
 	best = None
 
 	for i in triplets:
 		if best:
 			if (bestresult(i) > bestresult(best)):
 				best = i
 		else:
 			best = i
 
 	return best
 	
 
 def getmulticombos(peeps):
 	""""""
 		Return the best surprising and non-surprising possibility for
 		each person.
 	""""""
 
 	ret = []
 
 	for p in peeps:
 		u,s = getcombos(p)
 
 		bestu = getbesttriplet(u)
 		bests = getbesttriplet(s)
 
 		ret.append((bestu, bests))
 
 	return ret
 
 def getbestresults(scores, best, numsur):
 	""""""
 		Figure out the maximum number of people that could have gotten
 		a single score >= best.  Limited to choosing only numsur surprising
 		triplets.
 	""""""
 
 	peeps = getmulticombos(scores)
 
 	count = 0
 	surcount = 0
 
 	for p in peeps:
 		if (bestresult(p[0]) >= best):
 			# unsurprising is good
 			count = count + 1
 		elif ((bestresult(p[1]) >= best) and (surcount < numsur)):
 			count = count + 1
 			surcount = surcount + 1
 
 	return count
 
 def process(test):
 	N = test['N']
 	S = test['S']
 	p = test['p']
 	t = test['t']
 
 	return getbestresults(t, p, S)
 
 data = readfile(""B-small-attempt0.in"")
 
 for i in xrange(data['T']):
 	test = data['tests'][i]
 
 	result = process(test)
 
 	print ""Case #%d: %d"" % (i+1, result)
",28,322,1472
"#!/usr/bin/python
 
 (puzutils.CodeJamProblem):
   def __init__(self, inputFilename):
     puzutils.CodeJamProblem.__init__(self, inputFilename)
 
     self.T = None
 
   def load(self):
     """"""
       input:
 
       T (number of test cases)
 
       N (number of blocks)
       N1 N2 N3 ... (mass of Naomi's blocks, real)
       K1 K2 K3 ... (mass of Ken's blocks, real)
 
     """"""
 
     self.tests = []
 
     with open(self.inputFilename, ""rt"") as file:
       self.T = int(file.readline().strip())
 
       for i in xrange(self.T):
         N = int(file.readline().strip())
         naomi = [float(x) for x in file.readline().split(' ')]
         ken = [float(x) for x in file.readline().split(' ')]
 
         test = {'N': N, 'Naomi': naomi, 'Ken': ken}
 
         self.tests.append(test)
 
     return True
 
   def playWar(self, naomi, ken):
     """"""
       How many points does naomi get when playing standard War?
     """"""
 
     if (len(naomi) <= 0):
       return 0
 
     # Just choose the biggest?
     maxN = max(naomi)
 
     # Can ken win?
     maxK = max(ken)
 
     if maxK > maxN:
       # Ken uses the smallest one that will beat her
       k = min([x for x in ken if x > maxN])
 
       #print ""Ken wins (%.3f > %.3f), max %.3f"" % (k, maxN, maxK)
 
       naomi.remove(maxN)
       ken.remove(k)
 
       return 0 + self.playWar(naomi, ken)
     else:
       # Ken loses his smallest
       k = min(ken)
 
       #print ""Ken loses (%.3f < %.3f), max %.3f"" % (k, maxN, maxK)
 
       naomi.remove(maxN)
       ken.remove(k)
 
       return 1 + self.playWar(naomi, ken)
 
   def playDWar(self, naomi, ken):
     """"""
       How many points does naomi get when playing decietful war?
     """"""
 
     if (len(naomi) <= 0):
       return 0
 
     minN = min(naomi)
     minK = min(ken)
     maxK = max(ken)
 
     if (minN < minK):
       # This is a guaranteed loser, take a big one down with it
       naomi.remove(minN)
       ken.remove(maxK)
       return 0 + self.playDWar(naomi, ken)
 
     # Use our smallest one to beat his smallest one, by lying and
     # saying ours is bigger than his biggest
     naomi.remove(minN)
     ken.remove(minK)
     return 1 + self.playDWar(naomi, ken)
 
   def executeTest(self, test):
     """"""
       Run a test and return output.
     """"""
 
     dwar = self.playDWar(list(test['Naomi']), list(test['Ken']))
     war = self.playWar(list(test['Naomi']), list(test['Ken']))
     return ""%d %d"" % (dwar, war)
 
 with War_2014_QD(sys.argv[1]) as problem:
   problem.load()
 
   problem.run()
",28,323,966
"#!/usr/bin/python
 
 (file):
   """"""
     input:
 
 		T (number of test cases)
 
 		A B
 
   """"""
 
   tests = []
 
   T = int(file.readline().strip())
 
   for i in xrange(T):
 		test = {}
 
 		line = file.readline().strip()
 		parts = line.split("" "")
 
 		if len(parts) != 2:
 			print ""HORRIBLE ERROR IN TEST CASE %d"" % (i+1,)
 			return None
 
 		test['A'] = int(parts[0])
 		test['B'] = int(parts[1])
     
 		tests.append(test)
 
   return tests
 
 def isPalindrome(s):
 	""""""
 		Is s a palindrome.
 
 		S must be a string.
 	""""""
 
 	l = len(s)
 
 	if (l % 2) == 0:
 		# even
 		frontHalf = s[0:l/2]
 		backHalf = s[l/2:]
 	else:
 		# odd
 		frontHalf = s[0:(l-1)/2]
 		backHalf = s[(l+1)/2:]
 
 	backHalf = backHalf[::-1]
 
 	if frontHalf == backHalf:
 		return True
 	else:
 		return False
 
 def isFairAndSquare(n):
 
 	sqrtN = int(math.sqrt(n))
 
 	if (sqrtN * sqrtN) != n:
 		#print ""%d is not square"" % (n, )
 		return False
 
 	if not isPalindrome(str(n)):
 		#print ""%d is not palindrome"" % (n, )
 		return False
 
 	if not isPalindrome(str(sqrtN)):
 		#print ""sqrt(%d) = %d is not palindrome"" % (n, sqrtN)
 		return False
 
 	return True
 
 def run(test):
 	""""""
 		Run a test and return output.
 	""""""
 
 	count = 0
 
 	for i in xrange(test['A'], test['B'] + 1):
 		if isFairAndSquare(i):
 			count = count + 1
 
 	return count
 
 	i = int(math.sqrt(test['A']))
 
 	if (i * i) < test['A']:
 		i = i + 1
 
 	# Generate squares from palindromes
 	while i < test['B']:
 		#print ""Checking %d"" % (i, )
 		if not isPalindrome(str(i)):
 			i = i + 1
 			continue
 
 		# square it
 		s = i * i
 
 		if s <= test['B']:
 			if isPalindrome(str(s)):
 				#print ""Counting %d"" % (i * i, )
 				count = count + 1
 		else:
 			# all done
 			break
 
 		i = i + 1
 
 	return ""%s"" % (count, )
 
 file = open(sys.argv[1], ""rt"")
 
 tests = readfile(file)
 
 file.close()
 
 case = 1
 
 for test in tests:
 #if True:
   #test = tests[0]
   result = run(test)
   print ""Case #%d: %s"" % (case, result)
   case = case + 1
",28,324,1013
"#!/usr/bin/python
 
 = ""aoz""
 outpt = ""yeq""
 
 input = input + ""our language is impossible to understand""
 outpt = outpt + ""ejp mysljylc kd kxveddknmc re jsicpdrysi""
 
 input = input + ""there are twenty six factorial possibilities""
 outpt = outpt + ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd""
 
 input = input + ""so it is okay if you want to just give up""
 outpt = outpt + ""de kr kd eoya kw aej tysr re ujdr lkgc jv""
 
 input = input + ""q""
 outpt = outpt + ""z""
 
 togoog = maketrans(input, outpt)
 ungoog = maketrans(outpt, input)
 
 filename = ""A-small-attempt1.in""
 
 file = open(filename, ""rt"")
 
 T = int(file.readline().strip())
 
 for i in xrange(T):
 	line = file.readline().strip()
 
 	print ""Case #%d: %s"" % (i + 1, line.translate(ungoog))
",28,325,312
"#!/usr/bin/python
 
 (puzutils.CodeJamProblem):
   def __init__(self, inputFilename):
     puzutils.CodeJamProblem.__init__(self, inputFilename)
 
     self.T = None
 
   def load(self):
     """"""
       input:
 
       T (number of test cases)
 
       R C M (integers)
 
     """"""
 
     self.tests = []
 
     with open(self.inputFilename, ""rt"") as file:
       self.T = int(file.readline().strip())
 
       for i in xrange(self.T):
         (R,C,M) = [int(x) for x in file.readline().split(' ')]
 
         self.tests.append([R,C,M])
 
     return True
 
   def boardToString(self, board):
     retval = """"
 
     for row in board:
       retval = retval + ""\n"" + """".join(row)
 
     return retval
 
   def executeTest(self, test):
     """"""
       Run a test and return output.
     """"""
 
     (R,C,M) = test
     #print ""R: %d, C: %d, M: %d"" % (R,C,M)
 
     spaces = R * C
     blanks = spaces - M
 
     if (blanks <= 0):
       #print ""R: %d, C: %d, M: %d, spaces: %d, blanks: %d"" % (R,C,M,spaces,blanks)
       return ""Impossible""
 
     board = [['.' for x in range(C)] for y in range(R)]
 
     board[R-1][C-1] = ""c""
 
     badpositions=[]
     positions=[]
 
     for x in xrange(C):
       for y in xrange(R):
         if (x == (C-1)) and (y == (R-1)):
           continue
         if (x == (C-1)) and (y == (R-2)):
           badpositions.append((x,y))
           continue
         if (x == (C-2)) and (y == (R-1)):
           badpositions.append((x,y))
           continue
         if (x == (C-2)) and (y == (R-2)):
           badpositions.append((x,y))
           continue
 
         positions.append((x,y))
 
     positions.reverse()
 
     for x in badpositions:
       positions.insert(0, x)
 
     m = M
 
     while (m > 0):
       if len(positions) <= 0:
         #return self.boardToString(board)
         return ""Impossible""
 
       pos = positions.pop()
       (x,y) = pos
 
       if (board[y][x] != "".""):
         #return self.boardToString(board)
         return ""Impossible""
 
       board[y][x] = '*'
       m = m - 1
 
     mines = sum([x.count('*') for x in board])
 
     if (mines != M):
       #return self.boardToString(board)
       return ""Impossible""
 
     if (blanks > 1):
       if (R > 1):
         if board[R - 2][C - 1] == ""*"":
           #return self.boardToString(board)
           return ""Impossible""
 
       if (C > 1):
         if board[R - 1][C - 2] == ""*"":
           #return self.boardToString(board)
           return ""Impossible""
 
       if (R > 1) and (C > 1):
         if board[R - 2][C - 2] == ""*"":
           #return self.boardToString(board)
           return ""Impossible""
 
     #return ""Possible""
     return self.boardToString(board)
 
 with Minesweeper_2014_QC(sys.argv[1]) as problem:
   problem.load()
 
   problem.run()
",28,326,1044
"#!/usr/bin/python
 
 (puzutils.CodeJamProblem):
   def __init__(self, inputFilename):
     puzutils.CodeJamProblem.__init__(self, inputFilename)
 
     self.T = None
 
   def load(self):
     """"""
       input:
 
       T (number of test cases)
 
       C F X (real numbers)
 
     """"""
 
     self.tests = []
 
     with open(self.inputFilename, ""rt"") as file:
       self.T = int(file.readline().strip())
 
       for i in xrange(self.T):
         (C,F,X) = [float(x) for x in file.readline().split(' ')]
 
         self.tests.append([C,F,X])
 
     return True
 
   def timeToNextFarm(self, C, rate):
     """"""
       How long in seconds until we get the next farm.
     """"""
 
     return (C * 1.0) / rate
 
   def timeToTarget(self, C, X, rate):
     """"""
       How long in seconds until we hit the target.
     """"""
 
     return ( X * 1.0) / rate
 
   def isFarmWorthIt(self, C, X, F, rate):
     #print ""C = %.2f, F = %.2f, X = %.2f, rate = %.2f"" % (C, F, X, rate)
 
     withoutFarm = self.timeToTarget(C, X, rate)
     withFarm = self.timeToNextFarm(C, rate) + self.timeToTarget(C, X, rate + F)
 
     #print ""With farm = %.2f"" % (withFarm,)
     #print ""Without farm = %.2f"" % (withoutFarm,)
 
     if (withFarm < withoutFarm):
       return True
     else:
       return False
 
   def executeTest(self, test):
     """"""
       Run a test and return output.
     """"""
 
     (C,F,X) = test
     rate = 2
     elapsed = 0.0
 
     #print ""C = %.2f, F = %.2f, X = %.2f, rate = %.2f"" % (C, F, X, rate)
 
     while True:
       if self.isFarmWorthIt(C, X, F, rate):
         #print ""%.2f: Bought farm, rate = %d"" % (elapsed, rate)
         elapsed = elapsed + self.timeToNextFarm(C, rate)
         rate = rate + F
       else:
         #print ""%.2f: Giving up and finishing it out, rate = %d"" % (elapsed, rate)
         elapsed = elapsed + self.timeToTarget(C, X, rate)
         return ""%0.7f"" % (elapsed, )
 
 with Cookie_2014_QB(sys.argv[1]) as problem:
   problem.load()
 
   problem.run()
",28,327,772
"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 # Recently you went to a magic show. You were very impressed by one of the tricks, so you decided to try to figure out the secret behind it!
 
 # The magician starts by arranging 16 cards in a square grid: 4 rows of cards, with 4 cards in each row. Each card has a different number from 1 to 16 written on the side that is showing. Next, the magician asks a volunteer to choose a card, and to tell him which row that card is in.
 
 # Finally, the magician arranges the 16 cards in a square grid again, possibly in a different order. Once again, he asks the volunteer which row her card is in. With only the answers to these two questions, the magician then correctly determines which card the volunteer chose. Amazing, right?
 
 # You decide to write a program to help you understand the magician's technique. The program will be given the two arrangements of the cards, and the volunteer's answers to the two questions: the row number of the selected card in the first arrangement, and the row number of the selected card in the second arrangement. The rows are numbered 1 to 4 from top to bottom.
 
 # Your program should determine which card the volunteer chose; or if there is more than one card the volunteer might have chosen (the magician did a bad job); or if there's no card consistent with the volunteer's answers (the volunteer cheated).
 
 # Solving this problem
 
 # Usually, Google Code Jam problems have 1 Small input and 1 Large input. This problem has only 1 Small input. Once you have solved the Small input, you have finished solving this problem.
 
 # Input
 
 # The first line of the input gives the number of test cases, T. T test cases follow. Each test case starts with a line containing an integer: the answer to the first question. The next 4 lines represent the first arrangement of the cards: each contains 4 integers, separated by a single space. The next line contains the answer to the second question, and the following four lines contain the second arrangement in the same format.
 
 # Output
 
 # For each test case, output one line containing ""Case #x: y"", where x is the test case number (starting from 1).
 
 # If there is a single card the volunteer could have chosen, y should be the number on the card. If there are multiple cards the volunteer could have chosen, y should be ""Bad magician!"", without the quotes. If there are no cards consistent with the volunteer's answers, y should be ""Volunteer cheated!"", without the quotes. The text needs to be exactly right, so consider copying/pasting it from here.
 
 # Limits
 
 # 1 â¤ T â¤ 100.
 # 1 â¤ both answers â¤ 4.
 # Each number from 1 to 16 will appear exactly once in each arrangement.
 
 
 (*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     answer1 = int(fin.readline())
     rows1 = []
     for i in range(4):
         rows1.append(set(map(int, fin.readline().split())))
     answer2 = int(fin.readline())
     rows2 = []
     for i in range(4):
         rows2.append(set(map(int, fin.readline().split())))
 
     possibilities1 = rows1[answer1-1]
     possibilities2 = rows2[answer2-1]
 
     numbers = possibilities1.intersection(possibilities2)
     result = None
     if len(numbers) == 1:
         result = list(numbers)[0]
     elif len(numbers) == 0:
         result = 'Volunteer cheated!'
     else:
         result = 'Bad magician!'
 
 
     print(""Case #%d: %s"" % (case, result))
 
",29,328,1007
"= sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     board = []
     N, M = map(int, fin.readline().split())
     for i in range(N):
         board.append(list(map(int, fin.readline().split())))
     
     row_min = [100]*N
     row_max = [0]*N
     col_min = [100]*M
     col_max = [0]*M
 
     for i in range(N):
         for j in range(M):
             v = board[i][j]
             row_min[i] = min(v, row_min[i])
             row_max[i] = max(v, row_max[i])
             col_min[j] = min(v, col_min[j])
             col_max[j] = max(v, col_max[j])
 
 
     possible = True
     for i in range(N):
         for j in range(M):
             v = board[i][j]
             if v != row_max[i] and v != col_max[j]:
                 possible = False
                 break
 
 
     print(""Case #%d: %s"" % (case, possible and ""YES"" or ""NO""))
 
 
 
",29,329,331
"# -*- coding: utf-8 -*-
 = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     A, B = map(int, fin.readline().split())
 
     total = 0
 
     for i in range(A, B+1):
         n = str(i)
         pairs = set()
         for shift in range(1, len(n)):
             m = n[shift:] + n[:shift]
             j = int(m)
             if j > i and j <= B:
                 pairs.add(m)
         total += len(pairs)
 
 
     print ""Case #%d: %s"" % (case, total)
 
",29,330,181
"= sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     board = []
     for i in range(4):
         row = list(fin.readline().strip())
         board.append(row)
 
     fin.readline()
 
     rows = [[], [], [], []]
     cols = [[], [], [], []]
     diags = [[], []]
 
     for i in range(4):
         for j in range(4):
             v = board[i][j]
             rows[i].append(v)
             cols[j].append(v)
             if i == j:
                 diags[0].append(v)
             if i + j == 3:
                 diags[1].append(v)
 
     buckets = rows + cols + diags
     result = 'Draw'
     filled = True
     for bucket in buckets:
         d = {'T': 0, 'X': 0, 'O': 0, '.': 0}
         for v in bucket:
             d[v] += 1
         if d['T'] + d['X'] == 4:
             result = 'X won'
             break
         if d['T'] + d['O'] == 4:
             result = 'O won'
             break
         if d['.'] > 0:
             result = 'Game has not completed'
 
     print(""Case #%d: %s"" % (case, result))
 
 
 
",29,331,369
"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 # Naomi and Ken sometimes play games together. Before they play, each of them gets N identical-looking blocks of wood with masses between 0.0kg and 1.0kg (exclusive). All of the blocks have different weights. There are lots of games they could play with those blocks, but they usually play something they call War. Here is how War works:
 
 # Each player weighs each of his or her own blocks, so each player knows the weights of all of his or her own blocks, but not the weights of the other player's blocks.
 # They repeat the following process N times:
 # Naomi chooses one of her own blocks, with mass ChosenNaomi.
 # Naomi tells Ken the mass of the block she chose.
 # Ken chooses one of his own blocks, with mass ChosenKen.
 # They each put their block on one side of a balance scale, and the person whose block is heavier gets one point.
 # Both blocks are destroyed in a fire.
 # Naomi has realized three things about War. First, she has realized that she loses a lot. Second, she has realized that there is a unique strategy that Ken can follow to maximize his points without assuming anything about Naomi's strategy, and that Ken always uses it. Third, she has realized that she hates to lose. Naomi has decided that instead of playing War, she will play a game she calls Deceitful War. The great thing about Deceitful War is that Ken will think they're playing War!
 
 # Here is how Deceitful War works, with differences between Deceitful War and War in bold:
 
 # Each player weighs each of his or her own blocks. Naomi also weighs Ken's blocks while he isn't looking, so Naomi knows the weights of all blocks and Ken only knows the weights of his own blocks.
 # They repeat the following process N times:
 # Naomi chooses one of her own blocks, with mass ChosenNaomi.
 # Naomi tells Ken a number, ToldNaomi, between 0.0kg and 1.0kg exclusive. Ken, who thinks they're playing War, thinks the number Naomi just told him is ChosenNaomi.
 # Ken chooses one of his own blocks, with mass ChosenKen.
 # They each put their block on one side of a balance scale, and the person whose block is heavier gets one point.
 # Both blocks are destroyed in a fire.
 # Naomi doesn't want Ken to know that she isn't playing War; so when she is choosing which block to play, and what mass to tell Ken, she must make sure that the balance scale won't reveal that ChosenNaomi â  ToldNaomi. In other words, she must make decisions so that:
 
 # ChosenNaomi > ChosenKen if, and only if, ToldNaomi > ChosenKen, and
 # ToldNaomi is not equal to the mass of any of Ken's blocks, because he knows that isn't possible.
 # It might seem like Naomi won't win any extra points by being deceitful, because Ken might discover that she wasn't playing War; but Naomi knows Ken thinks both players are playing War, and she knows what he knows, and she knows Ken will always follow his unique optimal strategy for War, so she can always predict what he will play.
 
 # You'll be given the masses of the blocks Naomi and Ken started with. Naomi will play Deceitful War optimally to gain the maximum number of points. Ken will play War optimally to gain the maximum number of points assuming that both players are playing War. What will Naomi's score be? What would it have been if she had played War optimally instead?
 
 # Examples
 
 # If each player has a single block left, where Naomi has 0.5kg and Ken has 0.6kg, then Ken is guaranteed to score the point. Naomi can't say her number is â¥ 0.6kg, or Ken will know she isn't playing War when the balance scale shows his block was heavier.
 
 # If each player has two blocks left, where Naomi has [0.7kg, 0.2kg] and Ken has [0.8kg, 0.3kg], then Naomi could choose her 0.2kg block, and deceive Ken by telling him that she chose a block that was 0.6kg. Ken assumes Naomi is telling the truth (as in how the War game works) and will play his 0.8kg block to score a point. Ken was just deceived, but he will never realize it because the balance scale shows that his 0.8kg block is, like he expected, heavier than the block Naomi played. Now Naomi can play her 0.7kg block, tell Ken it is 0.7kg, and score a point. If Naomi had played War instead of Deceitful War, then Ken would have scored two points and Naomi would have scored zero.
 
 # Input
 
 # The first line of the input gives the number of test cases, T. T test cases follow. Each test case starts with a line containing a single integer N, the number of blocks each player has. Next follows a line containing N space-separated real numbers: the masses of Naomi's blocks, in kg. Finally there will be a line containing N space-separated real numbers: the masses of Ken's blocks, in kg.
 
 # Each of the masses given to Ken and Naomi will be represented as a 0, followed by a decimal point, followed by 1-5 digits. Even though all the numbers in the input have 1-5 digits after the decimal point, Ken and Naomi don't know that; so Naomi can still tell Ken that she played a block with mass 0.5000001kg, and Ken has no reason not to believe her.
 
 # Output
 
 # For each test case, output one line containing ""Case #x: y z"", where x is the test case number (starting from 1), y is the number of points Naomi will score if she plays Deceitful War optimally, and z is the number of points Naomi will score if she plays War optimally.
 
 # Limits
 
 # 1 â¤ T â¤ 50.
 # All the masses given to Ken and Naomi are distinct, and between 0.0 and 1.0 exclusive.
 # Small dataset
 
 # 1 â¤ N â¤ 10.
 # Large dataset
 
 # 1 â¤ N â¤ 1000.
 
 
 (*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N = int(fin.readline())
     numbers1 = list(map(float, fin.readline().split()))
     numbers2 = list(map(float, fin.readline().split()))
 
     numbers1.sort(reverse=True)
     numbers2.sort()
 
     # Normal
     naomi = 0
     remaining = numbers2[:]
     for n in numbers1:
         lost = False
         for i, r in enumerate(remaining):
             if r > n:
                 del remaining[i]
                 lost = True
                 break
         if not lost:
             naomi += 1
 
     cheat = 0
     remaining = numbers2[:]
     numbers1.sort()
     # debug(numbers1)
     # debug(remaining)
     while numbers1:
         n = numbers1[0]
         if n > remaining[0]:
             cheat += 1
             del remaining[0]
             del numbers1[0]
         else:
             del remaining[-1]
             del numbers1[0]
 
     print(""Case #%d: %d %d"" % (case, cheat, naomi))
 
",29,332,1899
"= 10**4
 
 # [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004]
 # [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004, 100000020000001, 100220141022001, 102012040210201, 102234363432201, 121000242000121, 121242363242121, 123212464212321, 123456787654321, 400000080000004, 10000000200000001, 10002000300020001, 10004000600040001, 10020210401202001, 10022212521222001, 10024214841242001, 10201020402010201, 10203040504030201, 10205060806050201, 10221432623412201, 10223454745432201, 12100002420000121, 12102202520220121, 12104402820440121, 12122232623222121, 12124434743442121, 12321024642012321, 12323244744232321, 12343456865434321, 12345678987654321, 40000000800000004, 40004000900040004, 1000000002000000001, 1000220014100220001, 1002003004003002001, 1002223236323222001, 1020100204020010201, 1020322416142230201, 1022123226223212201, 1022345658565432201, 1210000024200000121, 1210242036302420121, 1212203226223022121, 1212445458545442121, 1232100246420012321, 1232344458544432321, 1234323468643234321, 4000000008000000004, 100000000020000000001L, 100002000030000200001L, 100004000060000400001L, 100020201040102020001L, 100022201252102220001L, 100024201484102420001L, 100200120040021002001L, 100202122050221202001L, 100204124080421402001L, 100220341262143022001L, 100222343474343222001L, 102010002040200010201L, 102012022050220210201L, 102014042080240410201L, 102030405060504030201L, 102032425272524230201L, 102212122262221212201L, 102214144272441412201L, 102232545484545232201L, 102234567696765432201L, 121000000242000000121L, 121002200252002200121L, 121004400282004400121L, 121022221262122220121L, 121024421474124420121L, 121220122262221022121L, 121222324272423222121L, 121242363484363242121L, 121244565696565442121L, 123210002464200012321L, 123212222474222212321L, 123232425484524232321L, 123234645696546432321L, 123432124686421234321L, 123434346696643434321L, 400000000080000000004L, 400004000090000400004L, 10000000000200000000001L, 10000220001410002200001L, 10002002100400120020001L, 10002222123632122220001L, 10020010200400201002001L, 10020230421612403202001L, 10022014302620341022001L, 10022234545854543222001L, 10201000020402000010201L, 10201222221612222210201L, 10203022140604122030201L, 10203244363836344230201L, 10221210222622201212201L, 10221432643834623412201L, 10223234344844343232201L, 12100000002420000000121L, 12100242003630024200121L, 12102202302620320220121L, 12102444325852344420121L, 12122010222622201022121L, 12122252443834425222121L, 12124214524842541242121L, 12321000024642000012321L, 12321244225852244212321L, 12323222344844322232321L, 12343210246864201234321L, 40000000000800000000004L]
 def isp(n):
     s = str(n)
     return s == s[::-1]
 
 fs = []
 for i in range(N):
     s = str(i)
     n1 = int(s + s[::-1])**2
     n2 = int(s[:-1] + s[::-1])**2
 
     if isp(n1):
         fs.append(n1)
     if isp(n2):
         fs.append(n2)
 
 fs.sort()
 
 print(fs, file=sys.stderr)
 
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     board = []
     A, B = map(int, fin.readline().split())
 
     i = bisect.bisect_left(fs, A)
     j = bisect.bisect_right(fs, B)
 
     print(""Case #%d: %s"" % (case, j-i))
 
 
",29,333,3628
"# -*- coding: utf-8 -*-
 = """"""ejp mysljylc kd kxveddknmc re jsicpdrysi
 rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
 de kr kd eoya kw aej tysr re ujdr lkgc jv""""""
 
 output = """"""our language is impossible to understand
 there are twenty six factorial possibilities
 so it is okay if you want to just give up""""""
 
 mapping = {'a': 'y', 'o': 'e', 'z': 'q', 'q': 'z'}
 
 for i, c in enumerate(input):
     mapping[c] = output[i]
 
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     line = fin.readline().strip()
 
     result = """"
     for c in line:
         result += mapping[c]
 #    N, M = map(int, fin.readline().split())
 
     print ""Case #%d: %s"" % (case, result)
 
",29,334,278
"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 # Minesweeper is a computer game that became popular in the 1980s, and is still included in some versions of the Microsoft Windows operating system. This problem has a similar idea, but it does not assume you have played Minesweeper.
 
 # In this problem, you are playing a game on a grid of identical cells. The content of each cell is initially hidden. There are M mines hidden in M different cells of the grid. No other cells contain mines. You may click on any cell to reveal it. If the revealed cell contains a mine, then the game is over, and you lose. Otherwise, the revealed cell will contain a digit between 0 and 8, inclusive, which corresponds to the number of neighboring cells that contain mines. Two cells are neighbors if they share a corner or an edge. Additionally, if the revealed cell contains a 0, then all of the neighbors of the revealed cell are automatically revealed as well, recursively. When all the cells that don't contain mines have been revealed, the game ends, and you win.
 
 # For example, an initial configuration of the board may look like this ('*' denotes a mine, and 'c' is the first clicked cell):
 
 # *..*...**.
 # ....*.....
 # ..c..*....
 # ........*.
 # ..........
 # There are no mines adjacent to the clicked cell, so when it is revealed, it becomes a 0, and its 8 adjacent cells are revealed as well. This process continues, resulting in the following board:
 # *..*...**.
 # 1112*.....
 # 00012*....
 # 00001111*.
 # 00000001..
 # At this point, there are still un-revealed cells that do not contain mines (denoted by '.' characters), so the player has to click again in order to continue the game.
 # You want to win the game as quickly as possible. There is nothing quicker than winning in one click. Given the size of the board (R x C) and the number of hidden mines M, is it possible (however unlikely) to win in one click? You may choose where you click. If it is possible, then print any valid mine configuration and the coordinates of your click, following the specifications in the Output section. Otherwise, print ""Impossible"".
 
 # Input
 
 # The first line of the input gives the number of test cases, T. T lines follow. Each line contains three space-separated integers: R, C, and M.
 
 # Output
 
 # For each test case, output a line containing ""Case #x:"", where x is the test case number (starting from 1). On the following R lines, output the board configuration with C characters per line, using '.' to represent an empty cell, '*' to represent a cell that contains a mine, and 'c' to represent the clicked cell.
 
 # If there is no possible configuration, then instead of the grid, output a line with ""Impossible"" instead. If there are multiple possible configurations, output any one of them.
 
 # Limits
 
 # 0 â¤ M < R * C.
 # Small dataset
 
 # 1 â¤ T â¤ 230.
 # 1 â¤ R, C â¤ 5.
 # Large dataset
 
 # 1 â¤ T â¤ 140.
 # 1 â¤ R, C â¤ 50.
  
 
 
 (*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     RR, CC, M = map(int, fin.readline().split())
     R, C = None, None
     blocks = RR*CC - M
     inverse = False
     if RR > CC:
         inverse = True
         R, C = CC, RR
     else:
         R, C = RR, CC
     result = None
     # Now R <= C
     if R == 1:
         # Always possible
         result = [('.' * blocks) + ('*' * M)]
     elif R == 2:
         # Possible if blocks == 1 or blocks % 2 == 0
         if blocks == 1:
             result = ['.' + ('*' * (C-1)), '*' * C]
         elif blocks % 2 == 0 and blocks != 2:
             cc = blocks // 2
             result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] 
         else:
             result = None
     else:
         if blocks == 1:
             result = ['*' * C] * R
         elif blocks == 4:
             result = ['..' + (C-2)*'*']*2
             result += ['*'*C] * (R-2)
         elif blocks == 6:
             result = ['...' + (C-3)*'*']*2
             result += ['*'*C] * (R-2)
         for rows in range(3, R+1):
             for columns in range(rows, C+1):
                 size = rows * columns
                 if size - blocks >= 0:
                     if size - blocks <= columns - 2: 
                         result = []
                         for r in range(rows):
                             if r < rows - 1:
                                 result.append(('.' * columns) + ('*' * (C - columns)))
                             else:
                                 cc = columns - (size - blocks)
                                 result.append(('.' * cc) + ('*' * (C - cc)))
                         for r in range(R - rows):
                             result.append('*' * C)
                     elif size - blocks == columns - 1 and rows >= 4:
                         result = []
                         for r in range(rows):
                             if r < rows - 2:
                                 result.append(('.' * columns) + ('*' * (C - columns)))
                             elif r == rows - 2:
                                 cc = columns - 1
                                 result.append(('.' * cc) + ('*' * (C - cc)))
                             else:
                                 cc = 2
                                 result.append(('.' * cc) + ('*' * (C - cc)))
                         for r in range(R - rows):
                             result.append('*' * C)
                     
 
 
 
     print(""Case #%d: "" % (case))
     if result is None:
         debug('impossible', blocks, RR, CC)
         print(""Impossible"")
     else:
         mines = 0
         for r in range(RR):
             row = ''
             for c in range(CC):
                 rr, cc = r, c
                 if inverse:
                     rr, cc = c, r
                 if rr == 0 and cc == 0:
                     row += 'c'
                 else:
                     row += result[rr][cc]
                     if result[rr][cc] == '*':
                         mines += 1
             print(row)
         if mines != M:
             raise Exception(""%d != %d %d x %d"" % (mines, M, RR, CC))
             
 
 
",29,335,1818
"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 # Cookie Clicker is a Javascript game by Orteil, where players click on a picture of a giant cookie. Clicking on the giant cookie gives them cookies. They can spend those cookies to buy buildings. Those buildings help them get even more cookies. Like this problem, the game is very cookie-focused. This problem has a similar idea, but it does not assume you have played Cookie Clicker. Please don't go play it now: it might be a long time before you come back.
 
 # Problem
 
 # In this problem, you start with 0 cookies. You gain cookies at a rate of 2 cookies per second, by clicking on a giant cookie. Any time you have at least C cookies, you can buy a cookie farm. Every time you buy a cookie farm, it costs you C cookies and gives you an extra F cookies per second.
 
 # Once you have X cookies that you haven't spent on farms, you win! Figure out how long it will take you to win if you use the best possible strategy.
 
 # Example
 
 # Suppose C=500.0, F=4.0 and X=2000.0. Here's how the best possible strategy plays out:
 
 # You start with 0 cookies, but producing 2 cookies per second.
 # After 250 seconds, you will have C=500 cookies and can buy a farm that produces F=4 cookies per second.
 # After buying the farm, you have 0 cookies, and your total cookie production is 6 cookies per second.
 # The next farm will cost 500 cookies, which you can buy after about 83.3333333 seconds.
 # After buying your second farm, you have 0 cookies, and your total cookie production is 10 cookies per second.
 # Another farm will cost 500 cookies, which you can buy after 50 seconds.
 # After buying your third farm, you have 0 cookies, and your total cookie production is 14 cookies per second.
 # Another farm would cost 500 cookies, but it actually makes sense not to buy it: instead you can just wait until you have X=2000 cookies, which takes about 142.8571429 seconds.
 # Total time: 250 + 83.3333333 + 50 + 142.8571429 = 526.1904762 seconds.
 # Notice that you get cookies continuously: so 0.1 seconds after the game starts you'll have 0.2 cookies, and Ï seconds after the game starts you'll have 2Ï cookies.
 
 # Input
 
 # The first line of the input gives the number of test cases, T. T lines follow. Each line contains three space-separated real-valued numbers: C, F and X, whose meanings are described earlier in the problem statement.
 
 # C, F and X will each consist of at least 1 digit followed by 1 decimal point followed by from 1 to 5 digits. There will be no leading zeroes.
 
 # Output
 
 # For each test case, output one line containing ""Case #x: y"", where x is the test case number (starting from 1) and y is the minimum number of seconds it takes before you can have X delicious cookies.
 
 
 # Limits
 
 # 1 â¤ T â¤ 100.
 
 # Small dataset
 
 # 1 â¤ C â¤ 500.
 # 1 â¤ F â¤ 4.
 # 1 â¤ X â¤ 2000.
 # Large dataset
 
 # 1 â¤ C â¤ 10000.
 # 1 â¤ F â¤ 100.
 # 1 â¤ X â¤ 100000.
 
 (*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     C, F, X = map(float, fin.readline().split())
 
 
     rate = 2
     time = 0
 
     best = 10**20
 
     while time < best:
         result = X / rate + time
         if result < best:
             best = result
         time += C / rate
         rate += F
 
 
 
     print(""Case #%d: %.7f"" % (case, best))
 
",29,336,1139
"#!/usr/bin/python
 
 filename = ""A-small-attempt0.in""
 
 inp = open(filename, ""rU"")
 
 n = int(inp.readline().strip())
 
 for case in range(1, n+1):
     gr = lambda x: [list(map(int, inp.readline().strip().split("" ""))) for p in range(4)][x-1]
     ans1 = int(inp.readline().strip())
     row1 = set(gr(ans1))
     ans2 = int(inp.readline().strip())
     row2 = set(gr(ans2))
     sect = row1 & row2
     if len(sect) <= 0:
         print(""Case #{}: Volunteer cheated!"".format(case))
     elif len(sect) == 1:
         print(""Case #{}: {}"".format(case, sect.pop()))
     elif len(sect) > 1:
         print(""Case #{}: Bad magician!"".format(case))
     else:
         print(""ERROR"")
",30,337,261
"def check(grid):
     if len(grid) <= 1 or len(grid[0]) <= 1:
         return True
     for r in range(len(grid)-1):
         for c in range(len(grid[r])-1):
             e1 = grid[r][c]
             e2 = grid[r][c+1]
             e3 = grid[r+1][c]
             e4 = grid[r+1][c+1]
             if (e1 > e2 and e4 > e2) or (e1 > e3 and e4 > e3):
                 return False
             if (e2 > e1 and e3 > e1) or (e2 > e4 and e3 > e4):
                 return False
     return True
 
 def removeG(grid):
     for i in range(len(grid)):
         if len(set(grid[i])) == 1 and grid[i][0] == 1 :
             del grid[i]
             return True
     return False
 
 infile = open('B-small-attempt5.in', 'Ur')
 #infile = open('test3.in', 'Ur')
 
 tests = int(infile.readline().strip())
 
 for t in range(tests):
     grid = []
     h, w = [int(x) for x in infile.readline().strip().split()]
     for i in range(h):
         row =[int(x) for x in infile.readline().strip().split()]
         grid.append(row)
 
     pass1 = check(grid)
     print(""------"")
     for r in grid:
         print("" "".join([str(x) for x in r]))
     while len(grid) >= 3:
         if not removeG(grid):
             break
 
     pass2 = check(grid)
     grid = [x for x in zip(*grid[::-1])]
     while len(grid) >= 3:
         if not removeG(grid):
             break
     print(""------"")
     for r in grid:
         print("" "".join([str(x) for x in r]))
     pass3 = check(grid)
 
 
 #   if len(grid) >= 3:
 #       grid = [row for row in grid if len(set(row)) != 1]
 #   print(""------"")
 #   for r in grid:
 #       print("" "".join([str(x) for x in r]))
 
     if pass1 and pass2 and pass3:
         res = 'YES'
     else:
         res = 'NO'
 
     print(""Case #{0}: {1}"".format(t+1,res))
 
 
",30,338,658
"data = [ [int(a) for a in i.split("" "")] for i in open(""C-small-attempt0.in"",""rU"").read()[:-1].split(""\n"")]
 
 def recycle(number, mini, maxi):
 	number2 = str(number)
 	count = 0
 	for i in range(len(number2)):
 		number2 = number2[-1:] + number2[:-1]
 		numtemp = int(number2)
 		if (number == numtemp) or (number > numtemp):
 			continue
 		if ((numtemp <= maxi) and (numtemp > mini)):
 			#print (number,numtemp)
 			numlist.append((number,numtemp))
 			count += 1
 	return count
 # total = 0
 # for i in range(1111,2222):
 # 	total += (recycle(i,1111,2222))
 # 	print (len(set(numlist)))
 
 
 
 count = 0
 for line in data[1:]:
 	count += 1
 	total = 0
 	numlist = []
 	for a in range(line[0],(line[1])):
 		total += recycle(a,line[0], line[1])
 	print (""Case #""+str(count)+"":"", len(set(numlist)))",30,339,362
"infile = open('A-small-attempt0.in', 'Ur').read()[1:].split('\n\n')
 
 case = 1
 for test in infile:
     test = test.replace('\n','')
     sets = []
     if not test:
         break
 
     r = 0
     for i in range(4):
         sets.append(test[i::4])
         sets.append(test[r:r+4])
         r = r+4
     sets.append(test[0] + test[5] + test[10] + test[15])
     sets.append(test[3] + test[6] + test[9] + test[12])
 
     sets = [set(x) for x in sets]
     winner = ''
     for i in sets:
         if i.issubset({'X', 'T'}):
             winner = 'X'
             break
         if i.issubset({'O', 'T'}):
             winner = 'O'
             break
 
     if winner:
         print(""Case #{0}: {1} won"".format(case, winner))
     else:
         if '.' in test:
             print(""Case #{0}: Game has not completed"".format(case))
         else:
             print(""Case #{0}: Draw"".format(case))
     case += 1
 
",30,340,335
"#data = [ [int(a) for a in i.split("" "")] for i in open(""small.data"",""rU"").read().split(""\n"")]
 data = [[100],[3,1,5,15,13,11],[3,0,8,23,22,21],[2,0,8,26,20],[1,0,3,30],[2,2,5,6,19],[2,0,9,18,2],[3,0,8,0,22,23],[3,2,4,29,17,28],[2,2,10,6,7],[2,1,1,17,0],[1,0,9,2],[2,0,10,27,27],[1,0,10,12],[2,2,6,20,12],[3,1,2,5,24,15],[3,0,8,29,20,20],[1,1,9,13],[1,1,7,11],[2,0,2,2,2],[1,0,5,11],[1,0,4,8],[1,0,4,1],[3,1,3,10,9,3],[2,2,7,15,2],[2,0,1,26,28],[3,0,10,5,27,9],[2,2,5,21,7],[3,0,1,23,11,26],[3,3,2,23,28,22],[2,1,5,11,11],[2,0,4,16,26],[3,0,10,26,30,18],[3,2,5,15,19,11],[1,0,1,4],[3,0,4,2,3,30],[3,1,2,3,0,3],[2,0,3,21,30],[3,1,6,14,16,14],[1,0,7,17],[3,3,3,22,18,22],[2,1,7,17,17],[2,0,1,19,14],[1,0,1,0],[3,0,4,8,3,25],[2,0,3,5,30],[2,0,6,14,15],[1,0,10,22],[1,0,7,18],[1,0,3,5],[3,3,8,26,17,4],[3,3,0,3,9,21],[3,2,1,14,12,0],[2,0,7,29,18],[2,0,3,6,8],[1,1,8,3],[3,1,9,17,12,14],[2,0,3,22,6],[2,0,8,29,9],[3,3,9,16,26,13],[1,1,0,12],[2,1,7,27,14],[2,0,6,22,19],[1,0,0,0],[2,1,5,18,22],[3,1,9,28,24,23],[3,0,1,4,15,29],[1,0,3,20],[3,0,1,30,21,30],[2,0,9,19,7],[1,0,9,10],[1,0,0,1],[2,1,3,6,6],[3,1,0,11,28,27],[2,0,4,25,8],[1,0,6,15],[3,3,9,12,23,26],[2,1,5,12,12],[3,1,9,28,3,28],[3,1,6,20,14,15],[1,0,10,30],[1,1,9,9],[2,0,9,3,10],[2,0,10,26,26],[2,1,9,23,23],[3,0,2,6,3,22],[1,1,0,27],[3,0,9,23,23,24],[1,1,7,2],[2,1,0,10,3],[1,0,4,1],[1,0,7,12],[3,0,9,23,15,8],[1,0,10,27],[3,0,0,30,30,30],[3,0,3,19,2,14],[3,1,3,6,21,5],[3,0,3,11,16,11],[1,1,8,3],[2,0,10,26,19],[1,0,7,18]]
 count = 0
 for line in data[1:]:
 	count += 1
 	supps = line[1]
 	score = line[2]
 	maxes = 0
 	nonsuptot = (score*3)-2
 	suptot = (score*3)-4
 	if suptot < 0:
 		suptot = 1
 	for i in range(3,(len(line))):
 		if line[i] >= nonsuptot:
 			maxes += 1
 			continue
 		if (line[i] >= suptot) and (supps > 0):
 			maxes += 1
 			supps -= 1
 	if score == 0:
 		maxes = line[0]
 	print (""Case #""+str(count)+"":"", maxes)
 		
 			
 
 
 
 
",30,341,1454
"#!/usr/bin/python
 
 
 def normal(ken, nao):
     total = 0
     k = ken[:]
     for i in nao[::-1]:
         if i > ken[-1]:
             k = k[1:]
         else:
             for e in range(len(k)):
                 if k[e] > i:
                     del k[e]
                     total += 1
                     break
     return total
 
 def deceit(ken, nao):
     k = ken[:]
     n = nao[:]
     while(len(n) > 0 and len(n) > 0 and (n[0] < k[0] or n[-1] < k[-1])):
             n = n[1:]
             k = k[:-1]
     return len(n)
     # total = 0
     # for i in k[::-1]:
     #     if n[-1] < i:
     #         n = n[1:]
     #     else:
     #         for e in range(len(n)):
     #             if n[e] > i:
     #                 del n[e]
     #                 total += 1
     #                 break
     # return total
 
 
     
 
 
 
 def main():
     # filename = ""D-small-attempt0.in""
     filename = ""D-small-attempt1.in""
     # filename = ""D-large.in""
     # filename = ""sample.in""
 
     inp = open(filename, ""rU"")
 
     n = int(inp.readline().strip())
 
     for case in range(1, n + 1):
         count = int(inp.readline().strip())
         nao = sorted(map(float, inp.readline().strip().split()))
         ken = sorted(map(float, inp.readline().strip().split()))
 
         war = count - normal(ken, nao)
         dwar = normal(nao, ken)
 
         print(""Case #{}: {} {}"".format(case, dwar, war))
         # print(count)
         # print(nao)
         # print(ken)
         # print(list(map((lambda x: x[0] > x[1]), zip(nao,ken))))
         # print()
 
 main()",30,342,584
"def ispal(num):
     num = str(num)
     if num == num[::-1]:
         return True
     else:
         return False
 
 def test(bot, top):
     count = []
     for i in range(bot,top+1):
         if not ((int(i**0.5)**2) == i):
             continue
         if ispal(i) and ispal(int(i**0.5)):
             count.append(i)
     return len(count)
 
 case = 1
 for line in open('C-small-attempt2.in', 'Ur'):
     if ' ' in line:
         a,b = line.split()
         res = test(int(a),int(b))
         print(""Case #{0}: {1}"".format(case, res))
         case += 1
 
 
",30,343,210
"mapp = {' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm','q':'z','z':'q'}
 input = open(""A-small-attempt0.in"", ""rU"").readlines()
 counter = 0
 for a in input[1:]:
 	counter += 1
 	outline = a.replace(""\n"",'')
 	outline2 = []
 	for i in outline:
 		outline2.append(mapp[i])
 	print (""Case #""+str(counter)+"":"",''.join(outline2))
 
",30,344,273
"#!/usr/bin/python
 
 #!/usr/bin/python
 
 filename = ""B-small-attempt0.in""
 # filename = ""sample.in""
 
 inp = open(filename, ""rU"")
 
 n = int(inp.readline().strip())
 
 for case in range(1, n + 1):
     cost, freq, goal = map(float, inp.readline().strip().split("" ""))
     fac = 0.0
     time = 0.0
     test = lambda x: (goal/(2+(freq * (x + 1)))) + (cost /(2+(freq * x)))
     test2 = lambda x: (goal/(2+(freq * x)))
     while(test2(fac) > test(fac)):
         # print(time)
         time += cost/(2 + (freq *  fac))
         fac += 1
     time += goal/(2+(freq*fac))
     print(""Case #{}: {}"".format(case, time))
",30,345,247
"#! /usr/bin/python3
 ncases = int(input())
 
 for n in range(1, ncases+1):
     row = int(input())
     for m in range(1, 5):
         if m == row:
             r1list = [int(x) for x in input().split()]
             assert len(r1list) == 4
         else:
             tmp = input()
     row = int(input())
     for m in range(1,5):
         if m == row:
             r2list = [int(x) for x in input().split()]
             assert len(r1list) == 4
         else:
             tmp = input()
     nset = set(r1list) & set(r2list)
     if len(nset) == 1:
         print(""Case #%d:"" % n, nset.pop())
     elif len(nset) > 1:
         print(""Case #%d:"" % n, ""Bad magician!"")
     else:
         print(""Case #%d:"" % n, ""Volunteer cheated!"")
",31,346,269
"#! /usr/bin/python
 
 T=input()
 
 for i in range(1, T+1):
     N, M = raw_input().split()
     N, M = int(N), int(M)
     matrix = []
     for j in range(N):
         row = raw_input().split()
         assert len(row) == M
         row = [int(x) for x in row]
         matrix.append(row)
     rmax = [max(x) for x in matrix]
     matrix_t = [list(x) for x in zip(*matrix)]
     cmax = [max(x) for x in matrix_t]
     feasible = True
     for r, k in zip(matrix, range(N)):
         for c, l in zip(r, range(M)):
             if c == rmax[k]:
                 continue
             elif c == cmax[l]:
                 continue
             else:
                 break
         else:
             continue
         break
     else:
         print ""Case #%d: %s"" % (i, ""YES"")
         continue
     print ""Case #%d: %s"" % (i, ""NO"")
",31,347,285
"#!/usr/bin/env python
 
 (index,num,numB):
 	n=int(str(num)[index:]+str(num)[:index])
 	if n > num and n <= numB:
 		#print ""pair"",num, n
 		return n
 	else: return False
 
 
 for line in fileinput.input():
 	if fileinput.isfirstline():
 		T=int(line) # no. of test cases
 		continue
 	numStrs=line.split()
 	numSize=len(numStrs[0])
 	numA=int(numStrs[0])
 	numB=int(numStrs[1])
 	count=0
 	for num in xrange(numA, numB+1):
 		pairs=set()
 		for i in range(numSize):
 			n=checkIndex(i,num, numB)
 			if n:
 				pairs.add(n)
 		count +=len(pairs)
 				
 	print ""Case #%(k)i: %(count)i"" % {""k"":fileinput.lineno()-1,""count"":count}
 	",31,348,313
"#! /usr/bin/python
 =input()
 for i in range(1, T+1):
     game = []
     res = """"
     unfinished = False
     for j in range(4):
         game.append(raw_input())
     diag1=""""
     diag2=""""
     for (j, line) in zip(range(4), game):
         if re.match(""(X|T){4}|(O|T){4}"", line):
             res = line[0] if line[0] != 'T' else line[1]
             break
         else:
             if ""."" in line:
                 unfinished = True
             diag1 += line[j]
             diag2 += line[3-j]
     if not res:
         game = ["""".join(x) for x in zip(*game)]
         game.append(diag1)
         game.append(diag2)
         for line in game:
             grp = re.match(""(X|T){4}|(O|T){4}"", line)
             if grp:
                 res = line[0] if line[0] != 'T' else line[1]
                 break
 
     if res:
         print ""Case #%d: %s won"" % (i, res)
     elif unfinished:
         print ""Case #%d: Game has not completed"" % i
     else:
         print ""Case #%d: Draw"" % i
     raw_input() #empty line after each test case
",31,349,360
"#! /usr/bin/python3
 
 T = int(input())
 
 for n in range(1, T+1):
     blocks = int(input())
     naomi = [ int(float(a)*(10**5)) for a in input().split() ]
     ken = [ int(float(a)*(10**5)) for a in input().split() ]
 
     naomi.sort()
     ken.sort()
     dcwar = blocks
     war = 0
     i = 0
     j = 0
     while i<blocks and j<blocks:
         if ken[i] > naomi[j]:
             dcwar -= 1
         else:
             i += 1
         j += 1
     i = 0
     j = 0
     while i<blocks and j<blocks:
         if ken[i] < naomi[j]:
             war += 1
         else:
             j += 1
         i += 1
 
     print(""Case #%d: %d %d"" % (n, dcwar, war))
         
 
",31,350,276
"#! /usr/bin/python
 
 T = input()
 
 for n in range(1, T+1):
 
     A, B = raw_input().split()
     A, B = int(A), int(B)
 
     j = 0
     for i in range(A, B+1):
         s = str(i)
         m = int(i**.5)
         if s[-1] in [""1"", ""4"", ""5"", ""6"", ""9""] and \
                 (s == """".join(reversed(s))) and \
                 m**2 == i:
             s = str(m)
             if s == """".join(reversed(s)):
                 j += 1
 
 
     print ""Case #%d: %d"" % (n, j)
",31,351,199
"=""""""ejp mysljylc kd kxveddknmc re jsicpdrysi
 rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
 de kr kd eoya kw aej tysr re ujdr lkgc jv""""""
 
 strlist=str1.split()
 
 str2=""""""our language is impossible to understand
 there are twenty six factorial possibilities
 so it is okay if you want to just give up""""""
 
 strlist2=str2.split()
 
 mapLang={""y"":""a"",""e"":""o"",""q"":""z""}
 for x,y in zip(strlist,strlist2):
     for xi,yj in zip(x,y):
         if xi not in mapLang:
             mapLang[xi]=yj
             
 alphabet= ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
 for letter in  alphabet:
     if letter not in mapLang.keys():
         for lv in alphabet:
             if lv not in mapLang.values():
                 mapLang[letter]=lv
                 break
     
 #print ""dict size is:"", len(mapLang)
 #print mapLang
 ncases=0
 sp="" ""
 for txt in fileinput.input():
     if fileinput.isfirstline():
         ncases=int(txt)
         continue
     txtList=txt.split()
     outList=[]
     for word in txtList:
         outword=""""
         for letter in word:
             outword += mapLang[letter]
         outList.append(outword)
     outstr=sp.join(outList)
     print ""Case #%(k)i: %(str)s"" % {""k"":fileinput.lineno()-1,""str"":outstr}
",31,352,478
"#! /usr/bin/python3
 
 T = int(input())
 
 for n in range(1, T+1):
     print(""Case #%d:"" % n)
     (R, C, M) = (int(x) for x in input().split())
     dots = R*C - M
     if M == 0:
         print(""\n"".join([""c""+(C-1)*"".""] + (R-1)*[C*"".""]))
     elif dots == 0:
         print(""Impossible"")
     elif R == 1:
         assert C - M > 0
         print(""c""+(C-M-1)*"".""+M*""*"")
     elif C == 1:
         assert R - M > 0
         print(""c\n""+(R-M-1)*"".\n""+M*""*\n"", end='')
     elif dots == 1:
         print(""\n"".join([""c""+ (C-1)*""*""] + (R-1)*[C*""*""]))
     elif dots > 3:
         if (dots == 5) or (dots == 7):
             print(""Impossible"")
             continue
         if (R == 2) or (C == 2):
             if dots%2 != 0 :
                 print(""Impossible"")
                 continue
             elif R == 2:
                 l = int(dots/2)
                 print(""c""+(l-1)*"".""+(C-l)*""*"")
                 print(l*"".""+(C-l)*""*"")
                 continue
             elif C == 2:
                 l = int(dots/2)
                 print(""c."")
                 print((l-1)*""..\n"", end='')
                 print(int(M/2)*""**\n"", end='')
                 continue
         (lines, extra) = divmod(dots, C)
         temp = []
         if (lines >= 2) and (extra != 1):
             temp.append(""c""+(C-1)*""."")
             temp.extend((lines-1)*[C*"".""])
             temp.append(extra*"".""+(C-extra)*""*"")
             temp.extend((R-lines-1)*[C*""*""])
             print(""\n"".join(temp))
             continue
         elif (lines > 2) and (extra == 1):
             temp.append(""c""+(C-1)*""."")
             temp.extend((lines-2)*[C*"".""])
             temp.append((C-1)*"".""+""*"")
             temp.append(""..""+ (C-2)*""*"")
             temp.extend((R-lines-1)*[C*""*""])
             print(""\n"".join(temp))
             continue
         elif (lines == 2) and (extra == 1):
             temp.append(""c""+(C-2)*"".""+""*"")
             temp.append((C-1)*"".""+""*"")
             temp.append(3*"".""+(C-3)*""*"")
             temp.extend((R-3)*[C*""*""])
             print(""\n"".join(temp))
             continue
         elif lines < 2:
             (l, rem) = divmod(dots, 2)
             if rem == 1:
                 l -= 1
                 rem += 2
             temp.append(""c""+(l-1)*"".""+(C-l)*""*"")
             temp.append(l*"".""+(C-l)*""*"")
             temp.append(rem*"".""+(C-rem)*""*"")
             temp.extend( (R-3)*[ C*""*"" ])
             print(""\n"".join(temp))
             continue
     else:
         print(""Impossible"")
 
",31,353,900
"#! /usr/bin/python3
 
 T = int(input())
 
 for x in range(1, T+1):
     (C, F, X) = [float(y) for y in input().split()]
     totalsecs = 0
     cur_speed = 2
     while True:
         cur_time = X/cur_speed
         new_speed = cur_speed + F
         new_time = C/cur_speed + X/new_speed
         if new_time < cur_time:
             totalsecs += C/cur_speed
             cur_speed = new_speed
         else:
             totalsecs += cur_time
             break
     
     print(""Case #%d: %.7f"" % (x, totalsecs))
",31,354,186
"filename = raw_input(""Name of file: "")
 f = open(filename, ""r"")
 o = open(filename + "".out"", ""w"")
 
 
 T = int(f.readline()[:-1])
 ## Code starts here
 
 many_possible = ""Bad magician!""
 zero_possible = ""Volunteer cheated!""
 
 for t in range(1, T + 1):
     first = int(f.readline()[:-1]) - 1
     grid1 = []
     for i in range(4):
         grid1 += [f.readline()[:-1].split("" "")]
         
     second = int(f.readline()[:-1]) - 1
     grid2 = []
     for i in range(4):
         grid2 += [f.readline()[:-1].split("" "")]
 
     possible = []
     for num in grid1[first]:
         if num in grid2[second]:
             possible += [num]
 
     if len(possible) == 1:
         o.write(""Case #%d: %s\n"" %(t, possible[0]))
     elif len(possible) == 0:
         o.write(""Case #%d: %s\n"" %(t, zero_possible))
     else:
         o.write(""Case #%d: %s\n"" %(t, many_possible))
         
     
 ## code ends here
 
 o.close()
 f.close()
",32,355,358
"fileName = raw_input(""File name: "")
 f = open(fileName,""r"")
 
 
 n = int(f.readline()[:-1])
 
 def check_row(board, index):
     row = board[index]
     M = row[0]
     index = 0
     for i in range(len(row)):
         num = row[i]
         if(num > M):
             M = num
             index = i
     for i in range(len(row)):
         num = row[i]
         if(num < M):
             if not check_col(board,i,num):
                 return False
     return True
 
 
 def check_col(board,index,number):
     for i in range(len(board)):
         if board[i][index] > number:
             return False
     return True
 
 def check_all(board):
     for i in range(len(board)):
         if not check_row(board, i):
             return False
     return True    
  
 outputFileName = raw_input(""output file name: "")
 of = open(outputFileName,""w"")
 
 for i in range(n):
     board = []
     mn = f.readline()[:-1].split()
     m = int(mn[0])
     n = int(mn[1])
     for j in range(m): 
         row = f.readline()[:-1].split()
         #print row
         row_lst = []
         for s in row:
             row_lst += [int(s)]
         board += [row]
     if check_all(board):
         of.write( ""Case #%d: %s\n"" %(i+1, ""YES""))
     else:
         of.write( ""Case #%d: %s\n"" %(i+1, ""NO""))
 
 of.close()
 f.close()
 
 #print might_have_finished, boards
 
 ##for i in range(n): # print out
 ##    print ""Case #%d: %s"" %(i+1, translate(cases[i]))
     
     
 
 
     
",32,356,524
"from string import *
 
 def compute(A,B):
     start = A
 
     count = 0
 
     while start < B:
         temp = str(start)+str(start)[:len(str(start))-1]
         for i in range (len(str(start))):
             if int(temp[i:len(str(start))+i]) > start and int(temp[i:len(str(start))+i]) <= B:
                 count += 1
         
         start += 1
 
     return count
         
 fileName = raw_input(""File name: "")
 f = open(fileName,""r"")
 n = int(f.readline()[:-1])
 i=0
 for line in f:
 
     items = (line[:-1]).split()
     #items.split()
 
     A = int(items[0])
     B = int(items[1])
     print ""Case #%d: %d"" %(i+1,compute(A,B))
     i+=1
     
 f.close()
",32,357,257
"fileName = raw_input(""File name: "")
 f = open(fileName,""r"")
 
 
 n = int(f.readline()[:-1])
 boards = []
 
 def check_tuple(row):
     has_o = False
     has_x = False
     for char in row:
         if(char == "".""):
             return (False, ""Game has not completed"")
         if(char == ""x"" or char == ""X""):
             has_x = True
         if(char == ""o"" or char == ""O""):
             has_o = True
         
     if has_o and has_x:
         return (False, ""Draw"")
     if has_o:
         return (True, ""O won"")
     return (True, ""X won"")
 
 def check_rows(board):
     for row in board:
         result = check_tuple(row)
         if result[0]:
             return result
     return (False, ""Unknown result"")
 
 def check_columns(board):
     for i in range(len(board)):
         col = """"
         col += board[0][i]
         col += board[1][i]
         col += board[2][i]
         col += board[3][i]
         result = check_tuple(col)
         if result[0]:
             return result
     return (False, ""Unknown result"")
 
 def check_diagonals(board):
     main_diag = """"
     main_diag += board[0][0]
     main_diag += board[1][1]
     main_diag += board[2][2]
     main_diag += board[3][3]
     result = check_tuple(main_diag)
     if result[0]:
         return result
     
     sec_diag = """"
     sec_diag += board[0][3]
     sec_diag += board[1][2]
     sec_diag += board[2][1]
     sec_diag += board[3][0]
 
     result = check_tuple(sec_diag)
     if result[0]:
         return result
 
     return (False,""Unknown reason"")
 
     
             
     
 
 def check_board(board,might_have_finished):
     result = check_rows(board)
     if result[0]:
         return result[1]
     
     result = check_columns(board)
     if result[0]:
         return result[1]
     
     result = check_diagonals(board)
     if result[0]:
         return result[1]
 
     if(might_have_finished):
         return ""Game has not completed""
     return ""Draw""
     
     
     
     
     
 
 
 for i in range(n):
     board = []
     might_have_finished = False
     for j in range(4): 
         row = f.readline()[:-1]
         #print row
         #row_lst = [[row[0]],[row[1]],[row[2]],[row[3]]]
         if ""."" in row:
             might_have_finished = True
         board += [row]
     print ""Case #%d: %s"" %(i+1, check_board(board,might_have_finished))
     f.readline()
 
 f.close()
 #print might_have_finished, boards
 
 ##for i in range(n): # print out
 ##    print ""Case #%d: %s"" %(i+1, translate(cases[i]))
     
     
 
 
     
",32,358,888
"fileName = raw_input(""File name: "")
 
 f = open(fileName,""r"")
 
 t = int(f.readline()[:-1])
 
 tests = []
 
 for i in range (t):
     tests += [f.readline()[:-1]]
 
 f.close()
 
 
 def compute(raw):
     dataN = [] # keeps the max mark for not surprising
     dataS = [] # keeps the max marks for surprisings
     
     items = raw.split() 
     
     for i in range (int(items[0])):
         ti = int(items[3+i])
         if ti < 1:
             dataS += [0]
             dataN += [0]
         elif ti > 28:
             dataS += [10]
             dataN += [10]
         else:
             dataN += [int((ti+2)/3)] # put the values for all participants
             dataS += [int((ti+4)/3)]
         
         
 
     
     p = int(items[2])
     s = int(items[1])
     
     n_vals = dataN
     n_vals.sort()
     
 
     i=0
     minimum = 0 # how many numbers greater than p are there in ""not surprising""
     if n_vals[0] < p:
         while n_vals[-1-i] >= p:
             minimum += 1
             i += 1
     else:
         minimum = len(n_vals)
         
 
     s_vals = dataS
     s_vals.sort()
     i=0
     maximum = 0 # how many numbers greater than p are there in ""surprising""
     if s_vals[0] < p:
         while s_vals[-1-i] >= p:
             maximum += 1
             i += 1
     else:
         maximum = len(n_vals)
     
             # we can make at most (max) but can take only (min + s)
     return min(maximum, minimum+s) 
     
 
 for i in range (t):
     print ""Case #%d: %d"" %(i+1,compute(tests[i]))
 
 
     
",32,359,555
"filename = raw_input(""Name of file: "")
 infile = open(filename, ""r"")
 outfile = open(filename + "".out"", ""w"")
 
 
 T = int(infile.readline()[:-1])
 ## Code starts here
 
 def playDecWars(her, his):
     n = len(her)
     count = 0
     while n > 0:
         if her[0] < his[0]:
             del(her[0])
             del(his[-1])
         else:
             del(her[0])
             del(his[0])
             count += 1
         n -= 1
     return count
 
 def playWars(her, his):
     n = len(her)
     count = 0
     while n > 0:
         if her[0] > his[-1]:
             count += 1
             del(her[0])
             del(his[0])
         else:
             his_index = 0
             for num in his:
                 if num > her[0]:
                     break
                 his_index += 1
             del(her[0])
             del(his[his_index])
         n -= 1
     return count
 
 for t in range(1, T + 1):
     n = int(infile.readline()[:-1])
     her = infile.readline()[:-1].split("" "")
     his = infile.readline()[:-1].split("" "")
     her = [float(x) for x in her]
     his = [float(x) for x in his]
 
     her.sort()
     his.sort()
 
     d_wars = playDecWars(her[:], his[:])
     wars = playWars(her[:], his[:])
     
     outfile.write(""Case #%d: %d %d\n"" % (t, d_wars, wars))
     
         
     
 ## code ends here
 
 outfile.close()
 infile.close()
",32,360,494
"lst = [1,4,9,121,484,10201,12321,14641,40804,44944,1002001,1234321,4008004,
     100020001,102030201,104060401,121242121,123454321,125686521,400080004,
     404090404,10000200001,10221412201,12102420121,12345654321,40000800004,
     1000002000001,1002003002001,1004006004001,1020304030201,1022325232201,
     1024348434201,1210024200121,1212225222121,1214428244121,1232346432321,
     1234567654321,4000008000004,4004009004004,100000020000001,100220141022001,
     102012040210201,102234363432201,121000242000121,121242363242121,123212464212321,
     123456787654321,400000080000004]
 
 
 def solve(lo,hi):
     global lst
     count = 0
     for i in range(len(lst)):
         if (lst[i] >= lo and lst[i] <= hi ):
             count += 1
     return count
 
 fname = raw_input(""name of file: "")
 oname = raw_input(""output file name:"")
 f = open(fname,""r"")
 out = open(oname,""w"")
 n = int(f.readline()[:-1])
 case_num = 1
 for line in f:
     args = line[:-1].split()
     lo = int(args[0])
     hi = int(args[1])
     out.write(""Case #%d: %d\n"" %(case_num,solve(lo,hi)))
     case_num += 1
     
 out.close()
 f.close()
     
",32,361,771
"from string import *
 dictionary = {
     ""a"":""y"",
     ""b"":""h"",
     ""c"":""e"",
     ""d"":""s"",
     ""e"":""o"",
     ""f"":""c"",
     ""g"":""v"",
     ""h"":""x"",
     ""i"":""d"",
     ""j"":""u"",
     ""k"":""i"",
     ""l"":""g"",
     ""m"":""l"",
     ""n"":""b"",
     ""o"":""k"",
     ""p"":""r"",
     ""q"":""z"",
     ""r"":""t"",
     ""s"":""n"",
     ""t"":""w"",
     ""u"":""j"",
     ""v"":""p"",
     ""w"":""f"",
     ""x"":""m"",
     ""y"":""a"",
     ""z"":""q"",
     "" "":"" ""    
     }
 
 def translate(sen):
     
     new_sen = """"
 
     for char in sen: #translate each charecter
         new_sen += dictionary[char]
         
     return new_sen
 
 fileName = raw_input(""File name: "")
 f = open(fileName,""r"")
 
 n = int(f.readline()[:-1])
 cases = [] #keeps the input msgs
 
 for i in range(n):
     cases += [f.readline()[:-1]]
 
 f.close()
 
 
 for i in range(n): # print out
     print ""Case #%d: %s"" %(i+1, translate(cases[i]))
     
     
 
 
     
",32,362,381
"filename = raw_input(""Name of file: "")
 infile = open(filename, ""r"")
 outfile = open(filename + "".out"", ""w"")
 
 
 T = int(infile.readline()[:-1])
 ## Code starts here
 
 def addMinesDiagonally(r, c, m):
     field = []
     for i in range (r):
         row = []
         for j in range(c):
             row += ["".""]
         field += [row]
         
     for i in range (r + c):
         ver = min (i, r - 1)
         hor = max (0, 1 + i - r)
         while ver >= 0 and hor <= c - 1 and m > 0:
             if m == 1 and hor == c - 2 and ver == r - 2:
                 ver -= 1
                 hor += 1
             field[ver][hor] = ""*""
             ver -= 1
             hor += 1
             m -= 1
         
     return field
 
 def isPossible(field):
     if field[-1][-1] != ""."":
         return False
     up = True
     left = True
     diag = True
     if len(field) > 1 and field[-2][-1] != ""."":
             up = len(field[-1]) <= 1
     if len(field[-1]) > 1 and field[-1][-2] != ""."":
             left = len(field) <= 1
     if len(field) > 1 and len(field[-1]) > 1 and field[-2][-2] != ""."":
         diag = False
     return (up and left and diag) or \
            ((not up) and (not left) and (not diag))
     
 
 for t in range(1, T + 1):
     items = infile.readline()[:-1].split("" "")
     r = int(items[0])
     c = int(items[1])
     m = int(items[2])
     field = addMinesDiagonally(r, c, m)
     if isPossible(field):
         field[-1][-1] = ""c""
         s = """"
         for line in field:
             for cell in line:
                 s += cell
             s += ""\n""
         outfile.write(""Case #%d:\n%s\n"" %(t, s[:-1]))
     else:
         s = ""IMPOSSIBLE!!!!\n""
         for line in field:
             for cell in line:
                 s += cell
             s += ""\n""
         outfile.write(""Case #%d:\n%s\n"" %(t, s[:-1]))
         #outfile.write(""Case #%d:\n%s\n"" %(t, ""Impossible""))
     
         
     
 ## code ends here
 
 outfile.close()
 infile.close()
",32,363,710
"(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         r1 = int(inputs[0])
         cs1 = set([int(x) for x in inputs[r1].split()])
         r2 = int(inputs[5])
         cs2 = set([int(x) for x in inputs[5+r2].split()])
         r = cs1.intersection(cs2)
         cnt = len(r)
         if 1 == cnt:
             return max(r)
         elif 0 == cnt:
             return 'Volunteer cheated!'
         else:
             return 'Bad magician!'
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 10
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-small-attempt0.in'
 #     iname = 'foo'
     sample_in = '''
     3
 2
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
 3
 1 2 5 4
 3 11 6 15
 9 10 7 12
 13 14 8 16
 2
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
 2
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
 2
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
 3
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
     '''
     sample_out = '''
  Case #1: 7
 Case #2: Bad magician!
 Case #3: Volunteer cheated!
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",33,364,975
"(t, amap, bmap):
     s = 0
     for m in amap:
         if len(m) == 1 and t == m.keys()[0]:
             s += m[t]
             for b in bmap:
                 if t in b:
                     b[t] -= 1
                     if b[t] == 0:
                         b.pop(t)
             m.clear()
     return s           
 
 
 def solve(case, in_lines):
     out = 'Case #%d: '%case
  
     rn, cn = [int(x) for x in in_lines[0].split()]
     mtx = []
     for i in xrange(rn):
         mtx.append([int(x) for x in in_lines[i+1].split()])
     rmap = [{} for x in xrange(rn)]
     cmap = [{} for x in xrange(cn)]
     td = {}
     
     for i in xrange(rn):
         for j in range(cn):
             k = mtx[i][j]
             if k in rmap[i]:
                 rmap[i][k] += 1
             else:
                 rmap[i][k] = 1
             if k in cmap[j]:
                 cmap[j][k] += 1
             else:
                 cmap[j][k] = 1
             if k in td:
                 td[k] += 1
             else:
                 td[k] = 1
                 
     while len(td):
         k = min(td.keys())
         sb = ss(k, rmap, cmap)
         sb += ss(k, cmap, rmap)
         if sb == 0:
             break;
         td[k] -= sb
         if td[k] == 0:
             td.pop(k)
 
     return out + ('YES' if sb else 'NO')
 
 
 def main(raw):
     lines = raw.split('\n')
     n = int(lines[0])
     ln = 1
     outs = []
     for case in xrange(1, n+1):
         buff = []
         cl = int(lines[ln].split()[0]) + ln + 1
         while ln < cl and lines[ln]:
             buff.append(lines[ln])
             ln += 1
         s = solve(case, buff)
         print s
         outs.append(s)
     return '\n'.join(outs)
     pass
 
 if __name__ == '__main__':
     test_input = """"""4
 4 3
 2 5 2
 1 1 1
 2 4 2
 2 3 2
 3 3
 2 1 2
 1 1 1
 2 1 2
 5 5
 2 2 2 2 2
 2 1 1 1 2
 2 1 2 1 2
 2 1 1 1 2
 2 2 2 2 2
 1 3
 1 2 1""""""
     force_no_file = False
     in_file_name = '' if force_no_file else 'B-small-attempt0.in'
     base_path = 'G:/workspace/py/codejam2013/RQ/'
     if in_file_name:
         with open(base_path + in_file_name) as f:
             raw = f.read()
     else:
         raw = test_input
     out = main(raw)
     if in_file_name:
         with open(base_path + in_file_name + '.out', 'w') as f:
             f.write(out)
     pass",33,365,938
"#! /usr/bin/env python
 #coding=utf-8
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     result = 0
     raw = case_input[0].split()
     n = len(raw[0])
     a = int(raw[0])
     b = int(raw[1])
     
     for i in xrange(a, b):
         rslt = set()
         for t in xrange(1, n):
             tt = 10**t
             tn = 10**(n-t)
             ia, ib = divmod(i, tt)
             ii = ib*tn + ia
             if ii > i and ii <= b:
                 rslt.add(ii)
         result += len(rslt)
         
 
     case_output += '%d'%result
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""5
 1 9
 10 40
 100 500
 1111 2222
 1000000 2000000
 """"""
     use_test_data = False
     
     test_file = 'C-small-attempt0.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",33,366,615
"= [0xf, 0xf0, 0xf00, 0xf000, 0x8888, 0x4444, 0x2222, 0x1111, 0x8421, 0x1248]
 
 def solve(case, in_lines):
     out = 'Case #%d: '%case
     s = ''.join(in_lines)
     x = 0
     o = 0
     nc = False
     for i in xrange(16):
         m = 1 << i
         c = s[i]
         if c == 'X':
             x |= m
         elif c == 'O':
             o |= m
         elif c == 'T':
             x |= m
             o |= m
         else:
             nc = True
     r = ''
     for m in mm:
         if m & x == m:
             r = 'X won'
             break
         if m & o == m:
             r = 'O won'
             break
     if not r:
         if nc:
             r = 'Game has not completed'
         else:
             r = 'Draw'
     
     return out + r
 
 
 def main(raw):
     lines = raw.split('\n')
     n = int(lines[0])
     ln = 0
     outs = []
     for case in xrange(1, n+1):
         buff = []
         ln += 1
         while ln < len(lines) and lines[ln]:
             buff.append(lines[ln])
             ln += 1
         s = solve(case, buff)
         print s
         outs.append(s)
     return '\n'.join(outs)
     pass
 
 if __name__ == '__main__':
     test_input = """"""6
 XXXT
 ....
 OO..
 ....
 
 XOXT
 XXOO
 OXOX
 XXOO
 
 XOX.
 OX..
 ....
 ....
 
 OOXX
 OXXX
 OX.T
 O..O
 
 XXXO
 ..O.
 .O..
 T...
 
 OXXX
 XO..
 ..O.
 ...O""""""
     force_no_file = False
     in_file_name = '' if force_no_file else 'A-small-attempt0.in'
     base_path = 'G:/workspace/py/codejam2013/RQ/'
     if in_file_name:
         with open(base_path + in_file_name) as f:
             raw = f.read()
     else:
         raw = test_input
     out = main(raw)
     if in_file_name:
         with open(base_path + in_file_name + '.out', 'w') as f:
             f.write(out)
     pass",33,367,717
"#! /usr/bin/env python
 #coding=utf-8
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     result = 0
     raw = [int(x) for x in case_input[0].split()]
     ts = raw[3:]
     ct = raw[1]
     n = raw[2]
     cc = 0
     for i in ts:
         if i > 3*n-3:
             result += 1
         elif i > max(3*n-5, 0):
             cc += 1
     result += min(cc, ct)
 
     case_output += '%d'%result
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""4
 3 1 5 15 13 11
 3 0 8 23 22 21
 2 1 1 8 0
 6 2 8 29 20 8 18 18 21
 """"""
     use_test_data = False
     
     test_file = 'B-small-attempt0.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",33,368,587
"(t, amap, bmap):
     s = 0
     for m in amap:
         if len(m) == 1 and t == m.keys()[0]:
             s += m[t]
             for b in bmap:
                 if t in b:
                     b[t] -= 1
                     if b[t] == 0:
                         b.pop(t)
             m.clear()
     return s           
 
 
 def solve(case, in_lines):
     out = 'Case #%d: '%case
  
     rn, cn = [int(x) for x in in_lines[0].split()]
     mtx = []
     for i in xrange(rn):
         mtx.append([int(x) for x in in_lines[i+1].split()])
     rmap = [{} for x in xrange(rn)]
     cmap = [{} for x in xrange(cn)]
     td = {}
     
     for i in xrange(rn):
         for j in range(cn):
             k = mtx[i][j]
             if k in rmap[i]:
                 rmap[i][k] += 1
             else:
                 rmap[i][k] = 1
             if k in cmap[j]:
                 cmap[j][k] += 1
             else:
                 cmap[j][k] = 1
             if k in td:
                 td[k] += 1
             else:
                 td[k] = 1
                 
     while len(td):
         k = min(td.keys())
         sb = ss(k, rmap, cmap)
         sb += ss(k, cmap, rmap)
         if sb == 0:
             break;
         td[k] -= sb
         if td[k] == 0:
             td.pop(k)
 
     return out + ('YES' if sb else 'NO')
 
 
 def main(raw):
     lines = raw.split('\n')
     n = int(lines[0])
     ln = 1
     outs = []
     for case in xrange(1, n+1):
         buff = []
         cl = int(lines[ln].split()[0]) + ln + 1
         while ln < cl and lines[ln]:
             buff.append(lines[ln])
             ln += 1
         s = solve(case, buff)
         print s
         outs.append(s)
     return '\n'.join(outs)
     pass
 
 if __name__ == '__main__':
     test_input = """"""4
 4 3
 2 5 2
 1 1 1
 2 4 2
 2 3 2
 3 3
 2 1 2
 1 1 1
 2 1 2
 5 5
 2 2 2 2 2
 2 1 1 1 2
 2 1 2 1 2
 2 1 1 1 2
 2 2 2 2 2
 1 3
 1 2 1""""""
     force_no_file = False
     in_file_name = '' if force_no_file else 'B-large.in'
     base_path = 'G:/workspace/py/codejam2013/RQ/'
     if in_file_name:
         with open(base_path + in_file_name) as f:
             raw = f.read()
     else:
         raw = test_input
     out = main(raw)
     if in_file_name:
         with open(base_path + in_file_name + '.out', 'w') as f:
             f.write(out)
     pass",33,369,934
"#! /usr/bin/env python
 #coding=utf-8
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     result = """"
     for c in case_input[0]:
         if c in map:
             result += map[c]
         else:
             result += c
 
     case_output += '%s'%result
     
     return case_output
 
 
 def getmap():
     inputs = [""ejp mysljylc kd kxveddknmc re jsicpdrysi"",
               ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"",
               ""de kr kd eoya kw aej tysr re ujdr lkgc jv""]
     outputs = [""our language is impossible to understand"",
                ""there are twenty six factorial possibilities"",
                ""so it is okay if you want to just give up""]
     map = {}
     for case in xrange(3):
         for i, c in enumerate(inputs[case]):
             map[c] = outputs[case][i]
     
     map['q'] = 'z'
     map['z'] = 'q'
     
     print map
     print len(map)
     for c in ""abcdefghijklmnopqrstuvwxyz"":
         if c not in map:
             print c
     return map
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""3
 ejp mysljylc kd kxveddknmc re jsicpdrysi
 rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
 de kr kd eoya kw aej tysr re ujdr lkgc jv
     """"""
     use_test_data = False
     
     map = getmap()
     
     test_file = 'A-small-attempt2.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",33,370,764
"(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         R, C, M = [int(x) for x in inputs[0].split()]
         mp = []
         for r in range(R):
             mp.append(['.']*C)
         mp[0][0] = 'c'
         outputs = []
         if M == 0:
             for row in mp:
                 outputs.append(''.join(row))
             return outputs
         rr, cc, rm = R, C, M
         while rm >= min(rr, cc):
             if rr <= cc:
                 for r in range(rr):
                     mp[r][cc-1] = '*'
                 cc -= 1
                 rm -= rr
             else:
                 for c in range(cc):
                     mp[rr-1][c] = '*'
                 rr -= 1
                 rm -= cc
         
         if rm == 0:
             if (min(rr, cc), max(rr, cc)) == (1, 2) and min(R, C) != 1:
                 return ['Impossible']
         else:
             if min(rr, cc) - rm >= 2:
                 if rr <= cc:
                     for r in range(rr-rm, rr):
                         mp[r][cc-1] = '*'
                 else:
                     for c in range(cc-rm, cc):
                         mp[rr-1][c] = '*'
             else:
                 if min(rr, cc) >= 4:
                     if rr <= cc:
                         for r in range(2, rr):
                             mp[r][cc-1] = '*'
                         mp[rr-1][cc-2] = '*'
                     else:
                         for c in range(2, cc):
                             mp[rr-1][c] = '*'
                         mp[rr-2][cc-1]='*'
                 elif min(rr,cc) == 3:
                     if max(rr, cc) == 3:
                         return ['Impossible']
                     else:
                         if rr <= cc:
                             mp[2][cc-1] = '*'
                             mp[2][cc-2] = '*'
                         else:
                             mp[rr-1][2] = '*'
                             mp[rr-2][2] = '*'
                 else:
                     return ['Impossible']
                     
         for row in mp:
             outputs.append(''.join(row))
         return outputs
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             R, C, M = [int(x) for x in case_inputs[0].split()]
             rslt = self.solve(case_inputs)
             if self.verify(rslt, R, C, M):
                 outputs.append(rslt)
             else:
                 raise 'Failed'
         return outputs
     
     def verify(self, outputs, RR, CC, MCNT):
         if 'Impossible' == outputs[0]:
             return True
         rr = len(outputs)
         cc = len(outputs[0])
         if RR != rr or CC != cc:
             return False
         bd = []
         mask = []
         for i in range(rr):
             mask.append([1]*cc)
             bd.append([0]*cc)
             for j in range(cc):
                 if outputs[i][j] == '*':
                     bd[i][j] = 9
                 elif outputs[i][j] == 'c':
                     start = (i, j)
         for r in range(rr):
             for c in range(cc):
                 if bd[r][c] == 9:
                     for i in [r-1,r,r+1]:
                         for j in [c-1,c,c+1]:
                             if 0 <= i < rr and 0 <= j < cc:
                                 if bd[i][j] != 9:
                                     bd[i][j] += 1
 #         for i, row in enumerate(bd):
 #             print i, row
 
         nlist = [start]
         while len(nlist):
             i, j = nlist.pop(0)
             if mask[i][j] != 0:
                 mask[i][j] = 0
                 if bd[i][j] == 9:
                     raise '!!! BOMB'
                 elif bd[i][j] == 0:
                     for ii in [i-1,i,i+1]:
                         for jj in [j-1,j,j+1]:
                             if 0<=ii<rr and 0<=jj<cc:
                                 if ii != i or jj != j:
                                     nlist.append((ii,jj))
         mcnt = 0
         for r in range(rr):
 #             print mask[r]
             for c in range(cc):
                 if mask[r][c] == 1:
                     mcnt += 1
                 if mask[r][c] == 1 and bd[r][c] != 9:
                     return False
                 if mask[r][c] != 1 and bd[r][c] == 9:
                     return False
         return (mcnt == MCNT)
                 
 
 if __name__ == '__main__':
     iname = 'C-small-attempt0.in'
 #     iname = 'foo'
     sample_in = '''
 7
 5 5 23
 3 1 1
 2 2 1
 4 7 3
 10 10 82
 3 4 0
 2 2 3
     '''
     sample_out = '''
 Case #1: 1.0000000
 Case #2: 39.1666667
 Case #3: 63.9680013
 Case #4: 526.1904762
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d:'%(i+1)
                 print >> f, '\n'.join(v)
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d:'%(i+1)
         print '\n'.join(v)
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",33,371,1847
"(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         c, f, x = [float(t) for t in inputs[0].split()]
         if x <= c:
             return '%.7f'%(x/2)
         ii = int(math.ceil((f*x-2*c)/(f*c)-1))
         if ii <= 0:
             return '%.7f'%(x/2)
         t = 0
         for i in range(ii):
             t += c/(2+i*f)
         t += x/(2+ii*f)
         return '%.7f'%t
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'B-small-attempt0.in'
 #     iname = 'foo'
     sample_in = '''
     4
 30.0 1.0 2.0
 30.0 2.0 100.0
 30.50000 3.14159 1999.19990
 500.0 4.0 2000.0
     '''
     sample_out = '''
 Case #1: 1.0000000
 Case #2: 39.1666667
 Case #3: 63.9680013
 Case #4: 526.1904762
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",33,372,812
"():
     cases = int(sys.stdin.readline())
 
     for case in range(cases):
         row1 = int(sys.stdin.readline())
         arrangement1 = [
             map(int, sys.stdin.readline().split())
             for _ in range(4)
         ]
         chosen1 = set(arrangement1[row1 - 1])
 
         row2 = int(sys.stdin.readline())
         arrangement2 = [
             map(int, sys.stdin.readline().split())
             for _ in range(4)
         ]
         chosen2 = set(arrangement2[row2 - 1])
 
         chosen = chosen1 & chosen2
 
         if not chosen:
             print 'Case #%d: Volunteer cheated!' % (case + 1)
         elif len(chosen) != 1:
             print 'Case #%d: Bad magician!' % (case + 1)
         else:
             print 'Case #%d: %d' % (case + 1, chosen.pop())
 
 if __name__ == '__main__':
     main()
",34,373,281
"(A, B):
     count = 0
     l = len(str(A))
     for i in range(A, B + 1):
         variants = []
         for d in range(1, l):
             fixed = str(i)[:d]
             moving = str(i)[-(l - d):]
             j = int(moving + fixed)
             if j != i and len(str(i)) == len(str(j)) and j in range(A, B + 1) and j not in variants:
                 variants.append(j)
                 #print '%s -> %s' % (fixed + moving, moving + fixed)
                 count = count + 1
     return count / 2
 
 
 def find_recycled_pairs_efficient(A, B):
     count = 0
     sa = str(A)
     sb = str(B)
     l = len(sa)
     for fixed in range(1, l):
         moving = l - fixed
         x = int(sa[:fixed])
         y = int(sb[:fixed])
         m = int(sa[-fixed:])
         n = int(sb[-fixed:])
         j = int(sa[:moving])
         k = int(sb[:moving])
         print '%i fixed: x = %i, m = %i, n = %i, y = %i, j = %i, k = %i' % (fixed, x, m, n, y, j, k)
 
         if int(str(y) + str(k)) >= B:
             k1 = int(sb[-moving:])
             print 'k1 - j = %i - %i' % (k1, j)
             if k1 > j:
                 count = count + (k1 - j)
         if int(str(x) + str(j)) <= A:
             j1 = int(sa[-moving:])
             print 'k - j1 = %i - %i' % (k, j1)
             if k > j1:
                 count = count + (k - j1)
 
         if len(str(k)) >= len(str(x)):
             count = count + (y - x) * (k - j)
         else:
             count = count + (y - x - 1) * (k - j + 1)
 
         if x < m:
             count = count - (m - x - 1)
         if y > n:
             count = count - (y - n - 1)
 
     return count / 2
 
 def main():
 
     case_count = int(sys.stdin.readline())
 
     for case_index in range(1, case_count + 1):
         (A, B) = sys.stdin.readline().strip().split(' ')
         A = int(A)
         B = int(B)
         assert len(str(A)) == len(str(B))
         print 'Case #%i: %s' % (case_index, find_recycled_pairs(A, B))
 
 if __name__ == '__main__':
     main()",34,374,760
"():
     empty = 0
     board = [['.', '.', '.', '.'] for i in range(4)]
     for r in range(4):
         row = sys.stdin.readline()
         for c in range(4):
             board[r][c] = row[c]
             if row[c] == '.': empty = empty + 1
     sys.stdin.readline()
 
     # print board
 
     # check rows
     for r in range(4):
         x = 0
         o = 0
         for c in range(4):
             if board[r][c] == 'X':
                 x = x + 1
             if board[r][c] == 'O':
                 o = o + 1
             if board[r][c] == 'T':
                 x = x + 1
                 o = o + 1
         if x == 4: return ""X won""
         if o == 4: return ""O won""
 
     for c in range(4):
         x = 0
         o = 0
         for r in range(4):
             if board[r][c] == 'X':
                 x = x + 1
             if board[r][c] == 'O':
                 o = o + 1
             if board[r][c] == 'T':
                 x = x + 1
                 o = o + 1
         if x == 4: return ""X won""
         if o == 4: return ""O won""
 
     x = 0
     o = 0
     for c in range(4):
         r = c
         if board[r][c] == 'X':
             x = x + 1
         if board[r][c] == 'O':
             o = o + 1
         if board[r][c] == 'T':
             x = x + 1
             o = o + 1
 
     if x == 4: return ""X won""
     if o == 4: return ""O won""
 
     x = 0
     o = 0
     for c in range(4):
         r = 3 - c
         if board[r][c] == 'X':
             x = x + 1
         if board[r][c] == 'O':
             o = o + 1
         if board[r][c] == 'T':
             x = x + 1
             o = o + 1
 
     if x == 4: return ""X won""
     if o == 4: return ""O won""
 
     if empty == 0: return ""Draw""
 
     return ""Game has not completed""
 
         
 
 def main():
 
     count = int(sys.stdin.readline())
     for index in range(count):
         result = process()
         print ""Case #%d: %s"" % (index + 1, result)
 
 if __name__ == '__main__':
     main()
",34,375,730
"(scores_sum):
     if scores_sum % 3 == 1:
         max_score = (scores_sum + 2) / 3
         return (max_score, max_score)
     if scores_sum % 3 == 2:
         max_score = (scores_sum + 1) / 3
         return (max_score, max_score + 1)
     max_score = scores_sum / 3
     if max_score == 0:
         return (0, 0)
     return (max_score, max_score + 1)
 
 def find_max_dancers(s, p, *scores_sums):
     dancers_count = 0
     for scores_sum in scores_sums:
         (normal_max, surprise_max) = calculate_max_score(scores_sum)
         if normal_max >= p:
             dancers_count = dancers_count + 1
             continue
         if surprise_max >= p and s > 0:
             s = s - 1
             dancers_count = dancers_count + 1
             continue
     return dancers_count
 
 def main():
 
     case_count = int(sys.stdin.readline())
 
     for case_index in range(1, case_count + 1):
         line = sys.stdin.readline().strip().split(' ')
         s = int(line[1])
         p = int(line[2])
         scores_sums = [int(scores_sum) for scores_sum in line[3:]]
         print 'Case #%i: %s' % (case_index, find_max_dancers(s, p, *scores_sums))
 
 if __name__ == '__main__':
     main()",34,376,446
"(ken_blocks, naomi_block):
     """"""
     Since ken do not know Naomi's blocks weights
     Best strategy will be spent the smallest block to beat Naomi
     """"""
 
     for block in ken_blocks:
         if block > naomi_block:
             ken_blocks = ken_blocks[:]
             ken_blocks.remove(block)
             return True, ken_blocks
 
     ken_blocks = ken_blocks[1:]
     return False, ken_blocks
 
 def naomi(naomi_blocks):
     naomi_block = naomi_blocks[0]
     naomi_blocks = naomi_blocks[1:]
     return naomi_block, naomi_blocks
 
 def play(naomi_blocks, ken_blocks):
     naomi_points = 0
     ken_points = 0
 
     naomi_blocks.sort()
     ken_blocks.sort()
 
     while naomi_blocks and ken_blocks:
         naomi_block, naomi_blocks = naomi(naomi_blocks)
         ken_wins, ken_blocks = ken(ken_blocks, naomi_block)
         if ken_wins:
             ken_points += 1
         else:
             naomi_points += 1
 
     return naomi_points
 
 def naomi2(naomi_blocks, ken_blocks):
     target = ken_blocks[0]
     for block in naomi_blocks:
         if block > target:
             naomi_blocks = naomi_blocks[:]
             naomi_blocks.remove(block)
             return ken_blocks[-1] + 0.0000001, naomi_blocks
     return naomi_blocks[0], naomi_blocks[1:]
 
 def cheat(naomi_blocks, ken_blocks):
     naomi_points = 0
     ken_points = 0
 
     naomi_blocks.sort()
     ken_blocks.sort()
 
     while naomi_blocks and ken_blocks:
         naomi_block, naomi_blocks = naomi2(naomi_blocks, ken_blocks)
         ken_wins, ken_blocks = ken(ken_blocks, naomi_block)
         if ken_wins:
             ken_points += 1
         else:
             naomi_points += 1
     return naomi_points
 
 def main():
     cases = int(sys.stdin.readline())
 
     for case in range(cases):
         N = int(sys.stdin.readline())
         naomi_blocks = map(float, sys.stdin.readline().split())
         ken_blocks = map(float, sys.stdin.readline().split())
         assert len(naomi_blocks) is N
         assert len(ken_blocks) is N
 
         normal_war = play(naomi_blocks, ken_blocks)
         cheat_war = cheat(naomi_blocks, ken_blocks)
         print 'Case #%d: %d %d' % (case + 1, cheat_war, normal_war)
 
 if __name__ == '__main__':
     main()
",34,377,854
"(n):
     n = str(n)
     for i in range(long(len(n) / 2)):
         if n[i] != n[len(n) - i - 1]:
             return False
     return True
 
 def is_square_and_fair(n):
     if not is_fair(n): return False
     root = math.sqrt(n)
     if root != math.floor(root): return False
     if not is_fair(long(root)): return False
     return True
 
 def process():
     a, b = sys.stdin.readline().split()
     a = long(a)
     b = long(b)
     
     count = 0
     for i in range(a, b + 1):
         if is_square_and_fair(i): count = count + 1
 
     return count
 
 def main():
 
     count = int(sys.stdin.readline())
     for index in range(count):
         result = process()
         print ""Case #%d: %s"" % (index + 1, result)
 
 if __name__ == '__main__':
     main()
",34,378,288
"= dict()
 
 def learn(encrypted_text, clear_text):
     for encrypted_letter, clear_letter in zip(encrypted_text, clear_text):
         if encrypted_letter in cipher:
             assert cipher[encrypted_letter] == clear_letter
         cipher[encrypted_letter] = clear_letter
 
 def test():
     alphabet = 'abcdefghijklmnopqrstuvwxyz '
     for letter in alphabet:
         if letter not in cipher.keys():
             print 'Googlerese letter %s does not have corresponding English letter.' % letter
         if letter not in cipher.values():
             print 'English letter %s not found in cipher dictionary values.' % letter
     if len(cipher.keys()) != len(alphabet):
         print 'Size of cipher dictionary and alphabet mismatch.'
 
 def decrypt(text):
     decrypted_text = ''
     for letter in text:
         assert letter in cipher
         decrypted_text += cipher[letter]
     return decrypted_text
 
 def main():
     learn(' yeqz', ' aozq')
     learn('ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand')
     learn('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities')
     learn('de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up')
     test()
 
     case_count = int(sys.stdin.readline())
 
     for case_index in range(1, case_count + 1):
         print 'Case #%i: %s' % (case_index, decrypt(sys.stdin.readline().strip()))
 
 if __name__ == '__main__':
     main()",34,379,470
"= [
     (-1, -1), (-1, 0), (-1, 1),
     ( 0, -1),          ( 0, 1),
     ( 1, -1), ( 1, 0), ( 1, 1),
 ]
 
 MOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]
 
 def valid(size, location, changes):
     y, x = location
     for y1, x1 in changes:
         y1 += y
         x1 += x
         if y1 < 0 or y1 >= size[0]:
             continue
         if x1 < 0 or x1 >= size[1]:
             continue
         yield (y1, x1)
 
 def click(size, grid, location):
     y, x = location
     if grid[y][x] is 0:
         return None
 
     grid = [row[:] for row in grid]
     grid[y][x] = 0
 
     for y, x in valid(size, location, NEIGHBOURS):
         if grid[y][x]:
             grid[y][x] = False
 
     return grid
 
 def sweep(R, C, M):
     # create initial grid
     grid = [[True] * C for _ in range(R)]
     size = (R, C)
 
     if M + 1 == R * C:
         grid[0][0] = False
         return grid, (0, 0)
 
     # start by click top left
     states = []
     for y in range(R):
         for x in range(C):
             location = (y, x)
             states.append((click(size, grid, location), location))
 
     while states:
         grid, location = states.pop(0)
 
         mines_count = sum([sum(row) for row in grid])
         if mines_count == M:
             return grid, location
 
         if mines_count < M:
             continue
 
         for new_location in valid(size, location, NEIGHBOURS):
             new_grid = click(size, grid, new_location)
             if new_grid:
                 states.insert(0, (new_grid, new_location))
 
     return None
 
 def validate(size, grid, location):
 
     result = [row[:] for row in grid]
 
     y, x = location
     result[y][x] = sum([
         grid[y1][x1]
         for y1, x1 in valid(size, (y, x), NEIGHBOURS)
     ])
     assert result[y][x] == 0
 
     seen = set([location])
     locations = set([location])
 
     while locations:
         location = locations.pop()
         for y, x in valid(size, location, NEIGHBOURS):
             assert grid[y][x] is not True
             result[y][x] = sum([
                 grid[y1][x1]
                 for y1, x1 in valid(size, (y, x), NEIGHBOURS)
             ])
             if result[y][x] == 0 and (y, x) not in seen:
                 locations.add((y, x))
                 seen.add((y, x))
 
     for row in result:
         for col in row:
             assert col is not False
     #print result
 
     for y, row in enumerate(result):
         output = ''
         for x, col in enumerate(row):
             if col is True:
                 output += '*'
             else:
                 output += str(col)
         print output
 
 
 def process(case, R, C, M):
     result = sweep(R, C, M)
 
     print 'Case #%d:' % (case + 1)
     #print R, C, M
     if not result:
         #print R, C, M
         print 'Impossible'
         return
 
     grid, location = result
     for y, row in enumerate(grid):
         output = ''
         for x, col in enumerate(row):
             if (y, x) == location:
                 output += 'c'
             elif col:
                 output += '*'
             #elif col is 0:
             #    output += '0'
             else:
                 output += '.'
         print output
 
     #validate((R, C), grid, location)
 
 
 def main():
     #for R in range(1, 6):
     #    for C in range(1, 6):
     #        for M in range(R * C):
     #            process(0, R, C, M)
     #return
     #for M in range(1, 25):
     #    process(M - 1, 5, 5, M)
     #return
     cases = int(sys.stdin.readline())
 
     for case in range(cases):
         R, C, M = map(int, sys.stdin.readline().split())
         process(case, R, C, M)
 
     return
     for case in range(100):
         R = random.randrange(51) + 1
         C = random.randrange(51) + 1
         M = random.randrange(R * C - 1) + 1
         process(case * 100000 + M - 1, R, C, M)
 
 
 if __name__ == '__main__':
     main()
",34,380,1373
"(C, F, X):
     states = Queue.PriorityQueue()
 
     # (time, rate, is_done)
     states.put((0.0, 2.0, False))
     while not states.empty():
         time, rate, is_done = states.get()
 
         # done
         if is_done:
             return time
 
         # two ways to move forward
         # 1. wait
         states.put((
             time + X / rate,
             rate,
             True
         ))
 
         # 2. wait for a farm
         states.put((
             time + C / rate,
             rate + F,
             False
         ))
 
     return None
 
 def main():
     cases = int(sys.stdin.readline())
 
     for case in range(cases):
         C, F, X = map(float, sys.stdin.readline().split())
         print 'Case #%d: %.7f' % (case + 1, click(C, F, X))
 
 if __name__ == '__main__':
     main()
",34,381,272
"# Written for Python 2.7.5
 
 # Expected format of TEST_CASES is a list of tuples of (input, expected_output)
 TEST_CASES = [
     (""""""3
 2
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
 3
 1 2 5 4
 3 11 6 15
 9 10 7 12
 13 14 8 16
 2
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
 2
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
 2
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
 3
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
 """""",""""""Case #1: 7
 Case #2: Bad magician!
 Case #3: Volunteer cheated!
 """"""),
     (""""""1
 1
 15 9 16 5
 6 10 1 3
 2 4 12 11
 13 14 8 7
 1
 5 10 9 6
 12 15 1 11
 14 16 4 2
 13 3 8 7"""""",""""""Case #1: Bad magician!
 """""")
 ]
 
 BAD_MAGIC = ""Bad magician!""
 CHEATING = ""Volunteer cheated!""
 
 def parse_input(input_reader):
     case_count = int(input_reader.readline())
     case_idx = 0
     while case_count > case_idx:
         case_idx += 1
         rows = []
         for loop_idx in (1,2):
             row_idx = int(input_reader.readline())
             for idx in (1,2,3,4):
                 if idx == row_idx:
                     rows.append(set(input_reader.readline().rstrip(""\n"").split("" "")))
                 else:
                     input_reader.readline()
         input_values = {""rows"":rows,
                         ""case"":case_idx}
         yield input_values
 
 
 def solve_problem(output_writer=sys.stdout, **kwargs):
     rows = kwargs['rows']
     case = kwargs['case']
     intersect = rows[0].intersection(rows[1])
     if not intersect:
         msg = CHEATING
     elif len(intersect) == 1:
         msg = intersect.pop()
     else:
         msg = BAD_MAGIC
     print >>output_writer, ""Case #%d: %s"" % (case, msg)
 
 def solve_inputs(input_reader, output_writer):
     """"""
     Loop through each problem input in input reader and solve it.
 
     Outputs responses to output_writer.
     """"""
     for input_values in parse_input(input_reader):
         solve_problem(output_writer=output_writer, **input_values)
 
 def run_tests():
     """"""
     Check the sample input and output match.
     """"""
     idx = 0
     all_pass = True
     for problem_input, expected_output in TEST_CASES:
         idx += 1
         input_reader = StringIO(problem_input)
         output_writer = StringIO()
         solve_inputs(input_reader, output_writer)
         problem_output = output_writer.getvalue()
         if problem_output == expected_output:
             print ""Test %d: Success"" % idx
         else:
             all_pass = False
             print ""Test %d: Failure"" % idx
         input_reader.close()
         output_writer.close()
     if all_pass:
         print ""All tests were successful!""
     else:
         print ""Something didn't match - try again.""
         print problem_output
 
 def main():
     parser = OptionParser()
     parser.add_option(""-f"", ""--file"",
                       dest=""filename_stem"",
                       help=""read input from FILE.in and write to FILE.out"",
                       metavar=""FILE"")
 
     (options, args) = parser.parse_args()
     if options.filename_stem:
         print ""Running in file mode.""
         input_reader = open(""%s.in"" % options.filename_stem, ""r"")
         output_writer = open(""%s.out"" % options.filename_stem, ""w"")
         solve_inputs(input_reader, output_writer)
     else:
         print ""Running in test mode.""
         run_tests()
 
 if __name__ == ""__main__"":
     main()",35,382,1293
"# The largest number B can be
 MAX_NUMBER = 2000000
 
 # COUNT_MAP will store the number of recycled pairs that can exist for a
 # list of cycles of length n (these are the triangular numbers).
 # Calculate this now so that we don't waste time with it later on.
 COUNT_MAP = { 1: 0 }
 index = 1
 while index < math.log10(MAX_NUMBER):
     index += 1
     COUNT_MAP[index] = index * (index - 1) / 2
 
 def solve(minimum, maximum):
     # Store the result
     total_cycles = 0
     # The numbers we need to check.  We'll remove numbers from this once we've
     # used them in a cycle so that we don't attempt to reprocess them.
     iter_range = range(minimum, maximum + 1)
     # Keep looping untli we've gone through all the numbers.
     while iter_range:
         # Remove the first number
         number = iter_range[0]
         iter_range.remove(number)
         # Add this to the list of numbers in a potential cycle.
         cycle_numbers = [number,]
         # Using strings for this feels icky but the modulo arithmetic seems
         # equally icky :-(
         # Double up the number in a string and we'll use slices to get the
         # cycles.
         string_rep = ""%s%s"" % (number, number)
         digits = len(string_rep) / 2
         start_index, end_index = 0, digits
         while start_index < digits:
             start_index += 1
             end_index += 1
             new_number = int(string_rep[start_index:end_index])
             if new_number == number:
                 # If we're repeating then there's no need to take more slices
                 start_index = digits
             elif new_number > number and new_number <= maximum:
                 # We should already have dealt with numbers lower than this,
                 # and we don't want anything above the maximum. Anything else
                 # add to the cycle options and remove from the list of numbers
                 # to check.
                 cycle_numbers.append(new_number)
                 iter_range.remove(new_number)
         total_cycles += COUNT_MAP[len(cycle_numbers)]
     return total_cycles
 
 def parse_case(data_line):
     bits = data_line.split()
     minimum = int(bits[0])
     maximum = int(bits[1])
     return (minimum, maximum, )
 
 def main():
     parser = OptionParser()
     parser.add_option(""-f"", ""--file"", dest=""filename"",
                       help=""read input from FILE"", metavar=""FILE"")
 
     (options, args) = parser.parse_args()
     if not options.filename:
         parser.error(""Must provide a filename."")
     input_file = open(options.filename, ""r"")
     total_cases = int(input_file.readline())
     case_number = 0
     while case_number < total_cases:
     	case_number += 1
     	data_args = parse_case(input_file.readline())
     	print ""Case #%d: %s"" % (case_number, solve(*data_args))
 
 if __name__ == ""__main__"":
     main()",35,383,837
"(data):
     GAME_INCOMPLETE = 0
     GAME_DRAWN = 1
     GAME_WON = 2
     winner = None
     state = GAME_DRAWN
     for row in data:
         if ""."" in row:
             state = GAME_INCOMPLETE
         elif ""X"" not in row:
             winner = ""O""
             state = GAME_WON
             break
         elif ""O"" not in row:
             winner = ""X""
             state = GAME_WON
             break
     if state == GAME_WON:
         return ""%s won"" % winner
     elif state == GAME_INCOMPLETE:
         return ""Game has not completed""
     else:
         return ""Draw""
 
 def parse_case(data):
     data_line = """".join(data)
     rows = []
     for idx in range(4):
         offset = idx * 4
         # Pull rows
         rows.append(data_line[offset:offset+4])
         # Pull columns
         rows.append(data_line[idx::4])
     # Pull diagonals
     rows.append(data_line[0::5])
     rows.append(data_line[3:-1:3])
     return (rows, )
 
 def main():
     parser = OptionParser()
     parser.add_option(""-f"", ""--file"", dest=""filename"",
                       help=""read input from FILE"", metavar=""FILE"")
 
     (options, args) = parser.parse_args()
     if not options.filename:
         parser.error(""Must provide a filename."")
     input_file = open(options.filename, ""r"")
     total_cases = int(input_file.readline())
     case_number = 0
     while case_number < total_cases:
         case_number += 1
         data = []
         for idx in range(4):
             data.append(input_file.readline()[:4])
         input_file.readline()
         data_args = parse_case(data)
         print ""Case #%d: %s"" % (case_number, solve(*data_args))
 
 if __name__ == ""__main__"":
     main()",35,384,548
"(N,S,p,t):
     # Easy pickings, if p is 0 then all must win.
     if p == 0:
         return N
     outright_wins = 0
     potential_surprises = 0
     win_cutoff = (p * 3) - 3
     surprise_cutoff = win_cutoff - 2
     for score in t:
         if score == 0:
             continue
         elif score > win_cutoff:
             outright_wins += 1
         elif score > surprise_cutoff:
             potential_surprises += 1
     if potential_surprises < S:
         return outright_wins + potential_surprises
     else:
         return outright_wins + S
 
 def parse_case(data_line):
     bits = data_line.split()
     N = int(bits[0])
     S = int(bits[1])
     p = int(bits[2])
     t = [int(x) for x in bits[3:]]
     return N,S,p,t
 
 def main():
     parser = OptionParser()
     parser.add_option(""-f"", ""--file"", dest=""filename"",
                       help=""read input from FILE"", metavar=""FILE"")
 
     (options, args) = parser.parse_args()
     if not options.filename:
         parser.error(""Must provide a filename."")
     input_file = open(options.filename, ""r"")
     total_cases = int(input_file.readline())
     case_number = 0
     while case_number < total_cases:
     	case_number += 1
     	data_args = parse_case(input_file.readline())
     	print ""Case #%d: %d"" % (case_number, solve(*data_args))
 
 if __name__ == ""__main__"":
 	main()",35,385,468
"# Written for Python 2.7.5
 
 # Expected format of TEST_CASES is a list of tuples of (input, expected_output)
 TEST_CASES = [
     (""""""4
 1
 0.5
 0.6
 2
 0.7 0.2
 0.8 0.3
 3
 0.5 0.1 0.9
 0.6 0.4 0.3
 9
 0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899
 0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458
 """""",""""""Case #1: 0 0
 Case #2: 1 0
 Case #3: 2 1
 Case #4: 8 4
 """""")
 ]
 
 def parse_input(input_reader):
     case_count = int(input_reader.readline())
     case_idx = 0
     while case_count > case_idx:
         case_idx += 1
         block_count = int(input_reader.readline())
         naomi_blocks = [float(x) for x in input_reader.readline().split("" "")]
         ken_blocks = [float(x) for x in input_reader.readline().split("" "")]
         input_values = {""case"":case_idx,
                         ""naomi"": naomi_blocks,
                         ""ken"": ken_blocks,
                         ""block_count"": block_count
                         }
         yield input_values
 
 
 def solve_problem(output_writer=sys.stdout, **kwargs):
     ken = sorted(kwargs[""ken""])
     naomi = sorted(kwargs[""naomi""])
     case = kwargs[""case""]
     block_count = kwargs[""block_count""]
 
     dw_idx = 0
     w_idx = 0
 
     w_score = 0
     dw_score = 0
 
     for block in naomi:
         if block > ken[dw_idx]:
             dw_score += 1
             dw_idx += 1
     naomi = sorted(naomi, key=lambda x: -x)
     ken = sorted(ken, key=lambda x: -x)
     for block in naomi:
         if block > ken[w_idx]:
             w_score += 1
         else:
             w_idx += 1
 
     print >> output_writer, ""Case #%d: %d %d"" % (case, dw_score, w_score)
 
     
     # Implementation of code to solve the problem.
     # Use 'print >> output_writer, ""Thing""' to output values.
 
 def solve_inputs(input_reader, output_writer):
     """"""
     Loop through each problem input in input reader and solve it.
 
     Outputs responses to output_writer.
     """"""
     for input_values in parse_input(input_reader):
         solve_problem(output_writer=output_writer, **input_values)
 
 def run_tests():
     idx = 0
     all_pass = True
     for problem_input, expected_output in TEST_CASES:
         idx += 1
         input_reader = StringIO(problem_input)
         output_writer = StringIO()
         solve_inputs(input_reader, output_writer)
         problem_output = output_writer.getvalue()
         if problem_output == expected_output:
             print ""Test %d: Success"" % idx
         else:
             all_pass = False
             print ""Test %d: Failure"" % idx
         input_reader.close()
         output_writer.close()
     if all_pass:
         print ""All tests were successful!""
     else:
         print ""Something didn't match - try again.""
 
 def main():
     parser = OptionParser()
     parser.add_option(""-f"", ""--file"",
                       dest=""filename_stem"",
                       help=""read input from FILE.in and write to FILE.out"",
                       metavar=""FILE"")
 
     (options, args) = parser.parse_args()
     if options.filename_stem:
         print ""Running in file mode.""
         input_reader = open(""%s.in"" % options.filename_stem, ""r"")
         output_writer = open(""%s.out"" % options.filename_stem, ""w"")
         solve_inputs(input_reader, output_writer)
     else:
         print ""Running in test mode.""
         run_tests()
 
 if __name__ == ""__main__"":
     main()",35,386,1207
"(lower, upper, cache):
     counter = 0
     for item in cache:
         if item > upper:
             break
         if item < lower:
             continue
         counter += 1
     return counter
 
 def is_palindrome(test_int):
     str_arg = str(test_int)
     return str_arg == str_arg[::-1]
 
 def generate_cache():
     """""" Generates a list of 'fair and square' numbers between 1 and 10^100
 
     By observation of generating the first few of these numbers it became
     obvious that the 'roots' fitted a very specific pattern, they are either
     single digits and 1,2 or 3; multiple digits consisting of only 1s and 0s;
     multiple digits with a 2 at the beginning and end and 1s and 0s in the
     middle or an odd number of digits with a single 2 in the centre and 1s and
     0s elsewhere.
 
     This function therefore only looks at these numbers to build a list of all
     valid results. """"""
     # Put 9 in to start with as it's the only one that uses a 3.
     cache = [9,]
     counter = 1
     if upper_bound is None:
         upper_bound = pow(2,25)
     while counter < upper_bound:
         binary_part = ""{0:b}"".format(counter)
         # Look for palindromes beginning with a 1
         half_int = binary_part
         # Check the odd length palindrome
         pal_int = int(half_int + half_int[:-1][::-1])
         pal_square = pal_int * pal_int
         if is_palindrome(pal_square):
             cache.append(pal_square)
         # Check the even length palindrome
         pal_int = int(half_int + half_int[::-1])
         pal_square = pal_int * pal_int
         if is_palindrome(pal_square):
             cache.append(pal_square)
         half_int = ""%s%s"" % (binary_part, 2)
         # Check the odd length palindrome only when adding a 2
         pal_int = int(half_int + half_int[:-1][::-1])
         pal_square = pal_int * pal_int
         if is_palindrome(pal_square):
             cache.append(pal_square)
         # Look for palindromes beginning with a 2
         half_int = ""2%s"" % binary_part[1:]
         # Check the odd length palindrome
         pal_int = int(half_int + half_int[:-1][::-1])
         pal_square = pal_int * pal_int
         if is_palindrome(pal_square):
             cache.append(pal_square)
         # Check the even length palindrome
         pal_int = int(half_int + half_int[::-1])
         pal_square = pal_int * pal_int
         if is_palindrome(pal_square):
             cache.append(pal_square)
         counter += 1
     return sorted(cache)
 
 
 def main():
     parser = OptionParser()
     parser.add_option(""-f"", ""--file"", dest=""filename"",
                       help=""read input from FILE"", metavar=""FILE"")
     parser.add_option(""-c"", ""--cache"", dest=""cache_filename"",
                       help=""read/write cache from/to CACHE_FILE"", metavar=""CACHE_FILE"")
     parser.add_option(""-g"", ""--generate-cache"", dest=""generate_cache"",
                       help=""generate the cache file"", action=""store_true"")
     cache = None
     (options, args) = parser.parse_args()
     if options.generate_cache:
         # Generate a cache file before going through answers so that we don't
         # waste precious time later.
         cache = generate_cache()
         if not options.cache_filename:
             output_file = open(options.cache_filename, ""w"")
             pickle.dump(cache, output_file)
             output_file.close()
     else:
         cache_file = open(options.cache_filename, ""r"")
         cache = pickle.load(cache_file)
         cache_file.close()
     if not options.filename:
         parser.error(""Must provide a filename."")
     input_file = open(options.filename, ""r"")
     total_cases = int(input_file.readline())
     case_number = 0
     while case_number < total_cases:
         case_number += 1
         lower,upper = input_file.readline().split()
         lower = int(lower)
         upper = int(upper)
         data_args = (lower, upper, cache)
         print ""Case #%d: %s"" % (case_number, solve(*data_args))
 
 if __name__ == ""__main__"":
     main()",35,387,1229
"(data_line):
     english, googlerese = generate_map()
     transmap = string.maketrans(googlerese, english)
     return string.translate(data_line, transmap, ""\n"")
 
 def parse_case(data_line):
     return (data_line, )
 
 def generate_map():
     """""" Use the known phrases we have to generate a translation map.  If
         there's exactly one letter missing after analysing these phrases (which
         there is) we can work it out by seeing what's left over.""""""
     known_mappings = {""a zoo"": ""y qee"",
                       ""our language is impossible to understand"": ""ejp mysljylc kd kxveddknmc re jsicpdrysi"",
                       ""there are twenty six factorial possibilities"": ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"",
                       ""so it is okay if you want to just give up"": ""de kr kd eoya kw aej tysr re ujdr lkgc jv"",
                      }
     all_letters = ""abcdefghijklmnopqrstuvwxyz""
     letter_map = {}
     for english, googlerese in known_mappings.items():
         pairs = zip(english, googlerese)
         for e,g in pairs:
             if e not in letter_map:
                 letter_map[e] = g
     if len(letter_map) == 26:
         e_letter = """"
         g_letter = """"
         for letter in all_letters:
             if not e_letter and letter not in letter_map.keys():
                 e_letter = letter
             if not g_letter and letter not in letter_map.values():
                 g_letter = letter
         letter_map[e_letter] = g_letter
     return """".join(letter_map.keys()), """".join(letter_map.values())
 
 def main():
     parser = OptionParser()
     parser.add_option(""-f"", ""--file"", dest=""filename"",
                       help=""read input from FILE"", metavar=""FILE"")
 
     (options, args) = parser.parse_args()
     if not options.filename:
         parser.error(""Must provide a filename."")
     input_file = open(options.filename, ""r"")
     total_cases = int(input_file.readline())
     case_number = 0
     while case_number < total_cases:
     	case_number += 1
     	data_args = parse_case(input_file.readline())
     	print ""Case #%d: %s"" % (case_number, solve(*data_args))
 
 if __name__ == ""__main__"":
 	main()",35,388,684
"# Written for Python 2.7.5
 
 # Expected format of TEST_CASES is a list of tuples of (input, expected_output)
 TEST_CASES = [
     (""""""5
 5 5 23
 3 1 1
 2 2 1
 4 7 3
 10 10 82
 """""",""""""Case #1:
 Impossible
 Case #2:
 c
 .
 *
 Case #3:
 Impossible
 Case #4:
 c......
 .......
 .......
 ....***
 Case #5:
 c........*
 .........*
 **********
 **********
 **********
 **********
 **********
 **********
 **********
 **********
 """"""),
     (""""""3
 5 4 3
 5 3 8
 5 5 14
 """""",""""""Case #1:
 c...
 ....
 ....
 ...*
 ..**
 Case #2:
 Impossible
 Case #3:
 c...*
 ....*
 ...**
 *****
 *****
 """""")
 ]
 
 IMPOSSIBLE = ""Impossible""
 
 """"""
 S is number of safe squares = (R*C) - M
 If S == 1 then always possible:
     Assume click in top left, all else mines
 Special cases (R or C is small):
 If R == 1 or C == 1 then always possible:
     Assume click in top left and all safe squares in a line
 Else if R == 2 or C == 2 then possible iff S % 2 == 0:
     Assume click in top left and all safe squares are in a 2 * X line
 Else if R == 3 or C == 3 then possible if S % 3 == 0 (Assume click in top left and all safe squares are in a 3 * X line)
    OR if S % 2 == 0 
 """"""
 
 def parse_input(input_reader):
     case_count = int(input_reader.readline())
     case_idx = 0
     while case_count > case_idx:
         case_idx += 1
         input_line = [int(x) for x in input_reader.readline().split()]
         input_values = {""case"": case_idx,
                         ""R"": input_line[0],
                         ""C"": input_line[1],
                         ""M"": input_line[2]}
         yield input_values
 
 
 def solve_problem(output_writer=sys.stdout, **kwargs):
     case = kwargs['case']
     rows = kwargs['R']
     cols = kwargs['C']
     mines = kwargs['M']
     safe_squares = ((rows * cols) - mines)
     print >> output_writer, ""Case #%d:"" % case
     row_string = ""{:*<%ds}"" % cols
     impossible = False
     if safe_squares == 1:
         print >> output_writer, row_string.format(""c"")
         for row in range(1, rows):
             print >> output_writer, row_string.format("""")
     elif rows == 1:
         safe_string = ""c"" + (""."" * (safe_squares - 1))
         print >> output_writer, row_string.format(safe_string)
     elif cols == 1:
         for row in range(rows):
             cell = """"
             if row == 0:
                 cell = ""c""
             elif row < safe_squares:
                 cell = "".""
             print >> output_writer, row_string.format(cell)
     elif safe_squares == 2:
         impossible = True
     elif rows == 2:
         safe_cols, remainder = divmod(safe_squares, 2)
         if remainder == 1:
             impossible = True
         else:
             safe_string = ""."" * (safe_cols - 1)
             print >> output_writer, row_string.format(""c%s"" % safe_string)
             print >> output_writer, row_string.format("".%s"" % safe_string)
     elif cols == 2:
         safe_rows, remainder = divmod(safe_squares, 2)
         if remainder == 1:
             impossible = True
         else:
             for row in range(rows):
                 cells = """"
                 if row == 0:
                     cells = ""c.""
                 elif row < safe_rows:
                     cells = ""..""
                 print >> output_writer, row_string.format(cells)
     else:
         safe_rows, remainder = divmod(safe_squares, cols)
         if remainder == 1 and cols == 3 and safe_rows == 2:
             impossible = True
         elif safe_rows > 1:
             if remainder == 1 and safe_rows == 2:
                 mid_safe = ""."" * (cols-2)
                 for row in range(rows):
                     cell_one = "".""
                     mid_cells = mid_safe
                     last_cell = "".""
                     if row == 0:
                         cell_one = ""c""
                     elif safe_rows == 0:
                         cell_one = "".""
                         mid_cells = ""."" * (remainder + 1)
                     elif safe_rows < 0:
                         cell_one = """"
                         mid_cells = """"
                     if safe_rows < 3:
                         last_cell = """"
                     print >> output_writer, row_string.format(""%s%s%s"" % (cell_one, mid_cells, last_cell))
                     safe_rows -= 1
             elif remainder == 1:
                 mid_safe = ""."" * (cols-2)
                 for row in range(rows):
                     cell_one = "".""
                     mid_cells = mid_safe
                     last_cell = "".""
                     if row == 0:
                         cell_one = ""c""
                     elif safe_rows == 0:
                         cell_one = "".""
                         mid_cells = ""."" * remainder
                     elif safe_rows < 0:
                         cell_one = """"
                         mid_cells = """"
                     if safe_rows < 2:
                         last_cell = """"
                     print >> output_writer, row_string.format(""%s%s%s"" % (cell_one, mid_cells, last_cell))
                     safe_rows -= 1
             else:
                 full_safe = ""."" * cols
                 for row in range(rows):
                     cells = full_safe
                     if row == 0:
                         cells = ""c"" + (""."" * (cols - 1))
                     elif row == safe_rows:
                         cells = ""."" * remainder
                     elif row > safe_rows:
                         cells = """"
                     print >> output_writer, row_string.format(cells)
         else:
             safe_cols, remainder = divmod(safe_squares, 2)
             if remainder == 1 and safe_cols < 4:
                 impossible = True
             elif remainder == 0:
                 print >> output_writer, row_string.format(""c%s"" % (""."" * (safe_cols - 1)))
                 print >> output_writer, row_string.format(""."" * safe_cols)
                 for row in range(2, rows):
                     print >> output_writer, row_string.format("""")
             else:
                 safe_cols -= 1
                 print >> output_writer, row_string.format(""c%s"" % (""."" * (safe_cols - 1)))
                 print >> output_writer, row_string.format(""."" * safe_cols)
                 print >> output_writer, row_string.format(""..."")
                 for row in range(3, rows):
                     print >> output_writer, row_string.format("""")
     if impossible:
         print >> output_writer, IMPOSSIBLE
 
 def solve_inputs(input_reader, output_writer):
     """"""
     Loop through each problem input in input reader and solve it.
 
     Outputs responses to output_writer.
     """"""
     for input_values in parse_input(input_reader):
         solve_problem(output_writer=output_writer, **input_values)
 
 def run_tests():
     idx = 0
     all_pass = True
     for problem_input, expected_output in TEST_CASES:
         idx += 1
         input_reader = StringIO(problem_input)
         output_writer = StringIO()
         solve_inputs(input_reader, output_writer)
         problem_output = output_writer.getvalue()
         if problem_output == expected_output:
             print ""Test %d: Success"" % idx
         else:
             all_pass = False
             print ""Test %d: Failure"" % idx
             print problem_output
         input_reader.close()
         output_writer.close()
     if all_pass:
         print ""All tests were successful!""
     else:
         print ""Something didn't match - try again.""
 
 def main():
     parser = OptionParser()
     parser.add_option(""-f"", ""--file"",
                       dest=""filename_stem"",
                       help=""read input from FILE.in and write to FILE.out"",
                       metavar=""FILE"")
 
     (options, args) = parser.parse_args()
     if options.filename_stem:
         print ""Running in file mode.""
         input_reader = open(""%s.in"" % options.filename_stem, ""r"")
         output_writer = open(""%s.out"" % options.filename_stem, ""w"")
         solve_inputs(input_reader, output_writer)
     else:
         print ""Running in test mode.""
         run_tests()
 
 if __name__ == ""__main__"":
     main()",35,389,2417
"# Written for Python 2.7.5
 
 # Expected format of TEST_CASES is a list of tuples of (input, expected_output)
 TEST_CASES = [
     (""""""4
 30.0 1.0 2.0
 30.0 2.0 100.0
 30.50000 3.14159 1999.19990
 500.0 4.0 2000.0
 """""",""""""Case #1: 1.0000000
 Case #2: 39.1666667
 Case #3: 63.9680013
 Case #4: 526.1904762
 """""")
 ]
 
 """"""
 Z is number of farms held
 tF(Z) is time to build a farm = C / (2+(F*Z))
 tX(Z) is time to win = X / (2+(F*Z))
 No point incresing Z when tX(Z) < (tX(Z+1) + tF(Z)
     == X / (2+(F*Z)) < (X / (2+(F*(Z+1))) + (C / (2+(F*Z)))
     == (X - C) / (2+(F*Z)) < X / (2+(F*(Z+1)))
     == (X - C) * (2+(F*Z)+F) < X * (2+(F*Z))
     == 2X - 2C + XFZ - CFZ + XF - CF < 2X + XFZ
     == XF - CF - 2C < CFZ
     == (XF - CF - 2C) / CF < Z
 """"""
 
 def parse_input(input_reader):
     case_count = int(input_reader.readline())
     case_idx = 0
     while case_count > case_idx:
         case_idx += 1
         input_line = input_reader.readline().rstrip(""\n"").split("" "")
         input_values = {""C"": float(input_line[0]),
                         ""F"": float(input_line[1]),
                         ""X"": float(input_line[2]),
                         ""case"": case_idx}
         yield input_values
 
 def solve_problem(output_writer=sys.stdout, **kwargs):
     case = kwargs['case']
     C_val = kwargs['C']
     F_val = kwargs['F']
     X_val = kwargs['X']
 
     best_Z = ((X_val * F_val) - (C_val * F_val) - (2 * C_val)) / (C_val * F_val)
     best_Z = int(ceil(best_Z))
     if best_Z < 0:
         best_Z = 0
 
     tX = lambda z: (X_val / (2+(F_val * z)))
     tF = lambda z: (C_val / (2+(F_val * z)))
 
     total_time = reduce(lambda x,y: x + tF(y), range(best_Z), tX(best_Z))
     print >> output_writer, ""Case #%d: %.7f"" % (case, total_time)
 
 def solve_inputs(input_reader, output_writer):
     """"""
     Loop through each problem input in input reader and solve it.
 
     Outputs responses to output_writer.
     """"""
     for input_values in parse_input(input_reader):
         solve_problem(output_writer=output_writer, **input_values)
 
 def run_tests():
     idx = 0
     all_pass = True
     for problem_input, expected_output in TEST_CASES:
         idx += 1
         input_reader = StringIO(problem_input)
         output_writer = StringIO()
         solve_inputs(input_reader, output_writer)
         problem_output = output_writer.getvalue()
         if problem_output == expected_output:
             print ""Test %d: Success"" % idx
         else:
             all_pass = False
             print ""Test %d: Failure"" % idx
         input_reader.close()
         output_writer.close()
     if all_pass:
         print ""All tests were successful!""
     else:
         print ""Something didn't match - try again.""
 
 def main():
     parser = OptionParser()
     parser.add_option(""-f"", ""--file"",
                       dest=""filename_stem"",
                       help=""read input from FILE.in and write to FILE.out"",
                       metavar=""FILE"")
 
     (options, args) = parser.parse_args()
     if options.filename_stem:
         print ""Running in file mode.""
         input_reader = open(""%s.in"" % options.filename_stem, ""r"")
         output_writer = open(""%s.out"" % options.filename_stem, ""w"")
         solve_inputs(input_reader, output_writer)
     else:
         print ""Running in test mode.""
         run_tests()
 
 if __name__ == ""__main__"":
     main()",35,390,1288
"# TODO FOR 14 : rounding functions, graph manipulation, desert lion
 
 #EOL = os.linesep - using this causes weird \r\r\n problems
 EOL = ""\n""
 
 # ----------------------------------------------------------------------
 
 def is_equal_approx(x, y, epsilon=1e-6):
     """"""Returns True iff y is within relative or absolute 'epsilon' of x.
     
     By default, 'epsilon' is 1e-6.
     """"""
     # Check absolute precision.
     if -epsilon <= x - y <= epsilon:
         return True
 
     # Is x or y too close to zero?
     if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:
         return False
 
     # Check relative precision.
     return (-epsilon <= (x - y) / x <= epsilon
         or -epsilon <= (x - y) / y <= epsilon)
   
 def read_syms(fd):
     """"""Read a line of whitespace separated symbols.""""""
     return fd.readline().strip().split()
 
 def read_ints(fd):
     """"""Read a line of whitespace separated integers.""""""
     return [int(p) for p in read_syms(fd)]
 
 def read_floats(fd):
     """"""Read a line of whitespace separated floats.""""""
     return [float(p) for p in read_syms(fd)]
 
 class Mtrx(object):
     """"""A matrix object.""""""
     
     def __init__(self, rows, cols, data):
         assert len(data) == rows * cols
         self.rows = rows
         self.cols = cols
         self.data = data
         
     def cell(self, r, c):
         return self.data[r * self.cols + c]
     
     def getrow(self, i):
         return [self.cell(i, c) for c in xrange(self.cols)]
 
     def getcol(self, i):
         return [self.cell(c, i) for c in xrange(self.rows)]
     
     @classmethod
     def readfromfile(cls, fd, readfunc, rows=None, cols=None):
         """"""Read matrix from file, assuming first line at location is `R C`.
         
         Return a new Mtrx object. Reading values is performed by the `readfunc`.
         Pre-determined size can be passed using `rows` and `cols`.
         """"""
         data = []
         if rows is None:
             assert cols is None
             rows, cols = read_ints(fd)
         else:
             assert cols is not None
         for _ in range(rows):
             line = readfunc(fd)
             assert len(line) == cols
             data.extend(line)
         return Mtrx(rows, cols, data)
             
     @classmethod
     def read_int_matrix(cls, fd, rows=None, cols=None):
         return cls.readfromfile(fd, read_ints, rows, cols)
             
     @classmethod
     def read_sym_matrix(cls, fd, rows=None, cols=None):
         return cls.readfromfile(fd, read_syms, rows, cols)
             
     def __str__(self):
         res = """"
         for i in xrange(self.rows):
             res += str(self.getrow(i)) + EOL
         return res
     
     def __repr__(self):
         return ""{}({}, {}, {})"".format(self.__class__.__name__, self.rows,
                                        self.cols, self.data)
 
 #===============================================================================
 # Class decorators 
 #===============================================================================
              
 cachetotals = 0
 cachemisses = 0
 
 def statreset():
     global cachemisses, cachetotals
     cachemisses = 0
     cachetotals = 0
 
 class memoizeit(object):
     """"""Decorator. Caches a function's return value each time it is called.
     
     If called later with the same arguments, the cached value is returned 
     (not reevaluated).
     """"""
     
     def __init__(self, func):
         self.func = func
         self.cache = {}
         
     def __call__(self, *args):
         
         # update stats
         global cachetotals, cachemisses
         cachetotals += 1
         
         try:
             return self.cache[args]
         except KeyError:
             
             # update stats
             cachemisses += 1
             
             value = self.func(*args)
             self.cache[args] = value
             return value
         except TypeError:
 
             # update stats
             cachemisses += 1
 
             # uncachable -- for instance, passing a list as an argument.
             # Better to not cache than to blow up entirely.
             return self.func(*args)
     
     @property
     def __name__(self):
         return self.func.__name__
     
     def __get__(self, obj, objtype):
         """"""Support instance methods.""""""
         return functools.partial(self.__call__, obj)
 
 class timeit(object):
     """"""Decorator that times a function.
     
     When function ends, print name, runtime, return value and cache stats.
     """"""
     
     def __init__(self, func):
         self.func = func
         
     def __call__(self, *args):
         start = time.time()
         value = self.func(*args)
         delta = time.time() - start
         cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \
             cachetotals else 0
         print self.func.__name__, ""{:7.3f}s, (res: {}, cache: {:.2%})"".format(
             delta, value, cachedata)
         return value
     
     def __get__(self, obj, objtype):
         return functools.partial(self.__call__, obj)
 
 # ----------------------------------------------------------------------
",36,391,1508
"from gcjbase import *
 
 NO = ""NO""
 YES = ""YES""
 
 
 def read_input(filename):
     data = []
     with open(filename, ""r"") as f:
         cases = read_ints(f)[0]
         # =============================================
         for _ in xrange(cases):
             field = IntMatrix()
             field.readfromfile(f)
             data.append(field)
         # =============================================
     return data
 
 def make_output(fname, output):
     CASE_PRFX = ""Case #%s: ""
     fname = fname + time.strftime(""%H%M%S"") + "".out""
     with open(fname, ""w"") as f:
         # =============================================
         restext = []
         print ""Output content ===============""
         for i, v in enumerate(output):
             line = CASE_PRFX % (i+1,) + str(v) + ""\n""
             print line[:-1]
             restext.append(line)
         print ""="" * 30
         f.writelines(restext)
         # =============================================
 
 # ----------------------------------------------------------------------
 
 @timeit
 def solveit(case):
     print case
     for row in range(case.rows):
         for col in range(case.cols):
             cell = case.cell(row, col)
             if (any([c > cell for c in case.getrow(row)]) and
                 any([c > cell for c in case.getcol(col)])):
                 return NO
     return YES
         
 @timeit
 def main(fname):
     data = read_input(fname)
     output = []
     for i, case in enumerate(data):
         # =============================================
         res = solveit(case)
         output.append(res)
         # =============================================
     make_output(fname, output)
 
 
 if __name__ == '__main__':
 #    main(""sample.in"")
     main(""small.in"")
     #main(""large.in"")",36,392,519
"= "".out""
 CASE_PRFX = ""Case #%s: ""
 
 MAXB = 2000000
 
 
 
 def circlify(num, cutoff=MAXB):
     numstr = str(num) + str(num)
     max_opt = len(numstr) / 2
     opts = [int(numstr[i:i+max_opt]) for i in xrange(max_opt)]
     
     # only values larger than num (also filters leading zeroes) 
     # and smaller than cutoff
     opts = [o for o in opts if o > num and o <= cutoff]
     
     #clean dupes
     return len(set(opts))
 
 def check(A, B):
     res2 = 0
     start = time.time()
     for t in xrange(A, B):
         res2 += circlify(t, B)
     print res2, time.time()-start  
 
     return res2
 
 def read_input(filename):
     data = []
     with open(filename, ""r"") as f:
         cases = int(f.readline())
         for _ in xrange(cases):
             case = f.readline().strip().split()
             data.append((int(case[0]), int(case[1])))
     return data
 
 def make_output(fname, output):
     fname = fname + OEXT
     with open(fname, ""w"") as f:
         restext = []
         for i, v in enumerate(output):
             restext.append(CASE_PRFX % (i+1,) + str(v) + ""\n"")
         f.writelines(restext)
     
 def main(fname):
     data = read_input(fname)
     output = []
     for case in data:
         output.append(check(case[0], case[1]))
     print ""output:"", output
     make_output(fname, output)
 
 main(""small.in"")",36,393,492
"from gcjbase import *
 
 XWON = ""X won""
 OWON = ""O won""
 DRAW = ""Draw"" 
 NOTOVER = ""Game has not completed""
 
 
 def read_input(filename):
     data = []
     with open(filename, ""r"") as f:
         cases = read_ints(f)[0]
         # =============================================
         for _ in xrange(cases):
             board = []
             for _ in xrange(4):
                 board.extend(read_syms(f))
             read_syms(f)
             data.append(board)
         # =============================================
     return data
 
 def make_output(fname, output):
     CASE_PRFX = ""Case #%s: ""
     fname = fname + time.strftime(""%H%M%S"") + "".out""
     with open(fname, ""w"") as f:
         # =============================================
         restext = []
         for i, v in enumerate(output):
             line = CASE_PRFX % (i+1,) + str(v) + ""\n""
             print line
             restext.append(line)
         f.writelines(restext)
         # =============================================
 
 # ----------------------------------------------------------------------
 
 def getrow(board, i):
     return board[i*4:4*i+4]
 
 def getcol(board, i):
     return [c for j, c in enumerate(board) if j % 4 == i ]
 
 def getdiag(board, i):
     if i == 0:
         return board[0], board[5], board[10], board[15]
     return board[3], board[6], board[9], board[12]
 
 @timeit
 def solveit(case):
     print case
     xcase = [(c if c != 'T' else 'X') for c in case]
     ocase = [(c if c != 'T' else 'O') for c in case]
     
     # rows
     for i in range(4):
         if all([x == 'X' for x in getrow(xcase, i)]):
             return XWON
         if all([x == 'O' for x in getrow(ocase, i)]):
             return OWON
         
     # cols
     for i in range(4):
         if all([x == 'X' for x in getcol(xcase, i)]):
             return XWON
         if all([x == 'O' for x in getcol(ocase, i)]):
             return OWON
         
     # diag
     for i in range(2):
         if all([x == 'X' for x in getdiag(xcase, i)]):
             return XWON
         if all([x == 'O' for x in getdiag(ocase, i)]):
             return OWON
         
     if any([x == '.' for x in case]):
         return NOTOVER
     return DRAW
         
 @timeit
 def main(fname):
     data = read_input(fname)
     output = []
     for i, case in enumerate(data):
         # =============================================
         res = solveit(case)
         output.append(res)
         # =============================================
     make_output(fname, output)
 
 
 if __name__ == '__main__':
     #main(""sample.in"")
     main(""small.in"")
     #main(""sample.in"")",36,394,869
"= "".out""
 IN_S = ""small.in""
 IN_L = ""large.in""
 CASE_PRFX = ""Case #%s: ""
 
 
 def avg(L):
     return 1.0*sum(L)/len(L)
 
 triplets = [[0,0,0], [0,0,1], [0,1,1], 
             [0,0,2], [0,2,2], [0,1,2],
             [10,10,9], [10,9,8], [10,9,9], [10, 10, 8],
             ]
 
 def analyze_sum(sm, tgt):
     av = 1.0 * sm / 3
     av_cls = av % 1
 
     #assume non surprising
     if av_cls > 0.1:
         ns_max_val = math.ceil(av)
     else:
         ns_max_val = av 
     
     #assume surprising
     s_max_val = 0 
     if sm >= 2 and sm <= 28:
         if av_cls > 0.5:
             s_max_val = math.ceil(av) + 1
         elif av_cls > 0.1:
             s_max_val = math.ceil(av) 
         else:
             s_max_val = av + 1
     
     if ns_max_val >= tgt:
         res = [ns_max_val, None]
         kind = 1
     elif s_max_val < tgt:
         res = [None, None]
         kind = 0
     else:
         res = [None, s_max_val]
         kind = 2
         
     print sm, tgt, av, av_cls, ns_max_val, s_max_val, res, kind
     return res, kind
 
 def analyze_triplet(trip, tgt):
     sm = sum(trip)
     analyze_triplet(sm, tgt)
     
 
 def read_input(filename):
     data = []
     with open(filename, ""r"") as f:
         cases = int(f.readline())
         for _ in xrange(cases):
             case = f.readline().strip().split()
             case = [int(c) for c in case]
             data.append({""ngoog"": case[0], ""ssurp"": case[1], ""ptgt"": case[2],
                          ""trips"": case[3:]})
     return data
 
 def make_output(fname, output):
     fname = fname + OEXT
     with open(fname, ""w"") as f:
         restext = []
         for i, v in enumerate(output):
             restext.append(CASE_PRFX % (i+1,) + str(v) + ""\n"")
         f.writelines(restext)
     
 def main(fname):
     data = read_input(fname)
     output = []
     for case in data:
         ansys = [analyze_sum(c, case[""ptgt""]) for c in case[""trips""]]
         non_surp_is_enough = len([k for _, k in ansys if k == 1])
         surp_needed = len([k for _, k in ansys if k == 2])
         if surp_needed >= case[""ssurp""]:
             res = non_surp_is_enough + case[""ssurp""]
         else:
             res = non_surp_is_enough + surp_needed
         output.append(res)
     print ""output:"", output
     make_output(fname, output)
      
 
 main(""examples.in"")
 main(""small.in"")",36,395,934
"#===============================================================================
 # Generic helpers
 #===============================================================================
 # TODO FOR 14 : rounding functions, graph manipulation, desert lion, AttrDict
 
 #EOL = os.linesep - using this causes weird \r\r\n problems
 EOL = ""\n""
 
 # ------------------------------------------------------------------------------
 
 def is_equal_approx(x, y, epsilon=1e-6):
     """"""Returns True iff y is within relative or absolute 'epsilon' of x.
     
     By default, 'epsilon' is 1e-6.
     """"""
     # Check absolute precision.
     if -epsilon <= x - y <= epsilon:
         return True
 
     # Is x or y too close to zero?
     if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:
         return False
 
     # Check relative precision.
     return (-epsilon <= (x - y) / x <= epsilon
         or -epsilon <= (x - y) / y <= epsilon)
   
 def read_syms(fd):
     """"""Read a line of whitespace separated symbols.""""""
     return fd.readline().strip().split()
 
 def read_ints(fd):
     """"""Read a line of whitespace separated integers.""""""
     return [int(p) for p in read_syms(fd)]
 
 def read_floats(fd):
     """"""Read a line of whitespace separated floats.""""""
     return [float(p) for p in read_syms(fd)]
 
 # ------------------------------------------------------------------------------
 
 class Mtrx(object):
     """"""A matrix object.""""""
     
     def __init__(self, rows, cols, data):
         assert len(data) == rows * cols
         self.rows = rows
         self.cols = cols
         self.data = data
         
     def cell(self, r, c):
         return self.data[r * self.cols + c]
     
     def getrow(self, i):
         return [self.cell(i, c) for c in xrange(self.cols)]
 
     def getcol(self, i):
         return [self.cell(c, i) for c in xrange(self.rows)]
     
     @classmethod
     def readfromfile(cls, fd, readfunc, rows=None, cols=None):
         """"""Read matrix from file, assuming first line at location is `R C`.
         
         Return a new Mtrx object. Reading values is performed by the `readfunc`.
         Pre-determined size can be passed using `rows` and `cols`.
         """"""
         data = []
         if rows is None:
             assert cols is None
             rows, cols = read_ints(fd)
         else:
             assert cols is not None
         for _ in range(rows):
             line = readfunc(fd)
             assert len(line) == cols
             data.extend(line)
         return Mtrx(rows, cols, data)
             
     @classmethod
     def read_int_matrix(cls, fd, rows=None, cols=None):
         return cls.readfromfile(fd, read_ints, rows, cols)
             
     @classmethod
     def read_sym_matrix(cls, fd, rows=None, cols=None):
         return cls.readfromfile(fd, read_syms, rows, cols)
             
     def __str__(self):
         res = """"
         for i in xrange(self.rows):
             res += str(self.getrow(i)) + EOL
         return res
     
     def __repr__(self):
         return ""{}({}, {}, {})"".format(self.__class__.__name__, self.rows,
                                        self.cols, self.data)
 
 # ------------------------------------------------------------------------------
 
 cachetotals = 0
 cachemisses = 0
 
 def statreset():
     global cachemisses, cachetotals
     cachemisses = 0
     cachetotals = 0
 
 class memoizeit(object):
     """"""Decorator. Caches a function's return value each time it is called.
     
     If called later with the same arguments, the cached value is returned 
     (not reevaluated).
     """"""
     
     def __init__(self, func):
         self.func = func
         self.cache = {}
         
     def __call__(self, *args):
         
         # update stats
         global cachetotals, cachemisses
         cachetotals += 1
         
         try:
             return self.cache[args]
         except KeyError:
             
             # update stats
             cachemisses += 1
             
             value = self.func(*args)
             self.cache[args] = value
             return value
         except TypeError:
 
             # update stats
             cachemisses += 1
 
             # uncachable -- for instance, passing a list as an argument.
             # Better to not cache than to blow up entirely.
             return self.func(*args)
     
     @property
     def __name__(self):
         return self.func.__name__
     
     def __get__(self, obj, objtype):
         """"""Support instance methods.""""""
         return functools.partial(self.__call__, obj)
 
 # ------------------------------------------------------------------------------
 
 class timeit(object):
     """"""Decorator that times a function.
     
     When function ends, print name, runtime, return value and cache stats.
     """"""
     
     def __init__(self, func):
         self.func = func
         
     def __call__(self, *args):
         start = time.time()
         value = self.func(*args)
         delta = time.time() - start
         cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \
             cachetotals else 0
         print self.func.__name__, ""{:7.3f}s, (res: {}, cache: {:.2%})"".format(
             delta, value, cachedata)
         return value
     
     def __get__(self, obj, objtype):
         return functools.partial(self.__call__, obj)
 
 #===============================================================================
 # Input/output
 #===============================================================================
 
 def read_input(filename):
     data = []
     with open(filename, ""r"") as f:
         cases = read_ints(f)[0]
         # =============================================
         for _ in xrange(cases):
             case = {}
             case[""N""] = read_ints(f)
             case[""Naomi""] = sorted(read_floats(f))
             case[""Ken""] = sorted(read_floats(f))
             data.append(case)
         # =============================================
     return data
 
 def make_output(fname, output):
     CASE_PRFX = ""Case #%s: ""
     fname = fname + time.strftime(""%H%M%S"") + "".out""
     with open(fname, ""w"") as f:
         restext = []
         print ""Output content ===============""
         # =============================================
         for i, outdata in enumerate(output):
             line = CASE_PRFX % (i + 1,) + str(outdata) + EOL
             print line,
             restext.append(line)
         # =============================================
         print ""="" * 30
         f.writelines(restext)
 
 #===============================================================================
 # Actual solution
 #===============================================================================
 
 @timeit
 def solveit(case):
     ns = case[""Naomi""]
     ks = case[""Ken""]
     
     # calculate deceptive war
     nsmin = 0
     ksmin = 0
     
     dwpoints = 0
     while nsmin < len(ns):
         if ns[nsmin] > ks[ksmin]:
             ksmin += 1
             dwpoints += 1 
         nsmin += 1
     
     # calculate regular war
     nsmax = len(ns) - 1
     ksmin = 0
     
     wpoints = 0
     while len(ks) >= ksmin + 1:
         print ns, ks, nsmax, ksmin
         if ns[nsmax] > ks[-1]:
             ksmin += 1
             wpoints += 1
         else:
             m = ksmin
             for i in xrange(len(ks)-1, ksmin-1, -1):
                 if ks[i] < ns[nsmax]:
                     m = i + 1
                     break
             del ks[m]
         nsmax -= 1
     
     return str(dwpoints) + "" "" + str(wpoints) 
 
 
 #===============================================================================
 # Main
 #===============================================================================
 
 @timeit
 def main(fname):
     data = read_input(fname)
     output = []
     for case in data:
         statreset() # reset cache stats
         # =============================================
         res = solveit(case)
         output.append(res)
         # =============================================
     make_output(fname, output)
 
 
 if __name__ == '__main__':
 #    main(""sample.in"")
     main(""D-small-attempt0.in"")
 #    main(""C-large.in"")
 #    main(""B-small-attempt0.in"")
 #    main(""A-large.in"")",36,396,2376
"# ----------------------------------------------------------------------
 
 def is_equal_approx(x, y, epsilon=1e-6):
     """""" Returns True iff y is within relative or absolute 'epsilon' of x.
         By default, 'epsilon' is 1e-6.
     """"""
     # Check absolute precision.
     if -epsilon <= x - y <= epsilon:
         return True
 
     # Is x or y too close to zero?
     if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:
         return False
 
     # Check relative precision.
     return (-epsilon <= (x - y) / x <= epsilon
         or -epsilon <= (x - y) / y <= epsilon)
   
 def read_syms(fd):
     return [c for c in fd.readline().strip()]
 
 def read_ints(fd):
     return [int(p) for p in fd.readline().strip().split()]
 
 def read_floats(fd):
     return [float(p) for p in fd.readline().strip().split()]
 
 class Mtrx(object):
     
     def __init__(self, readfunc):
         self.readfunc = readfunc
         
     def cell(self, r, c):
         return self.data[r * self.cols + c]
     
     def getrow(self, i):
         return [self.cell(i, c) for c in range(self.cols)]
 
     def getcol(self, i):
         return [self.cell(c, i) for c in range(self.rows)]
     
     def readfromfile(self, fd):
         self.data = []
         self.rows, self.cols = read_ints(fd)
         for _ in range(self.rows):
             line = self.readfunc(fd)
             assert len(line) == self.cols
             self.data.extend(line)
             
     def __str__(self):
         res = """"
         for i in xrange(self.rows):
             res += str(self.getrow(i)) + ""\n""
         return res
              
 class IntMatrix(Mtrx):
     def __init__(self):
         super(IntMatrix, self).__init__(read_ints)
 
 class SymMatrix(Mtrx):
     def __init__(self):
         super(IntMatrix, self).__init__(read_syms)
 
 class memoizeit(object):
     def __init__(self, func):
         self.func = func
         self.cache = {}
         
     def __call__(self, *args):
         try:
             return self.cache[args]
         except KeyError:
             value = self.func(*args)
             self.cache[args] = value
             return value
         except TypeError:
             return self.func(*args)
     
     @property
     def __name__(self):
         return self.func.__name__
     
     def __get__(self, obj, objtype):
         return functools.partial(self.__call__, obj)
 
 class timeit(object):
     def __init__(self, func):
         self.func = func
     def __call__(self, *args):
         start = time.time()
         value = self.func(*args)
         delta = time.time() - start
         print self.func.__name__, ""{:7.3f}s, (res: {})"".format(delta, value)
         return value
     def __get__(self, obj, objtype):
         return functools.partial(self.__call__, obj)
 
 # ----------------------------------------------------------------------
",36,397,887
"#===============================================================================
 # Generic helpers
 #===============================================================================
 # TODO FOR 14 : rounding functions, graph manipulation, desert lion, AttrDict
 
 #EOL = os.linesep - using this causes weird \r\r\n problems
 EOL = ""\n""
 
 # ------------------------------------------------------------------------------
 
 def is_equal_approx(x, y, epsilon=1e-6):
     """"""Returns True iff y is within relative or absolute 'epsilon' of x.
     
     By default, 'epsilon' is 1e-6.
     """"""
     # Check absolute precision.
     if -epsilon <= x - y <= epsilon:
         return True
 
     # Is x or y too close to zero?
     if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:
         return False
 
     # Check relative precision.
     return (-epsilon <= (x - y) / x <= epsilon
         or -epsilon <= (x - y) / y <= epsilon)
   
 def read_syms(fd):
     """"""Read a line of whitespace separated symbols.""""""
     return fd.readline().strip().split()
 
 def read_ints(fd):
     """"""Read a line of whitespace separated integers.""""""
     return [int(p) for p in read_syms(fd)]
 
 def read_floats(fd):
     """"""Read a line of whitespace separated floats.""""""
     return [float(p) for p in read_syms(fd)]
 
 # ------------------------------------------------------------------------------
 
 class Mtrx(object):
     """"""A matrix object.""""""
     
     def __init__(self, rows, cols, data):
         assert len(data) == rows * cols
         self.rows = rows
         self.cols = cols
         self.data = data
         
     def cell(self, r, c):
         return self.data[r * self.cols + c]
     
     def getrow(self, i):
         return [self.cell(i, c) for c in xrange(self.cols)]
 
     def getcol(self, i):
         return [self.cell(c, i) for c in xrange(self.rows)]
     
     @classmethod
     def readfromfile(cls, fd, readfunc, rows=None, cols=None):
         """"""Read matrix from file, assuming first line at location is `R C`.
         
         Return a new Mtrx object. Reading values is performed by the `readfunc`.
         Pre-determined size can be passed using `rows` and `cols`.
         """"""
         data = []
         if rows is None:
             assert cols is None
             rows, cols = read_ints(fd)
         else:
             assert cols is not None
         for _ in range(rows):
             line = readfunc(fd)
             assert len(line) == cols
             data.extend(line)
         return Mtrx(rows, cols, data)
             
     @classmethod
     def read_int_matrix(cls, fd, rows=None, cols=None):
         return cls.readfromfile(fd, read_ints, rows, cols)
             
     @classmethod
     def read_sym_matrix(cls, fd, rows=None, cols=None):
         return cls.readfromfile(fd, read_syms, rows, cols)
             
     def __str__(self):
         res = """"
         for i in xrange(self.rows):
             res += str(self.getrow(i)) + EOL
         return res
     
     def __repr__(self):
         return ""{}({}, {}, {})"".format(self.__class__.__name__, self.rows,
                                        self.cols, self.data)
 
 # ------------------------------------------------------------------------------
 
 cachetotals = 0
 cachemisses = 0
 
 def statreset():
     global cachemisses, cachetotals
     cachemisses = 0
     cachetotals = 0
 
 class memoizeit(object):
     """"""Decorator. Caches a function's return value each time it is called.
     
     If called later with the same arguments, the cached value is returned 
     (not reevaluated).
     """"""
     
     def __init__(self, func):
         self.func = func
         self.cache = {}
         
     def __call__(self, *args):
         
         # update stats
         global cachetotals, cachemisses
         cachetotals += 1
         
         try:
             return self.cache[args]
         except KeyError:
             
             # update stats
             cachemisses += 1
             
             value = self.func(*args)
             self.cache[args] = value
             return value
         except TypeError:
 
             # update stats
             cachemisses += 1
 
             # uncachable -- for instance, passing a list as an argument.
             # Better to not cache than to blow up entirely.
             return self.func(*args)
     
     @property
     def __name__(self):
         return self.func.__name__
     
     def __get__(self, obj, objtype):
         """"""Support instance methods.""""""
         return functools.partial(self.__call__, obj)
 
 # ------------------------------------------------------------------------------
 
 class timeit(object):
     """"""Decorator that times a function.
     
     When function ends, print name, runtime, return value and cache stats.
     """"""
     
     def __init__(self, func):
         self.func = func
         
     def __call__(self, *args):
         start = time.time()
         value = self.func(*args)
         delta = time.time() - start
         cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \
             cachetotals else 0
         print self.func.__name__, ""{:7.3f}s, (res: {}, cache: {:.2%})"".format(
             delta, value, cachedata)
         return value
     
     def __get__(self, obj, objtype):
         return functools.partial(self.__call__, obj)
 
 #===============================================================================
 # Input/output
 #===============================================================================
 
 def read_input(filename):
     data = []
     with open(filename, ""r"") as f:
         cases = read_ints(f)[0]
         # =============================================
         for _ in xrange(cases):
             case = {}
             case[""R""], case[""C""], case[""M""] = read_ints(f)
             data.append(case)
         # =============================================
     return data
 
 def make_output(fname, output):
     CASE_PRFX = ""Case #%s: ""
     fname = fname + time.strftime(""%H%M%S"") + "".out""
     with open(fname, ""w"") as f:
         restext = []
         print ""Output content ===============""
         # =============================================
         for i, outdata in enumerate(output):
             line = CASE_PRFX % (i + 1,) + EOL + str(outdata) + EOL
             print line,
             restext.append(line)
         # =============================================
         print ""="" * 30
         f.writelines(restext)
 
 #===============================================================================
 # Actual solution
 #===============================================================================
 
 MINE = ""*""
 CLICK = ""c""
 UNK = "".""
 
 class Board(object):
     
     def __init__(self, r, c):
         self.rows = r
         self.cols = c
         self.edge_row_idx = self.rows - 1
         self.edge_col_idx = self.cols - 1
         self.board = [[UNK for _ in xrange(c)] for _ in xrange(r)]
         self.board[0][0] = CLICK
 
     def fill_edge_row(self, m):
         i = self.edge_col_idx
         while m > 0 and i >= 0:
             self.board[self.edge_row_idx][i] = MINE
             i -= 1
             m -= 1
         self.edge_row_idx -= 1
 
     def fill_edge_col(self, m):
         i = self.edge_row_idx
         while m > 0 and i >= 0:
             self.board[i][self.edge_col_idx] = MINE
             i -= 1
             m -= 1
         self.edge_col_idx -= 1
 
     def __str__(self):
         return EOL.join(["""".join(r) for r in self.board])
 
 @memoizeit
 def is_stage_solvable(rows, cols, mines):
     """"""Return True iff stage is solvable. 
     Also return fill instruction:
     0 if impossible/dontcare, 1 to fill row, 2 to fill column, 
     3 for row special (most in the row), 4 for col special (most in the col)
     """"""
     rc = rows * cols
     
     # all full
     if mines == rc:
         return False, 0
 
     if rows == 1:
         return mines <= rc - 1, 2
     if cols == 1:
         return mines <= rc - 1, 1
     
     # rows and cols > 1
     # single cell in corner   
     if mines == rc - 1:
         return True, 1  # doesn't matter what to fill
     
     # won't find 4 cells for the corner
     if mines > rc - 4:
         return False, 0
     
     if rows == 2:
         return (False, 0) if mines == 1 else (True, 2)
     if cols == 2:
         return (False, 0) if mines == 1 else (True, 1)
         
     # rows and cols > 2
     if rows <= cols:
         # try to fill columns
         if mines >= rows:
             return True, 2
         if mines == rows - 1:
             if mines == cols - 1:
                 if rows == 3:
                     return False, 0
                 return True, 4 # L shape fill, most in the column
             else:
                 return True, 1 # fill row
         return True, 2 
     else:
         # try to fill rows
         if mines >= cols:
             return True, 1
         if mines == cols - 1:
             if mines == rows - 1:
                 if cols == 3:
                     return False, 0
                 return True, 3 # L shape fill, most in the row
             else:
                 return True, 2 # fill column
         return True, 1 
 
 @timeit
 def solveit(case):
     rows = case[""R""]
     cols = case[""C""]
     mines = case[""M""]
     
     b = Board(rows, cols)
     r, c, m = rows, cols, mines
     
     while m >= 0:
         okgo, howtofill = is_stage_solvable(r, c, m)
         if not okgo:
             return ""Impossible""
         if howtofill == 1: # fill row
             b.fill_edge_row(m)
             if m <= c:
                 break # fill and done
             m -= c
             r -= 1
         elif howtofill == 2: # fill column
             b.fill_edge_col(m)
             if m <= r:
                 break # fill and done
             m -= r
             c -= 1
         elif howtofill == 3: # L shape fill, most in the row
             b.fill_edge_row(m - 1)
             b.fill_edge_col(1)
             break # fill and done
         elif howtofill == 4: # L shape fill, most in the column
             b.fill_edge_col(m - 1)
             b.fill_edge_row(1)
             break # fill and done
         else:
             assert False
 
     return str(b) 
 
 
 #===============================================================================
 # Main
 #===============================================================================
 
 @timeit
 def main(fname):
     data = read_input(fname)
     output = []
     for case in data:
         statreset() # reset cache stats
         # =============================================
         res = solveit(case)
         output.append(res)
         # =============================================
     make_output(fname, output)
 
 
 if __name__ == '__main__':
 #    main(""sample.in"")
     main(""C-small-attempt0.in"")
 #    main(""B-large.in"")
 #    main(""B-small-attempt0.in"")
 #    main(""A-large.in"")",36,398,3222
"#===============================================================================
 # Generic helpers
 #===============================================================================
 # TODO FOR 14 : rounding functions, graph manipulation, desert lion, AttrDict
 
 #EOL = os.linesep - using this causes weird \r\r\n problems
 EOL = ""\n""
 
 # ------------------------------------------------------------------------------
 
 def is_equal_approx(x, y, epsilon=1e-6):
     """"""Returns True iff y is within relative or absolute 'epsilon' of x.
     
     By default, 'epsilon' is 1e-6.
     """"""
     # Check absolute precision.
     if -epsilon <= x - y <= epsilon:
         return True
 
     # Is x or y too close to zero?
     if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:
         return False
 
     # Check relative precision.
     return (-epsilon <= (x - y) / x <= epsilon
         or -epsilon <= (x - y) / y <= epsilon)
   
 def read_syms(fd):
     """"""Read a line of whitespace separated symbols.""""""
     return fd.readline().strip().split()
 
 def read_ints(fd):
     """"""Read a line of whitespace separated integers.""""""
     return [int(p) for p in read_syms(fd)]
 
 def read_floats(fd):
     """"""Read a line of whitespace separated floats.""""""
     return [float(p) for p in read_syms(fd)]
 
 # ------------------------------------------------------------------------------
 
 class Mtrx(object):
     """"""A matrix object.""""""
     
     def __init__(self, rows, cols, data):
         assert len(data) == rows * cols
         self.rows = rows
         self.cols = cols
         self.data = data
         
     def cell(self, r, c):
         return self.data[r * self.cols + c]
     
     def getrow(self, i):
         return [self.cell(i, c) for c in xrange(self.cols)]
 
     def getcol(self, i):
         return [self.cell(c, i) for c in xrange(self.rows)]
     
     @classmethod
     def readfromfile(cls, fd, readfunc, rows=None, cols=None):
         """"""Read matrix from file, assuming first line at location is `R C`.
         
         Return a new Mtrx object. Reading values is performed by the `readfunc`.
         Pre-determined size can be passed using `rows` and `cols`.
         """"""
         data = []
         if rows is None:
             assert cols is None
             rows, cols = read_ints(fd)
         else:
             assert cols is not None
         for _ in range(rows):
             line = readfunc(fd)
             assert len(line) == cols
             data.extend(line)
         return Mtrx(rows, cols, data)
             
     @classmethod
     def read_int_matrix(cls, fd, rows=None, cols=None):
         return cls.readfromfile(fd, read_ints, rows, cols)
             
     @classmethod
     def read_sym_matrix(cls, fd, rows=None, cols=None):
         return cls.readfromfile(fd, read_syms, rows, cols)
             
     def __str__(self):
         res = """"
         for i in xrange(self.rows):
             res += str(self.getrow(i)) + EOL
         return res
     
     def __repr__(self):
         return ""{}({}, {}, {})"".format(self.__class__.__name__, self.rows,
                                        self.cols, self.data)
 
 # ------------------------------------------------------------------------------
 
 cachetotals = 0
 cachemisses = 0
 
 def statreset():
     global cachemisses, cachetotals
     cachemisses = 0
     cachetotals = 0
 
 class memoizeit(object):
     """"""Decorator. Caches a function's return value each time it is called.
     
     If called later with the same arguments, the cached value is returned 
     (not reevaluated).
     """"""
     
     def __init__(self, func):
         self.func = func
         self.cache = {}
         
     def __call__(self, *args):
         
         # update stats
         global cachetotals, cachemisses
         cachetotals += 1
         
         try:
             return self.cache[args]
         except KeyError:
             
             # update stats
             cachemisses += 1
             
             value = self.func(*args)
             self.cache[args] = value
             return value
         except TypeError:
 
             # update stats
             cachemisses += 1
 
             # uncachable -- for instance, passing a list as an argument.
             # Better to not cache than to blow up entirely.
             return self.func(*args)
     
     @property
     def __name__(self):
         return self.func.__name__
     
     def __get__(self, obj, objtype):
         """"""Support instance methods.""""""
         return functools.partial(self.__call__, obj)
 
 # ------------------------------------------------------------------------------
 
 class timeit(object):
     """"""Decorator that times a function.
     
     When function ends, print name, runtime, return value and cache stats.
     """"""
     
     def __init__(self, func):
         self.func = func
         
     def __call__(self, *args):
         start = time.time()
         value = self.func(*args)
         delta = time.time() - start
         cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \
             cachetotals else 0
         print self.func.__name__, ""{:7.3f}s, (res: {}, cache: {:.2%})"".format(
             delta, value, cachedata)
         return value
     
     def __get__(self, obj, objtype):
         return functools.partial(self.__call__, obj)
 
 #===============================================================================
 # Input/output
 #===============================================================================
 
 def read_input(filename):
     data = []
     with open(filename, ""r"") as f:
         cases = read_ints(f)[0]
         # =============================================
         for _ in xrange(cases):
             case = {}
             case[""C""], case[""F""], case[""X""] = read_floats(f)
             data.append(case)
         # =============================================
     return data
 
 def make_output(fname, output):
     CASE_PRFX = ""Case #%s: ""
     fname = fname + time.strftime(""%H%M%S"") + "".out""
     with open(fname, ""w"") as f:
         restext = []
         print ""Output content ===============""
         # =============================================
         for i, outdata in enumerate(output):
             line = CASE_PRFX % (i + 1,) + str(outdata) + EOL
             print line,
             restext.append(line)
         # =============================================
         print ""="" * 30
         f.writelines(restext)
 
 #===============================================================================
 # Actual solution
 #===============================================================================
 
 @memoizeit
 def will_a_farm_help(target, current_rate, farm_cost, farm_rate):
     no_farm = target / current_rate
     with_farm = farm_cost / current_rate + target / (farm_rate + current_rate)
     if no_farm > with_farm:
         return True, farm_cost / current_rate
     else:
         return False, no_farm
 
 @timeit
 def solveit(case):
     C = case[""C""]
     F = case[""F""]
     X = case[""X""]
     
     t = 0
     current_rate = 2.0 # default rate of 2 cookies per seconds
     
     while True:
         new_farm, add_time = will_a_farm_help(X, current_rate, C, F)
         if new_farm:
             t += add_time
             current_rate += F
         else:
             t += add_time
             return t
 
 #===============================================================================
 # Main
 #===============================================================================
 
 @timeit
 def main(fname):
     data = read_input(fname)
     output = []
     for case in data:
         statreset() # reset cache stats
         # =============================================
         res = solveit(case)
         output.append(res)
         # =============================================
     make_output(fname, output)
 
 
 if __name__ == '__main__':
 #    main(""sample.in"")
     main(""B-small-attempt0.in"")
 #    main(""B-large.in"")
 #    main(""B-small-attempt0.in"")
 #    main(""A-large.in"")",36,399,2291
"(): return stdin.readline().rstrip('\n')
 def read_int(): return int(stdin.readline())
 def read_ints(): return map(int, stdin.readline().split())
 
 def read_cards():
     cards = []
     for i in range(4):
         cards.append(read_ints())
     return cards
 
 def main():
     cases = read_int()
     for case in range(1, cases + 1):
         row = read_int() - 1
         cards = read_cards()
         candidates1 = set(cards[row])
         
         row = read_int() - 1
         cards = read_cards()
         candidates2 = set(cards[row])
         
         candidates = candidates1.intersection(candidates2)
         if len(candidates) == 1:
             ans = list(candidates)[0]
         elif len(candidates) == 0:
             ans = 'Volunteer cheated!'
         else:
             ans = 'Bad magician!'
         
         print('Case #{}: {}'.format(case, ans))
         
 main()
",37,400,276
"():
     return map(int, stdin.readline().rstrip().split(' '))
 
 def print_lawn(lawn):
     for row in lawn:
         print row
         
 def is_higher(a, i, j, N, M):
     s = a[i][j]
     v, h = False, False
     for ii in xrange(N):
         if a[ii][j] > s:
             v = True
             break
     for jj in xrange(M):
         if a[i][jj] > s:
             h = True
             break
     return v and h
     
 def check(a, N, M):
     if N == 1 or M == 1:
         return True
     else:
         for i in xrange(N):
             for j in xrange(M):
                 h = is_higher(a, i, j, N, M)
                 if h:
                     return False
         return True
     
 def main():
     T = int(stdin.readline())
     for Ti in xrange(T):
         N, M = read_ints()
         a = []
         for i in xrange(N):
             a.append(read_ints())
         answer = 'YES' if check(a, N, M) else 'NO'
         #print_lawn(a)
         print 'Case #{}: {}'.format(Ti + 1, answer)
         
 main()
",37,401,356
"():
 	T = int(stdin.readline())
 	for Ti in xrange(T):
 		A, B =  map(int, stdin.readline().rstrip().split(' '))
 		
 		ss = set()
 		for n in xrange(A, B + 1):
 			sn = str(n)
 			for i in xrange(1, len(sn)):
 				sm = sn[i:] + sn[:i]
 				if sm[0] != '0':
 					m = int(sm)
 					if m > n and m <= B:
 						ss.add((n, m))
 		
 		print 'Case #%d: %d' % (Ti + 1, len(ss))	
 	
 if __name__ == '__main__':
 	program()",37,402,236
"(x, o, t):
     if x == 4 or (x == 3 and t == 1):
         return 1
     elif o == 4 or (o == 3 and t == 1):
         return 2
 
 def check(board, BOARD_SIZE, RESULTS):
     d = 0
     for i in xrange(BOARD_SIZE):
         x = board[i].count('X')
         o = board[i].count('O')
         t = board[i].count('T')
         d += board[i].count('.')
         w = won(x, o, t)
         if w:
             return w
     for i in xrange(BOARD_SIZE):
         vertical = [ board[j][i] for j in xrange(BOARD_SIZE) ]
         x = vertical.count('X')
         o = vertical.count('O')
         t = vertical.count('T')
         w = won(x, o, t)
         if w:
             return w
     x, o, t = 0, 0, 0
     for i in xrange(BOARD_SIZE):
         if board[i][i] == 'X':
             x += 1
         elif board[i][i] == 'O':
             o += 1
         elif board[i][i] == 'T':
             t += 1
     w = won(x, o, t)
     if w:
         return w    
     x, o, t = 0, 0, 0
     for i in xrange(BOARD_SIZE):
         if board[i][BOARD_SIZE - i - 1] == 'X':
             x += 1
         elif board[i][BOARD_SIZE - i - 1] == 'O':
             o += 1
         elif board[i][BOARD_SIZE - i - 1] == 'T':
             t += 1
     w = won(x, o, t)
     if w:
         return w
     if d == 0:
         return 3
     else:
         return 4
     
 def main():
     BOARD_SIZE = 4
     RESULTS = 'X won', 'O won', 'Draw', 'Game has not completed'
 
     T = int(stdin.readline())
     for Ti in xrange(T):
         board = []
         for i in xrange(BOARD_SIZE):
             board.append(list(stdin.readline().rstrip()))
         print 'Case #{}: {}'.format(Ti + 1, RESULTS[check(board, BOARD_SIZE, RESULTS) - 1])    
         stdin.readline()
         
 main()
",37,403,661
"():
 	T = int(stdin.readline())
 	for Ti in xrange(T):
 		numbers = a = map(int, stdin.readline().rstrip().split(' '))
 		N, S, p, totals = numbers[0], numbers[1], numbers[2], numbers[3:]
 		
 		m = 0
 		curr_S = S
 		for i in xrange(N):
 			t = totals[i]
 			
 			if t / 3 >= p or (t / 3 == p - 1 and t % 3 > 0):
 				m += 1
 			elif curr_S > 0 and t > 0:
 				if (t / 3 == p - 1 and t % 3 == 0) or (t / 3 == p - 2 and t % 3 == 2):
 					m += 1
 					curr_S -= 1
 		
 		print 'Case #%d: %d' % (Ti + 1, m)	
 	
 if __name__ == '__main__':
 	program()",37,404,308
"(): return stdin.readline().rstrip('\n')
 def read_int(): return int(stdin.readline())
 def read_ints(): return map(int, stdin.readline().split())
 def read_floats(): return map(float, stdin.readline().split())
 
     
 def war(N, K):
     points = 0
     j = 0
     for i in range(len(N)):
         while j < len(K) and K[j] < N[i]:
             j += 1
         if j == len(K):
             points += 1
         else:
             j += 1
     return points
 
 
 def deceitful_war(N, K):
     return len(N) - war(K, N)
     
 
 def solve_case():
     read_int()
     N = sorted(read_floats())
     K = sorted(read_floats())
     
     return '{} {}'.format(deceitful_war(N, K), war(N, K))
 
     
 def main():
     cases = read_int()
     for case in range(1, cases + 1):
         print('Case #{}: {}'.format(case, solve_case()))
 
         
 main()
",37,405,311
"():
     return map(int, stdin.readline().rstrip().split(' '))
 
 def is_palin(n):
     s = str(n)
     return s == s[::-1]
     
 def find(n, fas):
     for i in xrange(len(fas)):
         if fas[i] >= n:
             return i
     return len(fas)
     
 def gen_fas(max):
     fas = []
     fasappend = fas.append
     square, base, d = 1, 1, 3
     while square < max:
         if is_palin(square) and is_palin(base):
             fasappend(square)
         square += d
         d += 2
         base += 1
     return fas
     
 def main():
     MAX = 1000
     fas = gen_fas(MAX)
     
     T = int(stdin.readline())
     for Ti in xrange(T):
         A, B = read_ints()
         answer = find(B + 1, fas) - find(A, fas)
         print 'Case #{}: {}'.format(Ti + 1, answer)
         
 main()
",37,406,291
"():
 	d = ord('a')
 	mapping = [ None ] * 26
 	inputs = [ 'ejp mysljylc kd kxveddknmc re jsicpdrysi', 
 		'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 
 		'de kr kd eoya kw aej tysr re ujdr lkgc jv' ]
 	outputs = [ 'our language is impossible to understand', 
 		'there are twenty six factorial possibilities', 
 		'so it is okay if you want to just give up' ]
 	
 	for i in xrange(len(inputs)):
 		input = inputs[i]
 		output = outputs[i]
 		for j in xrange(len(input)):
 			if input[j] == ' ':
 				continue
 			k = ord(input[j]) - d
 			if mapping[k] is None:
 				mapping[k] = output[j]
 	mapping[ord('q') - d] = 'z'
 	mapping[ord('z') - d] = 'q'
 				
 	return mapping
 			
 
 def program():
 	T = int(stdin.readline())
 	mapping = get_mapping()
 	d = ord('a')
 	for i in xrange(T):
 		s = stdin.readline().rstrip()
 		t = ''
 		
 		for ss in s:
 			if ss == ' ':
 				t += ' '
 			else:
 				t += mapping[ord(ss) - d]
 		print 'Case #%d: %s' % (i + 1, t)
 	
 if __name__ == '__main__':
 	program()",37,407,494
"(): return stdin.readline().rstrip('\n')
 def read_int(): return int(stdin.readline())
 def read_ints(): return map(int, stdin.readline().split())
 def read_floats(): return map(float, stdin.readline().split())
 
 
 def atos(A):
     return '\n'.join([''.join(row) for row in A])
     
 
 def get_field(r, c):
     field = [['.'] * c for i in range(r)]
     field[0][0] = 'c'
     return field
     
     
 def is_forbidden(i, j):
     return i == 0 and j == 0 or i == 0 and j == 1 or \
         i == 1 and j == 0 or i == 1 and j == 1
     
     
 def fill(field, r, c, m):
     left = m
     for ii in range(r - 1, -1, -1):
         i = ii
         j = c - 1
         while i < r and j >= 0:
             if is_forbidden(i, j):
                 i += 1
                 j -= 1
                 continue
             if left == 0:
                 return 0
             field[i][j] = '*'
             left -= 1
             
             i += 1
             j -= 1
             
         if ii == 0:
             for jj in range(c - 2, 1, -1):
                 i = ii
                 j = jj
                 while i < r and j >= 0:
                     if is_forbidden(i, j):
                         i += 1
                         j -= 1
                         continue
                     if left == 0:
                         return 0
                     field[i][j] = '*'
                     left -= 1
                     
                     i += 1
                     j -= 1
             
     if r * c == m + 1:
         if r > 1:
             field[1][0] = '*'
         if c > 1:
             field[0][1] = '*'
         if r > 1 and c > 1:
             field[1][1] = '*'
         return 0
             
     return left
 
     
 def solve_case():
     r, c, m = read_ints()
     #print('\n', r, c, m)
     
     field = get_field(r, c)
         
     left = fill(field, r, c, m)
         
     return 'Impossible' if left != 0 else atos(field)
     
     
 def main():
     cases = read_int()
     for case in range(1, cases + 1):
         print('Case #{}:\n{}'.format(case, solve_case()))
 
         
 main()
",37,408,711
"def CASE(IN):
     def rstr(): return IN.readline().strip()
     def rint(): return int(rstr())
     def rints(): return map(int, rstr().split())
     def rr():
         x = rint()
         m = [rints() for i in xrange(4)]
         return set(m[x-1])
     s = rr().intersection(rr())
     if not s:
         return ""Volunteer cheated!""
     if len(s) == 1:
         return s.pop()
     return ""Bad magician!""
 
 
 def RUN(IN, OUT):
     t = int(IN.readline().strip())
     for i in xrange(1,t+1):
         OUT.write(""Case #%i: %s\n"" % (i, CASE(IN)))
 
 if __name__ == ""__main__"":
     (sys.stdin, sys.stdout)
",38,409,230
"#!/usr/bin/env python
 = {}
 # to compute F:
 def f(x, _x, _min, _max):
     if x < 10: 
         #raise StopIteration
         return set()
     l = len(str(x)) -1
     k = 10**l
     res = set()
     res.add(_x)
     for i in xrange(l):
         x = (x % 10) * k + x/10
         if _min <= x <= _max and _x < x:
             res.add(x)
     res.remove(_x)
     if res:
         #print _x, ""=>"", res
         F[_x] = sorted(res)
     return res
 
 def compute_F(B):
     for i in xrange(0, B+1):
         f(i,i, 0, B+1)
     with open(""picle"",'wb') as _file:
         cPickle.dump( F, _file)
 
 #print ""start"", time.time()
 #compute_F(2000000)
 #print ""end  "", time.time()
 
 
 t_start = time.time()
 print ""loading...""
 with open(""picle"",'rb') as _file:
     F = cPickle.load(_file)
 print ""done in %.2fs"" % (time.time() - t_start)
 print ""loaded F with %i keys"" % len(F)
 
 def case(A, B):
     print ""XXXXXXXXX "", A, B
     res = 0
     res2 = 0
     for i in xrange(A, B):
         l = F.get(i, [])
         #l = sorted(f(i,i,A,B))
         #res += len(l)
         #l1 = sorted(F.get(i,[]))
         #if l != l1:
         #    print i, l, l1
 
         for x in l:
            if x <= B:
                res += 1
     return res
 
 def solve(fin, fout):
     T = int(fin.readline())
     for t in xrange(T):
         A, B = map(int, fin.readline().strip().split("" ""))
         assert A <= B
         fout.write(""Case #%i: %i\n"" % (t+1, case(A,B)) )
     return True
 
 if __name__ == ""__main__"":
     (sys.argv[1],'r') as fin:
         with open(sys.argv[2], 'w') as fout:
             solve(fin, fout)
",38,410,660
"def test_win(M, c):
     N = len(M)
     def yielder():
         for row in M:
             yield row, 'row'
         for i in xrange(N):
             yield [row[i] for row in M], 'col'
         yield [M[i][i] for i in xrange(N)], 'd1'
         yield [M[i][N-i-1] for i in xrange(N)], 'd2'
     for lst, typ in yielder():
         if all(l == c or l == 'T' for l in lst):
             #print ""won at %s %s"" % (lst, typ)
             return True
     return False
 
 def CASE(IN):
     def rstr(): return IN.readline().strip()
     def rint(): return int(rstr())
     def rints(): return map(int, rstr().split())
     M = [rstr() for i in xrange(4)]
     rstr()
     #print M
     if test_win(M, 'X'):
         return 'X won'
     if test_win(M, 'O'):
         return 'O won'
     if any('.' in row for row in M):
         return 'Game has not completed'
     return 'Draw'
 
 def RUN(IN, OUT):
     t = int(IN.readline().strip())
     for i in xrange(1,t+1):
         OUT.write(""Case #%i: %s\n"" % (i, CASE(IN)))
 
 if __name__ == ""__main__"":
     (sys.stdin, sys.stdout)
",38,411,400
"#!/usr/bin/env python
 
 
 = {} # no suprize
 D2 = {} # surprize
 for i in xrange(0, 31):
     D1[i] = D2[i] = -1
 
 def precompute():
     for a in xrange(0, 11):
         for b in xrange(a, min(a+3,11)):
             for c in xrange(b, min(a+3,11)):
                 t = a+b+c
                 assert a <= b <= c <= a+2 and c <= 11
                 if c < a+2:
                     D1[t] = max(D1[t], c)
                 else: # that is, c == a+2, we have a suprize
                     D2[t] = max(D2[t], c)
 
 #    for k in D1:
 #        print k, D2[k] - D1[k]
 
 precompute()
 ##with open(""prec"",""wb"") as f:
 #    cPickle.dump((D1, D2), f )
 #print D1, D2
 
 def case(S, P, ts):
     res_n = 0
     res_s = 0
     for t in ts:
         if D1[t] >= P:
             res_n+=1
         elif D2[t]>=P:
             res_s+=1
     return (res_n + min(res_s, S))
 
 
 def solve(fin, fout):
     T = int(fin.readline())
     for t in xrange(T):
         nums = map(int, fin.readline().strip().split("" ""))
         N, S, P = nums[:3]
         ts = nums[3:]
         assert len(ts) == N    
         fout.write(""Case #%i: %i\n"" % (t+1, case(S,P,ts)) )
     return True
 
 if __name__ == ""__main__"":
     (sys.argv[1],'r') as fin:
         with open(sys.argv[2], 'w') as fout:
             solve(fin, fout)
",38,412,547
"def CASE(IN):
     def rstr(): return IN.readline().strip()
     def rint(): return int(rstr())
     def rfs(): return map(float, rstr().split())
     N = rint()
     A = sorted(rfs())
     B = sorted(rfs())
     dwar = solve(N, A, B)
     war = N - solve(N, B, A)
     return ""%i %i"" % (dwar, war)
 
 
 def solve(N, A, B):
     i, j = 0, 0
     while True:
         while j < N and A[j] < B[i]:
             j += 1
         if j == N:
             return i
         i += 1
         j += 1
 
 
 def RUN(IN, OUT):
     t = int(IN.readline().strip())
     for i in xrange(1,t+1):
         OUT.write(""Case #%i: %s\n"" % (i, CASE(IN)))
 
 if __name__ == ""__main__"":
     (sys.stdin, sys.stdout)
",38,413,278
"*
 (s):
     for i in xrange(len(s)/2):
         if s[i] != s[-i-1]:
             return False
     return True
 
 def pal2(x, s):
     return pal(s) and pal(str(x*x))
 
 def E(k):
     return 10**k
 
 
 def CREATE_DATABASE(MAX):
     def init():
         yield 1
         yield 2
         yield 3
         yield 11
         yield 22
         for i in xrange(1, MAX):
             yield 1*E(2*i) + 1
             yield 1*E(2*i+1) + 1
             #yield 1*E(2*i + 1) + 1
             #yield 1*E(2*i) + 1 + 2*E(i)
             yield 2*E(2*i) + 2
             yield 2*E(2*i) + 2 + 1*E(i)
             yield 2*E(2*i+1) + 2
             
             
     heap = list(sorted(set(init())))
     for i in heap:
         print i
     heapq.heapify(heap)
     RES = []
     try:
         MAX_X = E(MAX)
         print ""MAX_X"", MAX_X
         while True:
             x = heapq.heappop(heap)
             #print x
             RES.append(x)
             if x == 3:
                 continue
             if x > MAX_X:
                 break
             s = str(x)
             j = len(s) / 2
             shift = 1 if len(s) == 2*j else 0
             for i in xrange(j+1, MAX):
                 n = E(2*i-shift) + 1 + E(i-j) * x
                 if pal2(n,str(n)):
                     #print (""{:^%i} => {:^%i}"" % (2*MAX, 2*MAX)).format(x, n)
                     heapq.heappush(heap, n)
                 
     except KeyboardInterrupt:
         print ""stopped while x is"", x
     with open(""c.database"", 'w') as f:
         for i in sorted(RES + heap):
             f.write(""%i\n""%i)
 
 def READ_DATABASE():
     with open(""c.database"", 'r') as f:
         return sorted(map(lambda x: int(x.strip())**2, f))
 DB = READ_DATABASE()
 
 (IN):
     def rstr(): return IN.readline().strip()
     def rint(): return int(rstr())
     def rints(): return map(int, rstr().split())
     def nrints(N): return [rints() for i in xrange(N)]
     A, B = rints()
     i = bisect_left(DB, A) 
     j = bisect_right(DB, B)
     return j-i
 
 def RUN(IN, OUT):
     t = int(IN.readline().strip())
     for i in xrange(1,t+1):
         OUT.write(""Case #%i: %s\n"" % (i, CASE(IN)))
 
 if __name__ == ""__main__"":
     # CREATE_DATABASE(52)
     (sys.stdin, sys.stdout)
",38,414,862
"#!/usr/bin/env python
 
 IN = """"""
 ejp mysljylc kd kxveddknmc re jsicpdrysi
 rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
 de kr kd eoya kw aej tysr re ujdr lkgc jv""""""
 OUT =""""""
 Case #1: our language is impossible to understand
 Case #2: there are twenty six factorial possibilities
 Case #3: so it is okay if you want to just give up""""""
 
 ins = IN.strip().split(""\n"")
 outs = OUT.strip().split(""\n"")
 assert len(ins) == len(outs) == 3
 
 D = {}
 D['a'] = 'y'
 D['o'] = 'e'
 D['z'] = 'q'
 
 for case, s in enumerate(ins):
     out = outs[case][9:] # skip ""Case #?: ""
     assert len(out) == len(s)
     for i, o in enumerate(out):
         if o == ' ': continue
         D[s[i]] = o
 
 if len(D) == 25:
     chars = map(chr, xrange(97, 123))
     key = set(chars).difference( set(D.keys()) ).pop()
     value = set(chars).difference( set(D.values()) ).pop()
     D[key] = value
 assert len(D) == 26
 D[' '] = ' '
 
 
 def solve(fin, fout):
     T = int(fin.readline())
     for t in xrange(T):
         fout.write(""Case #%i: "" % (t+1) )
         for c in fin.readline().strip():
             fout.write(D[c])
         fout.write('\n')
     return True
 
 if __name__ == ""__main__"":
     (sys.argv[1],'r') as fin:
         with open(sys.argv[2], 'w') as fout:
             solve(fin, fout)
",38,415,520
"def get_a(r, c, f='.'):
     A = []
     for i in xrange(r):
         A.append([f] * c)
     return A
 
 
 def apply(A, r, c, B):
     for i, b in enumerate(B):
         for j, v in enumerate(b):
             A[r + i][c + j] = v
 
 
 def draw(A):
     if A is None:
         return '\nImpossible'
     res = ['']
     for a in A:
         res.append(''.join(a))
     return '\n'.join(res)
 
 
 def trans(A):
     if not A:
         return None
     B = get_a(len(A[0]), len(A))
     for i, a in enumerate(A):
         for j, v in enumerate(a):
             B[j][i] = v
     return B
 
 
 def check(A, m, r, c):
     if A is None:
         return True
     cnts = {'c': 0, '*': 0, '.': 0}
     #print draw(A)
     #print
 
     assert len(A) == r
     for i in xrange(r):
         assert len(A[i]) == c
         for j in xrange(c):
             cnts[A[i][j]] += 1
     #print m, r, c, ""=>"", cnts
     assert cnts['*'] == m
     assert cnts['c'] == 1
     assert cnts['.'] == r * c - m - 1
 
 
 def CASE(IN):
     def rstr():
         return IN.readline().strip()
 
     def rint():
         return int(rstr())
 
     def rints():
         return map(int, rstr().split())
     r, c, m = rints()
     A = solve(m, r, c)
     if A:
         A[-1][-1] = 'c'
     check(A, m, r, c)
     return draw(A)
 
 
 def solve(m, r, c):
     if r > c:
         return trans(solve(m, c, r))
     assert r <= c
     assert m != r * c
     e = r * c - m
     # we click always in the right bottom corner
     if e == 1:
         A = get_a(r, c, '*')
         return A
     if r == 1:
         A = get_a(1, c, '.')
         for i in xrange(m):
             A[0][i] = '*'
         return A
     if r == 2:
         if e == 2 or e % 2 == 1:
             return None
         A = get_a(2, c, '.')
         assert m % 2 == 0
         for i in xrange(m / 2):
             A[0][i] = A[1][i] = '*'
         return A
     assert r >= 3
     A = get_a(r, c, '*')
     if e in (2, 3, 5, 7):
         return None
     E = [c] * (e / c) + ([e % c] if e % c else [])
     if sum(E) < e:
         E.append(e % c)
         assert sum(E) == e
     if len(E) == 1:
         E = [e / 2] * 2
         if sum(E) < e:
             e.append(1)
     if E[0] != E[1]:
         s = sum(E[:2])
         E[0] = E[1] = s / 2
         if sum(E[:2]) != s:
             assert len(E) == 2
             E.append(1)
     if E[-1] == 1:
         if len(E) > 3:
             E[-2] -= 1
             E[-1] += 1
         else:
             E[0] -= 1
             E[1] -= 1
             E[2] += 2
     for i in xrange(len(E)):
         for j in xrange(E[i]):
             A[-i - 1][-j - 1] = '.'
     return A
 
 
 def RUN(IN, OUT):
     t = int(IN.readline().strip())
     for i in xrange(1, t + 1):
         OUT.write(""Case #%i: %s\n"" % (i, CASE(IN)))
 
 if __name__ == ""__main__"":
     (sys.stdin, sys.stdout)
",38,416,1174
"def CASE(IN):
     def rstr(): return IN.readline().strip()
     def rint(): return int(rstr())
     def rints(): return map(int, rstr().split())
     def rfs(): return map(float, rstr().split())
     c, f, x = rfs()
     b = 2.0
     if x <= c:
         return x/b
     t = 0
     while True:
         # we can buy a farm now, should we?
         tf = x/(b+f) + c/b
         tn = x/b
         if tn <= tf:
             return t + tn
         t += c/b
         b += f
 
 
 def RUN(IN, OUT):
     t = int(IN.readline().strip())
     for i in xrange(1,t+1):
         OUT.write(""Case #%i: %.7f\n"" % (i, CASE(IN)))
 
 if __name__ == ""__main__"":
     (sys.stdin, sys.stdout)
",38,417,258
"#!/usr/bin/env python
 (F1,r1,F2,r2):
     s1=set(F1[r1-1])
     s2=set(F2[r2-1])
     sx=s1.intersection(s2)
     if len(sx)>1:
         return ""Bad magician!""
     elif len(sx)==0:
         return ""Volunteer cheated!""
     else:
         return sx.__iter__().next()
 
 
 
 def parse(infile):
     r1=int(infile.readline().strip())
     F1=[]
     for i in xrange(4):
         F1.append( map(int, infile.readline().split() ))
     r2=int(infile.readline().strip())
     F2=[]
     for i in xrange(4):
         F2.append( map(int, infile.readline().split() ))
     return F1,r1,F2,r2
 
 
 
 class GCJ_Parser( object ):
     def __init__(self,fname):
         self.infile=open(fname,'r')
         self.NumCases=int(self.infile.readline().strip() )
         self.caseNum=0
 
     def __iter__(self): return self
 
     def next(self):
         if self.caseNum==self.NumCases: raise StopIteration
         self.caseNum += 1
         args=parse(self.infile)
         return self.caseNum , args
 
 
 def runmain():
     myCases=GCJ_Parser(sys.argv[1])
 
     #Open output file, but don't overwrite old ones (for comparison)
     outname=sys.argv[1].rstrip('.in')+'.out'
     if os.path.isfile(outname):
         oldout=outname+'.old'
         ii=0
         while os.path.isfile(oldout):
             ii+=1
             oldout=outname+'.old'+str(ii)
         os.rename(outname,oldout)
         print 'Rename: %s -> %s'%(outname,oldout)   
  
     outfile=open(outname,'w')
 
     for iCase, args in myCases:
         answer=Solve(*args)
 
         print 'Case #'+str(iCase)+':',answer
         print >> outfile, 'Case #'+str(iCase)+':',answer
 
 
 
 
 if __name__=='__main__':
     runmain()
",39,418,649
"#!/usr/bin/env python
 (n,m,heights):
     #print heights
     for i,j in ( (i,j) for i in xrange(n) for j in xrange(m) ):
         if (heights[i,:]<= heights[i,j]).all(): continue
 
         if (heights[:,j]>heights[i,j]).any(): return ""NO""
 
 
     return 'YES'
 
 
 
 def parse(infile):
     n,m=map(int, infile.readline().split() )
     heights=np.zeros( (n,m) )
     for i in xrange(n):
         heights[i,:]=np.array( map(int, infile.readline().split() ) )
     return n,m,heights
 
 
 
 class GCJ_Parser( object ):
     def __init__(self,fname):
         self.infile=open(fname,'r')
         self.NumCases=int(self.infile.readline().strip() )
         self.caseNum=0
 
     def __iter__(self): return self
 
     def next(self):
         if self.caseNum==self.NumCases: raise StopIteration
         self.caseNum += 1
         args=parse(self.infile)
         return self.caseNum , args
 
 
 def runmain():
     myCases=GCJ_Parser(sys.argv[1])
     outfile=open(sys.argv[1].rstrip('.in')+'.out','w')
 
     for iCase, args in myCases:
         answer=Solve(*args)
 
         print 'Case #'+str(iCase)+':',answer
         print >> outfile, 'Case #'+str(iCase)+':',answer
 
 
 
 
 ########library functions
 class Categorizer(dict):
     def __init__(self,thelist,transform,trunc=2):
         dict.__init__(self)
         self.transform=transform
         self.AddList(thelist)
         self.trunc=trunc
     def AddList(self,thelist):
         for item in thelist: self.Add( item )
     def Add(self,object):
         cat=self.transform( object )
         if type(cat) is float:
             cat=round(cat,trunc)
         if self.has_key(cat):
             self[cat].append( object )
         else:
             self[cat]=[object]
     def PrintRanking(self,n=None):
         if n is None: n=len(self)
         items=self.items()
         items.sort(key=lambda x:-len(x[1]))
         total=0
         for i in items: total+=len(i[1])
         maxkey=max( len(str(key)) for key in self.iterkeys() )
         maxval=max( len(str(len(val))) for val in self.itervalues() )
         formatter=""{0:<""+str(maxkey)+""} {1:>""+str(maxval)+""}    {2}""
         for key,count in items[0:n]:
             print formatter.format(key,len(count),
                                    (""%.2f""%(len(count)*100.0/total))+'%')
     def Combine(self,newdict):
         newkeys=newdict.keys()
         for key in newkeys:
            if not type(newdict[key])==int:
               raise TypeError('passed object is not a counter')
         for key in newkeys:
            if not self.has_key(key): self[key]=[]
            self[key] += newdict[key]
     def Avg(self):
         avg=0.0
         ntot=0
         for key in self.keys():
             ntot+=len(self[key])
             avg+=len(self[key])*key
         return avg/(1.0*ntot)
     def StdDev(self):
         avg=self.Avg()
         ntot=0
         stddev=0.0
         for key in self.iterkeys():
             ntot+=len(self[key])
             stddev += len(self[key]) * ( (key-avg)**2)
         return stddev/(1.0*ntot)
     def Median(self):
         tot=0
         for value in self.itervalues(): tot+=len(value)
         keys=self.keys()
         keys.sort()
         nCount=0
         for key in keys:
            nCount += len(self[key])
            if nCount>tot/2: return key
     def Mode(self):
         return max(self.iteritems(), key=lambda x: len(x[1]))[0]
 
 
 
 
 class Counter(dict):
     def __init__(self,thelist,transform=None,trunc=2):
         dict.__init__(self)
         self.transform=transform
         self.trunc=trunc
         self.AddList(thelist)
     def AddList(self,thelist):
         if self.transform is not None:
             for item in thelist: self.Add( self.transform(item) )
         else:
             for item in thelist: self.Add( item )            
     def Add(self,object):
         if type(object) is float:
             object=round(object,self.trunc)
         if self.has_key(object):
             self[object]+=1
         else:
             self[object]=1
     def PrintRanking(self,n=None):
         if n is None: n=len(self)
         items=self.items()
         items.sort(key=lambda x:-x[1])
         total=0
         for i in items: total+=i[1]
         maxkey=max( len(str(key)) for key in self.iterkeys() )
         maxval=max( len(str(val)) for val in self.itervalues() )
         formatter=""{0:<""+str(maxkey)+""} {1:>""+str(maxval)+""}    {2}""
         for key,count in items[0:n]:
             print formatter.format(key,count, (""%.2f""%(count*100.0/total))+'%')
     def Combine(self,newdict):
         newkeys=newdict.keys()
         for key in newkeys:
            if not type(newdict[key])==int:
               raise TypeError('passed object is not a counter')
         for key in newkeys:
            if not self.has_key(key): self[key]=0
            self[key] += newdict[key]
     def Avg(self):
         avg=0.0
         ntot=0
         for key in self.keys():
             ntot+=self[key]
             avg+=self[key]*key
         return avg/(1.0*ntot)
     def StdDev(self):
         avg=self.Avg()
         ntot=0
         stddev=0.0
         for key in self.iterkeys():
             ntot+=self[key]
             stddev += self[key] * ( (key-avg)**2)
         return stddev/(1.0*ntot)
     def Median(self):
  	total=sum(self.values())
         keys=self.keys()
         keys.sort()
         nCount=0
         for key in keys:
            nCount += self[key]
            if nCount>total/2: return key
     def Mode(self):
         return max(self.iteritems(), key=lambda x: x[1])[0]
 
 
 def gen_primes():
     """""" Generate an infinite sequence of prime numbers.
     from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python
     """"""
     D = {}  
     q = 2  
 
     while True:
         if q not in D:
             yield q        
             D[q * q] = [q]
         else:
             for p in D[q]:
                 D.setdefault(p + q, []).append(p)
             del D[q]
 
         q += 1
 
 
 
 if __name__=='__main__':
     runmain()
",39,419,2078
"#!/usr/bin/env python
 =open(sys.argv[1],'r')
 
 NumCases=int(infile.readline())
 
 for iCase in xrange(NumCases):
 
     a,b=[int(i) for i in infile.readline().split()]
 
 
 #for iCase in xrange(1):
 #    a,b=[int(i) for i in sys.argv[1:]]
     a_digits=[int(i) for i in str(a) ]
     b_digits=[int(i) for i in str(b) ]
 
     ld=len(a_digits)
 
 #    print a_digits,b_digits
 
     result=0
 #    lowers={}
 
     for iNum in xrange(a,b+1):
         mystr=str(iNum)
         myset=set()
         for i in xrange(1,ld):
             mystr=mystr[1:]+mystr[0]
             iii=int(mystr)
             if iii>iNum and iii<=b and iii not in myset:
                 result+=1
                 #print iNum,iii
                 #if lowers.has_key(iii):
                 #    lowers[iii].append(iNum)
                 #else: lowers[iii]=[iNum]
 
             myset.add(iii)
             
         
 
 
 #    for k,v in lowers.iteritems(): print k,':',v
     print 'Case #'+str(iCase+1)+':',result
 
",39,420,396
"#!/usr/bin/env python
 (lines):
     hasEmpty=False
 
     rows=[ lines[0][i]+lines[1][i]+lines[2][i]+lines[3][i] 
            for i in xrange(4) ]
 
     diags=[ lines[0][0]+lines[1][1]+lines[2][2]+lines[3][3] ,
             lines[0][3]+lines[1][2]+lines[2][1]+lines[3][0] ]
 
 
     for il in lines + rows + diags:
         if il.replace('T','X')=='XXXX': return ""X won""
         elif il.replace('T','O')=='OOOO': return ""O won""
         elif il.find('.')>=0: hasEmpty=True
 
     
     if hasEmpty: return ""Game has not completed""
     else: return ""Draw""
 
 
 
 def parse(infile):
     lines=[]
     for i in xrange(4):
         lines.append(infile.readline().strip())
     infile.readline()
     return (lines,)
 
 
 
 class GCJ_Parser( object ):
     def __init__(self,fname):
         self.infile=open(fname,'r')
         self.NumCases=int(self.infile.readline().strip() )
         self.caseNum=0
 
     def __iter__(self): return self
 
     def next(self):
         if self.caseNum==self.NumCases: raise StopIteration
         self.caseNum += 1
         args=parse(self.infile)
         return self.caseNum , args
 
 
 def runmain():
     myCases=GCJ_Parser(sys.argv[1])
     outfile=open(sys.argv[1].rstrip('.in')+'.out','w')
 
     for iCase, args in myCases:
         answer=Solve(*args)
 
         print 'Case #'+str(iCase)+':',answer
         print >> outfile, 'Case #'+str(iCase)+':',answer
 
 
 
 
 ########library functions
 class Categorizer(dict):
     def __init__(self,thelist,transform,trunc=2):
         dict.__init__(self)
         self.transform=transform
         self.AddList(thelist)
         self.trunc=trunc
     def AddList(self,thelist):
         for item in thelist: self.Add( item )
     def Add(self,object):
         cat=self.transform( object )
         if type(cat) is float:
             cat=round(cat,trunc)
         if self.has_key(cat):
             self[cat].append( object )
         else:
             self[cat]=[object]
     def PrintRanking(self,n=None):
         if n is None: n=len(self)
         items=self.items()
         items.sort(key=lambda x:-len(x[1]))
         total=0
         for i in items: total+=len(i[1])
         maxkey=max( len(str(key)) for key in self.iterkeys() )
         maxval=max( len(str(len(val))) for val in self.itervalues() )
         formatter=""{0:<""+str(maxkey)+""} {1:>""+str(maxval)+""}    {2}""
         for key,count in items[0:n]:
             print formatter.format(key,len(count),
                                    (""%.2f""%(len(count)*100.0/total))+'%')
     def Combine(self,newdict):
         newkeys=newdict.keys()
         for key in newkeys:
            if not type(newdict[key])==int:
               raise TypeError('passed object is not a counter')
         for key in newkeys:
            if not self.has_key(key): self[key]=[]
            self[key] += newdict[key]
     def Avg(self):
         avg=0.0
         ntot=0
         for key in self.keys():
             ntot+=len(self[key])
             avg+=len(self[key])*key
         return avg/(1.0*ntot)
     def StdDev(self):
         avg=self.Avg()
         ntot=0
         stddev=0.0
         for key in self.iterkeys():
             ntot+=len(self[key])
             stddev += len(self[key]) * ( (key-avg)**2)
         return stddev/(1.0*ntot)
     def Median(self):
         tot=0
         for value in self.itervalues(): tot+=len(value)
         keys=self.keys()
         keys.sort()
         nCount=0
         for key in keys:
            nCount += len(self[key])
            if nCount>tot/2: return key
     def Mode(self):
         return max(self.iteritems(), key=lambda x: len(x[1]))[0]
 
 
 
 
 class Counter(dict):
     def __init__(self,thelist,transform=None,trunc=2):
         dict.__init__(self)
         self.transform=transform
         self.trunc=trunc
         self.AddList(thelist)
     def AddList(self,thelist):
         if self.transform is not None:
             for item in thelist: self.Add( self.transform(item) )
         else:
             for item in thelist: self.Add( item )            
     def Add(self,object):
         if type(object) is float:
             object=round(object,self.trunc)
         if self.has_key(object):
             self[object]+=1
         else:
             self[object]=1
     def PrintRanking(self,n=None):
         if n is None: n=len(self)
         items=self.items()
         items.sort(key=lambda x:-x[1])
         total=0
         for i in items: total+=i[1]
         maxkey=max( len(str(key)) for key in self.iterkeys() )
         maxval=max( len(str(val)) for val in self.itervalues() )
         formatter=""{0:<""+str(maxkey)+""} {1:>""+str(maxval)+""}    {2}""
         for key,count in items[0:n]:
             print formatter.format(key,count, (""%.2f""%(count*100.0/total))+'%')
     def Combine(self,newdict):
         newkeys=newdict.keys()
         for key in newkeys:
            if not type(newdict[key])==int:
               raise TypeError('passed object is not a counter')
         for key in newkeys:
            if not self.has_key(key): self[key]=0
            self[key] += newdict[key]
     def Avg(self):
         avg=0.0
         ntot=0
         for key in self.keys():
             ntot+=self[key]
             avg+=self[key]*key
         return avg/(1.0*ntot)
     def StdDev(self):
         avg=self.Avg()
         ntot=0
         stddev=0.0
         for key in self.iterkeys():
             ntot+=self[key]
             stddev += self[key] * ( (key-avg)**2)
         return stddev/(1.0*ntot)
     def Median(self):
  	total=sum(self.values())
         keys=self.keys()
         keys.sort()
         nCount=0
         for key in keys:
            nCount += self[key]
            if nCount>total/2: return key
     def Mode(self):
         return max(self.iteritems(), key=lambda x: x[1])[0]
 
 
 def gen_primes():
     """""" Generate an infinite sequence of prime numbers.
     from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python
     """"""
     D = {}  
     q = 2  
 
     while True:
         if q not in D:
             yield q        
             D[q * q] = [q]
         else:
             for p in D[q]:
                 D.setdefault(p + q, []).append(p)
             del D[q]
 
         q += 1
 
 
 
 if __name__=='__main__':
     runmain()
",39,421,2148
"#!/usr/bin/env python
 =open(sys.argv[1],'r')
 
 NumCases=int(infile.readline())
 
 for iCase in xrange(NumCases):
     line=[ int(i) for i in infile.readline().split() ]
 
     n=line.pop(0)
     s=line.pop(0)
     p=line.pop(0)
 
     scores=line
     assert(len(scores))==n
 
     imax=0
     isurprise=0
 
     for score in scores:
         if score<p: continue
         if score<3*p-4:
             pass
         elif 3*p-2>score>=3*p-4:
             isurprise+=1
         else:
             imax+=1
 
     print 'Case #'+str(iCase+1)+':',imax+min(isurprise,s)
 
",39,422,232
"#!/usr/bin/env python
 (N,n,k):
     n.sort(reverse=True)
     k.sort(reverse=True)
     nDW=0
     i_n,i_k=0,0
     while i_n<N and i_k<N:
         if n[i_n]>k[i_k]:
             nDW+=1
             i_n+=1
             i_k+=1
         else:
             i_k+=1
 
     nW=0
     i_n,i_k=0,0
     while i_n<N and i_k<N:
         if n[i_n]<k[i_k]:
             nW+=1
             i_n+=1
             i_k+=1
         else:
             i_n+=1
 
     nW=N-nW
     return '%d %d'%(nDW,nW)
 
 
 
 def parse(infile):
     N=int(infile.readline().strip())
     n=map(float, infile.readline().split() )
     k=map(float, infile.readline().split() )
     return N,n,k
 
 
 
 class GCJ_Parser( object ):
     def __init__(self,fname):
         self.infile=open(fname,'r')
         self.NumCases=int(self.infile.readline().strip() )
         self.caseNum=0
 
     def __iter__(self): return self
 
     def next(self):
         if self.caseNum==self.NumCases: raise StopIteration
         self.caseNum += 1
         args=parse(self.infile)
         return self.caseNum , args
 
 
 def runmain():
     myCases=GCJ_Parser(sys.argv[1])
 
     #Open output file, but don't overwrite old ones (for comparison)
     outname=sys.argv[1].rstrip('.in')+'.out'
     if os.path.isfile(outname):
         oldout=outname+'.old'
         ii=0
         while os.path.isfile(oldout):
             ii+=1
             oldout=outname+'.old'+str(ii)
         os.rename(outname,oldout)
         print 'Rename: %s -> %s'%(outname,oldout)   
  
     outfile=open(outname,'w')
 
     for iCase, args in myCases:
         answer=Solve(*args)
 
         print 'Case #'+str(iCase)+':',answer
         print >> outfile, 'Case #'+str(iCase)+':',answer
 
 
 
 
 if __name__=='__main__':
     runmain()
",39,423,697
"#!/usr/bin/env python
 (n):
     cn=str(n)
     return (cn==cn[::-1])
 
 #Precomputed
 palinSqrt=[0, 1, 2, 3, 11, 22, 101, 111, 121, 202, 212, 1001, 1111, 2002, 10001, 10101, 10201, 11011, 11111, 11211, 20002, 20102, 100001, 101101, 110011, 111111, 200002, 1000001, 1001001, 1002001, 1010101, 1011101, 1012101, 1100011, 1101011, 1102011, 1110111, 1111111, 2000002, 2001002]
 
 
 #def genPalindromes(nPlaces):
 #    assert nPlaces>0
 #
 #    if nPlaces==1:
 #        for i in (1,2,3): yield i
 #    elif nPlaces%2==0:
 #        for i in xrange(nPlaces/2):
 
             
         
         
 
 
 
 def Solve(a,b):
     num=0
     for p in palinSqrt:
         if a<= p**2 <=b: num+=1
     return num
 
 
 
 def parse(infile):
     a,b=map(int, infile.readline().split() )
     return a,b
 
 
 
 class GCJ_Parser( object ):
     def __init__(self,fname):
         self.infile=open(fname,'r')
         self.NumCases=int(self.infile.readline().strip() )
         self.caseNum=0
 
     def __iter__(self): return self
 
     def next(self):
         if self.caseNum==self.NumCases: raise StopIteration
         self.caseNum += 1
         args=parse(self.infile)
         return self.caseNum , args
 
 
 def runmain():
     myCases=GCJ_Parser(sys.argv[1])
     outfile=open(sys.argv[1].rstrip('.in')+'.out','w')
 
     for iCase, args in myCases:
         answer=Solve(*args)
 
         print 'Case #'+str(iCase)+':',answer
         print >> outfile, 'Case #'+str(iCase)+':',answer
 
 
 
 
 ########library functions
 class Categorizer(dict):
     def __init__(self,thelist,transform,trunc=2):
         dict.__init__(self)
         self.transform=transform
         self.AddList(thelist)
         self.trunc=trunc
     def AddList(self,thelist):
         for item in thelist: self.Add( item )
     def Add(self,object):
         cat=self.transform( object )
         if type(cat) is float:
             cat=round(cat,trunc)
         if self.has_key(cat):
             self[cat].append( object )
         else:
             self[cat]=[object]
     def PrintRanking(self,n=None):
         if n is None: n=len(self)
         items=self.items()
         items.sort(key=lambda x:-len(x[1]))
         total=0
         for i in items: total+=len(i[1])
         maxkey=max( len(str(key)) for key in self.iterkeys() )
         maxval=max( len(str(len(val))) for val in self.itervalues() )
         formatter=""{0:<""+str(maxkey)+""} {1:>""+str(maxval)+""}    {2}""
         for key,count in items[0:n]:
             print formatter.format(key,len(count),
                                    (""%.2f""%(len(count)*100.0/total))+'%')
     def Combine(self,newdict):
         newkeys=newdict.keys()
         for key in newkeys:
            if not type(newdict[key])==int:
               raise TypeError('passed object is not a counter')
         for key in newkeys:
            if not self.has_key(key): self[key]=[]
            self[key] += newdict[key]
     def Avg(self):
         avg=0.0
         ntot=0
         for key in self.keys():
             ntot+=len(self[key])
             avg+=len(self[key])*key
         return avg/(1.0*ntot)
     def StdDev(self):
         avg=self.Avg()
         ntot=0
         stddev=0.0
         for key in self.iterkeys():
             ntot+=len(self[key])
             stddev += len(self[key]) * ( (key-avg)**2)
         return stddev/(1.0*ntot)
     def Median(self):
         tot=0
         for value in self.itervalues(): tot+=len(value)
         keys=self.keys()
         keys.sort()
         nCount=0
         for key in keys:
            nCount += len(self[key])
            if nCount>tot/2: return key
     def Mode(self):
         return max(self.iteritems(), key=lambda x: len(x[1]))[0]
 
 
 
 
 class Counter(dict):
     def __init__(self,thelist,transform=None,trunc=2):
         dict.__init__(self)
         self.transform=transform
         self.trunc=trunc
         self.AddList(thelist)
     def AddList(self,thelist):
         if self.transform is not None:
             for item in thelist: self.Add( self.transform(item) )
         else:
             for item in thelist: self.Add( item )            
     def Add(self,object):
         if type(object) is float:
             object=round(object,self.trunc)
         if self.has_key(object):
             self[object]+=1
         else:
             self[object]=1
     def PrintRanking(self,n=None):
         if n is None: n=len(self)
         items=self.items()
         items.sort(key=lambda x:-x[1])
         total=0
         for i in items: total+=i[1]
         maxkey=max( len(str(key)) for key in self.iterkeys() )
         maxval=max( len(str(val)) for val in self.itervalues() )
         formatter=""{0:<""+str(maxkey)+""} {1:>""+str(maxval)+""}    {2}""
         for key,count in items[0:n]:
             print formatter.format(key,count, (""%.2f""%(count*100.0/total))+'%')
     def Combine(self,newdict):
         newkeys=newdict.keys()
         for key in newkeys:
            if not type(newdict[key])==int:
               raise TypeError('passed object is not a counter')
         for key in newkeys:
            if not self.has_key(key): self[key]=0
            self[key] += newdict[key]
     def Avg(self):
         avg=0.0
         ntot=0
         for key in self.keys():
             ntot+=self[key]
             avg+=self[key]*key
         return avg/(1.0*ntot)
     def StdDev(self):
         avg=self.Avg()
         ntot=0
         stddev=0.0
         for key in self.iterkeys():
             ntot+=self[key]
             stddev += self[key] * ( (key-avg)**2)
         return stddev/(1.0*ntot)
     def Median(self):
  	total=sum(self.values())
         keys=self.keys()
         keys.sort()
         nCount=0
         for key in keys:
            nCount += self[key]
            if nCount>total/2: return key
     def Mode(self):
         return max(self.iteritems(), key=lambda x: x[1])[0]
 
 
 def gen_primes():
     """""" Generate an infinite sequence of prime numbers.
     from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python
     """"""
     D = {}  
     q = 2  
 
     while True:
         if q not in D:
             yield q        
             D[q * q] = [q]
         else:
             for p in D[q]:
                 D.setdefault(p + q, []).append(p)
             del D[q]
 
         q += 1
 
 
 
 if __name__=='__main__':
     runmain()
",39,424,2370
"#!/usr/bin/env python
 =open(sys.argv[1],'r')
 
 NumCases=int(infile.readline())
 
 myinput=""""""ejp mysljylc kd kxveddknmc re jsicpdrysi
 rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
 de kr kd eoya kw aej tysr re ujdr lkgc jv""""""
 
 myoutput=\
 """"""our language is impossible to understand
 there are twenty six factorial possibilities
 so it is okay if you want to just give up""""""
 
 mapping={}
 mapping['q']='z'
 mapping['z']='q'
 
 
 for char,mapto in zip(myinput,myoutput):
     if mapping.has_key(char):
         assert mapping[char]==mapto
     else:
         mapping[char]=mapto
 
 #allchar=set('abcdefghijklmnopqrstuvwxyz')
 #print allchar-set( mapping.keys() )
 #print allchar-set(mapping.values() )
 
 
 
 for iCase in xrange(NumCases):
     thestring=infile.readline().strip()
 
     newstring=''
     for char in thestring: newstring+=mapping[char]
 
 
     print 'Case #'+str(iCase+1)+': '+newstring
 
",39,425,353
"#!/usr/bin/env python
 #guaranteed that R,C>=3, and F is not 1,2,3,5,7
 def Fill(outmat,R,C,F):
     nF=F
     #first square
     outmat[:2,:2]='.'
     nF-=4
     if nF==0: return
 
     #next two
     outmat[2,:2]='.'
     nF-=2
     if nF==0: return    
 
     #nearly there...
     outmat[:2,2]='.'
     nF-=2
     if nF==0: return
 
     #Fill by 2 across columns
     for iC in xrange(3,C):
         if nF==1:
             outmat[2,2]='.'
             return
         outmat[:2,iC]='.'
         nF-=2
         if nF==0: return
         
     #Fill by 2 across rows
     for iR in xrange(3,R):
         if nF==1:
             outmat[2,2]='.'
             return
         outmat[iR,:2]='.'
         nF-=2
         if nF==0: return
 
     #Now fill singly 3rd row/column
     for iR,iC in ( (iR,iC) for iR in xrange(2,R)
                    for iC in xrange(2,C)):
         outmat[iR,iC]='.'
         nF-=1
         if nF==0: return
     
 
 
 
 def Solve(R,C,M):
     F=R*C-M
     if F==0: return '\nImpossible'
     if (R>1 and C>1 and F in (2,3)):
         return '\nImpossible'
 
     outmat=np.zeros( (R,C), dtype='S1')
     outmat[:,:]='*'
 
     if R==1:
         for i in xrange(F):
             outmat[0][i]='.'
     
     elif C==1:
         for i in xrange(F):
             outmat[i][0]='.'
 
     elif F>1:
         if F in (2,3,5,7): return ""\nImpossible""
         elif (R==2 or C==2) and F%2 != 0:
             return ""\nImpossible""
         elif R==2:
             outmat[:,:F/2]='.'
         elif C==2:
             outmat[:F/2,:]='.'
         else: Fill(outmat,R,C,F)
         
     outmat[0,0]='c'
     outmatlines=[ ''.join(x) for x in outmat ]
     #print outmatlines
     answer='\n'+'\n'.join(outmatlines)
 
     Verify(answer,F)
 
     return answer
 
 disp=[ (dx,dy) for dx in (-1,0,1)
     for dy in (1,0,-1) if (dx !=0 or dy!=0) ]
 
 def Verify(answer,F):
     lines=[list(x) for x in answer.split('\n')]
     if len(lines[0])==0: lines.pop(0)
     R,C=len(lines),len(lines[0])
     assert lines[0][0]=='c'
     assert answer.count('.')+1==F
     q=Queue.Queue()
     q.put( (0,0) )
 
     def adjToMine(x,y):
         for dx,dy in disp:
             if 0<=x+dx<R and 0<=y+dy<C:
                 if lines[x+dx][y+dy]=='*': return True
         return False
                 
 
     while not q.empty():
         x,y=q.get()
         for dx,dy in disp:
             if 0<=x+dx<R and 0<=y+dy<C:
                 if lines[x+dx][y+dy]=='c': continue
                 lines[x+dx][y+dy]='c'
                 if not adjToMine(x+dx,y+dy):
                     q.put( (x+dx,y+dy) )
 
     clicked='\n'.join([ ''.join(x) for x in lines])
     if clicked.find('.')>=0:
         print '\n','*'*20,""\nERROR, input:""
         print answer
         print 'OUTPUT:'
         print clicked
     
 
 
 
 def parse(infile):
     R,C,M=map(int, infile.readline().split() )
     return R,C,M
 
 
 
 class GCJ_Parser( object ):
     def __init__(self,fname):
         self.infile=open(fname,'r')
         self.NumCases=int(self.infile.readline().strip() )
         self.caseNum=0
 
     def __iter__(self): return self
 
     def next(self):
         if self.caseNum==self.NumCases: raise StopIteration
         self.caseNum += 1
         args=parse(self.infile)
         return self.caseNum , args
 
 
 def runmain():
     myCases=GCJ_Parser(sys.argv[1])
 
     #Open output file, but don't overwrite old ones (for comparison)
     outname=sys.argv[1].rstrip('.in')+'.out'
     if os.path.isfile(outname):
         oldout=outname+'.old'
         ii=0
         while os.path.isfile(oldout):
             ii+=1
             oldout=outname+'.old'+str(ii)
         os.rename(outname,oldout)
         print 'Rename: %s -> %s'%(outname,oldout)   
  
     outfile=open(outname,'w')
 
     for iCase, args in myCases:
         answer=Solve(*args)
 
         print 'Case #'+str(iCase)+':',answer
         print >> outfile, 'Case #'+str(iCase)+':',answer
 
 
 
 
 if __name__=='__main__':
     runmain()
",39,426,1584
"#!/usr/bin/python3
 
 = int(sys.stdin.readline().strip())
 
 def read_arrangement():
     arr = []
     for row in range(0,4):
         arr.append(sys.stdin.readline().strip().split(' '))
     return arr
 
 for t in range(1, ncases+1):
     answer1 = int(sys.stdin.readline().strip())
     arrang1 = read_arrangement()
     answer2 = int(sys.stdin.readline().strip())
     arrang2 = read_arrangement()
 
     row1 = arrang1[answer1-1]
     row2 = arrang2[answer2-1]
 
     intersect = set(row1) & set(row2)
 
     if len(intersect) == 1:
         print(""Case #{0}: {1}"".format(t, intersect.pop()))
     elif len(intersect) == 0:
         print(""Case #{0}: Volunteer cheated!"".format(t))
     else:
         print(""Case #{0}: Bad magician!"".format(t))
",40,427,276
"#!/usr/bin/python3
 
 = int(sys.stdin.readline())
 
 for t in range(1, ncases+1):
     (n, m) = [int(x) for x in sys.stdin.readline().strip().split("" "")]
     lawn = []
     cuttable = []
     for row in range(0, n):
         lawn.append([int(x) for x in sys.stdin.readline().strip().split("" "")])
         cuttable.append([False for x in range(0, m)])
 
     # Find cuttable squares in rows
     for row in range(0, n):
         rowdata = lawn[row]
         maxheight = max(rowdata)
         for col in range(0, m):
             if lawn[row][col] == maxheight:
                 cuttable[row][col] = True
 
     # Find cuttable squares in columns
     for col in range(0, m):
         coldata = [x[col] for x in lawn]
         maxheight = max(coldata)
         for row in range(0, n):
             if lawn[row][col] == maxheight:
                 cuttable[row][col] = True
 
     # Find if there's any square that is not cuttable
     result = True
     for row in range(0, n):
         for col in range(0, m):
             if not cuttable[row][col]:
                 result = False
                 break
         if result == False:
             break
 
     if result == False:
         print(""Case #%d: NO"" % t)
     else:
         print(""Case #%d: YES"" % t)
",40,428,413
"#!/usr/bin/python3
 
 (num, A, B):
 	strnum = str(num)
 	results = {}
 	for i in range(1, len(strnum)):
 		strrecycled = strnum[i:] + strnum[0:i]
 		recycled = int(strrecycled)
 		if recycled > num and recycled >= A and recycled <= B:
 			results[""%d_%d"" % (num, recycled)] = 1
 	return len(results)
 
 # Ignore the number of cases
 sys.stdin.readline()
 
 casenum = 0
 for line in sys.stdin:
 	casenum += 1
 
 	data = line.strip().split(' ')
 	A = int(data[0])
 	B = int(data[1])
 
 	count = 0
 	for num in range(A, B):
 		count += findrecycled(num, A, B)
 
 	print(""Case #%d: %d"" % (casenum, count))
",40,429,281
"#!/usr/bin/python3
 
 = int(sys.stdin.readline())
 
 for t in range(1, ncases+1):
     board = []
     winner = False
     numDots = 0
 
     # Fill the board while finding the winning rows
     for row in range(0, 4):
         rowdata = sys.stdin.readline().strip()
         board.append([])
         numX = 0
         numO = 0
         for col in range(0, 4):
             value = rowdata[col]
             if value == ""."":
                 numDots += 1
             if value == ""X"":
                 numX += 1
             if value == ""O"":
                 numO += 1
             if value == ""T"":
                 numX += 1
                 numO += 1
             board[row].append(value)
         if numX == 4:
             winner = True
             print(""Case #%d: X won"" % t)
             break
         if numO == 4:
             winner = True
             print(""Case #%d: O won"" % t)
             break
     while sys.stdin.readline().strip() != """": pass
 
     if winner == True: continue
 
     # Find columns
     for col in range(0, 4):
         numX = 0
         numO = 0
         for row in range(0, 4):
             value = board[row][col]
             if value == ""X"":
                 numX += 1
             if value == ""O"":
                 numO += 1
             if value == ""T"":
                 numX += 1
                 numO += 1
         if numX == 4:
             winner = True
             print(""Case #%d: X won"" % t)
             break
         if numO == 4:
             winner = True
             print(""Case #%d: O won"" % t)
             break
 
     if winner == True: continue
 
     # Find first diagonal
     numX = 0
     numO = 0
     for rowcol in range(0, 4):
         value = board[rowcol][rowcol]
         if value == ""X"":
             numX += 1
         if value == ""O"":
             numO += 1
         if value == ""T"":
             numX += 1
             numO += 1
     if numX == 4:
         print(""Case #%d: X won"" % t)
         continue
     if numO == 4:
         print(""Case #%d: O won"" % t)
         continue
 
     # Find second diagonal
     numX = 0
     numO = 0
     for rowcol in range(0, 4):
         value = board[rowcol][3-rowcol]
         if value == ""X"":
             numX += 1
         if value == ""O"":
             numO += 1
         if value == ""T"":
             numX += 1
             numO += 1
     if numX == 4:
         print(""Case #%d: X won"" % t)
         continue
     if numO == 4:
         print(""Case #%d: O won"" % t)
         continue
 
     # Final case
     if numDots == 0:
         print(""Case #%d: Draw"" % t)
     else:
         print(""Case #%d: Game has not completed"" % t)
 
",40,430,849
"#!/usr/bin/python3
 
 (score):
 	# Corner case
 	if score == 0: return (0, 0)
 
 	best = math.ceil(score / 3)
 	bestsurp = round(score / 3) + 1
 
 	return (best, bestsurp)
 	
 # Ignore the number of cases
 sys.stdin.readline()
 
 casenum = 0
 for line in sys.stdin:
 	casenum += 1
 
 	data = line.strip().split(' ')
 	maxsurprising = int(data[1])
 	p = int(data[2])
 	scores = data[3:]
 	maxgooglers = 0
 
 	for s in scores:
 		(best, bestsurp) = findbest(int(s))
 		if best >= p:
 			maxgooglers += 1
 		else:
 			if bestsurp >= p and maxsurprising > 0:
 				maxgooglers += 1
 				maxsurprising -= 1
 
 	print(""Case #%d: %d"" % (casenum, maxgooglers))
",40,431,314
"#!/usr/bin/python3
 # Strategies:
 # 0. Sort both lists of block weights
 # Deceitful War:
 # 1. Walk through her own blocks from the lightest to the heaviest one
 # 2. If the block is lighter than the lightest one from Ken, Naomi will tell a weight slightly lower than Ken's biggest one. So Ken wins, but he loses his heaviest block
 # 3. If the block is heavier than the lightest one from Ken, Naomi will tell a weight slightly higher than Ken's heaviest block. So Naomi wins, and Ken loses his lightest block
 # Standard War:
 # 1. Walk through her own blocks from the heaviest to the lightest one (there's no difference in the order for the result, but this way it's easier to compare)
 # 2. If the block is heavier than the heaviest one from Ken, Naomi wins, and Ken loses his lightest block
 # 3. If the block is lighter than the heaviest one from Ken, Ken wins, and Ken loses his heaviest block
 
 = int(sys.stdin.readline().strip())
 
 for t in range(1, ncases+1):
     nblocks = int(sys.stdin.readline().strip())
     naomi_blocks = [float(x) for x in sys.stdin.readline().strip().split()]
     ken_blocks = [float(x) for x in sys.stdin.readline().strip().split()]
 
     naomi_blocks.sort()
     ken_blocks.sort()
 
     # Deceitful War
     ken_lightest = 0
     ken_heaviest = nblocks-1
     points_deceitful = 0
 
     for i in range(0, nblocks):
         if naomi_blocks[i] > ken_blocks[ken_lightest]:
             points_deceitful += 1
             ken_lightest += 1
         else:
             ken_heaviest -= 1
 
     # Standard War
     ken_lightest = 0
     ken_heaviest = nblocks-1
     points_standard = 0
 
     for i in range(nblocks-1, -1, -1):
         if naomi_blocks[i] > ken_blocks[ken_heaviest]:
             points_standard += 1
             ken_lightest += 1
         else:
             ken_heaviest -= 1
 
     print(""Case #{0}: {1} {2}"".format(t, points_deceitful, points_standard))
",40,432,651
"#!/usr/bin/python3
 #
 # Some notes:
 # - It's better to find palindromes in the square rooted numbers (there will be a lot fewer)
 # - It's also much faster to generate the palindromes than to detect if a random number is a palindrome
 #   - Number of palindromes with n digits: 10^(ceil(n/2))
 #   - E.g, 3 digits => 10^2  -  4 digits => 10^2  -  5 digits => 10^3
 # - So the problem is reduced to generate the palindromes which are still palindromes when squared
 #
 # - And how to detect is a squared palindrome is still a palindrome? Easy, let's draw a multiplication:
 #          1 2 1
 #          1 2 1
 #       --------
 #          1 2 1
 #        2 4 2
 #      1 2 1
 #      ---------
 #      1 4 6 4 1
 #
 #   - The extreme case is the central column. If the sum is >=10, then resulting number will not be a palindrome
 #   - As the original number is a palindrome, this central column will always be the sum of the squares of all
 #     the digits in the number. E.g: 121 => 1^2 + 2^2 + 1^2 = 1 + 4 + 1 = 6 => less than 10 => square is a palindrome
 #   - This means that palindromes with digits 4-9 can never become a palindrome when squared
 #   - 3 can only appear once => 3 is the only valid number containing digit 3
 #   - 2 can appear at most twice:
 #     - 2 twos + 0/1 one (in this case 2 have to be the first and last digit)
 #     - 1 two + 0/2/4 ones (in this case 2 has to be in the middle position)
 #   - 1 can appear alone up to 9 times
 #   - 0 can appear as many times as you want
 #
 
 
 # This is the same as findpalindromes, but much faster (it just calculates the combinations
 # instead of obtaining all the actual numbers)
 def calculatepalindromes(ndigits):
     # Special case: only 1 digit
     if ndigits == 1:
         return 3
 
     result = 0
     isEven = ndigits % 2 == 0
     fillingdigits = math.floor((ndigits - 2)/2)
 
     # Palindromes with 2's
     if isEven:
         result += 1
     else:
         result += 3
 
     # Palindromes with only 1's
     for numones in range(0, min(6, fillingdigits) + 1):
         combinations = int(math.factorial(fillingdigits) / (math.factorial(fillingdigits-numones) * math.factorial(numones)))
         result += combinations
         if not isEven:
             result += combinations
 
     return result
 
 
 def findpalindromes(ndigits):
     # Special case: only 1 digit
     if ndigits == 1:
         return [1, 2, 3]
 
     result = []
     isEven = ndigits % 2 == 0
     fillingdigits = math.floor((ndigits - 2)/2)
 
     # Palindromes with 2's
     if isEven:
         result.append(int(""2"" + ""0""*(fillingdigits*2) + ""2""))
     else:
         result.append(int(""2"" + ""0""*fillingdigits + ""0"" + ""0""*fillingdigits + ""2""))
         result.append(int(""2"" + ""0""*fillingdigits + ""1"" + ""0""*fillingdigits + ""2""))
         result.append(int(""1"" + ""0""*fillingdigits + ""2"" + ""0""*fillingdigits + ""1""))
 
     # Palindromes with only 1's
     for numones in range(0, min(6, fillingdigits)+1):
         ones = fillOnes([], fillingdigits, numones)
         for o in ones:
             if isEven:
                 result.append(int(""1"" + """".join(o) + """".join(list(reversed(o))) + ""1""))
             else:
                 result.append(int(""1"" + """".join(o) + ""0"" + """".join(list(reversed(o))) + ""1""))
                 result.append(int(""1"" + """".join(o) + ""1"" + """".join(list(reversed(o))) + ""1""))
 
     return result
 
 def fillOnes(combination, size, remainingOnes):
     if len(combination) == size:
         return [combination]
     result = []
     if remainingOnes > 0:
         c = combination + [""1""]
         result += fillOnes(c, size, remainingOnes - 1)
     if remainingOnes < size - len(combination):
         c = combination + [""0""]
         result += fillOnes(c, size, remainingOnes)
     return result
 
 
 
 ncases = int(sys.stdin.readline())
 
 for t in range(1, ncases+1):
     fairsquare = 0
     (a, b) = sys.stdin.readline().strip().split("" "")
     intA = int(a)
     intB = int(b)
     ndigitsA = len(a)
     ndigitsB = len(b)
     ndigitsARooted = math.ceil(ndigitsA/2)
     ndigitsBRooted = math.ceil(ndigitsB/2)
 
     if ndigitsBRooted == ndigitsARooted:
         palindromes = findpalindromes(ndigitsARooted)
         for p in palindromes:
             if p ** 2 >= intA and p ** 2 <= intB:
                 fairsquare +=1
     else:
         palindromes = findpalindromes(ndigitsARooted)
         for p in palindromes:
             if p ** 2 >= intA:
                 fairsquare +=1
 
         for i in range(ndigitsARooted + 1, ndigitsBRooted):
             fairsquare += calculatepalindromes(i)
 
         palindromes = findpalindromes(ndigitsBRooted)
         for p in palindromes:
             if p ** 2 <= intB:
                 fairsquare +=1
 
     print(""Case #%d: %d"" % (t, fairsquare))
",40,433,1715
"#!/usr/bin/python3
 
 = {
 'a': 'y',
 'b': 'h',
 'c': 'e',
 'd': 's',
 'e': 'o',
 'f': 'c',
 'g': 'v',
 'h': 'x',
 'i': 'd',
 'j': 'u',
 'k': 'i',
 'l': 'g',
 'm': 'l',
 'n': 'b',
 'o': 'k',
 'p': 'r',
 'q': 'z',
 'r': 't',
 's': 'n',
 't': 'w',
 'u': 'j',
 'v': 'p',
 'w': 'f',
 'x': 'm',
 'y': 'a',
 'z': 'q',
 ' ': ' '
 }
 
 def reverse(string):
 	return ''.join([reverseMappings[c] for c in string])
 
 # Ignore number of tests
 sys.stdin.readline()
 
 casenum=0
 for line in sys.stdin:
 	casenum += 1
 	reversed = reverse(line.strip())
 	print(""Case #%d: %s"" % (casenum, reversed))
",40,434,306
"#!/usr/bin/python3
 #
 # Algorithm:
 # - For boards with one row: you need at least 1 free cells
 # - For boards with two rows, you need either 1 or at least 4 free cells
 #   - It needs to be an even number!
 # - For general boards, you need either 1 or at least 4 free cells (except 5 or 7)
 #
 # - To fill the board, you cannot have a row or a column with only one
 #   free cell, so you fill it in groups of two.
 #
 #   - First you start with the minimum of 4:
 #       c . * * * *
 #       . . * * * *
 #       * * * * * *
 #
 #   - Then you fill next columns and rows two by two:
 #       c . % * * *
 #       . . % * * *
 #       * * * * * *
 #
 #       c . . * * *
 #       . . . * * *
 #       % % * * * *
 #
 #       c . . % * *
 #       . . . % * *
 #       . . * * * *
 #
 #   - In case there's a pending free cell, you simply fill it in the inner board:
 #       c . . . * *
 #       . . . . * *
 #       . . % * * *
 #
 #   - In case you fill the outer border, you simply start filling the inner board:
 #       c . . . . %
 #       . . . . . %
 #       . . * * * *
 #
 #       c . . . . .
 #       . . . . . .
 #       . . % * * *
 #
 
 = int(sys.stdin.readline().strip())
 
 def print_board(r, c, free):
     board = {}
     for row in range(0, r):
         board[row] = {}
         for col in range(0, c):
             board[row][col] = '*'
 
     pending = free
 
     if free == 1:
         board[0][0] = '.'
     elif r == 1 or c == 1:
         for row in range(0, r):
             for col in range(0, c):
                 if pending > 0:
                     pending -= 1
                     board[row][col] = '.'
     else:
         for row in range(0,2):
             for col in range(0,2):
                 board[row][col] = '.'
         pending -= 4
         col=2
         row=2
 
         # First fill the outer border with groups of two
         while pending >= 2 and (col<c or row<r):
             if pending >= 2 and col<c:
                 board[0][col] = '.'
                 board[1][col] = '.'
                 col += 1
                 pending -= 2
             if pending >= 2 and row<r:
                 board[row][0] = '.'
                 board[row][1] = '.'
                 row += 1
                 pending -= 2
 
         # Now fill the inner board with the remaining free cells
         for row in range(2, r):
             for col in range(2, c):
                 if pending > 0:
                     board[row][col] = '.'
                     pending -= 1
 
     # The clicked one is always on the top left corner
     board[0][0] = 'c'
 
     # Finally print the board
     for row in range(0, r):
         line = ''
         for col in range(0, c):
             line += board[row][col]
         print(line)
 
 
 for t in range(1, ncases+1):
     values = sys.stdin.readline().strip().split()
     r = int(values[0])
     c = int(values[1])
     m = int(values[2])
 
     cells = r * c
     free = cells - m
 
     possible = False
 
     if r == 1 or c == 1:
         if free >= 1:
             possible = True
     elif r == 2 or c == 2:
         if free == 1 or (free >= 4 and free%2 == 0):
             possible = True
     else:
         if free == 1 or (free >= 4 and free != 5 and free != 7):
             possible = True
 
     print(""Case #{0}:"".format(t))
 
     if possible:
         print_board(r, c, free)
     else:
         print(""Impossible"")
",40,435,1124
"#!/usr/bin/env python
 
 (fin, n):
     rows = [set(map(int, fin.readline().strip().split())) for i in xrange(4)]
     return rows[n-1]
 
 def solve(rowa, rowb):
     both = rowa & rowb
     if len(both) == 1:
         return list(both)[0]
     elif len(both) > 1:
         return ""Bad magician!""
     elif not both:
         return ""Volunteer cheated!""
 
 if __name__ == '__main__':
     fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin
     fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout
     with fin, fout:
         T = int(fin.readline())
         for case in xrange(1, T+1):
             n = int(fin.readline())
             rowa = read_row(fin, n)
             n = int(fin.readline())
             rowb = read_row(fin, n)
             soln = solve(rowa, rowb)
             print >> fout, ""Case #{0}: {1}"".format(case, soln)
 
",41,436,316
"#!/usr/bin/env python
 (N, M, grid):
     possible = [[False for _ in xrange(M)] for _ in xrange(N)]
     for i in xrange(N):
         m = max(grid[i])
         for j in xrange(M):
             possible[i][j] = possible[i][j] or grid[i][j] == m
 
     for j in xrange(M):
         m = max(grid[_][j] for _ in xrange(N))
         for i in xrange(N):
             possible[i][j] = possible[i][j] or grid[i][j] == m
 
     if all(all(row) for row in possible):
         return ""YES""
     else:
         return ""NO""
 
 if __name__ == '__main__':
     with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:
         T = int(fin.readline())
         for case in xrange(1, T+1):
             print ""Case #{0}:"".format(case)
 
             N, M = map(int, fin.readline().split())
             grid = [map(int, fin.readline().split()) for _ in xrange(N)]
 
             soln = solve(N, M, grid)
             print soln
             print >> fout, ""Case #{0}: {1}"".format(case, soln)
",41,437,359
"(a, b):
     count = 0
     for n in xrange(a, b):
         s = str(n)
         for i in xrange(len(s)):
             m = int(s[i:] + s[:i])
             if n < m <= b:
                 count += 1
     return count
 
 if __name__ == '__main__':
     with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:
         T = int(fin.readline())
         for case in xrange(1, T+1):
             a, b = map(int, fin.readline().split())
             print >> fout, ""Case #{0}: {1}"".format(case, solve(a, b))
",41,438,192
"#!/usr/bin/env python
 (grid):
     for i in xrange(4):
         yield list(grid[i]) # row i
         yield [grid[x][i] for x in xrange(4)] # column i
     yield [grid[x][x] for x in xrange(4)] # major diagonal
     yield [grid[x][3-x] for x in xrange(4)] # minor diagonal
 
 def solve(grid):
     for x in fours(grid):
         if set(x) in ({'X', 'T'}, {'X'}):
             return ""X won""
         elif set(x) in ({'O', 'T'}, {'O'}):
             return ""O won""
     if any('.' in x for x in grid):
         return ""Game has not completed""
     else:
         return ""Draw""
 
 if __name__ == '__main__':
     with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:
         T = int(fin.readline())
         for case in xrange(1, T+1):
 
             grid = [fin.readline().strip() for _ in xrange(4)]
             assert fin.readline().strip() == ''
 
             soln = solve(grid)
             print >> fout, ""Case #{0}: {1}"".format(case, soln)
",41,439,340
"#!/usr/local/bin/python3
 (n, s, p, scores):
     count = 0
     for t in scores:
         if ceil(t/3) >= p:
             # This one must have a best score, even if it wasn't surprising.
             count += 1
         elif 2 <= t <= 28 and ceil((t+2)/3) >= p and s > 0:
             # This one could be surprising
             count += 1
             s -= 1
     return count
 
 if __name__ == '__main__':
     with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:
         T = int(fin.readline())
         for case in range(1, T+1):
             line = map(int, fin.readline().split())
             n, s, p, *scores = line
             result = solve(n, s, p, scores)
             print(""Case #{0}: {1}"".format(case, result), file=fout)
",41,440,259
"#!/usr/bin/env python
 ():
     # it's not straightforward to get the numbers in order...
     for digits in count(1):
         for n in xrange(10**(digits-1), 10**digits):
             n = str(n)
             yield int(n + n[-2::-1])
         for n in xrange(10**(digits-1), 10**digits):
             n = str(n)
             yield int(n + n[::-1])
 
 def is_palindrome(n):
     n = str(n)
     return n == n[::-1]
 
 def solve(A, B):
     # Loop through palindromic numbers and check that their squares are palindromes.
     count = 0
     for n in palindromes():
         square = n**2
         if square > B:
             break
         if square >= A and is_palindrome(square):
             count += 1
     return count
 
 if __name__ == '__main__':
     with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:
         T = int(fin.readline())
         for case in xrange(1, T+1):
 
             A, B = map(int,fin.readline().split())
             soln = solve(A, B)
 
             print >> fout, ""Case #{0}: {1}"".format(case, soln)
",41,441,372
"= maketrans(""y qee""
                  ""ejp mysljylc kd kxveddknmc re jsicpdrysi""
                  ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd""
                  ""de kr kd eoya kw aej tysr re ujdr lkgc jv""
                  ""z"",
                  ""a zoo""
                  ""our language is impossible to understand""
                  ""there are twenty six factorial possibilities""
                  ""so it is okay if you want to just give up""
                  ""q"")
 
 if __name__ == '__main__':
     with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:
         T = int(fin.readline())
         for case in xrange(1, T+1):
             line = fin.readline().strip('\n')
             decrypted = translate(line, code)
             print >> fout, ""Case #{0}: {1}"".format(case, decrypted)",41,442,266
"#!/usr/bin/env python
 
 = []
 
 def transpose(grid):
     return map(list, zip(*grid))
 
 def find_grid(R, C, M):
     """"""Return a grid of a solution, if one exists, otherwise []
 
     Observations:
     * WLOG, C <= R (otherwise, take the transpose of a solution)
     * Trivial cases are:
       - M = 0 or  M = RC - 1
       - C = 1
       - (R, C) = (2, 2)
       - (R, C, M) = (3, 3, 2)
       - (C, M) = (2, 1)
     * If M >= C >= 2 and R >= 3, we can add a row of C mines to the bottom and consider M'=M-C, R'=R-1
     * The remaining cases are M <= R-2, and M + 1 == R == C >= 4, which are both solvable
     """"""
     # Take care of simple cases
     if M == 0:
         #print ""zero "", R, C, M
         grid = [['.' for c in xrange(C)] for r in xrange(R)]
         grid[0][0] = 'c'
         return grid
     elif M == R * C - 1:
         #print ""full "", R, C, M
         grid = [['*' for c in xrange(C)] for r in xrange(R)]
         grid[0][0] = 'c'
         return grid
     elif C > R:
         #print ""trans"", R, C, M
         return transpose(find_grid(C, R, M))
     elif C == 1:
         #print ""C=1  "", R, C, M
         return [['c']] + [['.'] for i in xrange(R-M-1)] + [['*'] for i in xrange(M)]
     elif (R, C) == (2, 2) or (R, C, M) == (3, 3, 2) or (C, M) == (2, 1):
         #print ""impos"", R, C, M
         return IMPOSSIBLE
 
     assert 2 <= C <= R >= 3, ""R={} C={} M={}"".format(R, C, M)
 
     if M >= C:
         #print ""M>=C "", R, C, M
         s = find_grid(R-1, C, M-C)
         return s and s + [['*' for c in xrange(C)]]
     elif M <= R-2 and C >= 3:
         #print ""M+1<R"", R, C, M
         grid = [['.' for c in xrange(C)] for r in xrange(R)]
         grid[0][0] = 'c'
         for i in xrange(M):
             grid[R-i-1][C-1] = '*'
         return grid
     elif M + 1 == R == C >= 4:
         #print ""M+1=R"", R, C, M
         grid = [['.' for c in xrange(C)] for r in xrange(R)]
         grid[0][0] = 'c'
         grid[R-1][C-2] = '*'
         for i in xrange(M-1):
             grid[R-i-1][C-1] = '*'
         return grid
 
     assert False, ""R={} C={} M={}"".format(R, C, M)
 
 def check_soln(grid, R, C, M):
     """"""checking, because debugging...""""""
     error = ""R={} C={} M={}"".format(R, C, M)
     assert sum(row.count('*') for row in grid) == M, error
     assert sum(row.count('c') for row in grid) == 1, error
     assert len(grid) == R, error
     assert all(len(row) == C for row in grid), error
     _ = [i for i, row in enumerate(grid) if 'c' in row][0]
     click = (_, [i for i, c in enumerate(grid[_]) if c == 'c'][0])
 
     def neighbours(r, c):
         ns = [(i, j) for i in range(max(r-1,0),min(r+2,R)) for j in range(max(c-1,0),min(c+2,C))]
         ns.remove((r, c))
         return ns
 
     cpy = map(list, grid)
     def fill(cpy, pos):
         cpy[pos[0]][pos[1]] = str(sum(1 for i, j in neighbours(*pos) if grid[i][j] == '*'))
         if cpy[pos[0]][pos[1]] == '0':
             for i, j in neighbours(*pos):
                 if cpy[i][j] == '.':
                     fill(cpy, (i, j))
     fill(cpy, click)
     assert sum(row.count('.') for row in cpy) == 0, error
 
 def solve(R, C, M):
     soln = find_grid(R, C, M)
     if soln == IMPOSSIBLE:
         return ""Impossible""
     else:
         check_soln(soln, R, C, M)
         return '\n'.join(''.join(row) for row in soln)
 
 if __name__ == '__main__':
     fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin
     fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout
     with fin, fout:
         T = int(fin.readline())
         for case in xrange(1, T+1):
             r, c, m = map(int, fin.readline().split())
             soln = solve(r, c, m)
             print >> fout, ""Case #{0}:\n{1}"".format(case, soln)
 
",41,443,1519
"#!/usr/bin/env python
 
 (c, f, x):
     time = 0
     cps = 2.0
     while True:
         time_to_farm = c / cps
         time_to_end = x / cps
         buy_a_farm = (time_to_farm + x / (cps + f)) < time_to_end
         #print time_to_farm, time_to_end, (time_to_farm + x / (cps + f)), buy_a_farm
         if buy_a_farm:
             time += time_to_farm
             cps += f
         else:
             time += time_to_end
             return time
 
 if __name__ == '__main__':
     fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin
     fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout
     with fin, fout:
         T = int(fin.readline())
         for case in xrange(1, T+1):
             c, f, x = map(float, fin.readline().split())
             soln = solve(c, f, x)
             print >> fout, ""Case #{0}: {1:.7f}"".format(case, soln)
 
",41,444,338
"#!/usr/bin/python
 
 (row1, row2):
     common = [x for x in row1 if x in row2]
     num_common = len(common)
     if num_common == 0:
         return 'Volunteer cheated!'
     elif num_common > 1:
         return 'Bad magician!'
     else:
         return common[0]
 
 def main():
     N = int(sys.stdin.readline()) # number of testcases
     for i in range(N):
         row_index1 = int(sys.stdin.readline())
         row1 = list()
         for j in range(4):
             if row_index1 == j + 1:
                 row1 = [int(x) for x in sys.stdin.readline().rstrip().split()]
             else:
                 sys.stdin.readline()
 
         row_index2 = int(sys.stdin.readline())
         row2 = list()
         for j in range(4):
             if row_index2 == j + 1:
                 row2 = [int(x) for x in sys.stdin.readline().rstrip().split()]
             else:
                 sys.stdin.readline()
 
         result = solve(row1, row2)
         print (""Case #%s: %s"" % (i+1, result))
 
 if __name__ == '__main__':
     main()
",42,445,354
"#!/usr/bin/python
 
 (M, a, b):
     rowmax = [max(r) for r in M]
     colmax = [max([M[j][i] for j in range(a)]) for i in range(b)]
     rowmin = [min(r) for r in M]
     colmin = [min([M[j][i] for j in range(a)]) for i in range(b)]
 
     for i in range(a):
         for j in range(b):
             if M[i][j] != min(rowmax[i], colmax[j]):
                 return 'NO'
     return 'YES'
 
 def main():
     N = int(sys.stdin.readline()) # number of testcases
     for i in range(N):
         [a,b] = [int(x) for x in sys.stdin.readline().rstrip().split()]
         M = []
         for j in range(a):
             M += [[int(x) for x in sys.stdin.readline().split()]]
         result = solve(M, a, b)
         print (""Case #%s: %s"" % (i+1, result))
 
 
 if __name__ == '__main__':
     main()
",42,446,312
"#!/usr/bin/python
 
 (a,b):
     num_recycled = 0
     for n in range(a, b+1):
         s = str(n)
         pairs = []
         for i in range(1,len(s)):
             m = int(s[i:] + s[:i])
             #print(""checking "" + str(m))
             if n < m and m <= b and m not in pairs:
                 num_recycled += 1
                 pairs.append(m)
     return num_recycled
         
 
 def main():
     N = int(sys.stdin.readline()) # number of testcases
     for i in range(N):
         [a, b] = [int(x) for x in sys.stdin.readline().split()]
         result = solve(a,b)
         print (""Case #%s: %s"" % (i+1, result))
 
 
 if __name__ == '__main__':
     main()
",42,447,246
"#!/usr/bin/python
 
 (l):
     xcount = 0
     ocount = 0
     empty = False
     for field in l:
         if field == 'X' or field == 'T':
             xcount += 1
         if field == 'O' or field == 'T':
             ocount += 1
         if field == '.':
             empty = True
 
     if xcount == 4:
         return 'X'
     if ocount == 4:
         return 'O'
     if empty:
         return '.'
     else:
         return ''
 
 def solve(M):
     # check rows
     empty = False
     for i in range(4):
         r = result(M[i])
         if (r == 'X' or r == 'O'):
             return r + ' won'
         if r == '.':
             empty = True
 
     # check columns
     for i in range(4):
         r = result([M[j][i] for j in range(4)])
         if (r == 'X' or r == 'O'):
             return r + ' won'
 
     # check diagonals
     r = result([M[i][i] for i in range(4)])
     if (r == 'X' or r == 'O'):
         return r + ' won'
     r = result([M[i][3-i] for i in range(4)])
     if (r == 'X' or r == 'O'):
         return r + ' won'
 
     # determine whether it's a draw
     if empty:
         return 'Game has not completed'
     else:
         return 'Draw'
 
 def main():
     N = int(sys.stdin.readline()) # number of testcases
     for i in range(N):
         M = []
         for j in range(4):
             M += [list(sys.stdin.readline().rstrip())]
         sys.stdin.readline()
         result = solve(M)
         print (""Case #%s: %s"" % (i+1, result))
 
 if __name__ == '__main__':
     main()
",42,448,529
"#!/usr/bin/python
 
 (num_surprises, p, ts):
     s = 0
     u = 0
     for t in ts:
         a = int(t/3)
         r = t % 3
         if a+1 >= p and not r == 0:
             u += 1
         elif a >= p and r == 0:
             u += 1
         elif a > 0 and a+1 >= p and r == 0:
             s += 1
         elif a+2 >= p and r == 2:
             s += 1
 
     return min(num_surprises, s) + u
         
         
 
 def main():
     N = int(sys.stdin.readline()) # number of testcases
     for i in range(N):
         line = [int(x) for x in sys.stdin.readline().split()]
         num_surprises = line[1]
         p = line[2]
         ts = line[3:]
         result = solve(num_surprises, p, ts)
         print (""Case #%s: %s"" % (i+1, result))
 
 
 if __name__ == '__main__':
     main()
",42,449,303
"#!/usr/bin/python
 
 (n_weights, k_weights):
     nweights = sorted(n_weights)
     kweights = sorted(k_weights)
     score = 0
     
     # while nweights:
     #     w = nweights.pop(0)
     #     res = [kweight for kweight in kweights if kweight > w]
     #     if res:
     #         kweights.remove(min(res))
     #     else:
     #         score += len(nweights) + 1
     #         break
 
     for w in nweights:
         while kweights and kweights[0] < w:
             kweights.pop(0)
             score += 1
 
         if not kweights:
             break
         else:
             kweights.pop(0)
             
     return score
 
 def solveDWar(n_weights, k_weights):
     nweights = sorted(n_weights)
     kweights = sorted(k_weights)
     score = 0
 
     for w in nweights:
         if w > kweights[0]:
             score += 1
             kweights.pop(0)
         else:
             kweights.pop(-1)
     
     return score
 
 def solve(nweights, kweights):
     return (""%s %s"" % (solveDWar(nweights, kweights), solveWar(nweights, kweights)))
 
 def main():
     N = int(sys.stdin.readline()) # number of testcases
     for i in range(N):
         sys.stdin.readline()
         nweights = [float(x) for x in sys.stdin.readline().rstrip().split()]
         kweights = [float(x) for x in sys.stdin.readline().rstrip().split()]
 
         result = solve(nweights, kweights)
         print (""Case #%s: %s"" % (i+1, result))
 
 if __name__ == '__main__':
     main()
",42,450,535
"#!/usr/bin/python
 
 (n):
     l = str(n)
     return l == l[::-1]
 
 def solve(a, b):
     l = int(math.ceil(math.sqrt(a)))
     u = int(math.floor(math.sqrt(b)))
 
     count = 0
     for x in range(l, u + 1):
         if isPal(x):
             if isPal(x*x):
                 count += 1
     return str(count)
 
 def main():
     N = int(sys.stdin.readline()) # number of testcases
     for i in range(N):
         [a,b] = [int(x) for x in sys.stdin.readline().rstrip().split()]
         result = solve(a, b)
         print (""Case #%s: %s"" % (i+1, result))
 
         # use something like:
         # sys.stdin.readline()
         # [int(x) for x in sys.stdin.readline().split()]
 
 
 if __name__ == '__main__':
     main()
",42,451,282
"#!/usr/bin/python
 
 = {'a': 'y',
          'b': 'h',
          'c': 'e',
          'd': 's',
          'e': 'o',
          'f': 'c',
          'g': 'v',
          'h': 'x',
          'i': 'd',
          'j': 'u',
          'k': 'i',
          'l': 'g',
          'm': 'l',
          'n': 'b',
          'o': 'k',
          'p': 'r',
          'q': 'z',
          'r': 't',
          's': 'n',
          't': 'w',
          'u': 'j',
          'v': 'p',
          'w': 'f',
          'x': 'm',
          'y': 'a',
          'z': 'q',
          ' ': ' ',
          '\n': ''}
 
 def solve(s):
     return ''.join([table[c] for c in s])
         
 
 def main():
     N = int(sys.stdin.readline()) # number of testcases
     for i in range(N):
         # use something like:
         # sys.stdin.readline()
         # [int(x) for x in sys.stdin.readline().split()]
         result = solve(sys.stdin.readline())
         print (""Case #%s: %s"" % (i+1, result))
 
 
 if __name__ == '__main__':
     main()
",42,452,384
"#!/usr/bin/python
 
 (grid, (i, j), n, m):
     for a in range(max(i-1, 0), min(i+2, n)):
         for b in range(max(j-1, 0), min(j+2, m)):
             if (a != i or b != j):
                 yield (a, b)
 
 def isGridCorrect(grid):
     g = list(grid)
     n = len(g)
     m = len(g[0])
     queue = [(0, 0)]
 
     while queue:
         v = queue.pop(0)
         g[v[0]][v[1]] = 'r'
         bomb = False
         for (i, j) in neighbours(g, v, n, m):
             if g[i][j] == '*':
                 bomb = True
         if not bomb:
             for (i, j) in neighbours(g, v, n, m):
                 if g[i][j] != 'r':
                     #print('append')
                     queue.append((i, j))
 
     for i in range(n):
         for j in range(m):
             if g[i][j] != 'r' and g[i][j] != '*':
                 #print draw(g)
                 return 'WRONG'
 
     return 'Right'
 
 def createGrid(R, C, s):
     field = []
     for i in range(R):
         field.append([s] * C)
     field[0][0] = 'c'
     return field
 
 def draw(grid):
     s = """"
     for row in grid:
         s += ""\n"" + ''.join(row)
     return s
 
 def reduceRows(grid, k, l, M):
     if k <= 2:
         return (grid, k, l, M)
     
     #num_rows = M / l
     #lowest = max(k - num_rows, 2)
     #num_rows = k - lowest
 
     #print('k: ' + str(k))
     #print('l: ' + str(l))
     for j in range(l):
         #print grid
         #print i, j
         grid[k-1][j] = '*'
     k -= 1
     M -= l
     return (grid, k, l, M)
 
 def reduceCols(grid, k, l, M):
     if l <= 2:
         return (grid, k, l, M)
     
     #num_cols = M / k
     #lowest = max(l - num_cols, 2)
     #num_cols = l - lowest
 
     for i in range(k):
         grid[i][l-1] = '*'
     l -= 1
     M -= k
     return (grid, k, l, M)
 
 def solve(R, C, M):
     mp = M
     if M == 0:
         f = createGrid(R, C, '.')
         #print(isGridCorrect(f))
         return draw(f)
     elif M == R*C - 1:
         f = createGrid(R, C, '*')
         #print(isGridCorrect(f))
         return draw(f)
     elif (R == 2 or C == 2) and (M % 2 == 1 or M == R*C - 2):
         return ""\n"" + 'Impossible' #+ '1: ' + str(R) + ' ' + str(C) + ' ' + str(mp)
     elif R > 2 and C > 2 and (M == R*C - 2 or M == R*C - 3 or M == R*C - 5 or M == R*C - 7):
         return ""\n"" + 'Impossible' #+ '2: ' + str(R) + ' ' + str(C) + ' ' + str(mp)
     else:
         grid = createGrid(R, C, '.')
 
         #print('R: ' + str(R))
         #print('C: ' + str(C))
 
         k = R
         l = C
 
         while (M >= l and k > 2) or (M >= k and l > 2):
             if l >= k:
                 #print('l >= k')
                 (grid, k, l, M) = reduceCols(grid, k, l, M)
                 #print grid
                 #print k, l, M
             elif k > l:
                 #print('k > l')
                 (grid, k, l, M) = reduceRows(grid, k, l, M)
                 #print grid
                 #print k, l, M
 
         #print(grid)
         #print M
 
         if M == 0:
             #print(isGridCorrect(grid))
             return draw(grid)
         if M < l - 1 and k > 2:
             for j in range(l - M, l):
                 grid[k-1][j] = '*'
         elif M < k - 1 and l > 2:
             for i in range(k - M, k):
                 grid[i][l-1] = '*'
         elif l > 3 and k > 3:
             for i in range(2, k):
                 grid[i][l-1] = '*'
             M -= k - 2
             for j in range(l - M - 1, l - 1):
                 grid[k-1][j] = '*'
         else:
             return ""\n"" + 'Impossible' #+ '3: ' + str(R) + ' ' + str(C) + ' ' + str(mp)
 
         #print(isGridCorrect(grid))
         return draw(grid)
 
 def main():
     N = int(sys.stdin.readline()) # number of testcases
     for i in range(N):
         [R, C, M] = [int(x) for x in sys.stdin.readline().rstrip().split()]
 
         result = solve(R, C, M)
         print (""Case #%s:%s"" % (i+1, result))
 
 if __name__ == '__main__':
     main()
",42,453,1550
"== ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         n, m = map(int, f.readline().split())
         b = []
         for i in xrange(n):
             b.append(map(int, f.readline().split()))
             assert len(b[-1]) == m
         # print b
 
         max_h = [0] * n
         max_v = [0] * m
 
         for i in xrange(n):
             for j in xrange(m):
                 t = b[i][j]
                 max_h[i] = max(max_h[i], t)
                 max_v[j] = max(max_v[j], t)
         can = True
         for i in xrange(n):
             if not can:
                 break
             for j in xrange(m):
                 t = b[i][j]
                 if max_h[i] > t and max_v[j] > t:
                     can = False
                     break
 
         print ""Case #%d: %s"" % (_t+1, ""YES"" if can else ""NO"")
",43,454,340
"== ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         a, b = map(int, f.readline().split())
 
         total = 0
         for i in xrange(a, b):
             # print i
             s = set()
             cs = str(i)
             for j in xrange(1, len(cs)):
                 k = int(cs[j:] + cs[:j])
                 if i < k <= b:
                     s.add(k)
             # print s
             # print
             total += len(s)
 
         print ""Case #%d: %d"" % (_t + 1, total)
",43,455,220
"== ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         m = []
         for i in xrange(4):
             l = f.readline().strip()
             assert len(l) == 4
             m.append(l)
         f.readline()
 
         def check(x, y, dx, dy):
             s = set()
             for i in xrange(4):
                 s.add(m[x][y])
                 x += dx
                 y += dy
             # print x, y, dx, dy, s
             if 'T' in s:
                 s.remove('T')
             if '.' in s:
                 return None
             if len(s) == 1:
                 return list(s)[0]
             return None
 
         winner = None
         for i in xrange(4):
             winner = winner or check(0, i, 1, 0)
             winner = winner or check(i, 0, 0, 1)
         winner = winner or check(0, 0, 1, 1)
         winner = winner or check(0, 3, 1, -1)
 
         print ""Case #%d:"" % (_t+1),
         if winner:
             print ""%s won"" % winner
         elif any('.' in l for l in m):
             print ""Game has not completed""
         else:
             print ""Draw""
",43,456,402
"== ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         ns = map(int, f.readline().split())
         n = ns[0]
         s = ns[1]
         p = ns[2]
         assert len(ns) == n + 3
         scores = ns[3:3+n]
 
         sure = 0
         if_surprising = 0
         for x in scores:
             not_surprising = (x + 2) / 3
             is_surprising = (x + 4) / 3
             if not_surprising >= p:
                 sure += 1
             elif (2 <= x <= 28) and is_surprising >= p:
                 if_surprising += 1
         print ""Case #%d: %d"" % (_t+1, sure + min(if_surprising, s))
",43,457,277
"== ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N = int(f.readline())
         naomi = map(float, f.readline().split())
         ken = map(float, f.readline().split())
         assert len(ken) == len(naomi) == N
 
         naomi = [(w, 1) for w in naomi]
         ken = [(w, 0) for w in ken]
 
         blocks = ken + naomi
         blocks.sort(reverse=True)
         blocks = [p[1] for p in blocks]
         # print blocks
 
         honest = 0
         adv = 0
         for b in blocks:
             if b == 1:
                 adv += 1
                 honest = max(honest, adv)
             else:
                 adv -= 1
 
         deceitful = 0
         kept = 0
         for b in blocks:
             if b == 1:
                 kept += 1
             else:
                 if kept:
                     kept -= 1
                     deceitful += 1
         print ""Case #%d: %d %d"" % (_T+1, deceitful, honest)
",43,458,355
"(n):
     s = str(n)
     return s == s[::-1]
 
 def ispalsq(n):
     sqrt = int(math.sqrt(n) + .01)
     if sqrt ** 2 != n:
         return False
     return ispal(n) and ispal(sqrt)
 
 def search(s, l, idx):
     if l % 2 == 0:
         m = s + s[::-1]
     else:
         m = s[:-1] + s[::-1]
     assert ispal(m)
     n = int(m) ** 2
     if not ispal(n):
         # print m, False
         return 0
     # print m, int(m)**2
 
     r = 1 if (a <= n <= b) else 0
     for i in xrange(idx, len(s)):
         s2 = list(s)
         s2[i] = str(int(s2[i])+1)
         s2 = ''.join(s2)
         r += search(s2, l, i)
     return r
 
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         a, b = map(int, f.readline().split())
 
         total = 0
         for l in xrange(1, 150):
             if 10 ** (l-1) > b:
                 break
             total += search(""1"" + ""0"" * ((l-1)/2), l, 0)
         print ""Case #%d: %d"" % (_t+1, total)
 
",43,459,469
"= {
         'a':'y',
         'o':'e',
         'z':'q',
         ' ':' ',
         'r':'p',
         'l':'m',
         'n':'s',
         'g':'l',
         'u':'j',
         'e':'c',
         'i':'k',
         's':'d',
         'm':'x',
         'p':'v',
         't':'r',
         'd':'i',
         'b':'n',
         'h':'b',
         'w':'t',
         'y':'a',
         'x':'h',
         'f':'w',
         'c':'f',
         'k':'o',
         'j':'u',
         'v':'g',
         'q':'z',
         '\n':'\n',
         }
 
 r = dict((v,k) for (k,v) in d.items())
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     f.readline()
     i = 1
     for l in f:
         sys.stdout.write(""Case #%d: "" % i)
         for c in l:
             # sys.stdout.write(r.get(c, '?'))
             sys.stdout.write(r[c])
         i += 1
 
",43,460,367
"== ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         R, C, M = map(int, f.readline().split())
 
         # print R, C, M
         print ""Case #%d:"" % (_T+1)
 
         left = R * C - M
 
         if R == 1:
             s = 'c'
             s += '.' * (left - 1)
             s += '*' * M
             print s
             continue
         if C == 1:
             print 'c'
             for i in xrange(left - 1):
                 print '.'
             for i in xrange(M):
                 print '*'
             continue
 
         if left == 1:
             print 'c' + '*' * (C-1)
             for i in xrange(R-1):
                 print '*' * C
             continue
 
         if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):
             print ""Impossible""
             continue
         if R == 2:
             assert left not in (2, 3, 5, 7)
             assert left >= 4
             print 'c' + '.' * (left/2 - 1) + '*' * (M/2)
             print '.' + '.' * (left/2 - 1) + '*' * (M/2)
             continue
         if C == 2:
             assert left >= 4
             assert left not in (2, 3, 5, 7)
             print 'c.'
             left -= 2
             R -= 1
             while left:
                 print '..'
                 left -= 2
                 R -= 1
             assert R >= 0
             while R:
                 print '**'
                 R -= 1
             continue
 
         assert R >= 3
         assert C >= 3
 
         if left == 4:
             print 'c.' + '*' * (C-2)
             print '..' + '*' * (C-2)
             for i in xrange(R-2):
                 print '*' * C
             continue
 
         if left in (2, 3, 5, 7):
             print ""Impossible""
             continue
 
         assert left >= 6
 
         cols = max(3, (left + R-1) // R)
 
         if left % cols == 1:
             assert left >= 10
 
             print 'c' + '.' * (cols - 1) + '*' * (C - cols)
             left -= cols
             R -= 1
 
             while left > cols + 1:
                 print '.' * cols + '*' * (C - cols)
                 left -= cols
                 R -= 1
             assert left == cols + 1
             print '.' * (cols - 1) + '*' * (C - cols + 1)
             print '.' * (2) + '*' * (C - 2)
             R -= 2
 
             assert R >= 0
 
             while R:
                 print '*' * C
                 R -= 1
             continue
         else:
             assert left >= 6
 
             print 'c' + '.' * (cols - 1) + '*' * (C - cols)
             left -= cols
             R -= 1
 
             while left > cols:
                 print '.' * cols + '*' * (C - cols)
                 left -= cols
                 R -= 1
             assert left >= 2
             print '.' * (left) + '*' * (C - left)
             R -= 1
 
             assert R >= 0
 
             while R:
                 print '*' * C
                 R -= 1
             continue
 
         1/0
",43,461,1002
"== ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         C, F, X = map(float, f.readline().split())
 
         cps = 2.0
         t = 0.0
         best_t = X / cps
 
         while True:
             t += C / cps
             if t >= best_t:
                 break
 
             cps += F
             best_t = min(best_t, t + X / cps)
 
         print ""Case #%d: %.7f"" % (_T+1, best_t)
",43,462,204
"(unittest.TestCase):
 	def test_1(self):
 		self.assertEqual(main(5, 2, 2, [2,1]), 12)
 	def test_2(self):
 		self.assertEqual(main(5,2,2,[1,2]), 12)
 	def test_3(self):
 		self.assertEqual(main(3,3,4,[4,1,3,5]), 39)
 	def test_4(self):
 		self.assertEqual(main(5,2,4,[5, 1, 1, 5]), 51)
 
 
 #tCase = sys.stdin.readline().split()
 tCase = int(sys.stdin.readline())
 
 def main(A, B, AList, BList):
 	resp = 0
 	A = A - 1
 	B = B - 1
 	Alist = AList[A*4:A*4+4]
 	BList = BList[B*4:B*4+4]
 	cont = 0
 	#print Alist, BList
 	for aa in Alist:
 		if aa in BList:
 			resp = aa
 			cont += 1
 		
 	if cont == 1:
 		return resp
 	elif cont == 0:
 		return ""Volunteer cheated!""
 	else:
 		return ""Bad magician!""
 		
  
 if __name__ == '__main__':
 	#unittest.main()
 	for i in xrange(tCase):	
 		#frase = [str(x) for x in sys.stdin.readline().split(' ')]	
 		#print ""Case #%d: %s"" % (i + 1, main(frase[0]))
 		
 		##Numbers
 		A = [int(x) for x in sys.stdin.readline().split(' ')][0]
 		NList = [int(x) for x in sys.stdin.readline().split(' ')]
 		NList += [int(x) for x in sys.stdin.readline().split(' ')]
 		NList += [int(x) for x in sys.stdin.readline().split(' ')]
 		NList += [int(x) for x in sys.stdin.readline().split(' ')]
 		B = [int(x) for x in sys.stdin.readline().split(' ')][0]
 		BList = [int(x) for x in sys.stdin.readline().split(' ')]
 		BList += [int(x) for x in sys.stdin.readline().split(' ')]
 		BList += [int(x) for x in sys.stdin.readline().split(' ')]
 		BList += [int(x) for x in sys.stdin.readline().split(' ')]
 		#print A, B, NList, BList
 		print ""Case #%d: %s"" % (i + 1, main(A, B, NList, BList))",44,463,808
"= int(sys.stdin.readline())
 
 def alien(numbers):
 	resul = 0
 	A = int(numbers[0])
 	B = int(numbers[1])
 
 	for n in range(A,B-1):
 		for m in range(n+1,B+1):
 			#print n,m
 			if (len(str(n)) == len(str(m))):
 				resul += isRecycled(str(n),str(m))
 	
 
 
 	return resul
 	
 def isRecycled(n,m):
 	if len(n) < 2:
 		return 0
 		
 	for c in m:
 		if c not in n:
 			return 0
 
 	for i in range (1, len(n)):
 		mi = m[i:] + m[-len(m):-(len(m)-i)]
 		if n == mi:
 			return 1
 	
 	return 0
 
 
 lines = []
 for i in xrange(tCase):
 	line = sys.stdin.readline().split()
 	lines.append((line[0],line[1]))
 	
 
 for i in xrange(tCase):	
 	#case.append(frase)
 	print ""Case #%d: %s"" % (i+1, alien(lines[i]))
 	
 	
 
",44,464,388
"(unittest.TestCase):
 	def test_1(self):
 		self.assertEqual(main('XXXT', '....', 'OO..', '....'), 'X won')
 	def test_2(self):
 		self.assertEqual(main('XOXT', 'XXOO', 'OXOX', 'XXOO'), 'Draw')
 	def test_3(self):
 		self.assertEqual(main('XOX.', 'OX..', '....', '....'), 'Game has not completed')
 	def test_4(self):
 		self.assertEqual(main('OOXX', 'OXXX', 'OX.T', 'O..O'), 'O won')
 	def test_5(self):
 		self.assertEqual(main('XXXO', '..O.', '.O..', 'T...'), 'O won')
 	def test_6(self):
 		self.assertEqual(main('OXXX', 'XO..', '..O.', '...O'), 'O won')
 
 #tCase = sys.stdin.readline().split()
 tCase = int(sys.stdin.readline())
 
 def main(l1, l2, l3, l4):
 	
 	resul = ganhador(l1[0], l1[1], l1[2], l1[3])
 	
 	if resul == 0:
 		return 'X won'
 	elif resul == 1:
 		return 'O won'
 		
 	resul = ganhador(l2[0], l2[1], l2[2], l2[3])
 	
 	if resul == 0:
 		return 'X won'
 	elif resul == 1:
 		return 'O won'
 		
 	resul = ganhador(l3[0], l3[1], l3[2], l3[3])
 	
 	if resul == 0:
 		return 'X won'
 	elif resul == 1:
 		return 'O won'
 		
 	resul = ganhador(l4[0], l4[1], l4[2], l4[3])
 	
 	if resul == 0:
 		return 'X won'
 	elif resul == 1:
 		return 'O won'
 		
 	# coluna
 	resul = ganhador(l1[0], l2[0], l3[0], l4[0])
 	
 	if resul == 0:
 		return 'X won'
 	elif resul == 1:
 		return 'O won'
 
 	resul = ganhador(l1[1], l2[1], l3[1], l4[1])
 	
 	if resul == 0:
 		return 'X won'
 	elif resul == 1:
 		return 'O won'
 
 	resul = ganhador(l1[2], l2[2], l3[2], l4[2])
 	
 	if resul == 0:
 		return 'X won'
 	elif resul == 1:
 		return 'O won'
 
 	resul = ganhador(l1[3], l2[3], l3[3], l4[3])
 	
 	if resul == 0:
 		return 'X won'
 	elif resul == 1:
 		return 'O won'
 
 	# /
 	resul = ganhador(l1[3], l2[2], l3[1], l4[0])
 	
 	if resul == 0:
 		return 'X won'
 	elif resul == 1:
 		return 'O won'
 
 	# \
 	resul = ganhador(l1[0], l2[1], l3[2], l4[3])
 	
 	if resul == 0:
 		return 'X won'
 	elif resul == 1:
 		return 'O won'
 	
 	if '.' in l1 or '.' in l2 or '.' in l3 or '.' in l4:
 		return 'Game has not completed'
 	else:
 		return 'Draw'
 	
 	
 def ganhador(a, b, c, d):
 	x = 0
 	o = 0
 	p = 0
 	if a == 'X':
 		x += 1
 		p += 1
 	if a == 'O':
 		o += 1
 		p += 1
 	if a == 'T':
 		x += 1
 		o += 1
 		p += 1
 	if b == 'X':
 		x += 1
 		p += 1
 	if b == 'O':
 		o += 1
 		p += 1
 	if b == 'T':
 		x += 1
 		o += 1
 		p += 1
 	if c == 'X':
 		x += 1
 		p += 1
 	if c == 'O':
 		o += 1
 		p += 1
 	if c == 'T':
 		x += 1
 		o += 1
 		p += 1
 	if d == 'X':
 		x += 1
 		p += 1
 	if d == 'O':
 		o += 1
 		p += 1
 	if d == 'T':
 		x += 1
 		o += 1
 		p += 1	
 	if x == 4:
 		return 0
 	elif o == 4:
 		return 1
 	elif p == 4:
 		return 2
 	else: # incompleto
 		return 3
  
 if __name__ == '__main__':
 	#unittest.main()
 	for i in xrange(tCase):	
 		l1 = [str(x) for x in sys.stdin.readline().split(' ')]
 		l2 = [str(x) for x in sys.stdin.readline().split(' ')]	
 		l3 = [str(x) for x in sys.stdin.readline().split(' ')]	
 		l4 = [str(x) for x in sys.stdin.readline().split(' ')]
 		nulo = [str(x) for x in sys.stdin.readline().split(' ')]		
 		print ""Case #%d: %s"" % (i + 1, main(l1[0], l2[0], l3[0], l4[0]))
 		
 		##Numbers
 		#N,M = [int(x) for x in sys.stdin.readline().split(' ')]	
 		#print ""Case #%d: %d"" % (i + 1, main(N,M))",44,465,1842
"= int(sys.stdin.readline())
 
 def alien(frases,case):
 	
 	case = case.replace('(','[')
 	case = case.replace(')',']')
 	#print frases,case
 	
 	ER1 = re.compile(case, re.I)
 	count = 0
 	for frase in frases:
 		#print ER1.search(frase)
 		if ER1.search(frase):
 			count += 1
 	return count
 
 
 for i in xrange(tCase):	
 	linha = sys.stdin.readline().split()
 	#S = linha[0]
 	P = int(linha[1])
 	T = int(linha[2])
 	list = []
 	for j in range (3,len(linha)):
 		list.append(int(linha[j]))
 	list.sort(reverse=True)
 	#print S,P,T,list
 	realT = T*3 - 2
 	supT = realT - 2
 	
 	count = 0
 	for item in list:
 		if item >= realT:
 			count += 1
 		elif P > 0 and item >= supT and T >= 2:
 			count += 1
 			P -= 1
 		elif P > 0 and item >= realT and T == 1:
 			count += 1
 			P -= 1
 		elif T == 0:
 			count += 1
 		else:
 			break
 		
 	#case.append(frase)
 	print ""Case #%d: %d"" % (i+1, count)
 	
 	
 
",44,466,475
"#tCase = sys.stdin.readline().split()
 tCase = int(sys.stdin.readline())
 
 def ken(bet, list):
 	for i in list:
 		if i >= bet:
 			list.remove(i)
 			return i, list
 	
 	x = list[0]
 	list.remove(x)
 	return x, list
 	
 def naomi(YList, ZList):
 	l1 = list(YList)
 	l2 = list(ZList)
 	
 	while len(l1) > 0:
 		cy = l1.pop()
 		cz = l2.pop()
 
 		if (cy < cz):
 			#if len(l2) > 0:
 				return YList[0], ZList[len(ZList)-1]
 			#else:
 			#	return cz, cy
 		
 	return YList[len(YList)-1], ZList[len(ZList)-1]
 		
 def main(YList, ZList):
 	dnp = 0
 	np = 0
 	#YList.sort(reverse=True)
 	YList.sort()
 	ZList.sort()
 	
 	YList2 = list(YList)
 	ZList2 = list(ZList)
 	
 	YList.sort()
 	#print YList
 	#print ZList
 	
 	while len(YList) > 0:
 		cy, ty = naomi(YList, ZList)
 		YList.remove(cy)		
 		cz, ZList = ken(ty, ZList)
 	#	print cy, ty,  cz
 		if (cy > cz):
 			dnp += 1
 			
 	while len(YList2) > 0:
 		cy = YList2.pop()
 		cz, ZList2 = ken(cy, ZList2)
 		#print cy, cz
 		if (cy > cz):
 			np += 1
 			
 			
 	
 
 	return str(dnp) + "" "" + str(np)
 		
  
 if __name__ == '__main__':
 	#unittest.main()
 	for i in xrange(tCase):	
 		#frase = [str(x) for x in sys.stdin.readline().split(' ')]	
 		#print ""Case #%d: %s"" % (i + 1, main(frase[0]))
 		
 		##Numbers
 		N = [int(x) for x in sys.stdin.readline().split(' ')]
 		YList = [float(x) for x in sys.stdin.readline().split(' ')]
 		ZList = [float(x) for x in sys.stdin.readline().split(' ')]
 		#print E,R,N, NList
 		print ""Case #%d: %s"" % (i + 1, main(YList, ZList))",44,467,820
"(unittest.TestCase):
 	def test_1(self):
 		self.assertEqual(main(1, 4), 2)
 	def test_2(self):
 		self.assertEqual(main(10, 120), 0)
 	def test_3(self):
 		self.assertEqual(main(100, 100000000000000), 2)
 
 #tCase = sys.stdin.readline().split()
 tCase = int(sys.stdin.readline())
 
 
 def main(M, N):
 	fns = 0
 	num = M
 	maior = math.sqrt(N)
 	int_maior = 0
 	
 	if maior.is_integer():
 		int_maior = int(maior) - 1
 		if fair(N):
 			if fair(int(maior)):
 				fns += 1
 	else:
 		int_maior = int(maior)
 		
 	while int_maior >= 1:
 		if fair(int_maior):
 			quadrado = int_maior * int_maior
 			if quadrado >= M:
 				if fair(quadrado):
 					fns += 1
 		int_maior -= 1
 	return fns
 
 def main2(M, N):
 	fns = 0
 	num = M
 	#for num in xrange(M, N + 1):
 	while num <= N:
 		result = raiz(num)
 		if result:
 			if fair(num):
 			
 				if fair(result):
 					fns += 1
 					#print num
 		#yield i
 		num += 1
 		#print raiz(num)
 	return fns
 	
 def fair(num):
 	return str(num) == str(num)[::-1]
 	#return True
 	
 def raiz(num):
 	result = math.sqrt(num)
 	#result = 1.0
 	if result.is_integer():
 		return int(result)
 	else:
 		return False
 	
 if __name__ == '__main__':
 	#unittest.main()
 	for i in xrange(tCase):	
 		#l1 = [str(x) for x in sys.stdin.readline().split(' ')]		
 		#print ""Case #%d: %s"" % (i + 1, main(l1[0], l2[0], l3[0], l4[0]))
 		
 		##Numbers
 		N,M = [int(x) for x in sys.stdin.readline().split(' ')]	
 		print ""Case #%d: %d"" % (i + 1, main(N,M))",44,468,789
"= sys.stdin.readline().split()
 tCase = int(fLine[0])
 
 
 dic = {		'a':'y',
 			'b':'h',
 			'c':'e',
 			'd':'s',
 			'e':'o',
 			'f':'c',
 			'g':'v',
 			'h':'x',
 			'i':'d',
 			'j':'u',
 			'k':'i',
 			'l':'g',
 			'm':'l',
 			'n':'b',
 			'o':'k',
 			'p':'r',
 			'q':'z',
 			'r':'t',
 			's':'n',
 			't':'w',
 			'u':'j',
 			'v':'p',
 			'w':'f',
 			'x':'m',
 			'y':'a',
 			'z':'q',
 			'\n':'',
 			' ':' '}
 
 
 def alien(frase):
 	resul = """"
 	for c in frase:
 		resul += dic[c]
 
 	return resul
 
 
 
 frases = []
 for i in xrange(tCase):
 	frase = sys.stdin.readline().replace(""\n"","""")
 	frases.append(frase)
 	
 
 for i in xrange(tCase):	
 	#case.append(frase)
 	print ""Case #%d: %s"" % (i+1, alien(frases[i]))
 	
 	
 
",44,469,467
"#tCase = sys.stdin.readline().split()
 tCase = int(sys.stdin.readline())
 
 
 def map(R, C, Bombs):
 	m = [[""."" for x in xrange(C)] for x in xrange(R)]
 	print Bombs
 	m[R-1][C-1] = 'c'
 	lastSkip = False
 	#for b in xrange(Bombs):
 	for i in xrange(R):
 		for j in xrange(C):
 			if Bombs == 0:
 				break
 			
 			if lastSkip:
 				m[i][j] = 'f'
 				continue
 			
 			if R - i == 2 or C - j == 2:
 				if Bombs == 1:
 					m[i][j] = 'f'
 					lastSkip = True
 					continue
 			
 				
 			m[i][j] = '*'
 			Bombs -= 1
 			lastSkip = False
 		lastSkip = False
 				
 	
 	
 	for line in m:
 		for c in line:
 			print c,
 		print
 		
 		
 def imprimir(m):
 	for line in m:
 		for c in line:
 			print c,
 		print
 		
 def map2(R, C, Bombs):
 	m = [[""."" for x in xrange(C)] for x in xrange(R)]
 	#print Bombs
 	m[R-1][C-1] = 'c'
 	lastSkip = False
 	#for b in xrange(Bombs):
 	
 	ii = 0
 	jj = 0
 	while Bombs > 0:
 		for j in xrange(jj, C):
 			if Bombs >= (C - j) or Bombs <= (C - j - 2) and Bombs > 0:
 				m[ii][j] = '*'
 				Bombs -= 1
 			else:
 				continue
 		
 		
 		for i in xrange(ii+1, R):
 			if Bombs >= (R - i) or Bombs <= (R - i - 2) and Bombs > 0:
 				m[i][jj] = '*'
 				Bombs -= 1
 			else:
 				if Bombs > 0:
 					print ""Impossible""
 					#imprimir(m)
 					return
 				continue
 		jj += 1
 		ii += 1
 	#print ""b"", Bombs
 	imprimir(m)
 	
 				
 	
 	
 
 		
 def main(R, C, M):
 	vazios = R * C - M
 
 	if R == 1 or C == 1 or vazios == 1 or vazios >= 4:
 		map2(R, C, M)
 	else:
 		print ""Impossible""
 
 	#print vazios
 	return """"
 		
  
 if __name__ == '__main__':
 	#unittest.main()
 	for i in xrange(tCase):	
 		#frase = [str(x) for x in sys.stdin.readline().split(' ')]	
 		#print ""Case #%d: %s"" % (i + 1, main(frase[0]))
 		
 		##Numbers
 		R, C, M = [int(x) for x in sys.stdin.readline().split(' ')]
 		#YList = [float(x) for x in sys.stdin.readline().split(' ')]
 		#ZList = [float(x) for x in sys.stdin.readline().split(' ')]
 		#print E,R,N, NList
 		print ""Case #%d:"" % (i + 1)
 		main(R, C, M)",44,470,1150
"#tCase = sys.stdin.readline().split()
 tCase = int(sys.stdin.readline())
 
 def calcTemp(taxa, X):
 	return X/taxa;
 
 def main(C, F, X):
 
 	taxa = 2.0
 	resp = 0
 	
 	
 	while True:
 		#print calcTemp(taxa, X), C/taxa + calcTemp(taxa + F, X), resp
 		if C/taxa + calcTemp(taxa + F, X) < calcTemp(taxa, X):
 			resp += C/taxa
 			taxa += F			
 		else:
 			resp += calcTemp(taxa, X)
 			return resp
 	
 	
 	return 0
 		
  
 if __name__ == '__main__':
 	#unittest.main()
 	for i in xrange(tCase):	
 		#frase = [str(x) for x in sys.stdin.readline().split(' ')]	
 		#print ""Case #%d: %s"" % (i + 1, main(frase[0]))
 		
 		##Numbers
 		C, F, X = [float(x) for x in sys.stdin.readline().split(' ')]
 		#print A, B, NList, BList
 		print ""Case #%d: %s"" % (i + 1, main(C, F, X))",44,471,395
"inputFile = open('A-small-attempt0.in', 'r')
 lines = inputFile.readlines()
 inputFile.close()
 
 outputFile = open('A-small-attempt0.out', 'w')
 
 numTests = int(lines[0])
 
 
 currLine = 1
 for i in range(1, numTests+1):
     firstRow = lines[int(lines[currLine])+currLine]
     currLine += 5
     secondRow = lines[int(lines[currLine])+currLine]
     currLine += 5
 
     firstNums = map(lambda x: int(x), firstRow.split())
     secondNums = map(lambda x: int(x), secondRow.split())
     
     intersect = [v for v in firstNums if v in secondNums]
 
     outputFile.write('Case #'+str(i)+': ')
     if len(intersect) == 1:
         outputFile.write(str(intersect[0])+'\n')
     elif len(intersect) == 0:
         outputFile.write('Volunteer cheated!\n')
     else:
         outputFile.write('Bad magician!\n')
 
 outputFile.close()
     
",45,472,305
"def isMowable(lawn):
     for i in range(len(lawn)):
         for j in range(len(lawn[i])):
             cellHeight = lawn[i][j]
             vertPossible = True
             horizPossible = True
             for k in range(len(lawn)):
                 if lawn[k][j] > cellHeight:
                     vertPossible = False
                     break
             for k in range(len(lawn[i])):
                 if lawn[i][k] > cellHeight:
                     horizPossible = False
                     break
             if not vertPossible and not horizPossible:
                 return ""NO""
     return ""YES""
 
 
 filename = ""B-small-attempt0.in""
 outputname = filename + ""out.txt""
 
 inFile = open(filename, 'r')
 outFile = open(outputname, 'w')
 
 
 numTests = int(inFile.readline())
 
     
 
 for i in range(numTests):
     dimensions = inFile.readline().split()
     n = int(dimensions[0])
     m = int(dimensions[1])
     lawn = []
     for j in range(n):
         line = inFile.readline().split()
         for k in range(m):
             line[k] = int(line[k])
         lawn += [line]
 
     answer = isMowable(lawn)
     
     
     outFile.write(""Case #"" + str(i+1) + "": "" + answer + '\n')
     print ""Case #"" + str(i+1) + "": "" + answer
 
 inFile.close()
 outFile.close()
",45,473,423
"inputFile = open(""C-small-attempt0.in"", 'r')
 outputFile = open(""recycleOut.txt"", 'w')
 numTests = int(inputFile.readline())
 
 def countRecycle(a,b):
     count = 0
     for n in range(a,b):
         for m in range(n+1,b+1):
             nStr = str(n)
             canRecycle = False
             for k in range(len(nStr)):
                 if nStr[k:] + nStr[0:k] == str(m):
                     canRecycle = True
                     break
             if canRecycle:
                 count += 1
     return count
 
 for i in range(numTests):
     line = inputFile.readline().split()
     a = int(line[0])
     b = int(line[1])
     outputFile.write('Case #' + str(i+1) + ': ' + str(countRecycle(a,b)) + '\n')
 
 inputFile.close()
 outputFile.close()
",45,474,261
"filename = ""A-small-attempt0 (3).in""
 outputname = filename + ""out.txt""
 
 inFile = open(filename, 'r')
 outFile = open(outputname, 'w')
 
 
 
 
 
 def evalGame(lines):
     board = []
     gameOver = True
     
     for line in lines:
         bline = []
         for i in range(len(line)):
             if line[i] == 'X':
                 bline += [1]
             elif line[i] == 'O':
                 bline += [2]
             elif line[i] == 'T':
                 bline += [3]
             elif line[i] == '.':
                 gameOver = False
                 bline += [0]
         board += [bline]
 
     # Check down
     for i in range(1):
         for j in range(4):
             startTile = board[i][j]
             if startTile == 3 or startTile == 0:
                 continue
             winner = True
             for k in range(1,4):
                 if board[i+k][j] not in [startTile, 3]:
                     winner = False
                     break
             if winner:
                 return startTile
 
     # Check right
     for i in range(4):
         for j in range(1):
             startTile = board[i][j]
             if startTile == 3 or startTile == 0:
                 continue
             winner = True
             for k in range(1,4):
                 if board[i][j+k] not in [startTile, 3]:
                     winner = False
                     break
             if winner:
                 return startTile
 
     # Check up
     for i in range(3,4):
         for j in range(4):
             startTile = board[i][j]
             if startTile == 3 or startTile == 0:
                 continue
             winner = True
             for k in range(1,4):
                 if board[i-k][j] not in [startTile, 3]:
                     winner = False
                     break
             if winner:
                 return startTile
 
     # Check left
     for i in range(4):
         for j in range(3,4):
             startTile = board[i][j]
             if startTile == 3 or startTile == 0:
                 continue
             winner = True
             for k in range(1,4):
                 if board[i][j-k] not in [startTile, 3]:
                     winner = False
                     break
             if winner:
                 return startTile
     
      # Check down right
     startTile = board[0][0]
     if startTile != 3 and startTile != 0:
         winner = True
         for k in range(1,4):
             if board[k][k] not in [startTile, 3]:
                 winner = False
                 break
         if winner:
             return startTile
 
      # Check up right
     startTile = board[3][0]
     if startTile != 3 and startTile != 0:
         winner = True
         for k in range(1,4):
             if board[3-k][k] not in [startTile, 3]:
                 winner = False
                 break
         if winner:
             return startTile
 
      # Check up left
     startTile = board[3][3]
     if startTile != 3 and startTile != 0:
         winner = True
         for k in range(1,4):
             if board[3-k][3-k] not in [startTile, 3]:
                 winner = False
                 break
         if winner:
             return startTile
 
      # Check down left
     startTile = board[0][3]
     if startTile != 3 and startTile != 0:
         winner = True
         for k in range(1,4):
             if board[k][3-k] not in [startTile, 3]:
                 winner = False
                 break
         if winner:
             return startTile
 
 
     if gameOver:
         return 0
 
     else:
         return -1
     
                       
 
 
 
 
 
 def resultToString(result):
     if result == 0:
         return ""Draw""
     elif result == 1:
         return ""X won""
     elif result == 2:
         return ""O won""
     else:
         return ""Game has not completed""
 
 
 numCases = int(inFile.readline())
 
 for i in range(numCases):
     lines = []
     for j in range(4):
         lines += [inFile.readline().strip()]
 
     result = evalGame(lines)
 
     print ""Case #"" + str(i+1) + "": "" + resultToString(result)
     outFile.write(""Case #"" + str(i+1) + "": "" + resultToString(result) + '\n')
     
     if i < numCases -1:
         inFile.readline()
 
 inFile.close()
 outFile.close()
",45,475,1294
"inputFile = open(""B-small-attempt0 (3).in"", 'r')
 outputFile = open(""dancingOutSmall.txt"", 'w')
 numTests = int(inputFile.readline())
 
 def countDancers(n,s,p,totals):
     guaranteed = 0
     needSurprise = 0
     if p == 1:
         for total in totals:
             if total != 0:
                 guaranteed += 1
         return guaranteed
     for total in totals:
         if total >= p*3 - 2:
             guaranteed += 1
         elif total >= p*3 - 4:
             needSurprise += 1
     if needSurprise > s:
         return guaranteed + s
     else:
         return guaranteed + needSurprise
 
 for i in range(numTests):
     line = inputFile.readline().split()
     n = int(line[0])
     s = int(line[1])
     p = int(line[2])
     totals = []
     for j in range(n):
         totals += [int(line[3+j])]
     outputFile.write('Case #' + str(i+1) + ': ' + str(countDancers(n,s,p,totals)) + '\n')
 
 outputFile.close()
",45,476,322
"inputFile = open('D-small-attempt0.in', 'r')
 lines = inputFile.readlines()
 inputFile.close()
 
 outputFile = open('D-small-attempt0.out', 'w')
 
 numTests = int(lines[0])
 
 def scoreWar(naomiNums, kenNums):
     naomiInd = 0
     kenInd = 0
     while naomiInd < len(naomiNums):
         naomiPlay = naomiNums[naomiInd]
         while kenInd < len(kenNums) and kenNums[kenInd] < naomiPlay:
             kenInd += 1
         if kenInd == len(kenNums):
             break
         naomiInd += 1
         kenInd += 1
     return len(naomiNums) - naomiInd
 
 def scoreDeceit(naomiNums, kenNums):
     naomiInd = 0
     kenInd = 0
     while kenInd < len(kenNums):
         kenPlay = kenNums[kenInd]
         while naomiInd < len(naomiNums) and naomiNums[naomiInd] < kenPlay:
             naomiInd += 1
         if naomiInd == len(naomiNums):
             break
         naomiInd += 1
         kenInd += 1
     return kenInd
 
 for i in range(1, numTests+1):
     naomiNums = map(lambda x: float(x), lines[3*i-1].split())
     kenNums = map(lambda x: float(x), lines[3*i].split())
     naomiNums.sort()
     kenNums.sort()
     deceitScore = scoreDeceit(naomiNums, kenNums)
     warScore = scoreWar(naomiNums, kenNums)
     outputFile.write('Case #'+str(i)+': ' + str(deceitScore) + ' ' + str(warScore) + '\n')
 
 outputFile.close()
",45,477,517
"def isPalindrome(number):
     strNum = str(number)
     for i in range(len(strNum)/2 + 1):
         if strNum[i] != strNum[-1*(i+1)]:
             return False
     return True
 
 '''for i in range(40):
     if isPalindrome(i) and isPalindrome(i*i):
         print i*i
 '''
 
 
 filename = ""C-small-attempt0.in""
 outputname = filename + ""out.txt""
 
 inFile = open(filename, 'r')
 outFile = open(outputname, 'w')
 
 
 fairAndSquareNums = [1,4,9,121,484]
 
 numTests = int(inFile.readline())
 
 for i in range(numTests):
     line = inFile.readline().split()
     count = 0
     for j in range(int(line[0]), int(line[1])+1):
         if j in fairAndSquareNums:
             count += 1
     outFile.write(""Case #"" + str(i+1) + "": "" + str(count) + '\n')
     print ""Case #"" + str(i+1) + "": "" + str(count)
 
 inFile.close()
 outFile.close()
",45,478,331
"translator = {}
 translator['a'] = 'y'
 translator['b'] = 'h'
 translator['c'] = 'e'
 translator['d'] = 's'
 translator['e'] = 'o'
 translator['f'] = 'c'
 translator['g'] = 'v'
 translator['h'] = 'x'
 translator['i'] = 'd'
 translator['j'] = 'u'
 translator['k'] = 'i'
 translator['l'] = 'g'
 translator['m'] = 'l'
 translator['n'] = 'b'
 translator['o'] = 'k'
 translator['p'] = 'r'
 translator['q'] = 'z'
 translator['r'] = 't'
 translator['s'] = 'n'
 translator['t'] = 'w'
 translator['u'] = 'j'
 translator['v'] = 'p'
 translator['w'] = 'f'
 translator['x'] = 'm'
 translator['y'] = 'a'
 translator['z'] = 'q'
 
 def translate(string, translator):
     accum = """"
     for i in range(len(string)):
         if string[i] == ' ':
             accum += ' '
         elif string[i] == '\n':
             break
         else:
             accum += translator[string[i]]
     return accum
 
 inputFile = open(""A-small-attempt0.in"", 'r')
 outputFile = open(""tonguesOut.txt"", 'w')
 numTests = int(inputFile.readline())
 
 for i in range(numTests):
     outputFile.write('Case #' + str(i+1) + ': ' + translate(inputFile.readline(), translator) + '\n')
 
 inputFile.close()
 outputFile.close()
 
",45,479,455
"inputFile = open('B-small-attempt0.in', 'r')
 lines = inputFile.readlines()
 inputFile.close()
 
 outputFile = open('B-small-attempt0.out', 'w')
 
 numTests = int(lines[0])
 
 
 def solveCookies(c, f, x):
     accumTime = 0
     farmRate = 0
     while True:
         # two options: Buy, or don't buy
         timeToWait = x/(2.0+farmRate)
         timeIfBuyFarm = (c/(2.0+farmRate) +   # Time to get a farm
                          x/(2.0+farmRate+f))
         if timeToWait <= timeIfBuyFarm:
             return accumTime+timeToWait
         else:
             accumTime += c/(2.0+farmRate)
             farmRate += f
 
 for i in range(1, numTests+1):
     [c, f, x] = map(lambda x: float(x), lines[i].split())
 
     outputFile.write('Case #'+str(i)+': ' + str(solveCookies(c, f, x))+'\n')
 outputFile.close()
     
",45,480,307
"= sys.argv[1]
 
 f = file(inputFileName)
 fout = file(""output.txt"", ""w"")
 
 T = eval(f.readline())
 
 for case in xrange(T):
 
 	####First question
 	A1 = int(f.readline().strip())
 
 	for i in xrange(4):
 		if i == A1 - 1:
 			possibles1 = f.readline().strip().split("" "")
 		else:
 			f.readline().strip().split("" "")
 
 	####Second question
 	A2 = int(f.readline().strip())
 
 	for i in xrange(4):
 		if i == A2 - 1:
 			possibles2 = f.readline().strip().split("" "")
 		else:
 			f.readline().strip().split("" "")
 
 	final = []
 	for item in possibles2:
 		if item in possibles1:
 			final.append(item)
 
 	##### Output writing
 	if len(final) == 0:	
 		fout.write(""Case #%d: Volunteer cheated!\n"" %(case + 1))
 	elif len(final) == 1:
 		fout.write(""Case #%d: %s\n"" %(case + 1, final[0]))
 	else:
 		fout.write(""Case #%d: Bad magician!\n"" %(case + 1))
",46,481,397
"(i, lawn):
 	return (2 not in lawn[i])
 
 def testColumn(j, lawn):
 	possible = True
 	for line in lawn:
 		if line[j] == 2:
 			possible = False
 			break
 	return possible
 
 ##########################################################
 # Main
 
 inputFileName = sys.argv[1]
 
 f = file(inputFileName)
 fout = file(""output.txt"", ""w"")
 
 T = eval(f.readline())
 
 for case in xrange(T):
 	data = f.readline().split()
 	N = eval(data[0])
 	M = eval(data[1])
 	possible = True
 	if N == 1 or M == 1:
 		for i in xrange(N):
 			f.readline()
 	else:
 		lawn = []
 		for i in xrange(N):
 			line = f.readline().strip().split()
 			for j in xrange(M):
 				line[j] = eval(line[j])
 			lawn.append(line)
 		i = 0
 		while i < N and possible:
 			for j in xrange(M):
 				if lawn[i][j] == 1:
 					if not testLine(i, lawn):
 						if not testColumn(j, lawn):
 							possible = False
 			i += 1
 
 	##### Output writing
 	fout.write(""Case #%d: "" %(case + 1))
 	if possible:
 		fout.write(""YES\n"")
 	else:
 		fout.write(""NO\n"")
",46,482,482
"def find_recycled(n, b):
 	ns = str(n)
 	reclist = []
 	for i in xrange(1, len(ns), 1):
 		nrec = ns[i:len(ns)] + ns[0:i]
 		if nrec[0] != ""0"":
 			nrec = eval(nrec)
 			if nrec <= b and nrec > n and (n, nrec) not in reclist:
 				reclist.append((n,nrec))
 	return len(reclist)
 
 inp = file(""input.in"")
 T = eval(inp.readline())
 out = file(""output.txt"", ""w"")
 
 for i in xrange(T):
 	a, b = inp.readline().strip().split()
 	a = eval(a)
 	b = eval(b)
 	nrec = 0
 	reclist = []
 	for n in xrange(a, b):
 		if n > 11:
 			nrec += find_recycled(n, b)
 	out.write(""Case #%d: %d\n"" %(i + 1, nrec))
 			
",46,483,322
"(symbol, game):
 	if testLines(symbol, game):
 		return True
 	elif testColumns(symbol, game):
 		return True
 	elif testDiagonals(symbol, game):
 		return True
 	else:
 		return False
 
 def testLines(symbol, game):
 	i = 0
 	won = False
 	while (i < 4 and not won):
 		line = game[i]
 		c = line.count(symbol)
 		if c == 4 or (c == 3 and ""T"" in line):
 			won = True
 		i += 1
 	return won
 
 def transpose(game):
 	for i in xrange(3):
 		for j in xrange(i + 1, 4):
 			aux = game[i][j]
 			game[i][j] = game[j][i]
 			game[j][i] = aux
 	return game
 
 def testColumns(symbol, game):
 	game = transpose(game)
 	return testLines(symbol, game)
 
 def testDiagonals(symbol, game):
 	won1 = True
 	won2 = True
 	i = 0
 	while i < 4 and (won1 or won2):
 		if game[i][i] not in [symbol, ""T""]:
 			won1 = False
 		if game[i][3 - i] not in [symbol, ""T""]:
 			won2 = False
 		i += 1
 	return (won1 or won2)		
 
 inputFileName = sys.argv[1]
 
 f = file(inputFileName)
 fout = file(""output.txt"", ""w"")
 
 T = eval(f.readline())
 
 for i in xrange(T):
 	game = []
 	for j in xrange(4):
 		line = f.readline().strip()
 		gameLine = 4*[None]
 		for k in xrange(4):
 			gameLine[k] = line[k]
 		game.append(gameLine)
 	f.readline()
 	if testSymbol(""X"", game):
 		gameResult = ""X""
 	elif testSymbol(""O"", game):
 		gameResult = ""O""
 	elif ""."" not in game[0] and ""."" not in game[1] and ""."" not in game[2] and ""."" not in game[3]:
 		gameResult = ""Draw\n""
 	else:
 		gameResult = ""Game has not completed\n""
 
 	fout.write(""Case #%d: "" %(i + 1))
 	if gameResult in [""X"", ""O""]:
 		fout.write(""%s won\n"" %(gameResult))
 	else:
 		fout.write(gameResult)
",46,484,755
"arq = file(""input.in"")
 n_cases = eval(arq.readline())
 out = file(""output.txt"", ""w"")
 
 for case in xrange(n_cases):
 
 	data = arq.readline()
 	data = data.strip()
 	data = data.split("" "")
 
 	n = eval(data[0])
 	s = eval(data[1])
 	p = eval(data[2])
 
 	scores = []
 	n_googlers_with_best_result = 0
 	candidates = 0
 
 	for j in data[3:]:
 		i = eval(j)
 		if i%3 == 0:
 			score = i/3
 			scores.append([score, score, score])
 		elif (i+1)%3 == 0:
 			score = (i+1)/3
 			scores.append([score-1, score, score])
 		else: #(i+2)%3 == 0
 			score = (i+2)/3
 			scores.append([score-1, score-1, score])
 
 	for score in scores:
 		if score[2] >= p:
 			n_googlers_with_best_result +=1
 		elif score[2] + 1 == p and score[1] == score[2] and score[2] != 0:
 			candidates += 1
 
 	n_googlers_with_best_result = n_googlers_with_best_result + min(s, candidates)
 
 	out.write(""Case #%d: %d\n"" % (case+1, n_googlers_with_best_result))
",46,485,463
"(naomi, ken, N):
 	points = 0
 	iNaomi = 0
 	iKen = 0
 	while iNaomi < N and iKen < N:
 		if naomi[iNaomi] > ken[iKen]:
 			points += 1
 		else:
 			iNaomi += 1
 		iKen += 1
 	return points
 
 def pointsDeceitfulWar(naomi, ken, N):
 	points = N
 	iNaomi = 0
 	iKen = 0
 	while iNaomi < N and iKen < N:
 		if naomi[iNaomi] > ken[iKen]:
 			iKen += 1
 		else:
 			points -= 1
 		iNaomi += 1
 	return points
 
 ##########################################################
 # Main
 
 inputFileName = sys.argv[1]
 
 f = file(inputFileName)
 fout = file(""output.txt"", ""w"")
 
 T = int(f.readline())
 
 for case in xrange(T):
 	N = int(f.readline().strip())
 	naomi = f.readline().strip().split()
 	ken = f.readline().strip().split()
 
 	for i in xrange(N):
 		naomi[i] = (float(naomi[i]),""N"")
 		ken[i] = (float(ken[i]),""K"")
 
 	naomi.sort()
 	ken.sort()
 
 	##### Output writing
 	fout.write(""Case #%d: %d %d\n"" %(case + 1, pointsDeceitfulWar(naomi, ken, N), pointsWar(naomi, ken, N)))
",46,486,481
"(n):
 	n = str(n)	
 	for i in xrange(len(n)/2):
 		if n[i] != n[(-i-1)]:
 			return False
 	return True
 
 ##########################################################
 # Main
 
 inputFileName = sys.argv[1]
 
 f = file(inputFileName)
 fout = file(""output.txt"", ""w"")
 
 T = eval(f.readline())
 
 for case in xrange(T):
 	data = f.readline().split()
 	A = eval(data[0])
 	B = eval(data[1])
 
 	i = A
 	found = []
 	while i <= B:
 		if isPalindrome(i):
 			sqrtI = math.sqrt(i)
 			if sqrtI == int(sqrtI):
 				if isPalindrome(int(sqrtI)):
 					found.append(i)
 		i += 1
 
 	##### Output writing
 	fout.write(""Case #%d: %d\n"" %(case + 1, len(found)))
",46,487,303
"(result, R, C):
 	resultSplitted = result.split(""\n"")
 	aux = R*[""""]
 	for i in xrange(R):
 		for j in xrange(C):
 		    aux[i] += resultSplitted[j][i]
 		aux[i] += ""\n""
 	result = """"
 	for item in aux:
 		result += item + ""\n""
 	return result.strip()
 
 ##########################################################
 # Main
 
 inputFileName = sys.argv[1]
 
 f = file(inputFileName)
 fout = file(""output.txt"", ""w"")
 
 T = int(f.readline())
 
 for case in xrange(T):
 	data = f.readline().strip().split("" "")
 	R = int(data[0])
 	C = int(data[1])
 	M = int(data[2])
 
 	result = """"
 
 	x = min(R,C)
 	y = max(R,C)
 
 	#if x == 2 and M%2 == 1 and M < R*C - 1:
 	#	result = ""Impossible""
 	#elif x == 3 and M > y and M != R*C - 1:
 #		result = ""Impossible""
 	if M > (y - 2)*x and M != y*x - 1:
 		N = M - (y-2)*x
 		if N%2 == 1 or y*x - M == 2:
 			result = ""Impossible""
 	if result != ""Impossible"":
 		i = 0
 		while M > 0: # 2
 			if i < y - 2:
 				if M >= x:
 					result += x*""*"" + ""\n""
 					M -= x
 					i += 1
 				elif M <= x - 2:
 					result += M*""*"" + (x - M) * ""."" + ""\n""
 					M = 0
 					i += 1
 				elif i + 2 < y - 1:
 					result += (M-1)*""*"" + (x - M + 1) * ""."" + ""\n"" + ""*"" + (x-1)*""."" + ""\n""
 					M = 0
 					i += 2
 				else:
 					result = ""Impossible""
 					break
 			else:
 				if M%2 != 0:
 					result += x*""*"" + ""\n""
 					result += (x-1)*""*"" + ""c""
 				else:
 					n = M/2
 					result += n*""*"" + (x-n)*""."" + ""\n""
 					result += n*""*"" + (x-n-1)*""."" + ""c""
 				M = 0
 				i += 2
 					
 		while i <= y - 1 and result != ""Impossible"":
 			if i == y - 1:
 				result += (x-1)*""."" + ""c""
 			else:
 				result += x*""."" + ""\n""
 			i += 1
 	
 	if R < C and result != ""Impossible"":
 		result = transpose(result, R, C)
 
 	##### Output writing
 	fout.write(""Case #%d:\n%s\n"" %(case + 1, result))
",46,488,982
"(C, F, nFarms):
 	return C/(2.0 + nFarms*F)
 	
 
 ##########################################################
 # Main
 
 inputFileName = sys.argv[1]
 
 f = file(inputFileName)
 fout = file(""output.txt"", ""w"")
 
 T = int(f.readline().strip())
 
 for case in xrange(T):
 
 	data = f.readline().split()
 	C = eval(data[0])
 	F = eval(data[1])
 	X = eval(data[2])
 
 	tmin = X/2.0
 	foundMin = False
 
 	S = 0
 	nFarms = 0
 
 	while not foundMin:
 		nFarms += 1
 		S += oneMoreFarm(C, F, nFarms - 1)
 		t = S + X/(2.0 + nFarms*F)
 		if t < tmin:
 			tmin = t
 		else:
 			foundMin = True
 
 	##### Output writing
 	fout.write(""Case #%d: %.7f\n"" %(case + 1, tmin))
",46,489,327
"def read_case():
 
     answer = int(input())
     lines = tuple(map(lambda _: set(str.split(input())), range(4)))
     return lines[answer - 1]
 
 
 for i in range(int(input())):
 
     intersection = read_case() & read_case()
     count = len(intersection)
     if count == 1:
 
         answer = intersection.pop()
 
     elif count > 1:
 
         answer = ""Bad magician!""
 
     elif count < 1:
 
         answer = ""Volunteer cheated!""
 
     print(str.format(""Case #{}: {}"", i + 1, answer))
",47,490,173
"(int(input())):
     n, m = tuple(map(int, input().split()))
     l = dict(chain.from_iterable(map(lambda j: zip(zip([j] * m, range(m)), map(int, input().split())), range(n))))
     ans = ""YES""
 
     while len(l):
         ly, lx = min(l, key=l.get)
         lowest = l[(ly, lx)]
 
         if all(map(lambda j: l.get((ly, j), lowest) == lowest, range(m))):
             for j in range(m):
                 l.pop((ly, j), None)
 
         elif all(map(lambda j: l.get((j, lx), lowest) == lowest, range(n))):
             for j in range(n):
                 l.pop((j, lx), None)
 
         else:
             ans = ""NO""
             break
 
     print(""Case #{}: {}"".format(i + 1, ans))
",47,491,251
"for case in range(int(input())):
     a, b = tuple(map(int, input().split()))
     result = 0
     ast, bst = str(a), str(b)
     for x in range(a, b + 1):
         xst = str(x)
         added = list()
         for j in range(len(xst)):
             xstr = xst[j:] + xst[:j]
             if xstr < ast or xstr > bst:
                 continue
             elif xst < xstr and xstr not in added:
                 added.append(xstr)
                 result += 1
     print(""Case #{}: {}"".format(case + 1, result))
",47,492,170
"def yoba(s, ch):
     lines = [True] * 10
     for i in range(4):
         for j in range(4):
             lines[j] = lines[j] and (s[i][j] in (ch, ""T""))
             lines[j + 4] = lines[j + 4] and (s[j][i] in (ch, ""T""))
         lines[8] = lines[8] and (s[i][i] in (ch, ""T""))
         lines[9] = lines[9] and (s[3 - i][i] in (ch, ""T""))
     return any(lines)
 
 for i in range(int(input())):
     s = tuple(map(lambda _: input(), range(4)))
 
     if yoba(s, ""X""):
         ans = ""X won""
     elif yoba(s, ""O""):
         ans = ""O won""
     elif ""."" not in """".join(s):
         ans = ""Draw""
     else:
         ans = ""Game has not completed""
 
     input()
     print(""Case #{}: {}"".format(i + 1, ans))
",47,493,287
"def passes(p, t): #normal, surprising
     q, r = divmod(t, 3)
     if r == 0:
         return q >= p, q + 1 >= p and q
     elif r == 1:
         return q + 1 >= p, q + 1 >= p and q
     elif r == 2:
         return q + 1 >= p, q + 2 >= p
 
 for case in range(int(input())):
     st = input().strip().split()
     n, s, p, t = int(st[0]), int(st[1]), int(st[2]), list(map(int, st[3:]))
     result = 0
     for i in t:
         normal, surprising = passes(p, i)
         if normal:
             result += 1
         elif surprising and s != 0:
             result += 1
             s -= 1
     print(""Case #{}: {}"".format(case + 1, result))
",47,494,237
"(blocks, value):
 
     win_blocks = set(filter(lambda block: block > value, blocks))
     blocks.discard(min(win_blocks if win_blocks else blocks))
     return bool(win_blocks)
 
 
 def deceitful_war(ken, naomi, epsilon = 10 ** (-6)):
 
     while ken:
 
         min_ken = min(ken)
         max_ken = max(ken)
         min_naomi = min(naomi)
 
         if min_ken > min_naomi and any(map(lambda bs: operator.lt(*bs), zip(sorted(naomi), sorted(ken)))):
 
             yield max_ken - epsilon
 
         else:
 
             yield 1.0 - epsilon
 
         naomi.discard(min_naomi)
 
 
 for i in range(int(input())):
 
     input()
     naomi = set(map(float, str.split(input())))
     ken = set(map(float, str.split(input())))
 
     dwar_ken = ken.copy()
     dwar_naomi = naomi.copy()
     dwar = collections.Counter(map(functools.partial(optimal_war_step, dwar_ken), deceitful_war(dwar_ken, dwar_naomi)))
     war = collections.Counter(map(functools.partial(optimal_war_step, ken), naomi))
     print(str.format(""Case #{}: {} {}"", i + 1, dwar[False], war[False]))
",47,495,399
"def sqrt(x, ge):
     if x == 1:
         return 1
     sx = x >> 1
     step = sx >> 1
 
     while step:
         if sx ** 2 >= x:
             sx = sx - step
         else:
             sx = sx + step
         step = step >> 1
 
     if ge:
         while not sx ** 2 < x:
             sx = sx - 1
         while not sx ** 2 >= x:
             sx = sx + 1
     else:
         while not sx ** 2 > x:
             sx = sx + 1
         while not sx ** 2 <= x:
             sx = sx - 1
 
     return sx
 
 
 def get_start_pali(a):
     s = str(a)
     ls = len(s)
     if ls == 1:
         return s, True
     elif ls & 1:
         return s[:ls >> 1 + 1], True
     else:
         return s[:ls >> 1], False
 
 
 def get_next_pali(p, m):
     if len(p) == p.count(""9""):
         if m:
             return ""1"" + ""0"" * (len(p) - 1), False
         else:
             return ""1"" + ""0"" * len(p), True
     else:
         return str(int(p) + 1), m
 
 
 def pali_to_num(p, m):
     if m:
         return int(p + p[-2::-1])
     else:
         return int(p + p[::-1])
 
 
 def is_pali(a):
     s = str(a)
     hls = len(s) >> 1
     return s[:hls] == s[:-hls - 1:-1]
 
 for i in range(int(input())):
     a, b = tuple(map(int, input().split()))
     sqa, sqb = sqrt(a, True), sqrt(b, False)
 
     p, m = get_start_pali(sqa)
     while pali_to_num(p, m) < sqa:
         p, m = get_next_pali(p, m)
 
     count = 0
 
     while True:
         curr = pali_to_num(p, m)
         if curr > sqb:
             break
         if is_pali(curr ** 2):
             count = count + 1
         p, m = get_next_pali(p, m)
 
     print(""Case #{}: {}"".format(i + 1, count))
",47,496,681
"for case in range(int(input())):
     a, b = tuple(map(int, input().split()))
     result = 0
     ast, bst = str(a), str(b)
     for x in range(a, b + 1):
         xst = str(x)
         added = list()
         for j in range(len(xst)):
             xstr = xst[j:] + xst[:j]
             if xstr < ast or xstr > bst:
                 continue
             elif xst < xstr and xstr not in added:
                 added.append(xstr)
                 result += 1
     print(""Case #{}: {}"".format(case + 1, result))
",47,497,170
"for i in range(int(input())):
 
     c, f, x = tuple(map(float, str.split(input())))
 
     base_time = 0.0
     base_rate = 2.0
     farms_count = 0
     best_time = None
 
     current_time = base_time + x / (base_rate + farms_count * f)
 
     while best_time is None or best_time > current_time:
 
         best_time = current_time
         base_time += c / (base_rate + farms_count * f)
         farms_count += 1
 
         current_time = base_time + x / (base_rate + farms_count * f)
 
     print(str.format(""Case #{}: {}"", i + 1, best_time))
",47,498,207
"#!/usr/bin/env python
 (chosen_row_1, arrange_1, chosen_row_2, arrange_2):
 	rlt = 'Volunteer cheated!'
 	found = False
 	for i in arrange_1[chosen_row_1]:
 		if i in arrange_2[chosen_row_2]:
 			if not found:
 				rlt = i
 				found = True
 			else:
 				rlt = 'Bad magician!'
 				break
 	return rlt
 
 input_file = open(sys.argv[1], 'r')
 T = int(input_file.readline())
 for i in range(T):
 	chosen_row_1 = int(input_file.readline()) - 1
 	arrange_1 = []
 	arrange_1.append(map(int, input_file.readline().split()))
 	arrange_1.append(map(int, input_file.readline().split()))
 	arrange_1.append(map(int, input_file.readline().split()))
 	arrange_1.append(map(int, input_file.readline().split()))
 	chosen_row_2 = int(input_file.readline()) - 1
 	arrange_2 = []
 	arrange_2.append(map(int, input_file.readline().split()))
 	arrange_2.append(map(int, input_file.readline().split()))
 	arrange_2.append(map(int, input_file.readline().split()))
 	arrange_2.append(map(int, input_file.readline().split()))
 	print 'Case #%d:' % (i + 1), process(chosen_row_1, arrange_1, chosen_row_2, arrange_2)
",48,499,477
"'''
 Created on 13 Apr 2013
 
 @author: mengda
 '''
 expected = []
 
 def process(N, M):
     lawn = []
     for n in range(N):
         lawn.append([100] * M)
     for n in range(N):
         highest = 0
         for m in range(M):
             if expected[n][m] > highest:
                 highest = expected[n][m]
         for m in range(M):
             if lawn[n][m] > highest:
                 lawn[n][m] = highest
     for m in range(M):
         highest = 0
         for n in range(N):
             if expected[n][m] > highest:
                 highest = expected[n][m]
         for n in range(N):
             if lawn[n][m] > highest:
                 lawn[n][m] = highest
     for n in range(N):
         for m in range(M):
             if lawn[n][m] <> expected[n][m]:
                 return 'NO'
     return 'YES'
 
 f = open('B-small-attempt0.in', 'r')
 T = int(f.readline())
 outLine = []
 
 for i in range(1, T + 1):
     expected = []
     (N, M) = map(int, f.readline().split())
     for _ in range(N):
         expected.append(map(int, f.readline().split()))
     outLine.append('Case #%d: %s\n' % (i, process(N, M)))
     print outLine[-1],
 
 f.close()
 outFile = open('b.s.out', 'w')
 outFile.writelines(outLine)
 outFile.close()
",48,500,448
"'''
 Created on 2012-4-14
 
 @author: hemnd
 '''
 def cal(A, B):
     rslt = 0
     tmp = []
     for i in range(1, len(A)):
         min = max = 0
         for j in range(int(A[0:i]), int(B[0:i]) + 1):
             sJ = str(j)
             sMin = (sJ * (len(A) - i))[0:len(A) - i]
             min = int(sMin)
             if int(sMin + sJ) <= int(sJ + sMin):
                 min += 1
             if int(B[-i:]) >= j:
                 max = int(B[:(len(A) - i)])
             else:
                 max = int(B[:(len(A) - i)]) - 1
             if max < min:
                 continue
             for k in range(min, max + 1):
                 if (sJ + str(k), str(k) + sJ) in tmp:
                     print (sJ + str(k), str(k) + sJ), 'already there'
                     continue
                 else:
                     tmp.append((sJ + str(k), str(k) + sJ))
                     rslt += 1
 
 #            rslt = rslt + max - min + 1
     return rslt
 
 inputFile = open('C-small-attempt2.in', 'r')
 #inputFile = open('test.txt', 'r')
 inputLines = inputFile.readlines()
 inputFile.close()
 
 T = int(inputLines[0])
 outputLines = []
 
 for i in range(1, T + 1):
     args = inputLines[i].strip().split(' ')
     outputLines.append('Case #%d: %d\n' % (i, cal(args[0], args[1])))
     print outputLines[i - 1],
 
 outputFile = open('C-small.out', 'w')
 outputFile.writelines(outputLines)
 outputFile.close()
",48,501,523
"'''
 Created on 2012-4-14
 
 @author: hemnd
 '''
 def cal(args):
     rslt = 0
     N = int(args[0])
     S = int(args[1])
     p = int(args[2])
     for i in range(N):
         s = int(args[i + 3])
         e = s / 3
         r = s % 3
         if e >= p:
             rslt += 1
         elif r == 1:
             if e + 1 >= p:
                 rslt += 1
         elif r == 0:
             if e == 0:
                 continue
             if S > 0 and e + 1 >= p:
                 rslt += 1
                 S -= 1
         elif r == 2:
             if e + 1 >= p:
                 rslt += 1
             elif S > 0 and e + 2 >= p:
                 rslt += 1
                 S -= 1
     return rslt
 
 inputFile = open('B-small-attempt0.in', 'r')
 #inputFile = open('test.txt', 'r')
 inputLines = inputFile.readlines()
 inputFile.close()
 
 T = int(inputLines[0])
 outputLines = []
 
 for i in range(1, T + 1):
     args = inputLines[i].strip().split(' ')
     outputLines.append('Case #%d: %d\n' % (i, cal(args)))
     print outputLines[i - 1],
 
 outputFile = open('B-small.out', 'w')
 outputFile.writelines(outputLines)
 outputFile.close()
",48,502,417
"#!/usr/bin/env python
 (N, naomi, ken):
 	pointer_n = pointer_k = 0
 	score0 = 0
 	score1 = N
 	for i in range(N):
 		if naomi[i] > ken[pointer_k]:
 			score0 += 1
 			pointer_k += 1
 		if ken[i] > naomi[pointer_n]:
 			score1 -= 1
 			pointer_n +=1
 	return str(score0) + ' ' + str(score1)
 
 input_file = open(sys.argv[1], 'r')
 T = int(input_file.readline())
 for i in range(T):
 	N = int(input_file.readline())
 	naomi = sorted(map(float, input_file.readline().split()))
 	ken = sorted(map(float, input_file.readline().split()))
 	print 'Case #%d:' % (i + 1), process(N, naomi, ken)
",48,503,271
"'''
 Created on 13 Apr 2013
 
 @author: mengda
 '''
 = []
 
 def isP(num):
     num = str(int(num))
     for i in range(len(num) / 2):
         if num[i] <> num[-1 - i]:
             return False
     return True
 
 def createP(root, half_digits):
     root = str(root)
     for i in range(half_digits):
         ls[i] = root[i]
         ls[-1 - i] = root[i]
     return int(''.join(ls))
 
 def process(A, B):
     rlt = 0
     a = int(math.ceil(math.sqrt(A)))
     b = int(math.floor(math.sqrt(B)))
     str_a = str(a)
     half_digits = int(math.ceil(len(str_a) / 2.0))
     root = int(str_a[:half_digits])
     next_root = 10 ** half_digits
     digits = len(str_a)
     for _ in range(digits - len(ls)):
         ls.append('')
     while True:
         if root == next_root:
             if digits % 2 == 0:
                 next_root *= 10
                 half_digits += 1
             else:
                 root /= 10
             digits += 1
             ls.append('')
         p = createP(root, half_digits)
         print p,
         if p > b:
             print 'too large'
             break
         if isP(math.pow(p, 2)):
             print 'right one!'
             rlt += 1
         else:
             print 
         root += 1
     return rlt
 
 def process1(A, B):
     rlt = 0
     a = int(math.ceil(math.sqrt(A)))
     b = int(math.floor(math.sqrt(B)))
     for i in range(a, b + 1):
         if not isP(i):
             continue
         power = math.pow(i, 2)
         if isP(power):
             rlt += 1
     return rlt
 
 f = open('C-small-attempt1.in', 'r')
 T = int(f.readline())
 outLine = []
 
 for i in range(1, T + 1):
     (A, B) = map(int, f.readline().split())
     outLine.append('Case #%d: %s\n' % (i, process1(A, B)))
     print outLine[-1],
 
 f.close()
 outFile = open('C-S.out', 'w')
 outFile.writelines(outLine)
 outFile.close()
",48,504,704
"'''
 Created on 2012-4-14
 
 @author: hemnd
 '''
 dict = {}
 strs1 = ['our language is impossible to understand', 'there are twenty six factorial possibilities', 'so it is okay if you want to just give up']
 strs0 = ['ejp mysljylc kd kxveddknmc re jsicpdrysi', 'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'de kr kd eoya kw aej tysr re ujdr lkgc jv']
 
 for i in range(3):
     for j in range(len(strs1[i])):
         c = strs0[i][j]
         if c == ' ':
             continue
         e = strs1[i][j]
         try:
             dict[c]
             print c, '=', dict[c], e
         except:
             dict[c] = e
             print c, '=', e
 
 for k in dict.keys():
     print k, dict[k]
     
 dict['q'] = 'z'
 dict['z'] = 'q'
 dict[' '] = ' '
 
 def trans(s):
     rslt = ''
     for i in range(len(s) - 1):
         rslt += dict[s[i]]
     return rslt
 
 #inputFile = open('A-small-practice.in', 'r')
 inputFile = open('A-small-attempt0.in', 'r')
 inputLines = inputFile.readlines()
 inputFile.close()
 
 N = int(inputLines[0])
 outputLines = []
 
 for i in range(1, N + 1):
     outputLines.append('Case #%d: %s\n' % (i, trans(inputLines[i])))
     print outputLines[i - 1],
 
 outputFile = open('A-small-practice.out', 'w')
 outputFile.writelines(outputLines)
 outputFile.close()
",48,505,505
"#!/usr/bin/env python
 (R, C, M, grid):
 	if M == 0:
 		return
 	R -= 1
 	C -= 1
 	grid[R][C] = '*'
 	M -= 1
 	r = R - 1
 	c = C - 1
 	while M > 0:
 		if r > c:
 			grid[r][C] = '*'
 			r -= 1
 		else:
 			grid[R][c] = '*'
 			c -= 1
 		M -= 1
 
 def put_mines(R, C, M, grid):
 	if R > C:
 		if M < C:
 			put_mines_last_step(R, C, M, grid)
 			return
 		for i in range(C):
 			grid[R - 1][i] = '*'
 		put_mines(R - 1, C, M - C, grid)
 		return
 	if M < R:
 		put_mines_last_step(R, C, M, grid)
 		return
 	for i in range(R):
 		grid[i][C - 1] = '*'
 	put_mines(R, C - 1, M - R, grid)
 	return
 
 def process(R, C, M):
 	rlt = ''
 	grid = []
 	for i in range(R):
 		grid.append(['.'] * C)
 	put_mines(R, C, M, grid)
 	if not C == 1:
 		for i in range(R):
 			if not grid[i][0] == '.':
 				break
 			if not grid[i][1] == '.':
 				return '\nImpossible'
 	if not R == 1:
 		for i in range(C):
 			if not grid[0][i] == '.':
 				break
 			if not grid[1][i] == '.':
 				return '\nImpossible'
 	grid[0][0] = 'c'
 	for i in grid:
 		rlt += '\n' + ''.join(i)
 	return rlt
 
 input_file = open(sys.argv[1], 'r')
 T = int(input_file.readline())
 for i in range(T):
 	(R, C, M) = map(int, input_file.readline().split())
 	print 'Case #%d:' % (i + 1), process(R, C, M)
",48,506,707
"#!/usr/bin/env python
 (C, F, X):
 	speed = 2.0
 	time = 0.0
 	while True:
 		if C / speed + X / (speed + F) > X / speed:
 			time += X / speed
 			break
 		time += C / speed
 		speed += F
 	return round(time, 7)
 
 input_file = open(sys.argv[1], 'r')
 T = int(input_file.readline())
 for i in range(T):
 	(C, F, X) = map(float, input_file.readline().split())
 	print 'Case #%d:' % (i + 1), process(C, F, X)
",48,507,191
"# -*- coding: utf-8 -*-
 
 (f):
 	return [
 		[int(x) for x in line.split()]
 		for line in [f.readline() for _ in range(4)]
 	]
 
 def read_case(f):
 	answer1 = int(f.readline())
 	grid1 = read_grid(f)
 	answer2 = int(f.readline())
 	grid2 = read_grid(f)
 	return (grid1[answer1 - 1], grid2[answer2 - 1])
 
 
 def solve(r1, r2):
 	res = set(r1) & set(r2)
 	if len(res) == 0:
 		return 'Volunteer cheated!'
 	if len(res) == 1:
 		return list(res)[0]
 	return 'Bad magician!'
 
 
 
 def main():
 	fn = sys.argv[1]
 	with open(fn, encoding='utf-8') as f:
 		ncases = int(f.readline())
 		for case in range(1, ncases + 1):
 			row1, row2 = read_case(f)
 			solution = solve(row1, row2)
 			print('Case #{}: {}'.format(case, solution))
 
 
 if __name__ == '__main__':
 	main()",49,508,373
"#!/usr/bin/env python
 
 (stream):
     init = stream.readline()
     if not init:
         return None
 
     N, _ = map(int, init.split())
     lawn = []
     for i in range(N):
         line = stream.readline()
         lawn.append([int(x) for x in line.split()])
     return lawn
 
 
 def test_hor(lawn, i, j):
     me = lawn[i][j]
     return all(lawn[i][col] <= me for col in range(len(lawn[i])))
 
 
 def test_ver(lawn, i, j):
     me = lawn[i][j]
     return all(lawn[row][j] <= me for row in range(len(lawn)))
 
 
 def test_square(lawn, i, j):
     return test_hor(lawn, i, j) or test_ver(lawn, i, j)
 
 
 def is_possible(lawn):
     return all(test_square(lawn, i, j) for i in range(len(lawn))
                for j in range(len(lawn[i])))
 
 
 def main():
     with open('B-small-attempt0.in', encoding='utf-8') as f:
         f.readline()            # Skip the first line
 
         for i in count(1):
             lawn = next_lawn(f)
             if lawn is None:
                 break
             ans = is_possible(lawn)
             print('Case #{}: {}'.format(i, 'YES' if ans else 'NO'))
         
 
 main()
",49,509,421
"#!/usr/bin/env python
 
 
 def rotate(i, ndigits):
     s = str(i)
     s = s[-ndigits:] + s[:-ndigits]
     return int(s)
 
 def pairs(A, B):
     for n in range(A, B + 1):
         for i in range(1, len(str(n))):
             m = rotate(n, i)
             if n >= m or m > B: continue
             yield n, m
 
 def main():
     (sys.argv[1], 'r') as f:
         f.readline()
         n = 0
         for line in f:
             n += 1
 
             A, B = [int(x) for x in line.split(' ')]
             unique = set()
             for pair in pairs(A, B):
                 unique.add(pair)
             print 'Case #%d: %d' % (n, len(unique))
 
 if __name__ == '__main__':
     main()
",49,510,255
"#!/usr/bin/env python
 
 (stream=None):
     """"""""""""
     if stream is None:
         stream = sys.stdin
     board = []
     for line in filter(lambda line: len(line) and line[0] in '.OTX', stream):
         board.append([c for c in line.rstrip()])
         if len(board) == 4:
             break
     return board if len(board) else None
 
 
 def scan_not_completed(board):
     if any(board[i][j] == '.'
            for j in range(len(board))
            for i in range(len(board))):
         return '.'
 
 
 def check_set(s):
     s.discard('T')
     return s.pop() if len(s) == 1 and '.' not in s else None
 
 
 scan_diagonal1 = lambda board: check_set({board[i][i]
         for i in range(len(board))})
 
 scan_diagonal2 = lambda board: check_set({board[i][len(board)-1-i]
         for i in range(len(board))})
 
 scan_col = lambda board, col: check_set({board[i][col]
     for i in range(len(board))})
 
 scan_row = lambda board, row: check_set(set(board[row]))
 
 
 def determine_state(board):
     """"""""""""
     for i in range(4):
         for s in (scan_col, scan_row):
             ret = s(board, i)
             if ret:
                 return ret
     for s in (scan_diagonal1, scan_diagonal2, scan_not_completed):
         ret = s(board)
         if ret:
             return ret
     return 'draw'
 
 
 def main():
     """"""""""""
     with open('A-small-attempt0.in', encoding='utf-8') as f:
         for i in itertools.count(1):
             board = next_board(f)
             if board is None:
                 break
             state = determine_state(board)
             if state == 'X':
                 line = 'X won'
             elif state == 'O':
                 line = 'O won'
             elif state == 'draw':
                 line = 'Draw'
             elif state == '.':
                 line = 'Game has not completed'
             print('Case #{}: {}'.format(i, line))
 
 
 main()
",49,511,617
"#!/usr/bin/env python
 
 
 def best(total):
     """"""Return the best possible score for the given `total`.  Assume
     the total is computed by summing exactly three scores (each in the
     interval of 0 to 10 inclusive) and no score can be 2 points apart
     from another.
     
     Arguments:
     - `total`:
     """"""
     m = total % 3
     if m == 2:
         b = total // 3 + 2
     else:
         b = total // 3 + 1
     if b > 10:
         b = 10
     return b
 
 def best_non_surprising(total):
     """"""Return the best possible score for the given `total`, but
     assume that there should be no more than 1 point difference
     between the scores.
 
     Arguments:
     - `total`:
     """"""
     if total % 3 == 0:
         return total // 3
     else:
         return total // 3 + 1
 
 def max_num_gte_p(totals, S, p):
     """"""Return the maximum number of Googlers that could have had a
     best result of at least p.
     
     Arguments:
     - `totals`:
     - `S`: number of surprising triplets of scores
     - `p`:
     """"""
     res = 0
     for total in totals:
         if total == 0:
             if p == 0:
                 res += 1
             continue
 
         if best_non_surprising(total) >= p:
             # print total, 'non_surp --> ', best_non_surprising(total)
             res += 1
         elif S > 0 and best(total) >= p:
             # print total, 'surp --> ', best(total)
             res += 1
             S -= 1
 
     return res
 
 def main():
     (sys.argv[1], 'r') as f:
         f.readline()            # skip T
 
         n = 0
         for line in f:
             n += 1
 
             line = [int(s) for s in line.split()]
             N = line[0]
             S = line[1]
             p = line[2]
             totals = line[3:]
 
             # print 'S=%d, p=%d, Totals: ' % (S, p), totals
             print 'Case #%d: %d' % (n, max_num_gte_p(totals, S, p))
             # print
 
 if __name__ == '__main__':
     main()
",49,512,652
"(naomi_told, kens_blocks):
 	heavier = list(filter(lambda b: b > naomi_told, kens_blocks))
 	if heavier:
 		chosen = min(heavier)
 	else:
 		chosen = min(kens_blocks)
 	kens_blocks.remove(chosen)
 	return chosen
 
 
 def remove_lightest(blocks):
 	lightest = sorted(blocks)[0]
 	blocks.remove(lightest)
 	return lightest
 
 
 def remove_heaviest(blocks):
 	heaviest = sorted(blocks)[-1]
 	blocks.remove(heaviest)
 	return heaviest
 
 
 def dwar(naomis_blocks, kens_blocks):
 	wins = 0
 	kens_blocks = copy.copy(kens_blocks)
 	for block in sorted(naomis_blocks):
 		if any(map(lambda x: x < block, kens_blocks)):
 			# Ken got a lighter block
 			wins += 1
 			remove_lightest(kens_blocks)
 
 		elif any(map(lambda x: x > block, kens_blocks)):
 			# Ken got a heavier block
 			remove_heaviest(kens_blocks)
 	return wins
 
 
 def war(naomis_blocks, kens_blocks):
 	wins = 0
 	kens_blocks = copy.copy(kens_blocks)
 	for block in naomis_blocks:
 		k = ken(block, kens_blocks)
 		if block > k:
 			wins += 1
 	return wins
 
 
 def read_case(f):
 	N = int(f.readline())
 	naomis_blocks = list(map(float, f.readline().split()))
 	kens_blocks = list(map(float, f.readline().split()))
 	return N, naomis_blocks, kens_blocks
 
 
 def solve(n, k):
 	return '{} {}'.format(dwar(n, k), war(n, k))
 
 
 def main():
 	fn = sys.argv[1]
 	with open(fn, encoding='utf-8') as f:
 		ncases = int(f.readline())
 		for case in range(1, ncases + 1):
 			N, naomi, ken = read_case(f)
 			solution = solve(naomi, ken)
 			print('Case #{}: {}'.format(case, solution))
 
 
 if __name__ == '__main__':
 	main()",49,513,727
"#!/usr/bin/env python3
 
 (stream):
     line = stream.readline()
     if not line:
         return None
     return [int(x) for x in line.split()]
 
 
 def is_palindrome(n):
     n = str(n)
     return all(n[i] == n[len(n)-1-i] for i in range(len(n) // 2))
 
 def mysqrt(n):
     """"""Return -1 if not an integer""""""
     rt = int(sqrt(n))
     return rt if rt * rt == n else -1
 
 
 def is_fas(n):
     rt = mysqrt(n)
     return rt != -1 and is_palindrome(n) and is_palindrome(rt)
 
 
 def main():
     with open('C-small-attempt0.in', encoding='utf-8') as f:
         f.readline()
 
         for case in count(1):
             r = next_range(f)
             if r is None:
                 break
 
             cnt = 0
             for n in range(r[0], r[1] + 1):
                 if is_fas(n):
                     cnt += 1
 
             print('Case #{}: {}'.format(case, cnt))
 
 
 main()
",49,514,341
"= '.'
 BOMB = '*'
 CLICK = 'c'
 
 
 class Board:
 
 	def __init__(self, R, C, M):
 		self.initial_M = M
 		self.R = R
 		self.C = C
 		self.M = M
 		self.matrix = [[FREE for c in range(C)] for r in range(R)]
 		# A rectangle that says what's the current subarea we work on
 		self.endx = len(self.matrix[0])
 		self.endy = len(self.matrix)  # 0 < R * C
 		self.startx = 0
 		self.starty = 0
 
 	def fill_row(self, row):
 		for c in self.range_active_cols:
 			self.matrix[row][c] = BOMB
 		self.starty += 1
 		self.M -= self.active_cols
 
 	def fill_col(self, col):
 		for r in self.range_active_rows:
 			self.matrix[r][col] = BOMB
 		self.startx += 1
 		self.M -= self.active_rows
 
 	def pprint(self):
 		# print('startx={}, endx={}, starty={}, endy={}, M={}'
 		# 		.format(self.startx, self.endx, self.starty, self.endy, self.M))
 		for row in self.matrix:
 			for cell in row:
 				print(cell, end='')
 			print()
 
 	@property
 	def active_rows(self):
 		return self.endy - self.starty
 
 	@property
 	def active_cols(self):
 		return self.endx - self.startx
 
 	def optimize(self):
 		while 1:
 			if (self.active_cols <= self.active_rows
 					and self.active_cols <= self.M):
 				self.fill_row(self.starty)
 			elif (self.active_rows < self.active_cols
 					and self.active_rows <= self.M):
 				self.fill_col(self.startx)
 			else:
 				break
 
 	@property
 	def range_active_cols(self):
 		return range(self.startx, self.endx)
 
 	@property
 	def range_active_rows(self):
 		return range(self.starty, self.endy)
 
 	def is_free(self, row, col):
 		return self.matrix[row][col] == FREE
 
 	def place_bomb(self):
 		for row in self.range_active_rows:
 			for col in self.range_active_cols:
 				if (self.is_free(row, col) 
 						and row + 2 < self.R
 						and col + 2 < self.C):
 					self.matrix[row][col] = BOMB
 					self.M -= 1 
 					return True
 		for col in self.range_active_cols:
 			for row in self.range_active_rows:
 				if (self.is_free(row, col)
 						and row + 2 < self.R
 						and col + 2 < self.C):
 					self.matrix[row][col] = BOMB
 					self.M -= 1
 					return True
 		return False
 
 	def mark_click(self):
 		self.matrix[-1][-1] = 'c'
 
 	def win_condition(self):
 		click_row = len(self.matrix) - 1
 		click_col = len(self.matrix[0]) - 1
 		# Check the cell left of the click
 		if (click_col - 1 >= 0
 				and not self.is_free(click_row, click_col - 1)):
 			return False
 
 		if (click_row - 1 >= 0
 				and not self.is_free(click_row - 1, click_col)):
 			return False
 
 		if (click_row -1 >= 0
 				and click_col -1 >= 0
 				and not self.is_free(click_row - 1, click_col - 1)):
 			return False
 		
 		return True
 
 	def win_cond2(self):
 		if self.initial_M + 1 == self.C * self.R:
 			return True
 		return False
 
 	def solve(self):
 		self.optimize()
 		while self.M > 0 and self.place_bomb():
 			pass
 		if self.M == 0 and (self.win_condition() or self.win_cond2()):
 			self.mark_click()
 			self.pprint()
 		else:
 			print('Impossible')
 
 
 def read_case(f):
 	return map(int, f.readline().split())
 
 
 def main():
 	fn = sys.argv[1]
 	with open(fn, encoding='utf-8') as f:
 		ncases = int(f.readline())
 		for case in range(1, ncases + 1):
 			R, C, M = read_case(f)
 			print('Case #{}:'.format(case))
 			b = Board(R, C, M)
 			b.solve()
 
 
 def main1():
 	b = Board(2, 1, 1)
 	; pdb.set_trace()
 	b.solve()
 
 
 if __name__ == '__main__':
 	main()
",49,515,1650
"(f):
 	return map(float, f.readline().split())
 
 
 def solve(C, F, X, rate=2.0):
 	accum = 0
 	while 1:
 		goal1 = X / rate
 	
 		farm = C / rate
 		goal2 = farm + (X / (rate + F))
 
 		if goal1 <= goal2:
 			return accum + goal1
 		else:
 			accum += farm
 			rate += F
 
 			
 def trunc(x, p=7):
 	m = 10 ** p
 	return round(x * m) / m
 
 
 def main():
 	fn = sys.argv[1]
 	with open(fn, encoding='utf-8') as f:
 		ncases = int(f.readline())
 		for case in range(1, ncases + 1):
 			C, F, X = read_case(f)
 			solution = solve(C, F, X)
 			print('Case #{}: {}'.format(case, trunc(solution)))
 
 
 if __name__ == '__main__':
 	main()
",49,516,320
"#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013
 #for the Google Code Jam programming contest
 
 ###############################################################################
 # Imports go here
 ###############################################################################
 
 #For faster numerical analysis
 #Needed for the memoization decorator
 ###############################################################################
 # Global variables (for caching, etc.) go here
 ###############################################################################
 
 ###############################################################################
 # Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)
 ###############################################################################
 
 class memoize(object):
    """"""Decorator. Caches a function's return value each time it is called.
    If called later with the same arguments, the cached value is returned
    (not reevaluated).
    """"""
    def __init__(self, func):
       self.func = func
       self.cache = {}
    def __call__(self, *args):
       if not isinstance(args, collections.Hashable):
          # uncacheable. a list, for instance.
          # better to not cache than blow up.
          return self.func(*args)
       if args in self.cache:
          return self.cache[args]
       else:
          value = self.func(*args)
          self.cache[args] = value
          return value
    def __repr__(self):
       '''Return the function's docstring.'''
       return self.func.__doc__
    def __get__(self, obj, objtype):
       '''Support instance methods.'''
       return functools.partial(self.__call__, obj)
 
 ###############################################################################
 # Functions
 ###############################################################################
 
 def precalculate():
     """"""Perform any calculations that need to be performed before the main path
     (e.g., preparing lookup tables, etc.)
     
     N.B. Make sure you make any important variables global so that other
     functions can access them.
     """"""
     pass
 
 def read_input(infile):
     """"""This function should take an open input file, load in all of the
     relevant information for a single case of the problem, and output it
     as a single object.    
     """"""
     #Some utility functions to read in particular types of input
     def read_int():
         return int(infile.readline().strip())
     def read_ints():
         return np.array(infile.readline().split(), dtype=int)
     def read_bigints(): #For ints that won't fit directly in an int32 array
         line = infile.readline().split()
         return np.array(map(lambda x: int(x), line))
     def read_float():
         return float(infile.readline().strip())
     def read_floats():
         return np.array(infile.readline().split(), dtype=float)
     def read_string():
         return infile.readline().strip()
     def read_strings():
         return np.array(infile.readline().split(), dtype=object) #N.B. general dtype
     
     ans1 = read_int()
     grid1 = np.zeros((4,4), dtype=int)
     for i in range(4):
         grid1[i] = read_ints()
     
     ans2 = read_int()
     grid2 = np.zeros((4,4), dtype=int)
     for i in range(4):
         grid2[i] = read_ints()
     
     
     case = (ans1, grid1, ans2, grid2)
     
     return case
 
 def solve_case(case):
     """"""Take the input data (structured in case) and perform any necessary
     calculations to obtain the desired output, formatted as the appropriate
     string.    
     """"""
     
     ans1, grid1, ans2, grid2 = case
     
     valid = set(grid1[ans1-1]) & set(grid2[ans2-1])
     
     #print valid
     #print ans1, grid1, ans2, grid2
     #print grid1[ans1], grid2[ans2]
     
     if len(valid) == 1:
         output = valid.pop()
     elif len(valid) > 1:
         output = ""Bad magician!""
     elif len(valid) < 1:
         output = ""Volunteer cheated!""
     return output
 
 ###############################################################################
 # Main execution path
 ###############################################################################
 
 if __name__ == ""__main__"":
     #Do any pre-calculations required
     precalculate()
     
     #Open up the input & output files based on the provided input file
     assert len(sys.argv) == 2 #only one argument
     assert sys.argv[1][-3:] == "".in"" #input must end with .in
     infile = open(""%s"" % sys.argv[1], 'r')
     outfile = open(""%s.out"" % sys.argv[1][:-3], 'w')
     
     #Read in the number of cases (the first input line) to iterate through
     cases = int(infile.readline().strip('\n'))
     for i in range(cases):
         
         #Read in the input data for this case
         case = read_input(infile)
         
         #Solve the problem for this case
         output = solve_case(case)
         
         #Write out the output of this case
         outfile.write('Case #%i: %s\n' % (i+1, output))
         print 'Case #%i: %s\n' % (i+1, output)
     
     #Close files
     infile.close()
     outfile.close()",50,517,1407
"#Code copyright Brett Olsen, 2012
 
 #Standard imports
 #Some switching behavior to set standard input/output files
 #Set these three variables to adjust behavior
 case = 1
 problem = ""C""
 practice = False
 
 if practice:
     practice = ""-practice""
 else:
     practice = ""-attempt0""
 if case == 0:
     infile = open(""%s-%s%s.in"" % (problem, ""sample"", practice), 'r')
     outfile = open(""%s-%s%s.out"" % (problem, ""sample"", practice), 'w')        
 elif case == 1:
     infile = open(""%s-%s%s.in"" % (problem, ""small"", practice), 'r')
     outfile = open(""%s-%s%s.out"" % (problem, ""small"", practice), 'w')    
 elif case == 2:
     infile = open(""%s-%s%s.in"" % (problem, ""large"", practice), 'r')
     outfile = open(""%s-%s%s.out"" % (problem, ""large"", practice), 'w')   
 else:
     raise ValueError, 'Invalid case'
     
 def permute(num, maxval):
     assert type(num) == int
     output = []
     digits = int(N.ceil(N.log10(num)))
     current = num
     for i in range(digits-1):
         current = current / 10 + 10**(digits-1) * (current % 10)
         if current <= num: #We only want permutations greater than num (for uniqueness)
             continue
         if current > maxval: #only permutations less than the maximum value
             continue
         if current not in output:
             output.append(current)
 #    return output
     return len(output)
     
 def count_recycled(A, B):
     count = 0
     for num in xrange(A, B+1):
         count += permute(num, B)
     return count
     
 #Read in the number of cases (the first input line) we need to iterate through
 cases = int(infile.readline().strip('\n'))
 for i in range(cases):
 ##################NEW CODE GOES HERE###########################################    
     #Read in all relevant data for each case
     A, B = infile.readline().split()
     A = int(A)
     B = int(B)
     
     #Do calculations to generate the output
     output = '%i' % count_recycled(A, B)
     
 ##################NEW CODE GOES HERE###########################################    
     #Write out the results for this case
     outfile.write('Case #%i: %s\n' % (i+1, output))
     
 #Close files
 infile.close()
 outfile.close()",50,518,700
"#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013
 #for the Google Code Jam programming contest
 
 ###############################################################################
 # Imports go here
 ###############################################################################
 
 ###############################################################################
 # Global variables (for caching, etc.) go here
 ###############################################################################
 
 #Set up the input/output files: problem-tagsuffix.in / *.out
 problem = ""A""
 tag = ""small"" #commonly sample, small, or large
 suffix = ""-attempt1"" #used sometimes for indexing later input files
 
 ###############################################################################
 # Helper functions go here
 ###############################################################################
 
 def read_input(infile):
     """"""This function should take an open input file, load in all of the
     relevant information for a single case of the problem, and output it
     as a single object.    
     """"""
     #Some utility functions to read in particular types of input
     def read_int():
         return int(infile.readline().strip())
     def read_ints():
         return np.array(infile.readline().split(), dtype=int)
     def read_float():
         return float(infile.readline().strip())
     def read_floats():
         return np.array(infile.readline().split(), dtype=float)
     def read_string():
         return infile.readline().strip()
     def read_strings():
         return np.array(infile.readline().split(), dtype=object) #change the dtype?
     
     board = np.empty((4,4), dtype=int)
     
     dic = {'X': 1, 'T': 2, 'O': 3, '.': 4}
     
     #Read in rows
     for i in range(4):
         line = read_string()
         for j in range(4):
             board[i,j] = dic[line[j]]
     infile.readline()
     
     return board
 
 def iswin(row):
     if 4 in row:
         return None #gap
     if (row <= 2).all():
         return ""X won""
     if (row >= 2).all():
         return ""O won""
     return None
 
 def solve_case(case):
     """"""Take the input data (structured in case) and perform any necessary
     calculations to obtain the desired output, formatted as the appropriate
     string.    
     """"""
     
     board = case
 
     #Look for win conditions
     for i in range(4):
         row = board[i,:]
         if iswin(row) is not None:
             return iswin(row)
         
     for i in range(4):
         col = board[:,i]
         if iswin(col) is not None:
             return iswin(col)
         
     vals = np.arange(4)
     diag = board[vals,vals]
     if iswin(diag) is not None:
         return iswin(diag)
     
     diag = board[vals, vals[::-1]]
     if iswin(diag) is not None:
         return iswin(diag)
 
     #Check if the board is completed (has empty squares left)
     if 4 in board:
         return ""Game has not completed""
     
     return ""Draw""
 
 ###############################################################################
 # Main execution path
 ###############################################################################
 
 if __name__ == ""__main__"":
     #Open up the input & output files
     infile = open(""%s-%s%s.in"" % (problem, tag, suffix), 'r')
     outfile = open(""%s-%s%s.out"" % (problem, tag, suffix), 'w')
     
     #Read in the number of cases (the first input line) to iterate through
     cases = int(infile.readline().strip('\n'))
     for i in range(cases):
         
         #Read in the input data for this case
         case = read_input(infile)
         
         #Solve the problem for this case
         output = solve_case(case)
         
         #Write out the output of this case
         outfile.write('Case #%i: %s\n' % (i+1, output))
         print 'Case #%i: %s\n' % (i+1, output)
     
     #Close files
     infile.close()
     outfile.close()",50,519,1098
"#Code copyright Brett Olsen, 2012
 
 #Standard imports
 #Some switching behavior to set standard input/output files
 #Set these three variables to adjust behavior
 case = 1
 problem = ""B""
 practice = False
 
 if practice:
     practice = ""-practice""
 else:
     practice = ""-attempt0""
 if case == 0:
     infile = open(""%s-%s%s.in"" % (problem, ""sample"", practice), 'r')
     outfile = open(""%s-%s%s.out"" % (problem, ""sample"", practice), 'w')        
 elif case == 1:
     infile = open(""%s-%s%s.in"" % (problem, ""small"", practice), 'r')
     outfile = open(""%s-%s%s.out"" % (problem, ""small"", practice), 'w')    
 elif case == 2:
     infile = open(""%s-%s%s.in"" % (problem, ""large"", practice), 'r')
     outfile = open(""%s-%s%s.out"" % (problem, ""large"", practice), 'w')   
 else:
     raise ValueError, 'Invalid case'
     
 #Hash table:  -1 is never, +1 is always, 0 is sometimes
 lookup = {}
 
 def check_total(total, p):
     assert type(total) == int
     resid = total % 3
 
     min_nosurprise = (total / 3)    
     max_nosurprise = (total / 3) + min(1, resid)
     
     #print min_nosurprise, max_nosurprise
     
     #If the residual is 1, then being surprising won't change the max value
     #similarly, if we're already at the maximum, it can't change
     #similarly, if residual is 0 and the min value is already 0, it can't change
     if resid == 1 or max_nosurprise == 10 or (resid == 0 and min_nosurprise == 0):
         if max_nosurprise >= p:
             return 1
         else:
             return -1
 
     if max_nosurprise >= p:
         return 1
     elif max_nosurprise == p-1:
         return 0
     else:
         return -1
     
 #Read in the number of cases (the first input line) we need to iterate through
 cases = int(infile.readline().strip('\n'))
 for i in range(cases):
     print 'case %i of %i' % (i+1, cases)
 ##################NEW CODE GOES HERE###########################################    
     #Read in all relevant data for each case
     line = infile.readline().split()
     N = int(line[0])
     S = int(line[1])
     p = int(line[2])
     points = []
     for item in line[3:]:
         points.append(int(item))
     assert N == len(points)
     assert p <= 10
     assert p >= 0
     assert S >= 0
     assert S <= N
     
     always = 0
     possible = 0
     
     for total in points:
         if (total, p) in lookup:
             depends = lookup[total, p]
         else:
             depends = check_total(total, p)
         
         if depends == 1:
             always += 1
         elif depends == 0:
             possible += 1
     
     #Do calculations to generate the output
     output = '%i' % (always + min(possible, S))
     
 ##################NEW CODE GOES HERE###########################################    
     #Write out the results for this case
     outfile.write('Case #%i: %s\n' % (i+1, output))
     
 #Close files
 infile.close()
 outfile.close()",50,520,955
"#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013
 #for the Google Code Jam programming contest
 
 ###############################################################################
 # Imports go here
 ###############################################################################
 
 #For faster numerical analysis
 #Needed for the memoization decorator
 ###############################################################################
 # Global variables (for caching, etc.) go here
 ###############################################################################
 
 ###############################################################################
 # Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)
 ###############################################################################
 
 class memoize(object):
    """"""Decorator. Caches a function's return value each time it is called.
    If called later with the same arguments, the cached value is returned
    (not reevaluated).
    """"""
    def __init__(self, func):
       self.func = func
       self.cache = {}
    def __call__(self, *args):
       if not isinstance(args, collections.Hashable):
          # uncacheable. a list, for instance.
          # better to not cache than blow up.
          return self.func(*args)
       if args in self.cache:
          return self.cache[args]
       else:
          value = self.func(*args)
          self.cache[args] = value
          return value
    def __repr__(self):
       '''Return the function's docstring.'''
       return self.func.__doc__
    def __get__(self, obj, objtype):
       '''Support instance methods.'''
       return functools.partial(self.__call__, obj)
 
 ###############################################################################
 # Functions
 ###############################################################################
 
 def precalculate():
     """"""Perform any calculations that need to be performed before the main path
     (e.g., preparing lookup tables, etc.)
     
     N.B. Make sure you make any important variables global so that other
     functions can access them.
     """"""
     pass
 
 def read_input(infile):
     """"""This function should take an open input file, load in all of the
     relevant information for a single case of the problem, and output it
     as a single object.    
     """"""
     #Some utility functions to read in particular types of input
     def read_int():
         return int(infile.readline().strip())
     def read_ints():
         return np.array(infile.readline().split(), dtype=int)
     def read_bigints(): #For ints that won't fit directly in an int32 array
         line = infile.readline().split()
         return np.array(map(lambda x: int(x), line))
     def read_float():
         return float(infile.readline().strip())
     def read_floats():
         return np.array(infile.readline().split(), dtype=float)
     def read_string():
         return infile.readline().strip()
     def read_strings():
         return np.array(infile.readline().split(), dtype=object) #N.B. general dtype
     
     N = read_int()
     naomi = read_floats()
     ken = read_floats()
     naomi.sort()
     ken.sort()
     assert len(naomi) == N
     assert len(ken) == N
     
     return naomi, ken
 
 def ken_choice(told_naomi, ken, ken_free):
     #Ken's strategy is as follows:  if he has no block heavier than what Naomi
     #tells him, then he chooses his smallest block.  Otherwise, he chooses the smallest
     #block that is heavier than what she tells him.
     #N.B. ken should be provided as a sorted list from smallest to largest.
     N = len(ken)
     lowest = None
     for j in range(N):
         if not ken_free[j]:
             continue
         if lowest is None:
             lowest, idx = ken[j], j
         if ken[j] > told_naomi:
             return ken[j], j
     return lowest, idx
 
 def normal_war(naomi, ken):
     #Naomi's strategy is to play blocks from largest to smallest,
     #Ken's strategy is to play the smallest block that could beat Naomi's,
     #or the smallest block if he has none that can do so.
     #Runs as N^2, fast enough even with N=1000
     
     #Appears to be validated as the best strategy, checked it with 
     #a complete exponential solution on the small import - no differences.
     N = len(naomi)
     ken_free = np.ones(N, dtype=bool)
     score = 0
     for i in range(N)[::-1]:
         chosen_naomi = naomi[i]
         chosen_ken, j = ken_choice(chosen_naomi, ken, ken_free)
         ken_free[j] = False
         
         if chosen_naomi > chosen_ken:
             score += 1
     return score
 
 
 def new_deceitful_war(naomi, ken):
     score = 0
     
     N = len(naomi)
     
     for i in range(N):
         if naomi[-1] > ken[-1]:
             score += 1
             naomi = naomi[:-1]
             ken = ken[:-1]
         else:
             naomi = naomi[1:]
             ken = ken[:-1]
     return score
 
 
 def deceitful_war(naomi, ken):
     #Naomi certainly can't win with blocks that are lower than all of Ken's
     #blocks.  But Naomi can lie about these blocks' weight to use up key blocks
     #of Ken's. 
     
     
     #, and will also lose against all of Ken's blocks that are larger
     #than all of her blocks.  So Naomi can lie using her lowest blocks to
     #use up Ken's highest blocks to remove these guaranteed losses.
     
     
     #Naomi's strategy is to use her no-hopers (those that are lower
     #than all of Ken's blocks) to fish out Ken's highest weight blocks.
     #Then she uses her lowest blocks to fish out any of Ken's best blocks
     #that will beat all of hers
     N = len(naomi)
     no_hopers = 0
     for i in range(N):
         if naomi[i] < ken[0]:
             no_hopers += 1
     #Some of Ken's blocks might be larger than all of hers
     def_losses = 0
     for i in range(N)[::-1]:
         if ken[i] > naomi[-1]:
             def_losses += 1
     
     #Then she goes through the rest and tries to win in order
     edge = max(no_hopers, def_losses)
     naomi = naomi[edge:]
     ken = ken[:N-edge]
 
     '''
     print ""After removing sure losers:""
     print N, N-edge, edge
     if N - edge > 0:
         if min(naomi) < max(ken):
             print naomi
             print ken
     '''
 
     #print len(naomi), len(ken), edge
 
     score = 0
     for i in range(N - edge):
         if naomi[i] > ken[i]:
             score += 1
             
     return score
 
 def solve_case(case):
     """"""Take the input data (structured in case) and perform any necessary
     calculations to obtain the desired output, formatted as the appropriate
     string.    
     """"""
     
     naomi, ken = case
     print naomi
     print ken
     
     new = new_deceitful_war(naomi, ken)
     
     good, bad = deceitful_war(naomi, ken), normal_war(naomi, ken)
     
     if not new == good:
         print 'Hey!', new, good
     
     output = ""%i %i"" % (new, bad)
     return output
 
 ###############################################################################
 # Main execution path
 ###############################################################################
 
 if __name__ == ""__main__"":
     #Do any pre-calculations required
     precalculate()
     
     #Open up the input & output files based on the provided input file
     assert len(sys.argv) == 2 #only one argument
     assert sys.argv[1][-3:] == "".in"" #input must end with .in
     infile = open(""%s"" % sys.argv[1], 'r')
     outfile = open(""%s.out"" % sys.argv[1][:-3], 'w')
     
     #Read in the number of cases (the first input line) to iterate through
     cases = int(infile.readline().strip('\n'))
     for i in range(cases):
         
         #Read in the input data for this case
         case = read_input(infile)
         
         #Solve the problem for this case
         output = solve_case(case)
         
         #Write out the output of this case
         outfile.write('Case #%i: %s\n' % (i+1, output))
         print 'Case #%i: %s\n' % (i+1, output)
     
     #Close files
     infile.close()
     outfile.close()",50,521,2367
"#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013
 #for the Google Code Jam programming contest
 
 ###############################################################################
 # Imports go here
 ###############################################################################
 
 ###############################################################################
 # Global variables (for caching, etc.) go here
 ###############################################################################
 
 #Set up the input/output files: problem-tagsuffix.in / *.out
 problem = ""C""
 tag = ""small"" #commonly sample, small, or large
 #tag = ""large""
 #tag = ""sample""
 suffix = ""-attempt0"" #used sometimes for indexing later input files
 #suffix = """"
 #From http://oeis.org/A002779/b002779.txt
 #Lazy route for the first two sets!
 #Numbers that are both squares and palindromes
 table_of_fairs = np.array([0, 1, 4, 9, 121, 484, 676, 10201, 12321, 14641, 
 40804, 44944, 69696, 94249, 698896, 1002001, 1234321, 4008004, 5221225, 6948496, 
 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 
 404090404, 522808225, 617323716, 942060249, 10000200001, 10221412201, 12102420121, 
 12345654321, 40000800004, 637832238736, 1000002000001, 1002003002001, 1004006004001, 
 1020304030201, 1022325232201, 1024348434201, 1086078706801, 1210024200121, 
 1212225222121, 1214428244121, 1230127210321, 1232346432321, 1234567654321, 
 1615108015161, 4000008000004, 4004009004004, 4051154511504, 5265533355625, 
 9420645460249, 100000020000001, 100220141022001, 102012040210201, 102234363432201, 
 121000242000121, 121242363242121, 123212464212321, 123456787654321, 
 123862676268321, 144678292876441, 165551171155561, 400000080000004, 
 900075181570009, 4099923883299904, 10000000200000001, 10002000300020001, 
 10004000600040001, 10020210401202001, 10022212521222001, 10024214841242001, 
 10201020402010201, 10203040504030201, 10205060806050201, 10221432623412201, 
 10223454745432201, 12100002420000121, 12102202520220121, 12104402820440121, 
 12120030703002121, 12122232623222121, 12124434743442121, 12321024642012321, 
 12323244744232321, 12341234943214321, 12343456865434321, 12345678987654321, 
 40000000800000004, 40004000900040004, 94206450305460249, 1000000002000000001, 
 1000220014100220001, 1002003004003002001, 1002223236323222001, 1020100204020010201, 
 1020322416142230201, 1022123226223212201, 1022345658565432201, 1210000024200000121, 
 1210242036302420121, 1212203226223022121, 1212445458545442121, 1232100246420012321, 
 1232344458544432321, 1234323468643234321, 4000000008000000004, 4253436912196343524, 
 6158453974793548516, 100000000020000000001, 100002000030000200001, 100004000060000400001, 
 100020201040102020001, 100022201252102220001, 100024201484102420001, 
 100200120040021002001, 100202122050221202001, 100204124080421402001, 
 100220341262143022001, 100222343474343222001, 102010002040200010201, 
 102012022050220210201, 102014042080240410201, 102030405060504030201, 
 102032425272524230201, 102132537636735231201, 102210100272001012201, 102212122262221212201, 
 102214144272441412201, 102230523292325032201, 102232545484545232201, 102234567696765432201, 
 104190107303701091401, 121000000242000000121, 121002200252002200121, 121004400282004400121, 
 121020021070120020121, 121022221262122220121, 121024421474124420121, 121220122262221022121, 
 121222324272423222121, 121240161292161042121, 121242363484363242121, 121244565696565442121, 
 123210002464200012321, 123212222474222212321, 123230205292502032321, 123232425484524232321, 
 123234645696546432321, 123432124686421234321, 123434346696643434321, 184398883818388893481, 
 400000000080000000004, 400004000090000400004, 522815090696090518225, 906086675171576680609, 
 942064503484305460249, 6916103777337773016196, 10000000000200000000001, 10000220001410002200001, 
 10002002100400120020001, 10002222123632122220001, 10020010200400201002001, 10020230421612403202001, 
 10022014302620341022001, 10022234545854543222001, 10201000020402000010201, 10201222221612222210201, 
 10203022140604122030201, 10203244363836344230201, 10221210222622201212201, 10221432643834623412201, 
 10223234344844343232201, 10224609234443290642201, 12100000002420000000121, 12100242003630024200121,
 12102202302620320220121, 12102444325852344420121, 12122010222622201022121, 12122252443834425222121, 
 12124214524842541242121, 12321000024642000012321, 12321244225852244212321, 12323222344844322232321, 
 12343210246864201234321, 12384043938083934048321, 12599536942224963599521, 16593841302620314839561, 
 40000000000800000000004, 1000000000002000000000001, 1000002000003000002000001, 
 1000004000006000004000001, 1000020200104010020200001, 1000022200125210022200001, 1000024200148410024200001, 1000200030004000300020001, 1000202030205020302020001, 1000204030408040304020001, 1000220232126212320220001, 1000222232347432322220001, 1002001002004002001002001, 1002003004005004003002001, 1002005006008006005002001, 1002021222306032221202001, 1002023224327234223202001, 1002201232026202321022001, 1002203234227224323022001, 1002221454348434541222001, 1002223456569656543222001, 1020100000204020000010201, 1020102020205020202010201, 1020104040208020404010201, 1020120402306032040210201, 1020122422327232242210201, 1020300010207020100030201, 1020302030406040302030201, 1020304050607060504030201, 1020320414309034140230201, 1020322434528254342230201, 1020324454749474544230201, 1022121002226222001212201, 1022123024227224203212201, 1022141424528254241412201, 1022143446549456443412201, 1022321210249420121232201, 1022323232448442323232201, 1022325254649464525232201, 1210000000024200000000121, 1210002200025200022000121, 1210004400028200044000121, 1210020020107010200200121, 1210022220126210222200121, 1210024420147410244200121, 1210220032026202300220121, 1210222232227222322220121, 1210242254148414522420121, 1210244454369634544420121, 1212201002226222001022121, 1212203204227224023022121, 1212221040509050401222121, 1212223242528252423222121, 1212225444549454445222121, 1212421234248424321242121, 1212423436449446343242121, 1232100000246420000012321, 1232102220247420222012321, 1232120202329232020212321, 1232122422348432242212321, 1232124642369632464212321, 1232322032448442302232321, 1232324252649462524232321, 1234321002468642001234321, 1234323224469644223234321, 1821056104269624016501281, 4000000000008000000000004, 4000004000009000004000004, 4618627222542452227268164, 6942236477330337746322496, 9420645034800084305460249, 40460195511188111559106404, 100000000000020000000000001, 100000220000141000022000001, 100002002010040010200200001, 100002222012363210222200001, 100020001200040002100020001, 100020221222161222122020001, 100022003410262014300220001, 100022223434585434322220001, 100200100020040020001002001, 100200320240161042023002001, 100202104032060230401202001, 100202324254383452423202001, 100220121220262022121022001, 100220341462383264143022001, 100222125432484234521222001, 102010000002040200000010201, 102010222202161202222010201, 102012022032060230220210201, 102012244234383432442210201, 102030201204060402102030201, 102030423426181624324030201, 102032223434282434322230201, 102212100022262220001212201, 102212322442383244223212201, 102214124054282450421412201, 102232321224484422123232201, 121000000000242000000000121, 121000242000363000242000121, 121002202210262012202200121, 121002444212585212444200121, 121022001220262022100220121, 121022243242383242342220121, 121024203630484036302420121, 121220100022262220001022121, 121220342242383242243022121, 121222304234282432403222121, 121242121242484242121242121, 123210000002464200000012321, 123210244202585202442012321, 123212222232484232222212321, 123232201224484422102232321, 123432100024686420001234321, 400000000000080000000000004, 923860899791363197998068329, 4872133543202112023453312784, 9658137819052882509187318569, 10000000000000200000000000001, 10000002000000300000020000001, 10000004000000600000040000001, 10000020200010401000202000001, 10000022200012521000222000001, 10000024200014841000242000001, 10000200021000400012000200001, 10000202021020502012020200001, 10000204021040804012040200001, 10000220221212621212202200001, 10000222221234743212222200001, 10002000102000400020100020001, 10002002102200500220120020001, 10002004102400800420140020001, 10002020304030603040302020001, 10002022304232723240322020001, 10002200143002620034100220001, 10002202143222722234120220001, 10002220345234843254302220001, 10002222345456965454322220001, 10020010000200400200001002001, 10020012002200500220021002001, 10020014004200800240041002001, 10020030220410601402203002001, 10020032222412721422223002001, 10020210221220602212201202001, 10020212223240704232221202001, 10020230441632823614403202001, 10020232443654945634423202001, 10022010100002720000101022001, 10022012102202620220121022001, 10022014104402720440141022001, 10022030322230903222303022001, 10022032324432823442323022001, 10022034326634943662343022001, 10022210341004940014301222001, 10022212343224842234321222001, 10022214345444944454341222001, 10201000000020402000000010201, 10201002020020502002020010201, 10201004040020802004040010201, 10201020402030603020402010201, 10201022422032723022422010201, 10201200001200700210000210201, 10201202021220602212020210201, 10201204041240704214040210201, 10201220403410901430402210201, 10201222423432823432422210201, 10201224443454945434442210201, 10203020102040604020102030201, 10203022122240704222122030201, 10203040506070807060504030201, 10203042526272927262524030201, 10203220123022922032102230201, 10203222143242824234122230201, 10203224163462926436142230201, 10221210000222622200001212201, 10221212022222722222021212201, 10221230422432823422403212201, 10221232444434943444423212201, 10221412221442824412221412201, 10221414243462926434241412201, 10223232102244844220123232201, 10223234124444944442143232201, 12100000000002420000000000121, 12100002200002520000220000121, 12100004400002820000440000121, 12100020020010701002002000121, 12100022220012621002222000121, 12100024420014741002442000121, 12100220023002620032002200121, 12100222223022722032222200121, 12100242243214841234224200121, 12100244443236963234444200121, 12102200102202620220100220121, 12102202302402720420320220121, 12102220124030903042102220121, 12102222324232823242322220121, 12102224524434943442542220121, 12102420145204840254102420121, 12102422345424942454322420121, 12122010000222622200001022121, 12122012202222722220221022121, 12122032240432823404223022121, 12122034442434943424443022121, 12122230223242824232203222121, 12122232425262926252423222121, 12124212102424842420121242121, 12124214304624942640341242121, 12321000000024642000000012321, 12321002220024742002220012321, 12321020202032923020202012321, 12321022422034843022422012321, 12321024642036963024642012321, 12321222023224842232022212321, 12321224243244944234242212321, 12323220102244844220102232321, 12323222322444944422322232321, 12343210000246864200001234321, 12343212222246964222221234321, 16799008923862526832980099761, 40000000000000800000000000004, 40000004000000900000040000004, 44431002775280908257720013444, 98693567900935453900976539689, 1000000000000002000000000000001, 1000000220000014100000220000001, 1000002002001004001002002000001, 1000002222001236321002222000001, 1000020000300004000030000200001, 1000020220302216122030220200001, 1000022002321026201232002200001, 1000022222323458543232222200001, 1000200010020004000200100020001, 1000200230042016102400320020001, 1000202012221206021222102020001, 1000202232243438343422322020001, 1000220012320026200232100220001, 1000220232344238324432320220001, 1000222014541248421454102220001, 1002001000002004002000001002001, 1002001220222016102220221002001, 1002003004005006005004003002001, 1002003224225238325224223002001, 1002021020302206022030201202001, 1002021240524418144250421202001, 1002023024325228225234203202001, 1002201210022026202200121022001, 1002201430264038304620341022001, 1002203214225228225224123022001, 1002221232322248422232321222001, 1020100000000204020000000010201, 1020100222200216120022220010201, 1020102022021206021202202010201, 1020102244221438341224422010201, 1020120200302206022030020210201, 1020120422504418144052240210201, 1020122222343228223432222210201, 1020302010020406040200102030201, 1020302232242418142422322030201, 1020304032241608061422304030201, 1020322212322428242232122230201, 1022121000002226222000001212201, 1022121222422238322242221212201, 1022123024025228225204203212201, 1022141220304428244030221412201, 1022323210022448442200123232201, 1210000000000024200000000000121, 1210000242000036300002420000121, 1210002202201026201022022000121, 1210002444201258521024442000121, 1210022000320026200230002200121, 1210022242322238322232422200121, 1210024202541048401452024200121, 1210220010022026202200100220121, 1210220252044038304402520220121, 1210222212423228223242122220121, 1210242012342048402432102420121, 1212201000002226222000001022121, 1212201242222238322222421022121, 1212203204205228225024023022121, 1212223020322428242230203222121, 1212421210024248424200121242121, 1232100000000246420000000012321, 1232100244200258520024420012321, 1232102222221248421222222012321, 1232122200322248422230022212321, 1232322010022448442200102232321, 1234321000002468642000001234321, 4000000000000008000000000000004, 4844486878939076709398786844484, 6574372239019762679109322734756, 9403095533541415141453355903049, 9659504223792743472973224059569, 9848294822582726272852284928489
 ])
 
 #and here we've filtered the table
 filtered_table = np.array([0, 1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001,
        1234321, 4008004, 100020001, 102030201, 104060401, 121242121,
        123454321, 125686521, 400080004, 404090404, 10000200001,
        10221412201, 12102420121, 12345654321, 40000800004, 1000002000001,
        1002003002001, 1004006004001, 1020304030201, 1022325232201,
        1024348434201, 1210024200121, 1212225222121, 1214428244121,
        1232346432321, 1234567654321, 4000008000004, 4004009004004,
        100000020000001, 100220141022001, 102012040210201, 102234363432201,
        121000242000121, 121242363242121, 123212464212321, 123456787654321,
        400000080000004, 10000000200000001, 10002000300020001,
        10004000600040001, 10020210401202001, 10022212521222001,
        10024214841242001, 10201020402010201, 10203040504030201,
        10205060806050201, 10221432623412201, 10223454745432201,
        12100002420000121, 12102202520220121, 12104402820440121,
        12122232623222121, 12124434743442121, 12321024642012321,
        12323244744232321, 12343456865434321, 12345678987654321,
        40000000800000004, 40004000900040004, 1000000002000000001,
        1000220014100220001, 1002003004003002001, 1002223236323222001,
        1020100204020010201, 1020322416142230201, 1022123226223212201,
        1022345658565432201, 1210000024200000121, 1210242036302420121,
        1212203226223022121, 1212445458545442121, 1232100246420012321,
        1232344458544432321, 1234323468643234321, 4000000008000000004,
        100000000020000000001, 100002000030000200001, 100004000060000400001,
        100020201040102020001, 100022201252102220001, 100024201484102420001,
        100200120040021002001, 100202122050221202001, 100204124080421402001,
        100220341262143022001, 100222343474343222001, 102010002040200010201,
        102012022050220210201, 102014042080240410201, 102030405060504030201,
        102032425272524230201, 102212122262221212201, 102214144272441412201,
        102232545484545232201, 102234567696765432201, 121000000242000000121,
        121002200252002200121, 121004400282004400121, 121022221262122220121,
        121024421474124420121, 121220122262221022121, 121222324272423222121,
        121242363484363242121, 121244565696565442121, 123210002464200012321,
        123212222474222212321, 123232425484524232321, 123234645696546432321,
        123432124686421234321, 123434346696643434321, 400000000080000000004,
        400004000090000400004, 10000000000200000000001,
        10000220001410002200001, 10002002100400120020001,
        10002222123632122220001, 10020010200400201002001,
        10020230421612403202001, 10022014302620341022001,
        10022234545854543222001, 10201000020402000010201,
        10201222221612222210201, 10203022140604122030201,
        10203244363836344230201, 10221210222622201212201,
        10221432643834623412201, 10223234344844343232201,
        12100000002420000000121, 12100242003630024200121,
        12102202302620320220121, 12102444325852344420121,
        12122010222622201022121, 12122252443834425222121,
        12124214524842541242121, 12321000024642000012321,
        12321244225852244212321, 12323222344844322232321,
        12343210246864201234321, 40000000000800000000004,
        1000000000002000000000001, 1000002000003000002000001,
        1000004000006000004000001, 1000020200104010020200001,
        1000022200125210022200001, 1000024200148410024200001,
        1000200030004000300020001, 1000202030205020302020001,
        1000204030408040304020001, 1000220232126212320220001,
        1000222232347432322220001, 1002001002004002001002001,
        1002003004005004003002001, 1002005006008006005002001,
        1002021222306032221202001, 1002023224327234223202001,
        1002201232026202321022001, 1002203234227224323022001,
        1002221454348434541222001, 1002223456569656543222001,
        1020100000204020000010201, 1020102020205020202010201,
        1020104040208020404010201, 1020120402306032040210201,
        1020122422327232242210201, 1020302030406040302030201,
        1020304050607060504030201, 1020322434528254342230201,
        1020324454749474544230201, 1022121002226222001212201,
        1022123024227224203212201, 1022141424528254241412201,
        1022143446549456443412201, 1022323232448442323232201,
        1022325254649464525232201, 1210000000024200000000121,
        1210002200025200022000121, 1210004400028200044000121,
        1210022220126210222200121, 1210024420147410244200121,
        1210220032026202300220121, 1210222232227222322220121,
        1210242254148414522420121, 1210244454369634544420121,
        1212201002226222001022121, 1212203204227224023022121,
        1212223242528252423222121, 1212225444549454445222121,
        1212421234248424321242121, 1212423436449446343242121,
        1232100000246420000012321, 1232102220247420222012321,
        1232122422348432242212321, 1232124642369632464212321,
        1232322032448442302232321, 1232324252649462524232321,
        1234321002468642001234321, 1234323224469644223234321,
        4000000000008000000000004, 4000004000009000004000004,
        100000000000020000000000001, 100000220000141000022000001,
        100002002010040010200200001, 100002222012363210222200001,
        100020001200040002100020001, 100020221222161222122020001,
        100022003410262014300220001, 100022223434585434322220001,
        100200100020040020001002001, 100200320240161042023002001,
        100202104032060230401202001, 100202324254383452423202001,
        100220121220262022121022001, 100220341462383264143022001,
        100222125432484234521222001, 102010000002040200000010201,
        102010222202161202222010201, 102012022032060230220210201,
        102012244234383432442210201, 102030201204060402102030201,
        102030423426181624324030201, 102032223434282434322230201,
        102212100022262220001212201, 102212322442383244223212201,
        102214124054282450421412201, 102232321224484422123232201,
        121000000000242000000000121, 121000242000363000242000121,
        121002202210262012202200121, 121002444212585212444200121,
        121022001220262022100220121, 121022243242383242342220121,
        121024203630484036302420121, 121220100022262220001022121,
        121220342242383242243022121, 121222304234282432403222121,
        121242121242484242121242121, 123210000002464200000012321,
        123210244202585202442012321, 123212222232484232222212321,
        123232201224484422102232321, 123432100024686420001234321,
        400000000000080000000000004, 10000000000000200000000000001,
        10000002000000300000020000001, 10000004000000600000040000001,
        10000020200010401000202000001, 10000022200012521000222000001,
        10000024200014841000242000001, 10000200021000400012000200001,
        10000202021020502012020200001, 10000204021040804012040200001,
        10000220221212621212202200001, 10000222221234743212222200001,
        10002000102000400020100020001, 10002002102200500220120020001,
        10002004102400800420140020001, 10002020304030603040302020001,
        10002022304232723240322020001, 10002200143002620034100220001,
        10002202143222722234120220001, 10002220345234843254302220001,
        10002222345456965454322220001, 10020010000200400200001002001,
        10020012002200500220021002001, 10020014004200800240041002001,
        10020030220410601402203002001, 10020032222412721422223002001,
        10020210221220602212201202001, 10020212223240704232221202001,
        10020230441632823614403202001, 10020232443654945634423202001,
        10022012102202620220121022001, 10022014104402720440141022001,
        10022032324432823442323022001, 10022034326634943662343022001,
        10022212343224842234321222001, 10022214345444944454341222001,
        10201000000020402000000010201, 10201002020020502002020010201,
        10201004040020802004040010201, 10201020402030603020402010201,
        10201022422032723022422010201, 10201202021220602212020210201,
        10201204041240704214040210201, 10201222423432823432422210201,
        10201224443454945434442210201, 10203020102040604020102030201,
        10203022122240704222122030201, 10203040506070807060504030201,
        10203042526272927262524030201, 10203222143242824234122230201,
        10203224163462926436142230201, 10221210000222622200001212201,
        10221212022222722222021212201, 10221230422432823422403212201,
        10221232444434943444423212201, 10221412221442824412221412201,
        10221414243462926434241412201, 10223232102244844220123232201,
        10223234124444944442143232201, 12100000000002420000000000121,
        12100002200002520000220000121, 12100004400002820000440000121,
        12100022220012621002222000121, 12100024420014741002442000121,
        12100220023002620032002200121, 12100222223022722032222200121,
        12100242243214841234224200121, 12100244443236963234444200121,
        12102200102202620220100220121, 12102202302402720420320220121,
        12102222324232823242322220121, 12102224524434943442542220121,
        12102420145204840254102420121, 12102422345424942454322420121,
        12122010000222622200001022121, 12122012202222722220221022121,
        12122032240432823404223022121, 12122034442434943424443022121,
        12122230223242824232203222121, 12122232425262926252423222121,
        12124212102424842420121242121, 12124214304624942640341242121,
        12321000000024642000000012321, 12321002220024742002220012321,
        12321022422034843022422012321, 12321024642036963024642012321,
        12321222023224842232022212321, 12321224243244944234242212321,
        12323220102244844220102232321, 12323222322444944422322232321,
        12343210000246864200001234321, 12343212222246964222221234321,
        40000000000000800000000000004, 40000004000000900000040000004,
        1000000000000002000000000000001, 1000000220000014100000220000001,
        1000002002001004001002002000001, 1000002222001236321002222000001,
        1000020000300004000030000200001, 1000020220302216122030220200001,
        1000022002321026201232002200001, 1000022222323458543232222200001,
        1000200010020004000200100020001, 1000200230042016102400320020001,
        1000202012221206021222102020001, 1000202232243438343422322020001,
        1000220012320026200232100220001, 1000220232344238324432320220001,
        1000222014541248421454102220001, 1002001000002004002000001002001,
        1002001220222016102220221002001, 1002003004005006005004003002001,
        1002003224225238325224223002001, 1002021020302206022030201202001,
        1002021240524418144250421202001, 1002023024325228225234203202001,
        1002201210022026202200121022001, 1002201430264038304620341022001,
        1002203214225228225224123022001, 1002221232322248422232321222001,
        1020100000000204020000000010201, 1020100222200216120022220010201,
        1020102022021206021202202010201, 1020102244221438341224422010201,
        1020120200302206022030020210201, 1020120422504418144052240210201,
        1020122222343228223432222210201, 1020302010020406040200102030201,
        1020302232242418142422322030201, 1020304032241608061422304030201,
        1020322212322428242232122230201, 1022121000002226222000001212201,
        1022121222422238322242221212201, 1022123024025228225204203212201,
        1022141220304428244030221412201, 1022323210022448442200123232201,
        1210000000000024200000000000121, 1210000242000036300002420000121,
        1210002202201026201022022000121, 1210002444201258521024442000121,
        1210022000320026200230002200121, 1210022242322238322232422200121,
        1210024202541048401452024200121, 1210220010022026202200100220121,
        1210220252044038304402520220121, 1210222212423228223242122220121,
        1210242012342048402432102420121, 1212201000002226222000001022121,
        1212201242222238322222421022121, 1212203204205228225024023022121,
        1212223020322428242230203222121, 1212421210024248424200121242121,
        1232100000000246420000000012321, 1232100244200258520024420012321,
        1232102222221248421222222012321, 1232122200322248422230022212321,
        1232322010022448442200102232321, 1234321000002468642000001234321,
        4000000000000008000000000000004], dtype=object)
 
 ###############################################################################
 # Helper functions go here
 ###############################################################################
 
 def read_input(infile):
     """"""This function should take an open input file, load in all of the
     relevant information for a single case of the problem, and output it
     as a single object.    
     """"""
     #Some utility functions to read in particular types of input
     def read_int():
         return int(infile.readline().strip())
     def read_ints():
         return np.array(infile.readline().split(), dtype=int)
     def read_bigints():
         line = infile.readline().split()
         return np.array(map(lambda x: int(x), line))
     def read_float():
         return float(infile.readline().strip())
     def read_floats():
         return np.array(infile.readline().split(), dtype=float)
     def read_string():
         return infile.readline().strip()
     def read_strings():
         return np.array(infile.readline().split(), dtype=object) #change the dtype?
     
     A, B = read_bigints()
     
     return (A, B)
 
 def is_palindrome(num):
     digits = []
     num = int(num)
     while num > 0:
         digits.append(num % 10)
         num = num / 10 #n.b. int division (discard remainder)
 
     return digits == digits[::-1]
 
     for i in range(len(digits) / 2): #n.b. int division (skips center)
         if digits[i] != digits[-i+1]:
             return False
     return True
 
 def solve_case_simple(case):
     A, B = case
     
     if B > table_of_fairs[-1]:
         raise ValueError, ""Ranges too big for lookup table!""
     
     valid = (A <= filtered_table) * (filtered_table <= B)
     return valid.sum()
 
 def solve_case(case):
     """"""Take the input data (structured in case) and perform any necessary
     calculations to obtain the desired output, formatted as the appropriate
     string.    
     """"""
     
     output = solve_case_simple(case)
     return output
 
 ###############################################################################
 # Main execution path
 ###############################################################################
 
 if __name__ == ""__main__"":
     #Open up the input & output files
     infile = open(""%s-%s%s.in"" % (problem, tag, suffix), 'r')
     outfile = open(""%s-%s%s.out"" % (problem, tag, suffix), 'w')
     
     #Read in the number of cases (the first input line) to iterate through
     cases = int(infile.readline().strip('\n'))
     for i in range(cases):
         
         #Read in the input data for this case
         case = read_input(infile)
         
         #Solve the problem for this case
         output = solve_case(case)
         
         #Write out the output of this case
         outfile.write('Case #%i: %s\n' % (i+1, output))
         print 'Case #%i: %s\n' % (i+1, output)
     
     #Close files
     infile.close()
     outfile.close()",50,522,24550
"#Code copyright Brett Olsen, 2012
 
 #Standard imports
 #Some switching behavior to set standard input/output files
 #Set these three variables to adjust behavior
 case = 1
 problem = ""A""
 practice = False
 
 if practice:
     practice = ""-practice""
 else:
     practice = ""-attempt0""
 if case == 0:
     infile = open(""%s-%s%s.in"" % (problem, ""sample"", practice), 'r')
     outfile = open(""%s-%s%s.out"" % (problem, ""sample"", practice), 'w')        
 elif case == 1:
     infile = open(""%s-%s%s.in"" % (problem, ""small"", practice), 'r')
     outfile = open(""%s-%s%s.out"" % (problem, ""small"", practice), 'w')    
 elif case == 2:
     infile = open(""%s-%s%s.in"" % (problem, ""large"", practice), 'r')
     outfile = open(""%s-%s%s.out"" % (problem, ""large"", practice), 'w')   
 else:
     raise ValueError, 'Invalid case'
     
 alpha = 'abcdefghijklmnopqrstuvwxyz '
 trans = 'ynficwlbkuomxsevzpdrjgthaq '
 table = maketrans(trans, alpha)
     
 #Read in the number of cases (the first input line) we need to iterate through
 cases = int(infile.readline().strip('\n'))
 for i in range(cases):
 ##################NEW CODE GOES HERE###########################################    
     #Read in all relevant data for each case
     instr = infile.readline().strip('\n')
     
     #Do calculations to generate the output
     
     output = translate(instr, table)
     
     
 ##################NEW CODE GOES HERE###########################################    
     #Write out the results for this case
     outfile.write('Case #%i: %s\n' % (i+1, output))
     
 #Close files
 infile.close()
 outfile.close()",50,523,524
"#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013
 #for the Google Code Jam programming contest
 
 ###############################################################################
 # Imports go here
 ###############################################################################
 
 #For faster numerical analysis
 #Needed for the memoization decorator
 ###############################################################################
 # Global variables (for caching, etc.) go here
 ###############################################################################
 
 ###############################################################################
 # Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)
 ###############################################################################
 
 class memoize(object):
    """"""Decorator. Caches a function's return value each time it is called.
    If called later with the same arguments, the cached value is returned
    (not reevaluated).
    """"""
    def __init__(self, func):
       self.func = func
       self.cache = {}
    def __call__(self, *args):
       if not isinstance(args, collections.Hashable):
          # uncacheable. a list, for instance.
          # better to not cache than blow up.
          return self.func(*args)
       if args in self.cache:
          return self.cache[args]
       else:
          value = self.func(*args)
          self.cache[args] = value
          return value
    def __repr__(self):
       '''Return the function's docstring.'''
       return self.func.__doc__
    def __get__(self, obj, objtype):
       '''Support instance methods.'''
       return functools.partial(self.__call__, obj)
 
 ###############################################################################
 # Functions
 ###############################################################################
 
 def precalculate():
     """"""Perform any calculations that need to be performed before the main path
     (e.g., preparing lookup tables, etc.)
     
     N.B. Make sure you make any important variables global so that other
     functions can access them.
     """"""
     pass
 
 def read_input(infile):
     """"""This function should take an open input file, load in all of the
     relevant information for a single case of the problem, and output it
     as a single object.    
     """"""
     #Some utility functions to read in particular types of input
     def read_int():
         return int(infile.readline().strip())
     def read_ints():
         return np.array(infile.readline().split(), dtype=int)
     def read_bigints(): #For ints that won't fit directly in an int32 array
         line = infile.readline().split()
         return np.array(map(lambda x: int(x), line))
     def read_float():
         return float(infile.readline().strip())
     def read_floats():
         return np.array(infile.readline().split(), dtype=float)
     def read_string():
         return infile.readline().strip()
     def read_strings():
         return np.array(infile.readline().split(), dtype=object) #N.B. general dtype
     
     R, C, M = read_ints()
     
     return R, C, M
 
 def solve_case(case):
     """"""Take the input data (structured in case) and perform any necessary
     calculations to obtain the desired output, formatted as the appropriate
     string.    
     """"""
     R, C, M = case
     
     free = R * C - M
     assert free >= 1
     
     board = np.zeros((R, C), dtype=int) - 1
     
     def write_board(board):
         d = {0:'.', 1:'c', 2:'*'}
         s = ""\n""
         for row in board:
             for num in row:
                 try:
                     s += d[num]
                 except KeyError:
                     #s += ""X""
                     raise ValueError(""Board not filled in!"")
             s += ""\n""
         return s
     
     #Clicking in the corner is always optimal!
     board[0,0] = 1
     
     #Always possible with no mines!
     if M == 0:
         board[board == -1] = 0
         return write_board(board)
     
     #Always possible with one free square, if you click on the free square.
     if free == 1:
         #Fill all the empty squares in with mines
         board[board == -1] = 2
         return write_board(board)
         
     
     #Fill in the shortest sides while we have enough mines to do so:
     while min(R, C) <= M:
         if R < C:
             board[:,C-1] = 2
             C -= 1
             M -= R
         elif C <= R:
             board[R-1,:] = 2
             R -= 1
             M -= C
     
     def cascades(board, r, c):
         rows = [i for i in (r-1, r, r+1) if (i >= 0 and i < board.shape[0])]
         cols = [i for i in (c-1, c, c+1) if (i >= 0 and i < board.shape[1])]
         for r in rows:
             for c in cols:
                 if board[r,c] == 2: #Mine next to given position
                     return False
         return True
     
     #If we have no mines left, we win as long as the initial click cascades:
     if M == 0:
         board[board == -1] = 0
         if cascades(board, 0, 0):
             return write_board(board)
         else:
             return ""\nImpossible""
     
     #Now we have a rectangular free space with less than a full row or column
     #to fill.
     
     #If there's so many mines that we fill in all but one square on either
     #the row or column, it can't be done.
     if M > (R + C - 5):
         return ""\nImpossible""
         
     if M > 0 and (R <= 2 or C <= 2):
         return ""\nImpossible""
         
     #Otherwise, we fill in mines from the corner opposite to the click
     print M, R + C - 5
     fill_num = min(M, R - 2)
     print M, fill_num
     board[(R - fill_num):,C-1] = 2
     M -= fill_num
     
     fill_num = min(M, C - 3)
     print M, fill_num
     board[R-1,(C - fill_num - 1):] = 2
     M -= fill_num
     #assert M == 0
     
     board[board == -1] = 0
     return write_board(board)
 
 ###############################################################################
 # Main execution path
 ###############################################################################
 
 if __name__ == ""__main__"":
     #Do any pre-calculations required
     precalculate()
     
     #Open up the input & output files based on the provided input file
     assert len(sys.argv) == 2 #only one argument
     assert sys.argv[1][-3:] == "".in"" #input must end with .in
     infile = open(""%s"" % sys.argv[1], 'r')
     outfile = open(""%s.out"" % sys.argv[1][:-3], 'w')
     
     #Read in the number of cases (the first input line) to iterate through
     cases = int(infile.readline().strip('\n'))
     for i in range(cases):
         
         #Read in the input data for this case
         case = read_input(infile)
         
         #Solve the problem for this case
         output = solve_case(case)
         
         #Write out the output of this case
         outfile.write('Case #%i: %s\n' % (i+1, output))
         print 'Case #%i: %s\n' % (i+1, output)
     
     #Close files
     infile.close()
     outfile.close()",50,524,2014
"#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013
 #for the Google Code Jam programming contest
 
 ###############################################################################
 # Imports go here
 ###############################################################################
 
 #For faster numerical analysis
 #Needed for the memoization decorator
 ###############################################################################
 # Global variables (for caching, etc.) go here
 ###############################################################################
 
 ###############################################################################
 # Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)
 ###############################################################################
 
 class memoize(object):
    """"""Decorator. Caches a function's return value each time it is called.
    If called later with the same arguments, the cached value is returned
    (not reevaluated).
    """"""
    def __init__(self, func):
       self.func = func
       self.cache = {}
    def __call__(self, *args):
       if not isinstance(args, collections.Hashable):
          # uncacheable. a list, for instance.
          # better to not cache than blow up.
          return self.func(*args)
       if args in self.cache:
          return self.cache[args]
       else:
          value = self.func(*args)
          self.cache[args] = value
          return value
    def __repr__(self):
       '''Return the function's docstring.'''
       return self.func.__doc__
    def __get__(self, obj, objtype):
       '''Support instance methods.'''
       return functools.partial(self.__call__, obj)
 
 ###############################################################################
 # Functions
 ###############################################################################
 
 def precalculate():
     """"""Perform any calculations that need to be performed before the main path
     (e.g., preparing lookup tables, etc.)
     
     N.B. Make sure you make any important variables global so that other
     functions can access them.
     """"""
     pass
 
 def read_input(infile):
     """"""This function should take an open input file, load in all of the
     relevant information for a single case of the problem, and output it
     as a single object.    
     """"""
     #Some utility functions to read in particular types of input
     def read_int():
         return int(infile.readline().strip())
     def read_ints():
         return np.array(infile.readline().split(), dtype=int)
     def read_bigints(): #For ints that won't fit directly in an int32 array
         line = infile.readline().split()
         return np.array(map(lambda x: int(x), line))
     def read_float():
         return float(infile.readline().strip())
     def read_floats():
         return np.array(infile.readline().split(), dtype=float)
     def read_string():
         return infile.readline().strip()
     def read_strings():
         return np.array(infile.readline().split(), dtype=object) #N.B. general dtype
     
     C, F, X = read_floats()
     
     case = (C, F, X)
     
     return case
 
 def solve_case(case):
     """"""Take the input data (structured in case) and perform any necessary
     calculations to obtain the desired output, formatted as the appropriate
     string.    
     """"""
     C, F, X = case
     
     rate = 2.0
     cookies = 0.0
     time = 0.0
     
     #If it takes more cookies to buy a farm than we need to win, just wait and win:
     if C >= X:
         return X / rate
     
     while cookies < X:
         #If we don't have enough cookies to buy a farm, we have to wait until we do
         if cookies < C:
             wait_time = (C - cookies) / rate
             time += wait_time
             cookies = C
         #Now we do have enough cookies to buy a farm. Should we keep waiting or buy?
         time_if_wait = (X - C) / rate
         time_if_buy = X / (rate + F)
         if time_if_wait < time_if_buy:
             return time + time_if_wait
         else:
             rate += F
             cookies = 0.0
 
 ###############################################################################
 # Main execution path
 ###############################################################################
 
 if __name__ == ""__main__"":
     #Do any pre-calculations required
     precalculate()
     
     #Open up the input & output files based on the provided input file
     assert len(sys.argv) == 2 #only one argument
     assert sys.argv[1][-3:] == "".in"" #input must end with .in
     infile = open(""%s"" % sys.argv[1], 'r')
     outfile = open(""%s.out"" % sys.argv[1][:-3], 'w')
     
     #Read in the number of cases (the first input line) to iterate through
     cases = int(infile.readline().strip('\n'))
     for i in range(cases):
         
         #Read in the input data for this case
         case = read_input(infile)
         
         #Solve the problem for this case
         output = solve_case(case)
         
         #Write out the output of this case
         outfile.write('Case #%i: %s\n' % (i+1, output))
         print 'Case #%i: %s\n' % (i+1, output)
     
     #Close files
     infile.close()
     outfile.close()",50,525,1398
"= [[0, 1], [1, 0]]
 
 t = int(sys.stdin.readline())
 for i in range(t):
 	line = sys.stdin.readline().strip().split()
 	n = int(line[0])
 	m = int(line[1])
 	field = []
 	for j in range(n):
 		line = [int(x) for x in sys.stdin.readline().strip().split()]
 		field.append(line)
 
 	possibleLawn = True
 	for j in range(n):
 		for k in range(m):
 			for direct in range(2):
 				coords = [j if (direct == 0) else 0, 0 if (direct == 0) else k]
 				possibleField = True
 				while (coords[0] < n) and (coords[1] < m):
 					if field[j][k] < field[coords[0]][coords[1]]:
 						possibleField = False
 					coords[0] += direction[direct][0]
 					coords[1] += direction[direct][1]
 
 				if possibleField:
 					break
 			else:
 				possibleLawn = False
 
 	print ""Case #"" + str(i + 1) + "": "" + ('YES' if possibleLawn else 'NO')
 
",51,526,394
"= int(sys.stdin.readline())
 for i in range(n):
 	inputline = sys.stdin.readline().strip()
 	inputparams = inputline.split()
 
 	a = int(inputparams[0])
 	b = int(inputparams[1])
 
 	k = a
 	ndigits = 0
 	while k > 0:
 		k /= 10
 		ndigits += 1
 
 	cnt = 0
 
 	dic = {}
 
 	for n1digits in range(1, ndigits / 2 + 1):
 		n2digits = ndigits - n1digits
 
 		for n1 in range(a / (10 ** n2digits), b / (10 ** n2digits) + 1):
 			for n2 in range(a / (10 ** n1digits), b / (10 ** n1digits) + 1):
 
 				k1 = n1 * 10 ** n2digits + n2
 				k2 = n2 * 10 ** n1digits + n1
 
 				if (n1digits == n2digits) and (n1 >= n2):
 					continue
 
 				if (k1 != k2) and (k1 >=a) and (k2 >= a) and (k1 <= b) and (k2 <= b):
 
 					if min(k1, k2) not in dic:
 						dic[min(k1, k2)] = set()
 
 					if max(k1, k2) not in dic[min(k1, k2)]:
 						dic[min(k1, k2)].add(max(k1, k2))
 						cnt += 1
 
 	print ""Case #%d: %d"" % (i + 1, cnt)	
 
",51,527,526
"= int(sys.stdin.readline())
 for i in range(t):
 	board = []
 	for j in range(4):
 		board.append(sys.stdin.readline().strip())
 
 	sys.stdin.readline()
 
 	winX = False
 	winO = False
 	gameEnded = True
 
 	for j in range(4):
 		xCount = 0
 		oCount = 0
 		tCount = 0
 		for k in range(4):
 			if board[j][k] == 'X':
 				xCount += 1
 			if board[j][k] == 'O':
 				oCount += 1
 			if board[j][k] == 'T':
 				tCount += 1
 
 		if xCount + tCount == 4:
 			winX = True
 		
 		if oCount + tCount == 4:
 			winO = True
 
 		if xCount + oCount + tCount < 4:
 			gameEnded = False
 
 	for k in range(4):
 		xCount = 0
 		oCount = 0
 		tCount = 0
 		for j in range(4):
 			if board[j][k] == 'X':
 				xCount += 1
 			if board[j][k] == 'O':
 				oCount += 1
 			if board[j][k] == 'T':
 				tCount += 1
 
 		if xCount + tCount == 4:
 			winX = True
 		
 		if oCount + tCount == 4:
 			winO = True
 
 		if xCount + oCount + tCount < 4:
 			gameEnded = False
 
 	xCount = 0
 	oCount = 0
 	tCount = 0
 	for j in range(4):
 		if board[j][j] == 'X':
 			xCount += 1
 		if board[j][j] == 'O':
 			oCount += 1
 		if board[j][j] == 'T':
 			tCount += 1
 
 	if xCount + tCount == 4:
 		winX = True
 	
 	if oCount + tCount == 4:
 		winO = True
 
 	if xCount + oCount + tCount < 4:
 		gameEnded = False
 
 
 	xCount = 0
 	oCount = 0
 	tCount = 0
 	for j in range(4):
 		if board[3 - j][j] == 'X':
 			xCount += 1
 		if board[3 - j][j] == 'O':
 			oCount += 1
 		if board[3 - j][j] == 'T':
 			tCount += 1
 
 	if xCount + tCount == 4:
 		winX = True
 	
 	if oCount + tCount == 4:
 		winO = True
 
 	if xCount + oCount + tCount < 4:
 		gameEnded = False
 
 	print ""Case #"" + str(i + 1) + "": "",
 	if winX:
 		print ""X won""
 	elif winO:
 		print ""O won""
 	elif gameEnded:
 		print ""Draw""
 	else:
 		print ""Game has not completed""
",51,528,978
"= int(sys.stdin.readline())
 for i in range(t):
 	inputline = sys.stdin.readline().strip()
 	inputparams = inputline.split()
 
 	n = int(inputparams[0])
 	s = int(inputparams[1])
 	p = int(inputparams[2])
 	validcount = 0
 	surprisingcount = 0
 	for j in range(n):
 		score = int(inputparams[3 + j])
 		if (p + (p - 1) * 2) <= score:
 			validcount += 1
 		elif ((p + (p - 2) * 2) <= score) and (p <= score):
 			surprisingcount += 1
 
 	print ""Case #%d: %d"" % (i + 1, validcount + min(surprisingcount, s))
",51,529,232
"(b1, b2):
 	if 0 == len(b1):
 		return 0
 		
 	if b1[0] > b2[0]:
 		b1.pop(0)
 		b2.pop()
 		return 1 + play_war(b1, b2)
 	else:
 		b1.pop(0)
 		b2.pop(0)
 		return play_war(b1, b2)
 		
 def play_deceitful_war(b1, b2):
 	if 0 == len(b1):
 		return 0
 		
 	i = len(b1) - 1
 	while (i >= 0) and (b1[i] < b2[len(b2) - 1]):
 		i -= 1
 		
 	if i < 0:
 		return 0
 	
 	
 	b1.pop(i)
 	b2.pop()
 
 	return 1 + play_deceitful_war(b1, b2)
 
 
 t = int(sys.stdin.readline().strip())
 
 for i in range(t):
 	print ""Case #"" + str(i + 1) + "":"",
 
 	n = int(sys.stdin.readline().strip())
 	
 	blocks1 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)
 	blocks2 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)
 
 	print play_deceitful_war(list(blocks1), list(blocks2)), play_war(blocks1, blocks2)
 	
",51,530,467
"def is_palindrome(s):
 	if s == '':
 		return True
 	else:
 		if (ord(s[0]) - ord(s[len(s)-1])) == 0:
 			return is_palindrome(s[1 : len(s) - 1])
 		else:
 			return False
 
 all_fair_and_square = set()
 for i in range(10000):
 	orig = str(i)
 	rev = orig[::-1]
 
 	palin = orig + rev
 	intpalin = int(palin)
 	if is_palindrome(str(intpalin * intpalin)):
 		all_fair_and_square.add(intpalin * intpalin)
 
 	palin = orig[:-1] + rev
 	intpalin = int(palin)
 	if is_palindrome(str(intpalin * intpalin)):
 		all_fair_and_square.add(intpalin * intpalin)
 	
 
 = int(sys.stdin.readline().strip())
 for ii in range(t):
 	line = sys.stdin.readline().strip().split()
 	a = int(line[0])
 	b = int(line[1])
 	count = 0
 	for num in all_fair_and_square:
 		if (num >= a) and (num <= b):
 			count += 1
 	print ""Case #"" + str(ii + 1) + "": "" + str(count)
 
",51,531,414
"= ""abcdefghijklmnopqrstuvwxyz ""
 outputmapping = ""ynficwlbkuomxsevzpdrjgthaq ""
 
 n = int(sys.stdin.readline())
 for i in range(n):
 	outputstring = sys.stdin.readline().strip()
 	inputstring = """"
 	for j in range(len(outputstring)):
 		outputletter = outputstring[j]
 		k = 0
 		while outputmapping[k] != outputletter:
 			k += 1
 
 		inputstring += inputmapping[k]
 
 	print ""Case #%d: %s"" % (i + 1, inputstring)	
 
 		
",51,532,187
"(r, c, char):
 	mat = [[char for i in range(c)] for j in range(r)]
 	return mat
 	
 def merge(mat1, mat2):
 	for i in range(len(mat1)):
 		for j in range(len(mat1[i])):
 			mat2[i][j] = mat1[i][j]
 	return mat2
 
 def solve(r, c, m):
 	if 0 == m:
 		mat = generate_matrix(r, c, '.')
 		mat[0][0] = 'c'
 		return mat
 		
 	f = r * c - m
 	
 	if 0 == f:
 		return False
 		
 	if 1 == f:
 		mat = generate_matrix(r, c, '*')
 		mat[0][0] = 'c'
 		return mat
 		
 	if 1 == min(r, c):
 		mat = generate_matrix(r, c, '*')
 		for i in range(f):
 			mat[0 if 1 == r else i][0 if 1 == c else i] = '.'
 		mat[0][0] = 'c'
 		return mat
 
 	if 2 == min(r, c):
 		if (0 != f % 2) or (2 == f):
 			return False
 		mat = generate_matrix(r, c, '*')
 		for i in range(f // 2):
 			mat[0 if 2 == r else i][0 if 2 == c else i] = '.'
 			mat[1 if 2 == r else i][1 if 2 == c else i] = '.'
 		mat[0][0] = 'c'
 		return mat
 		
 	if (3 == r) and (3 == c):
 		if (4 == f) or (6 == f):
 			mat = generate_matrix(r, c, '*')
 			for i in range(f // 2):
 				mat[0][i] = '.'
 				mat[1][i] = '.'
 			mat[0][0] = 'c'
 			return mat
 		if 8 == f:
 			mat = generate_matrix(r, c, '.')
 			mat[2][2] = '*'
 			mat[0][0] = 'c'
 			return mat
 		return False
 		
 	rows_to_reduce = min(r - 3, m // c)
 	if 0 < rows_to_reduce:
 		res = solve(r - rows_to_reduce, c, m - rows_to_reduce * c)
 		if False == res:
 			return False
 		mat = merge(res, generate_matrix(r, c, '*'))
 		return mat
 		
 	cols_to_reduce = min(c - 3, m // r)
 	if 0 < cols_to_reduce:
 		res = solve(r, c - cols_to_reduce, m - cols_to_reduce * r)
 		if False == res:
 			return False
 		mat = merge(res, generate_matrix(r, c, '*'))
 		return mat
 	
 	mat = generate_matrix(r, c, '.')
 	for i in range(min(m, r - 2)):
 		mat[r - i - 1][c - 1] = '*'
 	if m == r - 1:
 		mat[r - 1][c - 2] = '*'
 	mat[0][0] = 'c'
 	return mat
 			
 
 t = int(sys.stdin.readline().strip())
 
 for i in range(t):
 	print ""Case #"" + str(i + 1) + "":""
 
 	r, c, m = [int(i) for i in sys.stdin.readline().strip().split()]
 	
 	res = solve(r, c, m)
 	
 	if False == res:
 		print ""Impossible""
 	else:
 		for i in range(r):
 			for j in range(c):
 				sys.stdout.write(res[i][j])
 			print
",51,533,1166
"(c, f, x, num_farms):
 	t = 0.0
 	rate = 2.0
 	for i in range(num_farms):
 		t += c / rate
 		rate += f
 		
 	t += x / rate
 	return t	
 
 t = int(sys.stdin.readline().strip())
 
 for i in range(t):
 	print ""Case #"" + str(i + 1) + "":"",
 
 	(c, f, x) = [float(i) for i in sys.stdin.readline().strip().split()]
 	
 	if x <= c:
 		t = calculate_time(c, f, x, 0)
 	else:
 		opt_rate = f * (x - c) / c
 		num_farms = (opt_rate - 2) / f
 		t1 = calculate_time(c, f, x, int(math.floor(num_farms)))
 		t2 = calculate_time(c, f, x, int(math.ceil(num_farms)))
 
 		t = min(t1, t2)
 		
 	print ""%.7f"" % t
",51,534,316
"== ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in range(t):
         X = int(f.readline())
         cardsX = [[int(y) for y in f.readline().split()] for x in range(4)]
         row = cardsX[X-1]
         Y = int(f.readline())
         cardsY = [[int(y) for y in f.readline().split()] for x in range(4)]
         column = cardsY[Y-1]
         card = [x for x in row if x in column]
         if len(card) > 1:
             answer = ""Bad magician!""
         elif len(card) == 0:
             answer = ""Volunteer cheated!""
         else:
             answer = str(card[0])
         print (""Case #"" + str(_t+1) + "": "" + answer)
     
 
",52,535,271
"(input, x, y, z):
     rotated = zip(*input[::-1])
     #for row in rotated:
         #print (row)
     #for row in input:
         #print (row)
     for i in range(x):
         for j in range(y):
             if not input[i][j] == ""1"":
                 continue            
             if sum((int(xx) for xx in input[i])) != y and \
                sum((int(xx) for xx in rotated[j])) != x:
                 return ""NO""
     return ""YES""
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in range(t):
         x, y = f.readline().split()
         s = [f.readline().split() for i in range(int(x))]
         print (""Case #"" + str(_t+1) + "": "" + decode_data(s, int(x), int(y), 2))
     
 
",52,536,296
"(number, base = 10):
   while number:
     yield number % base
     number //= base
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())    
     for _t in range(t):
         s = f.readline()
         s = s.split()
         A = int(s[0])
         B = int(s[1])
         score = 0
         #print (A, B, [x for x in range(A, B)][-1])
         for i in range(A, B):
             #print (A, B, [x for x in range(i+1, B+1)][-1])
             for j in range(i+1, B+1):
                 id = [d for d in digits(i)]
                 jd = [d for d in digits(j)]
                 if  sorted(id) == sorted(jd):
                     checklist = [jd[n:] + jd[:n] for n in range(len(id))]
                     if id in checklist:
                         score +=1
                     #print(checklist)
         print (""Case #"" + str(_t+1) + "": "" + str(score))
     
 
",52,537,347
"(input):
     output = """"
     Total = 0
     for row in input:
         T = row.count(""T"")
         X = row.count(""X"")
         O = row.count(""O"")
         #print (row, T, X, O, Total)
         if X + T == 4:
             return ""X won""
         elif O + T == 4:
             return ""O won""
         else:
             Total += T + X + O
             
     rotated = zip(*input[::-1])
     for row in rotated:
         T = row.count(""T"")
         X = row.count(""X"")
         O = row.count(""O"")
         if X + T == 4:
             return ""X won""
         elif O + T == 4:
             return ""O won""
 
     row = [input[x][x] for x in range(4)]
     row.count(""T"")
     X = row.count(""X"")
     O = row.count(""O"")
     if X + T == 4:
         return ""X won""
     elif O + T == 4:
         return ""O won""
 
     row = [input[3-x][x] for x in range(4)]
     T = row.count(""T"")
     X = row.count(""X"")
     O = row.count(""O"")
     if X + T == 4:
         return ""X won""
     elif O + T == 4:
         return ""O won""
 
     if Total < 16:
         return ""Game has not completed""
     else:
         return ""Draw""
     return output
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in range(t):
         s = [f.readline() for i in range(4)]
         print (""Case #"" + str(_t+1) + "": "" + decode_data(s))
         f.readline()
     
 
",52,538,537
"(input):
     output = """"
     for letter in input:
         if letter in library:
             output += library[letter]
     return output
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())    
     for _t in range(t):
         s = f.readline()
         s = s.split()
         N = int(s[0])
         S = int(s[1])
         p = int(s[2])
         low_scores = (p - 1) * 2
         ti = s[3:]
         ti.sort()
         r = 0
         ti = [int(x) for x in ti]
         for i in ti:
             score = i - low_scores
             if p <= i:
                 if score >= p:
                     r += 1
                     #print ([score, "" > "", p])
                 elif score >= p - 2 and S > 0:
                     S -= 1
                     r +=1
         print (""Case #"" + str(_t+1) + "": "" + str(r))
     
 
",52,539,320
"== ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in range(t):
         N = int(f.readline())
         Naomi = sorted([float(x) for x in f.readline().split()])
         Ken = sorted([float(x) for x in f.readline().split()])
         NMax = max(Naomi)
         DWScore = 0
         WScore = 0
         NaomiW = [x for x in Naomi]
         KenW = [x for x in Ken]
         for i in range(N):
             if(Naomi[-1] > Ken[-1]):
                 DWScore += 1
                 Naomi.pop()
                 Ken.pop()
             else:
                 Naomi.pop(0)
                 Ken.pop()
         for i in range(N):
             Na = NaomiW.pop(0)
             KWinners = [x for x in KenW if x > Na]
             if len(KWinners) > 0:
                 KenW.remove(KWinners[0])
             else:
                 KenW.pop(0)
                 WScore += 1
         print (""Case #"" + str(_t+1) + "": "" + str(DWScore) + "" "" + str(WScore))
     
 
",52,540,367
"(n):
     if n in square:
         return True
     if is_fair(n):
         root = int(math.sqrt(n))
         if root**2 != n:
             return False
         ss = is_fair(root)
         if ss: square.add(n)
         return ss
     return False
 
 def is_fair(n):
     if n in fair:
         return True
     if n in unfair:
         return False
     sn = str(n)
     l = len(sn)
     mid = math.ceil(n/2)
     if sn[0:mid] == sn[mid::-1]:
         fair.add(n)
         return True
     else:
         unfair.add(n)
         return False
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
             
     fair = set([1, 2, 3, 4, 5, 6, 7, 8, 9, 11])
     unfair = set([12, 13, 14, 15, 16, 17, 18, 19, 20, 21])
     square = set([1, 4])
 
     t = int(f.readline())
     for _t in range(t):
         s = f.readline()
         if s:
             x, y = s.split()
             Total = sum([is_square(n) for n in range(int(x), int(y)+1)])             
             print (""Case #"" + str(_t+1) + "": "" + str(Total))
     
 
",52,541,444
"= {'a': 'y', 'o': 'e', 'z': 'q', 'q' : 'z'}
 
 def parse_example(input, output):
     for key, value in zip(input, output):
         library[key] = value
 
 parse_example(""ejp mysljylc kd kxveddknmc re jsicpdrysi"", ""our language is impossible to understand"")
 parse_example(""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"", ""there are twenty six factorial possibilities"")
 parse_example(""de kr kd eoya kw aej tysr re ujdr lkgc jv"", ""so it is okay if you want to just give up"")
 
 def decode_data(input):
     output = """"
     for letter in input:
         if letter in library:
             output += library[letter]
     return output
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     d = {'O':0, 'B':1}
     for _t in range(t):
         s = f.readline()
         print (""Case #"" + str(_t+1) + "": "" + decode_data(s))
     
 
",52,542,350
"== ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in range(t):
 
         C, F, X = [float(x) for x in f.readline().split()]
 
         base = X / 2.0
 
         new_strategy = old_strategy = base
         time_building = 0
         farms = 0
         fastest_speed = 2
         while new_strategy <= old_strategy:
             old_strategy = new_strategy
             time_building += C / fastest_speed
             farms += 1
             fastest_speed += F
             new_strategy = time_building + X / fastest_speed
             
         
         print (""Case #"" + str(_t+1) + "": "" + str(old_strategy))
     
 
",52,543,254
"#!/usr/bin/python
 #solve case function
 def solve_case(answers, arrangements_of_cards, case_number):
     first_candidates = arrangements_of_cards[0][answers[0] - 1]
     second_candidates = arrangements_of_cards[1][answers[1] - 1]
     answer = set(first_candidates) & set(second_candidates)
     length_of_answer = len(answer)
     if length_of_answer > 1:
         print ""Case #%d: Bad magician!"" % case_number
     elif length_of_answer < 1:
         print ""Case #%d: Volunteer cheated!"" % case_number
     else:
         # There is only one element in the set!
         print ""Case #%d: %d"" % (case_number, answer.pop())
 
 #main
 r = sys.stdin
 
 if len(sys.argv) > 1:
     r = open(sys.argv[1], 'r')
 
 total_cases = r.readline()
 for case_number in range(1, int(total_cases) + 1):
     answers = []
     arrangements_of_cards = []
     answers.append(int(r.readline()))
     arrangements_of_cards.append([])
     for row in range(0, 4):
         arrangements_of_cards[0].append(map(int, r.readline().split(' ')))
     answers.append(int(r.readline()))
     arrangements_of_cards.append([])
     for row in range(0, 4):
         arrangements_of_cards[1].append(map(int, r.readline().split(' ')))
     solve_case(answers, arrangements_of_cards, case_number)
",53,544,450
"#!/usr/local/bin/python
 #solve case function
 def solve_case(nm, lawn, case_number):
     zipped_lawn = zip(*lawn)
     for n in range(0, nm[0]):
         max_lawn_n = max(lawn[n])
         for m in range(0, nm[1]):
             max_lawn_m = max(zipped_lawn[m])
             if lawn[n][m] < max_lawn_n and lawn[n][m] < max_lawn_m:
                 print ""Case #%d: NO"" % case_number
                 return
 
     print ""Case #%d: YES"" % case_number
 
 
 #main
 def main():
     r = sys.stdin
     if len(sys.argv) > 1:
         r = open(sys.argv[1], 'r')
 
     total_cases = r.readline()
     for case_number in range(1, int(total_cases) + 1):
         nm = map(int, r.readline().strip().split(' '))
         lawn = []
         for n in range(0, nm[0]):
             lawn.append(map(int, r.readline().strip().split(' ')))
         solve_case(nm, lawn, case_number)
 
 # invoke main
 if __name__ == ""__main__"":
     main()",53,545,355
"#!/usr/bin/python
 #solve case function
 def solve_case(min, max, case_number):
 	ans = 0
 
 	for candidate in range(min, max + 1):
 		candidate_str = str(candidate)
 		ignore = []
 		for rot in range(1, len(candidate_str)):
 			rot_candidate = int(candidate_str[rot:] + candidate_str[:rot])
 			if not rot_candidate in ignore:
 				if rot_candidate <= max and candidate < rot_candidate:
 					ans = ans + 1
 				ignore.append(rot_candidate)
 
 	print ""Case #%d: %d"" % (case_number, ans)
 
 #main
 r = sys.stdin
 
 if len(sys.argv) > 1:
 	r = open(sys.argv[1], 'r')
 
 total_cases = r.readline()
 for case_number in range(1, int(total_cases) + 1):
 	case = map(int, r.readline().rstrip().split(' '))
 	solve_case(case[0], case[1], case_number)
 
",53,546,328
"#!/usr/bin/python
 #output result
 def output(case_number, status):
     print ""Case #%d: %s"" % (case_number, status)
 
 #solve case function
 def solve_case(board, case_number):
     has_game_completed = True
 
     # check row
     for column in range(0, 4):
         x = 0
         o = 0
         for row in range(0, 4):
             if board[column][row] == 'X':
                 x += 1
             elif board[column][row] == 'O':
                 o += 1
             elif board[column][row] == 'T':
                 x += 1
                 o += 1
             else:
                 has_game_completed = False
 
         # check if X or O won already
         if x > 3:
             output(case_number, ""X won"")
             return
         if o > 3:
             output(case_number, ""O won"")
             return
 
     # check column
     for row in range(0, 4):
         x = 0
         o = 0
         for column in range(0, 4):
             if board[column][row] == 'X':
                 x += 1
             elif board[column][row] == 'O':
                 o += 1
             elif board[column][row] == 'T':
                 x += 1
                 o += 1
 
         # check if X or O won already
         if x > 3:
             output(case_number, ""X won"")
             return
         if o > 3:
             output(case_number, ""O won"")
             return
 
     # check diagonal 1
     x = 0
     o = 0
     for rc in range(0, 4):
         if board[rc][rc] == 'X':
             x += 1
         elif board[rc][rc] == 'O':
             o += 1
         elif board[rc][rc] == 'T':
             x += 1
             o += 1
 
     # check if X or O won already
     if x > 3:
         output(case_number, ""X won"")
         return
     if o > 3:
         output(case_number, ""O won"")
         return
 
     # check diagonal 2
     x = 0
     o = 0
     for rc in range(0, 4):
         if board[rc][3 - rc] == 'X':
             x += 1
         elif board[rc][3 - rc] == 'O':
             o += 1
         elif board[rc][3 - rc] == 'T':
             x += 1
             o += 1
 
     # check if X or O won already
     if x > 3:
         output(case_number, ""X won"")
         return
     if o > 3:
         output(case_number, ""O won"")
         return
 
     if has_game_completed:
         output(case_number, ""Draw"")
     else:
         output(case_number, ""Game has not completed"")
 
 #main
 def main():
     r = sys.stdin
     if len(sys.argv) > 1:
         r = open(sys.argv[1], 'r')
 
     total_cases = r.readline()
     for case_number in range(1, int(total_cases) + 1):
         board = []
         for row in range(0, 4):
             board.append(list(r.readline().strip()))
 
         #skip the last empty line
         r.readline()
         solve_case(board, case_number)
 
 # invoke main
 if __name__ == ""__main__"":
     main()",53,547,933
"#!/usr/bin/python
 = {0:1, 1:1, 2:2}
 mod_plus_conv_without_s = {0:0, 1:1, 2:1}
 
 #solve case function
 def solve_case(s, p, scores,case_number):
 	ans = 0
 	for score in scores:
 		if p <= (score / 3) + mod_plus_conv_without_s[score % 3]:
 			ans = ans + 1
 		elif s > 0 and (score / 3) > 0: 
 			if p <= (score / 3) + mod_plus_conv_with_s[score % 3]:
 				ans = ans + 1
 				s = s - 1
 	print ""Case #%d: %d"" % (case_number, ans)
 
 #main
 r = sys.stdin
 
 if len(sys.argv) > 1:
 	r = open(sys.argv[1], 'r')
 
 total_cases = r.readline()
 for case_number in range(1, int(total_cases) + 1):
 	case_line = map(int, r.readline().rstrip().split(' '))
 	solve_case(case_line[1], case_line[2], case_line[3:], case_number)
 
",53,548,355
"#!/usr/local/bin/python
 # check if num x is palindrome
 def is_palindrome(x):
     candidate = list(str(x))
     while len(candidate) > 1:
         if candidate.pop(0) != candidate.pop():
             return False
     return True
 
 
 #square
 def square(x):
     return x * x
 
 
 #solve case function
 def solve_case(ab, case_number):
     fs = 0
     root = int(math.sqrt(ab[0]))
     sq = square(root)
     if sq < ab[0]:
         root += 1
         sq = square(root)
 
     while sq <= ab[1]:
         if is_palindrome(root) and is_palindrome(sq):
             fs += 1
 
         #prepare for next
         root += 1
         sq = square(root)
 
     print ""Case #%d: %d"" % (case_number, fs)
 
 
 #main
 def main():
     r = sys.stdin
     if len(sys.argv) > 1:
         r = open(sys.argv[1], 'r')
 
     total_cases = r.readline()
     for case_number in range(1, int(total_cases) + 1):
         ab = map(int, r.readline().strip().split(' '))
         solve_case(ab, case_number)
 
 # invoke main
 if __name__ == ""__main__"":
     main()",53,549,379
"#!/usr/bin/python
 # make the googlerese dic
 gdic = {}
 sample_googlerese = ""yqeeejpmysljylckdkxveddknmcrejsicpdrysirbcpcypcrtcsradkhwyfrepkymveddknkmkrkcddekrkdeoyakwaejtysrreujdrlkgcjv""
 sample_plain_text = ""azooourlanguageisimpossibletounderstandtherearetwentysixfactorialpossibilitiessoitisokayifyouwanttojustgiveup""
 for gletter, pletter in zip(sample_googlerese, sample_plain_text):
 	if gletter in gdic:
 		if not gdic[gletter] == pletter:
 			print ""ERROR!! Can't analyze the sample text.""
 			sys.exit()
 	else:
 		gdic[gletter] = pletter
 
 if len(gdic) == 25:
 	candidate_gletter = set(string.ascii_lowercase) - set(sample_googlerese)
 	candidate_pletter = set(string.ascii_lowercase) - set(sample_plain_text)
 	if len(candidate_gletter) == 1 and len(candidate_pletter) == 1:
 		gdic[candidate_gletter.pop()] = candidate_pletter.pop()
 
 gdic[' '] = ' '
 
 # open the file
 r = sys.stdin
 
 if len(sys.argv) > 1:
 	r = open(sys.argv[1], 'r')
 
 # solve the cases 
 total_cases = r.readline()
 for case_number in range(1, int(total_cases) + 1):
 	googlerese_text = r.readline().rstrip()
 	plain_text = """"	
 	for gletter in googlerese_text:
 		plain_text = plain_text + gdic[gletter]
 
 	print ""Case #%d: %s"" % (case_number, plain_text)
",53,550,533
"# !/usr/bin/python
 (no_mine, r, c):
     printed_c = False
     for row in range(0, r):
         line = []
         for column in range(0, c):
             if printed_c:
                 if no_mine > 0:
                     line.append(""."")
                     no_mine -= 1
                 else:
                     line.append(""*"")
             else:
                 line.append(""c"")
                 no_mine -= 1
                 printed_c = True
         print """".join(line)
 
 
 def print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c):
     printed_c = False
     for row in range(0, r):
         line = []
         for column in range(0, c):
             if printed_c:
                 if row < no_mine_row and column < no_mine_column:
                     line.append(""."")
                 elif rest_no_mine_for_column > 0 and column == no_mine_column:
                     line.append(""."")
                     rest_no_mine_for_column -= 1
                 elif rest_no_mine_for_row > 0 and row == no_mine_row:
                     line.append(""."")
                     rest_no_mine_for_row -= 1
                 else:
                     line.append(""*"")
             else:
                 line.append(""c"")
                 printed_c = True
         print """".join(line)
 
 
 #solve case function
 def solve_case(r, c, m, case_number):
     print ""Case #%d:"" % case_number
     no_mine = r * c - m
     if r < 2 or c < 2 or no_mine == 1:
         print_basic_board(no_mine, r, c)
     else:
         no_mine_row_max = int(math.ceil(float(no_mine) / 2))
         if no_mine_row_max > r:
             no_mine_row_max = r
         for no_mine_column in range(2, int(math.ceil(float(no_mine) / 2)) + 1):
             if no_mine_column > c:
                 break
             for no_mine_row in range(2, no_mine_row_max + 1):
                 rest_no_mine = no_mine - (no_mine_column * no_mine_row)
                 if rest_no_mine < 0:
                     continue
                 if rest_no_mine == 1:
                     continue
 
                 if rest_no_mine == 0:
                     print_board(no_mine_row, no_mine_column, 0, 0, r, c)
                     return
                 if rest_no_mine <= no_mine_row and no_mine_column < c:
                     print_board(no_mine_row, no_mine_column, 0, rest_no_mine, r, c)
                     return
                 if rest_no_mine <= no_mine_column and no_mine_row < r:
                     print_board(no_mine_row, no_mine_column, rest_no_mine, 0, r, c)
                     return
 
                 if rest_no_mine > 3 and no_mine_column < c and no_mine_row < r:
                     for rest_no_mine_for_row in range(2, no_mine_column):
                         rest_no_mine_for_column = rest_no_mine - rest_no_mine_for_row
                         if rest_no_mine_for_column < no_mine_row:
                             print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c)
                             return
 
         print ""Impossible""
 
 #main
 r_file = sys.stdin
 
 if len(sys.argv) > 1:
     r_file = open(sys.argv[1], 'r')
 
 total_cases = r_file.readline()
 for case_number in range(1, int(total_cases) + 1):
     values = map(int, r_file.readline().split(' '))
     solve_case(values[0], values[1], values[2], case_number)
 
",53,551,1098
"#!/usr/bin/python
 #solve case function
 def solve_case(c, f, x, case_number):
     rate = 2.0
     time = 0.0
     rest = x
     while True:
         time_to_c = c / rate
         time_to_x = rest / rate
         if time_to_c < time_to_x:
             time_to_x_with_boost = time_to_c + (rest / (rate + f))
             if time_to_x_with_boost < time_to_x:
                 rate += f
                 time += time_to_c
             else:
                 break
         else:
             break
     time += rest / rate
     print ""Case #%d: %.7f"" % (case_number, time)
 
 #main
 r = sys.stdin
 
 if len(sys.argv) > 1:
     r = open(sys.argv[1], 'r')
 
 total_cases = r.readline()
 for case_number in range(1, int(total_cases) + 1):
     values = map(float, r.readline().split(' '))
     solve_case(values[0], values[1], values[2], case_number)
",53,552,305
"(sys.argv) == 1:
     sys.stdin = open(""A.in"")
 else:
     sys.stdin = open(sys.argv[1])
 
 def to_ints(s):
     return map(int, s.split())
 
 def get_ints():
     return to_ints(raw_input())
 
 n_cases = input()
 
 for case in xrange(1, n_cases + 1):
     a_row, = get_ints()
     a_layout = [get_ints() for _ in range(4)]
     b_row, = get_ints()
     b_layout = [get_ints() for _ in range(4)]
 
     poss = set(a_layout[a_row - 1])
     poss.intersection_update(b_layout[b_row - 1])
 
     result = 'Bad magician!'
 
     if len(poss) == 0:
         result = 'Volunteer cheated!'
     elif len(poss) == 1:
         result = poss.pop()
 
     print ""Case #%d: %s"" % (case, result)
",54,553,279
"#sys.stdin = open(""b_example.in"")
 
 n_cases = input()
 
 def to_ints(s):
     return map(int, s.split())
 
 for case in xrange(1, n_cases + 1):
     ydim, xdim = to_ints(raw_input())
     heights = [to_ints(raw_input()) for _ in xrange(ydim)]
 
     ymaxes = [max(row) for row in heights]
     xmaxes = [max(col) for col in zip(*heights)]
 
     #print ymaxes, xmaxes
 
     poss = True
 
     for y in range(ydim):
         for x in range(xdim):
             height = heights[y][x]
             if not (height == xmaxes[x] or height == ymaxes[y]):
                 poss = False
 
 
     print ""Case #%d: %s"" % (case, 'YES' if poss else 'NO')
",54,554,250
"n_cases = input()
 
 for case in xrange(1, n_cases + 1):
     a, b = map(int, raw_input().split())
 
     out = 0
     e = 10 ** (len(str(a)) - 1)
     for n in xrange(a, b):
         s = str(n)
         m = n
         while True:
             m = (m / 10) + (m % 10 * e)
             if n < m <= b:
                 out += 1
             if m == n:
                 break
 
     print ""Case #%d: %s"" % (case, out)
",54,555,164
"#sys.stdin = open(""a_example.in"")
 
 n_cases = input()
 
 def xwin(s):
     return all(c in 'XT' for c in s)
 
 def owin(s):
     return all(c in 'OT' for c in s)
 
 for case in xrange(1, n_cases + 1):
     board = [raw_input().strip() for _ in xrange(4)]
     raw_input()
 
     board_t = zip(*board)
 
     #print board, board_t
 
     x_win = False
     o_win = False
     full = not any('.' in line for line in board)
 
     diag_nw = [board[x][x] for x in range(4)]
     diag_ne = [board[x][3-x] for x in range(4)]
 
     #print diag_nw, diag_ne
 
     if xwin(diag_nw) or xwin(diag_ne):
         x_win = True
     if owin(diag_nw) or owin(diag_ne):
         o_win = True
 
     for line, line_t in zip(board, board_t):
         if xwin(line) or xwin(line_t):
             x_win = True
         if owin(line) or owin(line_t):
             o_win = True
 
     out = 'Game has not completed'
     if x_win:
         out = 'X won'
     elif o_win:
         out = 'O won'
     elif full:
         out = 'Draw'
 
     print ""Case #%d: %s"" % (case, out)
",54,556,425
"n_cases = input()
 
 for case in xrange(1, n_cases + 1):
     ins = map(int, raw_input().strip().split())
     n = ins[0]
     s = ins[1]
     p = ins[2]
     t = ins[3:]
 
     out = 0
     for x in t:
         if (x + 2) / 3 >= p:
             out += 1
         elif s and x > p and p - ((x - p) / 2) <= 2:
             out += 1
             s -= 1
             
     print ""Case #%d: %s"" % (case, out)
",54,557,165
"(sys.argv) == 1:
     sys.stdin = open(""D.in"")
 else:
     sys.stdin = open(sys.argv[1])
 
 def to_floats(s):
     return map(float, s.split())
 
 def get_floats():
     return to_floats(raw_input())
 
 n_cases = input()
 
 # Ken strategy: pick smallest block larger than
 #     claimed one, else use smallest block
 
 def cheat(our_blocks, opp_blocks):
     # Cheat strategy: eliminate opponents
     # largest blocks with our smallest, until all our
     # blocks are larger than corresponding
     n_blocks = len(our_blocks)
     burned = 0
     while any(our_blocks[x+burned] < opp_blocks[x] for x in xrange(0, n_blocks - burned)):
         burned += 1
     return n_blocks - burned
 
 def fair(our_blocks, opp_blocks):
     # Our strategy: use blocks smallest to largest
     score = 0
     opp_left, opp_right = 0, len(opp_blocks)-1
     for our in our_blocks:
         for n, opp in enumerate(opp_blocks):
             if opp > our:
                 opp_blocks.pop(n)
                 break
         else:
             score += 1
             opp_blocks.pop(0)
     return score
 
 for case in xrange(1, n_cases + 1):
     n_blocks, = get_floats()
     our_blocks = sorted(get_floats())
     opp_blocks = sorted(get_floats())
 
     deceitful_score = cheat(our_blocks, opp_blocks)
     fair_score = fair(our_blocks, opp_blocks)
 
     print ""Case #%d: %d %d"" % (case, deceitful_score, fair_score)
",54,558,499
"#sys.stdin = open(""c_example.in"")
 
 n_cases = input()
 
 def to_ints(s):
     return map(int, s.split())
 
 def is_palindrome(n):
     s = str(n)
     return s == s[::-1]
 
 for case in xrange(1, n_cases + 1):
     a, b = to_ints(raw_input())
 
     nums = range(int(b ** .5) + 2)
     palins = filter(is_palindrome, nums)
     squares = [x**2 for x in palins]
     palin_squares = filter(is_palindrome, squares)
     range_squares = [x for x in palin_squares if a <= x <= b]
 
     print ""Case #%d: %s"" % (case, len(range_squares))
",54,559,225
"mapping = {'y':'a', 'e':'o', 'q':'z', 'z':'q'}
 
 for src, dst in [(""ejp mysljylc kd kxveddknmc re jsicpdrysi"", ""our language is impossible to understand""),
     (""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"",""there are twenty six factorial possibilities""),
     (""de kr kd eoya kw aej tysr re ujdr lkgc jv"",""so it is okay if you want to just give up"")]:
     for a, b in zip(src,dst):
         mapping[a] = b
 
 n_cases = input()
 
 
 for case in xrange(1, n_cases + 1):
     string = raw_input()
 
     out = ''.join(mapping.get(c, c) for c in string)
             
     print ""Case #%d: %s"" % (case, out)
",54,560,238
"(sys.argv) == 1:
     sys.stdin = open(""B.in"")
 else:
     sys.stdin = open(sys.argv[1])
 
 def to_floats(s):
     return map(float, s.split())
 
 def get_floats():
     return to_floats(raw_input())
 
 n_cases = input()
 
 for case in xrange(1, n_cases + 1):
     farm_cost, farm_increase, goal = get_floats()
 
     best_time = float('inf')
     time = 0.0
     rate = 2.0
     while time < best_time:
         best_time = min(best_time, time + goal / rate)
         time += farm_cost / rate
         rate += farm_increase
 
     print ""Case #%d: %.7f"" % (case, best_time)
",54,561,230
"= Test {
       choix1 :: Int
     , table1 :: [[Int]]
     , choix2 :: Int
     , table2 :: [[Int]]
     } deriving Show
 
 data Solution = Bonne Int | BadMag | Cheat
 
 instance Show Solution where
     show (Bonne i) = show i
     show BadMag    = ""Bad magician!""
     show Cheat     = ""Volunteer cheated!""
 
 main = do
     interact (unlines . map showCase . zip [1..] . map (resoudre) . goTest . tail . lines)
 
   where
     goTest [] = []
     goTest ls =
         let (c1, t1, ls')  = goTable ls
             (c2, t2, ls'') = goTable ls'
         in Test c1 t1 c2 t2 : goTest ls''
 
     goTable (n:ls) =
         let c = read n
             (t, ls') = splitAt 4 ls
         in (c, map goLigne t, ls')
 
     goLigne = map read . words
 
     showCase :: (Int, Solution) -> String
     showCase (i, s) = printf ""Case #%d: %s"" i (show s)
 
 resoudre :: Test -> Solution
 resoudre Test {..} =
     let choisis1 = table1 !! (choix1 - 1)
         choisis2 = table2 !! (choix2 - 1)
         communs  = filter (`elem` choisis1) choisis2
     in case communs of
         [x]     -> Bonne x
         (_:_:_) -> BadMag
         []      -> Cheat
",55,562,410
"= do
     interact (unlines . map showCase . zip [1..] . go . tail . lines)
 
   where
     go :: [String] -> [Bool]
     go []     = []
     go (l:ls) =
         let [h, w] = map read $ splitOn "" "" l
             (ls', ls'') = splitAt h ls
             table = map (map read . splitOn "" "") ls'
         in solve h w table : go ls''
 
     showCase :: (Int, Bool) -> String
     showCase (i, r) = printf ""Case #%d: %s"" i (if r then ""YES"" else ""NO"")
 
 solve :: Int -> Int -> [[Int]] -> Bool
 solve h w table = and [ cell >= (maxLgn ! y) || cell >= (maxCol ! x)
     | y <- [0..h-1], x <- [0..w-1], let cell = arr ! (y, x)
     ]
   where
     arr :: Array (Int, Int) Int
     arr = listArray ((0, 0), (h-1, w-1)) $ concat table
 
     maxLgn, maxCol :: Array Int Int
     maxLgn = listArray (0, h-1) $ [ maximum [ arr ! (y, x) | x <- [0..w-1] ]
         | y <- [0..h-1]
         ]
 
     maxCol = listArray (0, w-1) $ [ maximum [ arr ! (y, x) | y <- [0..h-1] ]
         | x <- [0..w-1]
         ]",55,563,391
"= interact (unlines . map showCase . zip [1..] . tail . lines)
   where
     showCase (i, t) = ""Case #"" ++ show i ++ "": "" ++ solve t
 
 solve = show . solve'' . map read . words
 solve' [a, b] = length [ () | 
         x <- [a..b]
     , let digits = nDigits x, let lastY = min b (10^digits - 1)
     , y <- [x+1..lastY]
     , isRecycled x y digits
     ]
     
 solve'' [a, b] = sum [ nRecycled | 
       x <- [a..b]
     , let digits = nDigits x
     , let nRecycled = length [ () |
               y <- nub $ sort $ moves x digits
             , y <= b, y > x
             ]
     ]
 
 isRecycled :: Int -> Int -> Int -> Bool
 isRecycled n m digits = any (== n) (m : moves m digits)
 
 nDigits :: Int -> Int
 nDigits n = nDigits' n 0
   where
     nDigits' 0 acc = acc
     nDigits' x acc = nDigits' (x `div` 10) (acc+1)
 
 moves :: Int -> Int -> [Int]
 moves n digits = [ dep n d digits | d <- [1..digits-1] ]
 dep x d digits = x * 10^d `rem` (10^digits) + x `div` 10^(digits - d)",55,564,386
"t = int(input())
 
 def win(lines, player):
     for y in range(0, 4):
         count = 0
         for x in range(0, 4):
             if lines[y][x] in [player, 'T']:
                 count += 1
                 if count >= 4:
                     return True
             else:
                 break
 
     for x in range(0, 4):
         count = 0
         for y in range(0, 4):
             if lines[y][x] in [player, 'T']:
                 count += 1
                 if count >= 4:
                     return True
             else:
                 break
 
     count = 0
     for i in range(0, 4):
         if lines[i][i] in [player, 'T']:
             count += 1
             if count >= 4:
                 return True
 
     count = 0
     for i in range(0, 4):
         x = 3 - i
         if lines[i][x] in [player, 'T']:
             count += 1
             if count >= 4:
                 return True
 
     return False
 
 for i in range(0, t):
     lines = []
     for j in range(0, 4):
         lines.append(input())
     input()
 
     if win(lines, 'X'):
         sol = ""X won""
     elif win(lines, 'O'):
         sol = ""O won""
     else:
         void = False
         for y in range(0, 4):
             if any(c == '.' for c in lines[y]):
                 void = True
                 break
 
         if void:
             sol = ""Game has not completed""
         else:
             sol = ""Draw""
 
 
     print (""Case #""+str(i+1)+"": ""+sol)",55,565,462
"= interact (unlines . map showCase . zip [1..] . tail . lines)
   where
     showCase (i, t) = ""Case #"" ++ show i ++ "": "" ++ solve t
 
 solve = show . solve' . map read . words
   where
     solve' (n:s:p:ts) = 
         let pts = map maxPoints ts
             directs = filter ((>= p) . fst) pts
             surps = filter (\(pd, ps) -> pd < p && ps >= p) pts
         in length directs + min (length surps) s
         
 maxPoints :: Int -> (Int, Int)
 maxPoints tot = 
     (maxScore $ scores normal, maxScore $ scores surprising)
   where
     scores cond = [ (x, y, z) |
         x <- [0..10], y <- [0..10], z <- [0..10]
         , x + y + z == tot, cond (x, y, z)
         ]
     normal t = bestScore t - badScore t <= 1
     surprising t = bestScore t - badScore t <= 2
     maxScore = maximum . map bestScore 
 
 bestScore (x, y, z) = maximum [x, y, z]
 badScore (x, y, z) = minimum [x, y, z]",55,566,321
"= Test {
       joueur     :: [Double]
     , adversaire :: [Double]
     } deriving Show
 
 data Solution = Solution Int Int
 
 instance Show Solution where
     show (Solution a b) = show a ++ "" "" ++ show b
 
 main = do
     interact (unlines . map showCase . zip [1..] . map resoudre . goTest . tail . lines)
 
   where
     goTest [] = []
     goTest (_:js:as:ls) =
         Test (map read $ words js) (map read $ words as) : goTest ls
 
     showCase :: (Int, Solution) -> String
     showCase (i, s) = printf ""Case #%d: %s"" i (show s)
 
 resoudre :: Test -> Solution
 resoudre Test {..} =
     let jou    = S.fromList joueur
         adv    = S.fromList adversaire
         war    = goWar adv (sort joueur)
         deceit = goDeceit (reverse $ sort adversaire) jou
     in Solution deceit war
   where
     goWar _   []     = 0
     goWar adv (j:js) =
         case S.lookupGT j adv of
             Just e  -> goWar (S.delete e adv)               js     -- Perd ce jeu
             Nothing -> goWar (S.delete (S.findMin adv) adv) js + 1 -- Gagne ce jeu
 
     goDeceit []     _   = 0
     goDeceit (a:as) jou =
         -- PremiÃ¨re Ã©tape : tente d'Ã©liminer le plus gros chiffre restant de
         -- l'adversaire.
         case S.lookupGT a jou of
             Just e  ->
                 -- Elimine le plus gros pion de l'adversaire et gagne.
                 goDeceit as (S.delete e jou) + 1
             Nothing ->
                 -- DeuxiÃ¨me Ã©tape: incapable de l'Ã©liminer, sacrifie un
                 -- point en forcant l'adversaire Ã  jouer ce pion, en
                 -- utilisant le plus petit point et en mentant sur son
                 -- poids.
                 let minJou = S.findMin jou
                 in goDeceit as (S.delete minJou jou)
",55,567,577
"= do
     interact (unlines . map showCase . zip [1..] . map (solve . interval) . tail . lines)
 
   where
     interval :: String -> (Int64, Int64)
     interval l =
         let [a, b] = map read $ splitOn "" "" l
         in (a, b)
 
     showCase :: (Int64, Int) -> String
     showCase (i, r) = printf ""Case #%d: %d"" i r
 
 solve :: (Int64, Int64) -> Int
 solve (a, b) =
     length $ takeWhile (<= b) $ dropWhile (< a) [ sq
         | x <- [0..], palindrome x, let sq = x * x, palindrome sq
         ]
   where
     square x = x * x
     start = truncate $ sqrt $ double a
 
 -- | Returns True if s is a palindrome.
 palindrome s =
     let s' = show s
     in s' == reverse s'
 
 double :: Int64 -> Double
 double = fromIntegral",55,568,269
"= [(' ',' '),('a','y'),('b','h'),('c','e'),('d','s'),('e','o') 
     ,('f','c'),('g','v'),('h','x'),('i','d'),('j','u'),('k','i'),('l','g')
     ,('m','l'),('n','b'),('o','k'),('p','r'),('q','z'),('r','t'),('s','n')
     ,('t','w'),('u','j'),('v','p'),('w','f'),('x','m'),('y','a'),('z', 'q')
     ]
 
 main = interact (unlines . map showCase . zip [1..] . tail . lines)
   where
     showCase (i, t) = ""Case #"" ++ show i ++ "": "" ++ solve t
 
 solve = map (fromJust . flip lookup alphabet)",55,569,216
"t = int(input())
 
 VIDE = 0
 MINE = 1
 CURSEUR = 2
 
 def test_position(arr, lignes, cols, y, x):
     def voisinage_libre(arr, y, x):
         if y > 0:
             if x > 0 and arr[y-1][x-1] == MINE:
                 return False
             if arr[y-1][x] == MINE:
                 return False
             if x < cols - 1 and arr[y-1][x+1] == MINE:
                 return False
 
         if x > 0 and arr[y][x-1] == MINE:
             return False
         if x < cols - 1 and arr[y][x+1] == MINE:
             return False
 
         if y < lignes - 1:
             if x > 0 and arr[y+1][x-1] == MINE:
                 return False
             if arr[y+1][x] == MINE:
                 return False
             if x < cols - 1 and arr[y+1][x+1] == MINE:
                 return False
 
         return True
 
     def remplissage_rec(arr, y, x):
         if x < 0 or y < 0 or x >= cols or y >= lignes:
             return
         elif arr[y][x] == CURSEUR:
             return
 
         arr[y][x] = CURSEUR
         if voisinage_libre(arr, y, x):
             remplissage_rec(arr, y-1, x-1)
             remplissage_rec(arr, y-1, x)
             remplissage_rec(arr, y-1, x+1)
             remplissage_rec(arr, y, x-1)
             remplissage_rec(arr, y, x+1)
             remplissage_rec(arr, y+1, x-1)
             remplissage_rec(arr, y+1, x)
             remplissage_rec(arr, y+1, x+1)
 
     if arr[y][x] != VIDE:
         return False
 
     # Copie arr and arr2
     arr2 = [ [ arr[i][j] for j in range(0, cols) ] for i in range(0, lignes) ]
 
     remplissage_rec(arr2, y, x)
 
     for i in range(0, lignes):
         for j in range(0, cols):
             if arr2[i][j] == VIDE:
                 return False
     return True
 
 def dfs(arr, lignes, cols, mines, y, x):
     cases_restantes = (cols - x) + ((lignes - y) * cols)
 
     if cases_restantes < mines:
         return None
     elif mines <= 0:
         for i in range(0, lignes):
             for j in range(0, cols):
                 if test_position(arr, lignes, cols, i, j):
                     return (i, j)
     elif x >= cols:
         return dfs(arr, lignes, cols, mines, y+1, 0)
     elif y >= lignes:
         return None
     else:
         res = dfs(arr, lignes, cols, mines, y, x+1)
         if res != None:
             return res
 
         arr[y][x] = MINE
         res = dfs(arr, lignes, cols, mines-1, y, x+1)
         if res != None:
             return res
 
         arr[y][x] = VIDE
         return None
 
 for i in range(0, t):
     ligne  = input().split("" "")
     lignes = int(ligne[0])
     cols   = int(ligne[1])
     mines  = int(ligne[2])
 
     arr = [ [VIDE] * cols for _ in range(0, lignes) ]
 
     res = dfs(arr, lignes, cols, mines, 0, 0)
 
     print (""Case #""+str(i+1)+"":"")
 
     if res == None:
         print (""Impossible"")
     else:
         (y, x) = res
 
         for i in range(0, lignes):
             for j in range(0, cols):
                 if i == y and j == x:
                     print('c', end='')
                 elif arr[i][j] == VIDE:
                     print('.', end='')
                 else:
                     print('*', end='')
 
             print('', end='\n')
",55,570,1159
"T = int(raw_input());
 for q in range(T):
     R1 = int(raw_input());
     Data1 = [];
     for i in range(4):
         Data1.append( map(int, raw_input().split()) );
         
     R2 = int(raw_input());
     Data2 = [];
     for i in range(4):
         Data2.append( map(int, raw_input().split()) );
 
     Ans = [];
     for entry in Data1[R1-1]:
         if entry in Data2[R2-1]:
             Ans.append(entry);
 
     print ""Case #%d:"" % (q+1),;
 
     if len(Ans) == 0:
         print ""Volunteer cheated!"";
     if len(Ans) == 1:
         print Ans[0];
     if len(Ans) > 1:
         print ""Bad magician!""
         
",56,571,232
"T = int(raw_input());
 for q in range(T):
     [H,W] = map(int, raw_input().split());
     Lawn = [];
     MRow = [0]*H;
     MCol = [0]*W;
     for i in range(H):
         Lawn.append( map(int, raw_input().split()) );
         MRow[i] = max(Lawn[-1]);
         for j in range(W):
             MCol[j] = max(MCol[j], Lawn[-1][j]);
 
     Valid = True;
     for i in range(H):
         for j in range(W):
             if Lawn[i][j] not in [MRow[i], MCol[j]]:
                 Valid = False;
                 break;
     
 
     if Valid:
         print ""Case #%d: YES"" %(q+1);
     else:
         print ""Case #%d: NO"" %(q+1);        
",56,572,242
"T = int(raw_input());
 for case in range(T):
    [A,B] = map(int, raw_input().split());
 
    Big = 10**(len(str(A))-1);
    Ans = 0;
 
    for i in range(A,B+1):
       j = (i/10)+Big*(i%10);
       while (j != i):
          if i < j <= B:
             Ans += 1;
          j = (j/10)+Big*(j%10);
 
    print ""Case #%d:"" % (case+1),;
    print Ans;
    
 
",56,573,162
"def Winner( M ):
     for i in range(4):          # Check rows
         nX = 0;     nO = 0;     
         for j in range(4):
             if M[i][j] == 'X':
                 nX += 1;
             if M[i][j] == 'O':
                 nO += 1;
             if M[i][j] == 'T':
                 nX += 1;
                 nO += 1;
         if nX == 4:
             return 'X';
         if nO == 4:
             return 'O';
         
     for j in range(4):          # Check columns
         nX = 0;     nO = 0;     
         for i in range(4):
             if M[i][j] == 'X':
                 nX += 1;
             if M[i][j] == 'O':
                 nO += 1;
             if M[i][j] == 'T':
                 nX += 1;
                 nO += 1;
         if nX == 4:
             return 'X';
         if nO == 4:
             return 'O';
 
     if (M[0][0] in ['X','T']) and (M[1][1] in ['X','T']) and (M[2][2] in ['X','T']) and (M[3][3] in ['X','T']):
         return 'X';
     if (M[0][3] in ['X','T']) and (M[1][2] in ['X','T']) and (M[2][1] in ['X','T']) and (M[3][0] in ['X','T']):
         return 'X';
     if (M[0][0] in ['O','T']) and (M[1][1] in ['O','T']) and (M[2][2] in ['O','T']) and (M[3][3] in ['O','T']):
         return 'O';           
     if (M[0][3] in ['O','T']) and (M[1][2] in ['O','T']) and (M[2][1] in ['O','T']) and (M[3][0] in ['O','T']):
         return 'O';
 
     return 'D';            
 
 
 T = int(raw_input());
 for q in range(T):
     if q != 0:
         raw_input();
     Map = [];
     Dot = False;
     for i in range(4):
         Map.append( raw_input() );
         if '.' in Map[-1]:
             Dot = True;
 
     ANS = Winner(Map);
 #    print ANS
     if ANS == 'X':
         print ""Case #%d: X won"" %(q+1)
     if ANS == 'O':
         print ""Case #%d: O won"" %(q+1)
     if ANS == 'D':
         if Dot:
             print ""Case #%d: Game has not completed"" %(q+1)
         else:
             print ""Case #%d: Draw "" % (q+1)
 
",56,574,774
"T = int(raw_input());
 for i in range(T):
    Data = map(int, raw_input().split());
    N = Data.pop(0);
    S = Data.pop(0);
    p = Data.pop(0);
    
    Good = 0;
    for score in Data:
       if score >= 3*p-2:
          Good += 1;
       else:
          if (S > 0) and (score >= 3*p-4) and (score >= p):
             S -= 1;
             Good += 1;
 
    print ""Case #%d:"" % (i+1),;
    print Good;
    
 
",56,575,167
"def IsPal(n):
     S = str(n);
     return S == S[::-1];
 
 
 def Gen():
     LIM = 10**14;
     N = 10**7;
     LIST = [];
     for i in range(1, N):
         if IsPal(i):
             if IsPal(i*i):
                 LIST.append(i);
     return LIST
 
 PP = Gen();
 #print 'Generated'
 
 T = int(raw_input());
 for q in range(1,T+1):
     [A,B] = map(int, raw_input().split());    
     ANS = 0;
     for i in range(len(PP)):
         if B >= PP[i]**2 >= A:
             ANS += 1;
     
     print ""Case #%d: %d"" %(q, ANS);
",56,576,223
"RAW = ['ejp mysljylc kd kxveddknmc re jsicpdrysi',
        'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',
        'de kr kd eoya kw aej tysr re ujdr lkgc jv']
 ENG = ['our language is impossible to understand',
        'there are twenty six factorial possibilities',
        'so it is okay if you want to just give up'];
 
 New = [32]*128;
 Left = [];
 for c in range(97, 123):
    Left += [chr(c)];
 
 for i in range(3):
    for j in range(len(RAW[i])):
        x = ord(RAW[i][j]);
        if (New[x] == 32) and (x != 32):
           Left.remove(RAW[i][j]);
        New[x] = ord(ENG[i][j]);
 
 New[ord('q')] = ord('z');
 New[ord('z')] = ord('q');
 
 
 T = int(raw_input());
 for i in range(T):
    print ""Case #%d:"" % (i+1),;
    S_in = raw_input();
    S_out = '';
    for c in S_in:
       S_out += chr(New[ord(c)])
    print S_out
    
 
",56,577,362
"def Trivial(R,C,char):
 #    print
     for i in range(R):
         Ans = '';
         for j in range(C):
             if (i==j==0):
                 Ans += 'c';
             else:
                 Ans += char;
         print Ans;
 
 
 def Draw1(R,C,Blank):
 #    print
     Ans = ""c"";
     for i in range(Blank-1):
         Ans += '.';
     for i in range(R*C-Blank):
         Ans += '*';
     if (R == 1):
         print Ans;        
         return;
     if (C == 1):
         for i in range(len(Ans)):
             print Ans[i];
 
 def Draw2(R,C,Blank):
     if (Blank%2 != 0) or (Blank == 2):
         print ""Impossible"";
         return;
     Row1 = '.'*(Blank/2) + '*'*(Mine/2);
     Row0 = 'c' + Row1[1:];
     if R==2:
         print Row0;
         print Row1;
     else:
         for i in range(len(Row0)):
             print Row0[i]+Row1[i];
     return;
 
 
 def Generate(R, C, Blank):
     TODO = Blank;
     Spaces = [0]*R;
     if TODO <= 2*C:
         if TODO%2 == 0:
             Spaces[0] = TODO/2;
             Spaces[1] = TODO-Spaces[0];
         else:
             if (TODO == 7):
                 Spaces[0] = 3;
                 Spaces[1] = 2;
                 Spaces[2] = 2;
             else:
                 Spaces[0] = (TODO-3)/2;
                 Spaces[1] = (TODO-3)/2;
                 Spaces[2] = 3;
     else:
         row = 0;
         if (TODO >= 2*C+2):
             Spaces[0] = C;
             Spaces[1] = C;
             TODO -= 2*C;
             row = 2;
             
         while TODO > C+1:
             if (TODO == 2*C+1) and (C != 3):
                 Spaces[row] = C-1;
                 Spaces[row+1] = C-1;
                 Spaces[row+2] = 3;
                 TODO = 0;
             else:
                 Spaces[row] = C;
                 TODO -= C;
                 row += 1;
         if (TODO == C+1):
             Spaces[row] += C-1;
             Spaces[row+1] = 2;
             TODO = 0;
         Spaces[row] += TODO;
 
     for r in range(R):
         Ans = '.'*Spaces[r] + '*'*(C-Spaces[r]);
         if r == 0:
             Ans = 'c'+Ans[1:];
         print Ans;
 
 
 def Solve(R, C, M):
     Blank = R*C-M;
     if Blank == 0:
         print ""Impossible"";
         return;
 
     if (Blank == 1):
         Trivial(R,C,'*');
         return
     if (Blank == R*C):
         Trivial(R,C,'.');
         return
 
     if (R == 1) or (C == 1):
           Draw1(R,C,Blank);
           return
 
     if (R-2)*(C-2) == 0:
         Draw2(R,C,Blank);
         return
 
     if Blank in [2,3,5,7]:
         print ""Impossible"";
         return;
     
     if (R >= 3) and (C >= 3):
         Generate(R, C, Blank);
 
     return;
 
 
 T = int(raw_input());
 for q in range(T):
     [Row,Col,Mine] = map(int, raw_input().split());
 
     Blanks = Row*Col - Mine;
     
     print ""Case #%d:"" % (q+1)
 #    print str(Row)+'x'+str(Col)+' with '+str(Mine)+' mines ('+str(Blanks)+' gaps)'
     Solve(Row, Col, Mine);
     
         
",56,578,1124
"T = int(raw_input());
 for q in range(T):
     [C,F,X] = map(float, raw_input().split());
 
     # Default rate is 2 cookies / s;
     # Farm costs C
     #   produces F
     # Target is X;
 
     Time = 0.;
     Rate = 2.;
     Fin = False;
     while (not Fin):
         t0 = X/Rate;
         t1 = C/Rate + X/(Rate+F);
 
         if t0 <= t1:
             Time += t0;
             Fin = True;
         else:
             Time += C/Rate;
             Rate += F;
 
     print ""Case #%d:"" % (q+1),;
     print ""%.7f"" % Time;
     
         
",56,579,200
"= input()
 for case in range( 1, numCases + 1 ):
   row1 = input()
   grid1 = []
   for i in range( 0, 4 ):
     grid1.append( raw_input().split() )
 
   cards = grid1[ row1 - 1 ]
 
   row2 = input()
   grid2 = []
   for i in range( 0, 4 ):
     grid2.append( raw_input().split() )
 
   bad = True
       
   cards2 = grid2[ row2 - 1 ]
 
   numPossibleAnswers = 0
   for card in cards:
     for card2 in cards2:
       if ( card == card2 ):
         if numPossibleAnswers == 0:
           output = card
         numPossibleAnswers += 1
         break
 
   if numPossibleAnswers == 0:
     output = ""Volunteer cheated!""
   elif numPossibleAnswers > 1:
     output = ""Bad magician!""
 
   print 'Case #' + str( case ) + ': ' + str( output )
",57,580,285
"= input()
 for case in range( 1, numCases + 1 ):
 	sizeX, sizeY = raw_input().split()
 	sizeX = int(sizeX)
 	sizeY = int(sizeY)
 	board = {}
 	rowMax = {}
 	colMax = {}
 	
 	for row in range( 0, sizeX ):
 		row_raw = raw_input()
 		board[ row ] = {}
 		col = 0
 		for value in row_raw.split():
 			board[ row ][ col ] = int(value)
 			colMax[ col ] = max( colMax.get(col, 0 ), board[row][col] )
 			col += 1
 
 		rowMax[row] = max( board[row].values() )
 	
 	possible = True
 	result = 'YES'
 	for row in range( 0, sizeX ):
 		for col in range( 0, sizeY ):
 			if board[ row ][ col ] != colMax[ col ] and board[ row ][ col ] != rowMax[ row ]:
 				possible = False
 				break
 		if not possible:
 			result = 'NO'
 			break
 
 	print 'Case #' + str( case ) + ': ' + result 
",57,581,360
"( number_s, limit ):
   num_digits = len(number_s)
   num_s = number_s + number_s
   num = int(number_s)
   r_nums = []
   for i in range( 1, num_digits ):
     r_num_s = num_s[i:num_digits+i]
     r_num = int(r_num_s)
     if ( r_num > num and r_num <= limit ):
       r_nums.append( r_num )
 
   return len(set(r_nums))
 
 
 num_cases = input()
 for i in range( 1, num_cases + 1 ):
   start, limit = raw_input().split()
   num_recycled = 0
   #start_t = time.clock()
   for num in range( int(start), int(limit) + 1 ):
      num_recycled += get_num_recycled( str(num), int(limit) )
   #end_t = time.clock()
   #print start_t, end_t, end_t - start_t
   print 'Case #' + str(i) + ': ' + str( num_recycled )
",57,582,309
"( row ):
 	if row.count( 'X' ) + row.count( 'T' )  == size:
 		return 'X won'
 	if row.count( 'O' ) + row.count( 'T' )  == size:
 		return 'O won'
 	return 'Draw'
 	
 
 numCases = input()
 for case in range( 1, numCases + 1 ):
 	size = 4
 	board = {}
 	full = True
 	winner = 'Draw'
 	
 	for row in range( 0, size ):
 		row_raw = raw_input()
 		board[row] = row_raw
 		if '.' in row_raw:
 			full = False
 
 		if winner == 'Draw':
 			winner = get_winner( row_raw )
 	
 	raw_input()
 
 	if winner == 'Draw':
 		for col in range( 0, size ):
 			row_new = ''
 			for row in range( 0, size ):
 				row_new += board[row][col]
 			winner = get_winner( row_new )
 			if winner != 'Draw':
 				break
 
 	if winner == 'Draw':
 		row_new = ''
 		for z in range( 0, size ):
 			row_new += board[z][z]
 		winner = get_winner( row_new )
 		if winner == 'Draw':
 			row_new = ''
 			for z in range( 0, size ):
 				row_new += board[z][size - z - 1]
 			winner = get_winner( row_new )
 		
 
 	if winner == 'Draw' and not full:
 		winner = 'Game has not completed'
 
 	print 'Case #' + str( case ) + ': ' + winner
",57,583,533
"def build_table():
 	table = []
 	for i in range( 0, 31 ):
 		table.append( ( get_max_score( i ), get_max_surprise_score( i ) ) )
 
 	return table
 
 
 def get_max_score( i ):
 	return max( 0, min( 10, ( i + 2 ) / 3 ) )
 
 def get_max_surprise_score( i ):
 	return min( i, max( 0, min( 10, ( i + 4 ) / 3 ) ) )
 
 def get_max( x, scores, score_needed, num_surprises ):
 	scores = sorted( scores, reverse=True )
 	numPass = 0
 	i = 0;
 	while ( i < len(scores) ):
 		if ( x[scores[i]][0] >= score_needed ):
 			numPass += 1
 		else:
 			break
 		i += 1
 
 	while ( i < len(scores) and num_surprises > 0 ):
 		if ( x[scores[i]][1] >= score_needed ):
 			numPass += 1
 			num_surprises -= 1
 			
 		i += 1
 
 	return numPass
 
 x = build_table()
 
 num_cases = input()
 
 for i in range( 1, num_cases + 1 ):
 	line = raw_input().split()
 	num_surprises = int(line[1])
 	score_needed = int(line[2])
 	scores_raw = line[3:]
 
 	scores = [ int(y) for y in scores_raw ]
 
 	print 'Case #' + str( i ) + ': ' + str( get_max( x, scores, score_needed, num_surprises ) )
",57,584,517
"= input()
 for case in range( 1, numCases + 1 ):
   N = input()
   Naomis = list( [float(x) for x in raw_input().split() ] )
   Kens = list( [float(x) for x in raw_input().split() ] )
   Naomis = sorted( Naomis )
   Kens = sorted( Kens )
 
   # sim optimal
   NaomisOptimal = Naomis[:]
   KensOptimal = Kens[:]
 
   KenScore = 0
   for i in xrange( 0, N ):
     Naomi = NaomisOptimal.pop()
     x = bisect_left( KensOptimal, Naomi )
     if x < len( KensOptimal ):
       KenScore += 1
       del KensOptimal[ x ]
     else:
       del KensOptimal[ 0 ]
 
   NScore = 0
   for i in xrange( 0, N ):
     Naomi = Naomis[0]
     del Naomis[0]
     x = bisect_left( Kens, Naomi )
     if x == 0:
       Kens.pop()
     else:
       NScore += 1
       del Kens[ 0 ]
 
     output = str( NScore ) + ' ' + str( N - KenScore )
   
   print 'Case #' + str( case ) + ': ' + str( output )
",57,585,363
"( number ):
 	num_str = str( number )
 	num_len = len( num_str )
 	half_len = int( num_len / 2 )
 	end = num_str[-half_len:]
 	rev_end = end[::-1]
 	start = num_str[:half_len]
 	equal = rev_end == start 
 	return equal
 
 f = open( 'palindromes.out' )
 
 numbers = [ int(x) for x in f.read().split() ]
 
 numCases = input()
 for case in range( 1, numCases + 1 ):
 	min, max = [ int(x) for x in raw_input().split() ]
 	count = 0
 	for number in numbers:
 		if min <= number and max >= number:
 			count += 1
 
 	print 'Case #' + str( case ) + ': ' + str( count )
",57,586,245
"= { 'a' : 'y', 'b' : 'h', 'c' : 'e', 'd' : 's', 'e' : 'o', 'f' : 'c', 'g' : 'v', 'h' : 'x',
 'i' : 'd', 'j' : 'u', 'k' : 'i', 'l' : 'g', 'm' : 'l', 'n' : 'b', 'o' : 'k', 'p' : 'r', 'q' : 'z', 'r' : 't',
  's' : 'n', 't' : 'w', 'u' : 'j', 'v' : 'p', 'w' : 'f', 'x' : 'm', 'y' : 'a', 'z' : 'q', ' ' : ' ' }
 
 #words = 'ejp mysljylc kd kxveddknmc re jsicpdrysi rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd de kr kd eoya kw aej tysr re ujdr lkgc jv'
 
 numCases = input()
 for case in range( 1, numCases + 1 ):
 	words = raw_input()
 	output = ''
 	
 	for letter in words:
 		output = output + translation[letter]
 
 	print 'Case #' + str( case ) + ': ' + output
",57,587,353
"( R, C, M, Flip, gridMines, sideMines, bottomMines ):
   x = []
   numSpaces = 0
   numMines = 0
 
   gridRows = max( R-2, 0 )
   gridCols = max( C-2, 0 )
 
   for r in xrange( 0, R ):
     x.append( [] )
     for c in xrange( 0, C ):
       x[ r ].append( '.' )
       numSpaces += 1
 
   if gridMines > 0:
     for r in xrange( 0, gridRows ):
       if numMines >= gridMines:
         break;
       for c in xrange( 0, gridCols ):
         x[ r ][ c ] = '*'
         numMines += 1
         numSpaces -= 1
         if numMines >= gridMines:
           break;
 
   for r in xrange( 0, R ):
     if sideMines <= 0:
       break
     for c in xrange( gridCols, C ):
       x[ r ][ c ] = '*'
       numMines += 1
       numSpaces -= 1
       sideMines -= 1
       if sideMines <= 0:
         break
 
   for c in xrange( 0, C ):
     if bottomMines <= 0:
       break
     for r in xrange( gridRows, R ):
       x[ r ][ c ] = '*'
       numMines += 1
       numSpaces -= 1
       bottomMines -= 1
       if bottomMines <= 0:
         break
     
   x[ R - 1][ C - 1 ] = 'c'
   
   if numMines != M and ( R * C ) - M != 1:
     print ""ERROR!!!!!!!!!!!!!!!!!!!!!!!!""
     print ( R * C ) - M
 
 
   o = """"
 
   if Flip:
     for c in xrange( 0, C ):
       for r in xrange( 0, R ):
          o += x[ r ][ c ]
       o += '\n'
   else:
     for r in xrange( 0, R ):
       for c in xrange( 0, C ):
          o += x[ r ][ c ]
       o += '\n'
 
   return o[:-1] #strip the extra newline
 
 
 
 
 numCases = input()
 for case in xrange( 1, numCases + 1 ):
   R, C, M = [int(x) for x in raw_input().split()]
 
   Output = None
 
   Flip = C > R
   if Flip:
     temp = R
     R = C
     C = temp
 
   NonMines = ( R * C ) - M
   # Special cases first
   if ( NonMines == 0 ):
     Output = ""Impossible""
   elif ( C == 1 ):
     gridMines = 0
     extraMines = M - gridMines
     Output = DrawMines( R, C, M, Flip, gridMines, extraMines, 0 )
   elif ( NonMines == 2 or  NonMines == 3 ):
     Output = ""Impossible""
   else:
     maxGridCols = max( 0, C - 2 )
     maxGridRows = max( 0, R - 2 )
     gridMines = min( M, maxGridCols * maxGridRows )
     extraMines = M - gridMines
     extraPairs = ( extraMines + 1 ) / 2
     extraPairsSide = max( min( extraPairs, maxGridRows - 1 ), 0 )
     extraPairsBottom = max( min( extraPairs - extraPairsSide, maxGridCols - 1 ), 0 )
     safeExtraPairs = extraPairsSide + extraPairsBottom
     blockingPairsSide = max( min( extraPairs - safeExtraPairs, 1 ), 0 )
     blockingPairsBottom = max( min( extraPairs - blockingPairsSide - safeExtraPairs, 1 ), 0 )
     blockingPairs = blockingPairsSide + blockingPairsBottom
     totalPairs = safeExtraPairs + blockingPairs
 
     
     if ( gridMines > 0 and extraMines % 2 != 0 and blockingPairs == 0 ):
       extraMines += 1
       gridMines -= 1
 
     if ( NonMines == 1 ):
       if extraMines % 2 != 0:
         extraMines += 1
       blockingPairsSide += 1
       blockingPairsBottom += 1
     
     if extraMines % 2 == 0:
       sideMines = 2 * ( extraPairsSide + blockingPairsSide )
       bottomMines = 2 * ( extraPairsBottom + blockingPairsBottom )
       Output = DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines )
     else:
       Output = ""Impossible""
 
   output = ""\n"" + Output
   print 'Case #' + str( case ) + ': ' + str( output )
",57,588,1312
"INPUT = 'A-small-attempt0.in'
 OUTPUT = 'A-small-attempt0.out'
 
 
 def solve(answer1, arr1, answer2, arr2):
     ret = None
 
     for card in arr1[answer1 - 1]:
         if card in arr2[answer2 - 1]:
             if ret is not None:
                 return 'Bad magician!'
             else:
                 ret = card
     if ret is None:
         return 'Volunteer cheated!'
     return ret
 
 if __name__ == '__main__':
     inp = open(INPUT)
     out = open(OUTPUT, 'w')
     
     T = int(inp.readline())
 
     def read_answer_and_arr():
         answer = int(inp.readline())
         arr = []
         for i in range(4):
             arr.append( map(int, inp.readline().split()) )
         return answer, arr
 
     for case in range(T):
         answer1, arr1 = read_answer_and_arr()
         answer2, arr2 = read_answer_and_arr()
 
         out.write('Case #%i: %s\n' % \
                         (case + 1, solve(answer1, arr1, answer2, arr2)))
",58,589,330
"fin = open('B-small-attempt0.in', 'r')
 fout = open('ass2.out', 'w')
 
 
 T = int(fin.readline())
 
 def check(lawn, r, c):
     h, v = True, True
     for i in range(len(lawn[0])):
         if i == c:
             continue
         if lawn[r][i] > lawn[r][c]:
             h = False
             break
     for i in range(len(lawn)):
         if i == r:
             continue
         if lawn[i][c] > lawn[r][c]:
             v = False
     return (h or v)
 
 for i in range(T):
     N, M = map(int, fin.readline().split())
     lawn = []
     for j in range(N):
         lawn.append( map(int, fin.readline().split()) )
 
     n = i + 1
     ret = True
     for j in range(len(lawn)):
         if not ret: break
         for k in range(len(lawn[0])):
             if not check(lawn, j, k):
                 ret = False
                 fout.write('Case #%i: NO\n' % n)
                 break
     if ret:
         fout.write('Case #%i: YES\n' % n)",58,590,345
"input_file = 'C-small-attempt4.in'
 #input_file = 'c_sample.in'
 output_file = 'c.out'
 
 
 def solvecase(inp):
 	A, B = [int(n) for n in inp.split()]
 	
 	def shift(s):
 		return s[-1] + s[:-1]
 	
 	ret = 0
 	for n in range(A, B + 1):
 		sn = str(n)
 		sm = sn
 		rep = []
 		for i in range(len(sn) - 1):
 			sm = shift(sm)
 			if not (sm in rep) and (B >= int(sm) > n):
 				ret += 1
 				rep.append(sm)
 	return ret
 
 
 lines = open(input_file, 'r').readlines()
 out = open(output_file, 'w')
 
 for i, l in enumerate(lines[1:]):
 	sout = 'Case #%i: %i' % (i + 1, solvecase(l))
 	print sout
 	out.write(sout + '\n')
 
 out.close()
",58,591,325
"fin = open('A-small-attempt0.in', 'r')
 fout = open('ass1.out', 'w')
 
 N = int(fin.readline())
 
 for i in range(N):
     field = []
     for j in range(4):
         field.append(fin.readline())
     fin.readline()
 
     for j in range(4):
         field.append([field[ln][j] for ln in range(4)])
     field.append([field[x][x] for x in range(4)])
     field.append([field[x][3 - x] for x in range(4)])
 
     
     hasdot = False
     winner = None
     for ln in field:
         if '.' in ln:
             hasdot = True
             continue
         if 'X' in ln and not ('O' in ln):
             winner = 'X'
             break
         if 'O' in ln and not ('X' in ln):
             winner = 'O'
             break
     n = i + 1
     if not (winner or hasdot):
         fout.write('Case #%i: Draw\n' % n)
     elif not winner and hasdot:
         fout.write('Case #%i: Game has not completed\n' % n)
     else:
         fout.write('Case #%i: %s won\n' % (n, winner))",58,592,353
"input_file = 'B-small-attempt1.in'
 output_file = 'b.out'
 
 
 def solvecase(inp):
 	data = [int(n) for n in inp.split()]
 	N, S, p = data[0:3]
 	if p == 0:
 		return N
 	t = data[3:]
 	ret = 0
 	for br in t:
 		d, r = br / 3, br % 3
 		if br == 0 or p - d > 2:
 			continue
 		if (d >= p) or (r and (d + 1) >= p):
 			ret += 1
 		elif S and (d + max(r, 1)) >= p:
 			ret += 1
 			S -= 1
 	return ret
 
 lines = open(input_file, 'r').readlines()
 out = open(output_file, 'w')
 
 for i, l in enumerate(lines[1:]):
 	sout = 'Case #%i: %i' % (i + 1, solvecase(l))
 	print sout
 	out.write(sout + '\n')
 
 out.close()
",58,593,324
"INPUT = 'D-small-attempt3.in'
 OUTPUT = 'D-small-attempt3.out'
 
 
 def solve(N, naomis, kens):
     naomis.sort()
     kens.sort()
 
     def play_war(naomis, kens):
         score = 0
         for game_round in range(N):
             nweight = naomis.pop(0)
             if nweight > kens[-1]:
                 kweight = kens.pop(0)
             else:
                 for i, weight in enumerate(kens):
                     if weight > nweight:
                         kweight = kens.pop(i)
                         break
             if nweight > kweight:
                 score += 1
         return score
 
     def play_deceitful_war(naomis, kens):
         score = 0
         crap = 0
         for i, weight in enumerate(naomis):
             if weight < kens[i]:
                 crap += 1
 
         for game_round in range(N):
             if crap:
                 ntold = kens[-1] - 0.0000001
                 crap -= 1
             else:
                 ntold = naomis[-1]
             nweight = naomis.pop(0)
 
             if ntold > kens[-1]:
                 kweight = kens.pop(0)
             else:
                 for i, weight in enumerate(kens):
                     if weight > ntold:
                         kweight = kens.pop(i)
                         break
             if nweight > kweight:
                 score += 1
         return score 
 
     return play_deceitful_war(naomis[:], kens[:]), play_war(naomis[:], kens[:])
 
 
 if __name__ == '__main__':
     inp = open(INPUT)
     out = open(OUTPUT, 'w')
     
     T = int(inp.readline())
 
     for case in range(T):
         N = int(inp.readline())
         naomis = map(float, inp.readline().split())
         kens = map(float, inp.readline().split())
         sol = solve(N, naomis, kens)
         out.write('Case #%i: %i %i\n' % (case + 1, sol[0], sol[1]))",58,594,612
"= open('C-small-attempt0.in', 'r')
 fout = open('ass3.out', 'w')
 
 T = int(fin.readline())
 
 def perfsq(n):
     sq = int(math.sqrt(n))
     if n == sq * sq:
         return sq
     return 0
 
 def palindrome(n):
     s = str(n)
     return (s == s[::-1])
 
 def getpal(n):
     if n == 1:
         for i in range(10):
             yield i
     else:
         n2 = n / 2
         for x in xrange(10 ** (n2 - 1), 10 ** n2):
             s = str(x)
             if n % 2:
                 for i in range(10):
                     ns = s + str(i) + s[::-1]
                     yield int(ns)
             else:
                 ns = s + s[::-1]
                 yield int(ns)
 
 for i in range(T):
     A, B = map(int, fin.readline().split())
 
     ret = 0
     for j in range(len(str(A)), len(str(B)) + 1):
         for x in getpal(j):
             if x < A:
                 continue
             if x > B:
                 break
             sq = perfsq(x)
             if sq and palindrome(sq):
                 ret += 1
     fout.write('Case #%i: %i\n' % (i + 1, ret))
",58,595,396
"input_file = 'A-small-attempt0.in'
 output_file = 'a_out'
 
 googlerese = ''.join([
 	'ejp mysljylc kd kxveddknmc re jsicpdrysi',
 	'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',
 	'de kr kd eoya kw aej tysr re ujdr lkgc jv',
 	'y qee', 'z'
 ])
 
 english = ''.join([
 	'our language is impossible to understand',
 	'there are twenty six factorial possibilities',
 	'so it is okay if you want to just give up',
 	'a zoo', 'q'
 ])
 
 alphabet = {}
 
 for g, e in zip(googlerese, english):
 	alphabet[g] = e
 
 lines = open(input_file, 'r').readlines()
 out = open(output_file, 'w')
 
 for i, l in enumerate(lines[1:]):
 	trans = 'Case #%i: %s' % (
 		i + 1, 
 		''.join([alphabet[c] for c in l if c in alphabet]))
 	print trans
 	out.write(trans + '\n')
 
 out.close()
 
 	
 	
 
",58,596,354
"INPUT = 'B-small-attempt1.in'
 OUTPUT = 'B-small-attempt1.out'
 
 
 def solve(C, F, X):
 
     cps = 2.0
     farm_time = 0.0
     time = X / cps
     
     while True:
         farm_time += C / cps
         cps += F
         ntime = farm_time + X / cps
         if ntime < time:
             time = ntime
         else:
             break
     return time
 
 
 if __name__ == '__main__':
     inp = open(INPUT)
     out = open(OUTPUT, 'w')
     
     T = int(inp.readline())
 
     for case in range(T):
         sol = solve(*map(float, inp.readline().split()))
         out.write('Case #%i: %.7f\n' % (case + 1, sol))",58,597,239
"def get_number_of_test_case():
     return int(raw_input().strip())
 
 def solve_case(t):
     N, M = [int(x) for x in raw_input().strip().split()]
     
     matrix = [[int(x) for x in raw_input().strip().split()] for y in range(N)]
 
     s_list = list()
     for i in range(N):
         for j in range(M):
             s_list.append([matrix[i][j], i, j,])
     s_list.sort(cmp = lambda x, y: x[0] - y[0])
 
     outcome = 'YES'
     for s in s_list:
         if matrix[s[1]][s[2]] == 0:
             continue
 
         row, col = s[1], s[2]
 
         can_do = True
         for i in range(N):
             can_do &= matrix[i][col] <= s[0]
         if can_do:
             for i in range(N):
                 matrix[i][col] = 0
             continue
 
         can_do = True
         for j in range(M):
             can_do &= matrix[row][j] <= s[0]
         if can_do:
             for j in range(M):
                 matrix[row][j] = 0
         else:
             outcome = 'NO'
             break
     
     print 'Case #%d: %s' % (t, outcome,)
 
 
 T = get_number_of_test_case()
 t = 1
 while t <= T:
     solve_case(t)
     t += 1
 
",59,598,418
"def count_between(a, b):
 	count = 0
 	for item in range(a, b + 1):
 		rotate = len(str(item)) - 1
 		watch_list = [item,]
 		rotate_count = 0
 		item_len = len(str(item))
 		while rotate_count < rotate:
 			r_item = str(item)
 			r_item = r_item[rotate_count + 1:] + r_item[:rotate_count + 1]
 			r_item_len = len(r_item)
 			r_item = int(r_item)
 			if r_item not in watch_list and r_item > item and r_item <= b and r_item >= a and item_len == r_item_len:
 				watch_list.append(r_item)
 				count +=1
 			rotate_count += 1
 	return count
 
 pre_computed = [0, 36, 801, 12060, 161982, 2023578, 299997,]
 
 t = int(raw_input().strip())
 t_count = 1
 while t_count <= t:
 	a, b = [int(x) for x in raw_input().strip().split()]
 	#len_a = len(str(a))
 	#len_b = len(str(b))
 	#result = reduce(lambda x, y: x + y, pre_computed[len_a - 1:len_b -1], 0)
 	#print result
 	#result -= count_between(pow(10, len_a - 1), a)
 	#print result
 	#result += count_between(pow(10, len_b - 1), b)
 	#print result
 	#print 'Case #%d: %d' % (t_count, result,)
 	print 'Case #%d: %d' % (t_count, count_between(a, b),)
 	t_count += 1
 
",59,599,552
"def get_number_of_test_case():
     return int(raw_input().strip())
 
 def solve_case(t):
     lines = [list(raw_input().strip()) for i in range(4)]
     raw_input()
 
     i = 0
     j = 0
 
     p_list = list()
     while i < 4:
         j = 0
         s = ''
         while j < 4:
             s += lines[i][j]
             j += 1
         p_list.append(s.replace('T', 'X'))
         p_list.append(s.replace('T', 'O'))
         i += 1
 
     j = 0
     while j < 4:
         i = 0
         s = ''
         while i < 4:
             s += lines[i][j]
             i += 1
         p_list.append(s.replace('T', 'X'))
         p_list.append(s.replace('T', 'O'))
         j += 1
     
     s = lines[0][0] + lines[1][1] + lines[2][2] + lines[3][3]
     p_list.append(s.replace('T', 'X'))
     p_list.append(s.replace('T', 'O'))
 
     s = lines[0][3] + lines[1][2] + lines[2][1] + lines[3][0]
     p_list.append(s.replace('T', 'X'))
     p_list.append(s.replace('T', 'O'))
 
     has_empty = False
     outcome = ''
     for p in p_list:
         has_empty |= '.' in p
         if p == 'XXXX':
             outcome = 'X won'
             break
         elif p == 'OOOO':
             outcome = 'O won'
             break
     if not outcome:
         if has_empty:
             outcome = 'Game has not completed'
         else:
             outcome = 'Draw'
     
     print 'Case #%d: %s' % (t, outcome,)
 
 T = get_number_of_test_case()
 t = 1
 while t <= T:
     solve_case(t)
     t += 1
 
",59,600,563
"t = int(raw_input().strip())
 t_count = 1
 while t_count <= t:
 	line = raw_input().strip().split()
 	n = int(line[0])
 	s = int(line[1])
 	p = int(line[2])
 	ti_list = line[3:]
 	p_min = max(p * 3 - 2, p)
 	p_min_surprise = max(p * 3 - 4, p)
 	result = 0
 	for ti in ti_list:
 		ti = int(ti)
 		if ti >= p_min:
 			result += 1
 		elif p_min > p_min_surprise and ti >= p_min_surprise and s > 0:
 			result += 1
 			s -= 1
 	print 'Case #%d: %d' % (t_count, result,)
 	t_count += 1
",59,601,250
"def solve_case(t):
     n = int(raw_input().strip())
     naomi = sorted([float(num) for num in raw_input().strip().split()])
     ken = sorted([float(num) for num in raw_input().strip().split()])
 
     #print naomi
     #print ken
 
     i, j = 0, 0
     while j < n:
         if ken[j] > naomi[i]:
             i += 1
         j += 1
     optimal_result = n - i
 
     deceit_result = 0
     while n > 0:
         if naomi[0] < ken[0]:
             ken.pop()
         else:
             deceit_result += 1
             ken = ken[1:]
         naomi = naomi[1:]
         n -= 1
     
     #deceit_result = 0
     #while n > 0 and naomi[-1] > ken[-1]:
     #    deceit_result += 1
     #    naomi.pop()
     #    ken.pop()
     #    n -= 1
 
     #k, l = 0, n - 1
     #while k < n and l >= 0 and naomi[k] < ken[l]:
     #    l -= 1
     #    k += 1
 
     #deceit_result += n - k
 
     print 'Case #%d: %d %d' % (t, deceit_result, optimal_result,)
 
 def main():
     t = int(raw_input().strip())
     for i in range(1, t + 1):
         solve_case(i)
 
 if __name__ == '__main__':
     main()
",59,602,441
"():
     return int(raw_input().strip())
 
 def solve_case(t):
     A, B = [int(x) for x in raw_input().strip().split()]
 
     print 'Case #%d: %d' % (t, get_number_of_palindrome(B) - get_number_of_palindrome(A - 1),)
 
 def get_number_of_palindrome(n):
     ret = 0
 
     nt = int(math.floor(math.sqrt(n)))
     total_column = int(math.ceil(math.ceil(math.log10(nt + 1)) / 2.0))
     upper_limit = 10 ** total_column
 
     counter = 0
     while counter < upper_limit:
         c_str = [c for c in str(counter)]
         c_str.reverse()
 
         number = str(counter)
         for c in c_str:
             number += c
         number = int(number)
         number = number ** 2
         if number <= n and is_palindrome(number):
             ret += 1
 
         number = str(counter)
         for c in c_str[1:]:
             number += c
         number = int(number)
         number = number ** 2
         if number <= n and is_palindrome(number):
             ret += 1
         
         counter += 1
 
     return ret
 
 def is_palindrome(n):
     if n == 0:
         return False
     num = str(n)
     check_len = len(num) / 2
     ret = True
     for i in range(check_len):
         ret &= num[i] == num[-i - 1]
     return ret
 
 T = get_number_of_test_case()
 t = 1
 while t <= T:
     solve_case(t)
     t += 1
 
",59,603,483
"""""""
 num = int(raw_input('num: ').strip())
 
 c_map = [None for x in range(0, 26)]
 
 while num > 0:
 	googleres = raw_input('googleres: ').strip()
 	original = raw_input('original: ').strip()
 
 
 	ord_a = ord('a')
 	ord_z = ord('z')
 
 	i = 0
 	for c in googleres:
 		ord_c = ord(c)
 		if ord_a <= ord_c and ord_c <= ord_z:
 			c_map[ord_c - ord_a] = ord(original[i]) - ord_c
 		i += 1
 	
 	num -= 1
 
 print c_map
 """"""
 
 """"""
 c_map = [24, 6, 2, 15, 10, -3, 15, 16, -5, 11, -2, -5, -1, -12, -4, 2, 9, 2, -5, 3, -11, -6, -17, -11, -24, -9]
 i = 0
 original_list = list()
 while i < 25:
 	original_list.append(c_map[i] + i)
 	i += 1
 original_list.sort()
 print original_list
 """"""
 
 c_map = [24, 6, 2, 15, 10, -3, 15, 16, -5, 11, -2, -5, -1, -12, -4, 2, 9, 2, -5, 3, -11, -6, -17, -11, -24, -9]
 
 t = int(raw_input().strip())
 t_count = 1
 while t_count <= t:
 	ord_a = ord('a')
 	ord_z = ord('z')
 	googleres = raw_input().strip()
 	original = ''
 	for c in googleres:
 		ord_c = ord(c)
 		if ord_a <= ord_c and ord_c <= ord_z:
 			original += chr(c_map[ord_c - ord_a] + ord_c)
 		else:
 			original += c
 	print 'Case #%d: %s' % (t_count, original,)
 	t_count += 1
 
",59,604,654
"class Sweeper(object):
     def __init__(self, r, c, m):
         self.matrix = [['.' for j in range(0, c)] for i in range(0, r)]
         self.matrix[0][0] = 'c'
 
         self.r = r
         self.c = c
         self.m = m
         self.current_r = r
         self.current_c = c
         self.current_m = m
 
     def fill_row(self):
         if self.current_r >= 3 and self.current_m >= self.current_c:
             for i in range(0, self.current_c):
                 self.matrix[self.current_r - 1][i] = '*'
             self.current_r -= 1
             self.current_m -= self.current_c
             return True
         return False
 
     def fill_col(self):
         if self.current_c >= 3 and self.current_m >= self.current_r:
             for i in range(0, self.current_r):
                 self.matrix[i][self.current_c - 1] = '*'
             self.current_c -= 1
             self.current_m -= self.current_r
             return True
         return False
 
     def fill_partial(self):
         if self.current_r >= 3:
             fill_num = min(self.current_m, self.current_c - 2)
             for i in range(0, fill_num):
                 self.matrix[self.current_r - 1][self.current_c - 1 - i] = '*'
             self.current_m -= fill_num
             if fill_num > 0:
                 self.current_r -= 1
         if self.current_c >= 3:
             fill_num = min(self.current_m, self.current_r - 2)
             for i in range(0, fill_num):
                 self.matrix[self.current_r - 1 - i][self.current_c - 1] = '*'
             self.current_m -= fill_num
             if fill_num > 0:
                 self.current_c -= 1
         if self.current_m > 0:
             return False
         else:
             return True
 
     def fill_special_one(self):
         if self.current_r * self.current_c == self.current_m + 1:
             for i in range(0, self.current_r):
                 for j in range(0, self.current_c):
                     self.matrix[i][j] = '*'
             self.matrix[0][0] = 'c'
             self.current_r = 0
             self.current_c = 0
             self.current_m = 0
             return True
         return False
 
     def fill_special_col(self):
         if self.current_c == 1 and self.current_r > self.current_m:
             for i in range(0, self.current_m):
                 self.matrix[self.current_r - 1 - i][0] = '*'
             self.matrix[0][0] = 'c'
             self.current_m = 0
             self.current_r = 0
             self.current_c = 0
             return True
         return False
 
     def fill_special_row(self):
         if self.current_r == 1 and self.current_c > self.current_m:
             for i in range(0, self.current_m):
                 self.matrix[0][self.current_c - 1 - i] = '*'
             self.matrix[0][0] = 'c'
             self.current_m = 0
             self.current_r = 0
             self.current_c = 0
             return True
         return False
 
 def print_matrix(matrix):
     for row in matrix:
         s = ''
         for col in row:
             s += col
         print s
 
 #def check_matrix(matrix, m):
 #    for row in matrix:
 #        for col in row:
 #            if col == '*':
 #                m -= 1
 #    if m > 0 or matrix[0][0] != 'c':
 #        print '>>>>>>>>>>>> BUG <<<<<<<<<<<'
     
 def solve_case(t):
     r, c, m = [int(num) for num in raw_input().strip().split()]
     sweeper = Sweeper(r, c, m)
     print 'Case #%d:' % (t,)
     if sweeper.fill_special_one() or sweeper.fill_special_col() or sweeper.fill_special_row():
         #check_matrix(sweeper.matrix, m)
         print_matrix(sweeper.matrix)
         return
     f_result = True
     while sweeper.current_m > 0 and f_result:
         f_result = False
         f_result |= sweeper.fill_row()
         f_result |= sweeper.fill_col()
     if sweeper.current_m > 0:
         sweeper.fill_partial()
     if sweeper.current_m > 0:
         print 'Impossible'
     else:
         #check_matrix(sweeper.matrix, m)
         print_matrix(sweeper.matrix)
 
 def main():
     t = int(raw_input().strip())
     for i in range(1, t + 1):
         solve_case(i)
 
 if __name__ == '__main__':
     main()
",59,605,1394
"def solve_case(t):
     c, f, x = [float(num) for num in raw_input().strip().split()]
     current_time_usage = x / 2.0
 
     n = 1
     build_farm_time = c / (2.0 + float((n - 1) * f))
     attemp_time_usage = (x / (2.0 + float(n * f))) + build_farm_time
 
     while attemp_time_usage < current_time_usage:
         current_time_usage = attemp_time_usage
 
         n += 1
         build_farm_time += c / (2.0 + float((n - 1) * f))
         attemp_time_usage = (x / (2.0 + float(n * f))) + build_farm_time
 
     print 'Case #%d: %.7f' % (t, current_time_usage,)
 
 def main():
     t = int(raw_input().strip())
     for i in range(1, t + 1):
         solve_case(i)
 
 if __name__ == '__main__':
     main()
",59,606,290
"#
 # Google Code Jam 2014
 # Roaund 0: A. Magic Trick
 # submission by EnTerr
 #
 
 '''
 ---Input 
 3
 2
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
 3
 1 2 5 4
 3 11 6 15
 9 10 7 12
 13 14 8 16
 2
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
 2
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
 2
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
 3
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
 
 ---Output 
 Case #1: 7
 Case #2: Bad magician!
 Case #3: Volunteer cheated!
 '''
 
 
 
 = open(sys.argv[1])
 def input(): return f.readline().strip();
 
        
 
 #clk = clock()
 
 for caseNo in xrange(1, int(input())+1):
     #first time
     row_no = int(input())
     for i in 1,2,3,4:
         row = input()
         if i == row_no:
             nums = set(row.split())
             
     #second time
     row_no = int(input())
     for i in 1,2,3,4:
         row = input()
         if i == row_no:
             nums &= set(row.split())
 
 #    print >>sys.stderr, caseNo
     if not nums:
         res = 'Volunteer cheated!'
     elif len(nums) > 1:
         res = 'Bad magician!'        
     else:
         res = nums.pop()
     print 'Case #%d:' % caseNo, res
     
 #print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )
 
",60,607,636
"#
 # Google Code Jam 2013
 # Round 0: B. Lawnmower
 # submission by EnTerr
 #
 
 '''
 Limits
 
 1 <= T <= 100.
 
 Small dataset   1 <= N, M <= 10. 1 <= a[i,j] <= 2.
 Large dataset   1 <= N, M <= 100. 1 <= a[i,j] <= 100.
 
 Sample
 
 *** Input 
 3
 3 3
 2 1 2
 1 1 1
 2 1 2
 5 5
 2 2 2 2 2
 2 1 1 1 2
 2 1 2 1 2
 2 1 1 1 2
 2 2 2 2 2
 1 3
 1 2 1
 
 *** Output 
 Case #1: YES
 Case #2: NO
 Case #3: YES
 
 '''
 
 ##psyco.full()
 
 = open(sys.argv[1])
 def input(): return inf.readline().strip()
 
 
 def check_lawn(board):
     n = len(board)
     m = len(board[0])
     hmax = map(max, board)
     vmax = map(max, zip(*board))
     for i in range(n):
         for j in range(m):
             if board[i][j] < min(hmax[i], vmax[j]):
                 return 'NO'
     return 'YES'
 
 for caseNo in range(1, int(input())+1):
     #tm = clock()
     n,m = map(int, input().split())
     board = [map(int, input().split()) for _ in range(n)]
     print 'Case #%d:' % caseNo, check_lawn(board)
     #print >>sys.stderr, caseNo, clock() - tm
 
",60,608,492
"#
 # Google Code Jam 2012
 # Round 0: C. Recycled Numbers
 # submission by EnTerr
 #
 
 '''
 Limits: 1 <= T <= 50. A and B have the same number of digits.
 Small dataset: 1 <= A <= B <= 1000.
 Large dataset: 1 <= A <= B <= 2000000
 
 Input 
 4
 1 9
 10 40
 100 500
 1111 2222
  	
 Output 
 Case #1: 0
 Case #2: 3
 Case #3: 156
 Case #4: 287
 
 '''
 
 ()
 
 = open(sys.argv[1])
 def input(): return inf.readline().strip()
 
 def numRecycled(A,B):
     ln = len(str(A))
     rot = 10**(ln-1)
     cnt = 0
     for i in range(A,B+1):
         res = set()
         j = i
         for _ in range(ln-1):
             a,b = divmod(j, 10)
             j = rot*b + a
             if i < j <= B:
                 res.add(j)
         cnt += len(res)
     return cnt
 
 for caseNo in range(1, int(input())+1):
     #print >>sys.stderr, caseNo
     #tm = clock()
     print 'Case #%d:' % caseNo,
     A,B = map(int, input().split())
     print numRecycled(A,B)
     #print A, B, clock() - tm
 
",60,609,432
"#
 # Google Code Jam 2013
 # Round 0: A. Tic-Tac-Toe-Tomek
 # submission by EnTerr
 #
 
 '''
 Limits
 The game board provided will represent a valid state that was reached
 through play of the game Tic-Tac-Toe-Tomek as described above.
 
 Small dataset   1 = T = 10.
 Large dataset   1 = T = 1000.
 
 *** Sample Input 
 6
 XXXT
 ....
 OO..
 ....
 
 XOXT
 XXOO
 OXOX
 XXOO
 
 XOX.
 OX..
 ....
 ....
 
 OOXX
 OXXX
 OX.T
 O..O
 
 XXXO
 ..O.
 .O..
 T...
 
 OXXX
 XO..
 ..O.
 ...O
 
 ***Output 
 Case #1: X won
 Case #2: Draw
 Case #3: Game has not completed
 Case #4: O won
 Case #5: O won
 Case #6: O won
 
 '''
 
 ##psyco.full()
 
 = open(sys.argv[1])
 def input(): return inf.readline().strip()
 
 # compile ""just in case"" not to rely on `re` caching
 # check horizontal or vertical or diagonal type1 or diag. type2
 x_ptrn = re.compile('X{4}|X(.{4}X){3}|X(.{3}X){3}|X(.{5}X){3}')
 o_ptrn = re.compile('O{4}|O(.{4}O){3}|O(.{3}O){3}|O(.{5}O){3}')
 
 
 def check_game_status(board):
     if x_ptrn.search(board.replace('T','X')):
         return 'X won'
     elif o_ptrn.search(board.replace('T','O')):
         return 'O won'
     elif '.' not in board:
         return 'Draw'
     else:
         return 'Game has not completed'
 
 for caseNo in range(1, int(input())+1):
     #tm = clock()
     board = '|'.join(input() for _ in range(4))
     input() # skip empty line
     print 'Case #%d:' % caseNo, check_game_status(board)
     #print >>sys.stderr, caseNo, clock() - tm
 
",60,610,606
"#
 # Google Code Jam 2012
 # Round 0: B. Dancing With the Googlers
 # submission by EnTerr
 #
 
 '''
 Limits: T in [1,100], S in [0,N], p in [0,10], Ti in [0, 30]
 At least S of the ti values will be between 2 and 28, inclusive.
 
 Small dataset 1 = N = 3.
 Large dataset 1 = N = 100.
 
 Sample Input 
 4
 3 1 5 15 13 11
 3 0 8 23 22 21
 2 1 1 8 0
 6 2 8 29 20 8 18 18 21
 
 Output 
 Case #1: 3
 Case #2: 2
 Case #3: 1
 Case #4: 3
 '''
 
 ##psyco.full()
 
 = open(sys.argv[1])
 def input(): return inf.readline().strip()
 
 def maxBestDancers(N, S, p, *Ti):
     cnt = 0
     for score in Ti:
         mx = (score + 2) // 3
         if mx >= p:
             cnt += 1
         elif mx >= p-1 > 0 and S>0:
             S -= 1
             cnt += 1
     return cnt
 
 for caseNo in range(1, int(input())+1):
     #tm = clock()
     print 'Case #%d:' % caseNo,
     lst = map(int, input().split())
     print maxBestDancers(*lst)
     #print >>sys.stderr, caseNo, clock() - tm
 
",60,611,448
"#
 # Google Code Jam 2014
 # Roaund 0: D. Deceitful War
 # submission by EnTerr
 #
 
 '''
 Input
 The first line of the input gives the number of test cases, T. T test cases follow. 
 Each test case starts with a line containing a single integer N, the number of blocks 
 each player has. Next follows a line containing N space-separated real numbers: 
 the masses of Naomi's blocks, in kg. Finally there will be a line containing N 
 space-separated real numbers: the masses of Ken's blocks, in kg.
 
 Output
 For each test case, output one line containing ""Case #x: y z"", where 
 x is the test case number (starting from 1), 
 y is the number of points Naomi will score if she plays Deceitful War optimally, and 
 z is the number of points Naomi will score if she plays War optimally.
 
 Limits
 1 <= T <= 50.
 All the masses given to Ken and Naomi are distinct, and between 0.0 and 1.0 exclusive.
 
 Small dataset
 1 <= N <= 10.
 
 Large dataset
 1 <= N <= 1000.
 
 ---Input 
 4
 1
 0.5
 0.6
 2
 0.7 0.2
 0.8 0.3
 3
 0.5 0.1 0.9
 0.6 0.4 0.3
 9
 0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899
 0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458
 
 ---Output 
 Case #1: 0 0
 Case #2: 1 0
 Case #3: 2 1
 Case #4: 8 4
 
 
 '''
 
 = open(sys.argv[1])
 def input(): return f.readline().strip();
 
 
 
 def deceitfulWar(Naomi, Ken):
     Naomi = Naomi[:]
     Ken = Ken[:]
     pts = 0
     while Naomi and Ken and Naomi[-1] > Ken[0]:
         #Naomi's max is bigger than Ken's min
         #lie to force him to throw out the min
         #fore-""trump"" with smallest bigger card
         kn = Ken.pop(0)
         for i in range(len(Naomi)):
             if Naomi[i] > kn:
                 #since Naomi[-1] > kn, we'll get here
                 Naomi.pop(i)
                 break
         pts += 1        
 
     return pts
 
 def war(Naomi, Ken):
     Naomi = Naomi[:]
     Ken = Ken[:]
     pts = 0
     while Naomi and Ken:
         #naomi plays her smallest
         nm = Naomi.pop(0)
         if nm > Ken[-1]:
             #if Ken cannot beat, he plays his smallest
             Ken.pop(0)
             pts += 1
         else:
             #if he can beat, he finds the smallest above nm
             for i in range(len(Ken)):
                 if Ken[i] > nm:
                     #since Ken[-1] > nm, we'll get here
                     Ken.pop(i)
                     break          
     return pts
 
 #clk = clock()
 
 for caseNo in xrange(1, int(input())+1):
     #print >>sys.stderr, caseNo
     _ = input()
     Naomi = sorted(map(float, input().split()))
     Ken = sorted(map(float, input().split()))
     print 'Case #%d:' % caseNo, deceitfulWar(Naomi, Ken), war(Naomi, Ken)
     
 #print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )
 
 
",60,612,1045
"#
 # Google Code Jam 2013
 # Round 0: C. Fair and Square
 # submission by EnTerr
 #
 
 '''
 Limits
 
 Small dataset       1 <= T <= 100, 1 <= A <= B <= 1000.
 First large dataset 1 <= T <= 10000. 1 <= A <= B <= 1014.
 Second large dataset    1 <= T <= 1000. 1 <= A <= B <= 10100.
 
 Sample
 *** Input 
 3
 1 4
 10 120
 100 1000
  	
 *** Output 
 Case #1: 2
 Case #2: 0
 Case #3: 2
 
 
 '''
 
 ##psyco.full()
 
 = open(sys.argv[1])
 def input(): return inf.readline().strip()
 
 # ""cheat"" from http://www.worldofnumbers.com/allsquar.htm
 # ""Exhaustive list of Palindromic Squares up to length 31""
 # roots of palindromic squares
 pal_sqr_roots = '''1 
 2 
 3 
 11 
 22 
 26 
 101 
 111 
 121 
 202 
 212 
 264 
 307 
 836 
 1001 
 1111 
 2002 
 2285 
 2636 
 10001 
 10101 
 10201 
 11011 
 11111 
 11211 
 20002 
 20102 
 22865 
 24846 
 30693 
 100001 
 101101 
 110011 
 111111 
 200002 
 798644 
 1000001 
 1001001 
 1002001 
 1010101 
 1011101 
 1012101 
 1042151 
 1100011 
 1101011 
 1102011 
 1109111 
 1110111 
 1111111 
 1270869 
 2000002 
 2001002 
 2012748 
 2294675 
 3069307 
 10000001 
 10011001 
 10100101 
 10111101 
 11000011 
 11011011 
 11100111 
 11111111 
 11129361 
 12028229 
 12866669 
 20000002 
 30001253 
 64030648 
 100000001 
 100010001 
 100020001 
 100101001 
 100111001 
 100121001 
 101000101 
 101010101 
 101020101 
 101101101 
 101111101 
 110000011 
 110010011 
 110020011 
 110091011 
 110101011 
 110111011 
 111000111 
 111010111 
 111091111 
 111101111 
 111111111 
 200000002 
 200010002 
 306930693 
 1000000001 
 1000110001 
 1001001001 
 1001111001 
 1010000101 
 1010110101 
 1011001101 
 1011111101 
 1100000011 
 1100110011 
 1101001011 
 1101111011 
 1110000111 
 1110110111 
 1111001111 
 2000000002 
 2062386218 
 2481623254 
 10000000001 
 10000100001 
 10000200001 
 10001010001 
 10001110001 
 10001210001 
 10010001001 
 10010101001 
 10010201001 
 10011011001 
 10011111001 
 10100000101 
 10100100101 
 10100200101 
 10101010101 
 10101110101 
 10106064399 
 10109901101 
 10110001101 
 10110101101 
 10110911101 
 10111011101 
 10111111101 
 10207355549 
 11000000011 
 11000100011 
 11000200011 
 11000910011 
 11001010011 
 11001110011 
 11010001011 
 11010101011 
 11010911011 
 11011011011 
 11011111011 
 11100000111 
 11100100111 
 11100910111 
 11101010111 
 11101110111 
 11110001111 
 11110101111 
 13579355059 
 20000000002 
 20000100002 
 22865150135 
 30101273647 
 30693069307 
 83163115486 
 100000000001 
 100001100001 
 100010010001 
 100011110001 
 100100001001 
 100101101001 
 100110011001 
 100111111001 
 101000000101 
 101001100101 
 101010010101 
 101011110101 
 101100001101 
 101101101101 
 101110011101 
 101116809851 
 110000000011 
 110001100011 
 110010010011 
 110011110011 
 110100001011 
 110101101011 
 110110011011 
 111000000111 
 111001100111 
 111010010111 
 111100001111 
 111283619361 
 112247658961 
 128817084669 
 200000000002 
 1000000000001 
 1000001000001 
 1000002000001 
 1000010100001 
 1000011100001 
 1000012100001 
 1000100010001 
 1000101010001 
 1000102010001 
 1000110110001 
 1000111110001 
 1001000001001 
 1001001001001 
 1001002001001 
 1001010101001 
 1001011101001 
 1001100011001 
 1001101011001 
 1001110111001 
 1001111111001 
 1010000000101 
 1010001000101 
 1010002000101 
 1010010100101 
 1010011100101 
 1010099010101 
 1010100010101 
 1010101010101 
 1010109110101 
 1010110110101 
 1010111110101 
 1011000001101 
 1011001001101 
 1011010101101 
 1011011101101 
 1011099011101 
 1011100011101 
 1011101011101 
 1100000000011 
 1100001000011 
 1100002000011 
 1100009100011 
 1100010100011 
 1100011100011 
 1100100010011 
 1100101010011 
 1100110110011 
 1100111110011 
 1101000001011 
 1101001001011 
 1101009101011 
 1101010101011 
 1101011101011 
 1101100011011 
 1101101011011 
 1110000000111 
 1110001000111 
 1110009100111 
 1110010100111 
 1110011100111 
 1110100010111 
 1110101010111 
 1111000001111 
 1111001001111 
 1349465117841 
 2000000000002 
 2000001000002 
 2149099165358 
 2634812417864 
 3069306930693 
 6360832925898 
 10000000000001 
 10000011000001 
 10000100100001 
 10000111100001 
 10001000010001 
 10001011010001 
 10001100110001 
 10001111110001 
 10010000001001 
 10010011001001 
 10010100101001 
 10010111101001 
 10011000011001 
 10011011011001 
 10011100111001 
 10100000000101 
 10100011000101 
 10100100100101 
 10100111100101 
 10101000010101 
 10101011010101 
 10101100110101 
 10110000001101 
 10110011001101 
 10110100101101 
 10111000011101 
 11000000000011 
 11000011000011 
 11000100100011 
 11000111100011 
 11001000010011 
 11001011010011 
 11001100110011 
 11010000001011 
 11010011001011 
 11010100101011 
 11011000011011 
 11100000000111 
 11100011000111 
 11100100100111 
 11101000010111 
 11110000001111 
 20000000000002 
 30395080190573 
 69800670077028 
 98275825201587 
 100000000000001 
 100000010000001 
 100000020000001 
 100000101000001 
 100000111000001 
 100000121000001 
 100001000100001 
 100001010100001 
 100001020100001 
 100001101100001 
 100001111100001 
 100010000010001 
 100010010010001 
 100010020010001 
 100010101010001 
 100010111010001 
 100011000110001 
 100011010110001 
 100011101110001 
 100011111110001 
 100100000001001 
 100100010001001 
 100100020001001 
 100100101001001 
 100100111001001 
 100101000101001 
 100101010101001 
 100101101101001 
 100101111101001 
 100109990011001 
 100110000011001 
 100110010011001 
 100110091011001 
 100110101011001 
 100110111011001 
 100110990111001 
 100111000111001 
 100111010111001 
 101000000000101 
 101000010000101 
 101000020000101 
 101000101000101 
 101000111000101 
 101000990100101 
 101001000100101 
 101001010100101 
 101001091100101 
 101001101100101 
 101001111100101 
 101010000010101 
 101010010010101 
 101010101010101 
 101010111010101 
 101010990110101 
 101011000110101 
 101011010110101 
 101100000001101 
 101100010001101 
 101100101001101 
 101100111001101 
 101101000101101 
 101101010101101 
 101110000011101 
 101110010011101 
 110000000000011 
 110000010000011 
 110000020000011 
 110000091000011 
 110000101000011 
 110000111000011 
 110001000100011 
 110001010100011 
 110001101100011 
 110001111100011 
 110010000010011 
 110010010010011 
 110010091010011 
 110010101010011 
 110010111010011 
 110011000110011 
 110011010110011 
 110100000001011 
 110100010001011 
 110100101001011 
 110100111001011 
 110101000101011 
 110101010101011 
 110110000011011 
 110110010011011 
 111000000000111 
 111000010000111 
 111000091000111 
 111000101000111 
 111000111000111 
 111001000100111 
 111001010100111 
 111010000010111 
 111010010010111 
 111100000001111 
 111100010001111 
 129610990752569 
 200000000000002 
 200000010000002 
 210786628549538 
 314155324482867 
 1000000000000000 
 1000000110000000 
 1000001001000000 
 1000001111000000 
 1000010000100000 
 1000010110100000 
 1000011001100000 
 1000011111100000 
 1000100000010000 
 1000100110010000 
 1000101001010000 
 1000101111010000 
 1000110000110000 
 1000110110110000 
 1000111001110000 
 1001000000001000 
 1001000110001000 
 1001001001001000 
 1001001111001000 
 1001010000101000 
 1001010110101000 
 1001011001101000 
 1001100000011000 
 1001100110011000 
 1001101001011000 
 1001110000111000 
 1010000000000100 
 1010000110000100 
 1010001001000100 
 1010001111000100 
 1010010000100100 
 1010010110100100 
 1010011001100100 
 1010100000010100 
 1010100110010100 
 1010101001010100 
 1010110000110100 
 1011000000001100 
 1011000110001100 
 1011001001001100 
 1011010000101100 
 1011100000011100 
 1100000000000010 
 1100000110000010 
 1100001001000010 
 1100001111000010 
 1100010000100010 
 1100010110100010 
 1100011001100010 
 1100100000010010 
 1100100110010010 
 1100101001010010 
 1100110000110010 
 1101000000001010 
 1101000110001010 
 1101001001001010 
 1101010000101010 
 1101100000011010 
 1110000000000110 
 1110000110000110 
 1110001001000110 
 1110010000100110 
 1110100000010110 
 1111000000001110 
 2000000000000000 
 2201019508986470 
 2564053868197730 
 3066446727654240 
 3107974295870660 
 3138199296186060'''
 pal_sqr_roots = map(int, pal_sqr_roots.split())
 
 # see also http://web.archive.org/web/20020614225321/http://www.geocities.com/williamrexmarshall/math/palsq.html
 # http://www.worldofnumbers.com/square.htm
 # http://mathforum.org/library/drmath/view/51510.html
 
 
 def is_palindrome(n):
     return str(n)[::-1] == str(n)
 
 palindromic_roots = [x for x in pal_sqr_roots if is_palindrome(x)]
 
 fair_and_square = [x*x for x in palindromic_roots]
 
 
 def get_num_fair_and_square(a, b):
     return len([x for x in fair_and_square if a <= x <= b])
 
 for caseNo in range(1, int(input())+1):
     #tm = clock()
     a,b = map(int, input().split())
     print 'Case #%d:' % caseNo, get_num_fair_and_square(a, b)
     #print >>sys.stderr, caseNo, clock() - tm
 
",60,613,8041
"#
 # Google Code Jam 2012
 # Round 0: A. Speaking in Tongues
 # submission by EnTerr
 #
 
 '''
 Limits: 1 = T = 30. G contains at most 100 characters.
 None of the text is guaranteed to be valid English.
 Sample
 
 Input
 3
 ejp mysljylc kd kxveddknmc re jsicpdrysi
 rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
 de kr kd eoya kw aej tysr re ujdr lkgc jv
 
 Output
 Case #1: our language is impossible to understand
 Case #2: there are twenty six factorial possibilities
 Case #3: so it is okay if you want to just give up
 '''
 
 ##psyco.full()
 
 #= open(sys.argv[1])
 def input(): return inf.readline().strip()
 
 knownPairs = [
     ('zq', 'qz'),
     ('ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand'),
     ('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities'),
     ('de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up')
 ]
 
 xlat = [chr(0) for ch in range(256)]
 for crypt, plain in knownPairs:
     for a,b in zip(crypt, plain):
         xlat[ord(a)] = b
 for i in range(26):
     xlat[ord('A')+i] = chr(ord(xlat[ord('a')+i]) - ord('a') + ord('A'))
 xlat = ''.join(xlat)
 
 for caseNo in range(1, int(input())+1):
     #print >>sys.stderr, caseNo
     print 'Case #%d:' % caseNo, input().translate(xlat)
 
 
",60,614,526
"#
 # Google Code Jam 2014
 # Roaund 0: C. Minesweeper Master
 # submission by EnTerr
 #
 
 '''
 Input
 The first line of the input gives the number of test cases, T. T lines follow. 
 Each line contains three space-separated integers: R, C, and M (Rows, Columns, Mines).
 
 Output
 For each test case, output a line containing ""Case #x:"", where x is the test case number. 
 On the following R lines, output the board configuration with C characters per line, 
 using '.' to represent an empty cell, '*' to represent a cell that contains a mine, 
 and 'c' to represent the clicked cell. If there is no possible configuration, 
 then instead of the grid, output a line with ""Impossible"" instead. 
 If there are multiple possible configurations, output any one of them.
 
 Limits
 0 <= M < R * C.
 
 Small dataset
 1 <= T <= 230.
 1 <= R, C <= 5.
 
 Large dataset
 1 <= T <= 140.
 1 <= R, C <= 50.
 
 Sample
 ---Input 
 5
 5 5 23
 3 1 1
 2 2 1
 4 7 3
 10 10 82
 
 ---Output 
 Case #1:
 Impossible
 Case #2:
 c
 .
 *
 Case #3:
 Impossible
 Case #4:
 ......*
 .c....*
 .......
 ..*....
 Case #5:
 **********
 **********
 **********
 ****....**
 ***.....**
 ***.c...**
 ***....***
 **********
 **********
 **********
 
 
 '''
 
 = open(sys.argv[1])
 def input(): return f.readline().strip();
 
 (R, C, M):
     #extra empty/boundary row added at the end (also reached as the one before [0])
     #each row has extra empty/boundary element at the end
     for mines in combinations( product(range(R), range(C)), M):
         board = [ ['.'] * C + [''] for _ in range(R) ]
         for row, col in mines:
             board[row][col] = '*'
         yield board + [[''] * (C+1)]
     pass
 
 def oneClickSolution(R, C, M):
     for bd in genBoards(R, C, M):
         #count number of mines
         minTile = 10
         for r in range(R):
             for c in range(C):
                 if bd[r][c] == '.':
                     n = sum(bd[r+i][c+j]=='*' for i in (-1,0,1) for j in (-1,0,1))
                     bd[r][c] = `n`
                     if n <= minTile:
                         minTile = n
                         minR, minC = r, c
         if minTile < 10:
             #use flood from a 0 square, does it reach all 0-s?
             queue = [ (minR, minC) ]
             nOpen = 0
             while queue:
                 r,c = queue.pop()
                 if bd[r][c] == '0':
                     for i in -1,0,1:
                         for j in -1,0,1:
                             if i or j: # we don't add the one we popped back
                                 queue.append( (r+i, c+j) )
                 if bd[r][c] not in '.*':
                     bd[r][c] = '.'
                     nOpen += 1
             if M + nOpen == R*C:
                 bd[minR][minC] = 'c'
                 return '\n'.join( ''.join(row[:-1]) for row in bd[:-1] )
 
     return 'Impossible'
 
 
 clk = clock()
 
 for caseNo in xrange(1, int(input())+1):
     R, C, M = map(int, input().split())
     print >>sys.stderr, caseNo, R, C, M #, oneClickSolution(R, C, M)<>'Impossible'
     print 'Case #%d:' % caseNo  
     print oneClickSolution(R, C, M)
     
 print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )
 
",60,615,1129
"():
     return int(sys.stdin.readline())
 
 def readintarray():
     return map(int, sys.stdin.readline().strip().split())
 
 def readpairs(start=0):
     elems = readintarray()[start:]
     return [elems[i:i+2] for i in xrange(0, len(elems), 2)]
 
 def readstring():
     return sys.stdin.readline()[:-1]
 
",61,616,120
"():
     return int(sys.stdin.readline())
 
 def readintarray():
     return map(int, sys.stdin.readline().strip().split())
 
 def readpairs(start=0):
     elems = readintarray()[start:]
     return [elems[i:i+2] for i in xrange(0, len(elems), 2)]
 
 def readstring():
     return sys.stdin.readline()[:-1]
 
",61,617,120
"from codejam import *
 
 for case in xrange(readint()):
     A, B = readintarray()
     res = 0
     for i in xrange(A, B + 1):
         for j in xrange(i + 1, B + 1):
             ist = str(i)
             jst = str(j)
             if len(ist) != len(jst):
                 continue
 
             if ist in (jst + jst):
                 res += 1
 
     print ""Case #%d: %d"" % (case + 1, res)
",61,618,145
"():
     return int(sys.stdin.readline())
 
 def readintarray():
     return map(int, sys.stdin.readline().strip().split())
 
 def readpairs(start=0):
     elems = readintarray()[start:]
     return [elems[i:i+2] for i in xrange(0, len(elems), 2)]
 
 def readstring():
     return sys.stdin.readline()[:-1]
 
",61,619,120
"():
     return int(sys.stdin.readline())
 
 def readintarray():
     return map(int, sys.stdin.readline().strip().split())
 
 def readpairs(start=0):
     elems = readintarray()[start:]
     return [elems[i:i+2] for i in xrange(0, len(elems), 2)]
 
 def readstring():
     return sys.stdin.readline()[:-1]
 
",61,620,120
"= [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004]
 
 for case in xrange(codejam.readint()):
     A, B = map(int, codejam.readstring().split())
     count = 0
     for possible in possibles:
         if A > possible:
             continue
 
         if B < possible:
             break
 
         count += 1
 
     print ""Case #%d: %d"" % (case + 1, count)
",61,621,534
"from codejam import *
 = ""ejp mysljylc kd kxveddknmc re jsicpdrysi""\
       ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd""\
       ""de kr kd eoya kw aej tysr re ujdr lkgc jv zq""
 out = ""our language is impossible to understand""\
     ""there are twenty six factorial possibilities""\
     ""so it is okay if you want to just give up qz""
 
 for case in xrange(readint()):
     trantab = maketrans(inp, out)
     line = readstring()
     print ""Case #%d: %s"" % (case + 1, line.translate(trantab))
",61,622,188
"*
 
 
 directions = list(itertools.product([1, 0, -1], [1, 0, -1]))
 def count_neighbors(table, r, c):
     cols = len(table[0])
     rows = len(table)
     return sum(table[r + x][c + y] == ""*"" for x, y in directions 
                 if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)
 
 def is_valid(table):
     cols = len(table[0])
     rows = len(table)
     for r in xrange(rows):
         for c in xrange(cols):
             has_zero = any(table[r + x][c + y] == 0 for x, y in directions 
                             if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)
             if table[r][c] != ""*"" and not has_zero:
                 return False
 
     return True
 
 
 def draw_table(table, hide=False):
     cols = len(table[0])
     rows = len(table)
     ascii_table = """"
     for r in xrange(rows):
         for c in xrange(cols):
             if table[r][c] != ""*"":
                 ch = ""c"" if r == 0 and c == 0 else "".""
                 table[r][c] = count_neighbors(table, r, c) if not hide else ch
 
             ascii_table += str(table[r][c])
 
         ascii_table += ""\n""
 
     return ascii_table[:-1]
 
 def solve(R, C, M):
     r = c = 0
     current_mines = R * C
     table = [[""*""] * C for k in xrange(R)]
     while M < current_mines:
         if table[r][c] == '*':
             table[r][c] = "".""
             current_mines -= 1
 
         if current_mines > M and r + 1 < R and table[r+1][c] == ""*"":
             table[r+1][c] = "".""
             current_mines -= 1
 
         draw_table(table)
         c += 1
         if c >= C:
             c = 0
             r += 1
 
     return table
 
 for i in xrange(readint()):
     R, C, M = readintarray()
 
     print ""Case #%d:"" % (i + 1)
     if M < (R * C) - 1:
         table = solve(R, C, M)
         if is_valid(table):
             print draw_table(table, hide=True)
         else:
             table = solve(C, R, M)
             rotated = [[""*""] * C for k in xrange(R)]
             for r in xrange(R - 1, -1, -1):
                 for c in xrange(C):
                     rotated[R - r - 1][c] = table[c][r]
 
             print draw_table(rotated, hide=True) if is_valid(rotated) else ""Impossible""
 
     elif M == R * C:
         print ""Impossible""
 
     else:
         table = [[""*""] * C for k in xrange(R)]
         table[0][0] = '.'
         print draw_table(table, hide=True)
",61,623,873
"():
     return int(sys.stdin.readline())
 
 def readfloatarray():
     return map(float, sys.stdin.readline().strip().split())
 
 def readintarray():
     return map(int, sys.stdin.readline().strip().split())
 
 def readpairs(start=0):
     elems = readintarray()[start:]
     return [elems[i:i+2] for i in xrange(0, len(elems), 2)]
 
 def readstring():
     return sys.stdin.readline()[:-1]
 
",61,624,147
"f = open('input.in')
 g = open('output', 'w')
 
 T = int(f.readline()[:-1])
 
 for case in xrange(T) :
     a1 = int(f.readline()[:-1])
     M1 = [map(int, f.readline()[:-1].split()) for i in range(4)]
     a2 = int(f.readline()[:-1])
     M2 = [map(int, f.readline()[:-1].split()) for i in range(4)]
     r1 = M1[a1-1]
     r2 = M2[a2-1]
     res = set(r1).intersection(set(r2))
     if len(res) == 1 : res = res.pop()
     elif len(res) == 0 : res = 'Volunteer cheated!'
     else : res = 'Bad magician!'
     output = 'Case #' + str(case + 1) + ': ' + str(res)
     g.write(output + '\n')
     print output
 
 f.close()
 g.close()
",62,625,278
"f = open('B-small-attempt0.in', 'r')
 g = open('output', 'w')
 
 T = int(f.readline()[:-1])
 
 for case in range(T) :
     A = []
     N, M = map(int, f.readline()[:-1].split())
     for i in range(N) : A.append(map(int, f.readline()[:-1].split()))
     for line in A : print line
     maxPerRow = map(max, A)
     maxPerColumn = map(max, zip(*A))
     res = all(A[i][j] in (maxPerRow[i], maxPerColumn[j]) for i in range(N) for j in range(M))
     outString = 'Case #' + str(case+1) + ': ' + ('YES' if res else 'NO') + '\n'
     print outString[:-1]
     g.write(outString)
 
 f.close()
 g.close()
",62,626,249
"fin = open('C-small-attempt0.in', 'r')
 fout = open('C-output.txt', 'w')
 
 cases = int(fin.readline()[:-1])
 
 for case in range(cases) :
     A, B = map(int, fin.readline()[:-1].split(' '))
     digits = len(str(A))
     couples = set()
     for n in range(A,B+1) :
         for t in range(1,digits) :
             m = [str(n)[(i+t)%digits] for i in range(digits)]
             m = int(''.join(m))
             if A <= n < m <= B :
                 couples.add(str([n,m]))
     res = len(couples)
     print 'Case #' + str(case+1) + ': ' + str(res)
     fout.write('Case #' + str(case+1) + ': ' + str(res) + '\n')
     
 fin.close()
 fout.close()
",62,627,263
"def detectResults() :
     for sym in ('X', 'O') :
         for line in board :
             if all(elem in (sym, 'T') for elem in line) :
                 return sym + ' won'
         for column in range(4) :
             if all(board[i][column] in (sym, 'T') for i in range(4)) :
                 return sym + ' won'
         if all(board[i][i] in (sym, 'T') for i in range(4)) or all(board[3-i][i] in (sym, 'T') for i in range(4)) :
             return sym + ' won'
     for sym in ('X', 'O') :
         for line in board :
             if all(elem in (sym, 'T', '.') for elem in line) :
                 return 'Game has not completed'
         for column in range(4) :
             if all(board[i][column] in (sym, 'T', '.') for i in range(4)) :
                 return 'Game has not completed'
         if all(board[i][i] in (sym, 'T', '.') for i in range(4)) or all(board[3-i][i] in (sym, 'T', '.') for i in range(4)) :
             return 'Game has not completed'
     return 'Draw'
 
 f = open('A-small-attempt0.in', 'r')
 g = open('output', 'w')
 
 T = int(f.readline()[:-1])
 
 for case in range(T) :
     board = []
     for i in range(4) : board.append([i for i in f.readline()[:-1]])
     outString = 'Case #' + str(case+1) + ': ' + detectResults() + '\n'
     print outString[:-1]
     g.write(outString)
     useless = f.readline()[:-1]
 
 f.close()
 g.close()
",62,628,481
"fin = open('B-small-attempt0.in', 'r')
 fout = open('B-output.txt', 'w')
 
 cases = int(fin.readline()[:-1])
 
 for case in range(cases) :
     line = map(int, fin.readline()[:-1].split(' '))
     N, S, p = line[:3]
     T = line[3:]
     okLimit = p + 2*max(p-1,0)
     okIfSLimit = p + 2*max(p-2,0)
     ok = len(filter(lambda x : x >= okLimit, T))
     okIfS = len(filter(lambda x : okLimit > x >= okIfSLimit, T))
     res = ok + min(okIfS, S)
     # print 'Case #' + str(case+1) + ': ' + str(res)
     fout.write('Case #' + str(case+1) + ': ' + str(res) + '\n')
     
 fin.close()
 fout.close()
",62,629,263
"f = open('input.in')
 g = open('output', 'w')
 
 T = int(f.readline()[:-1])
 
 for case in xrange(T) :
     N = int(f.readline()[:-1])
     Naomi = sorted(map(float, f.readline()[:-1].split()))
     Ken = sorted(map(float, f.readline()[:-1].split()))
     Ken2 = Ken[:]
     War, DWar = 0, 0
     for n in Naomi :
         if n > max(Ken) :
             Ken.pop(0)
             War += 1
         else :
             for i, k in enumerate(Ken) :
                 if k > n : break
             Ken.pop(i)
     Ken = Ken2
     for n in Naomi :
         if n < min(Ken) :
             Ken.pop(-1)
         else :
             Ken.pop(0)
             DWar += 1
     output = 'Case #' + str(case + 1) + ': ' + str(DWar) + ' ' + str(War)
     g.write(output + '\n')
     print output
 
 f.close()
 g.close()
",62,630,308
"(n) :
     return str(n) == str(n)[::-1]
 
 def findPalindrome(n) :
     if n % 2 == 0 : return [start*(10**(n/2)) + int(str(start)[::-1]) for start in range(10**(n/2-1),10**(n/2))]
     if n == 1 : return range(1,10)
     return [start*(10**(n/2)) + int(str(start)[:-1][::-1]) for start in range(10**(n/2),10**((n+1)/2))]
 
 def findPalindromeInRange(a, b) :
     num = range(len(str(a)), len(str(b)) + 1)
     allPalindrome = []
     for n in num : allPalindrome += findPalindrome(n)
     return filter(lambda x : a <= x <= b, allPalindrome)
 
 f = open('C-small-attempt0.in', 'r')
 g = open('output', 'w')
 
 T = int(f.readline()[:-1])
 
 for case in range(T) :
     A, B = map(int, f.readline()[:-1].split())
     a = int(math.ceil(A**0.5))
     b = int(B**0.5)
     res = len(filter(lambda x : isPalindrome(x**2), findPalindromeInRange(a, b)))
     outString = 'Case #' + str(case+1) + ': ' + str(res) + '\n'
     print outString[:-1]
     g.write(outString)
 
 f.close()
 g.close()
",62,631,438
"f = open('input.in')
 g = open('output', 'w')
 
 T = int(f.readline()[:-1])
 
 for case in xrange(T) :
     R, C, M = map(int, f.readline()[:-1].split())
     FREE = R*C - M
     if FREE == 0 : res = '\nImpossible'
     elif FREE != 1 and M > 0 and (R == 2 or C == 2) and (FREE == 2 or FREE % 2 == 1) : res = '\nImpossible'
     elif R > 2 and C > 2 and FREE in (2, 3, 5, 7) : res = '\nImpossible'
     else :
         MAP = [['.' for c in range(C)] for r in range(R)]
         MAP[0][0] = 'c'
         if R == 1 :
             for i in range(C-1, C-M-1, -1) : MAP[0][i] = '*'
         elif C == 1 :
             for i in range(R-1, R-M-1, -1) : MAP[i][0] = '*'
         elif R == 2 :
             for i in range(C-1, C-M/2-1, -1) : MAP[0][i], MAP[1][i] = '*', '*'
             if FREE == 1 : MAP[1][0] = '*'
         elif C == 2 :
             for i in range(R-1, R-M/2-1, -1) : MAP[i][0], MAP[i][1] = '*', '*'
             if FREE == 1 : MAP[0][1] = '*'
         else :
             com = M / C
             for i in range(R-1, max(R-com-1, 2), -1) :
                 MAP[i] = ['*' for j in range(C)]
                 M -= C
             I = max([i for i, j in enumerate(MAP) if j[0] == '.'])
             if I == 2 :
                 com = M / 3
                 if com == 0 : i = C
                 for i in range(C-1, C-com-1, -1) :
                     MAP[0][i], MAP[1][i], MAP[2][i] = '*', '*', '*'
                     M -= 3
                 if M >= 1 : MAP[2][i-1] = '*'
                 if M >= 2 :
                     if i != 1 : MAP[2][i-2] = '*'
                     else : MAP[1][0] = '*'
             else :
                 for i in range(C-1, C-M-1, -1) : MAP[I][i] = '*'
                 if i == 1 :
                     MAP[I][i] = '.'
                     MAP[I-1][C-1] = '*'
         res = '\n' + '\n'.join([''.join(i) for i in MAP])
     output = 'Case #' + str(case + 1) + ': ' + str(res)
     g.write(output + '\n')
     print output
 
 f.close()
 g.close()
",62,632,836
"f = open('input.in')
 g = open('output', 'w')
 
 T = int(f.readline()[:-1])
 
 def tot(n) :
     if n == 0 : return X / 2
     else :
         s = 0
         for i in range(0, n) : s += C / (2 + i*F)
         return s + X / (2 + n*F)
 
 for case in xrange(T) :
     C, F, X = map(float, f.readline()[:-1].split())
     N =  int(X/C) + 1
     s, e = 0, N
     if tot(0) >= tot(1) : 
         while True :
             m = (s+e)/2
             if tot(m) <= tot(m-1) and tot(m) <= tot(m+1) : break
             elif tot(m-1) <= tot(m) <= tot(m+1) : e = m
             elif tot(m-1) >= tot(m) >= tot(m+1) : s = m
             else : 1/0
     else : m = 0
     output = 'Case #' + str(case + 1) + ': ' + str(tot(m))
     g.write(output + '\n')
     print output
 
 f.close()
 g.close()
",62,633,340
"(f):
     return next(f).strip()
 
 def read_int(f, b=10):
     return int(read_word(f), b)
 
 def read_letters(f):
     return list(read_word(f))
 
 def read_digits(f, b=10):
     return [int(x, b) for x in read_letters(f)]
 
 def read_words(f, d=' '):
     return read_word(f).split(d)
 
 def read_ints(f, b=10, d=' '):
     return [int(x, b) for x in read_words(f, d)]
 
 def read_floats(f, d=' '):
     return [float(x) for x in read_words(f, d)]
 
 def read_arr(f, R, reader=read_ints, *args, **kwargs):
     return [reader(f, *args, **kwargs) for i in range(R)]
 
 def solve(solver, fn, out_fn=None):
     in_fn = fn + '.in'
     if out_fn is None:
         out_fn = fn + '.out'
     with open(in_fn, 'r') as fi:
         with open(out_fn, 'w') as fo:
             T = read_int(fi)
             for i in range(T):
                 case = read_case(fi)
                 res = solver(case)
                 write_case(fo, i, res)
 
 ################################################################################
 
 def read_case(f):
     R1 = read_int(f)
     Q1 = read_arr(f, 4)
     R2 = read_int(f)
     Q2 = read_arr(f, 4)
     return (R1, Q1, R2, Q2)
 
 def write_case(f, i, res):
     f.write('Case #%d: '%i)
     f.write('%s'%res)
     f.write('\n')
 
 ################################################################################
 
 def solve_small(case):
     (R1, Q1, R2, Q2) = case
     s = set(Q1[R1-1]) & set(Q2[R2-1])
     if len(s) == 0:
         return 'Volunteer cheated!'
     if len(s) == 1:
         return s.pop()
     return 'Bad magician!'
 
 def solve_large(case):
     return solve_small(case)
 
 DEBUG = 'i'
 
 from run import *
",63,634,653
"(f):
     return next(f).strip()
 
 def read_int(f, b=10):
     return int(read_word(f), b)
 
 def read_letters(f):
     return list(read_word(f))
 
 def read_digits(f, b=10):
     return [int(x, b) for x in read_letters(f)]
 
 def read_words(f, d=' '):
     return read_word(f).split(d)
 
 def read_ints(f, b=10, d=' '):
     return [int(x, b) for x in read_words(f, d)]
 
 def read_floats(f, d=' '):
     return [float(x) for x in read_words(f, d)]
 
 def read_arr(f, R, reader=read_ints, *args, **kwargs):
     res = []
     for i in range(R):
         res.append(reader(f, *args, **kwargs))
     return res
 
 def solve(solver, fn, out_fn=None):
     in_fn = fn + '.in'
     if out_fn is None:
         out_fn = fn + '.out'
     with open(in_fn, 'r') as fi:
         with open(out_fn, 'w') as fo:
             T = read_int(fi)
             for i in range(T):
                 case = read_case(fi)
                 res = solver(case)
                 write_case(fo, i, res)
 
 ################################################################################
 
 def read_case(f):
     [N, M] = read_ints(f)
     A = read_arr(f, N)
     return (N, M, A)
 
 def write_case(f, i, res):
     f.write('Case #%d: '%i)
     f.write('%s'%res)
     f.write('\n')
 
 ################################################################################
 
 def solve_small(case):
     (N, M, A) = case
     rows = [max(row) for row in A]
     cols = [max(row[j] for row in A) for j in range(M)]
     for i in range(N):
         for j in range(M):
             if A[i][j] < min(rows[i], cols[j]):
                 return 'NO'
     return 'YES'
 
 def solve_large(case):
     return solve_small(case)
 
 DEBUG = 'i'
 
 from run import *
",63,635,646
"= sys.argv[0]
 __path__ = os.path.dirname(__file__)
 __prob__ = os.path.basename(__path__)
 
 def pout(s, back=0):
     f = sys._getframe(back+1)
     d = 0
     if 'depth' in f.f_locals:
         d = f.f_locals['depth']
     print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))
 
 def perr(s, back=0):
     f = sys._getframe(back+1)
     d = 0
     if 'depth' in f.f_locals:
         d = f.f_locals['depth']
     ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))
 
 def argmin(f, s=None):
     a = f
     if s is None:
         s = range(len(a))
         f = lambda i: a[i]
     res = None
     for x in s:
         y = f(x)
         if res is None or best > y:
             best = y
             res = x
     return res
 
 def argmax(f, s=None):
     a = f
     if s is None:
         s = range(len(a))
         f = lambda i: a[i]
     res = None
     for x in s:
         y = f(x)
         if res is None or best < y:
             best = y
             res = x
     return res
 
 def read_word(f):
     return next(f).strip()
 
 def read_int(f, b=10):
     return int(read_word(f), b)
 
 def read_words(f, d=' '):
     return read_word(f).split(d)
 
 def read_ints(f, b=10, d=' '):
     return [int(x, b) for x in read_words(f, d)]
 
 def read_word_arr(f, R):
     res = []
     for i in range(R):
         res.append(read_word(f))
     return res
 
 def read_ints_arr(f, R, dtype=int, *args, **kwargs):
     res = []
     for i in range(R):
         res.append(read_ints(f, *args, **kwargs))
     return numpy.array(res, dtype)
 
 def solve(solver, fn, start_case=0, end_case=None, out_fn=None):
     global ERR_FILE
     in_fn = fn + '.in'
     if out_fn is None:
         out_fn = fn + '.out'
     err_fn = fn + '.err'
     if start_case == 0:
         append = True
         if os.path.exists(out_fn):
             with open(out_fn, 'r') as f:
                 for l in f:
                     if l[:6] == 'Case #':
                         start_case = int(l[6:l.index(':')])+1
     else:
         append = False
     with open(in_fn, 'r') as fi:
         with open(out_fn, 'a' if append else 'w') as fo:
             with open(err_fn, 'w') as ERR_FILE:
                 T = read_int(fi)
                 for i in range(T):
                     case = read_case(fi)
                     if i+1 < start_case:
                         continue
                     print('Case #%d of %d'%(i+1, T))
                     ERR_FILE.write('Case #%d of %d\n'%(i+1, T))
                     perr('case')
                     res = solver(case)
                     perr('res')
                     write_case(fo, i, res)
                     fo.flush()
                     if end_case is not None and i+1 == end_case:
                         break
 
 def test(start_case=1, end_case=None):
     fn = os.path.join(__path__, 'test')
     solve(solve_small, fn, start_case, end_case)
 
 def small(start_case=1, end_case=None):
     fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)
     solve(solve_small, fn, start_case, end_case)
 
 def small2(start_case=1, end_case=None):
     fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)
     solve(solve_large, fn, start_case, end_case, fn + '2.out')
 
 def large(start_case=0, end_case=None):
     fn = os.path.join(__path__, '%s-large-attempt0'%__prob__)
     solve(solve_large, fn, start_case, end_case)
 
 ################################################################################
 
 def read_case(f):
     (A, B) = read_ints(f)
     return (A, B)
 
 def write_case(f, i, res):
     f.write('Case #%d: '%(i+1))
     f.write('%s'%res)
     f.write('\n')
 
 FAIL = 'NO SOLUTION'
 
 def aux(n, a, b):
     res = 0
     s = set()
     for i in range(1, len(n)):
         m = n[i:]+n[:i]
         if m > n and m >= a and m <= b and m not in s:
             res += 1
             s.add(m)
     return res
 
 def solve_small(case):
     (A, B) = case
     a = str(A)
     b = str(B)
     res = 0
     for n in range(A, B+1):
         res += aux(str(n), a, b)
     return res
 
 solve_large = solve_small
 
 ##perr = pout
 ##pout = lambda s: None
 pout = perr
",63,636,1581
"(f):
     return next(f).strip()
 
 def read_int(f, b=10):
     return int(read_word(f), b)
 
 def read_letters(f):
     return list(read_word(f))
 
 def read_digits(f, b=10):
     return [int(x, b) for x in read_letters(f)]
 
 def read_words(f, d=' '):
     return read_word(f).split(d)
 
 def read_ints(f, b=10, d=' '):
     return [int(x, b) for x in read_words(f, d)]
 
 def read_floats(f, d=' '):
     return [float(x) for x in read_words(f, d)]
 
 def read_arr(f, R, reader=read_ints, *args, **kwargs):
     res = []
     for i in range(R):
         res.append(reader(f, *args, **kwargs))
     return res
 
 def solve(solver, fn, out_fn=None):
     in_fn = fn + '.in'
     if out_fn is None:
         out_fn = fn + '.out'
     with open(in_fn, 'r') as fi:
         with open(out_fn, 'w') as fo:
             T = read_int(fi)
             for i in range(T):
                 case = read_case(fi)
                 res = solver(case)
                 write_case(fo, i, res)
 
 ################################################################################
 
 def read_case(f):
     B = read_arr(f, 4, read_letters)
     read_word(f)
     return B
 
 def write_case(f, i, res):
     f.write('Case #%d: '%i)
     f.write('%s'%res)
     f.write('\n')
 
 ################################################################################
 
 def test(a):
     if '.' not in a and 'O' not in a:
         return 'X won'
     if '.' not in a and 'X' not in a:
         return 'O won'
 
 def solve_small(case):
     draw = True
     for row in case:
         if '.' in row:
             draw = False
         res = test(row)
         if res:
             return res
     for i in range(len(case[0])):
         col = [row[i] for row in case]
         res = test(col)
         if res:
             return res
     diag = [case[i][i] for i in range(len(case))]
     res = test(diag)
     if res:
         return res
     diag = [case[i][-i-1] for i in range(len(case))]
     res = test(diag)
     if res:
         return res
     if draw:
         return 'Draw'
     return 'Game has not completed'
 
 def solve_large(case):
     return solve_small(case)
 
 DEBUG = 'i'
 
 from run import *
",63,637,781
"= sys.argv[0]
 __path__ = os.path.dirname(__file__)
 __prob__ = os.path.basename(__path__)
 
 def pout(s, back=0):
     f = sys._getframe(back+1)
     d = 0
     if 'depth' in f.f_locals:
         d = f.f_locals['depth']
     print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))
 
 def perr(s, back=0):
     f = sys._getframe(back+1)
     d = 0
     if 'depth' in f.f_locals:
         d = f.f_locals['depth']
     ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))
 
 def argmin(f, s=None):
     a = f
     if s is None:
         s = range(len(a))
         f = lambda i: a[i]
     res = None
     for x in s:
         y = f(x)
         if res is None or best > y:
             best = y
             res = x
     return res
 
 def argmax(f, s=None):
     a = f
     if s is None:
         s = range(len(a))
         f = lambda i: a[i]
     res = None
     for x in s:
         y = f(x)
         if res is None or best < y:
             best = y
             res = x
     return res
 
 def read_word(f):
     return next(f).strip()
 
 def read_int(f, b=10):
     return int(read_word(f), b)
 
 def read_words(f, d=' '):
     return read_word(f).split(d)
 
 def read_ints(f, b=10, d=' '):
     return [int(x, b) for x in read_words(f, d)]
 
 def read_word_arr(f, R):
     res = []
     for i in range(R):
         res.append(read_word(f))
     return res
 
 def read_ints_arr(f, R, dtype=int, *args, **kwargs):
     res = []
     for i in range(R):
         res.append(read_ints(f, *args, **kwargs))
     return numpy.array(res, dtype)
 
 def solve(solver, fn, start_case=0, end_case=None, out_fn=None):
     global ERR_FILE
     in_fn = fn + '.in'
     if out_fn is None:
         out_fn = fn + '.out'
     err_fn = fn + '.err'
     if start_case == 0:
         append = True
         if os.path.exists(out_fn):
             with open(out_fn, 'r') as f:
                 for l in f:
                     if l[:6] == 'Case #':
                         start_case = int(l[6:l.index(':')])+1
     else:
         append = False
     with open(in_fn, 'r') as fi:
         with open(out_fn, 'a' if append else 'w') as fo:
             with open(err_fn, 'w') as ERR_FILE:
                 T = read_int(fi)
                 for i in range(T):
                     case = read_case(fi)
                     if i+1 < start_case:
                         continue
                     print('Case #%d of %d'%(i+1, T))
                     ERR_FILE.write('Case #%d of %d\n'%(i+1, T))
                     perr('case')
                     res = solver(case)
                     perr('res')
                     write_case(fo, i, res)
                     fo.flush()
                     if end_case is not None and i+1 == end_case:
                         break
 
 def test(start_case=1, end_case=None):
     fn = os.path.join(__path__, 'test')
     solve(solve_small, fn, start_case, end_case)
 
 def small(start_case=1, end_case=None):
     fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)
     solve(solve_small, fn, start_case, end_case)
 
 def small2(start_case=1, end_case=None):
     fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)
     solve(solve_large, fn, start_case, end_case, fn + '2.out')
 
 def large(start_case=0, end_case=None):
     fn = os.path.join(__path__, '%s-large-attempt0'%__prob__)
     solve(solve_large, fn, start_case, end_case)
 
 ################################################################################
 
 def read_case(f):
     Z = read_ints(f)
     (N, S, p) = Z[:3]
     t = Z[3:]
     return (N, S, p, t)
 
 def write_case(f, i, res):
     f.write('Case #%d: '%(i+1))
     f.write('%s'%res)
     f.write('\n')
 
 FAIL = 'NO SOLUTION'
 
 def solve_small(case):
     (N, S, p, t) = case
     res = 0
     for i in range(N):
         if p >= 2:
             if t[i] >= 3*p-2:
                 res += 1
             elif S > 0 and t[i] >= 3*p-4:
                 res += 1
                 S -= 1
         elif p == 1:
             if t[i] >= 3*p-2:
                 res += 1
         elif p == 0:
             res += 1
     return res
 
 solve_large = solve_small
 
 ##perr = pout
 ##pout = lambda s: None
 pout = perr
",63,638,1589
"(f):
     return next(f).strip()
 
 def read_int(f, b=10):
     return int(read_word(f), b)
 
 def read_letters(f):
     return list(read_word(f))
 
 def read_digits(f, b=10):
     return [int(x, b) for x in read_letters(f)]
 
 def read_words(f, d=' '):
     return read_word(f).split(d)
 
 def read_ints(f, b=10, d=' '):
     return [int(x, b) for x in read_words(f, d)]
 
 def read_floats(f, d=' '):
     return [float(x) for x in read_words(f, d)]
 
 def read_arr(f, R, reader=read_ints, *args, **kwargs):
     res = []
     for i in range(R):
         res.append(reader(f, *args, **kwargs))
     return res
 
 def solve(solver, fn, out_fn=None):
     in_fn = fn + '.in'
     if out_fn is None:
         out_fn = fn + '.out'
     with open(in_fn, 'r') as fi:
         with open(out_fn, 'w') as fo:
             T = read_int(fi)
             for i in range(T):
                 case = read_case(fi)
                 res = solver(case)
                 write_case(fo, i, res)
 
 ################################################################################
 
 def read_case(f):
     return read_ints(f)
 
 def write_case(f, i, res):
     f.write('Case #%d: '%i)
     f.write('%d'%res)
     f.write('\n')
 
 ################################################################################
 
 def aux(A, B, x, s):
     res = 0
     n = int(''.join(x[::-1]+x))
     nn = n*n
     if nn > B:
         return res
     if nn >= A:
         res += 1
     for c in [0, 1, 2]:
         if s + c*c < 10:
             n = int(''.join(x[::-1]+[str(c)]+x))
             nn = n*n
             if nn >= A and nn <= B:
                 res += 1
         if s + 2*c*c < 10:
             res += aux(A, B, [str(c)]+x, s + 2*c*c)
     return res
 
 def solve_small(case):
     [A, B] = case
     res = 0
     for n in [1, 4, 9]:
         if n >= A and n <= B:
             res += 1
     for c in [1, 2]:
         res += aux(A, B, [str(c)], 2*c*c)
     return res
 
 def solve_large(case):
     return solve_small(case)
 
 DEBUG = 'i'
 
 from run import *
",63,639,799
"= sys.argv[0]
 __path__ = os.path.dirname(__file__)
 __prob__ = os.path.basename(__path__)
 
 def pout(s, back=0):
     f = sys._getframe(back+1)
     d = 0
     if 'depth' in f.f_locals:
         d = f.f_locals['depth']
     print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))
 
 def perr(s, back=0):
     f = sys._getframe(back+1)
     d = 0
     if 'depth' in f.f_locals:
         d = f.f_locals['depth']
     ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))
 
 def argmin(f, s=None):
     a = f
     if s is None:
         s = range(len(a))
         f = lambda i: a[i]
     res = None
     for x in s:
         y = f(x)
         if res is None or best > y:
             best = y
             res = x
     return res
 
 def argmax(f, s=None):
     a = f
     if s is None:
         s = range(len(a))
         f = lambda i: a[i]
     res = None
     for x in s:
         y = f(x)
         if res is None or best < y:
             best = y
             res = x
     return res
 
 def read_word(f):
     return next(f).strip()
 
 def read_int(f, b=10):
     return int(read_word(f), b)
 
 def read_words(f, d=' '):
     return read_word(f).split(d)
 
 def read_ints(f, b=10, d=' '):
     return [int(x, b) for x in read_words(f, d)]
 
 def read_word_arr(f, R):
     res = []
     for i in range(R):
         res.append(read_word(f))
     return res
 
 def read_ints_arr(f, R, dtype=int, *args, **kwargs):
     res = []
     for i in range(R):
         res.append(read_ints(f, *args, **kwargs))
     return numpy.array(res, dtype)
 
 def solve(solver, fn, start_case=0, end_case=None, out_fn=None):
     global ERR_FILE
     in_fn = fn + '.in'
     if out_fn is None:
         out_fn = fn + '.out'
     err_fn = fn + '.err'
     if start_case == 0:
         append = True
         if os.path.exists(out_fn):
             with open(out_fn, 'r') as f:
                 for l in f:
                     if l[:6] == 'Case #':
                         start_case = int(l[6:l.index(':')])+1
     else:
         append = False
     with open(in_fn, 'r') as fi:
         with open(out_fn, 'a' if append else 'w') as fo:
             with open(err_fn, 'w') as ERR_FILE:
                 T = read_int(fi)
                 for i in range(T):
                     case = read_case(fi)
                     if i+1 < start_case:
                         continue
                     print('Case #%d of %d'%(i+1, T))
                     ERR_FILE.write('Case #%d of %d\n'%(i+1, T))
                     perr('case')
                     res = solver(case)
                     perr('res')
                     write_case(fo, i, res)
                     fo.flush()
                     if end_case is not None and i+1 == end_case:
                         break
 
 def test(start_case=1, end_case=None):
     fn = os.path.join(__path__, 'test')
     solve(solve_small, fn, start_case, end_case)
 
 def small(start_case=1, end_case=None):
     fn = os.path.join(__path__, '%s-small-practice'%__prob__)
     solve(solve_small, fn, start_case, end_case)
 
 def small2(start_case=1, end_case=None):
     fn = os.path.join(__path__, '%s-small-practice'%__prob__)
     solve(solve_large, fn, start_case, end_case, fn + '2.out')
 
 def large(start_case=0, end_case=None):
     fn = os.path.join(__path__, '%s-large-practice'%__prob__)
     solve(solve_large, fn, start_case, end_case)
 
 ################################################################################
 
 def read_case(f):
     G = read_word(f)
     return G
 
 def write_case(f, i, res):
     f.write('Case #%d: '%(i+1))
     f.write('%s'%res)
     f.write('\n')
 
 FAIL = 'NO SOLUTION'
 
 TRANS = {'z': 'q', 'q': 'z', '\n': '\n', ' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm'}
 
 def solve_small(case):
     G = case
     return ''.join(TRANS[x] for x in G)
 
 solve_large = solve_small
 
 ##perr = pout
 ##pout = lambda s: None
 pout = perr
",63,640,1619
"(f):
     return next(f).strip()
 
 def read_int(f, b=10):
     return int(read_word(f), b)
 
 def read_letters(f):
     return list(read_word(f))
 
 def read_digits(f, b=10):
     return [int(x, b) for x in read_letters(f)]
 
 def read_words(f, d=' '):
     return read_word(f).split(d)
 
 def read_ints(f, b=10, d=' '):
     return [int(x, b) for x in read_words(f, d)]
 
 def read_floats(f, d=' '):
     return [float(x) for x in read_words(f, d)]
 
 def read_arr(f, R, reader=read_ints, *args, **kwargs):
     return [reader(f, *args, **kwargs) for i in range(R)]
 
 def solve(solver, fn, out_fn=None):
     in_fn = fn + '.in'
     if out_fn is None:
         out_fn = fn + '.out'
     with open(in_fn, 'r') as fi:
         with open(out_fn, 'w') as fo:
             T = read_int(fi)
             for i in range(T):
                 case = read_case(fi)
                 res = solver(case)
                 write_case(fo, i, res)
 
 ################################################################################
 
 def read_case(f):
     return read_ints(f)
 
 def write_case(f, i, res):
     f.write('Case #%d: '%i)
     if isinstance(res, list):
         res[0][0] = 'c'
         res = '\n'.join(''.join(c for c in r) for r in res)
     f.write('\n%s'%res)
     f.write('\n')
 
 ################################################################################
 
 def solve_small(case):
     (R, C, M) = case
     if R == 1:
         return 'c' + '.'*(C-M-1) + '*'*M
     if C == 1:
         return '\n'.join(['c'] + ['.']*(R-M-1) + ['*']*M)
     m = R*C - M
     res = [['*']*C for r in range(R)]
     if m == 1:
         return res
     for r in range(2, R+1):
         c = m // r
         z = m % r
         if c < 2 or c + (z>0) > C:
             continue
         if z == 1 and (r < 3 or c < 3):
             continue
         for x in range(r):
             for y in range(c):
                 res[x][y] = '.'
         for y in range(z):
             res[y][c] = '.'
         if z == 1:
             res[z][c] = '.'
             res[r-1][c-1] = '*'
         return res
     return 'Impossible'
 
 def solve_large(case):
     return solve_small(case)
 
 DEBUG = 'f'
 
 from run import *
",63,641,833
"(f):
     return next(f).strip()
 
 def read_int(f, b=10):
     return int(read_word(f), b)
 
 def read_letters(f):
     return list(read_word(f))
 
 def read_digits(f, b=10):
     return [int(x, b) for x in read_letters(f)]
 
 def read_words(f, d=' '):
     return read_word(f).split(d)
 
 def read_ints(f, b=10, d=' '):
     return [int(x, b) for x in read_words(f, d)]
 
 def read_floats(f, d=' '):
     return [float(x) for x in read_words(f, d)]
 
 def read_arr(f, R, reader=read_ints, *args, **kwargs):
     return [reader(f, *args, **kwargs) for i in range(R)]
 
 def solve(solver, fn, out_fn=None):
     in_fn = fn + '.in'
     if out_fn is None:
         out_fn = fn + '.out'
     with open(in_fn, 'r') as fi:
         with open(out_fn, 'w') as fo:
             T = read_int(fi)
             for i in range(T):
                 case = read_case(fi)
                 res = solver(case)
                 write_case(fo, i, res)
 
 ################################################################################
 
 def read_case(f):
     return read_floats(f)
 
 def write_case(f, i, res):
     f.write('Case #%d: '%i)
     f.write('%s'%res)
     f.write('\n')
 
 ################################################################################
 
 def solve_small(case):
     (C, F, X) = case
     res = 0
     i = 0
     while X/(2 + i*F) > C/(2 + i*F) + X/(2 + (i+1)*F):
         res += C/(2 + i*F)
         i += 1
     return res + X/(2 + i*F)
 
 def solve_large(case):
     return solve_small(case)
 
 DEBUG = 'i'
 
 from run import *
",63,642,595
"directory = 'C:/users/me/desktop/google code jam/2014/qualification/A/'
 
 
 
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         
         c1 = int(f_in.readline())
         l1 = []
         for i in range(4):
             l1.append(f_in.readline())
         
         c2 = int(f_in.readline())
         l2 = []
         for i in range(4):
             l2.append(f_in.readline())
 
         d1 = l1[c1-1].split()
         d2 = l2[c2-1].split()
 
         foundFlag = False
         chosenCard = None
         badMagician = False
         for card in d1:
             if card in d2:
                 if not foundFlag:
                     foundFlag = True
                     chosenCard = card
                 else:
                     badMagician = True
 
         f_out.write('Case #' + str(testcase) + ': ')
         if badMagician:
             f_out.write('Bad magician!\n')
         elif not foundFlag:
             f_out.write('Volunteer cheated!\n')
         else:
             f_out.write(chosenCard + '\n')
 
 
 
 
 def main_run():
     = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
",64,643,591
"directory = 'C:/users/hai/my projects/google code jam/2013/qualification/B/'
 
 
 (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         print (testcase)
         N,M = [int(x) for x in f_in.readline().split()]
         sqr = []
         for i in range(N):
             sqr.append([int(x) for x in f_in.readline().split()])
         res = get_result(sqr)
         f_out.write('Case #' + str(testcase) + ': ' + res + '\n')
 
 
 def get_result (sqr):
     while len(sqr) > 1 and len(sqr[0]) > 1:
         print (sqr)
         r,c = 0,0
         for row in range(len(sqr)):
             for col in range(len(sqr[0])):
                 if sqr[row][col] < sqr[r][c]:
                     r,c = row, col
         min_val = sqr[r][c]
         whole_row = list(sqr[r])
         whole_col = []
         for row in range(len(sqr)):
             whole_col.append(sqr[row][c])
         assert min(whole_row) == min_val
         assert min(whole_col) == min_val
         if max(whole_row) == min_val:
             sqr = remove_row(sqr,r)
         elif max(whole_col) == min_val:
             sqr = remove_col(sqr,c)
         else:
             return 'NO'
 
     return 'YES'
     
 
 
 
 
 
 def remove_row (sqr, row):
     cpy = deepcopy(sqr)
     del cpy[row]
     return cpy
 
 def remove_col (sqr,col):
     cpy = deepcopy(sqr)
     for row in cpy:
         del row[col]
     return cpy
 
 
 
 
 
 def main_run():
     = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
",64,644,783
"directory = 'C:/users/hai/my projects/google code jam/2012/qualification/C/'
 
 
 def solve (f_in, f_out):
     pre_calc = prepare()
     T = int(f_in.readline())
     for i in range(1,T+1):
         A,B = [int(x) for x in f_in.readline().split()]
         c = 0
         for m in range(A,B+1):
             c += len ([n for n in pre_calc[m] if n >=A])
         f_out.write('Case #' + str(i) + ': ' + str(c) + '\n')
 
 
 
 
 
 
 def prepare ():
     l = [None]* 2000001
     for n in range(1,2000001):
         recycled = []
         s = str(n)
         for c in range(1, len(s)):
             s2 = s[c:] + s[:c]
             if s2[0] != '0':
                 n2 = int(s2)
                 if n2 < n and n2 not in recycled:
                     recycled.append(n2)
         #recycled.sort()
         l [n] = recycled
     return l
 
 
 def main_run():
     = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
",64,645,572
"directory = 'C:/users/hai/my projects/google code jam/2013/qualification/A/'
 
 
 def solve (f_in, f_out):
     N = int(f_in.readline())
     for testcase in range(1,N+1):
         sqr = []
         for i in range(4):
             sqr.append(list(f_in.readline().split()[0]))
         assert len(f_in.readline().split()) == 0
 
         f_out.write('Case #' + str(testcase) + ': ' + get_square_winner(sqr) +'\n')
     
 
 def get_all_lines(sqr):
     lines = []
     for line in sqr:
         lines.append(list(line))
     for column in range(4):
         line = []
         for row in range(4):
             line.append(sqr[row][column])
         lines.append(list(line))
 
     diag1 = []
     diag2 = []
     for  i in range(4):
         diag1.append(sqr[i][i])
         diag2.append(sqr[i][3-i])
     lines.append(diag1)
     lines.append(diag2)
 
     return lines
     
 def get_square_winner (sqr):
     for line in get_all_lines(sqr):
         if get_line_winner (line):
             return get_line_winner (line)
 
     for row in sqr:
         if '.' in row:
             return ""Game has not completed""
     return ""Draw""
 
 
 
 
 def get_line_winner (line):
     if line.count('X') == 4:
         return ""X won""
     if line.count('X') == 3 and 'T' in line:
         return ""X won""
     
     if line.count('O') == 4:
         return ""O won""
     if line.count('O') == 3 and 'T' in line:
         return ""O won""
 
 
     return None
 
 
 
 
 
 
 
 def main_run():
     = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
",64,646,779
"directory = 'C:/users/hai/my projects/google code jam/2012/qualification/B/'
 
 
 def solve (f_in, f_out):
     T = int(f_in.readline())
     print ('Test cases : ',T)
     for i in range(1,T+1):
         line = f_in.readline()
         nnn = [int(x) for x in line.split()]
         S = nnn[1]
         p = nnn[2]
         t = nnn[3:]
         if p > 1:
             A = 0
             B = 0
             for t_i in t:
                 if t_i >=3*p-2:
                     A += 1
                 elif t_i >= 3*p-4:
                     B += 1
             result = A + min(B,S)
         if p == 1:
             result = len([x for x in t if x>=1])
         if p == 0:
             result=  len(t)
         f_out.write('Case #' + str(i) + ': ' + str(result) + '\n')
 
 
 
 
 
 
 
 
 
 
 def main_run():
     = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
 
 
 
 main_run()
",64,647,509
"directory = 'C:/users/me/desktop/google code jam/2014/qualification/D/'
 
 = 501
 DECREASING = 502
 NO_ORDER = 503
 
 def play_war (l_n, l_k, inc_val):
     assert inc_val in [INCREASING, DECREASING, NO_ORDER]
     assert len(l_n) == len(l_k)
     if inc_val == INCREASING:
         l_n = list(sorted(l_n))
     if inc_val == DECREASING:
         l_n = list(reversed(sorted(l_n)))
     l_k = list(sorted(l_k))
     naomi_wins = 0
     for i in range(len(l_n)):
         val = l_n[0]
         l_n = l_n[1:]
         if l_k[-1] < val:
             l_k = l_k[1:]
             naomi_wins += 1
         else:
             for j in range(len(l_k)):
                 if l_k[j] > val:
                     del l_k[j]
                     break
 
     return naomi_wins
 
 
 def play_deceitful (l_n, l_k):
     l_n = list(sorted(l_n))
     l_k = list(sorted(l_k))
     naomi_wins = 0
     assert len(l_n) == len(l_k)
     while len(l_n):
         if l_n[-1] < l_k[-1]:
             l_n = l_n[1:]
             l_k = l_k[:-1]
         else:
             l_n = l_n[:-1]
             l_k = l_k[:-1]
             naomi_wins += 1
     return naomi_wins
             
             
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         N = int(f_in.readline())
         l_n = [float(x) for x in f_in.readline().split()]
         l_k = [float(x) for x in f_in.readline().split()]
 
         a1 = play_war (l_n, l_k, INCREASING)
         a2 = play_war (l_n, l_k, DECREASING)
         a3 = play_war (l_n, l_k, NO_ORDER)
         assert a1 == a2
         assert a2 == a3
         b = play_deceitful (l_n, l_k)
 
         f_out.write('Case #' + str(testcase) + ': ' + str(b) + ' ' + str(a1) + '\n')
 
 
         
         
 
     
 def main_run():
     = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
 
 def randomize_arrs (n):
     l = []
     for i in range(2*n):
         r = choice(range(2**30))
         while r in l:
             r = choice(range(2**30))
         l.append(r)
     return l[:n], l[n:]
 
",64,648,1061
"directory = 'C:/users/hai/my projects/google code jam/2012/qualification/A/'
 
 
 t= '''ay
 bh
 ce
 ds
 eo
 fc
 gv
 hx
 id
 ju
 ki
 lg
 ml
 nb
 ok
 pr
 qz
 rt
 sn
 tw
 uj
 vp
 wf
 xm
 ya
 zq'''
 
 table = {}
 for line in t.split():
     table[line[0]] = line[1]
 
 def translate (line):
     l = list(line)
     for i in range(len(l)):
         if l[i] in table:
             l[i] = table[l[i]]
     return ''.join(l)
 
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for i in range(1,T+1):
         line = f_in.readline()
         out_line = translate(line)
         f_out.write('Case #' + str(i) + ': ' + out_line)
 
 
 
 
 
 
 
 
 
 
 def main_run():
     = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
 
 
 
 main_run()
",64,649,496
"directory = 'C:/users/me/desktop/google code jam/2014/qualification/C/'
 
 (R,C,M):
         l = []
         for i in range(R):
             for j in range(C):
                 l.append((i,j))
 
         empty_mat = []
         for i in range(R):
             empty_mat.append(['.']*C)
 
         found = False
 
         assert (0,0) in l
         l = l[1:]
         l = l[::-1]
         assert (0,0) not in l
         
         output = ''
         
         for mine_placement in itertools.combinations(l,M):
             mat = deepcopy(empty_mat)
             for cell in mine_placement:
                 mat[cell[0]][cell[1]] = '*'
             if isOneClick(mat, R, C, M):
                 mat[0][0] = 'c'
                 for line in mat:
                     output += ''.join(line) + '\n'
                 found = True
                 return output
             
         if not found:
             return 'Impossible\n'
         
         assert ValueError()
         
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         line = f_in.readline()
         R,C,M = [int(q) for q in line.split()]
         print (testcase,R,C,M)
 
         output = solve_one_case (R,C,M)
         f_out.write('Case #' + str(testcase) + ':\n')
         f_out.write(output)
 
         
 
 
 def isOneClick (mat, R, C, M):
 ##    if mat[0][0] != '.':
 ##        return False
 ##    assert len(mat) == R
 ##    lens = [len(l) for l in mat]
 ##    assert min(lens) == C
 ##    assert max(lens) == C
 ##    assert sum([l.count('*') for l in mat]) == M
 
     mat_cpy = deepcopy(mat)
     oneclickcells = [(0,0)]
     while oneclickcells:
         node = oneclickcells.pop()
         mat_cpy[node[0]][node[1]] = 'v'
         if noNearbyMines(mat_cpy,node):
             oneclickcells.extend(getNearbyUnvisited(mat_cpy, node))
 
     #print (mat_cpy)
     return sum([l.count('.') for l in mat_cpy]) == 0
     
 
 def getNearbyUnvisited(mat, node):
     R = len(mat)
     C = len(mat[0])
     deltas_r = [0]
     deltas_c = [0]
     if node[0] > 0:
         deltas_r.append(-1)
     if node[1] > 0:
         deltas_c.append(-1)
     if node[0] < R-1:
         deltas_r.append(1)
     if node[1] < C-1:
         deltas_c.append(1)
 
     ret_list = []
     for delta_r in deltas_r:
         for delta_c in deltas_c:
             next_node = (node[0]+delta_r, node[1] + delta_c)
             if mat[next_node[0]][next_node[1]] not in ['*','v']:
                 ret_list.append((next_node[0],next_node[1]))
 
     return ret_list
 
 def noNearbyMines(mat,node):
     R = len(mat)
     C = len(mat[0])
     deltas_r = [0]
     deltas_c = [0]
     if node[0] > 0:
         deltas_r.append(-1)
     if node[1] > 0:
         deltas_c.append(-1)
     if node[0] < R-1:
         deltas_r.append(1)
     if node[1] < C-1:
         deltas_c.append(1)
 
     for delta_r in deltas_r:
         for delta_c in deltas_c:
             if mat[node[0] + delta_r][node[1] + delta_c] == '*':
                 return False
     return True
     
 def main_run():
     = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
 
 ##bads = []
 ##goods = []
 ##
 ##for R in range(1,6):
 ##    for C in range(1,6):
 ##        for M in range(1,R*C+1):
 ##            print (R,C,M)
 ##            output = solve_one_case (R,C,M)
 ##            if output[0] == 'I':
 ##                bads.append((R,C,M))
 ##            else:
 ##                goods.append((R,C,M))
 ##
",64,650,1519
"directory = 'C:/users/me/desktop/google code jam/2014/qualification/B/'
 
 
 
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         line = f_in.readline()
         C,F,X = [float(q) for q in line.split()]
         result = compute (C,F,X)
         f_out.write('Case #' + str(testcase) + ': ' + str(result) + '\n')
 
 
 def compute(C,F,X):
     cps = 2
     farms = 0
     timespent = 0
     while X / cps > C/cps + X/(cps+F):
         farms += 1
         timespent += C/cps
         cps += F
 
     return timespent + X/cps
 
 
 
 
 
 def main_run():
     = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
",64,651,478
"'''
 Created on Apr 11, 2014
 
 @author: mostasem
 '''
 
 
 
 def getIntersection(A,B):
     intersect_list = []
     dict = {};
     for i in range(4):
         if(dict.get(A[i]) <> None):
             dict[A[i]] += 1
             if(intersect_list.count(A[i]) == 0):
                 intersect_list.append(A[i])
         else:
             dict[A[i]] = 1
         if(dict.get(B[i]) <> None):
             dict[B[i]] += 1
             if(intersect_list.count(B[i]) == 0):
                 intersect_list.append(B[i])
         else:
             dict[B[i]] = 1
 
     return intersect_list
 
 f_r = open('A.in',""r"")
 n_test=int(f_r.readline().strip()) 
 f_w = open(""A.out"", ""w"")
 result = """"
 for i in range(n_test):
     cards1 = []
     row_index_1 = int(f_r.readline()) - 1
     for j in range(4):
         cards1.append(map(int,f_r.readline().split()))
     cards2 = []
     row_index_2 = int(f_r.readline()) - 1
     for j in range(4):
         cards2.append(map(int,f_r.readline().split())) 
 #     print cards1 
 #     print cards2
 #     print cards1[row_index_1] ,cards2[row_index_2]
     int_list =  getIntersection(cards1[row_index_1], cards2[row_index_2])
 #     print int_list
     result = """"
     if(len(int_list) == 0):
         result = ""Volunteer cheated!""
     elif(len(int_list)  == 1):
         result = str(int_list[0])
     else:
         result = ""Bad magician!""
     output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)
     print output_str
     f_w.write(output_str+'\n')
 f_r.close()
 f_w.close()",65,652,593
"'''
 Created on Apr 12, 2013
 
 @author: Moatasem
 '''
 
 (max_,start,end,marked,isRow,lawn):
     for i in range(end):
             if(isRow):
                 if( lawn[start][i]==max_):
                     marked[start][i]=-1
             else: 
                 if( lawn[i][start]==max_):
                     marked[i][start]=-1
                     
                 
     
     
 def mowerLawn(lawn,m,n,marked):
     #marked= [[0] *n]*m
     for i in range(m):
         max_=max(lawn[i])
         markMax(max_,i,n,marked,True,lawn) 
     
     for i in range(n):
         colList=[]
         for j in range(m):
             colList.append(lawn[j][i])
         max_=max(colList)
         markMax(max_,i,m,marked,False,lawn) 
            
     done=True
     for i in range(m):
         for j in range(n):
             if(marked[i][j]!=-1):
                 done=False
                 break
         if(not done):
             break
     if(done):
         return 'YES'
     else:
         return 'NO'
     
         
     
 
 f_r = open('B.in',""r"")
 n_test=int(f_r.readline().strip()) 
 f_w = open(""B.out"", ""w"")
 for i in range(n_test):
     lawn=[]
     
     range_ =map(int,f_r.readline().split())
     #marked= [[0] *range_[1]]*range_[0]
     marked=[[0]*range_[1] for x in xrange(range_[0])]
     for j in range(range_[0]):
         temp=[map(int,f_r.readline().split())]
         lawn.extend(temp)
     result=mowerLawn(lawn,range_[0],range_[1],marked)
     output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)
     f_w.write(output_str+'\n')
 f_r.close()
 f_w.close()",65,653,607
"'''
 Created on Apr 14, 2012
 
 @author: moatasem
 '''
 
 def getNumRecycle(n,A,B,h):
         c=0
         x=list(str(n))
         for i in xrange(1,len(x)):
             t1="""".join(x[0:i])
             t2="""".join(x[i:len(x)])
             num=int(t2+t1)
             if((num>=A and num<=B) and num<>n and h.get((num,n))==None and h.get((n,num))==None):
                 #print ""("",str(n),"","",str(num),"")""
                 h[(num,n)]=0;
                 c+=1
         return c
     
     
 f = open(""C-small-attempt0.in"", ""r"")
 n=int(f.readline().strip())
 for k  in xrange(n):
     d=f.readline().strip()
     A,B=[int(i) for i in d.split("" "")]
     count=0
     h={}
     for j in range(A,B+1):
         count+= getNumRecycle(j,A,B,h)
     print 'Case #'+str((k+1))+"": ""+str(count)",65,654,328
"'''
 Created on Apr 12, 2013
 
 @author: Moatasem
 '''
 
 def getStatus(board):
     status="""" 
     solved=False
     n_dotted=0
     #checking for columns and rows
     for i in range(4):
         result= checkBoard(board[i])
         if(result!=""None""):
             status=result
             solved=True
         else:
             columnlist=[]
             for j in range(4):
                 if(board[i][j]=='.'):
                     n_dotted+=1
                 columnlist.append(board[j][i])
             result= checkBoard(columnlist)
             if(result!=""None""): 
                 solved=True
                 status=result
                 break
         if(solved):
             break
         
     #checking for diagonals
     result_l=checkBoard([board[x][x] for x in range(4)]) #leftDiagonal
     result_r=checkBoard([board[0][3],board[1][2],board[2][1],board[3][0]]) #rightDiagonal
     if(result_l!=""None""): 
             solved=True
             status=result_l
     if(result_r!=""None""): 
             solved=True
             status=result_r
                 
     if(solved==False):
         if(n_dotted==0):
             status=""Draw""
         else: 
             status=""Game has not completed""   
 
     return status
 
 
 def checkBoard(board):
         status=""None""
         x_count=board.count('X')
         o_count=board.count('O')
         t_count=board.count('T')
         if(x_count==4 or (x_count==3 and t_count==1)):
             status=""X won""
         elif(o_count==4 or (o_count==3 and t_count==1)):
             status=""O won""
         return status
 
 
 f_r = open('A.in',""r"")
 n_test=int(f_r.readline().strip()) 
 
 f_w = open(""A.out"", ""w"")
 for i in range(n_test):
     board=[]
     for j in range(4):
         board.append(f_r.readline().strip())
     result= getStatus(board)
     output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)
     f_w.write(output_str+'\n')
     f_r.readline()
 f_r.close()
 f_w.close()
",65,655,662
"'''
 Created on Apr 14, 2012
 
 @author: moatasem
 '''
 
 
 def isSurprising(t):
     if(abs(t[0]-t[1])==2 or abs(t[2]-t[1])==2 or abs(t[0]-t[2])==2):
         return True
     else:
         return False
 
 
 def getAllTriplets(n):
     h=[]
     for i in xrange(11):
         for j in xrange(i,11):
             for  k in xrange(j,11):
                 if(i+j+k==n and abs(i-j)<3 and abs(k-j)<3 and abs(i-k)<3):
                     h.append((i,j,k))
             
     return  h
 
 def getInfo(p,total,S):
     g= getAllTriplets(total)
     #print total
     #print g
     if(S):
         s_=len(g)
         indcies=[]
         for i in xrange (s_):
             if(isSurprising(g[i])):
                 indcies.append(i)
         for i in xrange (len(indcies)):  
             g.remove(g[indcies[i]])
     #print g
     equ=False
     sur=False
     sur_equ=False
     for i in xrange(len(g)):
         if(max(g[i])>=p):
             if(isSurprising(g[i])):
                 #print g[i]
                 sur_equ=True
             else:
                 equ=True
         elif(isSurprising(g[i])):
                 sur=True
     return sur_equ,equ,sur
            
 f = open(""b_.in"", ""r"")
 n=int(f.readline().strip())
 for k  in xrange(n):
     d=f.readline().strip()
     googlers=[]
     g=[int(i) for i in d.split("" "")]
     N=g[0]
     S=g[1]
     noSu=False
     if(S==0):
         noSu=True
     p=g[2]
     count=0
     equ_count=0;
     both_count=0;
     sur_count=0;
     first_count=0;
     googlers=g[3:len(g)]
     for o in xrange(N):
         info=getInfo(p,googlers[o],noSu)
         #print info
         if(info[0]==True and info[1]==False and S<>0): #101 /100
             count+=1
             S-=1
         elif(info[0]==True and info[1]==True):#110 / 111
             first_count+=1
         elif(info[1]==True and info[2]==True):#011
             both_count+=1
         elif(info[1]==True):#010
             count+=1
         elif(info[2]==True):#001
             sur_count+=1
     count+=first_count
     if(S>0):
         if(first_count>S):
             S=0
         elif(first_count <=S) :
             S-=first_count
             if(S>0):
                  if(both_count>S):
                     both_count-=S
                     S=0
                  else:
                     both_count=0
     count+=both_count
     
     print 'Case #'+str((k+1))+"": ""+str(count)
 
 
 
 
 
 
 
 
 
 
     
 
 #f=getAllTriplets(18)
 #print f
 #for i in xrange(len(f)):
 #    print isSurprising(f[i])",65,656,980
"'''
 Created on Apr 11, 2014
 
 @author: mostasem
 '''
 def solveWar(Naomi, Ken):
     NPoints = 0
     while(len(Naomi) <> 0):
         Nmax = max(Naomi)
         Kmax = max(Ken)
         Kmin = min(Ken)
         if(Nmax > Kmax):
             NPoints += 1
             Naomi.remove(Nmax)
             Ken.remove(Kmin)
         else:
             Naomi.remove(Nmax)
             Ken.remove(Kmax)
     return NPoints
 
 
 def getKeyWithMaxValue(dict_):
  
     keys = dict_.keys()
     currentKey = 0.0
     min_val = 10000000000000000
     for i in range(len(keys)): 
         if(min_val > dict_.get(keys[i])):
             min_val = dict_.get(keys[i])
             currentKey = keys[i]
         elif(min_val == dict_.get(keys[i])):
             if(currentKey > keys [i]):
                 currentKey = keys[i]
             
     return currentKey
 
         
 def updateWeights(Naomi, Ken):  
     NaomiHash = {}     
     for i in range(len(Naomi)):
         if(NaomiHash.get(Naomi[i]) == None):
                 NaomiHash[Naomi[i]] = 0
         for j in range(len(Ken)):
             if(Naomi[i] > Ken [j]):
                     NaomiHash[Naomi[i]] += 1
     return NaomiHash
 
 
 def checkIFAllBigger(NaomiHash,Ken):
     k = len(Ken)
     allBigger = True
     values = list(NaomiHash.values());
     for i in range(k):
         found = False
         for j in range(len(values)):
             if(values [j] >= k - i):
                 #print values
                 values.remove(values[j])
                 found = True
                 break
         if(not found):
             allBigger = False
             break
     return allBigger
 
 def solveDecitfulWar(Naomi, Ken):
     NPoints = 0
     NaomiHash = updateWeights(Naomi, Ken)
     while(len(Naomi) <> 0):
         #print NaomiHash
         #print ""Ken"",len(Ken)
         if(checkIFAllBigger(NaomiHash,Ken)):
             NPoints += len(Ken)
             break
         NChoice = getKeyWithMaxValue(NaomiHash)
         print NChoice
         Kmax = max(Ken)
         Kmin = min(Ken)
         if(NChoice > Kmax):
             NPoints += 1
             Naomi.remove(NChoice)
             NaomiHash[NChoice] = 10000000000000000
             Ken.remove(Kmin)
         else:
             Naomi.remove(NChoice)
             NaomiHash[NChoice] = 10000000000000000
             Ken.remove(Kmax)
         NaomiHash = updateWeights(Naomi, Ken)
         
     return NPoints
 
 
  
 f_r = open('D.in',""r"")
 n_test=int(f_r.readline().strip()) 
 f_w = open(""D.out"", ""w"")
 result = """"
 for i in range(n_test):
     list_len = int(f_r.readline().strip()) 
     Naomi = map(float,f_r.readline().split())
     Ken = map(float,f_r.readline().split())
     
     Naomi2 = list(Naomi)
     Ken2 = list(Ken)
     #print Naomi ,Ken
     p1 =  solveWar(Naomi, Ken)
     p2 =  solveDecitfulWar(Naomi2, Ken2)
     result = str(p2)+"" ""+str(p1)
     #print result
     output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)
     f_w.write(output_str+'\n')
     
 f_r.close()",65,657,1095
"'''
 Created on Apr 12, 2013
 
 @author: Moatasem
 '''
 
 (word):
     isPalin=False
     if(len(word)%2==0):
         f_half=word[0:len(word)/2];
         s_half=word[len(word)/2:len(word)][::-1]
         if( f_half==s_half):
             isPalin= True
     else:
         f_half=word[0:len(word)/2]
         s_half=word[(len(word)/2)+1:len(word)][::-1]
         if( f_half==s_half):
             isPalin= True
     return isPalin
     
 def getNumberOfFairAndSquare(range_):
     start=range_[0]
     end=range_[1]
     count_=0
     for i in range(start,end+1):
         root=math.sqrt(i);
         if(root.is_integer() and isPalindrome(str(int(root))) and isPalindrome(str(i))):
             count_+=1
     return count_
         
         
     
 
 f_r = open('C.in',""r"")
 n_test=int(f_r.readline().strip()) 
 f_w = open(""C.out"", ""w"")
 for i in range(n_test):
     range_ =map(int,f_r.readline().split())
     result=getNumberOfFairAndSquare(range_)
     output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)
     f_w.write(output_str+'\n')
 f_r.close()
 f_w.close()",65,658,442
"'''
 Created on Apr 12, 2014
 
 @author: mostasem
 '''
 
 (m):
     r1 = -1 + math.sqrt(1 + (8 * m))/2
     r2 = -1 - math.sqrt(1 + (8 * m))/2
     return int(math.floor(r1))
     
 def boardHasZero(R,C,M):
     if(R > 1 and C > 1):
         S = M/C
         Sr = M % C
         print S,Sr
         return R >= S+3 or (R == S+2 and ((Sr % 2) == 0 or (((C + Sr) % 3 == 0) and (2*C >= (C + Sr + 4))))) or (R == S+1  and (C + Sr) % 2 == 0 and (2*C >= (C + Sr + 4)))  #M <= ((R*C) - 4)
     else :
         return M <= ((R*C) - 2)
 
 
 def generateMineSweeperCase(R,C,M):
 
     board = """"
 
     if( R > 1 and C > 1 ): # generate special
         S = M/C
         Sr = M % C
         print S,Sr
         if(S): # all rows of *
             board +=""\n""
             if(R >= S+3 or (R == S+2 and Sr % 2 == 0)):
                 board += (S - 1) * ((C*""*"") + ""\n"")
             else:
                 board += (S - 2) * ((C*""*"") + ""\n"")
             board +=  ((C*""*""))
             
         if(R >= S+3):
             if(Sr):
                 board +=""\n""
                 board += ((Sr *""*"") + ((C - Sr) *"".""))
             Rm = R - (S + 1)
             if(Rm):
                 board +=""\n""
                 board += (Rm - 1) * ((C*""."") + ""\n"")
                 board +=  ((C*"".""))
                 
         elif(R == S + 2):
             Sm = 0
             if(Sr % 2 == 0):
                 board +=""\n""
                 board += (((Sr / 2) *""*"") + ((C - (Sr / 2)) *""."") +""\n"")
                 board += ((Sr / 2) *""*"") + ((C - (Sr / 2)) *""."")
             else:
                 board +=""\n""
                 board += (((Sr / 3) *""*"") + ((C - (Sr / 3)) *""."") +""\n"")
                 board += ((Sr / 3) *""*"") + ((C - (Sr / 3)) *""."")
         else :
             Sm = Sr + C
             board +=""\n""
             board += (((Sm / 2) *""*"") + ((C - (Sm / 2)) *""."") +""\n"")
             board += ((Sm / 2) *""*"") + ((C - (Sm / 2)) *""."")
                 
         list_board = list(board)
         list_board[len(list_board) - 1] = 'c'
         board = """".join(list_board)
     else:
         board +=""\n""
         if(C == 1):
             board += M * ""*\n""
             board += (R-M-1) * "".\n""
             board +=  ""c""
         else:
             board += M * ""*""
             board += (C-M-1) * "".""
             board += ""c""
             
     return board
        
        
        
 
 f_r = open('C.in',""r"")
 n_test=int(f_r.readline().strip()) 
 f_w = open(""C.out"", ""w"")
 result = """"
 for i in range(n_test):
     R,C,M = map(int,f_r.readline().split())
     print R,C,M
     if(boardHasZero(R,C,M)):
         result = generateMineSweeperCase(R,C,M)
     else :
         result =""\nImpossible""
     print result
     output_str='Case #{itr}:{res}'.format(itr=(i+1),res=result)
     f_w.write(output_str+'\n')
     
 f_r.close()",65,659,1122
"'''
 Created on Apr 11, 2014
 
 @author: mostasem
 '''
 
 
 def getSeconds(C,F,X):
     seconds = 0.0
     cookie_rate = 2
     solved =False
     while (not solved):
         choice1 = X/cookie_rate
         choice2 = C/cookie_rate + X/(cookie_rate + F)
         if(choice1 < choice2):
             seconds += choice1
             solved = True
         else :
             seconds += C/cookie_rate
             cookie_rate += F
     
     return seconds
 
 f_r = open('B.in',""r"")
 n_test=int(f_r.readline().strip()) 
 f_w = open(""B.out"", ""w"")
 result = """"
 for i in range(n_test):
     C,F,X = map(float,f_r.readline().split())
     seconds = getSeconds(C,F,X)
     result = str(seconds)
     output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)
     f_w.write(output_str+'\n')
     
 f_r.close()
 f_w.close()
 
",65,660,311
