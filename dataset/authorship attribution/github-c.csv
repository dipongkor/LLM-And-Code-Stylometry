code,author,id,tokens
"int LongestConsecutive(int arr[],int size , int element){
    int max_consec = 0;
    int count = 0;
    int i;
    int ahead , current;
    
    for(i = 0; i < size ; i++){

        ahead = arr[i+1];
        current = arr[i];

        
        if(arr[i] == element){
            count++;

            
            if(count > max_consec){
                max_consec = count;
            }
        }

        
        if( ahead != current){
            count = 0;
        }
    }

    return max_consec;
}


int main(void){
    setvbuf(stdout , NULL , _IONBF , 0);
    setvbuf(stderr , NULL , _IONBF , 0);

    int size = 15;
    int arr[size];
    int maximum , element;
    int i;

    printf(""Enter array elements: "");

    
    for(i=0 ; i<size ; i++){
        scanf(""%d"",&arr[i]);
    }

    printf(""\n"");
    printf(""Enter required element: "");

    
    scanf(""%d"",&element);

    
    maximum = LongestConsecutive(arr , size , element);

    
    printf(""Longest consecutive number of element %d is %d"",element ,maximum);

    return 0;
}
",0,1,362
"#define CHECK_LOWER_FALSE   0
#define CHECK_LOWER_TRUE    1

int test_case = CHECK_LOWER_TRUE;                               


char lower_to_upper(char alphabet){
    if( alphabet >= 'a' && alphabet <= 'z' ){
        alphabet = alphabet - 32;                                   
    }
    else{
        test_case = CHECK_LOWER_FALSE;
    }
    return alphabet;
}

int main(void){
    setvbuf(stdout , NULL , _IONBF , 0);                            
    setvbuf(stderr , NULL , _IONBF , 0);
    char alphabet;                                                  
    char uppercase;                                                 
    printf(""Please enter a lowercase letter: "");
    scanf(""%c"",&alphabet);                                          
    uppercase = lower_to_upper(alphabet);                           
    if( test_case == CHECK_LOWER_TRUE ){
    printf(""Uppercase letter %c of corresponding Lowercase letter %c "",uppercase,alphabet);
       }
    else {
        printf(""Invalid input, please enter a lowercase letter "");
    }
    return 0;
}
",0,2,285
"int main(void){
    setvbuf(stdout , NULL , _IONBF , 0);                        
    setvbuf(stderr , NULL , _IONBF , 0);

    int i,j,rows;

        printf(""Enter number of rows: "");
        scanf(""%d"",&rows);
        printf(""\n"");

        for(i=0;i<rows;i++)
        {
            if(i == rows/2){
                continue;
            }
            for(j=0;j<rows;j++)
            {
                if(j == rows/2){
                    continue;
                }
                if( (j==i) || (j==rows-i-1) )
                {
                    printf(""*"");
                }
                else
                {
                    printf("" "");
                }
            }
            printf(""\n"");
        }
        return 0;

}
",0,3,219
"double E = 0.000001;

double pierwiastek(double p, double E)
{
    double a = 1, b = p;

    while (fabs(a - b) >= E)
    {
        a = (a + b) / 2;
        b = p / a;
    }

    return a;
}

int main()
{
    double x, y;

    printf(""Podaj liczbe, z ktorej chcesz wyznaczyc pierwiastek: "");
    scanf(""%2lf"", &x);

    y = pierwiastek(x, E);

    printf(""Pierwiastek = %.3lf"", y);

    return 0;
}",1,4,184
"struct node
{
    int data;
    struct node *next;
}*first;

void create(int A[], int n)
{
    struct node *t, *last;
    first = (struct node*)malloc(sizeof(struct node));
    first->data = A[0];
    first->next = NULL;
    last = first;

    for(int i = 1 ; i < n ; i++)
    {
        t = (struct node*)malloc(sizeof(struct node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
    }
}

void display(struct node *p)
{
    while(p)
    {
        printf(""%d "", p->data);
        p = p->next;
    }
    printf(""\n"");
}

void reverse_m(struct node *p, int m)
{
    int counter = 0;
    struct node *q = NULL;
    struct node *r = NULL;

    
    while(counter < m)
    {
        r = q;
        q = p;
        p = p->next;
        q->next = r;
        counter++;
    }
    first = q;
    
    

    
    while(q->next != NULL)
    {
        q = q->next;
    }
    q->next = p;
}

int main()
{
    int n, m;
    printf(""Number of elements : "");
    scanf(""%d"", &n);
    int A[n];
    printf(""Enter elements : "");
    for(int i = 0 ; i < n ; i++)
        scanf(""%d"", &A[i]);

    create(A, n);
    printf(""Enter value of m : "");
    scanf(""%d"", &m);
    reverse_m(first, m);
    display(first);

}",2,5,469
"int main()
{
    int m, n;
    printf(""Enter number of rows (m) : "");
    scanf(""%d"", &m);
    printf(""Enter number of columns (n) : "");
    scanf(""%d"", &n);
    int **mat;
    mat = (int**)malloc(m*sizeof(int*));
    for(int i = 0 ; i < n ; i++)
    {
        mat[i] = malloc(n*sizeof(int));
    }

    for(int i = 0 ; i < m ; i++)
    {
        for(int j = 0 ; j < n ; j++)
        {
            printf(""Enter element at row %d, column %d : "", i, j);
            scanf(""%d"", &mat[i][j]);
        }
    }
    printf(""Before swapping : \n"");
    for(int i = 0 ; i < m ; i++)
    {
        for(int j = 0 ; j < n ; j++)
        {
            printf(""%d "", mat[i][j]);
        }
        printf(""\n"");
    }

    int f = 0;
    int l = n - 1;
    int temp;
    while(f < l)
    {
        for(int i = 0; i < m ; i++)
        {
            temp = mat[i][f];
            mat[i][f] = mat[i][l];
            mat[i][l] = temp;
        }
        f++;
        l--;
    }

    printf(""After Swapping : \n"");
    for(int i = 0 ; i < m ; i++)
    {
        for(int j = 0 ; j < n ; j++)
        {
            printf(""%d "", mat[i][j]);
        }
        printf(""\n"");
    }


}",2,6,453
"struct node
{
    int data;
    struct node* next;
}*first;

void create(int A[], int n)
{
    struct node *last, *t;
    int i;
    first = (struct node*)malloc(sizeof(struct node));
    first->data = A[0];
    first->next = NULL;
    last = first;

    for(i = 1 ; i < n ; i++)
    {
        t = (struct node*)malloc(sizeof(struct node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
    }
}

void display(struct node *p)
{
    while(p)
    {
        printf(""%d "", p->data);
        p = p->next;
    }
    printf(""\n"");
}

void check_empty(struct node *p)
{
    if(!p)
    {
        printf(""\nList is empty\n"");
    }
    else
    {
        printf(""\nList is not empty\n"");
    }
}

int length(struct node *p)
{
    int len = 0;
    while(p)
    {
        len++;
        p = p->next;
    }
    return len;
}

void insert(struct node *p, int index, int x)
{
    if(index < 0 || index > length(first))
    {
        printf(""\nInvalid index\n"");
        return;
    }
    struct node *t = (struct node*)malloc(sizeof(struct node));
    t->data = x;

    if(index == 0)
    {
        t->next = first;
        first = t;
    }
    else
    {
        for(int i = 0; i < index - 1 ; i++)
            p = p->next;
        t->next = p->next;
        p->next = t;
    }
}

int delete_index(struct node *p, int index)
{
    if(index < 0 || index > length(first))
    {
        printf(""\nInvalid index\n"");
        return -1;
    }

    struct node *q = p;
    int x = 0;

    if(index == 1)
    {
        q = first;
        x = first->data;
        first = first->next;
        free(q);
        return x;
    }
    else
    {
        for(int i = 0 ; i < index - 1; i++)
        {
            q = p;
            p = p->next;
        }
        q->next = p->next;
        x = p->data;
        free(p);
        return x;
    }
}

int delete_key(struct node *p, int key)
{
    int index = 1;
    struct node *q = NULL;

    if(first->data == key)
    {
        q = first;
        if(first->next != NULL)
            first = first->next;
        else
            first = NULL;
        free (q);
        return index;

    }
    else
    {
        while(p->data != key)
        {
            q = p;
            p = p->next;
            index++;
            if(p->next ==NULL && p->data != key)
            {
                printf(""\nKey is not present in list\n"");
                return -1;
            }
        }
        q->next = p->next;
        free(p);
        return index;
    }
}

int search(struct node *p, int key)
{
    int index = 1;
    while(p)
    {
        if(key == p->data)
        {
            return index;
        }
        else
        {
            p = p->next;
            index++;
        }
    }
    return 0;
}

int main()
{
    int n,choice, index, x, key, len;
    printf(""Enter number of elements : "");
    scanf(""%d"", &n);

    int A[n];
    printf(""Enter elements : "");
    for(int i = 0 ; i < n ; i++)
        scanf(""%d"", &A[i]);

    create(A, n);
    do
    {
        printf(""\n\n1 : Traversal of the list\n2 : Check if the list is empty\n"");
        printf(""3 : Insert a node at the certain position\n4 : Delete a node at the certain position\n"");
        printf(""5 : Delete a node for the given key\n6 : Count the total number of nodes\n"");
        printf(""7 : Search for an element in the linked list\n8: EXIT\n"");
        printf(""\nEnter Choice : "");
        scanf(""%d"", &choice);

        switch(choice)
        {
            case 1 :
                display(first);
                break;

            case 2 :
                check_empty(first);
                break;

            case 3 :
                printf(""\nEnter position (0 for after zero nodes, 1 for after 1 node and so on..) : "");
                scanf(""%d"", &index);
                printf(""Enter data : "");
                scanf(""%d"", &x);
                insert(first, index, x);
                printf(""New list : "");
                display(first);
                break;

            case 4 :
                printf(""\nEnter position (1 for 1st node, 2 for 2nd node and so on..): "");
                scanf(""%d"", &index);
                x = delete_index(first, index);
                printf(""Data deleted at position %d : %d\n"", index, x);
                printf(""New list : "");
                display(first);
                break;

            case 5 :
                printf(""\nEnter key : "");
                scanf(""%d"", &key);
                index = delete_key(first, key);
                if(index != -1)
                {
                    printf(""% deleted at position : %d\n"", key, index);
                    printf(""New list : "");
                    display(first);
                }
                break;

            case 6 :
                len = length(first);
                printf(""\nNumber of nodes : %d\n"", len);
                break;

            case 7 :
                printf(""\nEnter key : "");
                scanf(""%d"", &key);
                index = search(first, key);
                if(index != -1)
                {
                    printf(""Element is present at position %d\n"", index);
                }
                break;
        }
    }while(choice != 8);
}",2,7,1644
"void swap(int *x, int *y)
{
    int temp = *x;
    *x = *y;
    *y = temp;
}
void rearrange(int *arr, int n)
{
    int i = 0, j = n-1;
    while (i < j)
    {
        while (arr[i]%2 == 0 && i < j)
            i++;

        while (arr[j]%2 == 1 && i< j)
            j--;

        if (i < j)
        {
            swap(&arr[i], &arr[j]);
            i++;
            j--;
        }
    }
}

int main()
{
    int *arr;
    int n;
    printf(""Enter number of elements : "");
    scanf(""%d"", &n);
    arr = (int*)malloc(n*sizeof(int));

    for(int l = 0 ; l < n ; l++)
    {
        printf(""Enter element no %d :"", l+1);
        scanf(""%d"", arr + l);
    }

    rearrange(arr, n);
    printf(""Rearranged array : \n"");
    for(int m = 0 ; m < n ; m++)
    {
        printf(""%d"", *(arr + m));
    }
    printf(""\n"");
}",2,8,332
"#define KETA 10

struct NUMBER{
    int n[KETA]; 
    int sign; 
};

void clearByZero(struct NUMBER *);
void dispNumber(struct NUMBER *);
void setRnd(struct NUMBER *, int);
void copyNumber(struct NUMBER *, struct NUMBER *);
void getAbs(struct NUMBER *, struct NUMBER *);
int isZero(struct NUMBER *);
int mulBy10(struct NUMBER *, struct NUMBER *);
int divBy10(struct NUMBER *, struct NUMBER *);

int main(int argc, char **argv)
{
    struct NUMBER a;
    struct NUMBER b, c, d;

    srandom(time(NULL));

    clearByZero(&a);
    clearByZero(&b);
    clearByZero(&c);
    clearByZero(&d);

    printf(""a = "");
    dispNumber(&a);
    printf(""\n"");
    printf(""b = "");
    dispNumber(&b);
    printf(""\n"");
    printf(""c = "");
    dispNumber(&c);
    printf(""\n"");
    printf(""d = "");
    dispNumber(&d);
    printf(""\n"");

    setRnd(&a, 3);

    printf(""a = "");
    dispNumber(&a);
    printf(""\n"");


    printf(""ãã¾ã=%d\n"", divBy10(&a, &b));

    printf(""b = "");
    dispNumber(&b);
    printf(""\n"");

    printf(""ãã¾ã=%d\n"", divBy10(&b, &c));

    printf(""c = "");
    dispNumber(&c);
    printf(""\n"");

    printf(""ãã¾ã=%d\n"", divBy10(&c, &d));

    printf(""d = "");
    dispNumber(&d);
    printf(""\n"");

    return 0;
}


void clearByZero(struct NUMBER *a){
    int i;

    for (i = 0; i < KETA;i++){
        a->n[i] = 0;
    }

    a->sign = 1;
}


void dispNumber(struct NUMBER *a){
    int i;

    if(a->sign == 1){
        printf(""+"");
    } else {
        printf(""-"");
    }

    for (i = KETA - 1; i >= 0;i--){
        printf(""%2d"", a->n[i]);
    }
}


void setRnd(struct NUMBER *a, int k){
    int i;
    int judge;

    for (i = 0; i < k;i++){
        a->n[i] = random() % 10; 
    }

    judge = random() % 2; 

    switch (judge) {
        case 1:
            a->sign = 1;
            break;
        case 0:
            a->sign = -1;
            break;
    }
}


void copyNumber(struct NUMBER *a, struct NUMBER *b){
    int i;

    b->sign = a->sign;

    for (i = 0; i < KETA;i++){
        b->n[i] = a->n[i];
    }
}


void getAbs(struct NUMBER *a, struct NUMBER *b){
    copyNumber(a, b);
    b->sign = 1;
}


int isZero(struct NUMBER *a){
    int i;

    for (i = 0; i < KETA;i++){
        if(a->n[i] != 0){
            return -1;
        }
    }

    return 0;
}


int mulBy10(struct NUMBER *a, struct NUMBER *b){
    int i;

    
    if(a->n[KETA - 1] != 0){
        return -1;
    }

    for (i = KETA - 2; i >= 0;i--){
        b->n[i + 1] = a->n[i];
    }

    b->n[0] = 0;

    return 0;
}


int divBy10(struct NUMBER *a, struct NUMBER *b){
    int i;
    int remainder; 

    b->sign = a->sign; 

    remainder = a->sign * a->n[0]; 

    for (i = 1; i <= KETA - 2;i++){
        b->n[i - 1] = a->n[i];
    }

    b->n[KETA -1] = 0;

    return remainder;
}",3,9,1209
"#include ""mulprec.h""

int sqrt_newton(struct NUMBER *, struct NUMBER *);

int main(int argc, char **argv)
{
    struct NUMBER r1, ans, tmp;
    int i, j, r;
    double r2;

    srandom(time(NULL));

    for (i = 0; i < 10;i++){
        r = random();
        setInt(&r1, r);
        for (j = 0; j < 10;j++){
            mulBy10(&r1, &tmp);
            copyNumber(&tmp, &r1);
        }
        sqrt_newton(&r1, &ans);
        printf(""r1:"");
        dispNumberZeroSuppress(&ans);
        puts("""");
        r2 = sqrt((double)r);
        printf(""r2:%f\n"", r2);
    }

    return 0;
}


int sqrt_newton(struct NUMBER *a, struct NUMBER *b) {
    struct NUMBER x, ox, tx, zero, one, two, quotient, sum, rest; 
    clearByZero(b);
    setInt(&zero, 0);
    setInt(&one, 1);
    setInt(&two, 2);

    quickDivide(a, &two, &x, &rest);
    if(isZero(&x) != -1 || numComp(&x, &one) == 0){ 
        copyNumber(a, b);
        return 0;
    }
    if (numComp(&x, &zero) == -1){ 
        return -1;
    }

    copyNumber(&x, &ox);
    

    while(1){
        copyNumber(&ox, &tx);
        copyNumber(&x, &ox);
        quickDivide(a, &ox, &quotient, &rest);
        add(&ox, &quotient, &sum);
        quickDivide(&sum, &two, &x, &rest);

        if(numComp(&x, &ox) == 0){ 
            break;
        }
        if(numComp(&x, &tx) == 0){ 
            if(numComp(&ox, &x) == -1){ 
                copyNumber(&ox, &x);
            }
            break;
        }
        
    }

    copyNumber(&x, b);
    return 0;
}",3,10,596
"int main()
{
    int i;
    int childpid;
    int status;
    char buf[BUFSIZ];
    char prompt[16] = ""prompt> "";
    char **ap, *argv[10], *inputstring;
    printf(""%s"", prompt);
    while (fgets(buf, BUFSIZ, stdin) != NULL) {
        buf[strlen(buf) - 1] = '\0'; 
        inputstring = buf;
        
        for (ap = argv; (*ap = strsep(&inputstring, "" \t"")) != NULL;)
            if (**ap != '\0')
                if (++ap >= &argv[10])
                    break;
        
        
        if ((childpid = fork()) == 0) {
            
            execv(argv[0], argv);
            sleep(30); 
            exit(0);
        } else {
            wait(&status);
            printf(""%04x\n"", status); 
        }
        printf(""%s"", prompt);
    }
}",3,11,257
"int main()
{
    int i;
    int childpid;
    int status;
    char buf[BUFSIZ];
    char prompt[16] = ""prompt> "";
    char **ap, *argv[10], *inputstring;
    printf(""%s"", prompt);
    while (fgets(buf, BUFSIZ, stdin) != NULL) {
        buf[strlen(buf) - 1] = '\0'; 
        inputstring = buf;
        
        for (ap = argv; (*ap = strsep(&inputstring, "" \t"")) != NULL;)
            if (**ap != '\0')
                if (++ap >= &argv[10])
                    break;
        
        
        if ((childpid = fork()) == 0) {
            
            execv(argv[0], argv);
            exit(0);
        } else {
            wait(&status);
        }
        printf(""%s"", prompt);
    }
}",3,12,236
"int main()
{

while(1){
    int i, originalNum, num, lastDigit, sum;
    long fact;

    
    printf(""Enter any number to check Strong number: "");
    scanf(""%d"", &num);

    
    originalNum = num;

    sum = 0;

    
    while(num > 0)
    {

        
        lastDigit = num % 10;

        
        fact = 1;
        for(i=1; i<=lastDigit; i++)
        {
            fact = fact * i;
        }

        
        sum = sum + fact;

        num = num / 10;
    }

    
    if(sum == originalNum)
    {
        printf(""%d is STRONG NUMBER\n"", originalNum);
    }
    else
    {
        printf(""%d is NOT STRONG NUMBER\n"", originalNum);
    }

}
}",4,13,237
"int f[50],i,k,j,inde[50],n,c,count=0,p;
main(){

for(i=0;i<50;i++)
f[i]=0;
x:
printf(""enter index block\t"");
scanf(""%d"",&p);
if(f[p]==0)
{
f[p]=1;
printf(""enter no of files on index\t"");
scanf(""%d"",&n);
}
else
{
printf(""Block already allocated\n"");
goto x;
}
for(i=0;i<n;i++)
scanf(""%d"",&inde[i]);
for(i=0;i<n;i++)
if(f[inde[i]]==1)
{
printf(""Block already allocated"");
goto x;
}
for(j=0;j<n;j++)
f[inde[j]]=1;
printf(""\n allocated"");
printf(""\n file indexed"");
for(k=0;k<n;k++)
printf(""\n %d->%d:%d"",p,inde[k],f[inde[k]]);
printf("" Enter 1 to enter more files and 0 to exit\t"");
scanf(""%d"",&c);
if(c==1)
goto x;
else
close();
getch();
}
",5,14,322
"int f[50],i,k,j,inde[50],n,c,count=0,p;
main(){

for(i=0;i<50;i++)
f[i]=0;
x:
printf(""\nEnter index block:\t"");
scanf(""%d"",&p);
if(f[p]==0){
f[p]=1;
printf(""\nEnter no of files on index:\t"");
scanf(""%d"",&n);
}
else
{
printf(""\nBlock already allocated\n"");
goto x;
}
for(i=0;i<n;i++)
scanf(""%d"",&inde[i]);
for(i=0;i<n;i++)
if(f[inde[i]]==1){
printf(""\nBlock already allocated"");
goto x;
}
for(j=0;j<n;j++)
f[inde[j]]=1;
printf(""\nAllocated"");
printf(""\nFile indexed"");
for(k=0;k<n;k++)
printf(""\n%d->%d:%d"",p,inde[k],f[inde[k]]);
printf(""\nEnter 1 to enter more files and 0 to exit:\t"");
scanf(""%d"",&c);
if(c==1)
goto x;
else
close();
getch();
}
",5,15,324
"int main()
{
    int A[3][3],B[3][3],AB[3][3]={{0,0,0},{0,0,0},{0,0,0}};
    int ii,row,col;
    printf(""Enter a 3*3 matrix A row wise."");

    for (ii = 0; ii < 3; ii++)
    {
        printf(""\nRow %d >>> "",ii + 1);
        scanf(""%d %d %d"",(*(A + ii)+0),(*(A + ii)+1),(*(A +ii)+2));
    }
    printf(""The matrix is A =\n\n"");
    for (ii = 0;ii < 3; ii++)
        printf(""\t%d\t%d\t%d\n"",*(*(A + ii)+0),*(*(A + ii)+1),*(*(A +ii)+2));
    printf(""Enter a 3*3 matrix B row wise."");

    for (ii = 0; ii < 3; ii++)
    {
        printf(""\nRow %d >>> "",ii + 1);
        scanf(""%d %d %d"",(*(B + ii)+0),(*(B + ii)+1),(*(B +ii)+2));
    }
    printf(""The matrix is B =\n\n"");
    for (ii = 0;ii < 3; ii++)
        printf(""\t%d\t%d\t%d\n"",*(*(B + ii)+0),*(*(B + ii)+1),*(*(B +ii)+2));

    for (row=0;row<3;row++)
    {
        for (col=0;col<3;col++)
        {
            for (ii=0;ii<3;ii++)
            {
                *(*(AB+row)+col) += *(*(A+row)+ii) * *(*(B+ii)+col);
            }
        }
    }
    printf(""The matrix is AB =\n\n"");
    for (ii = 0;ii < 3; ii++)
        printf(""\t%d\t%d\t%d\n"",*(*(AB + ii)+0),*(*(AB + ii)+1),*(*(AB +ii)+2));
}
",6,16,548
"#define MAX 20

struct NAME {
    char fname[MAX];
    char mname[MAX];
    char lname[MAX];
};

struct DOB {
    int DD;
    int MM;
    int YYYY;
};

struct student {
    struct NAME name;
    int roll;
    struct DOB dob;
};

int main(void) {
    struct student stud[3];
   
    for (int i = 0; i < 3; i++) {
        printf(""\nEnter First name - middle name - last name: "");
        scanf(""%s %s %s"", stud[i].name.fname, 
                stud[i].name.mname,
                stud[i].name.lname);

        printf(""\nEnter Roll no.: "");
        scanf(""%d"", &stud[i].roll);

        printf(""\nEnter DOB in form DD - MM - YY: "");
        scanf(""%d %d %d"", &stud[i].dob.DD, &stud[i].dob.MM, &stud[i].dob.YYYY);        
    }

    for (int i = 0; i < 3; i++) {
        printf(""NAME = %s %s %s\n"", 
                (stud+i)->name.fname, 
                (stud+i)->name.mname, 
                (stud+i)->name.lname);
        printf(""ROLL = %d\n"",(stud+i)->roll);
        printf(""DOB  = %2d/%2d/%4d\n"",
                ((stud+i)->dob).DD, 
                ((stud+i)->dob).MM, 
                ((stud+i)->dob).YYYY);
        printf(""\n"");
    }
    
    return 0;
}
",6,17,439
"#include ""shell.h""


int path_cmd(char **cmd)
{
    char *path, *value, *cmd_path;
    struct stat buf;

    path = _getenv(""PATH"");
    value = _strtok(path, "":"");
    while (value != NULL)
    {
        cmd_path = build(*cmd, value);
        if (stat(cmd_path, &buf) == 0)
        {
            *cmd = _strdup(cmd_path);
            free(cmd_path);
            free(path);
            return (0);
        }
        free(cmd_path);
        value = _strtok(NULL, "":"");
    }
    free(path);

    return (1);
}

char *build(char *token, char *value)
{
    char *cmd;
    size_t len;

    len = _strlen(value) + _strlen(token) + 2;
    cmd = malloc(sizeof(char) * len);
    if (cmd == NULL)
    {
        return (NULL);
    }

    memset(cmd, 0, len);

    cmd = _strcat(cmd, value);
    cmd = _strcat(cmd, ""/"");
    cmd = _strcat(cmd, token);

    return (cmd);
}

char *_getenv(char *name)
{
    size_t nl, vl;
    char *value;
    int i, x, j;

    nl = _strlen(name);
    for (i = 0 ; environ[i]; i++)
    {
        if (_strncmp(name, environ[i], nl) == 0)
        {
            vl = _strlen(environ[i]) - nl;
            value = malloc(sizeof(char) * vl);
            if (!value)
            {
                free(value);
                perror(""unable to alloc"");
                return (NULL);
            }

            j = 0;
            for (x = nl + 1; environ[i][x]; x++, j++)
            {
                value[j] = environ[i][x];
            }
            value[j] = '\0';

            return (value);
        }
    }

    return (NULL);
}
",7,18,562
"#define GIVE 0
#define TAKE 1

int main()
{
     int     shmid;
     void* shmptr;
     
    const int SIZE=4096;
    const char* name=""vowels"";
      shmid=shm_open(name,O_CREAT|O_RDWR,0666);
      ftruncate(shmid,SIZE);
      shmptr=mmap(0,SIZE,PROT_WRITE,MAP_SHARED,shmid,0);
      printf(""inside client\n"");
      
     
      printf(""the word count  is:\n"");
      
      puts(shmptr);
      printf(""the character count  is:\n"");
      shmptr+=sizeof(int);
      puts(shmptr);
      shm_unlink(name);
      return 0;
}",8,19,212
"#define SI 10

int sum_of_num(int array[],int n);
float average_of_num(int sum,int n);
float product_of_num(int array[],int n);

int i;



int main()
{
    int array[SI],n=0,sum;
    float product,average;
    printf(""enter the array elements\n"");
    while(array[i]!=999)
    {
    for(i=0;i<SI;i++)
    {
        scanf(""%d"",&array[i]);
        n=i;
        if(array[i]==999)
        break;

    }
    }
    sum=sum_of_num(array,n);
    printf(""the sum of number is %d\n"",sum);
    average=average_of_num(sum,n);
    printf(""the average is %f\n"",average);
    product=product_of_num(array,n);
    printf(""product of number is %f"",product);
    return 0;
}



int sum_of_num(int array[],int n)
{
    int sum=0;
    for(i=0;i<n;i++)
    {
        sum+=array[i];
    }
    return sum;
}



float average_of_num(int sum,int n)
{
    float average=0;
    average=sum/n;
    return average;
}



float product_of_num(int array[],int n)
{
    float product=1;
    for(i=0;i<n;i++)
    {
        product*=array[i];
    }
    return product;
}
",8,20,434
"#define FILE_SIZE 100

int read_lines(char s[FILE_SIZE]);
int read_char();
char s[FILE_SIZE];
int main()
{
    FILE *f;
    int pid,c_cnt,fd[2];
    pipe(fd);
    printf(""enter the source file path\n"");
    scanf(""%s"",s);
    
    pid=fork();
    if(pid==0)
    {
        int c_cnt=0;
        printf(""------inside the child process--------\n"");
        close(fd[0]);
        c_cnt=read_char();
        printf(""readed the character\n"");
        printf(""character :%d\n"",c_cnt);
        write(fd[1],&c_cnt,sizeof(c_cnt));
        close(fd[1]);
    }
    else
    {
        wait(NULL);
        
        printf(""-----back to parent process-----\n"");
        int cnt;
        read_lines(s);
        close(fd[1]);
        read(fd[0],&cnt,sizeof(cnt));
        printf(""The count of character in the file is :%d\n"",cnt);
        close(fd[0]);
    }
    
    return 0;
}

int read_char()
{
    FILE *f;
    int character=0;
    char ch;
    f=fopen(s,""r"");
    if (f == NULL) 
    { 
        printf(""Could not open file""); 
        return 0; 
    }
    while ((ch = fgetc(f)) != EOF)
    {
        if (ch != ' ' || ch != '\t' || ch != '\n' || ch != '\0'|| ch!='.')
        character++;
    }
    return(character);
}



int read_lines(char s[FILE_SIZE])
{
    FILE *f;
    int words;
    char ch;
    f=fopen(s,""r"");
    if (f == NULL) 
    { 
        printf(""Could not open file""); 
        return 0; 
    }
    words = 0;
    while ((ch = fgetc(f)) != EOF)
    {
        

        
        if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\0'|| ch=='.')
            words++;
    }
    
    printf(""\tthe number of words are :%d\n"",words);    
    fclose(f);
    return (1);
}
    ",8,21,632
"#include ""get_next_line.h""

int     str_is_digits(char *c)
{
    int i;

    i = 0;
    if (!c)
        return (0);
    while (c[i])
    {
        if (!ft_isdigit(c[i]))
            return (0);
        i++;
    }
    return (1);
}

int     array_is_rgb(char **colors)
{
    int i;

    i = 0;
    while (colors[i])
    {
        if (str_is_digits(colors[i]))
        {
            if (!(atoi(colors[i]) <= 255) || !(atoi(colors[i]) >= 0))
            {
                ft_putstr(""Error\n Wrong colors parametres!"");
                exit(0);
            }
        }
        else
            return (0);
        i++;
    }
    return (1);
}

void    get_s(char *line)
{
    char    **par;
    char    *str;
    int     re;

    re = 0;
    par = ft_split(line, ' ');
    str = ft_strdup("""");
    if (g_s != NULL)
        texture_error(0);
    if (c_w(line, ' ') != 2)
    {
        while (++re < c_w(line, ' '))
        {
            str = ft_strjoin(str, &par[re][0]);
            if (re != c_w(line, ' ') - 1)
                str = ft_strjoin(str, "" "");
        }
        if ((re = open(str, O_RDONLY) < 0))
            texture_error(5);
        else
            g_s = ft_strdup(str);
    }
    else
        wrong_file(&par[1][0], 5);
    free_this_shit(str, par);
}

void    get_f(char *line)
{
    char    **par;
    char    **colors;
    int     cc;
    int     cw;

    cw = 0;
    par = ft_split(line, ' ');
    cc = 0;
    colors = ft_split(&par[1][0], ',');
    while (line[cc])
    {
        if (line[cc] == ',')
            cw++;
        cc++;
    }
    if (cw != 2)
    {
        ft_putstr(""Error:\n Wrong floor RGB"");
        exit(0);
    }
    cw = c_w(line, ' ');
    cc = c_w(&par[1][0], ',');
    freethenipples(par);
    check_frgb(colors, cc, cw);
    freethenipples(colors);
}

void    get_c(char *line)
{
    char    **par;
    char    **colors;
    int     cc;
    int     cw;

    cw = 0;
    par = ft_split(line, ' ');
    cc = 0;
    colors = ft_split(&par[1][0], ',');
    while (line[cc])
    {
        if (line[cc] == ',')
            cw++;
        cc++;
    }
    if (cw != 2)
    {
        ft_putstr(""Error:\n Wrong ceiling RGB"");
        exit(0);
    }
    cw = c_w(line, ' ');
    cc = c_w(&par[1][0], ',');
    freethenipples(par);
    check_crgb(colors, cc, cw);
    freethenipples(colors);
}
",9,22,947
"#include ""get_next_line.h""


int     readline(void)
{
    int     fd;
    char    *line;

    fd = open(""map.cub"", O_RDONLY);
    global_init();
    while (get_next_line(fd, &line))
    {
        if (!all_params())
        {
            if (*line != '\0')
                routing(line);
        }
        else
            routing(line);
        free(line);
    }
    free(line);
    return (0);
}

void    routing(char *line)
{
    if (line[0] == 'R' && line[1] == ' ')
        get_re(line);
    else if (line[0] == 'N' && line[1] == 'O' && line[2] == ' ')
        get_no(line);
    else if (line[0] == 'S' && line[1] == 'O' && line[2] == ' ')
        get_so(line);
    else if (line[0] == 'W' && line[1] == 'E' && line[2] == ' ')
        get_we(line);
    else if (line[0] == 'E' && line[1] == 'A' && line[2] == ' ')
        get_ea(line);
    else if (line[0] == 'S' && line[1] == ' ')
        get_s(line);
    else if (line[0] == 'F' && line[1] == ' ')
        get_f(line);
    else if (line[0] == 'C' && line[1] == ' ')
        get_c(line);
    else if (all_params())
        readmap(line);
    else
    {
        ft_putstr(""one or many parametres format is wrong or missing!\n"");
        exit(0);
    }
}

int     main(void)
{
    char **ugh;
    int a;
    readline();
    manage_map();
    longuest_line();
    array_height();
    ugh = map_manager();
    g_vars.mlx = mlx_init();
    g_vars.win = mlx_new_window(g_vars.mlx, g_width, g_height, ""Bismilah!"");
    
    
    freethenipples(ugh);
    mlx_loop_hook(g_vars.mlx, move, 0);
    mlx_loop(g_vars.mlx);
}
",9,23,634
"void main()
 {int a[10][10],t[10][10],n,m,i,j;
  printf (""Enter numbers of rows:"");
  scanf (""%d"",&n);
  printf (""Enter numbers of columns:"");
  scanf (""%d"",&m);
  printf(""Enter elements:"");
  for(i=0;i<n;i++)            
   {for(j=0;j<m;j++)
     {  scanf(""%d"",&a[i][j]);
      }
    }
  printf(""\n Array is:\n"");
  for(i=0;i<n;i++)          
   {for(j=0;j<m;j++)
     {  printf(""\t %d"",a[i][j]);
      }
      printf(""\n"");
    }
  printf(""\n"");  
  for(i=0;i<n;i++)         
   {for(j=0;j<m;j++)
     {   t[j][i]=a[i][j];
      }
    }
  printf(""\n Its transpose:\n"");
  for(i=0;i<n;i++)           
   {for(j=0;j<m;j++)
     {  printf(""\t %d"",t[i][j]);
      }
    printf(""\n"");
    }
  }
  
                                                                      
 
  
  

                                       
",10,24,351
"typedef struct student
{
    int rollno;
    char name[30];
    float grade;
}class;
int main()
{
    int n;
    scanf(""%d"",&n);
    if(n<1)
    {
        printf(""ERROR"");
        exit(1);
    }
    class arr[n],t;
    
    for (int i = 0; i < n; i++)
    {
        scanf(""%d"",&arr[i].rollno);
        for(int j=0;j<30;j++) arr[i].name[j]=' ';
        gets(arr[i].name);
        
        
        scanf(""%f"",&arr[i].grade);
    }
    
    for (int i = 0; i < n-1; i++)
    {
        for (int j = 0; j < n-1; j++)
        {
            if(arr[j+1].grade > arr[j].grade)
            {
                t=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=t;
            }
        }
    }
    
    printf(""Merit List: \n"");
    for (int i = 0; i < n; i++)
    {
        printf(""%d "",arr[i].rollno);
        printf(""%-30s"",arr[i].name);
        printf("" %.2f\n"",arr[i].grade);
    }
    return 0;
}",11,25,368
"#define     MAX 20                      
void inputArray(int arr[], int len) {   
    int i;
    for (i = 0; i < len; i++) {
        scanf(""%d"", &arr[i]);
    }
}
int search(int arr[],int n,int val)
{
    for(int i=0;i<n;i++)
    {
        printf(""Pass %d: Comparing %d with %d\n"",i,arr[i],val);
        if(arr[i]==val)
            return i;
    }
    return -1;
}
int main() {
    int arr[MAX], n, val, pos;
    scanf(""%d"", &n);                    
    if (n<=0) {
            printf(""ERROR: Empty list\n"");
            exit(EXIT_FAILURE);
    }
    inputArray( arr, n );             
    scanf(""%d"", &val);                
    pos = search(arr, n, val); 
    if (pos != -1)
        printf(""Position of %d: %d\n"", val, pos);
    else
        printf(""All checked: %d not found\n"", val);
    return 0;
}
",11,26,302
"typedef struct node 
{ 
    int key; 
    struct node *left, *right; 
}list;
list *newNode(int item) 
{ 
    list *temp = (list *)malloc(sizeof(list)); 
    temp->key = item; 
    temp->left = temp->right = NULL; 
    return temp; 
} 
list* rec_insert(list* node, int key) 
{ 
    if (node == NULL) 
    return newNode(key); 
    if (key < node->key) 
        node->left = rec_insert(node->left, key); 
    else if (key > node->key) 
        node->right = rec_insert(node->right, key); 
    return node; 
}
list *insert(list* root, int n)
{
    list **temp=&root;
    while(*temp!=NULL)
    {
        if(n < (*temp)->key) temp=&(*temp)->left;
        else temp=&(*temp)->right;
    }
    *temp=newNode(n);
    return root;
}
void inorder(list *root) 
{ 
    if (root != NULL) 
    { 
        inorder(root->left); 
        printf(""%d \n"", root->key); 
        inorder(root->right); 
    } 
}
void preorder(list *root)
{
    if (root != NULL)
    {
        printf(""%d \n"", root->key); 
        preorder(root->left);
        preorder(root->right);
    }
}
void postorder(list *root)
{
    if (root != NULL)
    {
        postorder(root->left);
        postorder(root->right);
        printf(""%d \n"", root->key); 
    }
}
int main() 
{ 
    int ch;
    list* root=NULL;
    while(1)
    {
        printf(""\n"");
        printf(""1. Insertion Using Recursive Function\n"");
        printf(""2. Insertion Using Iterative Function\n"");
        printf(""3. In-order Traversal  using a Recursive Function\n"");
        printf(""4. Pre-order Traversal  using a Recursive Function\n"");
        printf(""5. Post-order Traversal  using a Recursive Function\n"");
        printf(""6. Exit\n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&ch);
        if (ch==1)
        {
            int n;
            printf(""Enter the element: "");
            scanf(""%d"",&n);
            root=rec_insert(root,n);
            printf(""%d inserted in Binary Tree\n"",n);
        }
        else if(ch==2)
        {
            int n;
            printf(""Enter the element: "");
            scanf(""%d"",&n);
            root=insert(root,n);
            printf(""%d inserted in Binary Tree\n"",n);
        }
        else if(ch==3)
        {
            printf(""IN-ORDER\n"");
            inorder(root);
        }
        else if(ch==4)
        {
            printf(""PRE-ORDER\n"");
            preorder(root);
        }
        else if(ch==5)
        {
            printf(""POST-ORDER\n"");
            postorder(root);
        }
        else if(ch==6)
        {
            printf(""Thank You.\n"");
            break;
        }
        else
            printf(""Invalid Choice.\n"");
    }
    return 0; 
}",11,27,885
"#define MAX 50
typedef struct bs_tree{
    int data;
    struct bs_tree *left, *right;
}BS_TREE; 
typedef struct queue{
   BS_TREE *elements[MAX];
    int front, rear; 
}QUEUE;
void initialiseQueue (QUEUE *aq){
    aq->front =-1; 
    aq->rear =-1;
}
void addQueue (BS_TREE * at, QUEUE *aq){

    if (aq->rear == MAX-1)
        exit(0); 
 
    else
        aq->elements [++(aq->rear)]=at;

}
BS_TREE* deleteQueue (QUEUE *aq){
     BS_TREE *p;
    
    if (aq->front != aq->rear){
        p= aq->elements [++(aq->front)];
        if (aq->front == aq->rear)
        
        initialiseQueue (aq);
        return p; 
    }
    else 
        return NULL; 
}
int  isEmptyQueue (QUEUE q) {
    return (q.front == -1);
}
void initialise_tree (BS_TREE **aar){
        *aar = NULL;
}
void rec_insert (BS_TREE **aar, int n){
    if (*aar == NULL){
       *aar=(BS_TREE *)malloc(sizeof(BS_TREE));
        (*aar)->data=n;
        (*aar)->left=(*aar)->right=NULL;
    } 
    else if (n<(*aar)->data)
        rec_insert(&((*aar)->left), n); 
    else
        rec_insert(&((*aar)->right), n); 
}
void level_order_Traversal (BS_TREE *ar){
    QUEUE q;
    BS_TREE *ptr;
    
    initialiseQueue (&q);
    
    addQueue (ar, &q);
        
    while (! isEmpty(q)){
            
        ptr = deleteQueue (&q);
            
        if ( ptr->left != NULL ) 
            addQueue (ptr->left, &q);
            
        if ( ptr->right != NULL ) 
            addQueue (ptr->right, &q);
        printf(""\t %d"", ptr->data);            
    }
}",11,28,593
"void StrcatX(char *Src, char *Dest)
{
    if( (Src == NULL) || (Dest == NULL)   )
    {
        return;
    }
    
    
  
    while(*Src != '\0')    
    {
        Src++;               
    }

   
    *Src=' ';
    Src++;

   while(*Dest != '\0')
   {
       *Src = *Dest;
       Dest++;
       Src++;
   }
    
    *Dest = '\0';
}

int main()
{
    char arr[30] = {'\0'};   

    char brr[30] = {'\0'};   
    
    printf(""Please enter first string\n"");
    scanf(""%[^'\n']s"",arr);
    
    printf(""Please enter second string\n"");
    scanf("" %[^'\n']s"",brr);
        
    StrcatX(arr,brr);       
    
    printf(""String after concatination %s\n"",arr);
    
    return 0;
}

",12,29,271
"typedef int BOOL;
# define TRUE 1
#define FALSE 0

BOOL CheckBit(int iNo)
{
    int iMask = 0X00800000;
    
    int iResult = 0;
    if(iNo < 0)
    {
        iNo = -iNo;
    }
    iResult = iNo & iMask;
    
    if(iResult == iMask)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
int main()
{
    int iNo = 0;
    BOOL bRet = FALSE;
    
    printf(""Enter number\n"");
    scanf(""%d"",&iNo);
        
    bRet = CheckBit(iNo);
    if(bRet == TRUE)
    {
        printf(""Fourth bit is on\n"");
    }
    else
    {
        printf(""Fourth bit is Off\n"");
    }
    return 0;
}
















",12,30,267
"int CountVowels(char str[])
{
    int iCnt = 0, i = 0;
    
    if(str == NULL)
    {
        return -1;
    }
    
    while(str[i] != '\0')
    {
        if(
           (str[i] == 'a') || (str[i] == 'A') || (str[i] == 'e') || (str[i] == 'E') || (str[i] == 'i') || (str[i] == 'I') || (str[i] == 'o')||(str[i] == 'O') || (str[i] == 'u')||(str[i] == 'U') )
        {
            iCnt++;
        }
        i++;
    }
    
    return iCnt;
}

int main()
{
    char arr[30];
    int iRet = 0;
    
    printf(""Please enter the string\n"");
 
    scanf(""%[^'\n']s"",arr);
    
    iRet = CountVowels(arr);
    
    printf(""Total number vowels are %d\n"",iRet);
    
    return 0;
}
",12,31,298
"typedef int BOOL;
# define TRUE 1
#define FALSE 0

BOOL CheckBit(int iNo, int iPos)
{
    int iMask = 0x00000001;
    
    int iResult = 0;
    if(iNo < 0)
    {
        iNo = -iNo;
    }
    
    if((iPos < 1) || (iPos > 32))
    {
        return FALSE;
    }
    
    iMask = iMask << (iPos -1);
    
    iResult = iNo & iMask;
    
    if(iResult == iMask)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
int main()
{
    int iNo = 0, iPos;
    BOOL bRet = FALSE;
    
    printf(""Enter number\n"");
    scanf(""%d"",&iNo);
    
    printf(""Enter the position\n"");
    scanf(""%d"",&iPos);
        
    bRet = CheckBit(iNo,iPos);
    if(bRet == TRUE)
    {
        printf(""Bit is on\n"");
    }
    else
    {
        printf(""Bits is Off\n"");
    }
    return 0;
}


",12,32,331
"#include ""sort.h""



void cocktail_sort_list(listint_t **list)
{
    listint_t *recorro, *temp;

    if (!list || *list == NULL)
        return;

    if ((*list)->next == NULL)
        return;

    temp = (*list)->next;
    while (temp != NULL)
    {
        recorro = *list;
        while (recorro->next != NULL)
        {
            if (recorro->n > recorro->next->n)
            {
                swap(recorro->next, recorro, list);
                print_list(*list);
            }
            else
                recorro = recorro->next;
        }
        while (recorro->prev != NULL)
        {
            if (recorro->n < recorro->prev->n)
            {
                swap(recorro, recorro->prev, list);
                print_list(*list);
            }
            else
                recorro = recorro->prev;
        }
        temp = temp->next;
    }
}


listint_t **swap(listint_t *temp_sort, listint_t *swapper, listint_t **list)
{
    listint_t *aux_prev, *aux_next = temp_sort->next;

    if (temp_sort->next == NULL && swapper->prev == NULL)
    {
        temp_sort->next = temp_sort->prev;
        temp_sort->prev = NULL;
        swapper->prev = swapper->next;
        swapper->next = NULL;
        *list = temp_sort;
    }
    else if (swapper->prev == NULL)
    {
        temp_sort->prev = NULL;
        temp_sort->next = swapper;
        swapper->prev = temp_sort;
        swapper->next = aux_next;
        aux_next->prev = swapper;
        *list = temp_sort;
    }
    else if (temp_sort->next == NULL)
    {
        aux_prev = swapper->prev;
        aux_prev->next = temp_sort;
        temp_sort->prev = aux_prev;
        temp_sort->next = swapper;
        swapper->prev = temp_sort;
        swapper->next = NULL;
    }
    else
    {
        aux_prev = swapper->prev;
        aux_prev->next = temp_sort;
        temp_sort->prev = aux_prev;
        temp_sort->next = swapper;
        swapper->next = aux_next;
        swapper->prev = temp_sort;
        aux_next->prev = swapper;
    }
    return (list);
}
",13,33,681
"int main(int argc, char *argv[]) {
    int rank, 
    size; 

    MPI_Init(&argc, &argv); 

    MPI_Comm_size(MPI_COMM_WORLD, &size); 
    MPI_Comm_rank(MPI_COMM_WORLD, &rank); 

    int localData[2];
    int resultSum[2];
    int resultProd[2];

    for(int i = 0; i < 2; i++){
        localData[i] = rank+1;
    }

    MPI_Reduce(localData, resultSum, 2, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);
    MPI_Reduce(localData, resultProd, 2, MPI_INT, MPI_PROD, 0, MPI_COMM_WORLD);

    MPI_Barrier(MPI_COMM_WORLD);

    if(rank == 0){
        printf(""El resultado de la suma de los arrays es: %d, %d.\n"", resultSum[0], resultSum[1]);
        printf(""El resultado del producto de los arrays es: %d, %d.\n"", resultProd[0], resultProd[1]);
    }

    MPI_Finalize();

    return 0;
} ",14,34,342
"#define SIZE 11

void okuYaz (void);

int main()
{
   okuYaz();

   return 0;

}

void okuYaz (void)
{
    int num[SIZE], i;

    printf(""%s"",""okul numaranÄ±zÄ± giriniz:"");
    
    for(i=0;i<SIZE;i++)
        scanf(""%d"",&num[i]);

    printf(""%s\n"",""okul numaranÄ±z:"");

    for(i=0;i<SIZE;i++)
        printf(""%d"",num[i]);
}",15,35,156
"int main ()
{
    int a,b,c;
    
    printf(""bir sayÄ± giriniz:"");
    scanf(""%d"",&a);
    
    
    printf(""bir sayÄ± giriniz:"");
    scanf(""%d"",&b);


    printf(""bir sayÄ± giriniz:"");
    scanf(""%d"",&c); 
    
    
    if(a<=b && a<=c) 
    {
            printf(""a b ve c ye eÅit veya kÃ¼Ã§Ã¼ktÃ¼r"");
        }
    
    
    if(a>=b && a>=c)
        {
            printf(""a b ve c ye eÅit veya bÃ¼yÃ¼ktÃ¼r"");
        }
    
    return 0;
    
    
    }
",15,36,210
"int main ()

{
    
    
    
    
    int secim ;
    
    printf(""1 giriniz"");
    scanf(""%d"",&secim);
    
    switch(secim)
    {
        
        case(1):
            {
                int k=10;
                
                printf(""bÃ¶lÃ¼m:%d "",k/0);
                
            }
            
            break;
            
            
            default:
                printf(""sayÄ±n kullanÄ±cÄ± neden 1 girmiyorsun ayÄ±p deÄil mi"");
        
    }
    
    
    
    return 0;
        
        
        
    
    
    
    
    
    
    
    
    
    
    
    
    
    }
",15,37,201
"#define inf 9999
void matrix_chain_multiplication(int p[11],int n,int M[11][11],int S[11][11])
{
 int i,j,k,l,q;
 for(l=2;l<=n;l++)
 {
  for(i=1;i<=n-l+1;i++)
  {
   j=i+l-1;
   M[i][j]=inf;
   for(k=i;k<=j-1;k++)
   {
    q=M[i][k]+M[k+1][j]+p[i-1]*p[k]*p[j];
    if(q<M[i][j])
    {
     M[i][j]=q;
     S[i][j]=k;
    }
   }
  }
 }
}

void putdata(int A[11][11],int row,int column)
{
 int i,j;
 for(i=1;i<=row;i++)
 {
   for(j=1;j<=column;j++)
   {
    printf(""%d\t"",A[i][j]);
   }
   printf(""\n"");
 }
}
void main()
{
 int M[11][11],S[11][11],i,j,n,p[11];
 for(i=0;i<=10;i++)
 {
  for(j=0;j<=10;j++)
  {
   M[i][j]=0;
   S[i][j]=0;
  }
   p[i]=0;
 }
 printf(""Enter the total number of matrices:"");
 scanf(""%d"",&n);
 printf(""Enter the chain of matrices:"");
 for(i=0;i<=n;i++)
  scanf(""%d"",&p[i]);
 matrix_chain_multiplication(p,n,M,S);
 printf(""\nResult\n"");
 putdata(M,n,n);
 printf(""\nResult\n"");
 putdata(S,n,n);
}
",16,38,513
"int count =0;
       int partition(int [50],int,int); 
       void quick_sort(int[50],int,int);
     void main()
      {
       void getdata(int[50],int);
       void putdata(int[50],int);
       int i,a[50],n;
       printf(""Enter the value of n \n"");
       scanf(""%d"",&n);
       getdata(a,n);
       printf(""Before sorting \n"");
       putdata(a,n);
       quick_sort(a,0,n-1);
       printf(""After sorting \n"");
       putdata(a,n);
       printf(""value of count=%d \n"",count);
      }
     void getdata(int x[50],int n)
       {
        int k;
        printf(""enter the value  for sorting\n"");
        for(k=0;k<n;k++)
        {
         scanf(""%d"",&x[k]);
        }     
       }
     void putdata(int x[50], int n)
       {
        int k;
        for(k=0;k<n;k++)
         {
          printf(""%d\t"",x[k]);
         }
          printf(""\n"");
        }
        
    int partition(int a[50],int p,int r)
   {
    int x,i,j,temp;
    x=a[r];
    i=p-1;
    count++;
    for(j=p;j<=r-1;j++)
    {
        count++;
        if(a[j]<=x)
        {
        count++;
            i=i+1;
        count++;
            temp=a[j];
        count++;
            a[j]=a[i];
        count++;
            a[i]=temp;
        count++;
        }
        count++;
    }
    count++;
    temp =a[r];
    count++;
    a[r]=a[i+1];                       
    count++;
    a[i+1]=temp;
    count++;
    return i+1;
    }

void quick_sort(int a[50],int p,int r)
{   
    int q;
    count++;
    if(p<r)
    {
        count++;
        q=partition(a,p,r);
        count++;
        quick_sort(a,p,q-1);
        count++;
        quick_sort(a,q+1,r);
        count++;
    }
}
",16,39,632
"#include ""app_display.h""
#include ""ugui.h""
#include ""nrf_gfx_ext.h""
#include ""images.h""

#define RSSI

UG_WINDOW window_1;
char m_summary_string1[64];
char m_summary_string2[64];

extern const nrf_lcd_t nrf_lcd_ili9341;
static const nrf_lcd_t * p_lcd = &nrf_lcd_ili9341;

char *display_string_phy[] = {""Coded"", ""1 Mbps"", ""2 Mbps"", ""MultiPhy""};

char *display_string_rssi_label[] = {""RSSI (LR):"", ""RSSI (1M):"", ""RSSI (2M):""};
char *display_string_speed_label[] = {""Speed (LR):"", ""Speed (1M):"", ""Speed (2M):""};
char *display_string_psr_label[] = {""PSR:"", ""PSR:"", ""PSR:""};

char *display_string_trip_phy_rssi_label[] = {""LB (LR):"", ""LB (1M):"", ""LB (2M):""};
char *display_string_tx_power[] = {""0 dBm"", ""4 dBm"", ""8 dBm""};
char *display_string_app_state[] = {""Idle"", ""Advertising"", ""Scanning"", ""Connected"", ""Disconnected""};
char *display_string_led_state[] = {""Off"", ""On""};
char *display_string_button_state[] = {""Off"", ""On""};
const UG_COLOR display_app_state_button_color[] = APP_STATE_COLORS;
const UG_COLOR display_app_state_button_font_color[] = APP_STATE_FONT_COLORS;
const UG_COLOR display_on_off_color[] = ON_OFF_COLORS;
const UG_COLOR display_on_off_font_color[] = ON_OFF_FONT_COLORS;

UG_GUI gui;
UG_TEXTBOX textbox_toggle_phy;
UG_TEXTBOX textbox_toggle_power;
UG_TEXTBOX textbox_toggle_adv_type; 
UG_TEXTBOX textbox_rssi_label[3];
UG_TEXTBOX textbox_psr_label;
UG_TEXTBOX textbox_rssi_number[3];
UG_TEXTBOX textbox_psr_number;
UG_TEXTBOX textbox_dbm_label;
UG_TEXTBOX textbox_percentage_label;
UG_TEXTBOX textbox_link_indicator;
UG_TEXTBOX textbox_led_label;
UG_TEXTBOX textbox_button_label;
UG_BUTTON phy_button;
UG_BUTTON power_button;
UG_BUTTON adv_button;
UG_BUTTON led_button;
UG_BUTTON button_button;
UG_IMAGE image_1;

static char sprintf_buf[64];
static char sprintf_psr[64];

#define MAX_OBJECTS 20

UG_OBJECT obj_buff_wnd_1[MAX_OBJECTS];

static app_display_content_t content_previous = {0};

void window_1_callback (UG_MESSAGE *msg)
{
        UNUSED_PARAMETER(msg);
}

void app_display_init(app_display_content_t *initial_state)
{
        content_previous = *initial_state;
        UG_Init(&gui, 240, 320, p_lcd);
}

void app_display_create_main_screen(app_display_content_t *content)
{
        
        UG_WindowCreate ( &window_1, obj_buff_wnd_1, MAX_OBJECTS, window_1_callback );
        
        UG_WindowSetTitleText (&window_1, content->main_title);
        UG_WindowSetTitleTextFont (&window_1, &FONT_10X16);
        UG_WindowSetTitleTextAlignment(&window_1, ALIGN_CENTER);

        
        UG_TextboxCreate(&window_1, &textbox_toggle_phy, TXB_ID_0, TXT_ID_0_X_LOCATION, TXT_ID_0_Y_LOCATION, TXT_ID_0_X_LOCATION+TXT_ID_0_WIDTH, TXT_ID_0_Y_LOCATION+TXT_ID_0_HEIGHT);
        UG_TextboxSetFont(&window_1, TXB_ID_0, &FONT_8X12);
        UG_TextboxSetText(&window_1, TXB_ID_0, ""Btn 1: PHY"");
        UG_TextboxSetForeColor (&window_1, TXB_ID_0, FONT_COLOR_TEXT );
        UG_TextboxSetBackColor (&window_1, TXB_ID_0, FILL_COLOR_TEXT );
        UG_TextboxSetAlignment (&window_1, TXB_ID_0, ALIGN_CENTER );

        
        UG_ButtonCreate(&window_1, &phy_button, BTN_ID_0, BTN_ID_0_X_LOCATION, BTN_ID_0_Y_LOCATION, BTN_ID_0_X_LOCATION+BTN_ID_0_WIDTH, BTN_ID_0_Y_LOCATION+BTN_ID_0_HEIGHT);
        UG_ButtonSetStyle(&window_1, BTN_ID_0, BTN_STYLE_3D|BTN_STYLE_USE_ALTERNATE_COLORS);
        UG_ButtonSetForeColor(&window_1, BTN_ID_0, FONT_COLOR_BUTTON);
        UG_ButtonSetBackColor(&window_1, BTN_ID_0, FILL_COLOR_BUTTON);
        UG_ButtonSetFont(&window_1, BTN_ID_0, &FONT_10X16);

        
        UG_TextboxCreate(&window_1, &textbox_toggle_power, TXB_ID_1, TXT_ID_1_X_LOCATION, TXT_ID_1_Y_LOCATION, TXT_ID_1_X_LOCATION+TXT_ID_1_WIDTH, TXT_ID_1_Y_LOCATION+TXT_ID_1_HEIGHT);
        UG_TextboxSetFont(&window_1, TXB_ID_1, &FONT_8X12);
        UG_TextboxSetText(&window_1, TXB_ID_1, ""Btn 2: Power"");
        UG_TextboxSetForeColor (&window_1, TXB_ID_1, FONT_COLOR_TEXT );
        UG_TextboxSetBackColor (&window_1, TXB_ID_1, FILL_COLOR_TEXT );
        UG_TextboxSetAlignment (&window_1, TXB_ID_1, ALIGN_CENTER );

        
        UG_ButtonCreate(&window_1, &power_button, BTN_ID_1, BTN_ID_1_X_LOCATION, BTN_ID_1_Y_LOCATION, BTN_ID_1_X_LOCATION+BTN_ID_1_WIDTH, BTN_ID_1_Y_LOCATION+BTN_ID_1_HEIGHT);
        UG_ButtonSetStyle(&window_1, BTN_ID_1, BTN_STYLE_3D|BTN_STYLE_USE_ALTERNATE_COLORS);
        UG_ButtonSetForeColor(&window_1, BTN_ID_1, FONT_COLOR_BUTTON);
        UG_ButtonSetBackColor(&window_1, BTN_ID_1, FILL_COLOR_BUTTON);
        UG_ButtonSetFont(&window_1, BTN_ID_1, &FONT_10X16);
        

        
        UG_TextboxCreate(&window_1, &textbox_toggle_adv_type, TXB_ID_2, TXT_ID_2_X_LOCATION, TXT_ID_2_Y_LOCATION, TXT_ID_2_X_LOCATION+TXT_ID_2_WIDTH, TXT_ID_2_Y_LOCATION+TXT_ID_2_HEIGHT);
        UG_TextboxSetFont(&window_1, TXB_ID_2, &FONT_8X12);
        UG_TextboxSetText(&window_1, TXB_ID_2, ""Btn 3: App state"");
        UG_TextboxSetForeColor (&window_1, TXB_ID_2, FONT_COLOR_TEXT );
        UG_TextboxSetBackColor (&window_1, TXB_ID_2, FILL_COLOR_TEXT );
        UG_TextboxSetAlignment (&window_1, TXB_ID_2, ALIGN_CENTER );

        
        UG_ButtonCreate(&window_1, &adv_button, BTN_ID_2, BTN_ID_2_X_LOCATION, BTN_ID_2_Y_LOCATION, BTN_ID_2_X_LOCATION+BTN_ID_2_WIDTH, BTN_ID_2_Y_LOCATION+BTN_ID_2_HEIGHT);
        UG_ButtonSetStyle(&window_1, BTN_ID_2, BTN_STYLE_3D|BTN_STYLE_USE_ALTERNATE_COLORS);
        UG_ButtonSetFont(&window_1, BTN_ID_2, &FONT_10X16);



























        
        UG_TextboxCreate(&window_1, &textbox_rssi_label[0], TXB_ID_3, TXT_ID_3_X_LOCATION, TXT_ID_3_Y_LOCATION, TXT_ID_3_X_LOCATION+TXT_ID_3_WIDTH, TXT_ID_3_Y_LOCATION+TXT_ID_3_HEIGHT);
        UG_TextboxSetFont(&window_1, TXB_ID_3, &FONT_8X12);
        UG_TextboxSetText(&window_1, TXB_ID_3, display_string_trip_phy_rssi_label[0]);
        UG_TextboxSetForeColor (&window_1, TXB_ID_3, FONT_COLOR_TEXT );
        UG_TextboxSetBackColor (&window_1, TXB_ID_3, 0x0000 );
        UG_TextboxSetAlignment (&window_1, TXB_ID_3, ALIGN_CENTER );

        UG_TextboxCreate(&window_1, &textbox_rssi_label[1], TXB_ID_4, TXT_ID_4_X_LOCATION, TXT_ID_4_Y_LOCATION, TXT_ID_4_X_LOCATION+TXT_ID_4_WIDTH, TXT_ID_4_Y_LOCATION+TXT_ID_4_HEIGHT);
        UG_TextboxSetFont(&window_1, TXB_ID_4, &FONT_8X12);
        UG_TextboxSetText(&window_1, TXB_ID_4, display_string_trip_phy_rssi_label[1]);
        UG_TextboxSetForeColor (&window_1, TXB_ID_4, FONT_COLOR_TEXT );
        UG_TextboxSetBackColor (&window_1, TXB_ID_4, 0x0000 );
        UG_TextboxSetAlignment (&window_1, TXB_ID_4, ALIGN_CENTER );

        UG_TextboxCreate(&window_1, &textbox_rssi_label[2], TXB_ID_5, TXT_ID_5_X_LOCATION, TXT_ID_5_Y_LOCATION, TXT_ID_5_X_LOCATION+TXT_ID_5_WIDTH, TXT_ID_5_Y_LOCATION+TXT_ID_5_HEIGHT);
        UG_TextboxSetFont(&window_1, TXB_ID_5, &FONT_8X12);
        UG_TextboxSetText(&window_1, TXB_ID_5, display_string_trip_phy_rssi_label[2]);
        UG_TextboxSetForeColor (&window_1, TXB_ID_5, FONT_COLOR_TEXT );
        UG_TextboxSetBackColor (&window_1, TXB_ID_5, 0x0000 );
        UG_TextboxSetAlignment (&window_1, TXB_ID_5, ALIGN_CENTER );

        
        UG_TextboxCreate(&window_1, &textbox_rssi_number[0], TXB_ID_6, TXT_ID_6_X_LOCATION, TXT_ID_6_Y_LOCATION, TXT_ID_6_X_LOCATION+TXT_ID_6_WIDTH, TXT_ID_6_Y_LOCATION+TXT_ID_6_HEIGHT);
        UG_TextboxSetFont(&window_1, TXB_ID_6, &FONT_8X12);
        UG_TextboxSetText(&window_1, TXB_ID_6, ""Disconnected"");
        UG_TextboxSetForeColor (&window_1, TXB_ID_6, FONT_COLOR_TEXT );
        UG_TextboxSetBackColor (&window_1, TXB_ID_6, 0x0000 );
        UG_TextboxSetAlignment (&window_1, TXB_ID_6, ALIGN_CENTER );

        UG_TextboxCreate(&window_1, &textbox_rssi_number[1], TXB_ID_7, TXT_ID_7_X_LOCATION, TXT_ID_7_Y_LOCATION, TXT_ID_7_X_LOCATION+TXT_ID_7_WIDTH, TXT_ID_7_Y_LOCATION+TXT_ID_7_HEIGHT);
        UG_TextboxSetFont(&window_1, TXB_ID_7, &FONT_8X12);
        UG_TextboxSetText(&window_1, TXB_ID_7, ""Disconnected"");
        UG_TextboxSetForeColor (&window_1, TXB_ID_7, FONT_COLOR_TEXT );
        UG_TextboxSetBackColor (&window_1, TXB_ID_7, 0x0000 );
        UG_TextboxSetAlignment (&window_1, TXB_ID_7, ALIGN_CENTER );

        UG_TextboxCreate(&window_1, &textbox_rssi_number[2], TXB_ID_8, TXT_ID_8_X_LOCATION, TXT_ID_8_Y_LOCATION, TXT_ID_8_X_LOCATION+TXT_ID_8_WIDTH, TXT_ID_8_Y_LOCATION+TXT_ID_8_HEIGHT);
        UG_TextboxSetFont(&window_1, TXB_ID_8, &FONT_8X12);
        UG_TextboxSetText(&window_1, TXB_ID_8, ""Disconnected"");
        UG_TextboxSetForeColor (&window_1, TXB_ID_8, FONT_COLOR_TEXT );
        UG_TextboxSetBackColor (&window_1, TXB_ID_8, 0x0000 );
        UG_TextboxSetAlignment (&window_1, TXB_ID_8, ALIGN_CENTER );

#if 1
        
        UG_TextboxCreate(&window_1, &textbox_psr_label, TXB_ID_12, TXT_ID_12_X_LOCATION, TXT_ID_12_Y_LOCATION, TXT_ID_12_X_LOCATION+TXT_ID_4_WIDTH, TXT_ID_12_Y_LOCATION+TXT_ID_4_HEIGHT);
        UG_TextboxSetFont(&window_1, TXB_ID_12, &FONT_8X12);
        UG_TextboxSetText(&window_1, TXB_ID_12, ""PSR: "");
        UG_TextboxSetForeColor (&window_1, TXB_ID_12, FONT_COLOR_TEXT );
        UG_TextboxSetBackColor (&window_1, TXB_ID_12, FILL_COLOR_TEXT );
        UG_TextboxSetAlignment (&window_1, TXB_ID_12, ALIGN_CENTER );

        
        UG_TextboxCreate(&window_1, &textbox_psr_number, TXB_ID_13, TXT_ID_13_X_LOCATION, TXT_ID_13_Y_LOCATION, TXT_ID_13_X_LOCATION+TXT_ID_6_WIDTH, TXT_ID_13_Y_LOCATION+TXT_ID_6_HEIGHT);
        UG_TextboxSetFont(&window_1, TXB_ID_13, &FONT_8X12);
        UG_TextboxSetText(&window_1, TXB_ID_13, ""###"");
        UG_TextboxSetForeColor (&window_1, TXB_ID_13, FONT_COLOR_TEXT );
        UG_TextboxSetBackColor (&window_1, TXB_ID_13, FILL_COLOR_TEXT );
        UG_TextboxSetAlignment (&window_1, TXB_ID_13, ALIGN_CENTER );

#endif

        UG_ImageCreate(&window_1, &image_1, IMG_ID_0, 0, 228, 30, 250);
        UG_ImageSetBMP(&window_1, IMG_ID_0, &bmp_nordicsemi);

        
        app_display_update_main_screen(content);

        
        UG_WindowShow( &window_1 );
}



void app_display_update_main_screen(app_display_content_t *content)
{
        static bool first_update = true;
        if(first_update || content->phy != content_previous.phy)
        {
                UG_ButtonSetText(&window_1, BTN_ID_0, display_string_phy[content->phy]);









                {


                        UG_TextboxSetText(&window_1, TXB_ID_4, display_string_rssi_label[APP_PHY_1M]);
                        UG_TextboxSetText(&window_1, TXB_ID_12, display_string_psr_label[APP_PHY_1M]);
                }
                UG_TextboxSetText(&window_1, TXB_ID_7, ""Disconnected"");
                UG_TextboxSetText(&window_1, TXB_ID_13, ""Disconnected"");
        }
        if(first_update || content->tx_power != content_previous.tx_power)
        {
                UG_ButtonSetText(&window_1, BTN_ID_1, display_string_tx_power[content->tx_power]);
        }
        if(first_update || content->app_state != content_previous.app_state)
        {
                UG_ButtonSetBackColor(&window_1, BTN_ID_2, display_app_state_button_color[content->app_state]);
                UG_ButtonSetForeColor(&window_1, BTN_ID_2, display_app_state_button_font_color[content->app_state]);
                UG_ButtonSetText(&window_1, BTN_ID_2, display_string_app_state[content->app_state]);

                if(content->app_state == APP_STATE_CONNECTED)
                {
                        UG_TextboxShow(&window_1, TXB_ID_4);
                        UG_TextboxShow(&window_1, TXB_ID_7);
                        UG_TextboxShow(&window_1, TXB_ID_12);
                        UG_TextboxShow(&window_1, TXB_ID_13); 

















                        {
                                UG_TextboxSetBackColor(&window_1, TXB_ID_4, RGB_888_TO_565(0x0ADD00));
                                UG_TextboxSetBackColor(&window_1, TXB_ID_7, RGB_888_TO_565(0x0ADD00));

                                UG_TextboxSetBackColor(&window_1, TXB_ID_12, RGB_888_TO_565(0x0ADD00));
                                UG_TextboxSetBackColor(&window_1, TXB_ID_13, RGB_888_TO_565(0x0ADD00));
                        }
                }
                else
                {
                        UG_TextboxHide(&window_1, TXB_ID_3);
                        UG_TextboxHide(&window_1, TXB_ID_6);
                        UG_TextboxHide(&window_1, TXB_ID_4);
                        UG_TextboxHide(&window_1, TXB_ID_5);
                        UG_TextboxHide(&window_1, TXB_ID_7);
                        UG_TextboxHide(&window_1, TXB_ID_8);

                        UG_TextboxHide(&window_1, TXB_ID_12);
                        UG_TextboxHide(&window_1, TXB_ID_13);
                }
        }












        static int rx_sensitivity[] = {-103, -95, -92};
        static uint32_t link_budget_colors[] = {0xEF0000, 0xfe6c00, 0xfdc700, 0xe2e500, 0xc6f700, 0x5ee900, 0x0ADD00};
        static int link_budget, link_color;
























        {
                if(first_update || content->rssi[0] != content_previous.rssi[0])
                {
                        link_budget = (int)content->rssi[0] - rx_sensitivity[content->phy];
                        
                        link_color = RGB_888_TO_565(link_budget < 35 ? link_budget_colors[link_budget / 5] : 0x0ADD00);

#ifdef RSSI
                        sprintf(sprintf_buf, ""%i dBm"", (int)content->rssi[0]);
                        UG_TextboxSetBackColor(&window_1, TXB_ID_4, link_color);
                        UG_TextboxSetBackColor(&window_1, TXB_ID_7, link_color);
                        UG_TextboxSetText(&window_1, TXB_ID_7, content->rssi[0] != 0 ? sprintf_buf : ""-"");
#else
                        sprintf(sprintf_buf, ""%i kbps"", (int)content->throughput_kbps);
                        UG_TextboxSetBackColor(&window_1, TXB_ID_4, link_color);
                        UG_TextboxSetBackColor(&window_1, TXB_ID_7, link_color);
                        UG_TextboxSetText(&window_1, TXB_ID_7, sprintf_buf);

#endif
                        sprintf(sprintf_psr, ""%3d% %"", (int)content->psr);
                        UG_TextboxSetBackColor(&window_1, TXB_ID_12, link_color);
                        UG_TextboxSetBackColor(&window_1, TXB_ID_13, link_color);
                        UG_TextboxSetText(&window_1, TXB_ID_13, sprintf_psr);

                }
        }
        first_update = false;
        content_previous = *content;
}

void app_display_update(void)
{
        UG_Update();
}
",17,40,6430
"FILE* F1;
FILE* F2;
int* read(int n)
{
        int i;
        int s = sizeof(int);
        int* arr1= (int*)malloc(s * n);
        for(i = 0; i<n; i++)
        {
                fscanf(F1, ""%d"", (arr1+i));
        }
        return arr1;
}



void display(int arr2[], int n)
{
        int i;
        for(i = 0; i<n; i++)
        {
                fprintf(F2, ""%d "", arr2[i]);
        }

}


int check_digit(int n)
{
    int count=0;
    if(n==0)
        return 1;
    while(n>0)
    {
        n=n/10;
        count++;
    }
    return count;
}
int check_digit_array(int A[], int n)
{
    int s;
    int num = check_digit(A[0]);
    for(int i = 1; i<n; i++)
    {
        s = check_digit(A[i]);
        if(s != num)
            return 0;
    }
    return 1;
}


int getMax(int arr[], int n) {
    int mx = arr[0];
    int i;
    for (i = 1; i < n; i++)
        if (arr[i] > mx)
            mx = arr[i];
    return mx;
}
 
void countSort(int arr[], int n, int exp) {
    int output[n]; 
    int i, count[10] = { 0 };
    for (i = 0; i < n; i++)
        count[(arr[i] / exp) % 10]++;
 
    for (i = 1; i < 10; i++)
        count[i] += count[i - 1];
 
    for (i = n - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }
 
    for (i = 0; i < n; i++)
        arr[i] = output[i];
}
 
void radix_sort(int arr[], int n) {
    int m = getMax(arr, n);
 
    int exp;
    for (exp = 1; m / exp > 0; exp *= 10)
        countSort(arr, n, exp);
}
 
int main(int argc, char* argv[]) {
    
        int num; char s;int size;
        int* arr;
        F1 = fopen(argv[1], ""r"");
        F2 = fopen(argv[2], ""w"");
        while(1)
        {
        fscanf(F1 ,""%c %d"",&s, &num);
        if(s == 'r')
        {
                size = num;
                arr = read(num);

        }
        else if(s == 's')
        {
            int nm1 = check_digit_array(arr, 6);
            if(nm1 != 0)
            {
                radix_sort(arr, size);
        display(arr, size);
            }
        }

        else if(s == 'd')
        {
                display(arr, size);
                fprintf(F2, ""\n"");
        }
        else if(s == 't')
                return 0;
        }
    
        return 0;

}
",18,41,932
"FILE* F1;
FILE* F2;
int* read(int n)
{
        int i;
        int s = sizeof(int);
        int* arr1= (int*)malloc(s * n);
        for(i = 0; i<n; i++)
        {
                fscanf(F1, ""%d"", (arr1+i));
        }
        return arr1;
}
void display(int arr2[], int n)
{
        int i;
        for(i = 0; i<n; i++)
        {
                fprintf(F2, ""%d "", arr2[i]);
        }

}


int binary_search(int a[], int str, int end, int k)
{
    int mid = (end+str)/2;
    while(str<=end)
    {
        mid = (end+str)/2;
        if(a[mid] == k)
            return mid;
        else if(a[mid]>k)
        {
            end = mid-1;
        }
        else if(a[mid]<k)
        {
            str = mid+1;
        }
    }
    return -1;

}

int binary_search_rev(int a[], int str, int end, int k)
{
        int mid = (end+str)/2;
        while(str<=end)
        {
                mid = (end+str)/2;
                if(a[mid] == k)
                        return mid;
                else if(a[mid]>k)
                {
                        str = mid+1;
                }
                else if(a[mid]<k)
                {
                        end = mid-1;
                }
        }
        return -1;

}
int binary_bitonic(int arr[],int str, int end ) 
{ 
    int mid; 
      
    mid = (str + end) / 2; 
    if(arr[mid] > arr[mid-1] && arr[mid] > arr[mid + 1]) 
    { 
        return mid; 
    } 
      
    else if(arr[mid] > arr[mid - 1] && arr[mid] < arr[mid + 1]) 
    { 
        binary_bitonic(arr, mid , end); 
    } 
  
    else if(arr[mid] < arr[mid - 1] && arr[mid] > arr[mid + 1]) 
    { 
        binary_bitonic(arr, str, mid); 
    } 
} 

int search(int a[], int k, int size)
{
    
    int str = 0; 
    int end = size - 1;
    int b = binary_bitonic(a, str, end);
    
    int bs = binary_search(a, 0, b, k);
    if(bs!=-1)
    {
        printf(""search succesful : normal\n"");  
        return bs;
    }
    else if (bs == -1)
    {
        int rbs = binary_search_rev(a, b, end, k);
            return rbs;
    }
}

int main(int argc, char* argv[])
{
    int num; char s;int size;
        int* arr;
        F1 = fopen(argv[1], ""r"");
        F2 = fopen(argv[2], ""w"");
        while(1)
        {
        fscanf(F1 ,""%c %d"",&s, &num);
        if(s == 'r')
        {
                size = num;
                arr = read(num);

        }
        else if(s == 's')
        {
                int p = search(arr, num, size);
                fprintf(F2,""%d\n"", p);
        }

        else if(s == 'd')
        {
                display(arr, size);
                fprintf(F2, ""\n"");
        }
        else if(s == 't')
                return 0;
        }
    fclose(F1);
    fclose(F2);
}
",18,42,1027
"#define PORT ""8888""   


void *get_in_addr(struct sockaddr *sa)
{
    if (sa->sa_family == AF_INET) {
        return &(((struct sockaddr_in*)sa)->sin_addr);
    }

    return &(((struct sockaddr_in6*)sa)->sin6_addr);
}

int main(void)
{
    fd_set master;    
    fd_set read_fds;  
    int fdmax;        

    int listener;     
    int newfd;        
    struct sockaddr_storage remoteaddr; 
    socklen_t addrlen;

    char buf[256];    
    int nbytes;

    char remoteIP[INET6_ADDRSTRLEN];

    int yes=1;        
    int i, j, rv;

    struct addrinfo hints, *ai, *p;

    FD_ZERO(&master);    
    FD_ZERO(&read_fds);

    
    memset(&hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;
    if ((rv = getaddrinfo(NULL, PORT, &hints, &ai)) != 0) {
        fprintf(stderr, ""selectserver: %s\n"", gai_strerror(rv));
        exit(1);
    }

    for(p = ai; p != NULL; p = p->ai_next) {
        listener = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
        if (listener < 0) {
            continue;
        }

        
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));

        if (bind(listener, p->ai_addr, p->ai_addrlen) < 0) {
            close(listener);
            continue;
        }

        break;
    }

    
    if (p == NULL) {
        fprintf(stderr, ""selectserver: failed to bind\n"");
        exit(2);
    }

    freeaddrinfo(ai); 

    
    if (listen(listener, 10) == -1) {
        perror(""listen"");
        exit(3);
    }

    
    FD_SET(listener, &master);

    
    fdmax = listener; 

    
    for(;;) {
        read_fds = master; 
        if (select(fdmax+1, &read_fds, NULL, NULL, NULL) == -1) {
            perror(""select"");
            exit(4);
        }

        
        for(i = 0; i <= fdmax; i++) {
            if (FD_ISSET(i, &read_fds)) { 
                if (i == listener) {
                    
                    addrlen = sizeof remoteaddr;
                    newfd = accept(listener,
                        (struct sockaddr *)&remoteaddr,
                        &addrlen);

                    if (newfd == -1) {
                        perror(""accept"");
                    } else {
                        FD_SET(newfd, &master); 
                        if (newfd > fdmax) {    
                            fdmax = newfd;
                        }
                        printf(""selectserver: new connection from %s on ""
                            ""socket %d\n"",
                            inet_ntop(remoteaddr.ss_family,
                                get_in_addr((struct sockaddr*)&remoteaddr),
                                remoteIP, INET6_ADDRSTRLEN),
                            newfd);
                    }
                } else {
                    
                    if ((nbytes = recv(i, buf, sizeof buf, 0)) <= 0) {
                        
                        if (nbytes == 0) {
                            
                            printf(""selectserver: socket %d hung up\n"", i);
                        } else {
                            perror(""recv"");
                        }
                        close(i); 
                        FD_CLR(i, &master); 
                    } else {
                        
                        for(j = 0; j <= fdmax; j++) {
                            
                            if (FD_ISSET(j, &master)) {
                                
                                if (j != listener && j != i) {
                                    if (send(j, buf, nbytes, 0) == -1) {
                                        perror(""send"");
                                    }
                                }
                            }
                        }
                    }
                } 
            } 
        } 
    } 

    return 0;
}
",18,43,1210
"#define PORT 8080
#define BUFSIZE 1024

#define MAX_NUMBER_CLIENTS 1024
char name_directory[MAX_NUMBER_CLIENTS][32];

#define PASSWORD ""password""








struct message
{
    int type;
    char name[32];
    char data[BUFSIZE];
};





void server_set_up(int *sockfd, struct sockaddr_in *server_addr);
void connection_accept(fd_set *master, int *fdmax, int sockfd, struct sockaddr_in *client_addr);
void send_recv(int i, fd_set *master, int sockfd, int fdmax);

int main()
{
    fd_set master, read_fds;

    int fdmax, i;
    int sockfd = 0;

    struct sockaddr_in server_addr, client_addr;

    
    FD_ZERO(&master);
    FD_ZERO(&read_fds);

    server_set_up(&sockfd, &server_addr);

    
    
    FD_SET(sockfd, &master);
    fdmax = sockfd;

    
    memset(name_directory, '\0', sizeof(name_directory));

    while (1)
    {
        
        read_fds = master;
        
        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)
        {
            perror(""select"");
            exit(4);
        }
       for (i = 0; i <= fdmax; i++)
        {
            if (FD_ISSET(i, &read_fds))
            {
                if (i == sockfd)
                    
                    
                    connection_accept(&master, &fdmax, sockfd, &client_addr);
                else
                    
                    send_recv(i, &master, sockfd, fdmax);
            }
        }
    }
    return 0;
}

void server_set_up(int *sockfd, struct sockaddr_in *server_addr)
{
    if ((*sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
    {
        perror(""Socket"");
        exit(1);
    }

    
    server_addr->sin_family = AF_INET;
    server_addr->sin_port = htons(PORT);
    server_addr->sin_addr.s_addr = INADDR_ANY;

    
    int flag = 1;
    if (setsockopt(*sockfd, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(int)) == -1) {
        perror(""error in setsockopt"");
        exit(1);
    }

    
    if (bind(*sockfd, (struct sockaddr *)server_addr, sizeof(struct sockaddr)) == -1)
    {
        perror(""Unable to bind"");
        exit(1);
    }
    printf(""TCP Server Bound to Port: %d\n"", PORT);

    
    if (listen(*sockfd, 10) == -1)
    {
        perror(""listen"");
        exit(1);
    }
    printf(""TCP Server Waiting for Client Requests...\n"");
    fflush(stdout);
}

void connection_accept(fd_set *master, int *fdmax, int sockfd, struct sockaddr_in *client_addr)
{
    socklen_t addrlen = sizeof(struct sockaddr_in);
    int newsockfd;

    char list_message[32] = ""The List of People Online are:"";
    char name_message[32];

    struct message send_message;

    if ((newsockfd = accept(sockfd, (struct sockaddr *)client_addr, &addrlen)) == -1)
    {
        perror(""accept"");
        exit(1);
    }
    else
    {
        
        FD_SET(newsockfd, master);
        
        if (newsockfd > *fdmax)
            *fdmax = newsockfd;
        printf(""New connection at %s : %d \n"", inet_ntoa(client_addr->sin_addr), ntohs(client_addr->sin_port));
        strcpy(send_message.data, ""\0"");
        for (int i = 0; i < *(fdmax); i++)
        {
            if (FD_ISSET(i, master) && i != newsockfd)
            {
                if (name_directory[i][0] != '\0')
                {
                    send_message.type = 3;
                    strcpy(send_message.name, name_directory[i]);
                    send(newsockfd, &send_message, sizeof(struct message), 0);
                }
            }
        }
    }
}

void send_recv(int i, fd_set *master, int sockfd, int fdmax)
{
    int recv_size, j;
    struct message recv_message, send_message;
    char recv_buf[BUFSIZE];

    if ((recv_size = recv(i, &recv_message, sizeof(struct message), 0)) <= 0)
    {
        if (recv_size == 0)
            printf(""Socket with FD: %d Hung Up\n"", i);
        else
            perror(""recv"");

        
        strcpy(name_directory[i], ""\0"");

        
        
        close(i);
        FD_CLR(i, master);
    }
    else
    {
        
        send_message.type = recv_message.type;
        strcpy(send_message.name, recv_message.name);
        strcpy(send_message.data, recv_message.data);

        if (recv_message.type == 1)
        {
            
            
            if(strcmp(recv_message.data, PASSWORD)==0) {
                
                strcpy(name_directory[i], recv_message.name);
            } else {
                send_message.type = 4;
                send(i, &send_message, sizeof(struct message), 0);
                close(i);
                FD_CLR(i, master);
                return;
            }
            
        }
        for (j = 0; j <= fdmax; j++)
        {
            
            if (FD_ISSET(j, master))
            {
                if (j != sockfd && j != i)
                {
                    if (send(j, &send_message, sizeof(struct message), 0) == -1)
                    {
                        perror(""send"");
                    }
                }
            }
        }

        if (recv_message.type == 2)
        {
            printf(""%s left the discussion\n"", recv_message.name);
        }
        bzero(recv_buf, BUFSIZE);
    }
}",18,44,1794
"int n, *vindex, **W;
bool promising(int);

void hamiltonian(int i) {
    for(int j = 1; j <= n-1; j++)
        printf(""%d "", vindex[j]);
    printf(""\n"");

    if(promising(i)) {
        if(i == n-1) {
            printf(""vindex = "");
            for(int j = 1; j <= n-1; j++)
                printf(""%d "", vindex[j]);
            printf(""\n"");
        }
        else {
            for(int j = 2; j <= n; j++) {
                vindex[i+1] = j;
                hamiltonian(i+1);
            }
        }
    }
}

bool promising(int i) {
    int j = 1;
    bool swtch;

    if(i == n-1 && !W[vindex[n-1]][vindex[0]])
        swtch = false;
    else if(i > 0 && !W[vindex[i-1]][vindex[i]])
        swtch = false;
    else {
        swtch = true;

        while(j < i && swtch) {
            if(vindex[i] == vindex[j]) swtch = false;
            j++;
        }
    }
    
    return swtch;
}

void main() {
    
    printf(""n = "");
    scanf(""%d"", &n);
    printf(""\n"");

    W = (int **)malloc(sizeof(int *) * (n+1));
    for(int i = 0; i <= n; i++) {
        W[i] = (int *)malloc(sizeof(int) * (n+1));
        memset(W[i], 0, sizeof(int) * (n+1));
    }
    vindex = (int *)malloc(sizeof(int) * (n+1));
    vindex[0] = 1;

    printf(""W = \n"");
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            scanf(""%d"", &W[i][j]);
    printf(""\n"");

    hamiltonian(0);
}

",19,45,569
"int main(int argc, char *argv[]) {

    int fd;
    int offset = atoi(argv[2]);
    int len = strlen(argv[3]);

    if((fd = open(argv[1], O_RDWR)) == -1) {
        perror(""rfd file openning error"");
        return 1;
    }

    if(lseek(fd, offset, SEEK_SET) == -1) {
        perror(""lseek error"");
        close(fd);
        return 1;
    }

    write(fd, argv[3], len);

    puts(""file overwrite success"");

    close(fd);

    return 0;
}
",19,46,177
"#define nr_of_adjecent 13

int main(void){
    long answer = 0, product = 1;
    char input[1001] =  ""73167176531330624919225119674426574742355349194934""
                        ""96983520312774506326239578318016984801869478851843""
                        ""85861560789112949495459501737958331952853208805511""
                        ""12540698747158523863050715693290963295227443043557""
                        ""66896648950445244523161731856403098711121722383113""
                        ""62229893423380308135336276614282806444486645238749""
                        ""30358907296290491560440772390713810515859307960866""
                        ""70172427121883998797908792274921901699720888093776""
                        ""65727333001053367881220235421809751254540594752243""
                        ""52584907711670556013604839586446706324415722155397""
                        ""53697817977846174064955149290862569321978468622482""
                        ""83972241375657056057490261407972968652414535100474""
                        ""82166370484403199890008895243450658541227588666881""
                        ""16427171479924442928230863465674813919123162824586""
                        ""17866458359124566529476545682848912883142607690042""
                        ""24219022671055626321111109370544217506941658960408""
                        ""07198403850962455444362981230987879927244284909188""
                        ""84580156166097919133875499200524063689912560717606""
                        ""05886116467109405077541002256983155200055935729725""
                        ""71636269561882670428252483600823257530420752963450"";
    char solution[nr_of_adjecent + 1] = """";
    int i, j;


    for(i = nr_of_adjecent - 1; i < 1000; i++){
        
        for(j = nr_of_adjecent - 1; j >= 0; j--){
            product = (input[i - j] - '0') * product;
        }

        
        if(product > answer){
            answer = product;

            
            for(j = 0; j < nr_of_adjecent; j++){
                solution[j] = input[i - nr_of_adjecent + 1 + j];
            }
        }

        product = 1;
    }

    printf(""answer=%ld (%s)\n"", answer, solution);
    return EXIT_SUCCESS;
}",20,47,1354
"#define NR_ROWS 400000 
#define NR_COLS 100

char input[] = ""^^.^..^.....^..^..^^...^^.^....^^^.^.^^....^.^^^...^^^^.^^^^.^..^^^^.^^.^.^.^.^.^^...^^..^^^..^.^^^^"";
bool traps[NR_ROWS][NR_COLS] = {false};
bool left, center, right;
int nr_safe = 0;


int main(){
   clock_t start = clock(), diff;

   for(int i = 0; i < strlen(input); i++){
      if(input[i] == '^'){
         traps[0][i] = true;
      }
      else{
         nr_safe++;
      }
   }

   for(int row = 1; row < NR_ROWS; row++){
      for(int col = 0; col < NR_COLS; col++){
         if(col == 0){
            left = false;
            center = traps[row - 1][col];
            right = traps[row - 1][col + 1];
         }
         else if(col == NR_COLS - 1){
            left = traps[row - 1][col - 1];
            center = traps[row - 1][col];
            right = false;
         }
         else{
            left = traps[row - 1][col - 1];
            center = traps[row - 1][col];
            right = traps[row - 1][col + 1];
         }

         if((left && center && !right) || (!left && center && right) ||
               (!left && !center && right) || (left && !center && !right)){
            traps[row][col] = true;
         }
         else{
            traps[row][col] = false;
            nr_safe++;
         }
      }
   }

   diff = clock() - start;
   int msec = diff * 1000 / CLOCKS_PER_SEC;

   printf(""answer=%d\n"", nr_safe);
   printf(""time: %ds %dms"", msec/1000, msec%1000);

   return EXIT_SUCCESS;
}
",20,48,584
"int main() {
   FILE * fp_data;
   fp_data = fopen(""data"", ""r"");

   char c;
   int x = 2, y = 2;

   char answer_key[5][5] = {
      {'0', '0', '1', '0', '0'},
      {'0', '2', '3', '4', '0'},
      {'5', '6', '7', '8', '9'},
      {'0', 'A', 'B', 'C', '0'},
      {'0', '0', 'D', '0', '0'}
   };

   for(int lines = 0; lines < 5; lines++){
      while ((c = getc(fp_data)) != ('\n') && c != EOF) {
         switch(c){
            case 'R' :
               if(y < 4) {
                  if(answer_key[x][y + 1] != '0'){
                     y++;
                  }
               }
               break;
            case 'L' :
               if(y > 0) {
                  if(answer_key[x][y - 1] != '0'){
                     y--;
                  }
               }
               break;

            case 'U' :
               if(x > 0) {
                  if(answer_key[x - 1][y] != '0'){
                     x--;
                  }
               }
               break;
            case 'D' :
               if(x < 4) {
                  if(answer_key[x + 1][y] != '0'){
                     x++;
                  }
               }
               break;
         }
      }

      printf(""%c"", answer_key[x][y]);
   }
   return 0;
}
",20,49,450
"#define NR_OF_SUES 500

int main(void){
    
    
    
    int sues[NR_OF_SUES][10];
    int analysis[10] = {3, 7, 2, 3, 0, 0, 5, 3, 2, 1};
    int sue_nr = 0;
    int index = 0, amount = 0;
    bool found_her = true;


    
    for(int i = 0; i < NR_OF_SUES; i++){
        for(int j = 0; j < 10; j++){
            sues[i][j] = 999;
        }
    }

    
    FILE * fp_data;
    fp_data = fopen(""data"", ""r"");
    char * data_read = NULL, * token = NULL, * dummy = NULL;
    size_t len = 0;
    ssize_t read;

    while((read = getline(&data_read, &len, fp_data)) != -1){
        char * data_dummy = data_read;

        
        token = strtok(data_dummy, "":"");
        data_dummy = strtok(NULL, """");

        
        token = strtok(data_dummy, "","");
        while(token != NULL){
            
            if(strstr(token, ""children"") != NULL){
                index = 0;
            }
            else if(strstr(token, ""cats"") != NULL){
                index = 1;
            }
            else if(strstr(token, ""samoyeds"") != NULL){
                index = 2;
            }           
            else if(strstr(token, ""pomeranians"") != NULL){
                index = 3;
            }
            else if(strstr(token, ""akitas"") != NULL){
                index = 4;
            }
            else if(strstr(token, ""vizslas"") != NULL){
                index = 5;
            }
            else if(strstr(token, ""goldfish"") != NULL){
                index = 6;
            }
            else if(strstr(token, ""trees"") != NULL){
                index = 7;
            }
            else if(strstr(token, ""cars"") != NULL){
                index = 8;
            }
            else if(strstr(token, ""perfumes"") != NULL){
                index = 9;
            }

            
            dummy = token;
            while (*dummy){
                if(isdigit(*dummy)){
                    amount = (int) strtol(dummy, &dummy, 10);
                }
                else{
                    dummy++;
                }
            }

            
            sues[sue_nr][index] = amount;
            
            
            token = strtok(NULL, "","");
        }

        sue_nr++;
    }

    
    for(int i = 0; i < NR_OF_SUES; i++){
        for(int j = 0; j < 10; j++){
            if(sues[i][j] != 999){
                switch (j){
                    case 1: case 7:
                        
                        if(sues[i][j] <= analysis[j]) found_her = false;
                        break;

                    case 3: case 6:
                        
                        if(sues[i][j] >= analysis[j])   found_her = false;
                        break;

                    default:
                        if(sues[i][j] != analysis[j])   found_her = false;
                }
            }
        }

        if(found_her){
            printf(""answer=%d\n"", i + 1);
            break;
        }
        else{
            found_her = true;
        }
    }

    return EXIT_SUCCESS;
}",20,50,977
"int main(void){
    unsigned long long answer = 0;
    unsigned long long input[100] = {
        37107287533902,
        46376937677490,
        74324986199524,
        91942213363574,
        23067588207539,
        89261670696623,
        28112879812849,
        44274228917432,
        47451445736001,
        70386486105843,
        62176457141856,
        64906352462741,
        92575867718337,
        58203565325359,
        80181199384826,
        35398664372827,
        86515506006295,
        71693888707715,
        54370070576826,
        53282654108756,
        36123272525000,
        45876576172410,
        17423706905851,
        81142660418086,
        51934325451728,
        62467221648435,
        15732444386908,
        55037687525678,
        18336384825330,
        80386287592878,
        78182833757993,
        16726320100436,
        48403098129077,
        87086987551392,
        59959406895756,
        69793950679652,
        41052684708299,
        65378607361501,
        35829035317434,
        94953759765105,
        88902802571733,
        25267680276078,
        36270218540497,
        24074486908231,
        91430288197103,
        34413065578016,
        23053081172816,
        11487696932154,
        63783299490636,
        67720186971698,
        95548255300263,
        76085327132285,
        37774242535411,
        23701913275725,
        29798860272258,
        18495701454879,
        38298203783031,
        34829543829199,
        40957953066405,
        29746152185502,
        41698116222072,
        62467957194401,
        23189706772547,
        86188088225875,
        11306739708304,
        82959174767140,
        97623331044818,
        42846280183517,
        55121603546981,
        32238195734329,
        75506164965184,
        62177842752192,
        32924185707147,
        99518671430235,
        73267460800591,
        76841822524674,
        97142617910342,
        87783646182799,
        10848802521674,
        71329612474782,
        62184073572399,
        66627891981488,
        60661826293682,
        85786944089552,
        66024396409905,
        64913982680032,
        16730939319872,
        94809377245048,
        78639167021187,
        15368713711936,
        40789923115535,
        44889911501440,
        41503128880339,
        81234880673210,
        82616570773948,
        22918802058777,
        77158542502016,
        72107838435069,
        20849603980134,
        53503534226472
    };

    int i;
    for(i = 0; i < 100; i++){
        answer += input[i];
    }
    printf(""answer=%lld\n"", answer);

    return EXIT_SUCCESS;
}",20,51,1790
"int distance(int, int, int);
void move(char *);
void parse_data(void);


int x = 0, y = 0, z = 0;
int max_distance = 0;


int main(void){
    parse_data();
    printf(""d=%d, max_d=%d\n"", distance(x, y, z), max_distance);

    return EXIT_SUCCESS;
}

int distance(int x, int y, int z){
    return (abs(x) + abs(y) + abs(z))/2;
}

void move(char * command){
    if(strncmp(command, ""n\0"", 2) == 0){
        y++;
        z--;
    }
    else if(strncmp(command, ""ne"", 2) == 0){
        x++;
        z--;
    }
    else if(strncmp(command, ""se"", 2) == 0){
        x++;
        y--;

    }
    else if(strncmp(command, ""s\0"", 2) == 0){
        y--;
        z++;
    }
    else if(strncmp(command, ""sw"", 2) == 0){
        x--;
        z++;
    }
    else if(strncmp(command, ""nw"", 2) == 0){
        x--;
        y++;
    }
}

void parse_data(void){
    FILE *fp;

    
    if(!(fp = fopen(""data"", ""r""))){
        fprintf(stderr, ""Error opening file\n"");
        exit(EXIT_FAILURE);
    }

    char * data_read = NULL;
    size_t len; ssize_t read;
    while((read = getline(&data_read, &len, fp)) != -1){
        data_read[strcspn(data_read, ""\r\n"")] = 0;  
        char * pch;
        pch = data_read;

        pch = strtok(pch, "","");
        while(pch != NULL){
            move(pch);
            if(distance(x, y, z) > max_distance) max_distance = distance(x, y, z);
            pch = strtok(NULL, "","");
        }
    }

    free(data_read);
    fclose(fp);
}
",20,52,604
"#include ""notebook.h""
#include ""marca.h""
#include ""tipo.h""
#include ""servicio.h""
#include ""trabajo.h""
#include ""utn.h""
#include ""menu.h""

#define TAM_NOTEBOOKS 10
#define TAM_MARCAS 4
#define TAM_TIPOS 4
#define TAM_SERVICIOS 4
#define TAM_TRABAJOS 20
#define TAM_CLIENTES 10


int main()
{


    eNotebook listaDeNotebooks[TAM_NOTEBOOKS];
    eMarca listadoDeMarcas[TAM_MARCAS];
    eTrabajo listadoDeTrabajos[TAM_TRABAJOS];
    eTipo listadoDeTipos[TAM_TIPOS];
    eServicio listadoDeServicios [TAM_SERVICIOS];
    eCliente listadoDeClientes [TAM_CLIENTES];

    int proximoIdTrabajo = 100;
    int proximoIdNotebook = 1;
    int auxModificacion;
    int auxBaja;
    int opcionMenu;

    if(!inicializarNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !inicializarTrabajo(listadoDeTrabajos,TAM_TRABAJOS))
    {
        printf(""Sistema inicializado con exito!\n\n"");
    }else
    {
        printf(""Problema para inicializar el sistema\n"");
    }


    hardCodearTipos(listadoDeTipos,TAM_TIPOS);
    hardcodearMarcas(listadoDeMarcas,TAM_MARCAS);
    hardCodearServicios(listadoDeServicios,TAM_SERVICIOS);
    hardCodearClientes(listadoDeClientes,TAM_NOTEBOOKS);
    hardCodearTrabajos(listadoDeTrabajos,TAM_NOTEBOOKS);




    do
    {
        menu(&opcionMenu);

        switch(opcionMenu)
        {
            case 1:

                if(!altaNotebook(listaDeNotebooks,listadoDeClientes,listadoDeMarcas,listadoDeTipos,TAM_NOTEBOOKS,TAM_CLIENTES,proximoIdNotebook,TAM_TIPOS,TAM_MARCAS))
                {
                    proximoIdNotebook++;
                    printf(""ALTA EXITOSA!\n"");
                }
                else
                {
                    printf(""Problema para realizar el alta\n"");
                }

            break;
            case 2:
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {
                    auxModificacion = modificarNotebook(listaDeNotebooks,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_MARCAS,TAM_TIPOS);

                    if( auxModificacion == 0)
                    {
                        printf(""Modificacion exitosa\n"");
                    }
                    else if(auxModificacion == 2)
                    {
                        printf(""La modificacion ha sido cancelada por usuario\n"");
                    }
                    else
                    {
                        printf(""Se ha producido un error en la modificacion\n"");
                    }

                }else
                {
                    printf(""No hay notebooks en el listado\n"");
                }
            break;

            case 3 :
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {
                    auxBaja = bajaNotebook(listaDeNotebooks,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_TIPOS,TAM_MARCAS);

                    if( auxBaja == 0)
                    {
                        printf(""Modificacion exitosa\n"");
                    }
                    else if(auxBaja == 2)
                    {
                        printf(""La baja ha sido cancelada por usuario\n"");
                    }
                    else
                    {
                        printf(""Se ha producido un error en la baja\n"");
                    }

                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }

            break;

            case 4:
                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))
                {
                    ordenarNotebooks(listaDeNotebooks,TAM_NOTEBOOKS);
                    listarNotebook(listaDeNotebooks, listadoDeMarcas,listadoDeClientes,listadoDeTipos,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_MARCAS,TAM_TIPOS);


                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }

            break;

            case 5:
                system(""cls"");
                listarMarcas(listadoDeMarcas,TAM_MARCAS);
            break;

            case 6:
                system(""cls"");
                listarTipos(listadoDeTipos,TAM_TIPOS);

            break;

            case 7:
                system(""cls"");
                listarServicios(listadoDeServicios,TAM_SERVICIOS);
            break;

            case 8:
                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))
                {
                    if(altaTrabajo(listaDeNotebooks,listadoDeTrabajos,listadoDeServicios,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,
                            TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS,TAM_TIPOS,TAM_MARCAS,proximoIdTrabajo)==0)
                    {
                        proximoIdTrabajo++;
                        printf(""ALTA TRABAJO EXITOSA!\n"");
                    }else
                    {
                        printf(""Se produjo un error al ingresa el trabajo\n"");
                    }

                }else
                {
                    printf(""No hay notebooks en la lista, no se puede ingresar trabajo\n"");
                }

            break;

            case 9:
                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) &&
                    !verificarExistenciaTrabajo(listadoDeTrabajos,TAM_TRABAJOS))
                {
                    system(""cls"");
                    listarTrabajos(listadoDeTrabajos,listaDeNotebooks,listadoDeServicios,TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS);

                }else
                {
                    printf(""No se ingresaron trabajos o notebooks\n"");
                }

            break;

            case 10:
                system(""cls"");
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {

                    listarPorTipo(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeClientes,TAM_CLIENTES,TAM_MARCAS,listadoDeTipos,TAM_TIPOS);

                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }
            break;

            case 11:
                system(""cls"");
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {

                    listarPorMarca(listaDeNotebooks,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_MARCAS,TAM_TIPOS);

                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }
            break;

            case 12:
                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))
                {
                    contarNotebooksMarcaYTipo(listaDeNotebooks, TAM_NOTEBOOKS,listadoDeMarcas,TAM_MARCAS,listadoDeClientes, TAM_CLIENTES, listadoDeTipos, TAM_TIPOS);
                }
            break;

            case 13:
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {
                    system(""cls"");
                    listarNotebookXCadaMarca(listaDeNotebooks,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_TIPOS,TAM_MARCAS);

                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }

            break;

            case 14:
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {
                    system(""cls"");
                    marcaFavorita(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_MARCAS);
                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }

            break;

            case 15:
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {
                    system(""cls"");
                    notebookMasBarata(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_TIPOS,TAM_MARCAS);

                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }

            break;

            case 16:
                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))
                {
                    listarTrabajosXNotebook(listadoDeTrabajos,listaDeNotebooks,listadoDeClientes,listadoDeMarcas,listadoDeTipos,listadoDeServicios,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS,TAM_MARCAS,TAM_TIPOS);

                }
            break;
            case 17:
                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))
                {
                    mostrarSumaDeImportesXNotebook(listadoDeServicios, TAM_SERVICIOS, listadoDeTrabajos, listaDeNotebooks, TAM_NOTEBOOKS, listadoDeMarcas, listadoDeTipos, listadoDeClientes, TAM_CLIENTES, TAM_TIPOS, TAM_MARCAS, TAM_TRABAJOS);
                }else
                {
                    printf(""No hay notebooks o trabajos cargados\n"");
                }
            break;

            case 18:

                 if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))
                {
                    mostrarFechaYNotebookXServicio(listadoDeClientes,listadoDeTrabajos,TAM_TRABAJOS,listadoDeServicios,TAM_SERVICIOS,listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,TAM_MARCAS,listadoDeTipos,TAM_TIPOS,TAM_CLIENTES);

                }else
                {
                    printf(""No hay notebooks o trabajos cargados\n"");
                }

            break;

            case 19:

                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))
                {
                    mostrarServiciosXFecha(listadoDeTrabajos,TAM_TRABAJOS,listadoDeServicios,TAM_SERVICIOS);
                }else
                {
                    printf(""No hay notebooks o trabajos cargados\n"");
                }

            break;

        }

    }while(opcionMenu != 20);

    return 0;
}


",21,53,3474
"#include ""sort.h""

int partition(int *array, int lo, int hi, size_t size)
{
    int i, j, pivot, tmp;

    pivot = array[hi];
    i = lo;
    j = lo;
    while (j < hi)
    {
        if (array[j] <= pivot)
        {
            if (i != j)
            {
                tmp = array[i];
                array[i] = array[j];
                array[j] = tmp;
                print_array(array, size);
            }
            i++;

        }
        j++;
    }
    if (i != hi)
    {
        tmp = array[i];
        array[i] = array[hi];
        array[hi] = tmp;
        print_array(array, size);
    }
    return (i);
}

void quicksort(int *array, int lo, int hi, size_t size)
{
    int q;

    if (lo < hi)
    {
        q = partition(array, lo, hi, size);
        quicksort(array, lo, q - 1, size);
        quicksort(array, q + 1, hi, size);
    }

}


void quick_sort(int *array, size_t size)
{
    if (array == NULL || size < 2)
        return;
    quicksort(array, 0, size - 1, size);
}
",22,54,361
"void    fprime(int nb)
{
    int i;

    i = 2;
    if (nb == 1)
    {
        printf(""1"");
        return ;
    }
    while (nb >= i)
    {
        if (nb % i == 0)
        {
            printf(""%d"",i);
            if (nb != i)
            {
                printf(""%c"",'*');
                nb /= i;
                i--;
            }
        }
        i++;
    }
}
int     main(int ac, char **av)
{
    if (ac == 2)
        fprime(atoi(av[1]));
    printf(""\n"");
    return (0);
}
",23,55,181
"#include ""header.h""

static int  check_empty(t_m *m)
{
    if (m->ac > 1)
        return (0);
    else
        return (1);
}

static void loop(t_m *m, int x, int y)
{
    if (y == m->ac)
        final_print(m);
    else if (m->av[y][x] == 0)
        loop(m, 0, y + 1);
    else
    {
        if (is_enemy(m, x, y))
        {
            m->enemy = m->av[y][x];
            check_enemy(m, x, y);
        }
        loop(m, x + 1, y);
    }
}

void        execute(t_m *m)
{
    if (!check_empty(m))
        loop(m, 0, 1);
    else
        write(1, ""\n"", 1);
}
",23,56,248
"void    print_hex(unsigned char c)
{
    char    *radix;

    radix = ""0123456789abcdef"";
    write(1, &radix[c / 16], 1);
    write(1, &radix[c % 16], 1);
}

void    print_char(unsigned char c)
{
    if (c >= ' ' && c <= '~')
        write(1, &c, 1);
    else
        write(1, ""."", 1);
}

void    print_memory(const void *addr, size_t size)
{
    unsigned char   *adr;
    size_t  i;
    size_t  j;

    i = 0;
    j = 0;
    adr = (unsigned char*)addr;
    while (i < size)
    {
        j = 0;
        while (j < 16 && i+j < size)
        {
            print_hex(adr[i + j]);
            if (j%2)
                write(1,"" "",1);
            j++;
        }
        while (j < 16)
        {
            write(1, ""  "", 2);
            if (j%2)
                write(1, "" "",1);
            j++;
        }
        j = 0;
        while (j < 16 && i+j < size)
        {
            print_char(adr[i +j]);
            j++;
        }
        write(1,""\n"",1);
        i += 16;
    }
}
",23,57,399
"int     ft_abs(int a)
{
    if (a < 0)
        return (-a);
    return (a);
}

int     *ft_range(int start, int end)
{
    int     *tab;
    int     i;

    i = 0;
    if (!(tab = (int*)malloc(sizeof(int*) *ft_abs (start - end) + 1)))
        return (NULL);
    if (start > end)
    {
            while (start >= end)
        {
            tab[i] = start--;
            i++;
        }
        tab[i] = '\0';
    }
    else if (start < end)
    {
        while (start <= end)
        {
            tab[i] = start++;
            i++;
        }
        tab[i] = '\0';
    }
    return (tab);
}

int main()
{
    int a = 0;
    int b = -3;

    int     i;
    i = 0;
    int *tab =ft_range(a,b);
    while (tab[i])
    {
        printf(""%d "",tab[i]);
        i++;
    }
    printf(""%d "",tab[i]);
    i++;
    while (tab[i])
    {
        printf(""%d "",tab[i]);
        i++;
    }
    return (0);
}
",23,58,349
"#define MAX 10


void display(int array[MAX], int length);
void insertion_sort(int array[MAX], int length);

void main()
{
    int i = 0;
    int size = 0;
    
    printf(""\nEnter number of elements: \n"");
    scanf(""%d"", &size);
    int input_array[size];

    printf(""\nEnter the array elements...\n"");
    for(i=0; i<size; i++)
        scanf(""%d"", &input_array[i]);

    
    printf(""\nOriginal Array is as follows:- \n"");
    display(input_array, size);

    
    insertion_sort(input_array, size);

    
    printf(""\nAfter Insertion Sorting:- \n"");
    display(input_array, size);
    printf(""\n"");
}


void display(int array[MAX], int length)
{
    int i = 0;
    for(i=0; i<length; i++)
        printf(""%d\t"", array[i]);

    printf(""\n"");
}


void insertion_sort(int array[MAX], int length)
{
    int i, j, temp = 0;
    int size = length;

    for(i=1; i<size; i++)
    {
        j = i;
        while((array[j] < array[j-1]) && j>0)
        {
            
            temp = array[j];
            array[j] = array[j-1];
            array[j-1] = temp;
            j--;
        }
    }
}",24,59,403
"const int R = 3;
const int C = 3;


void display(int matrix[R][C]);
int find_sum_principal(int matrix[R][C]);
int find_sum_counter(int matrix[R][C]);

void main()
{
    int i, j = 0;
    int input_matrix[R][C];
    int sum_of_principal_diagonal = 0;
    int sum_of_counter_diagonal = 0;
    
    printf(""\nEnter the matrix elements...\n"");
    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            scanf(""%d"", &input_matrix[i][j]);
        }
    }

    
    printf(""\nInput Matrix is as follows:- \n"");
    display(input_matrix);

    
    sum_of_principal_diagonal = find_sum_principal(input_matrix);
    printf(""\nSum of Principal Diagonal = %d\n"", sum_of_principal_diagonal);

    
    sum_of_counter_diagonal = find_sum_counter(input_matrix);
    printf(""\nSum of Counter Diagonal = %d\n"", sum_of_counter_diagonal);
}


int find_sum_principal(int matrix[R][C])
{
    int rows = R;
    int columns = C;
    int i, j, sum_principal = 0;

    for(i=0; i<rows; i++)
    {
        for(j=0; j<columns; j++)
        {
            if(i == j)
                sum_principal += matrix[i][j];
            else
                continue;
        }
    }

    return sum_principal;
}


int find_sum_counter(int matrix[R][C])
{
    int rows = R;
    int columns = C;
    int i, j, sum_counter = 0;

    for(i=0; i<rows; i++)
    {
        for(j=columns-1; j>=0; j--)
        {
            if((i+j) == (columns-1))
                sum_counter += matrix[i][j];
            else
                continue;
        }
    }

    return sum_counter;
}


void display(int matrix[R][C])
{
    int i, j = 0;

    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            printf(""%d\t"", matrix[i][j]);
        }
        printf(""\n"");
    }
}",24,60,678
"#define MAXNAME 20
#define MAXABB 3

typedef struct month { 
    char name[MAXNAME];
    char abb[MAXABB];
    int days;
    int order;
} MONTH;

int main()
{
    MONTH months[12] = {
        {""Styczen"", ""JAN"", 31, 1},
        {""Luty"", ""FEB"", 28, 2},
        {""Marzec"", ""MAR"", 31, 3},
        {""Kwiecien"", ""APR"", 30, 4},
        {""Maj"", ""MAY"", 31, 5},
        {""Czerwiec"", ""JUN"", 30, 6},
        {""Lipiec"", ""JUL"", 31, 7},
        {""Sierpien"", ""AUG"", 31, 8},
        {""Wrzesien"", ""SEP"", 30, 9},
        {""Pazdziernik"", ""OCT"", 31, 10},
        {""Listopad"", ""NOV"", 30, 11},
        {""Grudzien"", ""DEC"", 31, 12},
    }; 

    puts(months[10].name);
    puts(months[10].abb);
    printf(""Liczba dni: %d\n"", months[10].days);
    printf(""Numer w roku: %d\n"", months[10].order);

    getchar();
    return 0;
}
",25,61,386
"double power(double x, int y);

int main()
{
    double userNumber;
    int userPower;
    printf(""Podaj liczb\251: "");
    scanf(""%lf"", &userNumber);
    printf(""Podaj pot\251g\251 ca\210kowit\245: "");
    scanf(""%d"", &userPower);
    printf(""%.3lf do pot\251gi %d wynosi %.3lf\n"", userNumber, userPower, power(userNumber, userPower));
    return 0;
}

double power(double x, int y){
    double result = x;
    if(x == 0) return 0;
    if(y == 0) return 1;
    if(y<0){
        result = 1/x;
       for(int i = y + 1; i < 0; i++){
        result = result * (1/x);
        }
        return result;
    }
    for(int i = 1; i < y; i++){
        result = result * x;
    }
    return result;
}
",25,62,279
"int main()
{
    float a, b, c;
    int licznik = 0;

    printf(""Podaj 1 liczbe: "");
    scanf(""%f"", &a);
    printf(""Podaj 2 liczbe: "");
    scanf(""%f"", &b);
    printf(""Podaj 3 liczbe: "");
    scanf(""%f"", &c);

    if(a >= b && a >= c ) {
        printf(""Najwieksza liczba to %.2f\n"", a);
        if(b >= c) {
            printf(""Najmniejsza liczba to %.2f\n"", c);
        } else {
            printf(""Najmniejsza liczba to %.2f\n"", b);
        }
    } else if ( b >= c) {
        printf(""Najwieksza liczba to %.2f\n"", b);
        if(a >= c) {
            printf(""Najmniejsza liczba to %.2f\n"", c);
        } else {
            printf(""Najmniejsza liczba to %.2f\n"", a);
        }
    } else {
        printf(""Najwieksza liczba to %.2f\n"", c);
        if(a >= b) {
            printf(""Najmniejsza liczba to %.2f\n"", b);
        } else {
            printf(""Najmniejsza liczba to %.2f\n"", a);
        }
    }

    printf(""\n"");
    return 0;
}
",25,63,370
"void changeCells(unsigned int, int * array1, int * array2, int * array3);

int main()
{
    int one[8] = {55, 6, -8, -8, 10, 22, 0, 121};
    int two[8] = {22, 1, -3, -4, 10, 21, 2, 233};
    int three[8] = {33, 4, -9, -9, 99, 99, 0, 400};
    unsigned int naturalNumber = 8;

    printf(""Elementy tablicy1: "");
    for(int i = 0; i < (sizeof(one)/sizeof(one[0])); i++){
        printf(""%d "", one[i]);
    }
    printf(""\nElementy tablicy2: "");
    for(int i = 0; i < (sizeof(two)/sizeof(two[0])); i++){
        printf(""%d "", two[i]);
    }
    printf(""\nElementy tablicy3: "");
    for(int i = 0; i < (sizeof(three)/sizeof(three[0])); i++){
        printf(""%d "", three[i]);
    }

    printf(""\n\nMieszanie tablic!!!\n\n"");
    changeCells(naturalNumber, one, two, three);

     printf(""Elementy tablicy1: "");
    for(int i = 0; i < (sizeof(one)/sizeof(one[0])); i++){
        printf(""%d "", one[i]);
    }
    printf(""\nElementy tablicy2: "");
    for(int i = 0; i < (sizeof(two)/sizeof(two[0])); i++){
        printf(""%d "", two[i]);
    }
    printf(""\nElementy tablicy3: "");
    for(int i = 0; i < (sizeof(three)/sizeof(three[0])); i++){
        printf(""%d "", three[i]);
    }

    getchar();;
    return 0;
}

void changeCells(unsigned int n, int * array1, int * array2, int * array3){
    int i = 0;
    for(i; i < n; i++){
        int a = array1[i], b = array2[i], c = array3[i];
        int max = (a>=b && a>=c) ? a : (b>=a&&b>=c) ? b : c;
        int min = (a<=b && a<=c) ? a : (b<=a&&b<=c) ? b : c;
        int mid = (c!=max && c!=min) ? c : (b!=max && b!=min) ? b : a;
        array1[i] = max;
        array2[i] = mid;
        array3[i] = min;
    }
};
",25,64,708
"int main()
{
    int array[10];
    int userNumber;
    int licznik = 0;
    int smallestNum;
    int smallestIndex;

    while(licznik < 10) {
        printf(""Podaj liczbe nr %d do tablicy: "", licznik + 1);
        scanf(""%d"", &userNumber);
        array[licznik] = userNumber;
        licznik++;
    }

    smallestNum = array[0];
    smallestIndex = 0;

    for(int i = 1; i < 10; i++){
        if(array[i] < smallestNum) {
            smallestNum = array[i];
            smallestIndex = i;
        }
    }

    printf(""\nNajmniejsza liczba w tablicy: %d\n"", smallestNum);
    printf(""Indeks najmniejszej liczby w tablicy: %d\n"", smallestIndex);

    printf(""\n"");
    return 0;
}
",25,65,245
"#include ""mytar.h""
       
char use[]=""Usage: tar -c|x -f file_mytar [file1 file2 ...]\n"";

int main(int argc, char *argv[]) {

  int opt, nExtra, retCode=EXIT_SUCCESS;
  flags flag=NONE;
  char *tarName=NULL;
  
  
  if(argc < 2){
    fprintf(stderr,""%s"",use);
    exit(EXIT_FAILURE);
  }
  
  while((opt = getopt(argc, argv, ""cxf:"")) != -1) {
    switch(opt) {
      case 'c':
        flag=(flag==NONE)?CREATE:ERROR;
        break;
      case 'x':
        flag=(flag==NONE)?EXTRACT:ERROR;
        break;
      case 'f':
        tarName = optarg;
        break;
      default:
        flag=ERROR;
    }
    
    if(flag==ERROR){
      fprintf(stderr,""%s"",use);
      exit(EXIT_FAILURE);
    }
  }
  
  
  if(flag==NONE || tarName==NULL) {
    fprintf(stderr,""%s"",use);
    exit(EXIT_FAILURE);
  }
  
  
  nExtra=argc-optind;
  
  
  switch(flag) {
    case CREATE:
      retCode=createTar(nExtra, &argv[optind], tarName);
      break;
    case EXTRACT:
      if(nExtra!=0){
        fprintf(stderr,""%s"",use);
        exit(EXIT_FAILURE);
      }
      retCode=extractTar(tarName);
      break;
    default:
      retCode=EXIT_FAILURE;
  }
  exit(retCode);
}
",26,66,471
"#include ""44b.h""
#include ""intcontroller.h""

void ic_init(void)
{
    
    rINTMOD = 0x0; 
    rINTCON = 0x7; 
    rINTMSK = ~(0x0); 
}

int ic_conf_irq(enum enable st, enum int_vec vec)
{
    int conf = rINTCON;

    if (st != ENABLE && st != DISABLE)
        return -1;

    if (vec == VEC)
    {
        
        
        unsigned int b = 1;
        b <<= 2;

        conf &= ~b;
    }
    else
    {
        
        
        unsigned int b = 1;
        b <<= 2;

        conf |= b;
    }

    if (st == ENABLE)
    {
        
        
        unsigned int b = 1;
        b <<= 1;

        conf &= ~b;
    }
    else
    {
        
        
        unsigned int b = 1;
        b <<= 1;

        conf |= b;
    }

    rINTCON = conf;
    return 0;
}

int ic_conf_fiq(enum enable st)
{
    int ret = 0;

    if (st == ENABLE)
    {
        
        
        unsigned int b = 1;

        ret &= ~b;
    }
    else if (st == DISABLE)
    {
        
        
        unsigned int b = 1;

        ret |= b;
    }
    else
    {
        ret = -1;
    }

    return ret;
}

int ic_conf_line(enum int_line line, enum int_mode mode)
{
    unsigned int bit = INT_BIT(line);

    if (line < 0 || line > 26)
        return -1;

    if (mode != IRQ && mode != FIQ)
        return -1;

    if (mode == IRQ)
    {
        
        unsigned int b = 1;
        b <<= bit;
        
        rINTMOD &= ~b;
    }
    else
    {
        
        unsigned int b = 1;
        b <<= bit;
        
        rINTMOD |= b;
    }

    return 0;
}

int ic_enable(enum int_line line)
{
    if (line < 0 || line > 26)
        return -1;

    
    unsigned int b = 1;
    b <<= (int) line;
    
    rINTMSK &= ~b;

    return 0;
}

int ic_disable(enum int_line line)
{
    if (line < 0 || line > 26)
        return -1;

    
    unsigned int b = 1;
    b <<= (int) line;
    
    rINTMSK |= b;
    
    return 0;
}

int ic_cleanflag(enum int_line line)
{
    int bit;

    if (line < 0 || line > 26)
        return -1;

    bit = INT_BIT(line);

    if (rINTMOD & bit)
    {
        
        
        
        unsigned int b = 1;
        b <<= bit;

        rI_ISPC |= b;
    }
    else
    {
        
        
        unsigned int b = 1;
        b <<= bit;

        rF_ISPC |= b;
    }

    return 0;
}



",26,67,920
"int main()
{
  int i,j,k,r1,c1,r2,c2,flag = 0;
  printf(""Enter Value of r1, c1, r2, c2\n"");
  scanf(""%d%d%d%d"",&r1,&c1,&r2,&c2);
  int m1[r1][c1], m2[r2][c2], sum = 0, mul[r1][c2];





  printf(""Enter value of Matrix1\n"");
  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      scanf(""%d"",&m1[i][j]);
    }
  }
 
  do
  {
    printf(""Enter value of Matrix2\n"");
    for(i=0; i<r2; i++)
    {
      for(j=0; j<c2; j++)
      {
        scanf(""%d"",&m2[i][j]);
      }
    }

    for(i=0; i<r1; i++)
    {
      for(j=0; j<c2; j++)
      {
        for(k=0; k<r2; k++)
    {
          sum = sum + m1[i][k]* m2[k][j];
    }
    mul[i][j] = sum;
    sum = 0;
      }
    }

    for(i=0; i<r2; i++)
    {
      for(j=0; j<c2; j++)
      {
        printf(""%d "",mul[i][j]);
      }
      printf(""\n"");
    }

    for(i=0; i<r2; i++)
    {
      for(j=0; j<c2; j++)
      {
        m1[i][j] = mul[i][j];
    mul[i][j] = 0;
      }
    }
    printf(""Enter 1 To Add more Matrix\n"");
    scanf(""%d"",&flag);
  }while(flag);

}
",27,68,535
"int main()
{

  int no,i,j,k,x,y,sum = 0,a,b;
  printf(""Enter the Range with lower and uppar limit to find out the Happy no.  or not"");
  scanf(""%d%d"",&a,&b);



  for(i=a; i<=b; i++)
  {
    while( i > 0 )
    {
      x = i % 10;
      sum = sum + (x*x);
      i = i / 10;
      if( i == 0)
      {
    sleep(1);
        printf(""sum is %d\n"",sum);
        if( sum == 1)
        {
          printf(""Number is Happy"");
          break;
        }
        i = sum;
        sum = 0;
      }
    }
 }
}
",27,69,214
"int main()
{
  int i,j,k,r1,c1,r2,c2, flag = 0;
  printf(""Enter Value of r1, c1, r2, c2\n"");
  scanf(""%d%d%d%d"",&r1,&c1,&r2,&c2);
  int m1[r1][c1], m2[r2][c2], sum = 0, mul[r1][c2];





  if( c1==c2 && r1==r2)
  {
    printf(""Enter value of Matrix1\n"");
    for(i=0; i<r1; i++)
    {
      for(j=0; j<c1; j++)
      {
        scanf(""%d"",&m1[i][j]);
      }
    }
  
    printf(""Enter value of Matrix2\n"");
    for(i=0; i<r2; i++)
    {
      for(j=0; j<c2; j++)
      {
        scanf(""%d"",&m2[i][j]);
      }
    }
  
    for(i=0; i<r1; i++)
    {
      for(j=0; j<c1; j++)
      {
        if(m1[i][j] == m2[i][j])
    {
      flag = 1;
    }
    else
        {
          flag = 2;         
      break;
      }
    }
  }
 }
 else
 {
   printf(""Comparison is Not Possible"");
 }

    if(flag == 1)
    {
      printf(""Matrix Matched"");
    }  
    else
    {
      printf(""Matrix didn't Matched"");
    }
}
",27,70,442
"int main()
{
      
      char server_response[256];

      
      int network_socket;
      network_socket = socket(AF_INET,SOCK_STREAM,0); 
                                                      
  
  
      
      struct sockaddr_in server_address;
      server_address.sin_family = AF_INET;         
      server_address.sin_port = htons(9000);       
      server_address.sin_addr.s_addr = INADDR_ANY; 
                                                   
  
  
      
      int connection_status;
      connection_status = connect(network_socket, (struct sockaddr*)&server_address, sizeof(server_address)); 


      
      if(connection_status == -1)
        printf(""Error occur during creating the connection.\n"");


      
      recv(network_socket, &server_response, sizeof(server_response),0);
  

      
      if(connection_status != -1)
        printf(""%s"",server_response);
  

      
      
  

      
      close(network_socket);
  
      return 0;
}






",27,71,296
"int main()
{
  int i,j,k,no=0,max=0;
  printf(""Enter Length of array\n"");
  scanf(""%d"",&no);



  int *a = (int*)(malloc(no * sizeof(int)));
  printf(""Enter Array numbers\n"");
  for(i=0; i<no; i++)
  {
   scanf(""%d"",&a[i]);
  }
  for(i=0; i<no; i++)
  {
    printf(""%d "",a[i]);
  }
  max = a[0];
  for(i=0; i<no; i++)
  {
    if(max < a[i])
    { 
      max = a[i];
    }
  }
  printf(""Value of Max is %d"",max);
  max+=1;
  int b[max];
  a = (int*)(realloc(a,max * sizeof(int)));
  for(i=0; i<max; i++)
  {
    b[i] = 0;
    if(i>=no)
    {
      a[i] = 0;
    }
  }

  
  for(i=0; i<=max; i++)
  {
    if(a[i] != 0)
    {
      b[a[i]] = b[a[i]] + 1;
    }
  }
  printf(""Numbers Repeated odd numbers of Times\n"");
  for(i=0; i<max; i++)
  {
    if(b[i] != 0)
    {
      printf(""%d is repeated %d times\n"",i,b[i]);
    }
  }
}
",27,72,424
"int main()
{
  int i=0,j=0,k=0, no=0,insert_no=0,insert_index=0,flag=0,count = 0i, count2 = 0;
  printf(""Enter Length of Array"");
  scanf(""%d"",&no);
  int array1[no-1], array2[no-1];




  count = no;
  for(i=0; i<no; i++)
  {
    scanf(""%d"",&array1[i]);
  }
  for(i=0; i<no; i++)
  {
    printf(""%d "",array1[i]);
  }
  
  for(i=0; i<no; i++)
  {
    for(j=i+1; j<no;)
    {
      if(array1[i] == array1[j])
      {
        for(k=j; k<count; k++)
    {
          array1[k] = array1[k+1];
    }
    no--;
      }
      else
      {
        j++;

      }
    }  
  }
  printf(""Value of count is %d and count2 is %d"",count,count2);
  printf(""Array after Removal of Repetation\n"");
  for(i=0; i<no; i++)
  {
    printf(""%d "",array1[i]);
  }

}
",27,73,354
"int main()
{
  int i=0,j=0,k=0, no=0;
  printf(""Enter Length of Array"");
  scanf(""%d"",&no);
  int array1[no], array2[no];





  for(i=0; i<no; i++)
  {
    scanf(""%d"",&array1[i]);
  }
  
  for(i=0; i<no; i++)
  {
    printf(""%d "",array1[i]);
  }
  
  for(i=no-1; i>=0; i--)
  {
    array2[j] = array1[i];
    j++;
  }
  printf(""\n"");
  for(i=0; i<no; i++)
  {
    printf(""%d "",array2[i]);
  }
}
",27,74,210
"void array_print(int arr[], int no)
{
  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
  printf(""\n"");
}

void intersection_array(int arr1[], int arr2[], int size_arr1, int size_arr2)
{
  int i = 0, j = 0;
  
  while(i<size_arr1 && j<size_arr2)
  {
    if(arr1[i] < arr2[j])
      i++;  
    if(arr1[i] > arr2[j])
      j++;
    if(arr1[i] == arr2[j])
    {
      printf(""%d "",arr2[j]); 
      j++;
      i++;
    }
  }
}

int main()
{
  int arr1[] = {1,2,3,7,8,9,10}, arr2[] = {2, 8, 10, 15, 16, 100} ,no,j=0,temp=0,mid=0,n=0; 
  int size_arr1 = sizeof(arr1)/sizeof(int), size_arr2 = sizeof(arr2)/sizeof(int);
  array_print(arr1,size_arr1);
  array_print(arr2,size_arr2);
  intersection_array(arr1,arr2,size_arr1,size_arr2);
}
",27,75,367
"int i, j, k, m = 1, n, a, b;
int min, mincost = 0, cost[9][9], parent[9];
int find(int i);
int uni(int i, int j);
int main()
{
    printf(""Implementation of Kruskal's Algorithm\n"");
    printf(""Enter the number of vertices: "");
    scanf(""%d"", &n);

    
    printf(""\nEnter the cost adjacency matrix: \n"");
    for (i = 1; i <= n; i++)
    {
        for (j = 1; j<= n; j++)
        {
            scanf(""%d"", &cost[i][j]);
            if (i == j)
            {
                cost[i][j] = 0;
            }
            else if(cost[i][j]==0)
            {
                cost[i][j] = 999;
            }
        }
    }
    
    printf(""The Adjacency Matrix is:\n"");
    for(i = 1; i <= n; i++)
    {
        for(j = 1; j <= n; j++)
        {
            printf(""%d\t"", cost[i][j]);
        }
        printf(""\n"");
    }
    printf(""The edges of Minimum Cost Spanning Tree are: "");
    while(m < n)
    {
        for(i = 1, min = 999; i <= n; i++)
        {
            for(j = 1; j <= n; j++)
            {
                if(cost[i][j] < min)
                {
                    min = cost[i][j];
                    a = i;
                    b = j;
                }
            }
        }
        if(uni(find(a), find(b)))
        {
            printf(""\n%d. edge (%d, %d) = %d\n"", m++, a, b, min);
            mincost += min;
        }
        cost[a][b] = cost[b][a] = 999;
    }
    printf(""\nMinimum Cost = %d\n"", mincost);
    return 0;
}
int find(int i)
{
    while(parent[i])
        i = parent[i];
    return i;
}
int uni(int i, int j)
{
    if(i != j)
    {
        parent[j] = i;
        return 1;
    }
    return 0;
}
",28,76,621
"#define true 1
#define false 0
#define iteracoes 30

double x,seno;
int i,j;

double fatorial (int i)
{
    double res = 1;
    for (int j=1; j<i; j++)
    {
        res = res*(j+1);
    }
    return res;
}

double potencia (double x, int i)
{
    double x0 = 1;
    for (int j=0; j<i; j++)
    {
        x0 *= x;
    }

    return x0;
}

int main()
{
    scanf (""%lf"",&x);
    seno = x;

    for (int i=3,j=1; j<=iteracoes; i=i+2,j++)
    {
        if ((j%2) == 0)
        {
            seno += potencia(x,i)/fatorial(i);
        }
        else
        {
            seno -= potencia(x,i)/fatorial(i);
        }    
        
    }

    printf (""%.10lf\n"", seno);
    return 0;
}",29,77,300
"int main()
{
    int n, imaior, imenor, tempm;
    float temp[100000], maior, menor, media = 0;

    scanf(""%i"", &n);

    for (int i = 0; i < n; i++)
    {
        scanf(""%f"", &temp[i]);

        if (i == 0)
        {
            maior = temp[i];
            imaior = i;
            menor = temp[i];
            imenor = i;
        }

        else if (temp[i] > maior)
        {
            maior = temp[i];
            imaior = i;
        }

        else if (temp[i] < menor)
        {
            menor = temp[i];
            imenor = i;
        }

        media += temp[i];
    }

    media /= n;

    printf(""%i %.1f\n%i %.1f\n%.1f\n"", imenor, menor, imaior, maior, media);

    for (int i=0; i<n; i++)
    {
        if (temp[i] >= media)
        {
            printf(""%i "", i);
        }
    }
    putchar('\n');

    return 0;
}",29,78,324
"typedef enum Ordem
{
    normal,
    inversa

} ordem_t;

void imprime_elemento(long int *vet, long int i, long int n, ordem_t ordem)
{
    printf(""%li "", *(vet + i));

    if (ordem == normal)
    {
        return (i < n-1) ? imprime_elemento(vet, i+1, n, ordem) : 0;
    }
    
    else if (ordem == inversa)
    {
        return (i > 0) ? imprime_elemento(vet, i-1, NULL, ordem) : 0;
    }
}


int main()
{
    long int n, *vet;

    do
    {
        printf(""\nDigite o tamanho do vetor: "");
        scanf(""%ld"", &n);
        getchar();
        system(""clear"");

    } while (n <= 0);

    vet = malloc(n * sizeof(long int));

    printf(""\nDigite os elementos do vetor:\n"");

    for (long int i = 0; i < n; i++)
    {
        printf(""\t-> "");
        scanf(""%ld"", vet + i);
        getchar();
    }

    printf(""\nOrdem normal:\n"");
    printf(""\t[ "");
    imprime_elemento(vet, 0, n, normal);
    printf(""]\n"");
    
    printf(""\nOrdem inversa:\n"");
    printf(""\t[ "");
    imprime_elemento(vet, n-1, NULL, inversa);
    printf(""]\n\n"");

    return 0;
}",29,79,423
"#define true 1
#define false 0

int main()
{
    char frase[200], termo[200];
    int i, j, tam_frase, tam_termo, busca = false, indice;
    puts(""\nInforme uma frase:"");
    scanf(""%[^\n]s"", frase);
    getchar();
    puts(""\nInforme um termo:"");
    scanf(""%[^\n]s"", termo);

    tam_frase = strlen(frase);
    tam_termo = strlen(termo);

    if (tam_frase >= tam_termo)
    {
        for (int i = 0; i < tam_frase; i++)
        {
            if ((frase[i] == termo[0]) && (busca == false))
            {
                busca = true;
                indice = i;
                for (int j = 0; j < tam_termo; j++)
                {
                    if ((frase[i + j] != termo[j]) && (busca == true))
                    {
                        busca = false;
                    }
                }
            }
        }
    }
    if (busca == true)
    {
        printf(""\n"");
        for (int k = 0; k < indice; k++)
        {
            printf(""%c"", frase[k]);
        }
        for (int l = (indice + (tam_termo)); l < tam_frase; l++)
        {
            printf(""%c"", frase[l]);
        }
        printf(""\n"");
    }
    else if (busca == false)
    {
        puts(""\nTermo nÃ£o encontrado na frase\n"");
    }
    return 0;
}",29,80,449
"#define true 1
#define false 0

int main()
{
    char str[1001], aux[1002], aux2[1002];
    int tam, tam2, tam3, busca;

    scanf(""%1001[^\n]s"", str);
    tam = strlen(str);

    for (int i = 1; i < tam; i++)
    {
        for (int j = 0; j <= i; j++)
        {
            aux[j] = str[j];
        }

        tam2 = strlen(aux);
        for (int j = 0; j < tam2; j++)
        {
            if ((int) aux[j] != (int) str[j])
                aux[j] = '\0';
            
            
        }
        tam2 = strlen(aux);
        printf(""%s %i\n"", aux, tam2);

        for (int j = tam2 - 2; j > 0; j--)
        {
            for (int k = 0; aux[j + k] != '\0'; k++)
            {
                
                for (int l = k; (l <= j + k)&&(str[l + tam2] != '\0'); l++)
                {
                    printf(""%c %c\n"", aux[l], str[l + j]);
                }
                putchar('\n');
            }
        }
        
        for (int j = tam2 - 1; j <= 0; j--)
        {
            aux[j] = '\0';
        } 
    }

    return 0;
}",29,81,403
"#define true 1
#define false 0

int main()
{
    char str0[1002], str[1002], aux[1002];
    int qtd = 0, tam, busca, busca1, tam0, tam1, tam2, p2, p1, k1, h1;

    scanf(""%1002[^\n]s"", str);

    tam = strlen(str);

    for (int i = (tam / 2); i > 1; i--)
    {
        for (int h = 0; str[(2 * i) + h - 1] != '\0'; h++)
        {
            h1 = h;
        }
        
        for (int h = h1; h >= 0; h--)
        {
            for (int j = 0; j < i; j++)
            {
                aux[j] = str[j + h];
            }

            tam0 = strlen(aux);
            for (int j = 0; j < tam0; j++)
            {
                if (((int)aux[j] < 97) || ((int)aux[j] > 122))
                    aux[j] = '\0';
            }

            tam0 = strlen(aux);
            

            printf(""\n%s %i\n"", aux, tam0);

            for (int k = 0; str[2 * i - 1 + k + h] != '\0'; k++)
            {
                k1 = k;
            }

            for (int k = k1; k >= 0; k--)
            {
                busca = true;
                for (int l = 0; ((l < tam0)&&(busca == true)); l++)
                {
                    

                    if (aux[l] != str[i + k + l + h])
                    {
                        busca = false;
                    }
                    p2 = i + k + l + h;
                    p1 = i + k + h;
                }

                if (busca == true)
                {
                    if (str[p2 + 1] == '\0')
                    {
                        for (int j = p2; j >= p1; j--)
                        {
                            str[j] = '\0';
                        }
                    }

                    else
                    {
                        for (int j = p1; (j <= p2)||(str[j+tam0] != '\0'); j++)
                        {                           
                            str[j] = str[j + tam0];
                            str[j + tam0] = '\0';

                            
                        }
                    }
                    qtd ++;
                    printf(""\ntrue %i %i\n%s\n"", p1, p2, aux);
                }

                
            }

            for (int j = tam0 - 1; j >= 0; j--)
            {
                aux[j] = '\0';
            }
        }
    }

    printf(""\n%s %li %i\n"", str, strlen(str), qtd);
    printf(""%li\n"", strlen(str) + qtd);

    return 0;
}",29,82,812
"typedef struct Pontos
{
    double x;
    double y;

} pontos_t;

double fatorial(int n);
void le_poligono(pontos_t *poligono, int n);
double perimetro(pontos_t *poligono, int n);
double area(pontos_t *poligono, int n);
double triangulos(pontos_t *poligono, int n, int m);

int main()
{
    int n;

    do
    {
        printf(""\nDigite o nÃºmero de lados do polÃ­gono (>= 3): "");
        scanf(""%li"", &n);

        if (n < 3) system(""clear"");

    } while (n < 3);

    pontos_t *poligono = malloc(n * sizeof(pontos_t));

    le_poligono(poligono, n);

    system(""clear"");

    printf(""\n\tPerÃ­metro = %lf\n"", perimetro(poligono, n));
    printf(""\n\tÃrea = %lf\n"", area(poligono, n));
    printf(""\n\tQuantidade de triÃ¢ngulos possÃ­veis = %.0lf\n\n"", triangulos(poligono, n, 3));

    free(poligono);

    return 0;
}

double fatorial(int n)
{
    return (n > 0) ? n * fatorial(n-1) : 1;
}

void le_poligono(pontos_t *poligono, int n)
{
    for (int i = 0; i < n; i++)
    {
        printf(""\nDigite as coordenadas do %liÂº ponto:\n"", i+1);

        printf(""\t-> Coordenada x: "");
        scanf(""%lf"", &poligono[i].x);
        getchar();

        printf(""\t-> Coordenada y: "");
        scanf(""%lf"", &poligono[i].y);
        getchar();
    }
}

double perimetro(pontos_t *poligono, int n)
{
    double perimetro = 0;

    for (int i = 0; i < n; i++)
    {
        if (i == n-1)
        {
            perimetro += sqrtf(powf(poligono[i].x - poligono[0].x,2) + powf(poligono[i].y - poligono[0].y,2));
        }

        else
        {
            perimetro += sqrtf(powf(poligono[i].x - poligono[i+1].x,2) + powf(poligono[i].y - poligono[i+1].y,2));
        }
    }

    return perimetro;
}

double area(pontos_t *poligono, int n)
{
    double area = 0;

    for (int i = 0; i < n; i++)
    {
        if (i == n-1)
        {
            area += (poligono[i].x * poligono[0].y) - (poligono[0].x * poligono[i].y);
        }

        else
        {
            area += (poligono[i].x * poligono[i+1].y) - (poligono[i+1].x * poligono[i].y);
        }
    }

    area /= 2;

    return (area < 0) ? area*(-1) : area;
}

double triangulos(pontos_t *poligono, int n, int m)
{
    double triangulos;

    triangulos = fatorial(n) / (fatorial(n-m) * fatorial(m));

    return triangulos;
}",29,83,983
"long int ackermann(int m, int n)
{
    if (m == 0) return n+1;

    else if (n == 0) return ackermann(m-1, 1);

    else return ackermann(m-1, ackermann(m, n-1));
}

int main()
{
    int m, n;

    do
    {
        printf(""\nFunÃ§Ã£o de Ackermann:\n"");
        printf(""\t-> m: "");
        scanf(""%i"", &m);
        getchar();
        printf(""\t-> n: "");
        scanf(""%i"", &n);
        getchar();
        system(""clear"");

    } while (n < 0 || m < 0);

    printf(""\nA(%i,%i) = %li\n\n"", m, n, ackermann(m,n));

    return 0;
}",29,84,226
"int main()
{
    int n, i, j, multiplo = 0;

    printf(""\nInforme os nÃºmeros inteiros positivos 'n','i' e 'j'.\nOnde 'n' serÃ¡ a quantidade de nÃºmeros em ordem crescentes,\nque sejam mÃºltiplos de 'i' ou de 'j' ou de ambos.\n"");
    printf(""\nInforme 'n': "");
    scanf(""%i"", &n);
    printf(""\nInforme 'i': "");
    scanf(""%i"", &i);
    printf(""\nInforme 'j': "");
    scanf(""%i"", &j);
    printf(""\n"");

    for (int qtd = 0; qtd < n;)
    {
        if (((multiplo % i) == 0) || ((multiplo % j) == 0))
        {
            if (qtd == (n - 1))
            {
                printf(""%i."", multiplo);
            }

            else
            {
                printf(""%i,"", multiplo);
            }

            qtd++;
        }

        multiplo++;
    }

    printf(""\n\n"");
    return 0;
}",29,85,305
"int main()
{
    int a;
    int b;
    float c;
    int d =0;
    int e = 0;
    int f = 0;
    int g = 0;

    printf(""Digite o tamanho da sequencia: "");
    scanf(""%d"",&a);

    for(b = 0; b < a; b++)
    {
        printf(""Digite os numeros: "");
        scanf(""%f"",&c);

        if(c >= 0 && c <= 25)
        {
            d++;
        }else if(c >= 26 && c <= 50)
        {
            e++;
        }else if(c >= 51 && c <= 75)
        {
            f++;
        }else if(c >= 76 && c <= 100)
        {
            g++;
        }

    }
        printf(""[0...25]: %d\n"",d);
        printf(""[26...50]: %d\n"",e);
        printf(""[51...75]: %d\n"",f);
        printf(""[76...100]: %d\n"",g);




}
",30,86,302
"int main()

{

    int vetor[5];
    int primos[5];
    int i,j;
    int c = 0;
    int t = 0;


        for(i = 0; i < 5; i++){


            printf(""Digite um numero %d: "",i+1);
            scanf(""%d"",&vetor[i]);

        }

        for(i= 0; i < 5; i++){

            c = 0;



            for(j =2; j < vetor[i]; j++){

                if(vetor[i]%j == 0){
                    c=1;
                    break;
                }

            }

        if(c == 0){
            primos[t] = vetor[i];
            t++;
        }
    }

    printf(""\n \n Numeros primos do array : \n \n"");

    for(i =0; i < t; i++){
        printf(""\n %d \n"",primos[i]);
    }


    system(""PAUSE"");
    return 0;
}
",30,87,287
"int main()
{

     int i, maior, menor,posmaior,x;
     int vet[10];
    for (i = 0 ; i < 10 ; i++){
        printf(""Digite o valor:\n"");
        scanf(""%d"",&vet[i]);

    }
    maior=vet[0];
    posmaior=0;
    for (i=1;i<10;i++){
        if(vet[i]>maior){
            maior=vet[i];
            posmaior=i;
        }
    }
    menor=vet[0];
    for(i=1;i<10;i++){
    if(vet[i]<menor){
    menor=vet[i];
        }
    }
         printf(""vetor: "");
    for (i = 0 ; i < 10 ; i++){

        printf(""%d "",vet[i]);

    }
    printf(""\nO maior valor eh: %d \n "",maior);
    printf(""Posicao: %d\n"",posmaior);



    return 0;
}
",30,88,276
"#include ""parser-tree.h""

void freeexpression(TERM* e);
void freeexpressionlist(EXPRESSIONLIST* el);
void freestatements(STATEMENT* s);

void freevardec(VARDEC* v) {
    freestrlist(v->names);
    free(v->debug);
    free(v);
}

void freevardecs(VARDEC* v) {
    VARDEC* next = v->next;
    freevardec(v);
    if(next != NULL)
        freevardecs(next);
}

void freeparameters(PARAMETER* p) {
    free(p->debug);
    PARAMETER* next = p->next;
    free(p);
    if(next != NULL)
        freeparameters(next);
}

void freearray(ARRAY* a) {
    freeexpression(a->exp);
    free(a);
}

void freesubroutcall(SUBROUTCALL* call) {
    if(call->parameters != NULL)
        freeexpressionlist(call->parameters);
    free(call->debug);
    free(call);
}

void freeexpression(TERM* e) {
    if(e->type == arrayitem)
        freearray(e->array);
    else if(e->type == innerexpression || e->type == unaryopterm)
        freeexpression(e->expression);
    else if(e->type == subroutcall)
        freesubroutcall(e->call);
    TERM* next = e->next;
    free(e);
    if(next != NULL)
        freeexpression(next);
}

void freeexpressionlist(EXPRESSIONLIST* el) {
    freeexpression(el->expression);
    EXPRESSIONLIST* next = el->next;
    free(el);
    if(next != NULL)
        freeexpressionlist(next);
}

void freelet(LETSTATEMENT* l) {
    if(l->arrayind != NULL)
        freeexpression(l->arrayind);
    freeexpression(l->expression);
    free(l);
}

void freecond(CONDSTATEMENT* cond) {
    freeexpression(cond->expression);
    if(cond->statements != NULL)
        freestatements(cond->statements);
    free(cond);
}

void freeif(IFSTATEMENT* st) {
    freecond(st->base);
    if(st->elsestatements != NULL)
        freestatements(st->elsestatements);
    free(st);
}

void freestatements(STATEMENT* s) {
    if(s->type == letstatement)
        freelet(s->letstatement);
    else if(s->type == ifstatement)
        freeif(s->ifstatement);
    else if(s->type == whilestatement)
        freecond(s->whilestatement);
    else if(s->type == dostatement)
        freesubroutcall(s->dostatement);
    else if(s->retstatement != NULL)
        freeexpression(s->retstatement);

    free(s->debug);
    STATEMENT* next = s->next;
    free(s);
    if(next != NULL)
        freestatements(next);
}

void freesubroutbody(SUBROUTBODY* b) {
    if(b->vardecs != NULL)
        freevardecs(b->vardecs);
    if(b->statements != NULL)
        freestatements(b->statements);
    free(b);
}

void freesubroutdecs(SUBROUTDEC* sr) {
    free(sr->debug);
    if(sr->parameters != NULL)
        freeparameters(sr->parameters);
    freesubroutbody(sr->body);
    SUBROUTDEC* next = sr->next;
    free(sr);
    if(next != NULL)
        freesubroutdecs(next);
}

void freeclassvardecs(CLASSVARDEC* cvd) {
    freevardec(cvd->base);
    CLASSVARDEC* next = cvd->next;
    free(cvd);
    if(next != NULL)
        freeclassvardecs(next);
}

void freetree(CLASS* c) {
    free(c->debug);

    if(c->vardecs != NULL)
        freeclassvardecs(c->vardecs);
    if(c->subroutdecs != NULL)
        freesubroutdecs(c->subroutdecs);

    CLASS* next = c->next;
    free(c);
    if(next != NULL)
        freetree(next);
}
",31,89,1174
"#include ""parser-util.h""
#include ""parser-structure.h""
#include ""parser-statements.h""

const char* classvartypesarr[] = { ""static"", ""field"" };
const char* vartypesarr[] = { ""int"", ""char"", ""boolean"" };
const char* subroutclassesarr[] = { ""constructor"", ""function"", ""method"" };
mkstrlist(classvartypes, classvartypesarr);
mkstrlist(vartypes, vartypesarr);
mkstrlist(subroutclasses, subroutclassesarr);




bool isprimitive(TOKEN* tk);
char* parsetype(PARSER* p);
int parsepossibilities(PARSER* p, STRINGARRAY* poss);


CLASS* parseclass(PARSER* p);
CLASSVARTYPE parseclassvartype(PARSER* p);
CLASSVARDEC* parseclassvardec(PARSER* p);
CLASSVARDEC* parseclassvardecs(PARSER* p);
SUBROUTCLASS parsesubroutclass(PARSER* p);
SUBROUTDEC* parsesubroutdec(PARSER* p, CLASS* c);
SUBROUTDEC* parsesubroutdecs(PARSER* p, CLASS* c);
PARAMETER* parseparameter(PARSER* p);
PARAMETER* parseparameters(PARSER* p);
SUBROUTBODY* parsesubroutbody(PARSER* p);
void parsevardeccommon(PARSER* p, VARDEC* v);
VARDEC* parsevardec(PARSER* p);
VARDEC* parsevardecs(PARSER* p);





bool isprimitive(TOKEN* tk) {
    if(tk->type == keyword)
        if(existsinarray(&vartypes, tk->token))
            return true;
    return false;
}

char* parsetype(PARSER* p) {
    if(p->current->type != identifier && p->current->type != keyword)
        unexpected(p);

    char* result = p->current->token;
    next(p);
    return result;
}

int parsepossibilities(PARSER* p, STRINGARRAY* poss) {
    for(int i = 0; i < poss->size; i++)
        if(equals(p, poss->items[i]))
            return i;
    return -1;
}


CLASS* parseclass(PARSER* p) {
    checkcontent(p, ""class"");

    CLASS* class = (CLASS*)malloc(sizeof(CLASS));

    class->debug = getdebug(p);

    class->name = parseidentifier(p);

    checkcontent(p, ""{"");

    class->vardecs = parseclassvardecs(p);

    class->subroutdecs = parsesubroutdecs(p, class);

    checkcontent(p, ""}"");

    if(p->current != NULL)
        unexpected(p);

    return class;
}

CLASSVARTYPE parseclassvartype(PARSER* p) {
    return parsepossibilities(p, &classvartypes);
}

CLASSVARDEC* parseclassvardec(PARSER* p) {
    CLASSVARTYPE classvartype = parseclassvartype(p);
    if(classvartype == -1)
        return NULL;
    next(p);

    CLASSVARDEC* classvardec = (CLASSVARDEC*)malloc(sizeof(CLASSVARDEC));
    classvardec->type = classvartype;

    classvardec->base = (VARDEC*)malloc(sizeof(VARDEC));

    parsevardeccommon(p, classvardec->base);

    return classvardec;
}

CLASSVARDEC* parseclassvardecs(PARSER* p) {
    CLASSVARDEC* head = parseclassvardec(p);
    CLASSVARDEC* curr = head;
    CLASSVARDEC* nextc;
    while(nextc = parseclassvardec(p), nextc != NULL) {
        curr->next = nextc;
        curr = nextc;
    }
    if(curr != NULL)
        curr->next = NULL;
    return head;
}

SUBROUTCLASS parsesubroutclass(PARSER* p) {
    return parsepossibilities(p, &subroutclasses);
}

SUBROUTDEC* parsesubroutdec(PARSER* p, CLASS* c) {
    SUBROUTCLASS subroutclass = parsesubroutclass(p);
    if(subroutclass == -1)
        return NULL;

    next(p);
    SUBROUTDEC* subroutdec = (SUBROUTDEC*)malloc(sizeof(SUBROUTDEC));
    subroutdec->subroutclass = subroutclass;

    if(differs(p, ""void""))
        subroutdec->type = parsetype(p);
    else {
        subroutdec->type = p->current->token;
        next(p);
    }

    subroutdec->debug = getdebug(p);

    subroutdec->name = parseidentifier(p);

    checkcontent(p, ""("");
    subroutdec->parameters = parseparameters(p);
    checkcontent(p, "")"");

    checkcontent(p, ""{"");
    subroutdec->body = parsesubroutbody(p);
    checkcontent(p, ""}"");

    subroutdec->class = c;

    return subroutdec;
}

SUBROUTDEC* parsesubroutdecs(PARSER* p, CLASS* c) {
    SUBROUTDEC* head = parsesubroutdec(p, c);
    SUBROUTDEC* curr = head;
    SUBROUTDEC* nexts;
    while(nexts = parsesubroutdec(p, c), nexts != NULL) {
        curr->next = nexts;
        curr = nexts;
    }
    if(curr != NULL)
        curr->next = NULL;
    return head;
}

PARAMETER* parseparameter(PARSER* p) {
    if(equals(p, "")""))
        return NULL;
    PARAMETER* param = (PARAMETER*)malloc(sizeof(PARAMETER));
    param->debug = getdebug(p);
    param->primitive = isprimitive(p->current);
    param->type = parsetype(p);
    param->name = parseidentifier(p);
    return param;
}

PARAMETER* parseparameters(PARSER* p) {
    PARAMETER* head = parseparameter(p);
    PARAMETER* curr = head;
    PARAMETER* nextp;
    while(equals(p, "","")) {
        next(p);
        nextp = parseparameter(p);
        if(nextp == NULL)
            unexpected(p);
        curr->next = nextp;
        curr = curr->next;
    }
    if(curr != NULL)
        curr->next = NULL;
    return head;
}

SUBROUTBODY* parsesubroutbody(PARSER* p) {
    SUBROUTBODY* subroutbody = (SUBROUTBODY*)malloc(sizeof(SUBROUTBODY));
    subroutbody->vardecs = parsevardecs(p);
    subroutbody->statements = parsestatements(p);

    return subroutbody;
}

void parsevardeccommon(PARSER* p, VARDEC* v) {
    v->typeclass = p->current->type;
    v->primitive = isprimitive(p->current);
    v->type = parsetype(p);

    STRINGLIST* currstr = (STRINGLIST*)malloc(sizeof(STRINGLIST));
    v->names = currstr;

    v->debug = getdebug(p);

    v->names->content = parseidentifier(p);

    while(!strcmp(p->current->token, "","")) {
        next(p);
        STRINGLIST* nextstr = (STRINGLIST*)malloc(sizeof(STRINGLIST));
        nextstr->content = parseidentifier(p);
        currstr->next = nextstr;
        currstr = nextstr;
    }
    currstr->next = NULL;

    checkcontent(p, "";"");
}


VARDEC* parsevardec(PARSER* p) {
    if(strcmp(p->current->token, ""var""))
        return NULL;
    next(p);

    VARDEC* vardec = (VARDEC*)malloc(sizeof(VARDEC));

    parsevardeccommon(p, vardec);

    return vardec;
}

VARDEC* parsevardecs(PARSER* p) {
    VARDEC* head = parsevardec(p);
    VARDEC* curr = head;
    VARDEC* nextv;
    while(nextv = parsevardec(p), nextv != NULL) {
            curr->next = nextv;
        curr = nextv;
    }
    if(curr != NULL)
        curr->next = NULL;
    return head;
}
",31,90,2293
"#include ""compiler-util.h""

LINE* opvarraw(SCOPE* s, char* op, VAR* v) {
    char* tokens[] = { op, v->memsegment, itoa(v->index) };
    LINE* ln = mksimpleln(tokens, strcount(tokens));
    free(tokens[2]);
    return ln;
}

LINE* pushvarraw(SCOPE* s, VAR* v) {
    return opvarraw(s, ""push"", v);
}

LINE* pushvar(SCOPE* s, DEBUGINFO* d, const char* name) {
    return opvarraw(s, ""push"", getvarmustexist(s, d, name));
}

LINE* popvar(SCOPE* s, DEBUGINFO* d, const char* name) {
    return opvarraw(s, ""pop"", getvarmustexist(s, d, name));
}

LINE* poptemp() {
    char* poptemp[] = { ""pop"", ""temp"", ""0"" };
    return mksimpleln(poptemp, strcount(poptemp));
}

LINE* popthatadd() {
    char* popthatadd[] = { ""pop"", ""pointer"", ""1"" };
    return mksimpleln(popthatadd, strcount(popthatadd));
}

LINE* onetoken(char* str) {
    LINE* ln = mkline(1);
    addtoken(ln, ezheapstr(str));
    ln->next = NULL;
    return ln;
}

LINE* mksimpleln(char** tokens, int count) {
    LINE* ln = mkline(count);
    for(int i = 0; i < count; i++)
        addtoken(ln, ezheapstr(tokens[i]));
    ln->next = NULL;
    return ln;
}
",31,91,472
"struct node{
    int data;
    int key;
    struct node*next;
};
struct node*head;

void createList(int n)
{
    struct node*mehedi;
    struct node*temp;
    int data, i;
    head=(struct node*)malloc(sizeof(struct node));
    printf(""Enter node data:"");
    scanf(""%d"", &data);
    head->data=data;
    head->next=NULL;
    temp=head;
    for(i=2;i<=n; i++)
    {
        mehedi=(struct node*)malloc(sizeof(struct node));
        printf(""Enter node data:"");
        scanf(""%d"", &data);
        mehedi->data=data;
        mehedi->next=NULL;
        temp->next=mehedi;
        temp=temp->next;
    }
}

void print(){
struct node*temp;
temp=head;
while(temp!=NULL)
{
    printf(""%d\n"", temp->data);
    temp=temp->next;
}
}
void search(int key)
{
    struct node *temp;
    temp=head;
    while(temp!=NULL)
    {
        if(temp->data==key)
        {
            printf(""Key found :)"");
            temp=temp->next;
            break;
        }
        else
        {
            printf(""Key not found :("");
            break;
        }
    }
}
int main()
{
    int n, key;
    printf(""Enter the total number of nodes: "");
    scanf(""%d"", &n);
    createList(n);
    printf(""display:\n"");
    print();
    printf(""srch:"");
    scanf(""%d"", &key);
    search(key);
    return 0;


}

",32,92,448
"int main()
{
    int n;
    printf(""Enter The Number :"");
    scanf(""%d"", &n);
    if (n>=80 && n<=100)
    {
        printf(""\nEarned Grade is >> A+"");
    }
    else if (n>=70 && n<=79)
    {
        printf(""\nEarned Grade is >> A"");
    }
    else if(n>=60 && n<=69)
    {
        printf(""\nEarned Grade is >> A-"");
    }
    else if (n>=50 && n<=59)
    {
        printf(""\nEarned Grade is >> B"");
    }
    else if (n>=40 && n<=49)
    {
        printf(""\nEarned Grade is >> C"");
    }
    else
    {
        printf(""\nEarned Grade is >> F"");
    }
    return 0;

}
",32,93,239
"int main()
{
    int
    a[5][5], b[5][5], sum=0;
    int r, c;
    for(r=0; r<=2; r++)
        {
            for(c=0; c<=2; c++)
            {
                scanf(""%d"", &a[r][c]);
            }
        }
        printf(""\n"");
        for(r=0; r<=2; r++)
        {
            for(c=0; c<=2; c++)
            {
                scanf(""%d"", &b[100][100]);
            }
        }
        printf(""\n"");
        for(r=0; r<=2; r++)
        {
            for(c=0; c<=2; c++)
            {
                sum=a[r][c];
            }
            printf(""%d"", sum);
        }
        return 0;
}
",32,94,224
"void * cuentaLineas(void * fichero);

int main(int argc, char * argv[]){

    int nHilos = argc-1; 
    int total = 0; 
    int * nLineas=0;
    pthread_t hilos[nHilos];

    for (int i = 0; i < nHilos; i++){ pthread_create(&hilos[i], NULL, cuentaLineas, (void*) argv[i+1]); } 
    

    for (int i = 0; i < nHilos; i++) {

        pthread_join(hilos[i], (void**) &nLineas); 

        printf(""El fichero %s tiene %i lineas\n"", argv[i+1], *nLineas);

        total += *nLineas; 
    }

    printf(""Entre todos los ficheros suman %i lineas\n"", total);
    
}

void * cuentaLineas(void * fichero){

    printf(""contando el fichero: %s\n"", fichero);

    int * nLineas = malloc(sizeof(int)); 

    FILE * f = fopen(fichero, ""r""); 

    *nLineas = 0; 

    char s[200]; 

    while(fgets(s, 200, f)){ *nLineas = *nLineas + 1; } 
        
    pthread_exit((void *) nLineas); 

}",33,95,387
"typedef struct {        
         
  int *vector;          
  int hebras;           
  int i;                
  
} Vector;


void rellenaVector(int *vector){        

    srand(time(NULL));   

    for (int i = 0; i < 10; ++i){ vector[i] = ((rand()%9)+1); }
}

void imprimeVector (int *vector){       

    printf(""El vector es:\n"");
    printf(""| "");

    for (int i = 0; i < 10; ++i){ printf(""%d | "",vector[i]); }

    printf(""\n"");
}


void * sumaVector (void* v){            

    int *suma = malloc(sizeof(int));    
    *suma = 0;                          
    
    Vector *estructura;                 
    estructura = (Vector*) v;           
    

    if(estructura->hebras == 2){                                    

        for(int j=estructura->i; j<(estructura->i)+5; j++){         

            *suma = *suma + estructura->vector[j];
        }

        estructura->i = estructura->i + 5;
        pthread_exit((void**)suma);                                 
    }


    else{                                                           
        
        for(int j=estructura->i; j<(estructura->i)+2; j++){         
            
            *suma = *suma + estructura->vector[j];
        }

        estructura->i = estructura->i + 2;
        pthread_exit((void**)suma);                                 
    }

}


int main(int argc, char const *argv[]){
  
    Vector *v = malloc(sizeof(Vector));                 
    
    if (argc != 2){                                     
        
        printf(""Error, llame al programa asi:\n"");
        printf(""./ej3 2 o /ej3 5\n"");

        exit(EXIT_FAILURE);
    }

    v->hebras = atoi(argv[1]);                          
    v->i = 0;                                           

    if (v->hebras != 2 && v->hebras != 5){              
        
        printf(""Error, llame al programa asi:\n"");
        printf(""./ej3 2 o /ej3 5\n"");

        exit(EXIT_FAILURE);
    }
    
    v->vector = (int *)malloc (10*sizeof(int));         
    rellenaVector(v->vector);                           
    imprimeVector(v->vector);                           

    pthread_t thread[v->hebras];                        
    int *sumaLinea, suma = 0;                           
    
    printf(""Se pasaran a crear %d hebras para sumar los valores del vector\n"", v->hebras);

    for (int i = 0; i < v->hebras; i++){                
        
        if(pthread_create(&(thread[i]), NULL, (void*) sumaVector, (void*) v)){

            printf(""Error en la creacion de la hebra. Codigo de error %d\n"", errno);

            exit(EXIT_FAILURE);
        }

        if(pthread_join(thread[i], (void**) &sumaLinea)){

            printf(""Error al esperar la hebra. Codigo de error %d\n"", errno);

            exit(EXIT_FAILURE);
        } 

        suma = suma + *sumaLinea;                       
    }

    printf(""La suma de los numeros de todos los valores es: %d\n"", suma);

    exit(EXIT_SUCCESS);
}",33,96,954
"void displayMat(int mat[][20],int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
        {
        for(j=0;j<c;j++)
        printf(""%d "",mat[i][j]);
        printf(""\n"");
        }
    }
void SubMat(int mat1[][20],int mat2[][20],int r,int c)
    {
    int i,j,temp[20][20];
            
    for(i=0;i<r;i++)
        {
        for(j=0;j<c;j++)
            temp[i][j]=mat1[i][j]-mat2[i][j];
        }
    displayMat(temp,r,c);
    }
int main()
    {
    int i,j,r,c,mat1[20][20],mat2[20][20];
    printf(""\n Enter the row & col. for two matrix(Both should be same): "");
    scanf(""%d%d"",&r,&c);
    
    if(r!=c)
        printf(""\n For Addition matrix should be square"");
    else
        {       
        printf(""\n Enter the first matrix \n"");
        for(i=0;i<r;i++)
        for(j=0;j<c;j++)                
        scanf(""%d"",&mat1[i][j]);
        
        printf(""\n Enter the second matrix \n"");
        for(i=0;i<r;i++)
        for(j=0;j<c;j++)                
        scanf(""%d"",&mat2[i][j]);
        
        printf(""\n The addtion of two matrix is:\n"");
        SubMat(mat1,mat2,r,c);
        }
    return 0;
    }
",34,97,462
"void listFilesRecursively(char *path);


int main()
{
    
    char path[100];

    
    printf(""Enter path to list files: "");
    scanf(""%s"", path);

    listFilesRecursively(path);

    return 0;
}



void listFilesRecursively(char *basePath)
{
    char path[1000];
    struct dirent *dp;
    DIR *dir = opendir(basePath);

    
    if (!dir)
        return;

    while ((dp = readdir(dir)) != NULL)
    {
        if (strcmp(dp->d_name, ""."") != 0 && strcmp(dp->d_name, "".."") != 0)
        {
            printf(""%s\n"", dp->d_name);

            
            strcpy(path, basePath);
            strcat(path, ""/"");
            strcat(path, dp->d_name);

            listFilesRecursively(path);
        }
    }

    closedir(dir);
}
",34,98,272
"int main()
    {
    int n,i,j;
    
    printf(""Enter how many row"");
    scanf(""%d"",&n);
    
    for(i=1;i<=n;i++)
        {
        for(j=1;j<=n-i;j++)
            printf("" "");
        for(j=1;j<=i;j++)
            {
                if(i==j||i==n||j==1)
                    printf(""*"");
                else
                    printf("" "");
            }
        printf(""\n"");
        }
    printf(""\n\n"");
        return 0;
    }   







",34,99,163
"void displayMat(int mat[][20],int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
        {
        for(j=0;j<c;j++)
        printf(""%-3d "",mat[i][j]);
        printf(""\n"");
        }
    }
void ScalarProduct(int mat[][20],int r,int c,int s)
    {
    int i,j;
            
    for(i=0;i<r;i++)
        {
        for(j=0;j<c;j++)
            mat[i][j]=s*mat[i][j];
        }
    displayMat(mat,r,c);
    }
int main()
    {
    int i,j,r,c,mat1[20][20],s;
    printf(""\n Enter the row & col. for two matrix(Both should be same): "");
    scanf(""%d%d"",&r,&c);
    
    if(r!=c)
        printf(""\n For Addition matrix should be square"");
    else
        {       
        printf(""\n Enter the first matrix \n"");
        for(i=0;i<r;i++)
        for(j=0;j<c;j++)                
        scanf(""%d"",&mat1[i][j]);
        
        printf(""\n Enter the scalar to be multiplied: "");
        scanf(""%d"",&s);
        
        printf(""\n The addtion of two matrix is:\n"");
        ScalarProduct(mat1,r,c,s);
        }
    return 0;
    }
",34,100,407
"int main()
    {
        FILE *fptr,*fp=NULL;
        int ch;
        fptr=fopen(""File18.txt"",""r"");
        fp=fopen(""File18Final.txt"",""w"");
        
        if(fptr==NULL||fp==NULL)
            {
                printf(""\n Unable to open file"");
                exit(1);
            }
        
        while((ch=fgetc(fptr))!=EOF)
            {
                if(isupper(ch))
                    ch=tolower(ch);
                else if(islower(ch))
                    ch=toupper(ch);
                
                fputc(ch,fp);
            }
        
        printf(""\n Successfully Toggled"");
        fclose(fptr);
        fclose(fp);
        
        remove(""File18.txt"");
        
        rename(""File18Final.txt"",""File18.txt"");
        
        return 0;
    }
",34,101,242
"void displayarr(int arr[],int len);
int main()
    {
    int *arr,i,n,sum=0;
    printf(""Enter how many numbers you want to store into array"");
    scanf(""%d"",&n);
    
    arr=(int *)malloc((n)*sizeof(int *));   
    
    printf(""Enter %d elements"",n);
    for(i=0;i<n;i++)
    scanf(""%d"",&arr[i]);
    
    for(i=0;i<n;i++)
        sum=sum+arr[i];
        
    printf(""Sum of the array=%d"",sum);
    return 0;
    }

void displayarr(int arr[],int len)
    {
    int i;
    printf(""After delete operation the array is:\n"");
    for(i=0;i<len;i++)
        printf(""%d "",arr[i]);

    }
",34,102,227
"int r,c;
void Display(int **mat3)
    {
    int i,j;
    for(i=0;i<r;i++)
        {
        for(j=0;j<c;j++)
            printf(""%-3d "",mat3[i][j]);
        printf(""\n"");
        }
    }
int **Sum(int **mat1,int **mat2,int **mat3)
    {
    int i,j;
    for(i=0;i<r;i++)
        {
        for(j=0;j<c;j++)
            {
            mat3[i][j]=mat1[i][j]+mat2[i][j];
            }
        }
    return mat3;
    }
int main()
    {
        int i,j,m,n;
        int **mat1,**mat2,**mat3;
        printf(""Enter the row & col. of the first matrix "");
        scanf(""%d%d"",&r,&c);
        printf(""Enter the row & col. of the second matrix "");
        scanf(""%d%d"",&m,&n);
        if((r==m)&&(c==n))
            {
                mat1=(int **)malloc(r*sizeof(int *));       
                                                
                mat2=(int **)malloc(r*sizeof(int *));
            
                mat3=(int **)malloc(r*sizeof(int *));       
        
                for(i=0;i<r;i++)
                mat1[i]=(int *)malloc(c*sizeof(int));   
            
                for(j=0;j<r;j++)
                mat2[j]=(int *)malloc(c*sizeof(int));
        
                for(j=0;j<r;j++)
                mat3[j]=(int *)malloc(c*sizeof(int));
        
                printf(""\n Enter the first matrix "");
                for(i=0;i<r;i++)
                    {
                    for(j=0;j<c;j++)
                    scanf(""%d"",&mat1[i][j]);
                    }
                printf(""\n Enter the second matrix"");
                for(i=0;i<r;i++)
                    {
                    for(j=0;j<c;j++)
                    scanf(""%d"",&mat2[i][j]);
                    }
        
                Sum(mat1,mat2,mat3);
                
                printf(""\n The Resultant matrix is \n"");
                Display(mat3);
                
                free(mat1);
                free(mat2);
                free(mat3);
                }
        else
        printf(""Please enter same row & col of the two matrix ..."");
    return 0;
    }   

",34,103,678
"void displayMat(int **mat,int r,int c);
int traceMat(int **mat,int r,int c);

int main()
    {
    int i,j,r,c,**mat,sum=0;
    printf(""Enter the row & col. of the matrix "");
    scanf(""%d%d"",&r,&c);
    
    if(r!=c)
        printf(""For determinant matrix should be square"");
    else
        {
        mat=(int **)malloc(r*sizeof(int *));        
                                                
        for(i=0;i<r;i++)
            mat[i]=(int *)malloc(c*sizeof(int ));   
    
        printf(""\n Enter the matrix \n"");
        for(i=0;i<r;i++)
            {
            for(j=0;j<c;j++)
                {
                scanf(""%d"",&mat[i][j]);
                sum=sum+mat[i][j]*mat[i][j];
                
                }
            }
            
        printf(""The matrix is:\n"");
        displayMat(mat,r,c);
    
        printf(""\nTrace of the matrix is= %d"",traceMat(mat,r,c));

        printf(""\nNorm of the matrix is=%f"",sqrt((double)sum));
        
        }
    return 0;
    }   
void displayMat(int **mat,int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
        {
        for(j=0;j<c;j++)
        printf(""%d "",mat[i][j]);
        printf(""\n"");
        }
    }
int traceMat(int **mat,int r,int c)
    {
    int i,t=0;
    for(i=0;i<r;i++)
        t=t+mat[i][i];
    return t;
    }
    
",34,104,481
"void create();
void display();
void count();
struct node
{
    int data;
    struct node *next;
    struct node *pre;
};
struct node *head=0;
int main()
{
    int choice;
    printf(""function of doubly circular linked list \n"");
    printf(""1.implementation \n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of elements in the linked list\n"");
    printf(""4.exit\n"");
    printf(""enter the choice ="");
    scanf(""%d"",&choice);
    while(choice!=5)
    {
        switch(choice)
        {
            case 1:printf(""implementation \n"");
            create();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of elements in the linked list\n"");
            count();
            break;
            case 4:printf(""exit\n"");
            exit(0);
            break;
            default:printf(""wrong choice\n"");
            break;
        }
        printf(""enter the choice ="");
        scanf(""%d"",&choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->pre=0;
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
            newnode->next=newnode;
            newnode->pre=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            newnode->next=head;
            temp=newnode;
            head->pre=temp;
        }
    printf(""do you need to continue(0,1)?\nenter 0 to stop and 1 to continue ="");
    scanf(""%d"",&choice);
    }

}
void display()
{
    struct node *temp;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    temp=head;
    while(temp->next!=head)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""%d "",temp->data);
    printf(""\n"");
}
void count()
{
    struct node *temp;
    int c=0;
    temp=head;
    do
    {
        c++;
        temp=temp->next;
    }while(temp!=head);
    printf(""the number of elements in the linked list is %d\n"",c);
}
",35,105,699
"void create();
void display();
void count();
struct node
    {
        int data;
        struct node *next;
    };
    struct node *head=0;
int main()
{
    printf(""Linked list functions\n"");
    int choice;
    printf(""1.implementation\n"");
    printf(""2.display\n"");
    printf(""3.count\n"");
    printf(""4.exit\n"");
    printf(""enter the choice ="");
    scanf(""%d"",& choice);
    while(choice!=5)
    {
    switch(choice)
    {
    case 1:printf(""implementation \n"");
    create();
    break;
    case 2:printf(""display\n"");
    display();
    break;
    case 3:printf(""count the element in linked list\n"");
    count();
    break;
    case 4:exit(0);
    break;
    default: printf(""wrong choice \n"");
    break;
    }
    printf(""enter the choice ="");
    scanf(""%d"",& choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
            printf(""enter the data = "");
            scanf(""%d"",& newnode->data);
            newnode->next=0;
       if(head==0)
       {
            head=temp=newnode;
       }
       else
       {
            temp->next=newnode;
            temp=newnode;
       }
       printf(""do you need to continue (0,1)?\n0 to stop 1 to continue the element in the linked list ="");
           scanf(""%d"",& choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    while(temp!=0)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""\n"");
}
void count()
{
    struct node *temp;
    int count=0;
    temp=head;
    while(temp!=0)
    {
        count++;
        temp=temp->next;
    }
    printf(""the number of element in linked list is %d"", count);
    printf(""\n"");
}
",35,106,576
"void create();
void display();
struct node
{
    int data;
    struct node *next;
    struct node *pre;
};
struct node *head=0;
int main()
{
    printf(""function of doubly circular linked list \n"");
    printf(""1.implementation \n"");
    create();
    printf(""2.display the linked list\n"");
    display();

}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->pre=0;
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
            newnode->next=newnode;
            newnode->pre=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            newnode->next=head;
            temp=newnode;
            head->pre=temp;
        }
    printf(""do you need to continue(0,1)?\nenter 0 to stop and 1 to continue ="");
    scanf(""%d"",&choice);
    }

}
void display()
{
    struct node *temp;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    temp=head;
    while(temp->next!=head)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""%d "",temp->data);
    printf(""\n"");
}
",35,107,423
"void create();
void display();
void count();
void insert_beg();
struct node
{
    int data;
    struct node *next;
    struct node *pre;
};
struct node *head=0;
int main()
{
    int choice;
    printf(""function of doubly circular linked list \n"");
    printf(""1.implementation \n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of elements in the linked list\n"");
    printf(""4.insert the element at the beginning position in the linked list\n"");
    printf(""5.exit\n"");
    printf(""enter the choice ="");
    scanf(""%d"",&choice);
    while(choice!=6)
    {
        switch(choice)
        {
            case 1:printf(""implementation \n"");
            create();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of elements in the linked list\n"");
            count();
            break;
            case 4: printf(""insert the element at the beginning position in the linked list\n"");
            insert_beg();
            break;
            case 5:printf(""exit\n"");
            exit(0);
            break;
            default:printf(""wrong choice\n"");
            break;
        }
        printf(""enter the choice ="");
        scanf(""%d"",&choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->pre=0;
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
            newnode->next=newnode;
            newnode->pre=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            newnode->next=head;
            temp=newnode;
            head->pre=temp;
        }
    printf(""do you need to continue(0,1)?\nenter 0 to stop and 1 to continue ="");
    scanf(""%d"",&choice);
    }

}
void display()
{
    struct node *temp;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    temp=head;
    while(temp->next!=head)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""%d "",temp->data);
    printf(""\n"");
}
void count()
{
    struct node *temp;
    int c=0;
    temp=head;
    do
    {
        c++;
        temp=temp->next;
    }while(temp!=head);
    printf(""the number of elements in the linked list is %d\n"",c);
}
void insert_beg()
{
    struct node *newnode,*temp;
    newnode=(struct node*)malloc(sizeof(struct node));
    printf(""enter the data ="");
    scanf(""%d"",&newnode->data);
    temp=head;
    while(temp->next!=head)
    {
        temp=temp->next;
    }
    head->pre=newnode;
    temp->next=newnode;
    newnode->next=head;
    newnode->pre=temp;
    head=newnode;
}
",35,108,893
"void create();
void display();
int count();
void insert_beg();
void insert_end();
void insert_at_pos();
void delete_beg();
void delete_end();
void delete_at_pos();
struct node
{
    int data;
    struct node *next;
    struct node *pre;
};
struct node *head=0;
int main()
{
    int  choice;
    printf(""function of doubly circular linked list \n"");
    printf(""1.implementation \n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of elements in the linked list\n"");
    printf(""4.insert the element at the beginning position in the linked list\n"");
    printf(""5.insert the element at the last position in the linked list\n"");
    printf(""6.insert the element at any position in the linked list\n"");
    printf(""7.delete the element from the beginning position of linked list\n"");
    printf(""8.delete the element from the last position of linked list\n"");
    printf(""9.delete the element from any position of linked list\n"");
    printf(""10.exit\n"");
    printf(""enter the choice ="");
    scanf(""%d"",&choice);
    while(choice!=11)
    {
        switch(choice)
        {
            case 1:printf(""implementation \n"");
            create();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of elements in the linked list\n"");
            count();
            break;
            case 4: printf(""insert the element at the beginning position in the linked list\n"");
            insert_beg();
            break;
            case 5:printf(""insert the element at the last position in the linked list\n"");
            insert_end();
            break;
            case 6:printf(""insert the element at any position in the linked list\n"");
            insert_at_pos();
            break;
            case 7:printf(""delete the element from the beginning position of linked list\n"");
            delete_beg();
            break;
            case 8:printf(""delete the element from the last position of linked list\n"");
            delete_end();
            break;
            case 9:printf(""delete the element from any position of linked list\n"");
            delete_at_pos();
            break;
            case 10:printf(""exit\n"");
            exit(0);
            break;
            default:printf(""wrong choice\n"");
            break;
        }
        printf(""enter the choice ="");
        scanf(""%d"",&choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->pre=0;
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
            newnode->next=newnode;
            newnode->pre=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            newnode->next=head;
            temp=newnode;
            head->pre=temp;
        }
    printf(""do you need to continue(0,1)?\nenter 0 to stop and 1 to continue ="");
    scanf(""%d"",&choice);
    }

}
void display()
{
    struct node *temp;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    temp=head;
    while(temp->next!=head)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""%d "",temp->data);
    printf(""\n"");
}
int count()
{
    struct node *temp;
    int c=0;
    temp=head;
    do
    {
        c++;
        temp=temp->next;
    }while(temp!=head);
    printf(""the number of elements in the linked list is %d\n"",c);
    return c;
}
void insert_beg()
{
    struct node *newnode,*temp;
    newnode=(struct node*)malloc(sizeof(struct node));
    printf(""enter the data ="");
    scanf(""%d"",&newnode->data);
    temp=head;
    while(temp->next!=head)
    {
        temp=temp->next;
    }
    head->pre=newnode;
    temp->next=newnode;
    newnode->next=head;
    newnode->pre=temp;
    head=newnode;
}
void insert_end()
{
    struct node *newnode,*temp;
    newnode=(struct node*)malloc(sizeof(struct node));
    printf(""enter the data ="");
    scanf(""%d"",&newnode->data);
    temp=head;
    while(temp->next!=head)
    {
        temp=temp->next;
    }
    temp->next=newnode;
    newnode->pre=temp;
    newnode->next=head;
    head->pre=newnode;
}
void insert_at_pos()
{
    struct node *newnode,*temp;
    int i=1;
    int pos;
    int leg=count();
    printf(""enter the position in between the 1 to %d\n"",leg);
    printf(""enter the position ="");
    scanf(""%d"",&pos);
    if(pos>leg)
    {
        printf(""invalied position\n"");
    }
    else
    {
        temp=head;
        while(i<pos-1)
        {
            temp=temp->next;
            i++;
        }
        newnode=(struct node*)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->next=temp->next;
        newnode->pre=temp;
        temp->next->pre=newnode;
        temp->next=newnode;
    }
}
void delete_beg()
{
    struct node *temp,*firstnode;
    firstnode=head;
    temp=head;
    while(temp->next!=head)
    {
        temp=temp->next;
    }
    head->next->pre=head->pre;
    temp->next=firstnode->next;
    head=firstnode->next;
    free(firstnode);
}
void delete_end()
{
    struct node *temp,*endnode;
    temp=head;
    while(temp->next!=head)
    {
        temp=temp->next;
    }
    endnode=temp;
    temp->pre->next=head;
    head->pre=endnode->pre;
    free(endnode);
}
void delete_at_pos()
{
    struct node *temp;
    temp=head;
    int i=1;
    int pos;
    int leg=count();
    printf(""enter the position in between the 1 to %d\n"",leg);
    printf(""enter the position ="");
    scanf(""%d"",&pos);
    while(i<pos)
    {
        temp=temp->next;
        i++;
    }
    temp->pre->next=temp->next;
    temp->next->pre=temp->pre;
    free(temp);
}
",35,109,1870
"#include ""sort.h""


void merge_sort(int *array, size_t size)
{
    int low;
    int high;
    int *temp;

    low = 0;
    high = size - 1;

    temp = malloc(sizeof(int) * size);
    if (temp == NULL)
        return;

    sort(array, low, high, temp);

    free(temp);
}


void sort(int *array, int low, int high, int *temp)
{
    int mid;

    if (low < high)
    {
        mid = (low + high) / 2;
        sort(array, low, mid, temp);
        sort(array, mid + 1, high, temp);
        merge(array, low, mid, high, temp);
    }
}


void merge(int *array, int low, int mid, int high, int *temp)
{
    int left;
    int right;
    int i;

    left = low;
    right = mid + 1;

    printf(""Merging...\n"");
    printf(""[left]: "");
    print_array(&array[low], mid + 1);
    printf(""[right]: "");
    print_array(&array[mid + 1], high - mid);

    for (i = low; left <= mid && right <= high; i++)
    {
        if (array[left] <= array[right])
            temp[i] = array[left++];
        else
            temp[i] = array[right++];
    }

    while (left <= mid)
        temp[i++] = array[left++];

    while (right <= high)
        temp[i++] = array[right++];

    for (i = 0; i <= high; i++)
        array[i] = temp[i];

    printf(""[Done]: "");
    print_array(temp, i);
}


int len(int *array)
{
    int i;

    for (i = 0; array[i] != '\0'; i++)
        ;

    return (i);
}
",36,110,527
"#include ""sort.h""


void _swap(int *a, int *b)
{
    int tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;
}

void backward_insertion(int *array, int gap, int act)
{
    int i;

    for (i = act - gap; i >= 0; i -= gap, act -= gap)
    {
        if (array[i] > array[act])
            _swap(&array[i], &array[act]);
        else
            break;
    }
}

void shell_sort(int *array, size_t size)
{
    unsigned int gap = 1, i, j;

    if (array == NULL)
        return;
    if (size < 2)
        return;
    while (gap < size / 3)
        gap = gap * 3 + 1;

    while (gap > 0)
    {
        for (i = 0, j = gap; j < size; i++, j++)
        {
            if (array[i] > array[j])
            {
                _swap(&array[i], &array[j]);
                backward_insertion(array, gap, i);
            }
        }
        print_array(array, size);
        gap /= 3;
    }
}
",36,111,339
"void gotoxy(int x, int y);
int i;
int main()
{
    gotoxy(0,0); printf(""%c"",218);
    for(i = 1; i <= 69; i++)
    {
        gotoxy(i,0); printf(""%c"",196);
    }
    gotoxy(70,0); printf(""%c"",191);
    for(i = 1; i <= 15; i++)
    {
        gotoxy(0,i); printf(""%c"",179);
    }
     for(i = 1; i <= 15; i++)
    {
        gotoxy(70,i); printf(""%c"",179);
    }
    gotoxy(0,16); printf(""%c"",192);
    gotoxy(70,16); printf(""%c"",217);
    for(i = 1; i <= 69; i++)
    {
        gotoxy(i,16); printf(""%c"",196);
    }
    gotoxy(19,1); printf(""%c"",218);
    for(i = 20; i <= 50; i++)
    {
        gotoxy(i,1); printf(""%c"",196);
    }
    gotoxy(51,1); printf(""%c"",191);
    gotoxy(19,2); printf(""%c"",179);
    gotoxy(51,2); printf(""%c"",179);
    gotoxy(19,3); printf(""%c"",192);
    gotoxy(51,3); printf(""%c"",217);
    for(i = 20; i <= 50; i++)
    {
        gotoxy(i,3); printf(""%c"",196);
    }
    gotoxy(19,5); printf(""%c"",218);
    for(i = 20; i <= 50; i++)
    {
        gotoxy(i,5); printf(""%c"",196);
    }
    gotoxy(51,5); printf(""%c"",191);
    gotoxy(19,6); printf(""%c"",179);
    gotoxy(51,6); printf(""%c"",179);
    gotoxy(19,7); printf(""%c"",192);
    gotoxy(51,7); printf(""%c"",217);
    for(i = 20; i <= 50; i++)
    {
        gotoxy(i,7); printf(""%c"",196);
    }
    gotoxy(19,9); printf(""%c"",218);
    for(i = 20; i <= 50; i++)
    {
        gotoxy(i,9); printf(""%c"",196);
    }
    gotoxy(51,9); printf(""%c"",191);
    gotoxy(19,10); printf(""%c"",179);
    gotoxy(51,10); printf(""%c"",179);
    gotoxy(19,11); printf(""%c"",192);
    gotoxy(51,11); printf(""%c"",217);
    for(i = 20; i <= 50; i++)
    {
        gotoxy(i,11); printf(""%c"",196);
    }
    
    gotoxy(19,13); printf(""%c"",218);
    for(i = 20; i <= 50; i++)
    {
        gotoxy(i,13); printf(""%c"",196);
    }
    gotoxy(51,13); printf(""%c"",191);
    gotoxy(19,14); printf(""%c"",179);
    gotoxy(51,14); printf(""%c"",179);
    gotoxy(19,15); printf(""%c"",192);
    gotoxy(51,15); printf(""%c"",217);
    for(i = 20; i <= 50; i++)
    {
        gotoxy(i,15); printf(""%c"",196);
    }

    
    gotoxy(6,3); printf(""%c"",218);
    gotoxy(7,3); printf(""%c"",196);
    gotoxy(8,3); printf(""%c"",191);
    for (i = 4; i <= 13; i++)
    {
        gotoxy(6,i); printf(""%c"",179);
    }
     for (i = 4; i <= 13; i++)
    {
        gotoxy(8,i); printf(""%c"",179);
    }
    gotoxy(6,14); printf(""%c"",192);
    gotoxy(7,14); printf(""%c"",196);
    gotoxy(8,14); printf(""%c"",217);
    gotoxy(7,4); printf(""T"");
    gotoxy(7,5); printf(""A"");
    gotoxy(7,6); printf(""X"");
    gotoxy(7,7); printf(""I"");
    gotoxy(7,9); printf(""A"");
    gotoxy(7,10); printf(""E"");
    gotoxy(7,11); printf(""R"");
    gotoxy(7,12); printf(""E"");
    gotoxy(7,13); printf(""O"");


    printf(""\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"");
    system(""pause"");
}

void gotoxy(int x, int y)
{
    COORD coord;
    coord.X = x;
    coord.Y = y;
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);
}
",37,112,1505
"#include ""sort.h""


void bubble_sort(int *array, size_t size)
{
    size_t i = 0, sz = size;
    int flag = 0, tmp = 0;

    if (array == NULL || size < 2)
        return;
    while (1)
    {
        i = 0;
        while (i < (sz - 1))
        {
            if (array[i + 1] < array[i])
            {
                tmp = array[i];
                array[i] = array[i + 1];
                array[i + 1] = tmp;
                print_array(array, size);
                flag = 1;
            }
            i++;
        }
        if (flag == 0)
            break;
        flag = 0;
        sz--;
    }
}
",38,113,214
"#include ""sort.h""

void selection_sort(int *array, size_t size)
{
    size_t i, j, idx_min;
    int tmp = 0;

    if (array == NULL || size < 2)
        return;
    i = 0;
    while (i < size - 1)
    {
        idx_min = i;
        j = i + 1;
        while (j < size)
        {
            if (array[j] < array[idx_min])
                idx_min = j;
            j++;
        }
        if (idx_min != i)
        {
            tmp = array[i];
            array[i] = array[idx_min];
            array[idx_min] = tmp;
            print_array(array, size);
        }
        i++;
    }
}
",38,114,211
"typedef struct BMPImagem
{
    int   width;
    int   height;
    char *data;
}BMPImage;

#define MAX_NO_TEXTURES 6

GLuint texture_id[MAX_NO_TEXTURES];

char* filenameArray[MAX_NO_TEXTURES] = {
        ""earthTexture.bmp"",
        ""surface1.bmp"",
        ""surface2.bmp"",
        ""surface3.bmp"",
        ""surface4.bmp"",
        ""surface7.bmp""
};

GLUquadricObj *obj;

GLfloat angleX = 0.0f;
GLfloat angleY = 0.0f;
float angulo = 20.0;

double phi = 0.0;
double theta = 0.0;
double r = 0.5;
int n = 450;
int texture_index = 0;

double s1 = 2.5;
double s2 = 2.5;

double rt = 0.25;
double Rt = 0.75;

int stop = 0;
float cameraY=0.5;

void getBitmapImageData( char *pFileName, BMPImage *pImage )
{
    FILE *pFile = NULL;
    unsigned short nNumPlanes;
    unsigned short nNumBPP;
    int i;

    if( (pFile = fopen(pFileName, ""rb"") ) == NULL )
        printf(""ERROR: getBitmapImageData - %s not found.\n"", pFileName);

    fseek( pFile, 18, SEEK_CUR );

    if( (i = fread(&pImage->width, 4, 1, pFile) ) != 1 )
        printf(""ERROR: getBitmapImageData - Couldn't read width from %s.\n "", pFileName);

    if( (i = fread(&pImage->height, 4, 1, pFile) ) != 1 )
        printf(""ERROR: getBitmapImageData - Couldn't read height from %s.\n "", pFileName);

    if( (fread(&nNumPlanes, 2, 1, pFile) ) != 1 )
        printf(""ERROR: getBitmapImageData - Couldn't read plane count from %s.\n"", pFileName);

    if( nNumPlanes != 1 )
        printf(""ERROR: getBitmapImageData - Plane count from %s.\n "", pFileName);

    if( (i = fread(&nNumBPP, 2, 1, pFile)) != 1 )
        printf( ""ERROR: getBitmapImageData - Couldn't read BPP from %s.\n "", pFileName);

    if( nNumBPP != 24 )
        printf(""ERROR: getBitmapImageData - BPP from %s.\n "", pFileName);

    fseek( pFile, 24, SEEK_CUR );

    int nTotalImagesize = (pImage->width * pImage->height) * 3;

    pImage->data = (char*) malloc( nTotalImagesize );

    if( (i = fread(pImage->data, nTotalImagesize, 1, pFile) ) != 1 )
        printf(""ERROR: getBitmapImageData - Couldn't read image data from %s.\n "", pFileName);

    char charTemp;
    for( i = 0; i < nTotalImagesize; i += 3 )
    {
        charTemp = pImage->data[i];
        pImage->data[i] = pImage->data[i+2];
        pImage->data[i+2] = charTemp;
    }
}

void CarregaTexturas()
{
    BMPImage textura;

    glGenTextures(MAX_NO_TEXTURES, texture_id);
                                
    int i;
    for ( i=0; i<MAX_NO_TEXTURES; i++ ) {
        getBitmapImageData( filenameArray[i], &textura);
        glBindTexture(GL_TEXTURE_2D, texture_id[i]);
        glTexImage2D(GL_TEXTURE_2D, 0, 3, textura.width, textura.height, 0, GL_RGB, GL_UNSIGNED_BYTE, textura.data);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
    }
}

void initTexture (void)
{

    glEnable ( GL_TEXTURE_2D );
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

    CarregaTexturas();

}

void lightning(){
    GLfloat light0_pos[] = {2.0f, 2.0f, 2.0f, 1.0f};
    GLfloat white[] = {1.0f, 1.0f, 1.0f, 1.0f};
    GLfloat black[] = {0.0f, 0.0f, 0.0f, 1.0f};

    glLightfv(GL_LIGHT0,GL_POSITION,light0_pos);
    glLightfv(GL_LIGHT0,GL_AMBIENT,black);
    glLightfv(GL_LIGHT0,GL_DIFFUSE,white);
    glLightfv(GL_LIGHT0,GL_SPECULAR,white);

    GLfloat light1_pos[] = {-2.0f, 0.0f, 0.0f, 1.0f};
    glLightfv(GL_LIGHT1,GL_POSITION,light1_pos);
    glLightfv(GL_LIGHT1,GL_DIFFUSE, white);
    glLightfv(GL_LIGHT1,GL_SPECULAR, white);
    GLfloat direction[] = {1.0f, 0.0f, 0.0f};
    glLightfv(GL_LIGHT1,GL_SPOT_DIRECTION,direction);
    glLightf(GL_LIGHT1,GL_SPOT_CUTOFF,45.0f);          
    glLightf(GL_LIGHT1,GL_SPOT_EXPONENT,0.1f);             

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_LIGHT1);
}

void init(void)
{
    glEnable ( GL_COLOR_MATERIAL );
    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
    glEnable(GL_DEPTH_TEST);

    glShadeModel(GL_SMOOTH);
    glEnable(GL_NORMALIZE);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluLookAt(0.0, 2.0, 6.0,
              0.0, 0.0, 0.0,
              0.0, 1.0, 0.0);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45.0, 1.0, 2.0, 8.0);
    glViewport(0, 0, 700, 700);

    lightning();
}

void desenhaEsferaComTextura(){
     obj = gluNewQuadric();
     gluQuadricTexture(obj,GL_TRUE);
     gluSphere(obj,0.1,50,50);
}

void esferaQuadrica(){
    int i,j;
    glClear(GL_COLOR_BUFFER_BIT);
    for(i=0;i<n;i++){
        glBegin(GL_POINTS);
            for(j=0;j<n;j++){
                glVertex3f(r*cos(phi)*cos(theta),r*cos(phi)*sin(theta),r*sin(phi));
                phi = phi + (2*M_PI)/n;
            }
        glEnd();
        phi = 0.0;
        theta = theta+(2*M_PI)/n;
    }
}

void desenhaPlanetaCentral(){
    glPushMatrix();
    GLfloat diffuse[4];
    GLfloat specular[4];
    GLfloat ns;
    diffuse[0] = 1.0;
    diffuse[1] = 1.0;
    diffuse[2] = 1.0;
    diffuse[3] = 1.0f;
    specular[0] = 1;
    specular[1] = 1;
    specular[2] = 1;
    specular[3] = 1.0f;
    ns = 50.0f;
    glMaterialfv(GL_FRONT,GL_AMBIENT_AND_DIFFUSE,diffuse);
    glMaterialfv(GL_FRONT,GL_SPECULAR,specular);
    glMaterialf(GL_FRONT, GL_SHININESS, ns);
    glBindTexture(GL_TEXTURE_2D, 0);
        glRotatef(angulo,0.0,1.0,0.0);
        esferaQuadrica();
    glPopMatrix();
    
}

void desenhaSatelites(){
    float v1 = 1.2;
    float v2 = 1.4;

        
    glPushMatrix();
        glBindTexture(GL_TEXTURE_2D, texture_id[2]);
        glRotatef(angulo*v1,0.0,1.0,0.0);
        glTranslatef(-0.48,0.0,1.0);
        desenhaEsferaComTextura();
    glPopMatrix();

        
    glPushMatrix();
        glBindTexture(GL_TEXTURE_2D, texture_id[4]);
        glRotatef(-angulo*v2,0.0,1.0,0.0);
        glTranslatef(-0.8,0.0,2.0);
        desenhaEsferaComTextura();
    glPopMatrix();
}

void display() {
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        glMatrixMode(GL_MODELVIEW);
        desenhaPlanetaCentral();
        desenhaSatelites();

        glFlush();
}

void rotacionarPlaneta(int key, int x, int y){
     switch (key){
        case GLUT_KEY_UP :
            glMatrixMode(GL_MODELVIEW);
            glLoadIdentity();
            gluLookAt(0.0, 2.0, 6.0,
                        0.0, 0.0, 0.0,
                        0.0, 1.0, 0.0);

            glMatrixMode(GL_PROJECTION);
            glLoadIdentity();
            gluPerspective(45.0, 1.0, 2.0, 8.0);
           break ;
        case GLUT_KEY_DOWN :
            glMatrixMode(GL_MODELVIEW);
            glLoadIdentity();
            gluLookAt(0.0, -7.0, 3.0,
                    0.0, 0.0, 0.0,
                    0.0, 1.0, 0.0);
            glMatrixMode(GL_PROJECTION);
            glLoadIdentity();
            gluPerspective(45.0, 1.0, 2.0, 8.0);
           break ;
        case GLUT_KEY_LEFT :
           angulo-=15;
           break ;
        case GLUT_KEY_RIGHT :
           angulo+=15;
           break ;
        default:
           break;
     }
     glutPostRedisplay() ;
}

void executaAnimacao(){
    if(stop == 0){
        angulo+=6;
        glutTimerFunc(100, executaAnimacao, 1);
        glutPostRedisplay();
    }
}

void mouse(int botao, int estado, int x, int y)
{
    switch (botao)
    {
    case GLUT_LEFT_BUTTON:
        stop = 1;
        break;
    case GLUT_RIGHT_BUTTON:
        stop = 0;
                glutTimerFunc(100, executaAnimacao, 1);
        glutPostRedisplay();
        break;
    default:
        break;
    }
    glutPostRedisplay();
}

int main(int argc, char *argv[]){
    glutInit(&argc,argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowPosition(50,50);
    glutInitWindowSize(700,700);
    glutCreateWindow(""Planetas"");
    glutDisplayFunc(display);
    glutSpecialFunc(rotacionarPlaneta);
    glutTimerFunc(5, executaAnimacao, 1);
    glutMouseFunc(mouse);
    init();
    initTexture();
    glutMainLoop();
    return 0;
}",39,115,3467
"int raise(int b, int n);
long l_raise(int base, int n);
void main(){
  printf(""\n"");
  printf(""Range values from standard headers:\n"");
  printf(""\t -Signed-\n"");
  printf(""char  : [%d, %d]\n"", CHAR_MIN, CHAR_MAX);
  printf(""short : [%d, %d]\n"", SHRT_MIN, SHRT_MAX);
  printf(""int   : [%d, %d]\n"", INT_MIN, INT_MAX);
  printf(""long  : [%ld, %ld]\n\n"", LONG_MIN, LONG_MAX);
  printf(""\t -Unsigned-\n"");
  printf(""char  : [0, %d]\n"", UCHAR_MAX);
  printf(""short : [0, %d]\n"", USHRT_MAX);
  printf(""int   : [0, %u]\n"", UINT_MAX);
  printf(""long  : [0, %lu]\n"", ULONG_MAX);
  printf(""\n"");
  
  printf(""Range values by direct computation:\n"");
  printf(""\t -Signed-\n"");
  printf(""char  : [-%d, %d]\n"", raise(2, sizeof(char)*CHAR_BIT - 1 ) ,
     raise(2, sizeof(char)*CHAR_BIT - 1) - 1);
  
  printf(""short : [-%d, %d]\n"", raise(2, sizeof(short)*CHAR_BIT - 1 ) ,
     raise(2, sizeof(short)*CHAR_BIT - 1) - 1);
  
  printf(""int   : [%d, %d]\n"", raise(2, sizeof(int)*CHAR_BIT - 1 ) ,
     raise(2, sizeof(int)*CHAR_BIT - 1) - 1);

  printf(""long  : [-%lu, %lu]\n\n"",
     l_raise(2, sizeof(long)*CHAR_BIT - 1 ) ,
     l_raise(2, sizeof(long)*CHAR_BIT - 1) - 1);

  printf(""\t -Unsigned-\n"");
  printf(""char  : [0, %d]\n"", raise(2, sizeof(char)*CHAR_BIT) - 1);
  printf(""short : [0, %d]\n"", raise(2, sizeof(short)*CHAR_BIT) - 1);
  printf(""int   : [0, %u]\n"", raise(2, sizeof(int)*CHAR_BIT) - 1);
  printf(""long  : [0, %lu]\n"", (unsigned long)(raise(2, sizeof(long)*CHAR_BIT))-1);
}

int raise(int base, int n){
  if(n == 0)
    return 1;
  else{
    return base * raise(base, n-1);
  }
}

long l_raise(int base, int n){
  if(n == 0)
    return 1;
  else{
    return base * l_raise(base, n-1);
  }
}
",40,116,743
"char square[10] = { 'o', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
int checkwin();
void board();
int main()
{
    int player = 1, i, choice;
    char mark;
    do
    {
        board();
        player = (player % 2) ? 1 : 2;
        printf(""Player %d, enter a number:  "", player);
        scanf(""%d"", &choice);
        mark = (player == 1) ? 'X' : 'O';
        if (choice == 1 && square[1] == '1')
            square[1] = mark;
        else if (choice == 2 && square[2] == '2')
            square[2] = mark;
        else if (choice == 3 && square[3] == '3')
            square[3] = mark;
        else if (choice == 4 && square[4] == '4')
            square[4] = mark;
        else if (choice == 5 && square[5] == '5')
            square[5] = mark;
        else if (choice == 6 && square[6] == '6')
            square[6] = mark;
        else if (choice == 7 && square[7] == '7')
            square[7] = mark;
        else if (choice == 8 && square[8] == '8')
            square[8] = mark;
        else if (choice == 9 && square[9] == '9')
            square[9] = mark;
        else
        {
            printf(""Invalid move "");
            player--;
            getch();
        }
        i = checkwin();
        player++;
    }while (i ==  - 1);
    board();
    if (i == 1)
        printf(""==>\aPlayer %d win "", --player);
    else
        printf(""==>\aGame draw"");
    getch();
    return 0;
}

int checkwin()
{
    if (square[1] == square[2] && square[2] == square[3])
        return 1;
    else if (square[4] == square[5] && square[5] == square[6])
        return 1;
    else if (square[7] == square[8] && square[8] == square[9])
        return 1;
    else if (square[1] == square[4] && square[4] == square[7])
        return 1;
    else if (square[2] == square[5] && square[5] == square[8])
        return 1;
    else if (square[3] == square[6] && square[6] == square[9])
        return 1;
    else if (square[1] == square[5] && square[5] == square[9])
        return 1;
    else if (square[3] == square[5] && square[5] == square[7])
        return 1;
    else if (square[1] != '1' && square[2] != '2' && square[3] != '3' &&
        square[4] != '4' && square[5] != '5' && square[6] != '6' && square[7]
        != '7' && square[8] != '8' && square[9] != '9')
        return 0;
    else
        return  - 1;
}
void board()
{

    printf(""\n\n\tTic Tac Toe\n\n"");
    printf(""Player 1 (X)  -  Player 2 (O)\n\n\n"");
    printf(""     |     |     \n"");
    printf(""  %c  |  %c  |  %c \n"", square[1], square[2], square[3]);
    printf(""__|_|__\n"");
    printf(""     |     |     \n"");
    printf(""  %c  |  %c  |  %c \n"", square[4], square[5], square[6]);
    printf(""__|_|__\n"");
    printf(""     |     |     \n"");
    printf(""  %c  |  %c  |  %c \n"", square[7], square[8], square[9]);
    printf(""     |     |     \n\n"");
}

",41,117,1068
"# include<stdio.h>
void largest(int a[][90],int ,int);
void main()
{
    int a[90][90],r,c,i,j;
    printf(""enter no of rows and columns"");
    scanf(""%d%d"",&r,&c);
    printf(""enter ele"");
    for(i=0;i<r;i++)
    {
        for(j=0;j<c;j++)
        {
            scanf(""%d"",&a[i][j]);
        }
    }
    largest(a,r,c);
}
void largest(int a[][90],int r,int c)
{
    int max=a[0][0],i,j;
    for(i=0;i<r;i++)
    {
        for(j=0;j<c;j++)
        {
            if(max<a[i][j])
                max=a[i][j];
        }
    }
    printf(""%d"",max);
}
",41,118,253
"struct Node
{
     int data;          
     struct Node *next; 
};

void linkedListTraversal(struct Node *head)
{
     struct Node *ptr = head;
     do
     {
          printf(""Element is : %d\n"", ptr->data);
          ptr = ptr->next;
     } while (ptr != head);
}

struct Node *insertAtEnd(struct Node *head, int data)
{
     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));
     ptr->data = data;
     struct Node *p = head->next;
     while (p->next != head)
     {
          p = p->next;
     }
     
     p->next = ptr;
     ptr->next = head;
     return head;
}

struct Node *insertAtTheIndex(struct Node *head, int data, int index)
{
     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));
     struct Node *q = head;
     int i = 0;
     while (i != index - 1)
     {
          q = q->next;
          i++;
     }
     ptr->data = data;
     ptr->next = q->next;
     q->next = ptr;
     return head;
}

struct Node *insertAtTheFirst(struct Node *head, int data)
{
     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));
     ptr->data = data;
     struct Node *p = head->next;
     while (p->next != head)
     {
          p = p->next;
     }
     
     ptr->next = p->next;
     p->next = ptr;
     return ptr;
}

struct Node *deleteFirst(struct Node *head)
{
     struct Node *ptr = head;
     
     struct Node *p = head->next;
     while (p->next != head)
     {
          p = p->next;
     }
     head = head->next; 
     p->next = head;    
     free(ptr);         
     return head;       
}

struct Node *deleteByGivenKey(struct Node *head, int value)
{
     struct Node *p = head;
     struct Node *q = head->next;

     while (q->data != value) 
     {
          p = p->next;
          q = q->next;
     }

     if (q->data == value) 
     {
          p->next = q->next; 
          free(q);           
     }

     return head;
}

struct Node *deleteLastNode(struct Node *head)
{
     struct Node *p = head;
     struct Node *q = head->next;
     while (q->next != head)
     { 
          p = p->next;
          q = q->next;
     }
     p->next = head; 
     free(q);        
     return head;    
}

int main()
{
     
     struct Node *head;
     struct Node *second;
     struct Node *third;
     struct Node *fourth;

     
     head = (struct Node *)malloc(sizeof(struct Node));
     second = (struct Node *)malloc(sizeof(struct Node));
     third = (struct Node *)malloc(sizeof(struct Node));
     fourth = (struct Node *)malloc(sizeof(struct Node));

     
     head->data = 7;
     head->next = second;

     
     second->data = 11;
     second->next = third;

     
     third->data = 70;
     third->next = fourth;

     
     fourth->data = 22;
     fourth->next = head;

     linkedListTraversal(head);

     

     head = insertAtEnd(head, 54);
     printf(""---List After Insertion---\n"");
     linkedListTraversal(head);

     
     
     

     
     
     

     
     
     

     
     
     

     
     
     

     return 0;
}




",42,119,1010
"struct Node{
     int data;
     struct Node *next;

};
void linkedListTraversal(struct Node*ptr){
     while(ptr!=NULL){
          printf(""Element: %d\n"",ptr->data);
          ptr=ptr->next;
     }
}
struct Node * deleteFirst(struct Node * head){
     struct Node * ptr = head;
     head = head->next;
     free(ptr);
     return head;

}











 


struct Node * deleteInBetween(struct Node * head, int index){
     struct Node *p =head;
     struct Node *q = head->next;
     for (int i=0; i<index-1; i++){
          p= p->next;
          q=q->next;
     }
     p->next=q->next;
     free(q);
     return head;

}

struct Node * deleteLastNode(struct Node * head){
     struct Node *p = head;
     struct Node *q = head->next;
     while(q->next != NULL){
          p = p->next;
          q = q->next;
     }
     p->next = NULL;
     free(q);
     return head;

}

struct Node * deleteByGivenKey(struct Node * head, int value){
     struct Node *p = head;
     struct Node *q = head->next;

     while ( q->data != value && q->next != NULL)
     {
          p = p->next;
          q = q->next;
     }
      
     if (q->data == value)
     {
          p->next = q->next;
          free(q);
     }
     
     return head;
}

int main(){
     
     struct Node*head;
     struct Node*second;
     struct Node*third;
     struct Node*fourth;
     struct Node*fifth;
     struct Node*sixth;
     struct Node*seventh;
 
     
     head = (struct Node *) malloc(sizeof(struct Node));
     second = (struct Node *) malloc(sizeof(struct Node));
     third = (struct Node *) malloc(sizeof(struct Node));
     fourth = (struct Node *) malloc(sizeof(struct Node));
     fifth = (struct Node *) malloc(sizeof(struct Node));
     sixth = (struct Node *) malloc(sizeof(struct Node));
     seventh = (struct Node *) malloc(sizeof(struct Node));

     
     head->data=7;
     head->next=second;

     
     second->data=11;
     second->next=third;

     
     third->data=70;
     third->next=fourth;

     
     fourth->data=22;
     fourth->next=fifth;

      
     fifth->data=44;
     fifth->next=sixth;

      
     sixth->data=20;
     sixth->next=seventh; 

     
     seventh->data=100;
     seventh->next=NULL;

     linkedListTraversal(head);

     
     
     
     

     
     
     
     

     
     
     
     

     
     head = deleteByGivenKey(head, 70);
     printf(""---After deletion---\n"");
     linkedListTraversal(head);

     return 0;
}




",42,120,841
"void delay(int );
void blink_led(int);

int main()
{
    IODIR1 |= 0xFF<<17;
    WDMOD = (1<<1) | (1<<0);   
    WDTC = 0xFFFFFF;        
    blink_led(24);
    WDFEED = 0xAA; 
    WDFEED = 0x55;
    while(1)
    {
        if(WDTV <= 0xF00000)
        {
                WDFEED = 0xAA;          
                WDFEED = 0x55;
        }
        blink_led(17);
    }
}

void delay(int ct)
{
    for(int i=0;i<ct;i++)
    {
        for(int j=0;j<6000;j++)
        {}
    }
}

void blink_led(int led)
{
        IOSET1 = 1<<led;
        delay(500);    
        IOCLR1 = 1<<led;
        delay(500);
}
",43,121,288
"void blink_led(int );
void delay_ms(int );
int main()
{
    IODIR1 |= (0xFF<<17);
    WDMOD = (1<<0)|(1<<1);
    WDTC = 0xFFFFFF;            
    WDFEED = 0xAA;
    WDFEED = 0x55;
    blink_led(24);          
    while(1)
    {
        if(WDTV <= 0x800000)
        {
                WDFEED = 0xAA;
                WDFEED = 0x55;
        }
        IOSET1 = 1<<17;  
        delay_ms(100);
        IOCLR1 = 1<<17;   
        delay_ms(100);
    }
}

void blink_led(int led)
{
        IOSET1 = 1<<led;  
        delay_ms(100);
        IOCLR1 = 1<<led;   
        delay_ms(100);
}

void delay_ms(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}
",43,122,337
"#include ""../lcd_header.h""

void i2c_config(void);
void i2c_start(void);
void i2c_data(char );
void i2c_stop(void);


int main()
{
    lcd_config();
    i2c_config();
    
    
    i2c_start();
    i2c_data(0xA0);     
    i2c_data(0x00);     
    i2c_data('D');
    i2c_data('E');
    i2c_data('F');
    i2c_stop();
    
}

void i2c_config(void)
{
    PINSEL0 |= (1<<4)|(1<<6);           
    PINSEL0 &= ~((1<<5)|(1<<7));
    I2CONSET    = 1<<6;     
    I2SCLH = 75;                
    I2SCLL = 75;
}

void i2c_start(void)
{
    I2CONCLR = 1<<3;
    I2CONSET = 1<<5;        
    while(!(I2CONSET & (1<<3)));    
    I2CONCLR = 1<<3;        
    I2CONCLR = 1<<5;        
}

void i2c_data(char data)
{
    I2DAT = data;
    while(!(I2CONSET & (1<<3)));    
    I2CONCLR = 1<<3;
}

void i2c_stop(void)
{
    I2CONSET = 1<<4;    
}



",43,123,419
"void delay(int);

int main()
{
    int val;
    IODIR1 = IODIR1 | (0xFF<<17);
                                    
    while(1)
    {
        for(val =0x01;val <= 0xFF; val++)
        {
            IOSET1 = val<<17;
            delay(100);
            IOCLR1 = val<<17;
            delay(100);
        }
    }
}
void delay(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)             
        {}
    }
}
",43,124,181
"void delay_ms(int);
int main()
{

    PINSEL0 |= (1<<17);
    PINSEL0 &= ~(1<<16);                
    PWMPR = 14;
    PWMMR0 = 10000;                         
    PWMLER = (1<<0);
    PWMMCR = (1<<1);                        
    PWMPCR |= (1<<12)|(1<<4);                   
    PWMTCR = (1<<0) | (1<<3);       
    while(1)
    {
            PWMMR3 = 3000;          
            PWMMR4 = 5500;          
            PWMLER = (1<<3)|(1<<4);
            delay_ms(1000);
            PWMMR3 = 3000;          
            PWMMR4 = 7000;          
            PWMLER = (1<<3)|(1<<4);
            delay_ms(1000);
    }   
}

void delay_ms(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}
",43,125,335
"#define LED_ALL (0xFF<<17)
void delay(int );
void blink_led(int );
int keyFlag = 1;
int main()
{
    IODIR1 = IODIR1 | LED_ALL ;  
    IODIR1 = IODIR1 & ~(1<<25);  

    while(1)
    {
        if(IOPIN1 & (1<<25))
        {
            if(keyFlag)
            {   
                IOSET1 = 0x0F<<17;
                keyFlag = 0;
            }
            else
            {
                IOCLR1 = 0x0F<<17;
                keyFlag = 1;
            }
            delay(500);
        }       
    }
}

void blink_led(int led)
{
        IOSET1 = 1<<led;  
        delay(100);
        IOCLR1 = 1<<led;   
        delay(100);
}

void delay(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}
",43,126,309
"bool is_pass(bool* info) {
    for (int i = 0; i < 7; i++)
        if (!info[i]) return false;
    return true;
}

int main() {
    char *filename = ""Passports.txt"";
    FILE *f = fopen(filename, ""r"");
    size_t count = 0;

    char cur = '\0';
    bool *info = calloc(sizeof(bool), 7);
    char *curs = calloc(sizeof(char), 3);

    for (cur = fgetc(f); cur != EOF; cur = fgetc(f)) {
        if (cur == ':') switch (curs[0] + curs[1] + curs[2]) {
            case 333: 
                info[0] = true; break;
            case 340: 
                info[1] = true; break;
            case 336: 
                info[2] = true; break;
            case 323: 
                info[3] = true; break;
            case 311: 
                info[4] = true; break;
            case 308: 
                info[5] = true; break;
            case 317: 
                info[6] = true; break;
        }
        if (cur == '\n' && curs[2] == '\n') {
            if (is_pass(info)) count++;
            free(info);
            info = calloc(sizeof(bool), 7);
        }
        curs[0] = curs[1];
        curs[1] = curs[2];
        curs[2] = cur;
    }

    printf(""Answer: %zu\n"", count);

    free(info);
    free(curs);
    fclose(f);
    return 0;
}",44,127,457
"struct process
{
    char name[10];  
    int AT,BT,CT,TAT,WT,BT1,status;
};
void main()
{
    int n,i,j,temp,min,k,k1,init_temp,sum=0;
    float Waiting_time;
    char s[10];
    printf(""\nEnter the number of processess : "");
    scanf(""%d"",&n);
    struct process p[n];
    for(i=0;i<n;i++)
    {
        printf(""\nEnter name : "");
        scanf(""%s"",p[i].name);
        printf(""\nEnter AT : "");
        scanf(""%d"",&p[i].AT);
        printf(""\nEnter BT : "");
        scanf(""%d"",&p[i].BT);
        p[i].CT=0;
        p[i].status=0;
        p[i].BT1=p[i].BT;
    }
    for(i=0;i<n;i++)
    {
        for(j=i+1;j<n;j++)
        {
            if(p[i].AT>p[j].AT)
            {
                temp=p[i].AT;
                p[i].AT=p[j].AT;
                p[j].AT=temp;
                temp=p[i].BT;
                p[i].BT=p[j].BT;
                p[j].BT=temp;
                temp=p[i].BT1;
                p[i].BT1=p[j].BT1;
                p[j].BT1=temp;
                strcpy(s,p[i].name);
                strcpy(p[i].name,p[j].name);
                strcpy(p[j].name,s);
            }
        }
    }
    k=0;
    temp=0;
    while(k<n)
    {
        init_temp=temp;
        min=1000;
        printf(""\nq"");
        for(i=0;i<n;i++)
        {
            printf(""\nw"");
            if(p[i].BT1<min && p[i].BT1!=0 && p[i].AT<=temp)
            {
                min=p[i].BT1;
            }
        }
        for(i=0;i<n;i++)
        {
            printf(""\ne"");
            if(p[i].AT<=temp && p[i].status==0 && p[i].BT1<=min)
            {
                p[i].BT1--;
                temp++;
                p[i].CT=temp;
                break;
            }
        }
        for(i=0;i<n;i++)
        {
            printf(""\nr"");
            if(p[i].BT1==0 && p[i].status==0)
            {
                k=k+1;
                p[i].status=k;
            }
        }
        if(init_temp==temp)
            temp++;
    }
    printf(""\nstatus : "");
    for(i=0;i<n;i++)
        printf(""\t%d"",p[i].status);
    printf(""\nprocess\tAT\tBT\tCT\tTAT\tWT"");
    k1=1;
    while(k1<=k)
    {
        for(i=0;i<n;i++)
        {
            if(p[i].status==k1)
            {
                p[i].TAT=p[i].CT-p[i].AT;
                p[i].WT=p[i].TAT-p[i].BT;
                sum=sum+p[i].WT;
                printf(""\n%s\t%d\t%d\t%d\t%d\t%d"",p[i].name,p[i].AT,p[i].BT,p[i].CT,p[i].TAT,p[i].WT);
                k1++;
            }
        }
    }
    Waiting_time=(sum*1.0)/n;
    printf(""\nAverage Waiting_time : %f"",Waiting_time);
}",45,128,1051
"struct dir
{
    char file;
    struct dir* next;
}*start,*temp,*q;
int isthere(char name)
{
    int flag=-1;
    temp=start;
    while(temp!=NULL)
    {
        if(temp->file==name)
        {
            flag=1;
            break;
        }
        temp=temp->next;
    }
    return(flag);
}
void add_file(char name)
{
    struct dir* p=(struct dir*)malloc(sizeof(struct dir));
    p->file=name;
    p->next=NULL;
    if(isthere(name)==-1)
    {
        if(start==NULL)
            start=p;
        else
        {
            temp=start;
            while(temp->next!=NULL)
                temp=temp->next;
            temp->next=p;
        }
    }
    else
        printf(""\nFile already exists"");
}
void rem_file(char name)
{
    if(isthere(name)==-1)
        printf(""\nFile does not exist"");
    else
    {
        temp=start;
        q=temp;
        while(temp->next!=NULL)
        {
            if(temp->file==name)
            {
                if(temp==start)
                {
                    start=start->next;
                    free(temp);
                    temp=start;
                }
                else
                {
                    q->next=temp->next;
                    free(temp);
                    temp=q->next;
                }
            }
            q=temp;
            temp=temp->next;
        }
        if(temp->file==name)
        {
            q->next=NULL;
            free(temp);
        }
    }
}
void display()
{
    temp=start;
    printf(""\nFiles are : "");
    while(temp!=NULL)
    {
        printf(""%c\t"",temp->file);
        temp=temp->next;
    }
}
void main()
{
    int ch;
    char name[5];
    while(1)
    {
        printf(""\nEnter choice : "");
        scanf(""%d"",&ch);
        switch(ch)
        {
            case 1: 
            {
                printf(""\nEnter file name : "");
                scanf(""%s"",name);
                add_file(name[0]);
                break;
            }
            case 2: 
            {
                printf(""\nEnter file name : "");
                scanf(""%s"",name);
                rem_file(name[0]);
                break;
            }
            case 3:
            {
                display();
                break;
            }
            default:
            {
                exit(0);
                break;
            }
        }
    }
}",45,129,696
"struct process
{
    char name[10];
    int AT,BT,CT,TAT,WT,Pr,status,BT1;
};
void main()
{
    int n,i,j,sum=0,temp,init_temp,k=0,k1,min;
    char s[10];
    float Waiting_time;
    printf(""\nEnter the number of processess : "");
    scanf(""%d"",&n);
    struct process p[n];
    for(i=0;i<n;i++)
    {
        printf(""\nEnter name : "");
        scanf(""%s"",p[i].name);
        printf(""\nEnter AT : "");
        scanf(""%d"",&p[i].AT);
        printf(""\nEnter BT : "");
        scanf(""%d"",&p[i].BT);
        printf(""\nEnter priority : "");
        scanf(""%d"",&p[i].Pr);
        p[i].status=0;
        p[i].BT1=p[i].BT;
        p[i].CT=0;
    }
    for(i=0;i<n;i++)
    {
        for(j=i+1;j<n;j++)
        {
            if(p[i].Pr>p[j].Pr)
            {
                temp=p[i].AT;
                p[i].AT=p[j].AT;
                p[j].AT=temp;
                temp=p[i].BT;
                p[i].BT=p[j].BT;
                p[j].BT=temp;
                temp=p[i].BT1;
                p[i].BT1=p[j].BT1;
                p[j].BT1=temp;
                temp=p[i].Pr;
                p[i].Pr=p[j].Pr;
                p[j].Pr=temp;
                strcpy(s,p[i].name);
                strcpy(p[i].name,p[j].name);
                strcpy(p[j].name,s);
            }   
        }
    }
    k=0;
    temp=0;
    while(k<n)
    {
        init_temp=temp;
        for(i=0;i<n;i++)
        {
            if(p[i].AT<=temp && p[i].status==0)
            {
                p[i].BT1--;
                temp++;
                p[i].CT=temp;
                break;
            }
        }
        for(i=0;i<n;i++)
        {
            printf(""\nr"");
            if(p[i].BT1==0 && p[i].status==0)
            {
                k=k+1;
                p[i].status=k;
            }
        }
        if(init_temp==temp)
            temp++;
    }
    printf(""\nstatus : "");
    for(i=0;i<n;i++)
        printf(""\t%d"",p[i].status);
    printf(""\nprocess\tAT\tBT\tCT\tTAT\tWT"");
    k1=1;
    while(k1<=k)
    {
        for(i=0;i<n;i++)
        {
            if(p[i].status==k1)
            {
                p[i].TAT=p[i].CT-p[i].AT;
                p[i].WT=p[i].TAT-p[i].BT;
                sum=sum+p[i].WT;
                printf(""\n%s\t%d\t%d\t%d\t%d\t%d"",p[i].name,p[i].AT,p[i].BT,p[i].CT,p[i].TAT,p[i].WT);
                k1++;
            }
        }
    }
    Waiting_time=(sum*1.0)/n;
    printf(""\nAverage Waiting_time : %f"",Waiting_time);
}",45,130,1003
"#define F 3
int n,i,j,page,Queue[F],f=-1,r=-1,PFR;
void enqueue(int page)
{
    if(f==-1 && r==-1)
    {
        f=f+1;
        r=r+1;
        Queue[r]=page;
    }
    else
    {
        r=(r+1)%3;
        Queue[r]=page;
    }
}
int isthere(int page)
{
    int flag=-1;
    for(j=0;j<3;j++)
    {
        if(Queue[j]==page)
        {
            flag=1;
            break;
        }
    }
    return(flag);
}
void main()
{
    for(i=0;i<3;i++)
        Queue[i]=-1;    
    printf(""\nEnter the number of pages : "");
    scanf(""%d"",&n);
    for(i=0;i<n;i++)
    {
        printf(""\nEnter the page : "");
        scanf(""%d"",&page);
        if(isthere(page)==-1)
        {
            enqueue(page);
            PFR=PFR+1;
        }
        printf(""\nStatus : "");
        for(j=0;j<3;j++)
            printf(""%d\t"",Queue[j]);
    }
    printf(""\nPage Fault Rate is : %d"",PFR);
}",45,131,371
"#include ""sys_v_shm.h""

int main()
{
    char string[100];
    int shmid;
    char *data;

    shmid = shmget(1000, 100, 0);
    perror(""shmget "");

    data = shmat(shmid, NULL, 0);
    perror(""shmat"");

    strcpy(string, data);
    perror(""strcpy"");

    printf(""Data ==> %s\n"",string);

    shmdt(data);
    perror(""shmat"");

}
",46,132,149
"#include ""stack.h""

#define MAXSIZE 5

int push(void);
int pop(void);
int display(void);

struct stack
{
    int stack[MAXSIZE];
    int data;
}stack;

int main(){

    int input;

    stack.data = -1;

    while(1){
    printf(""Enter the choice\n1.Push\n2.Pop\n3.Display\n4.Exit\n"");
    scanf(""%d"",&input);

        switch(input){
            case 1 :
                push();
                break ;
            case 2 :
                pop();
                break ;
            case 3 :
                display();
                break ;
            case 4 :
                exit(EXIT_SUCCESS);
            default :
                printf(""Invalid Option\n"");
        }
    }
}


int push(void)
{
    int data_input;

    if(stack.data == (MAXSIZE - 1)){
        printf(""..........Stack is full...........\n"");
        return 0;
    }else{
        printf(""Enter the Data to push\n"");
        scanf(""%d"",&data_input);
        stack.data = stack.data + 1;
        stack.stack[stack.data] = data_input;
    }

}

int pop(void)
{
    int data_input;
    if(stack.data == -1){
        printf(""...............Stack is empty.............\n"");
        return 0;
    }else{
        data_input = stack.stack[stack.data];
        printf(""Deleted Data = %d\n"",stack.stack[stack.data]);
        stack.data = stack.data - 1;
    }

}
int display(void)
{
    int count;
    if(stack.data == -1){
        printf(""Stack is empty\n"");
        return 0;
    }else{
        printf(""The status of stack\n"");
        for(count = stack.data; count>=0; count--)
        {
            printf(""%d\n"",stack.stack[count]);
        }
    }
}
",46,133,533
"#include""queue.h""

#define MAX 6

int arr[MAX];
int front =0;
int rear = -1;
int count = 0;


int peek()
{
    return arr[front];
}


int empty()
{
    if(count == 0)
        return 1;
    else
        return 0;
}


int full()
{
    if(count == MAX )
        return 1;
    else
        return 0;
}


int size()
{
    return count;
}


void insert(int data)
{
    if(full()==0)
    {
        if(rear == MAX-1)
            rear = -1;
        arr[++rear] = data;
        count++;
    }
    else
        printf(""Queue is full\n"");
}


int removedata()
{
    int data = arr[front++];
    if(front == MAX)
        front =0;
    count--;
    return data;
}

int main()
{
    
    insert(1);
    insert(2);
    insert(3);
    insert(4);
    insert(5);
    insert(6);

    int num = removedata();
    printf(""%d \n"",num);

    insert(7);
    
    while(!empty())
    {
        int n = removedata();
        printf(""%d "",n);
    }
}
",46,134,364
"#include ""posix_shm.h""

int main()
{
   int open_fd, munmap_ret, msync_ret;
   ssize_t read_fd;
   char *mmap_ret;
   char buff[50];

   
   open_fd = shm_open(""/posix"" , O_RDWR , 0644);
   if(open_fd == -1){
       perror(""shm_open"");
       printf(""Return value of shm_open %d\n"",open_fd);
   }else {
       perror(""shm_open"");
       printf(""Return value of shm_open %d\n"",open_fd);
   }


   
   read_fd = read(open_fd,buff,4096);
   if(read_fd == -1){
    perror(""read"");
   }else {
    perror(""read"");
   }

   
   
   mmap_ret = mmap(NULL , 4096 , PROT_READ | PROT_WRITE, MAP_SHARED ,open_fd ,0);
   perror(""mmap"");

   
   msync_ret = msync(mmap_ret, 4096, MS_SYNC);
   if(msync_ret == -1){
       perror(""msync"");
   }else {
       perror(""msync"");
   }

   
   printf(""%s\n"",buff);

   
   munmap_ret = munmap(mmap_ret, 4096);
   if(munmap_ret == -1) {
       perror(""munmap"");
   }else {
       perror(""munmap"");
   }
}
",46,135,425
"void sys_error(const char *str)
{
    perror(str);
    exit(1);
}

int main(int argc, char *argv[])
{
    if(argc < 2)
    {
        printf(""enter a fifo name\n"");
        return -1;
    }

    int fd = open(argv[1], O_RDONLY);
    if(fd < 0)
        sys_error(""open error"");
    
    int n;
    char buf[1024];
    while(1)
    {
        n = read(fd, buf, sizeof(buf));
        write(STDOUT_FILENO, buf, n);
        sleep(1);
    }

    close(fd);
    return 0;
}
",47,136,194
"void sys_err(const char *str)
{
    perror(str);
    exit(1);
}

int main(int argc, char *argv[])
{
    int clnt_sock = socket(AF_INET, SOCK_STREAM, 0);
    if(clnt_sock == -1)
    {
        sys_err(""socket() error"");
    }

    struct sockaddr_in serv_addr;
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(9999);
    inet_pton(AF_INET, ""127.0.0.1"", &serv_addr.sin_addr.s_addr);
    int ret = connect(clnt_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
    if(ret != 0)
    {
        sys_err(""connect() error"");
    }

    int counter = 10;
    char buf[BUFSIZ];
    while(counter--)
    {
        write(clnt_sock, ""hello\n"", 6);
        ret = read(clnt_sock, buf, sizeof(buf));
        write(STDOUT_FILENO, buf, ret);
        sleep(1);
    }

    close(clnt_sock);

    return 0;
}",47,137,338
"int val = 100;

void sys_err(const char *str)
{
    perror(str);
    exit(1);
}

int main()
{
    int fd = open(""temp"", O_RDWR|O_CREAT|O_TRUNC, 0644);
    if(fd == -1)
        sys_err(""open error"");

    ftruncate(fd, 4); 

    
    int *p = (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
    if(p == MAP_FAILED)
        sys_err(""mmap error"");

    close(fd);              
    pid_t pid = fork();
    if(pid < 0)
        sys_err(""fork error"");
    else if(pid == 0)
    {
        *p = 2000;          
        val = 1000;
        printf(""child, *p = %d, var = %d\n"", *p, val);
    }
    else
    {
        sleep(1);
        printf(""parent, *p = %d, var = %d\n"", *p, val);     
        wait(NULL);
        
        int ret = munmap(p, 4);
        if(ret == -1)
            perror(""munmap error"");
    }

    return 0;
}",47,138,362
"void sys_error(const char *str)
{
    perror(str);
    exit(1);
}

int main()
{
    int fd[2];
    int ret = pipe(fd);
    if(ret == -1)
        sys_error(""pipe error"");
    
    int i;
    for(i = 0; i < 2; i++)
    {
        pid_t pid = fork();
        if(pid == -1)
            sys_error(""fork error"");
        else if(pid == 0)
            break;
    }

    char buf[1024];
    if (i == 0)
    {
        close(fd[0]);
        write(fd[1], ""1.hello\n"", strlen(""1.hello\n""));
    }
    else if (i == 1)
    {
        close(fd[0]);
        write(fd[1], ""2.world\n"", strlen(""2.world\n""));
    }
    else if(i == 2)
    {
        close(fd[1]);
        
        int n = read(fd[0], buf, 1024);
        write(STDOUT_FILENO, buf, n);

        wait(NULL);
        wait(NULL);
    }

    return 0;
}",47,139,328
"int main(int argc, char *argv[])
{
    int fd1 = open(argv[1], O_RDONLY);
    if(fd1 == -1)
    {
        perror(""open argv1 error"");
        exit(1);
    }

    int fd2 = open(argv[2], O_WRONLY|O_CREAT|O_TRUNC, 0644);
    if(fd2 == -1)
    {
        perror(""open argv2 error"");
        exit(1);
    }

    char buf[1024];
    int n = 0;
    while((n = read(fd1, buf, 1024)) != 0)
    {
        if(n < 0)
        {
            perror(""read error"");
            break;
        }
        write(fd2, buf, n);
    }

    close(fd1);
    close(fd2);
}   
",47,140,241
"int main(int argc, char *argv[])
{
    printf(""before fork-1-\n"");
    printf(""before fork-2-\n"");
    printf(""before fork-3-\n"");
    printf(""before fork-4-\n"");

    pid_t pid = fork();
    if(pid == -1)
    {
        perror(""fork error"");
        exit(1);
    }
    else if(pid == 0)
    {
        printf(""child is created, pid:%d, parent-pid:%d\n"", getpid(), getppid());
    }
    else if(pid > 0)
    {
        printf(""parent process:child pid:%d, my-pid:%d, parent-pid:%d\n"", pid, getpid(), getppid());
    }

    printf(""end of file\n"");
    sleep(2);
    return 0;
}",47,141,216
"#include ""BlinkDrv.h""




static uint16_t currentTick;

static uint16_t expirationTick;

void ICACHE_FLASH_ATTR blink_init(uint16_t runPeriod, uint16_t blinkPeriod)
{
  PIN_FUNC_SELECT(BLINK_PIN_NAME,BLINK_FUNC_GPIO);
  
  currentTick = 0;
  expirationTick = (blinkPeriod >> 1) / runPeriod;
}

void ICACHE_FLASH_ATTR blink_run(void)
{
  if (currentTick == expirationTick) 
  {
    uint32_t state = GPIO_INPUT_GET(BLINK_PIN);
    (state ^= (0x01u));
    GPIO_OUTPUT_SET(BLINK_PIN,state);
    
    currentTick = 0;
  }
  else
  {
    currentTick++;
  }
}
",48,142,266
"#include ""DemoFOTAUpdateWorkflow.h""

#include ""DemoProductInfo.h""


enum DemoFOTAUpdateWorkflowEngine__inevents {
  DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event,
  DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event,
  DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event
};
typedef enum DemoFOTAUpdateWorkflowEngine__inevents DemoFOTAUpdateWorkflowEngine__inevents_t;

enum DemoFOTAUpdateWorkflowEngine__states {
  DemoFOTAUpdateWorkflowEngine_idle__state = 0,
  DemoFOTAUpdateWorkflowEngine_connected__state,
  DemoFOTAUpdateWorkflowEngine_downloading__state,
  DemoFOTAUpdateWorkflowEngine_restarting__state
};
typedef enum DemoFOTAUpdateWorkflowEngine__states DemoFOTAUpdateWorkflowEngine__states_t;

struct DemoFOTAUpdateWorkflowEngine__data {
  DemoFOTAUpdateWorkflowEngine__states_t __currentState;
  FirmwareUpdateInfo_t updateInfo;
};
typedef struct DemoFOTAUpdateWorkflowEngine__data DemoFOTAUpdateWorkflowEngine__data_t;

static void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance);

static bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments);

static inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);

static inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);

static DemoFOTAUpdateWorkflowEngine__data_t updateWorkflowEngine;

void fotaUpdateWorkflow_init(void)
{
  DemoFOTAUpdateWorkflowEngine__init(&updateWorkflowEngine);
}

void fotahub_onConnectionStatusChanged(ConnectionStatus_t status)
{
  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;
  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);
}

void fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)
{
  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;
  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);
}

void fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)
{
  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;
  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);
}

static void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance)
{
  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;
  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;
  instance->updateInfo.version = NULL;
  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;
  instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;
}

static bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)
{
  switch (instance->__currentState)
  {
    case DemoFOTAUpdateWorkflowEngine_idle__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:
        {
          
          printf(""Cannot handle firmware over-the-air update request (missing network connection)\n"");
          
          
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_connected__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:
        {
          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) != 0) 
          {
            
            bool __transitionResult = true;
            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;
            
            
            instance->updateInfo.version = (*((char **)((arguments[0]))));
            
            
            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) 
            {
              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) 
            {
              
              instance->__currentState = __targetState;
              switch (__targetState)
              {
                case DemoFOTAUpdateWorkflowEngine_connected__state:
                {
                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
                  break;
                }
                default: {
                  break;
                }
              }
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
            break;
          }
          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) == 0) 
          {
            
            printf(""Ignoring firmware over-the-air update request to version %s as this version is already running\n"", (*((char **)((arguments[0])))));
            
            
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_downloading__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:
        {
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) 
          {
            
            bool __transitionResult = true;
            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;
            
            
            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) 
            {
              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) 
            {
              
              instance->__currentState = __targetState;
              switch (__targetState)
              {
                case DemoFOTAUpdateWorkflowEngine_restarting__state:
                {
                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);
                  break;
                }
                case DemoFOTAUpdateWorkflowEngine_connected__state:
                {
                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
                  break;
                }
                default: {
                  break;
                }
              }
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
            break;
          }
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;
            break;
          }
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_restarting__state:
    {
      switch (event)
      {
        default: {
          break;
        }
      }
      break;
    }
    default: {
      break;
    }
  }
  return true;
}

static inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)
{
  printf(""Ready for firmware over-the-air update\n"");
}

static inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)
{
  printf(""Waiting for restart\n"");
}
",48,143,2759
"#include ""DemoFOTAUpdateWorkflow.h""

#include ""DemoProductInfo.h""
#include ""DemoFOTAUpdateWorkflowPersistence.h""
#include ""DemoFOTAUpdateSelfTest.h""


enum DemoFOTAUpdateWorkflowEngine__inevents {
  DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event,
  DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event,
  DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event
};
typedef enum DemoFOTAUpdateWorkflowEngine__inevents DemoFOTAUpdateWorkflowEngine__inevents_t;

enum DemoFOTAUpdateWorkflowEngine__states {
  DemoFOTAUpdateWorkflowEngine_idle__state = 0,
  DemoFOTAUpdateWorkflowEngine_connected__state,
  DemoFOTAUpdateWorkflowEngine_downloading__state,
  DemoFOTAUpdateWorkflowEngine_restarting__state,
  DemoFOTAUpdateWorkflowEngine_activating__state,
  DemoFOTAUpdateWorkflowEngine_reverting__state
};
typedef enum DemoFOTAUpdateWorkflowEngine__states DemoFOTAUpdateWorkflowEngine__states_t;

struct DemoFOTAUpdateWorkflowEngine__data {
  DemoFOTAUpdateWorkflowEngine__states_t __currentState;
  FirmwareUpdateInfo_t updateInfo;
};
typedef struct DemoFOTAUpdateWorkflowEngine__data DemoFOTAUpdateWorkflowEngine__data_t;

static void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution);

static bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments);

static inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);

static inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);

static DemoFOTAUpdateWorkflowEngine__data_t updateWorkflowEngine;

void fotaUpdateWorkflow_init(void)
{
  DemoFOTAUpdateWorkflowEngine__init(&updateWorkflowEngine, false);
}

void fotahub_onConnectionStatusChanged(ConnectionStatus_t status)
{
  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;
  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);
}

void fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)
{
  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;
  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);
}

void fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)
{
  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;
  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);
}

static void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution)
{
  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;
  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;
  instance->updateInfo.version = NULL;
  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;
  if (!postponeInitialExecution) 
  {
    instance->__currentState = loadState();
    switch (instance->__currentState)
    {
      case DemoFOTAUpdateWorkflowEngine_connected__state:
      {
        DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
        break;
      }
      case DemoFOTAUpdateWorkflowEngine_restarting__state:
      {
        DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);
        break;
      }
      default: {
        break;
      }
    }
  }
}

static bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)
{
  switch (instance->__currentState)
  {
    case DemoFOTAUpdateWorkflowEngine_idle__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:
        {
          
          printf(""Cannot handle firmware over-the-air update request (missing network connection)\n"");
          
          
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_connected__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:
        {
          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) != 0) 
          {
            
            bool __transitionResult = true;
            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;
            
            
            instance->updateInfo.version = (*((char **)((arguments[0]))));
            
            
            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) 
            {
              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) 
            {
              
              instance->__currentState = __targetState;
              switch (__targetState)
              {
                case DemoFOTAUpdateWorkflowEngine_connected__state:
                {
                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
                  break;
                }
                default: {
                  break;
                }
              }
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
            break;
          }
          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) == 0) 
          {
            
            printf(""Ignoring firmware over-the-air update request to version %s as this version is already running\n"", (*((char **)((arguments[0])))));
            
            
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_downloading__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:
        {
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) 
          {
            
            bool __transitionResult = true;
            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;
            
            
            saveState(DemoFOTAUpdateWorkflowEngine_activating__state);
            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) 
            {
              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);
              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) 
            {
              
              instance->__currentState = __targetState;
              switch (__targetState)
              {
                case DemoFOTAUpdateWorkflowEngine_restarting__state:
                {
                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);
                  break;
                }
                case DemoFOTAUpdateWorkflowEngine_connected__state:
                {
                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
                  break;
                }
                default: {
                  break;
                }
              }
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
            break;
          }
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;
            break;
          }
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_restarting__state:
    {
      switch (event)
      {
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_activating__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            validateFirmwareUpdateActivation();
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) 
            {
              
            }
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:
        {
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED) 
          {
            
            bool __transitionResult = true;
            
            
            saveState(DemoFOTAUpdateWorkflowEngine_idle__state);
            if (!fotahub_confirmFirmwareUpdate(&instance->updateInfo)) 
            {
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) 
            {
              
              instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
              DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
            break;
          }
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_FAILED) 
          {
            
            bool __transitionResult = true;
            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;
            
            
            saveState(DemoFOTAUpdateWorkflowEngine_reverting__state);
            if (!fotahub_revertFirmwareUpdate(&instance->updateInfo)) 
            {
              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);
              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) 
            {
              
              instance->__currentState = __targetState;
              switch (__targetState)
              {
                case DemoFOTAUpdateWorkflowEngine_restarting__state:
                {
                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);
                  break;
                }
                case DemoFOTAUpdateWorkflowEngine_connected__state:
                {
                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
                  break;
                }
                default: {
                  break;
                }
              }
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_reverting__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            validateFirmwareUpdateReversion();
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_reverting__state) 
            {
              
            }
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:
        {
          
          
          saveState(DemoFOTAUpdateWorkflowEngine_idle__state);
          
          
          instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
          DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    default: {
      break;
    }
  }
  return true;
}

static inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)
{
  printf(""Ready for firmware over-the-air update\n"");
}

static inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)
{
  printf(""Waiting for restart\n"");
}
",48,144,4053
"#include ""BinHexConverter.h""




static inline char ICACHE_FLASH_ATTR convertBinValueToHexDigit(uint8_t value, bool upperCase);

static inline char ICACHE_FLASH_ATTR convertBinValueToHexDigit(uint8_t value, bool upperCase)
{
  char hexA = (upperCase) ? ('A') : ('a');
  return ((char)((value < 10) ? ('0' + value) : (hexA + value - 10)));
}

uint8_t ICACHE_FLASH_ATTR convertHexDigitToBinValue(char inputChr)
{
  if (inputChr >= '0' && inputChr <= '9') 
  {
    return ((uint8_t)(inputChr - '0'));
  }
  else if (inputChr >= 'a' && inputChr <= 'f') {
    return 10 + ((uint8_t)(inputChr - 'a'));
  }
  else if (inputChr >= 'A' && inputChr <= 'F') {
    return 10 + ((uint8_t)(inputChr - 'A'));
  }
  return 0;
}

size_t ICACHE_FLASH_ATTR convertBinValueToHexString8(uint8_t inputValue, char *outputStr, size_t outputStrSize, bool upperCase)
{
  if (outputStrSize < 2) 
  {
    return 0;
  }
  outputStr[0] = convertBinValueToHexDigit(((inputValue & 0xF0u) >> 4), upperCase);
  outputStr[1] = convertBinValueToHexDigit((inputValue & 0x0Fu), upperCase);
  return 2;
}

uint8_t ICACHE_FLASH_ATTR convertHexString8ToBinValue(char *inputStr, size_t inputStrLength)
{
  if (inputStrLength != 2) 
  {
    return 0;
  }
  uint8_t outputValue = convertHexDigitToBinValue(inputStr[0]) << 4;
  outputValue |= convertHexDigitToBinValue(inputStr[1]);
  return outputValue;
}

size_t ICACHE_FLASH_ATTR convertBinDataToHexString8(uint8_t *inputData, size_t inputDataSize, char *outputStr, size_t outputStrSize, bool upperCase)
{
  if (outputStrSize < inputDataSize * 2) 
  {
    return 0;
  }
  outputStr[0] = '\0';
  size_t count = 0;
  for ( size_t i = 0 ; i < inputDataSize; i++ )
  {
    count += convertBinValueToHexString8(inputData[i], outputStr + 2 * i, outputStrSize - count, upperCase);
  }
  if (outputStrSize > count) 
  {
    outputStr[count++] = '\0';
  }
  return count;
}

size_t ICACHE_FLASH_ATTR convertHexString8ToBinData(char *inputStr, size_t inputStrLength, uint8_t *pOutputData, size_t outputDataSize)
{
  if (outputDataSize < inputStrLength >> 1) 
  {
    return 0;
  }
  if ((inputStrLength & 0x01u) != 0) 
  {
    return 0;
  }
  os_memset(pOutputData, 0x00u, outputDataSize);
  for ( size_t i = 0 ; i < inputStrLength; i = i + 2 )
  {
    pOutputData[i >> 1] = convertHexString8ToBinValue(inputStr + i, 2);
  }
  return inputStrLength >> 1;
}
",48,145,978
"#include ""UARTDrv.h""

#include ""MultiPartitionDemoFirmwareUpdateInfoSerialReader.h""



static void ICACHE_FLASH_ATTR uart_recvTask(os_event_t *pEvent);

static uint8_t uartUnit;

void ICACHE_FLASH_ATTR one_uart_init(uint8_t unit, UartBautRate baudrate)
{
  uartUnit = unit;
  system_os_task(&uart_recvTask, uart_recvTaskPrio, uart_recvTaskQueue, uart_recvTaskQueueLen);
  
  UartDev.baut_rate = baudrate;
  uart_config(unit);
  
  ETS_UART_INTR_ENABLE();
}

static void ICACHE_FLASH_ATTR uart_recvTask(os_event_t *pEvent)
{
  if (pEvent->sig == uart_recvTaskSignal) 
  {
    
    uint32_t uartStatus = READ_PERI_REG(UART_STATUS(uartUnit));
    uint8_t rxFIFOLength = UART_RXFIFO_DATA_LEN(uartStatus);
    
    
    for ( int16_t __i = 0 ; __i < rxFIFOLength; __i++ )
    {
      uint32_t uartFifo = READ_PERI_REG(UART_FIFO(uartUnit));
      uint8_t rxChar = UART_RXFIFO_DATA(uartFifo);
      firmwareUpdateInfoReader_onCharacterReceived(rxChar);
    }
    
    
    WRITE_PERI_REG(UART_INT_CLR(uartUnit),UART_RXFIFO_FULL_INT_CLR | UART_RXFIFO_TOUT_INT_CLR);
    
    
    uart_rx_intr_enable(uartUnit);
  }
}
",48,146,508
"int strcmp(char *, char *);

int main(){
 char *str[] = {""aoki"", ""aoki""};
 int x;

 printf(""%sã¨%sã®è¾æ¸é ãèª¿ã¹ãã¨\n"", str[0], str[1]);

 x = strcmp(str[0], str[1]);

 printf(""%d\n"", x);

 return 0;
}

int strcmp(char *str1, char *str2){
 int r, i, a, b, c;
 char *ptr;

 for(ptr = str1; *ptr != '\0'; ptr++){
  a +=1;
 }
 for(ptr = str2; *ptr != '\0'; ptr++){
  b +=1;
 }
 if(a>b){
  c=a;
 }else{
  c=b;
 }

 for(i=0; i<=c; i++){
  if(str1[i] != str2[i]){
   if(str1[i] < str2[i]){
    r = -1;
    break;
   }
   else{
    r = 1;
    break;
   }
  }
 r = 0;
 }
 return r;
}
",49,147,322
"#include ""stm32f1xx_hal.h""





#ifdef HAL_MODULE_ENABLED






#define __STM32F1xx_HAL_VERSION_MAIN   (0x01U) 
#define __STM32F1xx_HAL_VERSION_SUB1   (0x01U) 
#define __STM32F1xx_HAL_VERSION_SUB2   (0x02U) 
#define __STM32F1xx_HAL_VERSION_RC     (0x00U) 
#define __STM32F1xx_HAL_VERSION         ((__STM32F1xx_HAL_VERSION_MAIN << 24)\
                                        |(__STM32F1xx_HAL_VERSION_SUB1 << 16)\
                                        |(__STM32F1xx_HAL_VERSION_SUB2 << 8 )\
                                        |(__STM32F1xx_HAL_VERSION_RC))

#define IDCODE_DEVID_MASK    0x00000FFFU







__IO uint32_t uwTick;
uint32_t uwTickPrio   = (1UL << __NVIC_PRIO_BITS); 
HAL_TickFreqTypeDef uwTickFreq = HAL_TICK_FREQ_DEFAULT;  









HAL_StatusTypeDef HAL_Init(void)
{
  
#if (PREFETCH_ENABLE != 0)
#if defined(STM32F101x6) || defined(STM32F101xB) || defined(STM32F101xE) || defined(STM32F101xG) || \
    defined(STM32F102x6) || defined(STM32F102xB) || \
    defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || \
    defined(STM32F105xC) || defined(STM32F107xC)

  
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif
#endif 

  
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);

  
  HAL_InitTick(TICK_INT_PRIORITY);

  
  HAL_MspInit();

  
  return HAL_OK;
}


HAL_StatusTypeDef HAL_DeInit(void)
{
  
  __HAL_RCC_APB1_FORCE_RESET();
  __HAL_RCC_APB1_RELEASE_RESET();

  __HAL_RCC_APB2_FORCE_RESET();
  __HAL_RCC_APB2_RELEASE_RESET();

#if defined(STM32F105xC) || defined(STM32F107xC)
  __HAL_RCC_AHB_FORCE_RESET();
  __HAL_RCC_AHB_RELEASE_RESET();
#endif

  
  HAL_MspDeInit();

  
  return HAL_OK;
}


__weak void HAL_MspInit(void)
{
  
}


__weak void HAL_MspDeInit(void)
{
  
}


__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
  {
    return HAL_ERROR;
  }

  
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    uwTickPrio = TickPriority;
  }
  else
  {
    return HAL_ERROR;
  }

  
  return HAL_OK;
}






__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
}


__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
}


uint32_t HAL_GetTickPrio(void)
{
  return uwTickPrio;
}


HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
{
  HAL_StatusTypeDef status  = HAL_OK;
  assert_param(IS_TICKFREQ(Freq));

  if (uwTickFreq != Freq)
  {
    uwTickFreq = Freq;

    
    status = HAL_InitTick(uwTickPrio);
  }

  return status;
}


HAL_TickFreqTypeDef HAL_GetTickFreq(void)
{
  return uwTickFreq;
}


__weak void HAL_Delay(uint32_t Delay)
{
  uint32_t tickstart = HAL_GetTick();
  uint32_t wait = Delay;

  
  if (wait < HAL_MAX_DELAY)
  {
    wait += (uint32_t)(uwTickFreq);
  }

  while ((HAL_GetTick() - tickstart) < wait)
  {
  }
}


__weak void HAL_SuspendTick(void)
{
  
  CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
}


__weak void HAL_ResumeTick(void)
{
  
  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
}


uint32_t HAL_GetHalVersion(void)
{
  return __STM32F1xx_HAL_VERSION;
}


uint32_t HAL_GetREVID(void)
{
  return ((DBGMCU->IDCODE) >> DBGMCU_IDCODE_REV_ID_Pos);
}


uint32_t HAL_GetDEVID(void)
{
  return ((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
}


void HAL_DBGMCU_EnableDBGSleepMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
}


void HAL_DBGMCU_DisableDBGSleepMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
}


void HAL_DBGMCU_EnableDBGStopMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
}


void HAL_DBGMCU_DisableDBGStopMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
}


void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
}


void HAL_DBGMCU_DisableDBGStandbyMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
}


void HAL_GetUID(uint32_t *UID)
{
  UID[0] = (uint32_t)(READ_REG(*((uint32_t *)UID_BASE)));
  UID[1] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
  UID[2] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
}





#endif 





",50,148,2196
"#include ""stm32f1xx_hal.h""





#ifdef HAL_GPIO_MODULE_ENABLED




#define GPIO_MODE             0x00000003U
#define EXTI_MODE             0x10000000U
#define GPIO_MODE_IT          0x00010000U
#define GPIO_MODE_EVT         0x00020000U
#define RISING_EDGE           0x00100000U
#define FALLING_EDGE          0x00200000U
#define GPIO_OUTPUT_TYPE      0x00000010U

#define GPIO_NUMBER           16U


#define  GPIO_CR_MODE_INPUT         0x00000000U 
#define  GPIO_CR_CNF_ANALOG         0x00000000U 
#define  GPIO_CR_CNF_INPUT_FLOATING 0x00000004U 
#define  GPIO_CR_CNF_INPUT_PU_PD    0x00000008U 
#define  GPIO_CR_CNF_GP_OUTPUT_PP   0x00000000U 
#define  GPIO_CR_CNF_GP_OUTPUT_OD   0x00000004U 
#define  GPIO_CR_CNF_AF_OUTPUT_PP   0x00000008U 
#define  GPIO_CR_CNF_AF_OUTPUT_OD   0x0000000CU 













void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  uint32_t position;
  uint32_t ioposition = 0x00U;
  uint32_t iocurrent = 0x00U;
  uint32_t temp = 0x00U;
  uint32_t config = 0x00U;
  __IO uint32_t *configregister; 
  uint32_t registeroffset = 0U; 

  
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  
  for (position = 0U; position < GPIO_NUMBER; position++)
  {
    
    ioposition = (0x01U << position);

    
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if (iocurrent == ioposition)
    {
      
      assert_param(IS_GPIO_AF_INSTANCE(GPIOx));

      
      switch (GPIO_Init->Mode)
      {
        
        case GPIO_MODE_OUTPUT_PP:
          
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
          break;

        
        case GPIO_MODE_OUTPUT_OD:
          
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
          break;

        
        case GPIO_MODE_AF_PP:
          
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
          break;

        
        case GPIO_MODE_AF_OD:
          
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
          break;

        
        case GPIO_MODE_INPUT:
        case GPIO_MODE_IT_RISING:
        case GPIO_MODE_IT_FALLING:
        case GPIO_MODE_IT_RISING_FALLING:
        case GPIO_MODE_EVT_RISING:
        case GPIO_MODE_EVT_FALLING:
        case GPIO_MODE_EVT_RISING_FALLING:
          
          assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
          if (GPIO_Init->Pull == GPIO_NOPULL)
          {
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
          }
          else if (GPIO_Init->Pull == GPIO_PULLUP)
          {
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;

            
            GPIOx->BSRR = ioposition;
          }
          else 
          {
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;

            
            GPIOx->BRR = ioposition;
          }
          break;

        
        case GPIO_MODE_ANALOG:
          config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
          break;

        
        default:
          break;
      }

      
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2U) : ((position - 8U) << 2U);

      
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));

      
      
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        
        __HAL_RCC_AFIO_CLK_ENABLE();
        temp = AFIO->EXTICR[position >> 2U];
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        AFIO->EXTICR[position >> 2U] = temp;


        
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          SET_BIT(EXTI->IMR, iocurrent);
        }
        else
        {
          CLEAR_BIT(EXTI->IMR, iocurrent);
        }

        
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          SET_BIT(EXTI->EMR, iocurrent);
        }
        else
        {
          CLEAR_BIT(EXTI->EMR, iocurrent);
        }

        
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          SET_BIT(EXTI->RTSR, iocurrent);
        }
        else
        {
          CLEAR_BIT(EXTI->RTSR, iocurrent);
        }

        
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          SET_BIT(EXTI->FTSR, iocurrent);
        }
        else
        {
          CLEAR_BIT(EXTI->FTSR, iocurrent);
        }
      }
    }
  }
}


void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
  uint32_t position = 0x00U;
  uint32_t iocurrent = 0x00U;
  uint32_t tmp = 0x00U;
  __IO uint32_t *configregister; 
  uint32_t registeroffset = 0U;

  
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  
  while ((GPIO_Pin >> position) != 0U)
  {
    
    iocurrent = (GPIO_Pin) & (1U << position);

    if (iocurrent)
    {
      
      
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2U) : ((position - 8U) << 2U);

      
      MODIFY_REG(*configregister, ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), GPIO_CRL_CNF0_0 << registeroffset);

      
      CLEAR_BIT(GPIOx->ODR, iocurrent);

      
      

      tmp = AFIO->EXTICR[position >> 2U];
      tmp &= 0x0FU << (4U * (position & 0x03U));
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
      {
        tmp = 0x0FU << (4U * (position & 0x03U));
        CLEAR_BIT(AFIO->EXTICR[position >> 2U], tmp);

        
        CLEAR_BIT(EXTI->IMR, (uint32_t)iocurrent);
        CLEAR_BIT(EXTI->EMR, (uint32_t)iocurrent);

        
        CLEAR_BIT(EXTI->RTSR, (uint32_t)iocurrent);
        CLEAR_BIT(EXTI->FTSR, (uint32_t)iocurrent);
      }
    }

    position++;
  }
}






GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
  GPIO_PinState bitstatus;

  
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
  {
    bitstatus = GPIO_PIN_SET;
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}


void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
  
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
  }
}


void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
  
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
}


HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
  __IO uint32_t tmp = GPIO_LCKR_LCKK;

  
  assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  
  SET_BIT(tmp, GPIO_Pin);
  
  GPIOx->LCKR = tmp;
  
  GPIOx->LCKR = GPIO_Pin;
  
  GPIOx->LCKR = tmp;
  
  tmp = GPIOx->LCKR;

  if ((uint32_t)(GPIOx->LCKR & GPIO_LCKR_LCKK))
  {
    return HAL_OK;
  }
  else
  {
    return HAL_ERROR;
  }
}


void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
}


__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  
  UNUSED(GPIO_Pin);
  
}





#endif 





",50,149,3682
"#include ""stm32f1xx_hal.h""
extern void _Error_Handler(char *, int);




void HAL_MspInit(void)
{
  

  

  __HAL_RCC_AFIO_CLK_ENABLE();
  __HAL_RCC_PWR_CLK_ENABLE();

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);

  
  
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
  
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
  
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
  
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
  
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
  
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
  
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);

    
  __HAL_AFIO_REMAP_SWJ_NOJTAG();

  

  
}










",50,150,363
"int main(int argc, char *argv[]) 
{
    int opcao, opcaoDeJogadaHumano, opcaoDeJogadaComputador, opcaoDeJogadaHumano1, opcaoDeJogadaHumano2;
    int numeroDePartidas = 0, numeroDeVitoriasHumano = 0, numeroDeVitoriasComputador = 0;
    int numeroDeVitoriasHumano1 = 0, numeroDeVitoriasHumano2 = 0, numeroDeEmpates = 0;
    
    while(1)
    {
        system(""cls"");
        printf(""Jogo Jokenpo\n\n"");
        printf(""(1) humano x computador\n"");
        printf(""(2) humano x humano\n"");
        printf(""(3) resultado\n"");
        printf(""(4) sair\n\n"");
        printf(""Escolha uma das opcoes acima: "");
        scanf(""%d"", &opcao);
        
            
        if(opcao == 1)
        {
            numeroDePartidas++;
            printf(""\n(1) = pedra\n"");
            printf(""(2) = papel\n"");
            printf(""(3) = tesoura\n"");
            
            printf(""\nopcao de jogada humano: "");
            scanf(""%d"", &opcaoDeJogadaHumano);
            
            opcaoDeJogadaComputador = rand()%3;
            printf(""opcao de jogada computador: %d\n\n"", opcaoDeJogadaComputador);
            
            if(opcaoDeJogadaHumano == 1 && opcaoDeJogadaComputador == 1)
            {
                printf(""empate\n"");
                numeroDeEmpates++;
            }
            if(opcaoDeJogadaHumano == 1 && opcaoDeJogadaComputador == 2)
            {
                printf(""computador ganha\n"");
                numeroDeVitoriasComputador++;
            }
            if(opcaoDeJogadaHumano == 1 && opcaoDeJogadaComputador == 3)
            {
                printf(""humano ganha\n"");
                numeroDeVitoriasHumano++;
            }
            if(opcaoDeJogadaHumano == 2 && opcaoDeJogadaComputador == 2)
            {
                printf(""empate\n"");
                numeroDeEmpates++;
            }
            if(opcaoDeJogadaHumano == 2 && opcaoDeJogadaComputador == 1)
            {
                printf(""humano ganha\n"");
                numeroDeVitoriasHumano++;
            }
            if(opcaoDeJogadaHumano == 2 && opcaoDeJogadaComputador == 3)
            {
                printf(""computador ganha\n"");
                numeroDeVitoriasComputador++;
            }
            if(opcaoDeJogadaHumano == 3 && opcaoDeJogadaComputador == 3)
            {
                printf(""empate\n"");
                numeroDeEmpates++;
            }
            if(opcaoDeJogadaHumano == 3 && opcaoDeJogadaComputador == 1)
            {
                printf(""computador ganha\n"");
                numeroDeVitoriasComputador++;
            }
            if(opcaoDeJogadaHumano == 3 && opcaoDeJogadaComputador == 2)
            {
                printf(""humano ganha\n"");
                numeroDeVitoriasHumano++;
            }
            system(""pause"");
        }
        else
        {
            if(opcao == 2)
            {
                numeroDePartidas++;
                printf(""\n1 = pedra\n"");
                printf(""2 = papel\n"");
                printf(""3 = tesoura\n"");
                
                printf(""\nopcao de jogada humano 1: "");
                scanf(""%d"", &opcaoDeJogadaHumano1);
            
                printf(""\nopcao de jogada humano 2: "");
                scanf(""%d"", &opcaoDeJogadaHumano2);
                
                if(opcaoDeJogadaHumano1 == 1 && opcaoDeJogadaHumano2 == 1)
                {
                    printf(""\nempate\n"");
                    numeroDeEmpates++;
                }
                if(opcaoDeJogadaHumano1 == 1 && opcaoDeJogadaHumano2 == 2)
                {
                    printf(""\nhumano 2 ganha\n"");
                    numeroDeVitoriasHumano2++;
                }
                if(opcaoDeJogadaHumano1 == 1 && opcaoDeJogadaHumano2 == 3)
                {
                    printf(""\nhumano 1 ganha\n"");
                    numeroDeVitoriasHumano1++;
                }
                if(opcaoDeJogadaHumano1 == 2 && opcaoDeJogadaHumano2 == 2)
                {
                    printf(""\nempate\n"");
                    numeroDeEmpates++;
                }
                if(opcaoDeJogadaHumano1 == 2 && opcaoDeJogadaHumano2 == 1)
                {
                    printf(""\nhumano 1 ganha\n"");
                    numeroDeVitoriasHumano1++;
                }
                if(opcaoDeJogadaHumano1 == 2 && opcaoDeJogadaHumano2 == 3)
                {
                    printf(""\nhumano 2 ganha\n"");
                    numeroDeVitoriasHumano2++;
                }
                if(opcaoDeJogadaHumano1 == 3 && opcaoDeJogadaHumano2 == 3)
                {
                    printf(""\nempate\n"");
                    numeroDeEmpates++;
                }
                if(opcaoDeJogadaHumano1 == 3 && opcaoDeJogadaHumano2 == 1)
                {
                    printf(""\nhumano 2 ganha\n"");
                    numeroDeVitoriasHumano2++;
                }
                if(opcaoDeJogadaHumano1 == 3 && opcaoDeJogadaHumano2 == 2)
                {
                    printf(""\nhumano 1 ganha\n"");
                    numeroDeVitoriasHumano1++;
                }
                system(""pause"");
            }
            else
            {
                if(opcao == 3)
                {
                    printf(""\nNumero de partidas: %d\n"", numeroDePartidas);
                    printf(""Numero de vitorias humano: %d\n"", numeroDeVitoriasHumano);
                    printf(""Numero de vitorias computador: %d\n"", numeroDeVitoriasComputador);
                    printf(""Numero de vitorias humano 1: %d\n"", numeroDeVitoriasHumano1);
                    printf(""Numero de vitorias humano 2: %d\n"", numeroDeVitoriasHumano2);
                    printf(""Numero de empates: %d\n\n"", numeroDeEmpates);
                    system(""pause"");
                }
                else
                {
                    if(opcao == 4)
                    {
                        exit(0);
                    }
                    else
                    {
                        printf(""\nopcao invalida\n\n"");
                    }
                    system(""pause"");
                }
            }
                
        }
    
    }
    
    
    
    
    
    return 0;
}
",51,151,1959
"int main(int argc, char *argv[]) {
    float percVitoriasComputador, percVitoriasJogador, percVitoriasJogador1, percVitoriasJogador2;
    int computador, jogador, jogador1, jogador2, opcao, jogar;
    int vitComputador, vitJogador, vitJogador1, vitJogador2, empate, partidas;
    srand(time(NULL));
    
    vitComputador = 0;
    vitJogador = 0;
    vitJogador1 = 0;
    vitJogador2 = 0;
    empate = 0;
    partidas = 0;
    
    printf(""\nDigite 1 para jogar contra o computador. \n"");
    printf(""Digite 2 para jogar contra outro jogador. \n"");
    scanf(""%d"", &opcao);
    while(opcao < 1 || opcao > 2)
    {
        printf(""Opcao invalida. Digite novamente."");
        printf(""\nDigite 1 para jogar contra o computador. \n"");
        printf(""Digite 2 para jogar contra outro jogador. \n"");
        scanf(""%d"", &opcao);
    }
        do{
            switch(opcao)
            {
                case 1:
                    printf(""\nEscolha uma opcao: \n"");
                    printf(""1. Pedra\n"");
                    printf(""2. Papel\n"");
                    printf(""3. Tesoura\n"");
                    scanf(""%d"", &jogador);
                    
                    while(jogador < 1 || jogador > 3)
                    {
                        printf(""Opcao invalida. Digite novamente.\n"");
                        printf(""\nEscolha uma opcao: \n"");
                        printf(""1. Pedra\n"");
                        printf(""2. Papel\n"");
                        printf(""3. Tesoura\n"");
                        scanf(""%d"", &jogador);
                    }
                    computador = rand();
                    printf("""", computador, (1 + computador % 3));
                    printf(""\nComputador escolheu %d\n"", (1 + computador % 3));
                    if((1 + computador % 3) == 2 && jogador == 1 || (1 + computador % 3) == 3 && jogador == 2 || (1 + computador % 3) == 1 && jogador == 3)
                    {
                        printf(""Computador ganhou.\n"");
                        vitComputador++;
                    }else
                    {
                        if(jogador == (1 + computador % 3))
                        {
                            printf(""Empate.\n"");
                            empate++;
                        }else
                        {
                            printf(""Jogador ganhou.\n"");
                            vitJogador++;
                        }
                    }
                    partidas++;
                    printf(""\nJogar novamente?\n"");
                    printf(""1. Sim\n"");
                    printf(""2. Nao\n"");
                    scanf(""%d"", &jogar);
                    while(jogar < 1 || jogar > 2)
                    {
                        printf(""Opcao invalida. Escolha novamente.\n"");
                        printf(""\nJogar novamente?\n"");
                        printf(""1. Sim\n"");
                        printf(""2. Nao\n"");
                        scanf(""%d"", &jogar);
                    }
                    break;
                case 2:
                    printf(""\nJogador 1 escolha uma opcao: \n"");
                    printf(""1. Pedra\n"");
                    printf(""2. Papel\n"");
                    printf(""3. Tesoura\n"");
                    scanf(""%d"", &jogador1);
                    
                    while(jogador1 < 1 || jogador1 > 3)
                    {
                        printf(""Opcao invalida. Digite novamente.\n"");
                        printf(""\nJogador 1 escolha uma opcao: \n"");
                        printf(""1. Pedra\n"");
                        printf(""2. Papel\n"");
                        printf(""3. Tesoura\n"");
                        scanf(""%d"", &jogador1);
                    }
                    printf(""\nJogador 2 escolha uma opcao: \n"");
                    printf(""1. Pedra\n"");
                    printf(""2. Papel\n"");
                    printf(""3. Tesoura\n"");
                    scanf(""%d"", &jogador2);
                    
                    while(jogador2 < 1 || jogador2 > 3)
                    {
                        printf(""Opcao invalida. Digite novamente.\n"");
                        printf(""\nJogador 2 escolha uma opcao: \n"");
                        printf(""1. Pedra\n"");
                        printf(""2. Papel\n"");
                        printf(""3. Tesoura\n"");
                        scanf(""%d"", &jogador2);
                    }
                    if(jogador1 == 2 && jogador2 == 1 || jogador1 == 3 && jogador2 == 2 || jogador1 == 1 && jogador2 == 3)
                    {
                        printf(""Jogador 1 ganhou.\n"");
                        vitJogador1++;
                    }else
                    {
                        if(jogador1 == jogador2)
                        {
                            printf(""Empate.\n"");
                            empate++;
                        }else
                        {
                            printf(""Jogador 2 ganhou.\n"");
                            vitJogador2++;
                        }
                    }
                    partidas++;
                    printf(""\nJogar novamente?\n"");
                    printf(""3. Sim\n"");
                    printf(""4. Nao\n"");
                    scanf(""%d"", &jogar);
                    while(jogar < 3 || jogar > 4)
                    {
                        printf(""Opcao invalida. Escolha novamente.\n"");
                        printf(""\nJogar novamente?\n"");
                        printf(""3. Sim\n"");
                        printf(""4. Nao\n"");
                        scanf(""%d"", &jogar);
                    }
                    break;
            }
            if(jogar == 1)
            {
            }else
            {
                if(jogar == 2)
                {
                    printf(""\nTotal de %d partida(s).\n"", partidas);
                    printf(""\nComputador venceu %d partida(s). \n"", vitComputador);
                    printf(""Jogador venceu %d partida(s). \n"", vitJogador);
                    printf(""Total de %d empate(s). \n"", empate);
                    percVitoriasComputador = (vitComputador * 100) / partidas;
                    printf(""Percentual de vitorias do computador = %.2f%%\n"", percVitoriasComputador);
                    percVitoriasJogador = (vitJogador * 100) / partidas;
                    printf(""Percentual de vitorias do jogador = %.2f%%\n"", percVitoriasJogador);
                    break;          
                }else
                {
                    if(jogar == 3)
                    {
                    }else
                    {
                        if(jogar == 4)
                        {
                            printf(""\nTotal de %d partida(s).\n"", partidas);
                            printf(""\nJogador 1 venceu %d partida(s). \n"", vitJogador1);
                            printf(""Jogador 2 venceu %d partida(s). \n"", vitJogador2);
                            printf(""Total de %d empate(s). \n"", empate);
                            percVitoriasJogador1 = (vitJogador1 * 100) / partidas;
                            printf(""Percentual de vitorias do jogador 1 = %.2f%\n"", percVitoriasJogador1);
                            percVitoriasJogador2 = (vitJogador2 * 100) / partidas;
                            printf(""Percentual de vitorias do jogador 2 = %.2f%\n"", percVitoriasJogador2);
                            break;
                        }
                    }
                }
            }       
        }while(opcao == 1 || opcao == 2);   
    return 0;
}
",51,152,2197
"#define logico int
#define TRUE 1
#define FALSE 0



char captchaLido[6];
char captchaGerado[6];

char * gerarCaptcha (char captchaGerado[6]) {

    int contadorLetras;
    int padraoCaptcha;

    padraoCaptcha = rand() % 3;
    switch (padraoCaptcha) {

        case 0: {
            for (contadorLetras=0; contadorLetras < 6 ; contadorLetras++) {
                if(contadorLetras == 0 || contadorLetras == 3) {
                    captchaGerado[contadorLetras] = 65 + (rand() % 26);
                } else {
                    if(contadorLetras == 1 || contadorLetras == 4) {
                        captchaGerado[contadorLetras] = 48 + (rand() % 10);
                    } else {
                        if(contadorLetras == 2 || contadorLetras == 5 ) {
                            captchaGerado[contadorLetras] = 97 + (rand() % 26);
                        }
                    }
                }
            }
            break;
        }
        case 1: {
            for (contadorLetras=0; contadorLetras < 6 ; contadorLetras++) {
                if(contadorLetras == 1 || contadorLetras == 3) {
                    captchaGerado[contadorLetras] = 65 + (rand() % 26);
                } else {
                    if(contadorLetras == 0 || contadorLetras == 5) {
                        captchaGerado[contadorLetras] = 48 + (rand() % 10);
                    } else {
                        if(contadorLetras == 2 || contadorLetras == 4 ) {
                            captchaGerado[contadorLetras] = 97 + (rand() % 26);
                        }
                    }
                }
            }
            break;
        }
        case 2: {
            for (contadorLetras=0; contadorLetras < 6 ; contadorLetras++) {
                if(contadorLetras == 0 || contadorLetras == 5) {
                    captchaGerado[contadorLetras] = 65 + (rand() % 26);
                } else {
                    if(contadorLetras == 2 || contadorLetras == 3) {
                        captchaGerado[contadorLetras] = 48 + (rand() % 10);
                    } else {
                        if(contadorLetras == 1 || contadorLetras == 4 ) {
                            captchaGerado[contadorLetras] = 97 + (rand() % 26);
                        }
                    }
                }
            }
            break;
        }
    }
    return captchaGerado;
}

logico validarCaptcha ( char captchaLido[6], char captchaGerado [6]) {
    int contador, contIguais;

    contIguais=0;
    for (contador=0; contador<6; contador++) {
        if( captchaLido[contador] == captchaGerado[contador]) {
            contIguais++;
        } else {
            contIguais = 0;
            break;
        }
    }

    if ( contIguais == 6) {
        return TRUE;
    } else {
        if(contIguais == 0) {
            return FALSE;
        }
    }
}

int main(int argc, char *argv[]) {
    char novamente;
    char *captcha;
    logico result;

    srand(time(NULL));


    do {
        novamente = 'N';
        captcha = gerarCaptcha(captchaGerado);
        printf("" --Por Favor, digite o CAPTCHA abaixo, respeitando maiusculas e minusculas:\n\n   %s  \n\n"", captcha);
        gets(captchaLido);

        result = validarCaptcha ( captchaLido , captcha);

        if(result == TRUE) {
            printf(""   --Captcha Correto! Acesso Permitido!"");
        } else {
            if (result == FALSE) {
                printf("" --Voce nao digitou o Captcha corretamente. Por favor, tente novamente.\n\n"");
                novamente = 'S';
            }
        }

    } while (novamente == 'S');


    return 0;
}
",51,153,1179
"#include ""mddl_stl_slist.h""


#ifdef DEBUG
static int debuglevel = 4;
#else
static const int debuglevel = 0;
#endif
#include ""dbms.h""
#define EOL_CRLF ""\n\r""

void __attribute__((weak)) *mddl_malloc(const size_t size)
{
    return malloc(size);
}

void __attribute__((weak)) mddl_free( void *const ptr )
{
    free(ptr);
}

typedef struct _fifoitem {
    struct _fifoitem *next;
    unsigned char data[];
} fifoitem_t;

typedef struct _mddl_stl_slist_ext {
    fifoitem_t *r_p, *w_p;  
    size_t sizof_element;
    size_t cnt;
    fifoitem_t base;        
} mddl_stl_slist_ext_t;

#define get_stl_slist_ext(s) (mddl_stl_slist_ext_t*)((s)->ext)
#define get_const_stl_slist_ext(s) (const mddl_stl_slist_ext_t*)((s)->ext)

static fifoitem_t *slist_get_foward_element_ptr( const mddl_stl_slist_ext_t *const e, void * const element_ptr);


static fifoitem_t *slist_get_foward_element_ptr( const mddl_stl_slist_ext_t *const e, void * const element_ptr)
{
    fifoitem_t *cur;

    if( (e->cnt == 0) || (e->w_p == &e->base) ) {
    return NULL;
    }

    for( cur=e->w_p; cur->next != NULL; cur=cur->next) {
    if( cur->next == element_ptr ) {
        return cur;
    }
    }

    return NULL;
}



int mddl_stl_slist_init(mddl_stl_slist_t *const self_p,
               const size_t sizof_element)
{
    mddl_stl_slist_ext_t *e = NULL;
    memset(self_p, 0x0, sizeof(mddl_stl_slist_t));

    e = (mddl_stl_slist_ext_t *)
    mddl_malloc(sizeof(mddl_stl_slist_ext_t));
    if (NULL == e) {
    DBMS1(""%s : mddl_malloc(ext) fail"" EOL_CRLF, __func__);
    return EAGAIN;
    }
    memset(e, 0x0, sizeof(mddl_stl_slist_ext_t));

    self_p->ext = e;
    self_p->sizof_element = e->sizof_element = sizof_element;

    e->r_p = e->w_p = &e->base;

    return 0;
}


int mddl_stl_slist_destroy(mddl_stl_slist_t *const self_p)
{
    int result;
    mddl_stl_slist_ext_t * const e = get_stl_slist_ext(self_p);

    result = mddl_stl_slist_clear(self_p);
    if (result) {
    DBMS1(""%s : que_clear fail"" EOL_CRLF, __func__);
    return EBUSY;
    }

    
    if (e->r_p != &e->base) {
    mddl_free(e->r_p);
    e->r_p = NULL;
    }

    mddl_free(self_p->ext);
    self_p->ext = NULL;

    return 0;
}


int mddl_stl_slist_push(mddl_stl_slist_t *const self_p, const void *const el_p,
               const size_t sizof_element)
{
    int status;
    mddl_stl_slist_ext_t * const e = get_stl_slist_ext(self_p);
    fifoitem_t *__restrict f = NULL;

    if (e->sizof_element != sizof_element) {
    return EINVAL;
    }

    f = (fifoitem_t *)mddl_malloc(sizeof(fifoitem_t) + e->sizof_element);
    if (NULL == f) {
    DBMS1(
          ""%s : mddl_malloc(fifoitem_t) fail"" EOL_CRLF, __func__);
    status = EAGAIN;
    goto out;
    }

    memset(f, 0x0, sizeof(fifoitem_t));
    memcpy(f->data, el_p, e->sizof_element);
    f->next = NULL;

    
    e->w_p->next = f;
    e->w_p = f;
    ++(e->cnt);

    status = 0;

  out:
    if (status) {
    if (NULL != f) {
        mddl_free(f);
    }
    }
    return status;
}


int mddl_stl_slist_pop(mddl_stl_slist_t *const self_p)
{
    mddl_stl_slist_ext_t * const e = get_stl_slist_ext(self_p);
    fifoitem_t *__restrict tmp = NULL;

    
    if (e->cnt == 0 ) {
    return ENOENT;
    }

    if((e->r_p == &e->base) && ( e->r_p->next == NULL)) { 
    return -1;
    }

    tmp = e->r_p;
    e->r_p = e->r_p->next;
    --(e->cnt);

    if (tmp != &e->base) {
    mddl_free(tmp);
    }

    if (e->cnt == 0) {
    if (e->r_p != &e->base) {
        mddl_free(e->r_p);
    }
    e->r_p = e->w_p = &e->base;
    }

    return 0;
}


int mddl_stl_slist_front(mddl_stl_slist_t *const self_p, void *const el_p,
                const size_t sizof_element)
{
    mddl_stl_slist_ext_t * const e = get_stl_slist_ext(self_p);
    fifoitem_t *__restrict f;

    if (e->sizof_element != sizof_element) {
    return EINVAL;
    }

    if (e->cnt == 0) {
    
    return ENOENT;
    }
    f = e->r_p->next;

    memcpy(el_p, f->data, e->sizof_element);

    return 0;
}


int mddl_stl_slist_clear(mddl_stl_slist_t *const self_p)
{
    mddl_stl_slist_ext_t * const e = get_stl_slist_ext(self_p);
    size_t n;
    int result;

    if (e->cnt == 0) {
    return 0;
    }

    for (n = e->cnt; n != 0; --n) {
    result = mddl_stl_slist_pop(self_p);
    if (result) {
        DBMS1(
          ""%s : mddl_stl_slist_pop[%llu] fail"" EOL_CRLF, __func__, n);
        return -1;
    }
    }

    return 0;
}


size_t mddl_stl_slist_get_pool_cnt(mddl_stl_slist_t *const self_p)
{
    const mddl_stl_slist_ext_t * const e = get_const_stl_slist_ext(self_p);

    return e->cnt;
}


int mddl_stl_slist_is_empty(mddl_stl_slist_t *const self_p)
{
    const mddl_stl_slist_ext_t * const e = get_const_stl_slist_ext(self_p);

    return (e->cnt == 0) ? 1 : 0;
}


int mddl_stl_slist_get_element_at(mddl_stl_slist_t *const self_p,
                       const size_t num, void *const el_p,
                       const size_t sizof_element)
{
    mddl_stl_slist_ext_t * const e = get_stl_slist_ext(self_p);
    fifoitem_t *__restrict item_p = &e->base;
    size_t n;

    if (mddl_stl_slist_is_empty(self_p)) {
    return EACCES;
    }

    if (NULL == el_p) {
    return EFAULT;
    }

    if (sizof_element < e->sizof_element) {
    return EINVAL;
    }

    if (!(num < e->cnt)) {
    return ENOENT;
    }

    for (n = 0; n < num; ++n) {
    item_p = item_p->next;
    }

    memcpy(el_p, item_p->next->data, e->sizof_element);

    return 0;
}



int mddl_stl_slist_back( mddl_stl_slist_t *const self_p, void *const el_p, const size_t  sizof_element )
{
    mddl_stl_slist_ext_t * const e = get_stl_slist_ext(self_p);
    fifoitem_t *__restrict tmp = NULL;

    
    if (e->cnt == 0) {
    return ENOENT;
    } else if( e->sizof_element != sizof_element ) {
    return EINVAL;
    }

    if (e->w_p == NULL) {
    return -1;
    }

    tmp = e->w_p;
    memcpy( el_p, tmp->data, e->sizof_element);

    return 0;
}


int mddl_stl_slist_insert_at( mddl_stl_slist_t *const self_p, const size_t no, void *const el_p, const size_t  sizof_element )
{
    size_t n;
    mddl_stl_slist_ext_t * const e = get_stl_slist_ext(self_p);
    fifoitem_t *__restrict cur_ticket_p = &e->base;
    fifoitem_t *__restrict fwd_ticket_p;
    fifoitem_t *__restrict f;

    if (mddl_stl_slist_is_empty(self_p)) {
    return ENOENT;
    }

    if (NULL == el_p) {
    return EFAULT;
    }

    if ((e->sizof_element != sizof_element) || ( no < e->cnt) ) {
    return EINVAL;
    }

    for (n = 0; n <= no; ++n) {
    cur_ticket_p = cur_ticket_p->next;
    }

    fwd_ticket_p = slist_get_foward_element_ptr( e, cur_ticket_p);
    if( NULL == fwd_ticket_p ) {
    return EFAULT;
    }

    f = (fifoitem_t *) mddl_malloc(sizeof(fifoitem_t) + e->sizof_element);
    if (NULL == f) {
    DBMS1(
          ""%s : mddl_malloc(fifoitem_t) fail"" EOL_CRLF, __func__);
    return EAGAIN;
    }

    memset(f, 0x0, sizeof(fifoitem_t));
    memcpy(f->data, el_p, e->sizof_element);
    f->next = NULL;

    
    f->next = cur_ticket_p;
    fwd_ticket_p->next = f;
    ++(e->cnt);

    return 0;
}


int mddl_stl_slist_erase_at( mddl_stl_slist_t *const self_p, const size_t no)
{
    mddl_stl_slist_ext_t * const e = get_stl_slist_ext(self_p);
    fifoitem_t *__restrict tmp = NULL;
    fifoitem_t *__restrict fwd_ticket_p;

    
    if (e->cnt == 0 || !(no < e->cnt) ) {
    return ENOENT;
    }

    if((e->r_p == &e->base) || ( e->r_p->next == NULL)) {
    return ENOENT;
    }

    if( no == 0 ) {
    tmp = e->r_p;
    e->r_p = e->r_p->next;
    --(e->cnt);
    } else {
    size_t n;
    fifoitem_t *__restrict cur_ticket_p = &e->base;

    for (n = 0; n <= no; ++n) {
            cur_ticket_p = cur_ticket_p->next;
    }

        fwd_ticket_p = slist_get_foward_element_ptr( e, cur_ticket_p);
        if( NULL == fwd_ticket_p ) {
        return EFAULT;
        }
    }


    if (tmp != &e->base) {
    mddl_free(tmp);
    }

    if (e->cnt == 0) {
    if (e->r_p != &e->base) {
        mddl_free(e->r_p);
    }
    e->r_p = e->w_p = &e->base;
    }

    return 0;

}

",52,154,3799
"#ifdef __GNUC__
__attribute__ ((unused))
#endif
#ifdef DEBUG
static int debuglevel = 4;
#else
static const int debuglevel = 0;
#endif

#include ""dbms.h""

#if defined(_MULTIOS_DMSG_IS_UART)
#define EOL_CRLF ""\n\r""
#else
#define EOL_CRLF ""\n""
#endif


#include ""mbmcs_LIMITED_MOTION_2STATE_SWITCH.h""

#define MBMCS_EXTTEND_MODULE_MEMMAP_ADDR 0xC0000000
#define MBMCS_MEMALIGN 4

#define LMSW_OP_STAT_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x0))
#define LMSW_THRESHOLD_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x4))

#define LMSW_MODULE_OP_ENABLE_BIT ((uint32_t)0x1)
#define LMSW_MODULE_OP_ENABLE_SHIFT (31)
#define LMSW_MODULE_OP_ENABLE_MASK \
    (LMSW_MODULE_OP_ENABLE_BIT << LMSW_MODULE_OP_ENABLE_SHIFT)
#define LMSW_OP_INTR_ENABLE_BIT ((uint32_t)0x1)
#define LMSW_OP_INTR_ENABLE_SHIFT (30)
#define LMSW_OP_INTR_ENABLE_MASK \
    (LMSW_OP_INTR_ENABLE_BIT << LMSW_OP_INTR_ENABLE_SHIFT)
#define LMSW_OP_INITIALIZED_BIT ((uint32_t)0x1)
#define LMSW_OP_INITIALIZED_SHIFT (27)
#define LMSW_ST_INITIALIZED_MASK \
    (LMSW_OP_INITIALIZED_BIT << LMSW_OP_INITIALIZED_SHIFT)

#define LMSW_ST_CURRENT_LEVEL_BIT ((uint32_t)0x1)
#define LMSW_ST_CURRENT_LEVEL_SHIFT (2)
#define LMSW_ST_CURRENT_LEVEL_MASK \
    (LMSW_ST_CURRENT_LEVEL_BIT << LMSW_ST_CURRENT_LEVEL_SHIFT)

#define LMSW_ST_TIMEDOUT_BIT ((uint32_t)0x1)
#define LMSW_ST_TIMEDOUT_SHIFT (1)
#define LMSE_ST_TIMEDOUT_MASK \
    (LMSW_ST_TIMEDOUT_BIT << LMSW_ST_TIMEDOUT_SHIFT)

#define LMSW_ST_INTIME_BIT ((uint32_t)0x1)
#define LMSW_ST_INTIME_SHIFT (0)
#define LMSW_ST_INTIME_MASK \
    (LMSW_ST_INTIME_BIT << LMSW_ST_INTIME_SHIFT)


extern int mbmcs_limited_motion_2state_switch_init( mbmcs_limited_motion_2state_switch_t * const, const uintptr_t )
    __attribute__ ((optimize(""O2"")));

extern void mbmcs_limited_motion_2state_switch_irq_enable(const mbmcs_limited_motion_2state_switch_t *, bool)
    __attribute__ ((optimize(""O2"")));

void mbmcs_limited_motion_2state_switch_get_interrupt_status(const mbmcs_limited_motion_2state_switch_t *const, mbmcs_limited_motion_2state_switch_status_t *)
    __attribute__ ((optimize(""O2"")));

extern void mbmcs_limited_motion_2state_switch_clear_interrupt_status(const mbmcs_limited_motion_2state_switch_t *const)
    __attribute__ ((optimize(""O2"")));

extern void mbmcs_limited_motion_2state_switch_set_limited_timer(const mbmcs_limited_motion_2state_switch_t *const, const uint16_t)
    __attribute__ ((optimize(""O2"")));


int mbmcs_limited_motion_2state_switch_init( mbmcs_limited_motion_2state_switch_t * const self_p, const uintptr_t base_addr)
{
    if((base_addr < MBMCS_EXTTEND_MODULE_MEMMAP_ADDR) ||  ( base_addr % MBMCS_MEMALIGN )) {
    return EINVAL;
    }

    self_p->base_addr = base_addr;
    LMSW_OP_STAT_REG(self_p->base_addr) = (uint32_t)LMSW_MODULE_OP_ENABLE_MASK;

    for(;;) {
    uint32_t reg32;
    reg32 = LMSW_OP_STAT_REG(self_p->base_addr);
    if( reg32 & LMSW_ST_INITIALIZED_MASK) {
        return 0;
    }
    }
    return EPERM;
}

void mbmcs_limited_motion_2state_switch_get_interrupt_status(const mbmcs_limited_motion_2state_switch_t *const self_p, mbmcs_limited_motion_2state_switch_status_t *const stat_p)
{
    const uint32_t reg32 = LMSW_OP_STAT_REG(self_p->base_addr);
    mbmcs_limited_motion_2state_switch_status_t stat;

    stat.flags = 0;

    if(reg32 & LMSW_ST_CURRENT_LEVEL_MASK) {
    stat.f.cur_level = 0x1;
    }

    if(reg32 & LMSE_ST_TIMEDOUT_MASK) {
    stat.f.timedout = 0x1;
    }

    if(reg32 & LMSW_ST_INTIME_MASK ) {
    stat.f.intime = 0x1;
    }

    *stat_p = stat;

    return;
}

void mbmcs_limited_motion_2state_switch_clear_interrupt_status(const mbmcs_limited_motion_2state_switch_t *const self_p)
{
    uint32_t reg32 = LMSW_OP_STAT_REG(self_p->base_addr);

    reg32 &= ~(LMSE_ST_TIMEDOUT_MASK | LMSW_ST_INTIME_MASK);

    LMSW_OP_STAT_REG(self_p->base_addr) = reg32;

    return;
}

void mbmcs_limited_motion_2state_switch_set_limited_timer(const mbmcs_limited_motion_2state_switch_t *const self_p, const uint16_t milisec)
{
    const uint32_t reg32 = milisec * 10;

    LMSW_THRESHOLD_REG(self_p->base_addr) = reg32;

    return;
}

void mbmcs_limited_motion_2state_switch_irq_enable(const mbmcs_limited_motion_2state_switch_t *self_p, bool is_true)
{
    uint32_t reg32 = LMSW_OP_STAT_REG(self_p->base_addr);

    if(is_true== true ) {
    reg32 |= LMSW_OP_INTR_ENABLE_MASK;
    } else {
    reg32 &= ~LMSW_OP_INTR_ENABLE_MASK;
    }

    LMSW_OP_STAT_REG(self_p->base_addr) = reg32;

    return;
}

",52,155,2110
"#define MAXLEN 14
#define MAX_STACK_SIZE 10000000
#define MAX 455
#define MALLOC(p,s)\
    if(!((p)=malloc(s))){\
        fprintf(stderr,""Insufficient memory"");\
        exit(EXIT_FAILURE);\
    }
char* make1darr(int n){
    char *x;
    MALLOC(x,n*sizeof(*x));
    return x;
}
char*** make3darr(int rows, int cols,int hei){
    char ***x;
    MALLOC(x,rows*sizeof(**x));
    int i,j;
    for(i=0;i<rows;i++){
        MALLOC(x[i],cols*sizeof(**x));
        for(j=0;j<hei;j++){
            MALLOC(x[i][j],hei*sizeof(***x));
        }
    }
    return x;
}

int*** make3darrint(int rows, int cols,int hei){
    int ***x;
    MALLOC(x,rows*sizeof(**x));
    int i,j;
    for(i=0;i<rows;i++){
        MALLOC(x[i],cols*sizeof(**x));
        for(j=0;j<hei;j++){
            MALLOC(x[i][j],hei*sizeof(***x));
        }
    }
    return x;
}
typedef struct{
    short int row;
    short int col;
    short int hei;
    short int dir;
} element;
element queue[MAX_STACK_SIZE];
int rear = -1;
int front = -1;
void queueFull(){
    fprintf(stderr, ""ä½åå·²æ»¿ï¼ä¸è½åå å¥åç´ "");
    exit(EXIT_FAILURE);
}
void addq(element item){
    if(rear==MAX_STACK_SIZE-1){
        queueFull();
    }
    queue[++rear] = item;
}
element deleteq(){
    if(front==rear){
        fprintf(stderr, ""1ä½åå·²ç©º"");
    }
    return queue[++front];
}

typedef struct{
    element t;
    int flag;
} tpoint;
tpoint queue2[MAX_STACK_SIZE];
int rear2 = -1;
int front2 = -1;
void addq2(tpoint item){
    if(rear2==MAX_STACK_SIZE-1){
        queueFull();
    }
    queue2[++rear2] = item;
}
tpoint deleteq2(){
    if(front2==rear2){
        fprintf(stderr, ""1ä½åå·²ç©º"");
    }
    return queue2[++front2];
}

typedef struct{
    short int vert;
    short int horiz;
    short int hei;
}offsets;
offsets move[6];


int min=10000;
int n;


int bfs(char*** maze,int*** d,int sr,int sc,int sh){

    int laststep=0;
    int arrive=0;
    element position;
    position.row = sr;
    position.col = sc;
    position.hei = sh;
    

    addq(position);
    int i,j,k,q;
    for(i=0;i<n/2+1;i++){
        for(j=0;j<n+2;j++){
            for(k=0;k<n+2;k++){
                d[i][j][k]=MAX;
            }
        }
    }
    d[sh][sr][sc]=0;
    

    int nr,nc,nh;
    int row,col,hei;
    while(rear!=front){
        

        
        position = deleteq();
        row = position.row;
        col = position.col;
        hei = position.hei;
        
        
        
        
        if(laststep!=d[hei][row][col] ){
            
            if(front2!=rear2){
                for(i=front2+1;i<=rear2;i++){
                    if(queue2[i].flag!=0){
                        if((queue2[i].flag-d[hei][row][col]+laststep)>=0){
                            queue2[i].flag-=(d[hei][row][col]-laststep);
                            
                            
                            
                        }
                        else queue2[i].flag=0;
                    }
                    if(queue2[i].flag==0){
                        addq(queue2[i].t);
                        deleteq2();
                        nr = queue2[i].t.row;
                        nc = queue2[i].t.col;
                        nh = queue2[i].t.hei;
                        
                        d[nh][nr][nc]=d[hei][row][col]+1;
                        
                    }
                }
            }
            laststep=d[hei][row][col];
        }
        
        
        
        
        if(maze[hei][row][col]=='U' || maze[hei][row][col]=='D'){
            
            
            int upanddown=-1;
            if(maze[hei][row][col]=='U'){
                
                upanddown=1;
            }
            

            nr = row;
            nc = col;
            nh = hei+upanddown;
            
            
            if(nh>=0){
                if(maze[nh][nr][nc]=='F'){
                    d[nh][nr][nc]=d[hei][row][col]+1;
                    
                    
                    if(min>d[nh][nr][nc]){
                        min = d[nh][nr][nc];
                    }
                    
                    return 1;
                }
                if(maze[nh][nr][nc]=='T'&& d[nh][nr][nc]==MAX){
                    
                    d[nh][nr][nc]=-1;
                    element nextposition;
                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;

                        tpoint Tpoint;

                        Tpoint.t=nextposition;
                        Tpoint.flag=2;
                        addq2(Tpoint);
                        
                        int r = queue2[front2].t.row;
                        int c = queue2[front2].t.col;
                        int h = queue2[front2].t.hei;
                        


                }
                else if (maze[nh][nr][nc]!='X'  && d[nh][nr][nc]==MAX){
                    
                    d[nh][nr][nc]=d[hei][row][col]+1;

                    element nextposition;
                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;
                    addq(nextposition);
                    
                }
            }

        }
        
        for(i=0;i<4;i++){
            nr = row+move[i].vert;
            nc = col+move[i].horiz;
            nh = hei+move[i].hei;
            if(maze[nh][nr][nc]=='T'&& d[nh][nr][nc]==MAX){
                d[nh][nr][nc]=-1;
                
                element nextposition;
                nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;

                    tpoint Tpoint;
                    Tpoint.t=nextposition;
                    Tpoint.flag=2;
                    addq2(Tpoint);
                    
                    int r = queue2[rear2].t.row;
                    int c = queue2[rear2].t.col;
                    int h = queue2[rear2].t.hei;
                    
                    


            }
            else if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]==MAX){
                d[nh][nr][nc]=d[hei][row][col]+1;
                element nextposition;
                nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;
                addq(nextposition);
                
            }

        }
        if(rear==front){
            int lastflag=queue2[front2+1].flag;
            for(i=front2+1;i<=rear2;i++){
                if(queue2[i].flag==lastflag){
                    addq(queue2[i].t);
                    deleteq2();
                    nr = queue2[i].t.row;
                    nc = queue2[i].t.col;
                    nh = queue2[i].t.hei;
                    
                    d[nh][nr][nc]=d[hei][row][col]+3;
                    

                }
                else{
                    queue2[i].flag-=lastflag;
                    
                }
            }
            laststep=lastflag;
        }
        

    }
    return arrive;
}

void path(int ***d,char ***maze,char*** road,int fr,int fc,int fh){

    int row=fr;
    int col=fc;
    int hei=fh;
    int i,j,k,nr,nc,nh;
    road[hei][row][col]='*';

    
    while(maze[hei][row][col]!='S'){
        
        if ((d[hei][row+1][col]==d[hei][row][col]-1&& maze[hei][row][col]!='T') || (d[hei][row+1][col]==d[hei][row][col]-3 && maze[hei][row][col]=='T')){
            
            row++;
        }
        else if ((d[hei][row-1][col]==d[hei][row][col]-1&& maze[hei][row][col]!='T') || (d[hei][row-1][col]==d[hei][row][col]-3 && maze[hei][row][col]=='T')){
            
            row--;
        }
        else if ((d[hei][row][col+1]==d[hei][row][col]-1&& maze[hei][row][col]!='T') || (d[hei][row][col+1]==d[hei][row][col]-3 && maze[hei][row][col]=='T')){
            col++;
        }
        else if ((d[hei][row][col-1]==d[hei][row][col]-1&& maze[hei][row][col]!='T') || (d[hei][row][col-1]==d[hei][row][col]-3 && maze[hei][row][col]=='T')){
            col--;
        }
        else if(maze[hei-1][row][col]=='U' &&((d[hei-1][row][col]==d[hei][row][col]-1&& maze[hei][row][col]!='T') || (d[hei-1][row][col]==d[hei][row][col]-3 && maze[hei][row][col]=='T'))){
            hei--;
        }
        else if(maze[hei+1][row][col]=='U' &&((d[hei+1][row][col]==d[hei][row][col]-1&& maze[hei][row][col]!='T') || (d[hei+1][row][col]==d[hei][row][col]-3 && maze[hei][row][col]=='T'))){
            hei++;
        }
        road[hei][row][col]='*';
    }
}
int main(){
    move[0].vert=-1;
    move[0].horiz=0;
    move[0].hei=0;
    move[1].vert=0;
    move[1].horiz=1;
    move[1].hei=0;
    move[2].vert=1;
    move[2].horiz=0;
    move[2].hei=0;
    move[3].vert=0;
    move[3].horiz=-1;
    move[3].hei=0;
    move[4].vert=0;
    move[4].horiz=0;
    move[4].hei=1;
    move[5].vert=0;
    move[5].horiz=0;
    move[5].hei=-1;
    
    char y;
    int i,j,k;

    FILE *pfile;
    char name[50];
    int control;
    for(control=2;control<=100;control++){
        min=100000;
        rear=-1;front=-1;
        rear2=-1;front2=-1;
        sprintf(name,""test%d.txt"",control);
        pfile = fopen(name,""r"");
        if(NULL==pfile){
            printf(""Open failure"");
            return 1;
        }
        else{
            printf(""reading %s\n"",name);
            
            char* bottom = make1darr(MAXLEN);
            n=0;
            char y;
            bottom[n]=fgetc(pfile);
            while(bottom[n]!='\n'){
                fgetc(pfile);
                bottom[++n]=fgetc(pfile);
                
            }
            char ***maze=make3darr(n/2+1,n+2,n+2);
            char ***road=make3darr(n/2+1,n+2,n+2);
            char ***mark=make3darr(n/2+1,n+2,n+2);
            int ***d=make3darrint(n/2+1,n+2,n+2);
            int len=0;
            int sr,sc,sh,fr,fc,fh;
            for(i=0;i<n/2+1;i++){
                for(j=0;j<n+2;j++){
                    for(k=0;k<n+2;k++){
                        if(j==0 || k==0 || j==n+1 || k==n+1){
                            maze[i][j][k]='X';
                        }
                        else if(i==0 && j==1){
                            maze[i][j][k]=bottom[k-1];
                        }
                        else if(j > len && j <= n-len && k > len && k <= n-len){
                            fscanf(pfile,""%c "",&maze[i][j][k]);

                        }
                        else{
                            maze[i][j][k]='X';
                        }
                        if(maze[i][j][k]=='S'){
                            sh=i;
                            sr=j;
                            sc=k;
                        }
                        if(maze[i][j][k]=='F'){
                            fh=i;
                            fr=j;
                            fc=k;
                        }
                        road[i][j][k]=maze[i][j][k];
                        mark[i][j][k]=maze[i][j][k];
                    }
                }
                len++;
            }
            FILE *wfile;
            sprintf(name,""test%d_ans.txt"",control);
            wfile = fopen(name,""w"");
            if( NULL == wfile ){
                printf( ""wfile open failure"" );
                return 1;
            }
            else{
                if(bfs(maze,d,sr,sc,sh)){
                    
                    
                    path(d,maze,road,fr,fc,fh);
                    
                    
                    fprintf(wfile,""Path length: %d\n"",min);
                    fprintf(wfile,""=====outMaze=====\n"");
                    for(i=0;i<n/2+1;i++){
                        for(j=i+1;j<n+2-i-1;j++){
                            for(k=i+1;k<n+2-i-1;k++){
                                fprintf(wfile,""%c "",road[i][j][k] );
                            }
                            fprintf(wfile,""\n"");
                        }
                        fprintf(wfile,""\n"");
                    }
                }
                else fprintf(wfile,""The maze does not have a path\n"" );
            }
            free(bottom);

            for(i = 0; i < n/2+1; i++) {
                for(j=0;j<n+2;j++){
                    free(maze[i][j]);
                }
            }
            for(i=0;i < n/2+1; i++){
                free(maze[i]);
            }
            free(maze);
            for(i = 0; i < n/2+1; i++) {
                for(j=0;j<n+2;j++){
                    free(mark[i][j]);
                }
            }
            for(i=0;i < n/2+1; i++){
                free(mark[i]);
            }
            free(mark);
            for(i = 0; i < n/2+1; i++) {
                for(j=0;j<n+2;j++){
                    free(road[i][j]);
                }
            }
            for(i=0;i < n/2+1; i++){
                free(road[i]);
            }
            free(road);
            for(i = 0; i < n/2+1; i++) {
                for(j=0;j<n+2;j++){
                    free(d[i][j]);
                }
            }
            for(i=0;i < n/2+1; i++){
                free(d[i]);
            }
            free(d);
        }
        fclose(pfile);

    }
}
",53,156,4735
"#define MAX_STACK_SIZE 100000
#define MAX 401
#define MALLOC(p,s)\
    if(!((p)=malloc(s))){\
        fprintf(stderr,""Insufficient memory"");\
        exit(EXIT_FAILURE);\
    }
char** arr(int rows, int cols){
    char **x;
    MALLOC(x,rows*sizeof(*x));
    int i;
    for(i=0;i<rows;i++){
        MALLOC(x[i],cols*sizeof(**x));
    }
    return x;
}
int** arrc(int rows, int cols){
    int **x;
    MALLOC(x,rows*sizeof(*x));
    int i;
    for(i=0;i<rows;i++){
        MALLOC(x[i],cols*sizeof(**x));
    }
    return x;
}
typedef struct{
    short int row;
    short int col;
    short int dir;
} element;
element queue[MAX_STACK_SIZE];
int rear = -1;
int front = -1;
void queueFull(){
    fprintf(stderr, ""ä½åå·²æ»¿ï¼ä¸è½åå å¥åç´ "");
    exit(EXIT_FAILURE);
}
void addq(element item){
    if(rear==MAX_STACK_SIZE-1){
        queueFull();
    }
    queue[++rear] = item;
}
element deleteq(){
    if(front==rear){
        fprintf(stderr, ""ä½åå·²ç©º"");
    }
    return queue[++front];
}

typedef struct{
    short int vert;
    short int horiz;
}offsets;
offsets move[4];


int min=100000;

int bfs(char** maze,int **d,int num,int sx,int sy){
    int arrive=0;

    queue[0].row = sx; queue[0].col = sy;
    rear++;
    
    int i,j;
    for(i=0;i<num+2;i++){
        for(j=0;j<num+2;j++){
            d[i][j]=MAX;
        }
    }
    d[sx][sy]=0;
    

    element position;
    int nr,nc;
    int row,col;
    while (rear!=front){
        position = deleteq();
        row = position.row;
        col = position.col;
        
        if(maze[row][col]=='F'){
            if(min>d[row][col]){
                min=d[row][col];
            }
            arrive=1;
            break;
        }
        
        for(i=0;i<4;i++){
            nr = position.row+move[i].vert;
            nc = position.col+move[i].horiz;
            
            if (maze[nr][nc]!='X' && d[nr][nc]>d[row][col]+1){
                d[nr][nc]=d[row][col]+1;;
                element nextposition;
                nextposition.row=nr;nextposition.col=nc;
                addq(nextposition);
            }
        }
        
    }
    return arrive;
}

void path(int **d,char **maze,char** road,int fx,int fy,int num){
    int row=fx;
    int col=fy;
    int i,j,nr,nc;
    road[row][col]='*';
    while(maze[row][col]!='S'){
        for(i=0;i<4;i++){
            nr = row+move[i].vert;
            nc = col+move[i].horiz;
            if (d[nr][nc] == d[row][col]-1){
                
                row=nr;
                col=nc;
                break;
            }
        }
        road[row][col]='*';
    }
}

int main(){

    move[0].vert=-1;
    move[0].horiz=0;
    move[1].vert=0;
    move[1].horiz=1;
    move[2].vert=1;
    move[2].horiz=0;
    move[3].vert=0;
    move[3].horiz=-1;
    
    int num,i,j,startx,starty,finalx,finaly;
    FILE *rptr;
    rptr = fopen(""test.txt"",""r"");
    if(NULL==rptr){
        printf(""Open failure"");
        return 1;
    }
    else{
        fscanf(rptr,""%d\n"",&num);
        char** maze = arr(num+2,num+2);
        char** mark = arr(num+2,num+2);
        char** road = arr(num+2,num+2);
        int** d = arrc(num+2,num+2);
        for(i=0;i<num+2;i++){
            for(j=0;j<num+2;j++){
                if(i==0 || j==0 || i==num+1 || j==num+1){
                    
                    maze[i][j]='X';
                }
                else{
                    fscanf(rptr,""%c "",&maze[i][j]);
                    if(maze[i][j]=='S'){
                        startx=i;
                        starty=j;
                    }
                    if(maze[i][j]=='F'){
                        finalx=i;
                        finaly=j;
                    }
                }
                road[i][j]=maze[i][j];
                mark[i][j]=maze[i][j];
            }
        }
        if(bfs(maze,d,num,startx,starty)){
            path(d,maze,road,finalx,finaly,num);
            for(i=1;i<num+2-1;i++){
                for(j=1;j<num+2-1;j++){
                    printf(""%c "",road[i][j]);
                }
                printf(""\n"");
            }
            printf(""æç­è·¯å¾çº%d\n"",min);
        }
        else printf(""The maze does not have a path\n"" );
        for(i = 0; i < num+2; i++) {
            free(maze[i]);
        }
        free(maze);
        for(i = 0; i < num+2; i++) {
            free(mark[i]);
        }
        free(mark);
        for(i = 0; i < num+2; i++) {
            free(road[i]);
        }
        free(road);
        free(d);
    }
    fclose(rptr);
}
",53,157,1791
"int es_primo(int numero);

int main(){
    
    
    
    

    int primos = 0, no_primos = 0;
    for (int numero = 1; numero <= 10000; numero++)
    {   
        if(es_primo(numero)==1){
            
            primos++;
        } else {
            
            no_primos++;
        }
    }
    printf(""Numero de primos %d, numero no primos %d"", primos, no_primos);

    return 0;
}



int es_primo(int numero){
    for (int i = 2; i <= sqrt(numero); i++){
        if ( numero % i == 0) {
            return 0;
        }
    }
    return 1;
}",54,158,208
"typedef struct{
    int id_number;
    int anu_income;
    int numOfMembers;
    int t;
}F;
F fam[5];
int IncomeSum=0;
int Members=0;

int sumOfIncome(int income){
    IncomeSum=IncomeSum+income;
    }

int totalOfMembers(int mem,int i){
    Members=Members+mem;
    fam[i].t=Members;

    }

int main(){

    FILE *fp;
    fp=fopen(""readme.txt"",""r"");
    int i=0,medianIncome;

    while(i<5){
        fscanf(fp,""%d\t\t%d\t\t\t%d"",&fam[i].id_number,&fam[i].anu_income,&fam[i].numOfMembers);
        sumOfIncome(fam[i].anu_income);
        totalOfMembers(fam[i].numOfMembers,i);
        i++;
    }

    printf(""IDNumber\tAnnualIncome($)\tNumberOfMembers\n\n"");
    for(i=0;i<5;i++){
        printf(""%d\t\t%d\t\t%d\n"",fam[i].id_number,fam[i].anu_income,fam[i].numOfMembers);
    }

    int avrgeIncm=IncomeSum/5;
    printf(""\nAverage household income($):%d\n"",avrgeIncm);
    printf(""\nTotal number of members in the town:%d\n"",Members);
    
    int medianPoint=Members/2;

    for(i=0;i<5;i++){
        if(medianPoint-fam[i].t<0){
            medianIncome=fam[i].anu_income;
            break;
        }
    }

    printf(""\nMedian Annual Income($):%d"",medianIncome);

    return 0;
}",55,159,523
"int main(){
    int num1,num2,num3;
    int *p1,*p2,*p3;

    printf(""Enter Number 1 : "");
    scanf(""%d"",&num1);
    printf(""Enter Number 2 : "");
    scanf(""%d"",&num2);
    printf(""Enter Number 3 : "");
    scanf(""%d"",&num3);
    printf(""\n"");
    
    p1 = &num1;
    p2 = &num2;
    p3 = &num3;
    
    
    if(*p1 > *p2){
        if(*p1 > *p3){
            printf(""Maximum is : %d\n"",*p1);
        }

        else{
            printf(""Maximum is : %d\n"",*p3);
        }
    }
    else{
        if(*p2 > *p3){
            printf(""Maximum is : %d\n"",*p2);
        }
        else{
            printf(""Maximum is : %d\n"",*p3);
        }
    }
    
    
    if(*p1 < *p2){
        if(*p1 < *p3){
            printf(""Minimum is : %d"",*p1);
        }
        else{
            printf(""Minimum is : %d"",*p3);
        }
    }
    else{
        if(*p2 < *p3){
            printf(""Minimum is : %d"",*p2);
        }
        else{
            printf(""Minimum is : %d"",*p3);
        }
    }
    return 0;
}",55,160,400
"#include ""binary_trees.h""


binary_tree_t *binary_tree_rotate_right(binary_tree_t *tree)
{
    binary_tree_t *y, *x;

    if (tree != NULL)
    {
        x = tree;
        if ((*x).left != NULL)
        {
            y = (*x).left;
            
            (*x).left = (*y).right;
            if ((*y).right != NULL)
            {
                (*(*y).right).parent = x;
            }
            
            (*y).parent = (*x).parent;
            if ((*x).parent == NULL)
            {
                tree = y;
            }
            else if (x == (*(*x).parent).right)
            {
                (*(*x).parent).right = y;
            }
            else
            {
                (*(*x).parent).left = y;
            }
            
            (*y).right = x;
            (*x).parent = y;
            return (tree);
        }
    }
    return (NULL);
}
",56,161,265
"int ft_eight_queens_puzzle(void);
int Mov_Queen(int [8][8], int, int);


int main(){
    printf(""%i"", ft_eight_queens_puzzle());
}

int ft_eight_queens_puzzle(void){
    int Tabla[8][8] = {{0,0,0,0,0,0,0,0},     
                       {0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0}};
    int  contador = 0;

    for(int Col_0 = 0; Col_0 < 8; Col_0++){  
        Tabla[Col_0][0] = 1; 

        for(int Col_1 = 0; Col_1 < 8; Col_1++){ 
            if(Mov_Queen(Tabla, Col_1, 1) == 0){
               Tabla[Col_1][1] = 1; 

               for (int Col_2 = 0; Col_2 < 8; Col_2++){ 
                   if(Mov_Queen(Tabla, Col_2, 2) == 0){
                        Tabla[Col_2][2] = 1; 

                        for (int Col_3 = 0; Col_3 < 8; Col_3++){ 
                            if(Mov_Queen(Tabla, Col_3, 3) == 0){
                                Tabla[Col_3][3] = 1; 

                                for (int Col_4 = 0; Col_4 < 8; Col_4++){  
                                    if(Mov_Queen(Tabla, Col_4, 4) == 0){
                                        Tabla[Col_4][4] = 1; 

                                        for (int Col_5 = 0; Col_5 < 8; Col_5++){ 
                                            if(Mov_Queen(Tabla, Col_5, 5) == 0){
                                                Tabla[Col_5][5] = 1; 

                                                for (int Col_6 = 0; Col_6 < 8; Col_6++){ 
                                                    if(Mov_Queen(Tabla, Col_6, 6) == 0){
                                                        Tabla[Col_6][6] = 1; 

                                                        for (int Col_7 = 0; Col_7 < 8; Col_7++) 
                                                        {
                                                            if(Mov_Queen(Tabla, Col_7, 7) == 0){
                                                                Tabla[Col_7][7] = 1; 
                                                                contador++;
                                                            }
                                                            Tabla[Col_7][7] = 0;  
                                                        }
                                                    }
                                                    Tabla[Col_6][6] = 0;
                                                }
                                            }
                                            Tabla[Col_5][5] = 0;
                                        }  
                                    } 
                                    Tabla[Col_4][4] = 0;
                                }
                            }
                            Tabla[Col_3][3] = 0;
                        }
                    }
                    Tabla[Col_2][2] = 0; 
                }
            }
            Tabla[Col_1][1] = 0;
        }
        Tabla[Col_0][0] = 0;
    }
    return contador; 
}


int Mov_Queen(int Tabla[8][8], int fila, int columna){   
                                                         
    int fila_actual = 0; 
    int columna_actual = 0; 
    int estado = 0; 
    
    for(int i = columna + 1; i < 8; i++) 
        if(Tabla[fila][i] == 1)
            estado = 1;
    
    for(int i = columna - 1; i >= 0; i--) 
       if(Tabla[fila][i] == 1)
            estado = 1; 

    for(int i = fila - 1; i >= 0; i--) 
       if(Tabla[i][columna] == 1)
            estado = 1; 

    for(int i = fila + 1; i < 8; i++) 
       if(Tabla[i][columna] == 1)
            estado = 1;

    fila_actual = fila - 1;
    columna_actual = columna + 1;
    while(columna_actual < 8 && fila_actual >= 0){    
        if(Tabla[fila_actual][columna_actual] == 1)
            estado = 1;
        fila_actual--;
        columna_actual++;
    }

    fila_actual = fila - 1;
    columna_actual = columna - 1;
    while(columna_actual >= 0 && fila_actual >= 0){    
        if(Tabla[fila_actual][columna_actual] == 1)
            estado = 1;
        fila_actual--;
        columna_actual--;
    }

    fila_actual = fila + 1;
    columna_actual = columna - 1;
    while(columna_actual >= 0 && fila_actual < 8){    
        if(Tabla[fila_actual][columna_actual] == 1)
            estado = 1;
        fila_actual++;
        columna_actual--;
    }

    fila_actual = fila + 1;
    columna_actual = columna + 1;
    while(columna_actual < 8 && fila_actual < 8){    
        if(Tabla[fila_actual][columna_actual] == 1)
            estado = 1;
        fila_actual++;
        columna_actual++;
    }
    return estado;
}",57,162,1668
"void Columna(int pibote)
{
    int i = 1;
    do
    {
        if(i >= 28){
            if(i >= (28 + pibote) && i <= 34 - pibote){
            printf("" "");
        }else{
            printf(""A"");
        }
        }else{
            printf("" "");
        }
        ++i;
    }while(i <= 34);
}


int main()
{
    int contador1 = 1;
    int contador2 = 7;
    do
    {
        printf(""\n"");
            if(contador1 >= 4)
            Columna(contador2);
        else
            Columna(contador1);
        
        --contador2;
        ++contador1;
    }while(contador1 < 8);
}",57,163,215
"void Columna(int pibote)
{
    int j = 1;
    while(j <= 20)
    {
        if(j >= (10 - pibote) && j <= (10 + pibote))
            printf(""Z"");
        else
            printf("" "");
        ++j;
    }
}

int main()
{
    int contador1 = 0;
    int contador2 = 7;
    while(contador1 < 8)
    {
    printf(""\n"");
    if(contador1 > 4)
        Columna(contador2 - 1);
    else
        Columna(contador1 - 1);
    --contador2;
    ++contador1;
    }
    return 0;

}",57,164,195
"double Fac(double num)
{
        if(num == 1)
                return 1;
        else
                return num * Fac(num - 1);
}

double Exp(int Exponente, double numero)
{
        if(Exponente == 1){
                return numero;
        }else{
                return numero * Exp(--Exponente, numero);
        }
}





void cosh(int contador, int iteraciones, double total, double X);


int main(){

        double X;
        printf(""Programa para calcular el cosh(X) por medio de sumas de Taylor\nValor de X:"");
        scanf(""%lf"", &X);
        cosh(1,30,0,X);
        return 0;
}

void cosh(int contador, int iteraciones, double total, double X)
{
        if(contador <= iteraciones){
                total = total + Exp((contador*2),X) / Fac((contador*2));
                cosh(++contador,iteraciones,total,X);
        }else{
                printf(""\n**El cosh(%lf) es igual a: %lf"",X,total+1);

        }
}

",57,165,305
"void Columna(int contador, int pibote);
void Filas(int contador);

int main()
{
        Filas(1);
        return 0;
}

void Columnas(int contador, int pibote){
    if(contador <= 13){
        if(contador >= (1 + pibote) && contador <= (13 - pibote))
                        printf(""P"");
                else
                        printf("" "");
                Columnas(++contador, pibote);
        }
}

void Filas(int contador)
{
        if(contador < 8){
                Columnas(1, (contador-1));
                printf(""\n"");
                Filas(++contador);
        }
}
",57,166,187
"double Fac(double num) 
{
        if(num == 1)
                return 1;
        else
                return num * Fac(num - 1);
}

double Exp(int Exponente, double numero) 
{
        if(Exponente == 1){
                return numero;
        }else{
                return numero * Exp(--Exponente, numero);
        }
}





void E(int contador, int iteraciones,double suma, double X);


int main()
{
        double X;
    int Numero_iteraciones;
        printf(""Programa para calcular Euler elevado a X me diante sumas de Taylor\nIngresa X: "");
        scanf(""%lf"", &X);
        
        E(1,30,0,X);
        return 0;
}

void E(int contador, int iteraciones,double suma, double X)
{
        if(contador <= iteraciones){
                printf(""\n->%i %0.0lf / %0.0lf = %0.6lf"",contador,Exp(contador,X),Fac((contador + 0.0)), Exp(contador,X) / (Fac(contador) + 0.0));
                suma = suma + Exp(contador,X) / (Fac(contador));
                printf(""\tSuma por el momento: %0.6lf\n"", suma);
                E(++contador,iteraciones,suma,X);
        }else{                
        printf(""\nEl resultado de e^%0.0lf es: %lf"",X , (suma + 1.0));
        }
}


",57,167,419
"#include ""UDP_sender.h""


void welcome(){
    printf(""[INFO] Usage: sender process.\n"");
    printf(""\n"");
}

int main(){
    welcome();
    printf(""Please input your message:"");
    
    int strSize = 20; 
    int payload_len = 0; 
    char input  = NULL; 
    unsigned char *payload = (unsigned char*)malloc(sizeof(char)*20);
    while((input=getc(stdin))!='\n') {
        payload[payload_len++] = input;
        if(payload_len%20==0) { 
            strSize+=20;    
            payload =(unsigned char*)realloc(payload,strSize);
        }
    }
    payload[payload_len] = '\0';
    
    udp_sender(payload,payload_len);
    printf(""[INFO] message send successfully!\n"");
    return 0;
}
",58,168,236
"#include ""UDP_sender.h""


void welcome(){
    printf(""[INFO] Usage: sender process.\n"");
    printf(""\n"");
}

int main(){
    welcome();
    printf(""Please input your message:"");
    
    int strSize = 20; 
    int payload_len = 0; 
    char input  = NULL; 
    unsigned char *payload = (unsigned char*)malloc(sizeof(char)*20);
    while((input=getc(stdin))!='\n') {
        payload[payload_len++] = input;
        if(payload_len%20==0) { 
            strSize+=20;    
            payload =(unsigned char*)realloc(payload,strSize);
        }
    }
    payload[payload_len] = '\0';
    
    udp_sender(payload,payload_len);
    printf(""[INFO] message send successfully!\n"");
    return 0;
}
",58,169,236
"void main()
{
    int sockopt,sockid,optlen,gs;
    sockid=socket(AF_INET,SOCK_STREAM,0);
    if(sockid==-1)
    {
        perror(""SOCK-CRE-ERR:"");
        exit(1);
    }

    optlen=sizeof(sockopt);
    gs=getsockopt(sockid,SOL_SOCKET,SO_TYPE,&sockopt,&optlen);
    if(gs==-1)
    {
        perror(""GETSOCK-ERR:"");
        close(sockid);
        exit(1);
    }
    switch(sockopt)
    {
        case SOCK_DGRAM:printf(""\nDatagram Socket\n"");
                break;
        case SOCK_STREAM:printf(""\nStream Socket\n"");
                break;
        case SOCK_RAW:printf(""\nRaw Socket\n"");
                break;
        default:printf(""\nUnknown Socket type\n"");
    }

    


    sockopt=2048;
    optlen=sizeof(sockopt);
    gs=setsockopt(sockid,SOL_SOCKET,SO_SNDBUF,&sockopt,optlen);
    if(gs!=-1)
    printf(""\nSend Buffer size is %d\n"",sockopt);
    else
    perror(""SND-BUF-ERR:"");

    optlen=sizeof(sockopt);
    gs=getsockopt(sockid,SOL_SOCKET,SO_SNDBUF,&sockopt,&optlen);
    if(gs!=-1)
    printf(""\nSend buffer size is %d\n"",sockopt);
    else
    perror(""SND-BUF-ERR:"");

    
    
    sockopt=2048;
    optlen=sizeof(sockopt);
    gs=setsockopt(sockid,SOL_SOCKET,SO_RCVBUF,&sockopt,optlen);
    if(gs!=-1)
    printf(""\nReceive Buffer size is %d\n"",sockopt);
    else
    perror(""RCV-BUF-ERR:"");

    optlen=sizeof(sockopt);
    gs=getsockopt(sockid,SOL_SOCKET,SO_RCVBUF,&sockopt,&optlen);
    if(gs!=-1)
    printf(""\nReceive Buffer size is %d\n"",sockopt);
    else
    perror(""RCV-BUF-ERR:"");

    optlen=sizeof(sockopt);
    gs=getsockopt(sockid,IPPROTO_TCP,TCP_MAXSEG,&sockopt,&optlen);
    if(gs!=-1)
    printf(""\nTCP MAX Segment size is %d\n"",sockopt);
    else
    perror(""TCP-SEG-ERR:"");

    optlen=sizeof(sockopt);
    sockopt=1;
    gs=setsockopt(sockid,IPPROTO_TCP,TCP_NODELAY,&sockopt,optlen);
    if(gs!=-1)
    printf(""\nNODELAY FLAG is set\n"");
    else
    perror(""TCP-NODELAY-ERR:"");


    optlen=sizeof(sockopt);
    gs=getsockopt(sockid,IPPROTO_TCP,TCP_NODELAY,&sockopt,&optlen);
    if(gs!=-1)
    if(sockopt==1)
    printf(""\nNODELAY flag is set\n"");
    else
    printf(""\nNODELAY flag not set\n"");
    else
    perror(""TCP-NODELAY-ERR:"");
    close(sockid);
}
",59,170,940
"void main(int argc,char* argv[])
{
    int sockid,rval,count=0,tlen;
    char msg[100];
    struct sockaddr_in lis,talk;
    system(""clear"");
    if(argc<3)
    {
        printf(""\nUSAGE : %s IP_ADDR PORT#\n"",argv[0]);
        exit(1);
    }
    lis.sin_family=AF_INET;
    lis.sin_port=htons(atoi(argv[2]));
    lis.sin_addr.s_addr=inet_addr(argv[1]);
    sockid=socket(AF_INET,SOCK_DGRAM,0);
    if(sockid==-1)
    {
        perror(""SOCK-CRE-ERR:"");
        exit(1);
    }
    rval=bind(sockid,(struct sockaddr*)&lis,sizeof(lis));
    if(rval==-1)
    {
        perror(""BIND-ERR:"");
        close(sockid);
        exit(1);
    }
    printf(""\nThe Listener is ready to accept messages\n"");
    tlen=sizeof(talk);
    while(1)
    {
        strncpy(msg,"" "",100);
        rval=recvfrom(sockid,msg,sizeof(msg),0,(struct sockaddr*)&talk,&tlen);
        if(rval==-1)
        {
            perror(""MSG-RCV-ERR:"");
            close(sockid);
            exit(1);
        }
        printf(""\nMessage %d read is %s\n"",++count,msg);
        if(!strcmp(msg,""EXIT""))
        break;
    }
    close(sockid);
}
",59,171,452
"#define _CRT_SECURE_NO_WARNINGS



typedef struct {
    char ime[10];
    char prezime[10];
    double bodovi;
}student;
int upis(FILE* fp, student* s, int n);
int main()
{
    int n = 0;
    FILE* fp = NULL;
    fp = fopen(""studenti.txt"", ""r"");
    if (fp == NULL)
    {   
        printf(""Datoteka nije pronadena!\n"");
        return 1;
    }
    while (!feof(fp))
    {
        if (fgetc(fp) == '\n')
            n++;
    }
    
    student* stud = NULL;
    stud = (student*)malloc(n * sizeof(student));
    if (stud == NULL)
    {
        printf(""Neuspjesna alokacija memorije!\n"");
    }
    rewind(fp);
    upis(fp, stud, n);
    fclose(fp);
    return 0;
}
int upis(FILE* fp, student* s, int n)
{
    int i, max = 100;
    double r;
    for (i = 0; i < n; i++)
    {
        fscanf(fp, ""%s %s %lf\n"", (*(s + i)).ime, (*(s + i)).prezime, &(*(s + i)).bodovi);
        r = s[i].bodovi / max * 100;
        printf(""Ime i prezime: %s \t%s\t Bodovi: %.2lf\t  Relativni bodovi: %.2lf\n"", (*(s + i)).ime, (*(s + i)).prezime, (*(s + i)).bodovi, r);
    }
    return 0;
}",60,172,468
"#define FOR(i,a,b) for(int i=a;i<b;i++)
int* takeInput(int n)
{
    int* arr=(int*)malloc(n*sizeof(int));
    int k;
    FOR(i,0,n)
    {
        scanf(""%d"",&k);
        arr[i]=k;
    }
    return arr;
}
void bubbleSort(int n,int* arr)
{
    FOR(i,0,n-1)
    {
        FOR(j,0,n-i-1)
        {
            if(arr[j]>arr[j+1])
            {
                arr[j]=arr[j]^arr[j+1];
                arr[j+1]=arr[j]^arr[j+1];
                arr[j]=arr[j]^arr[j+1];
            }
        }
    }
}
int main()
{
    int n;
    scanf(""%d\n"",&n);
    int* arr=takeInput(n);
    bubbleSort(n,arr);
    FOR(i,0,n)
    {
        printf(""%d\t"",arr[i]);
    }
    printf(""\n"");
    return 0;
}",61,173,311
"int main(int argc, char* argv[])
{
    int rank,size;
    int res;
    int s;
    MPI_Init(&argc,&argv);
    MPI_Comm_size(MPI_COMM_WORLD,&size);
    MPI_Comm_rank(MPI_COMM_WORLD,&rank);
    char st[100];
    char* c=(char*)malloc(sizeof(char)*100);
    int* b=(int*)malloc(size*sizeof(int));
    if(rank==0)
    {
        scanf(""%s"",st);
        int k=strlen(st);
        if(k%size!=0)
        {
            printf(""String length should be divisible by the number of processes."");
            return 0;
        }
        s=k/size;
    }
    MPI_Bcast(&s,1,MPI_INT,0,MPI_COMM_WORLD);
    MPI_Scatter(st,s,MPI_CHAR,c,s,MPI_CHAR,0,MPI_COMM_WORLD);
    res=0;
    for(int i=0;i<s;i++)
    {
        
        if(c[i]=='a'||c[i]=='e'||c[i]=='i'||c[i]=='o'||c[i]=='u')
            continue;
        res+=1;
    }
    
    MPI_Gather(&res,1,MPI_INT,b,1,MPI_INT,0,MPI_COMM_WORLD);
    if(rank==0)
    {
        res=0;
        for(int i=0;i<size;i++)
        {
            res+=b[i];
        }
        printf(""The total number of non vowels is:%d\n"",res);
    }   
    MPI_Finalize();
}   ",61,174,480
"#define PORT 9734

void main() {
    
    int serverfd = socket(AF_INET, SOCK_STREAM, 0);

    
    if (serverfd == -1) {
        printf(""Couldn't create socket. Exiting!\n"");
        exit(0);
    } else {
        printf(""Socket created \n"");
    }

    
    struct sockaddr_in server_address, client_address;
    int len = sizeof(server_address);

    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = inet_addr(""127.0.0.1"");
    server_address.sin_port = PORT;

    
    if (bind(serverfd, (struct sockaddr *)&server_address, len) == -1) {
        exit(0);
    } else {
        printf(""Binding successful!\n"");
    }

    
    if (listen(serverfd, 5) == -1) {
        printf(""Couldn't start listening. Exit.\n"");
        exit(0);
    } else {
        printf(""Server listening.\n\n"");
    }

    while (1) {
        int clientfd = accept(serverfd, (struct sockaddr *)&client_address, &len);

        
        time_t rawtime;
        struct tm * timeinfo;
        time ( &rawtime );
        timeinfo = localtime ( &rawtime );
        char* time_to_output = malloc(strlen(asctime (timeinfo)) + 1);
        strcpy(time_to_output, asctime (timeinfo));

        
        write(clientfd, time_to_output, 100);

        
        char process_id_to_output[100];
        sprintf(process_id_to_output, ""%d"", getpid());
        write(clientfd, &process_id_to_output, 100);

        
        close(clientfd);
    }
}",62,175,504
"#define SIZE 50

typedef struct Node* nptr;
typedef struct Node
{
    nptr llink;
    nptr rlink;
    char* ele;
}node;

nptr createNode()
{
    nptr temp=(nptr)malloc(sizeof(node));
    temp->ele=(char*)malloc(SIZE*sizeof(char));

    temp->llink=NULL;
    temp->rlink=NULL;

    return temp;
}

void insertf(nptr list,char* x)
{
    nptr temp=createNode();
    strcpy(temp->ele,x);

    if(!list->rlink)
    {
        list->rlink=temp;
        temp->llink=list;
        temp->rlink=NULL;

        return;
    }

    (list->rlink)->llink=temp;
    temp->llink=list;
    temp->rlink=list->rlink;
    list->rlink=temp;
}

char* delf(nptr list)
{
    if(!(list->rlink))
    {
        printf(""Underflow!!\n""); 
        return NULL;
    }

    nptr temp=list->rlink;
    list->rlink=temp->rlink;

    if(temp->rlink)
        (temp->rlink)->llink=list;
    
    char* str=(char*)malloc(SIZE*sizeof(char));
    strcpy(str,temp->ele);
    free(temp);

    return str;
}

void rev(nptr list)
{
    nptr trv=list;

    while(trv->rlink)
        trv=trv->rlink;

    nptr last=trv;
    
    while(trv!=list)
    {
        nptr temp=trv->llink;
        trv->llink=trv->rlink;
        trv->rlink=temp;
        trv=temp;
    }
    
    (list->rlink)->rlink=NULL;
    list->rlink=last;
    last->llink=list;
}

void disp(nptr list)
{
    nptr i=list->rlink;
    
    while(i)
    {
        printf(""%s  "",i->ele);
        i=i->rlink;
    }
    
    printf(""\n"");
}

int main()
{
    int n;
    printf(""Enter no. of elemnts: "");
    scanf(""%d"", &n);
    
    char str[SIZE];
    nptr list=createNode();

    for(int i = 0 ; i < n ; i++)
    {
        printf(""Enter word to insert: ""); 
        scanf(""%s"", str);
        insertf(list, str);
    }

    disp(list);
    rev(list);
    disp(list);
}",62,176,721
"typedef struct
{
    char name[20];
    int rollNum;
    float gpa;
} STUDENT;

void readData(STUDENT* s)
{
    printf(""Enter name: "");
    scanf(""%s"", (s->name));

    printf(""Enter roll number: "");
    scanf(""%d"", &(s->rollNum));

    printf(""Enter GPA: "");
    scanf(""%f"", &(s->gpa));
}

void printData(STUDENT* s)
{
    printf(""Name: %s \n"", (s->name)); 
    printf(""Roll number: %d \n"", s->rollNum);
    printf(""GPA: %f \n"", s->gpa);
}

int main()
{

    int n;
    printf(""Enter no. of students:"");
    scanf(""%d"", &n);

    STUDENT* ptr = calloc(n, sizeof(STUDENT));

    for(int i = 0 ; i < n ; i++)
    {
        printf(""\nEnter data of %dth student: \n"", i + 1);
        readData(ptr + i);
    }

    
    for(int i = 0 ; i < n - 1 ; i++)
    {
        STUDENT temp;
        
        for(int j = 0 ; j < n - i - 1 ; j++)
            if( ptr[j].rollNum  > ptr[j+1].rollNum )
            {
                temp = ptr[j];
                ptr[j] = ptr[j+1];
                ptr[j+1] = temp;
            }
    }

    for(int i = 0 ; i < n ; i++)
    {
        printf(""\nData of %dth student: \n"", i + 1);
        printData(ptr + i);
    }

    free(ptr);
}",62,177,467
"typedef struct node
{
    int data;
    struct node* next;
}*NODE;
NODE insert(NODE first,int e,int pr)
{
    NODE temp=(NODE)malloc(sizeof(struct node));
    temp->data=e;
    temp->next=NULL;
    if (first==NULL)
        return temp;
    else if(first->next==NULL)
    {
        if (first->data>e)
        {
            temp->next=first;
            return temp;
        }
        else if(first->data<e)
            first->next=temp;
        else
        {
            if (pr==1)
                printf(""Input not unique\n"");
            free(temp);
        }
    }
    else
    {
        NODE m=first;
        while(m->next!=NULL && m->next->data<=e)
            m=m->next;
        if (m->data!=e)
        {
            temp->next=m->next;
            m->next=temp;
        }
        else
        {
            if (pr==1)
                printf(""Input not unique\n"");
            free(temp);
        }
        return first;
    }
}
NODE lunion(NODE l1, NODE l2)
{
    NODE uni=NULL;
    while(l1!=NULL)
    {
        uni=insert(uni,l1->data,0);
        l1=l1->next;
    }
    while(l2!=NULL)
    {
        uni=insert(uni,l2->data,0);
        l2=l2->next;
    }
    return uni;
}
NODE lintersection(NODE l1, NODE l2)
{
    NODE in=NULL;
    while (l1!=NULL)
    {
        NODE pl2=l2;
        while(pl2!=NULL)
        {
            if (l1->data==pl2->data)
            {
                in=insert(in,l1->data,0);
                break;
            }
            pl2=pl2->next;
        }
        l1=l1->next;
    }
    return in;
}
void display(NODE first)
{
    if (first==NULL)
        printf(""List Empty\n"");
    else
    {
        NODE p=first;
        while (p->next!=NULL)
        {
            printf(""%d "",p->data);
            p=p->next;
        }
        printf(""%d\n"",p->data);
    }
}
int main()
{
    NODE first=NULL;
    NODE second=NULL;
    NODE uni=NULL;
    NODE in=NULL;
    int z=0,k;
    while (z==0)
    {
        printf(""1. Insert 1\t2. Insert 2\t3. Display 1\t4. Display 2\t5. Union\t6. Intersection\t7. Exit\t"");
        scanf(""%d"",&k);
        switch(k)
        {
            case 1:
            {
                int i;
                printf(""Insert:\t"");
                scanf(""%d"",&i);
                first=insert(first,i,1);
                break;
            }
            case 2:
            {
                int i;
                printf(""Insert:\t"");
                scanf(""%d"",&i);
                second=insert(second,i,1);
                break;
            }
            case 3:
            {
                display(first);
                break;
            }
            case 4:
            {
                display(second);
                break;
            }
            case 5:
            {
                uni=lunion(first,second);
                display(uni);
                break;
            }
            case 6:
            {
                in=lintersection(first,second);
                display(in);
                break;
            }
            case 7:
                z=1;
        }
    }
    return 0;
}",62,178,1010
"void strCopy(char *source, char* destin)
{
    if (*source == '\0')
    {
        *destin = '\0';
        return;
    }

    *destin = *source;
    strCopy(source + 1, destin + 1);
}


int main()
{
    char a[50] = """", b[50] = """";

    printf(""Enter string:\n"");
    scanf(""%s"", a);
    
    printf(""\nstring 1: %s string2 2: %s\n"", a, b);
    printf(""\nCopying strings...\n"");

    strCopy(a, b);

    printf(""\nstring 1: %s string2 2: %s\n"", a, b);

}",62,179,191
"void main () {

    struct sockaddr_in seradd;
    int sockaddr_len = sizeof(seradd);

    seradd.sin_family = AF_INET;
    seradd.sin_port = 1326;
    seradd.sin_addr.s_addr = inet_addr(""127.0.0.1"");

    int fd = socket(AF_INET, SOCK_STREAM, 0);

    connect(fd, (struct sockaddr*)&seradd, sockaddr_len);

    while (1) {
        printf(""enter n and elements: "");
        int n; scanf(""%d"", &n);
        
        int arr[n + 1];
        arr[0] = n;

        for (int i = 1; i <= n; ++i)
            scanf(""%d"", &arr[i]);

        write(fd, arr, (n + 1) * 4);

        if (n == 0) {
            break;
        }
    }


}",62,180,261
"void display_node();
void insert_at_end();
struct node
{
    int data;
    struct node*link;
};
int main()
{
    int choice = 1;
    struct node*head,*temp;
    head = temp = NULL;
    struct node*newnode;
    while(choice!=0)
    {
        newnode = (struct node*) malloc (sizeof(struct node));
        printf(""Enter the data:"");
        scanf(""%d"",&newnode->data);
        newnode->link = NULL;
        
        if(head == NULL)
        {
            head = temp = newnode;
        }
        else
        {
            temp->link = newnode;
            temp = newnode;
        }
        printf(""Do you want to enter more node?(1/0)"");
        scanf(""%d"",&choice);
    }
    temp = head;
    display_node(temp);
    insert_at_end(temp,head);
    getch();
}
void display_node(struct node*temp1)
{
    printf(""The Elements are:"");
    while(temp1!=NULL)
    {
        printf(""%d\t"",temp1->data);
        temp1 = temp1->link;
    }
}
void insert_at_end(struct node*temp1, struct node*head1)
{
    struct node*tempo;
    tempo = (struct node*) malloc (sizeof(struct node));
    printf(""\nEnter the Data:"");
    scanf(""%d"",&tempo->data);
    while(temp1->link!=NULL)
    {
        temp1 = temp1->link;
    }
    temp1->link = tempo;
    tempo->link = NULL;
    temp1 = head1;
    printf(""The Elements After Insertion are:"");
    while(temp1!=NULL)
    {
        printf(""%d\t"",temp1->data);
        temp1 = temp1->link;
    } 
}
",63,181,484
"void display_node();
void search_node();
struct node
{
    int data;
    struct node*link;
};
int main()
{
    int choice;
    printf(""ENTER 1 FOR CREATION ELSE ENTER 0 FOR TERMINATION:"");
    scanf(""%d"",&choice);
    struct node*head,*temp;
    head = temp = NULL;
    struct node*newnode;
    while(choice!=0)
    {
        newnode = (struct node*) malloc (sizeof(struct node));
        printf(""Enter the data:"");
        scanf(""%d"",&newnode->data);
        newnode->link = NULL;
        
        if(head == NULL)
        {
            head = temp = newnode;
        }
        else
        {
            temp->link = newnode;
            temp = newnode;
        }
        printf(""DO YOU WANT TO ENTER MORE?(1/0)"");
        scanf(""%d"",&choice);
    }
    temp = head;
    display_node(temp);
    search_node(head,temp);
    getch();
}
void display_node(struct node*temp1)
{
    printf(""THE ELEMENTS ARE:"");
    while(temp1!=NULL)
    {
        printf(""%d\t"",temp1->data);
        temp1 = temp1->link;
    }
}
void search_node(struct node*head1, struct node*temp1)
{
    int val;
    printf(""\nWHICH ELEMENT YOU ARE LOOKING FROM THE ABOVE LIST?\n"");
    scanf(""%d"",&val);
    int count = 1;
    while(temp1->data!=val)
    {
        count++;
        temp1 = temp1->link;
    }
    printf(""THE ELEMENT %d IS PRESENT AT POSITION %d"",temp1->data,count);
    return;
}
",63,182,480
"int bubbleSortOptimized(int a[],int n);
int main()
{
    int z,res;
    printf(""enter the no.of elements:"");
    scanf(""%d"",&z);
    int arr[z];
    int i;
    printf(""the elements are:\n"");
    for(i=0;i<z;i++)
    {
        scanf(""%d"",&arr[i]);
    }
    res = bubbleSortOptimized(arr,z);               
    return 0;                                     
int bubbleSortOptimized(int a[], int n)            
{
    int i,j,temp,flag=0;                           
    for(i=0;i<n;i++)                               
    {
        for(j=0;j<n-i-1;j++)
        {
            if(a[j] > a[j+1])
            {
                temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
                flag += 1;
            }
        }
        if(flag == 0)
        {
            break;
        }
    }
    printf(""Sorted array is:\n"");
    for(i=0;i<n;i++)
    {
        printf(""%d \n"",a[i]);
    }
    
}




",63,183,340
"#define TRACE_LEVEL TLS_TRACE_LEVEL



#include ""tls.h""
#include ""tls_cache.h""
#include ""tls_misc.h""
#include ""debug.h""


#if (TLS_SUPPORT == ENABLED)




TlsCache *tlsInitCache(uint_t size)
{
   size_t n;
   TlsCache *cache;

   
   if(size < 1)
      return NULL;

   
   n = sizeof(TlsCache) + size * sizeof(TlsSessionState);

   
   cache = tlsAllocMem(n);
   
   if(cache == NULL)
      return NULL;

   
   osMemset(cache, 0, n);

   
   if(!osCreateMutex(&cache->mutex))
   {
      
      tlsFreeMem(cache);
      
      return NULL;
   }

   
   cache->size = size;

   
   return cache;
}




TlsSessionState *tlsFindCache(TlsCache *cache, const uint8_t *sessionId,
   size_t sessionIdLen)
{
#if (TLS_MAX_VERSION >= SSL_VERSION_3_0 && TLS_MIN_VERSION <= TLS_VERSION_1_2)
   uint_t i;
   systime_t time;
   TlsSessionState *session;

   
   if(cache == NULL || sessionId == NULL || sessionIdLen == 0)
      return NULL;

   
   session = NULL;

   
   time = osGetSystemTime();

   
   osAcquireMutex(&cache->mutex);

   
   for(i = 0; i < cache->size; i++)
   {
      
      if(cache->sessions[i].sessionIdLen != 0)
      {
         
         if((time - cache->sessions[i].timestamp) >= TLS_SESSION_CACHE_LIFETIME)
         {
            
            tlsFreeSessionState(&cache->sessions[i]);
         }
      }
   }

   
   for(i = 0; i < cache->size; i++)
   {
      
      if(cache->sessions[i].sessionIdLen == sessionIdLen &&
         !osMemcmp(cache->sessions[i].sessionId, sessionId, sessionIdLen))
      {
         
         session = &cache->sessions[i];
         break;
      }
   }

   
   osReleaseMutex(&cache->mutex);

   
   return session;
#else
   
   return NULL;
#endif
}




error_t tlsSaveToCache(TlsContext *context)
{
#if (TLS_MAX_VERSION >= SSL_VERSION_3_0 && TLS_MIN_VERSION <= TLS_VERSION_1_2)
   error_t error;
   uint_t i;
   systime_t time;
   TlsSessionState *session;
   TlsSessionState *firstFreeEntry;
   TlsSessionState *oldestEntry;

   
   if(context == NULL)
      return ERROR_INVALID_PARAMETER;

   
   if(context->cache == NULL)
      return ERROR_FAILURE;

   
   if(context->sessionIdLen == 0)
      return NO_ERROR;

   
   osAcquireMutex(&context->cache->mutex);

   
   time = osGetSystemTime();

   
   firstFreeEntry = NULL;
   
   oldestEntry = NULL;

   
   for(i = 0; i < context->cache->size; i++)
   {
      
      session = &context->cache->sessions[i];

      
      if(session->sessionIdLen == context->sessionIdLen &&
         !osMemcmp(session->sessionId, context->sessionId, session->sessionIdLen))
      {
         
         firstFreeEntry = NULL;
         oldestEntry = NULL;
         
         break;
      }

      
      if(session->sessionIdLen == 0)
      {
         
         if(!firstFreeEntry)
         {
            firstFreeEntry = session;
         }
      }
      else
      {
         
         if(oldestEntry == NULL)
         {
            oldestEntry = session;
         }
         else if((time - session->timestamp) > (time - oldestEntry->timestamp))
         {
            oldestEntry = session;
         }
      }
   }

   
   if(firstFreeEntry != NULL)
   {
      error = tlsSaveSessionId(context, firstFreeEntry);
   }
   else if(oldestEntry != NULL)
   {
      error = tlsSaveSessionId(context, oldestEntry);
   }
   else
   {
      error = NO_ERROR;
   }

   
   osReleaseMutex(&context->cache->mutex);

   
   return error;
#else
   
   return ERROR_NOT_IMPLEMENTED;
#endif
}




error_t tlsRemoveFromCache(TlsContext *context)
{
#if (TLS_MAX_VERSION >= SSL_VERSION_3_0 && TLS_MIN_VERSION <= TLS_VERSION_1_2)
   uint_t i;
   TlsSessionState *session;

   
   if(context == NULL)
      return ERROR_INVALID_PARAMETER;

   
   if(context->cache == NULL)
      return ERROR_FAILURE;

   
   if(context->sessionIdLen == 0)
      return NO_ERROR;

   
   osAcquireMutex(&context->cache->mutex);

   
   for(i = 0; i < context->cache->size; i++)
   {
      
      session = &context->cache->sessions[i];

      
      if(session->sessionIdLen == context->sessionIdLen &&
         !osMemcmp(session->sessionId, context->sessionId, session->sessionIdLen))
      {
         
         tlsFreeSessionState(session);
      }
   }

   
   osReleaseMutex(&context->cache->mutex);
#endif

   
   return NO_ERROR;
}




void tlsFreeCache(TlsCache *cache)
{
   uint_t i;

   
   if(cache != NULL)
   {
      
      for(i = 0; i < cache->size; i++)
      {
         
         tlsFreeSessionState(&cache->sessions[i]);
      }

      
      osDeleteMutex(&cache->mutex);

      
      tlsFreeMem(cache);
   }
}

#endif
",64,184,1668
"#define TRACE_LEVEL TRACE_LEVEL_OFF


#if (defined(_WIN32) && defined(_DEBUG))
   #define _CRTDBG_MAP_ALLOC
   
   
#endif





#include ""os_port.h""
#include ""os_port_windows.h""
#include ""debug.h""




void osInitKernel(void)
{
   
}




void osStartKernel(void)
{
   
}




OsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,
   void *param, size_t stackSize, int_t priority)
{
   void *handle;

   
   handle = CreateThread(NULL, 0,
      (LPTHREAD_START_ROUTINE) taskCode, param, 0, NULL);

   
   return handle;
}




void osDeleteTask(OsTask *task)
{
   
   if(task == NULL)
   {
      
      ExitThread(0);
   }
   else
   {
      
      TerminateThread(task, 0);
   }
}




void osDelayTask(systime_t delay)
{
   
   Sleep(delay);
}




void osSwitchTask(void)
{
   
}




void osSuspendAllTasks(void)
{
   
}




void osResumeAllTasks(void)
{
   
}




bool_t osCreateEvent(OsEvent *event)
{
   
   event->handle = CreateEvent(NULL, FALSE, FALSE, NULL);

   
   if(event->handle != NULL)
      return TRUE;
   else
      return FALSE;
}




void osDeleteEvent(OsEvent *event)
{
   
   if(event->handle != NULL)
   {
      
      CloseHandle(event->handle);
   }
}




void osSetEvent(OsEvent *event)
{
   
   SetEvent(event->handle);
}




void osResetEvent(OsEvent *event)
{
   
   ResetEvent(event->handle);
}




bool_t osWaitForEvent(OsEvent *event, systime_t timeout)
{
   
   if(WaitForSingleObject(event->handle, timeout) == WAIT_OBJECT_0)
      return TRUE;
   else
      return FALSE;
}




bool_t osSetEventFromIsr(OsEvent *event)
{
   
   return FALSE;
}




bool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)
{
   
   semaphore->handle = CreateSemaphore(NULL, count, count, NULL);

   
   if(semaphore->handle != NULL)
      return TRUE;
   else
      return FALSE;
}




void osDeleteSemaphore(OsSemaphore *semaphore)
{
   
   if(semaphore->handle != NULL)
   {
      
      CloseHandle(semaphore->handle);
   }
}




bool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)
{
   
   if(WaitForSingleObject(semaphore->handle, timeout) == WAIT_OBJECT_0)
      return TRUE;
   else
      return FALSE;
}




void osReleaseSemaphore(OsSemaphore *semaphore)
{
   
   ReleaseSemaphore(semaphore->handle, 1, NULL);
}




bool_t osCreateMutex(OsMutex *mutex)
{
   
   mutex->handle = CreateMutex(NULL, FALSE, NULL);

   
   if(mutex->handle != NULL)
      return TRUE;
   else
      return FALSE;
}




void osDeleteMutex(OsMutex *mutex)
{
   
   if(mutex->handle != NULL)
   {
      
      CloseHandle(mutex->handle);
   }
}




void osAcquireMutex(OsMutex *mutex)
{
   
   WaitForSingleObject(mutex->handle, INFINITE);
}




void osReleaseMutex(OsMutex *mutex)
{
   
   ReleaseMutex(mutex->handle);
}




systime_t osGetSystemTime(void)
{
   
   return GetTickCount();
}




void *osAllocMem(size_t size)
{
   
   return malloc(size);
}




void osFreeMem(void *p)
{
   
   free(p);
}
",64,185,1214
"#define TRACE_LEVEL RSTP_TRACE_LEVEL


#include ""rstp/rstp.h""
#include ""rstp/rstp_fsm.h""
#include ""rstp/rstp_tcm.h""
#include ""rstp/rstp_procedures.h""
#include ""rstp/rstp_misc.h""
#include ""debug.h""


#if (RSTP_SUPPORT == ENABLED)


const RstpParamName rstpTcmStates[] =
{
   {RSTP_TCM_STATE_INACTIVE,     ""INACTIVE""},
   {RSTP_TCM_STATE_LEARNING,     ""LEARNING""},
   {RSTP_TCM_STATE_DETECTED,     ""DETECTED""},
   {RSTP_TCM_STATE_NOTIFIED_TCN, ""NOTIFIED_TCN""},
   {RSTP_TCM_STATE_NOTIFIED_TC,  ""NOTIFIED_TC""},
   {RSTP_TCM_STATE_PROPAGATING,  ""PROPAGATING""},
   {RSTP_TCM_STATE_ACKNOWLEDGED, ""ACKNOWLEDGED""},
   {RSTP_TCM_STATE_ACTIVE,       ""ACTIVE""}
};




void rstpTcmInit(RstpBridgePort *port)
{
   
   rstpTcmChangeState(port, RSTP_TCM_STATE_INACTIVE);
}




void rstpTcmFsm(RstpBridgePort *port)
{
   
   
   switch(port->tcmState)
   {
   
   case RSTP_TCM_STATE_INACTIVE:
      
      if(port->learn && !port->fdbFlush)
      {
         
         rstpTcmChangeState(port, RSTP_TCM_STATE_LEARNING);
      }

      break;

   
   case RSTP_TCM_STATE_LEARNING:
      
      if(port->rcvdTc || port->rcvdTcn || port->rcvdTcAck || port->tcProp)
      {
         
         rstpTcmChangeState(port, RSTP_TCM_STATE_LEARNING);
      }
      else if((port->role == STP_PORT_ROLE_ROOT ||
         port->role == STP_PORT_ROLE_DESIGNATED) &&
         port->forward && !port->operEdge)
      {
         
         rstpTcmChangeState(port, RSTP_TCM_STATE_DETECTED);
      }
      else if(port->role != STP_PORT_ROLE_ROOT &&
         port->role != STP_PORT_ROLE_DESIGNATED &&
         !(port->learn || port->learning) &&
         !(port->rcvdTc || port->rcvdTcn || port->rcvdTcAck || port->tcProp))
      {
         
         rstpTcmChangeState(port, RSTP_TCM_STATE_INACTIVE);
      }
      else
      {
         
      }

      break;

   
   case RSTP_TCM_STATE_NOTIFIED_TCN:
      
      rstpTcmChangeState(port, RSTP_TCM_STATE_NOTIFIED_TC);
      break;

   
   case RSTP_TCM_STATE_DETECTED:
   case RSTP_TCM_STATE_NOTIFIED_TC:
   case RSTP_TCM_STATE_PROPAGATING:
   case RSTP_TCM_STATE_ACKNOWLEDGED:
      
      rstpTcmChangeState(port, RSTP_TCM_STATE_ACTIVE);
      break;

   
   case RSTP_TCM_STATE_ACTIVE:
      
      if((port->role != STP_PORT_ROLE_ROOT &&
         port->role != STP_PORT_ROLE_DESIGNATED) || port->operEdge)
      {
         
         rstpTcmChangeState(port, RSTP_TCM_STATE_LEARNING);
      }
      else if(port->rcvdTcn)
      {
         
         rstpTcmChangeState(port, RSTP_TCM_STATE_NOTIFIED_TCN);
      }
      else if(port->rcvdTc)
      {
         
         rstpTcmChangeState(port, RSTP_TCM_STATE_NOTIFIED_TC);
      }
      else if(port->tcProp && !port->operEdge)
      {
         
         rstpTcmChangeState(port, RSTP_TCM_STATE_PROPAGATING);
      }
      else if(port->rcvdTcAck)
      {
         
         rstpTcmChangeState(port, RSTP_TCM_STATE_ACKNOWLEDGED);
      }
      else
      {
         
      }

      break;

   
   default:
      
      rstpFsmError(port->context);
      break;
   }
}




void rstpTcmChangeState(RstpBridgePort *port, RstpTcmState newState)
{
   
   TRACE_VERBOSE(""Port %"" PRIu8 "": TCM state machine %s -> %s\r\n"",
      port->portIndex,
      rstpGetParamName(port->tcmState, rstpTcmStates, arraysize(rstpTcmStates)),
      rstpGetParamName(newState, rstpTcmStates, arraysize(rstpTcmStates)));

   
   port->tcmState = newState;

   
   
   switch(port->tcmState)
   {
   
   case RSTP_TCM_STATE_INACTIVE:
      port->fdbFlush = TRUE;
      port->tcWhile = 0;
      port->tcAck = FALSE;
      break;

   
   case RSTP_TCM_STATE_LEARNING:
      port->rcvdTc = FALSE;
      port->rcvdTcn = FALSE;
      port->rcvdTcAck = FALSE;
      port->tcProp = FALSE;
      break;

   
   case RSTP_TCM_STATE_DETECTED:
      rstpNewTcWhile(port);
      rstpSetTcPropTree(port);
      port->newInfo = TRUE;
      break;

   
   case RSTP_TCM_STATE_NOTIFIED_TCN:
      rstpNewTcWhile(port);
      break;

   
   case RSTP_TCM_STATE_NOTIFIED_TC:
      port->rcvdTcn = FALSE;
      port->rcvdTc = FALSE;

      if(port->role == STP_PORT_ROLE_DESIGNATED)
      {
         port->tcAck = TRUE;
      }

      
      rstpSetTcPropTree(port);
      break;

   
   case RSTP_TCM_STATE_PROPAGATING:
      rstpNewTcWhile(port);
      port->fdbFlush = TRUE;
      port->tcProp = FALSE;
      break;

   
   case RSTP_TCM_STATE_ACKNOWLEDGED:
      port->tcWhile = 0;
      port->rcvdTcAck = FALSE;
      break;

   
   case RSTP_TCM_STATE_ACTIVE:
      
      break;

   
   default:
      
      break;
   }

   
   port->context->busy = TRUE;
}

#endif
",64,186,1984
"#define TRACE_LEVEL TLS_TRACE_LEVEL


#include ""tls.h""
#include ""tls_handshake.h""
#include ""tls_client.h""
#include ""tls_client_fsm.h""
#include ""tls_common.h""
#include ""tls_record.h""
#include ""tls_misc.h""
#include ""tls13_client.h""
#include ""tls13_client_misc.h""
#include ""tls13_common.h""
#include ""tls13_key_material.h""
#include ""debug.h""


#if (TLS_SUPPORT == ENABLED && TLS_CLIENT_SUPPORT == ENABLED)




error_t tlsPerformClientHandshake(TlsContext *context)
{
   error_t error;

   
   error = NO_ERROR;

   
   while(!error)
   {
      
      if(context->transportProtocol == TLS_TRANSPORT_PROTOCOL_STREAM)
      {
         
         if(context->state != TLS_STATE_INIT &&
            context->state != TLS_STATE_CLOSED)
         {
            
            error = tlsWriteProtocolData(context, NULL, 0, TLS_TYPE_NONE);
            
            if(error)
               break;
         }
      }

      
      if(context->state == TLS_STATE_APPLICATION_DATA)
      {
         
         
         break;
      }

      
      
      switch(context->state)
      {
      
      case TLS_STATE_INIT:
         
         error = tlsInitHandshake(context);
         break;

      
      case TLS_STATE_CLIENT_HELLO:
      case TLS_STATE_CLIENT_HELLO_2:
         
         
         error = tlsSendClientHello(context);
         break;

      
      case TLS_STATE_CLIENT_CERTIFICATE:
         
         
         
         error = tlsSendCertificate(context);
         break;

      
      case TLS_STATE_CLIENT_CERTIFICATE_VERIFY:
         
         
         
         
         error = tlsSendCertificateVerify(context);
         break;

      
      case TLS_STATE_CLIENT_CHANGE_CIPHER_SPEC:
      case TLS_STATE_CLIENT_CHANGE_CIPHER_SPEC_2:
         
         
         
         error = tlsSendChangeCipherSpec(context);
         break;

      
      case TLS_STATE_CLIENT_FINISHED:
         
         
         
         error = tlsSendFinished(context);
         break;

#if (TLS_MAX_VERSION >= SSL_VERSION_3_0 && TLS_MIN_VERSION <= TLS_VERSION_1_2)
      
      case TLS_STATE_CLIENT_KEY_EXCHANGE:
         
         
         
         
         error = tlsSendClientKeyExchange(context);
         break;
#endif

#if (TLS_MAX_VERSION >= TLS_VERSION_1_3 && TLS_MIN_VERSION <= TLS_VERSION_1_3)
      
      case TLS_STATE_END_OF_EARLY_DATA:
         
         
         
         error = tls13SendEndOfEarlyData(context);
         break;

      
      case TLS_STATE_HANDSHAKE_TRAFFIC_KEYS:
         
         error = tls13GenerateHandshakeTrafficKeys(context);
         break;

      
      case TLS_STATE_SERVER_APP_TRAFFIC_KEYS:
         
         error = tls13GenerateServerAppTrafficKeys(context);
         break;

      
      case TLS_STATE_CLIENT_APP_TRAFFIC_KEYS:
         
         error = tls13GenerateClientAppTrafficKeys(context);
         break;

      
      case TLS_STATE_KEY_UPDATE:
         
         
         error = tls13SendKeyUpdate(context);
         break;
#endif

      
      case TLS_STATE_SERVER_HELLO:
      case TLS_STATE_SERVER_HELLO_2:
      case TLS_STATE_SERVER_HELLO_3:
      case TLS_STATE_ENCRYPTED_EXTENSIONS:
      case TLS_STATE_SERVER_CERTIFICATE:
      case TLS_STATE_SERVER_KEY_EXCHANGE:
      case TLS_STATE_SERVER_CERTIFICATE_VERIFY:
      case TLS_STATE_CERTIFICATE_REQUEST:
      case TLS_STATE_SERVER_HELLO_DONE:
      case TLS_STATE_NEW_SESSION_TICKET:
      case TLS_STATE_SERVER_CHANGE_CIPHER_SPEC:
      case TLS_STATE_SERVER_FINISHED:
         
         error = tlsReceiveHandshakeMessage(context);
         break;

      
      case TLS_STATE_CLOSING:
         
         context->state = TLS_STATE_CLOSED;
         break;

      
      case TLS_STATE_CLOSED:
         
         TRACE_WARNING(""TLS handshake failure!\r\n"");
         
         error = ERROR_HANDSHAKE_FAILED;
         break;

      
      default:
         
         error = ERROR_UNEXPECTED_STATE;
         break;
      }
   }

   
   if(error)
   {
      
      tlsProcessError(context, error);
   }

   
   return error;
}




error_t tlsParseServerHandshakeMessage(TlsContext *context, uint8_t msgType,
   const void *message, size_t length)
{
   error_t error;

   
   switch(msgType)
   {
   
   case TLS_TYPE_HELLO_REQUEST:
      
      
      error = tlsParseHelloRequest(context, message, length);
      break;

   
   case TLS_TYPE_SERVER_HELLO:
#if (TLS_MAX_VERSION >= TLS_VERSION_1_3 && TLS_MIN_VERSION <= TLS_VERSION_1_3)
      
      
      
      if(tls13IsHelloRetryRequest(message, length))
      {
         
         
         
         error = tls13ParseHelloRetryRequest(context, message, length);
      }
      else
#endif
      {
         
         
         error = tlsParseServerHello(context, message, length);
      }

      break;

   
   case TLS_TYPE_CERTIFICATE:
      
      
      
      error = tlsParseCertificate(context, message, length);
      break;

   
   case TLS_TYPE_CERTIFICATE_REQUEST:
      
      
      
      error = tlsParseCertificateRequest(context, message, length);
      break;

   
   case TLS_TYPE_NEW_SESSION_TICKET:
#if (TLS_MAX_VERSION >= TLS_VERSION_1_3 && TLS_MIN_VERSION <= TLS_VERSION_1_3)
      
      if(context->version == TLS_VERSION_1_3)
      {
         
         
         error = tls13ParseNewSessionTicket(context, message, length);
      }
      else
#endif
      {
         
         
         error = tlsParseNewSessionTicket(context, message, length);
      }

      break;

   
   case TLS_TYPE_FINISHED:
      
      
      
      error = tlsParseFinished(context, message, length);
      break;

#if (DTLS_SUPPORT == ENABLED)
   
   case TLS_TYPE_HELLO_VERIFY_REQUEST:
      
      
      error = dtlsParseHelloVerifyRequest(context, message, length);
      break;
#endif

#if (TLS_MAX_VERSION >= SSL_VERSION_3_0 && TLS_MIN_VERSION <= TLS_VERSION_1_2)
   
   case TLS_TYPE_SERVER_KEY_EXCHANGE:
      
      
      
      error = tlsParseServerKeyExchange(context, message, length);
      break;

   
   case TLS_TYPE_SERVER_HELLO_DONE:
      
      
      error = tlsParseServerHelloDone(context, message, length);
      break;
#endif

#if (TLS_MAX_VERSION >= TLS_VERSION_1_3 && TLS_MIN_VERSION <= TLS_VERSION_1_3)
   
   case TLS_TYPE_ENCRYPTED_EXTENSIONS:
      
      
      
      error = tls13ParseEncryptedExtensions(context, message, length);
      break;

   
   case TLS_TYPE_CERTIFICATE_VERIFY:
      
      
      
      error = tlsParseCertificateVerify(context, message, length);
      break;

   
   case TLS_TYPE_KEY_UPDATE:
      
      
      
      error = tls13ParseKeyUpdate(context, message, length);
      break;
#endif

   
   default:
      
      error = ERROR_UNEXPECTED_MESSAGE;
   }

   
   return error;
}

#endif
",64,187,2333
"#define TRACE_LEVEL RSTP_TRACE_LEVEL


#include ""rstp/rstp.h""
#include ""rstp/rstp_fsm.h""
#include ""rstp/rstp_prs.h""
#include ""rstp/rstp_procedures.h""
#include ""rstp/rstp_misc.h""
#include ""debug.h""


#if (RSTP_SUPPORT == ENABLED)


const RstpParamName rstpPrsStates[] =
{
   {RSTP_PRS_STATE_INIT_BRIDGE,    ""INIT_BRIDGE""},
   {RSTP_PRS_STATE_ROLE_SELECTION, ""ROLE_SELECTION""}
};




void rstpPrsInit(RstpBridgeContext *context)
{
   
   rstpPrsChangeState(context, RSTP_PRS_STATE_INIT_BRIDGE);
}




void rstpPrsFsm(RstpBridgeContext *context)
{
   uint_t i;
   bool_t reselect;

   
   
   switch(context->prsState)
   {
   
   case RSTP_PRS_STATE_INIT_BRIDGE:
      
      rstpPrsChangeState(context, RSTP_PRS_STATE_ROLE_SELECTION);
      break;

   
   case RSTP_PRS_STATE_ROLE_SELECTION:
      
      for(reselect = FALSE, i = 0; i < context->numPorts; i++)
      {
         reselect |= context->ports[i].reselect;
      }

      
      
      if(reselect)
      {
         rstpPrsChangeState(context, RSTP_PRS_STATE_ROLE_SELECTION);
      }

      break;

   
   default:
      
      rstpFsmError(context);
      break;
   }
}




void rstpPrsChangeState(RstpBridgeContext *context, RstpPrsState newState)
{
   
   TRACE_VERBOSE(""PRS state machine %s -> %s\r\n"",
      rstpGetParamName(context->prsState, rstpPrsStates, arraysize(rstpPrsStates)),
      rstpGetParamName(newState, rstpPrsStates, arraysize(rstpPrsStates)));

   
   context->prsState = newState;

   
   
   switch(context->prsState)
   {
   
   case RSTP_PRS_STATE_INIT_BRIDGE:
      
      rstpUpdtRoleDisabledTree(context);
      break;

   
   case RSTP_PRS_STATE_ROLE_SELECTION:
      
      rstpClearReselectTree(context);
      rstpUpdtRolesTree(context);
      rstpSetSelectedTree(context);
      break;

   
   default:
      
      break;
   }

   
   context->busy = TRUE;
}

#endif
",64,188,810
"#define TRACE_LEVEL SSH_TRACE_LEVEL


#include ""ssh/ssh.h""
#include ""ssh/ssh_key_import.h""
#include ""ssh/ssh_key_verify.h""
#include ""debug.h""


#if (SSH_SUPPORT == ENABLED)




error_t sshVerifyHostKey(const uint8_t *hostKey, size_t hostKeyLen,
   const char_t *trustedKey, size_t trustedKeyLen)
{
   error_t error;
   size_t n;
   uint8_t *buffer;

   
   error = sshDecodePublicKeyFile(trustedKey, trustedKeyLen, NULL, &n);

   
   if(!error)
   {
      
      buffer = sshAllocMem(n);

      
      if(buffer != NULL)
      {
         
         error = sshDecodePublicKeyFile(trustedKey, trustedKeyLen, buffer, &n);

         
         if(hostKeyLen == n && !osMemcmp(hostKey, buffer, n))
         {
            
            error = NO_ERROR;
         }
         else
         {
            
            error = ERROR_INVALID_KEY;
         }

         
         sshFreeMem(buffer);
      }
      else
      {
         
         error = ERROR_OUT_OF_MEMORY;
      }
   }

   
   return error;
}

#endif
",64,189,369
"struct elemento{ int info; struct elemento* next; };

typedef struct elemento ElementodiLista;
typedef ElementodiLista* ListadiElementi;

int main(void) 
{
    ListadiElementi lista = NULL; 
    int N = 10;

    
    ListadiElementi new = malloc(sizeof(ElementodiLista));
    (*new).info = 1;
    
    lista = new;

    for(int i = 2; i < N; i++)
    {
        
        (*new).next = malloc(sizeof(ElementodiLista));
        
        new = new->next;
        
        (*new).info = i;
    }

    new->next=NULL;
}

",65,190,184
"void rimuovi(int a[], int *dim){
  
  for(int i=0; i<*dim; i++){
    
    for(int j=i+1; j<*dim; j++){
      
      if(a[i]==a[j]){
        
        for(int k=j; k<*dim-1; k++){
          a[k] = a[k+1];
        }
        
        *dim -=1;
        
        
        j--;
      }
    }
  }
}

int main(void) {
    int dim_a;
    printf(""Inserire dimensione a: "");
    scanf(""%d"", &dim_a);
    int *a = malloc(sizeof(int)*dim_a);

    
    for(int i=0; i<dim_a; i++){
        printf(""a[%d] = "", i);
        scanf(""%d"", &a[i]);
    }
    printf(""\n"");

    
    rimuovi(a, &dim_a);

}",65,191,261
"void calcolo_ipotenusa(float *ac, float *gamma, float *ipotenusa)
{
    double angolo_gamma = *gamma;
    *ipotenusa = *ac / sin(angolo_gamma);  
           
}

float calcolo_perimetro(float ac, float ipotenusa, float *bc)
{
   return ac + ipotenusa + *bc;
}

void calcolo_area(float *perimetro, float ac, float *ipotenusa, float *bc, float *area)
{
    double parziale = (*perimetro/2) * (*perimetro/2 - ac) * (*perimetro/2 - *ipotenusa) * (*perimetro/2 - *bc);

    *area = sqrt(parziale);
}

float calcolo_altezza(float *ab, float *h)
{
    return ((*ab * *h) / 2);
}

int main(void) 
{
    float ac, gamma, bc=15;
    int alfa = 90;
    float ipotenusa, perimetro, altezza, area;

    printf(""\n-------------------------------------\n"");
    printf(""Inserisci il valore del cateto minore: "");
    scanf(""%f"", &ac);

    printf(""Inserisci il valore dell'angolo gamma: "");
    scanf(""%f"", &gamma);
    printf(""\n-------------------------------------\n"");

    calcolo_ipotenusa(&ac, &gamma, &ipotenusa);
    printf(""L'ipotenusa del triangolo Ã¨: %f\n"", ipotenusa);

    perimetro = calcolo_perimetro(ac, ipotenusa, &bc);
    printf(""Il perimetro del triangolo Ã¨: %f\n"", perimetro);

    calcolo_area(&perimetro, ac, &ipotenusa, &bc, &area);
    printf(""L'area del triangolo Ã¨: %f\n"", area);

    altezza = calcolo_altezza(&ipotenusa, &area);
    printf(""L'altezza del triangolo Ã¨: %f\n"", altezza);

    return 0;

}",65,192,552
"int MaximumValue(int l, int r){
        int max_value = 0;
        int result = 0;

        
        for(int i = l ; i<=r ;i++){
            for(int j = i ; j<=r ;j++){
                result = i^j;
                if(result > max_value){
                    max_value = result;
                }
            }
        }
        return max_value;
}

int main(void){
    setvbuf(stdout , NULL , _IONBF , 0);                            
    setvbuf(stderr , NULL , _IONBF , 0);
    int number1, number2;
    int maximum;
    printf(""Enter first number: "");
    scanf(""%d"",&number1);                                           
    printf(""Enter second number: "");
    scanf(""%d"",&number2);                                           
    maximum = MaximumValue(number1,number2);
    printf(""The maximum value of %d XOR %d is %d"",number1,number2,maximum);
    return 0;
}
",0,193,261
"void BubbleSort(int arr[], const int array_size){
        int i, j;
        int temp;
        for(i=1 ; i<= array_size ; i++){
            for(j=0 ; j<= (array_size - 1) ; j++){

                if(arr[j]>arr[j+1]){
                    temp = arr[j+1];
                    arr[j+1] = arr[j];
                    arr[j] = temp;
                }
            }
        }
}

int main(void){

    const int array_size =5;
    int arr[array_size];
    int i, j, k;


    for(i=0 ; i<array_size ; i++){
            scanf(""%d"",&arr[i]);
        }

    printf(""Array before sorting: \n"");
    for(j=0 ; j<array_size ; j++){
            printf(""%d\t"",arr[j]);
        }

    BubbleSort(arr, array_size);

    printf(""\n"");
    printf(""Array after sorting: \n"");
    for(k=0 ; k<array_size ; k++){
        printf(""%d\t"",arr[k]);
    }

    return 0;
    }

",0,194,313
"#define SIZE 20
#define FOR_WHILE 1
#define RECURSIVE 2


int ForFibonacci(int arr[],int index){
    int i;

    
    arr[0] = 1;
    arr[1] = 1;

    
    for( i=2 ; i<(SIZE-1) ; i++ ){
        arr[i] = arr[i-1] + arr[i-2];
    }

    
    return arr[index];
}


long RecursiveFibonacci(long index){

    if(index == 0 || index == 1){
        return 1;
    }
    else{
        return RecursiveFibonacci(index-2) + RecursiveFibonacci(index-1);
    }
}

int main(void){
    setvbuf(stdout , NULL , _IONBF , 0);
    setvbuf(stderr , NULL , _IONBF , 0);

    int arr[SIZE];
    int function_type;                                                                      
    int index;
    int result_forwhile;
    long result_fibo;

    
    printf(""Enter required element in Fibonacci series: "");
    scanf(""%d"",&index);
    printf(""\n"");

    
    printf(""Type 1 for ForWhile function or type 2 for Recursive function: "");
    scanf(""%d"",&function_type);

    if(function_type == FOR_WHILE){

        
        result_forwhile = ForFibonacci(arr,index);
        printf(""The %d element in fibonacci series is %d"",index,result_forwhile);
    }
    else if(function_type == RECURSIVE){

        
        result_fibo = RecursiveFibonacci(index);
        printf(""The %d element in recursive fibonacci is %ld"",index , result_fibo);
    }


    return 0;
}
",0,195,491
"#define SIZE 10


void CopyArray(int *ptrA , int *ptrB){
    int i;

    for(i=0 ; i<SIZE ; i++){
        *ptrB = *ptrA;
        ptrA++;
        ptrB++;
    }
}

int main(void){
    setvbuf(stdout , NULL , _IONBF , 0);
    setvbuf(stdout , NULL , _IONBF , 0);

    int i;
    int array_A[SIZE];
    int array_B[SIZE];
    int *ptrA = array_A;
    int *ptrB = array_B;
    
    printf(""Enter elements of array A: "");
    for(i=0 ; i<SIZE ; i++){
        scanf(""%d"",ptrA);
        ptrA++;
    }

    
    CopyArray(array_A,array_B);

    
    for(i=0 ; i<SIZE ; i++){
        printf(""ArrayB[%d] = %d \n"",i,*ptrB);
        ptrB++;
    }

    return 0;
}
",0,196,274
"#define ARRAY_SIZE 15

int OddRepetitionNumberInArray(int *arr,int arr_size)
{
    int i,j;
    int count = 0;
    int index = 0;
    for(i=0;i<arr_size;i++)
    {
        for(j = 0; j < arr_size;j++)
        {
            
            if(arr[i] == arr[j])
            {
                index = i;
                count++;
            }
        }
        
        if(count%2 != 0)
        {
            break;
        }
        
        count = 0;
    }
    return arr[index];
}

int main(void)
{
    int arr[ARRAY_SIZE] = {1,2,3,1,2,3,1,1,1,1,3,3,3};

    int num = OddRepetitionNumberInArray(arr,ARRAY_SIZE);

    printf(""number is : %d"",num); 

    return 0;
}
",0,197,265
"void ReverseArray(int arr[] ,int size){
    int i, temp;

    
    for(i=0 ; i<size/2 ; i++){
        temp = arr[i];
        arr[i] = arr[size-1 - i];
        arr[size-1 -i] = temp;
    }
}

int main(void){
    setvbuf(stdout , NULL , _IONBF , 0);
    setvbuf(stderr , NULL , _IONBF , 0);

    int k , j;
    int size = 5;
    int arr[5];

    printf(""Enter elements of array: "");

    
    for(k=0 ; k<size ; k++){
        scanf(""%d"",&arr[k]);
    }

    
    ReverseArray(arr,size);

    printf(""Array after being reversed: "");
    
    for(j=0 ; j<size ; j++){
        printf(""%d "",arr[j]);
    }

    return 0;
}
",0,198,251
"int OutputArray[256];

int * PrintReverseInclusive(int LowerNumber,int UpperNumber,int * result_size)
{
    int i;
    *result_size = 0;
    
    if((LowerNumber>=UpperNumber) || (UpperNumber-1 == LowerNumber))
    {
        OutputArray[0] = 0xFF;
        OutputArray[1] = 0xFF;
        *result_size = 2;
    }
    else
    {
        
        for(i=UpperNumber-1;i>LowerNumber;i--)
        {
            OutputArray[*result_size] = i;
            (*result_size)++;
        }
    }
    return OutputArray;
}

int main(void) {
    int count;
    int n1 = 5,n2=10;
    int *ptr;
    int arr_size_used = 0;

    ptr = PrintReverseInclusive(n1,n2,&arr_size_used);

    printf(""Output Array = "");

    
    for(count=0;count<arr_size_used;count++)
    {
        
        printf(""%d "",ptr[count]);
    }
    printf(""\nOutput Array Size = %d"",arr_size_used);
    return 0;
}
",0,199,325
"void display_prime(int num1, int num2){
    int number = num1;
    int rem_of_two, rem_of_three;                           

    
    for (int i = num1; i<=num2 ; ){
        rem_of_two = number % 2;
        rem_of_three = number % 3;

        
        if(number == 2 || number == 3){
                printf(""%d "",number);                                               
            }
            else{
                
                if( rem_of_two == 0 || rem_of_three == 0){
                    i++;
                    number++;
                    continue;
                }
                else{
                    printf(""%d "",number);
                }
            }
        i++;
        number++;
    }
}

int main(void){
    setvbuf(stdout , NULL , _IONBF , 0);                            
    setvbuf(stderr , NULL , _IONBF , 0);
    int number1, number2;                                           
    printf(""Enter first number: "");
    scanf(""%d"",&number1);                                           
    printf(""Enter second number: "");
    scanf(""%d"",&number2);                                           
    display_prime(number1,number2);                                 
    return 0;
}
",0,200,318
"void SelectionSorting(int arr[],const int size ){
    int i , j , min , temp;

    
    for(i = 0 ; i < (size-1) ; i++){
        
        min = i;

            for(j = i+1 ; j < size ; j++){

                if(arr[j]<arr[min]){
                    min = j;
                }
            }

            
            temp = arr[i];
            arr[i] = arr[min];
            arr[min] = temp;
    }
}

int main(void){
    setvbuf(stdout , NULL , _IONBF , 0);
    setvbuf(stderr , NULL , _IONBF , 0);
    int i ,j ,k;
    const int size = 5;
    int arr[size];

    printf(""Enter array elements:\n"");

    
    for(i=0 ; i<size ; i++){
        scanf(""%d"",&arr[i]);
    }

    printf(""Array before sorting:\n"");

    
    for(j=0 ; j<size ; j++){
        printf(""%d\t"",arr[j]);
    }

    
    SelectionSorting(arr,size);

    printf(""\n"");
    printf(""Array after sorting:\n"");

    
    for(k=0 ; k<size ; k++){
        printf(""%d\t"",arr[k]);
    }

    return 0;
}
",0,201,360
"int main(void){
    setvbuf(stdout , NULL , _IONBF , 0);            
    setvbuf(stderr , NULL , _IONBF , 0);
    int grade;                                      
    printf(""Enter student's grade in percentage: "");
    scanf(""%d"",&grade);                             
    if(grade >= 85 && grade <=100){
        printf(""Student's grade is Excellent"");
    }
    else if(grade < 85 && grade >= 75){
        printf(""Student's grade is Very good"");
    }
    else if(grade < 75 && grade >= 65){
        printf(""Student's grade is Good"");
    }
    else if(grade < 65 && grade >= 50){
        printf(""Student's grade is Passed"");
    }
    else if(grade < 50 && grade >= 0){
        printf(""Student's grade is Failed"");
    }
    else{
        printf(""Invalid input"");
    }
    return 0;
}
",0,202,254
"void SwapBits(unsigned int *ptr){

    unsigned short temp;
    unsigned short *ptrS = (unsigned short *)ptr;

    temp = *ptrS;
    *ptrS = *(ptrS + 1);
    *(ptrS + 1) = temp;
}

int main(void){
    setvbuf(stdout, NULL ,_IONBF , 0);
    setvbuf(stderr, NULL ,_IONBF , 0);

    unsigned int number;
    unsigned short *ptr = (unsigned short *)&number;

    printf(""Enter number: "");
    scanf(""%d"",&number);


    printf(""Two 16-bits of 32-bits integer number before swapping are %hi  and  %hi\n"",*ptr,*(ptr+1));

    
    SwapBits(&number);

    printf(""Two 16-bits of 32-bits integer number after swapping are %hi  and  %hi"",*ptr,*(ptr+1));

    return 0;
}
",0,203,255
"#define SIZE 10

int maximum;

int main(void){
    setvbuf(stdout , NULL , _IONBF , 0);
    setvbuf(stderr , NULL , _IONBF , 0);

    int i;
    int array[SIZE];
    int *ptr[SIZE];

    
    printf(""Enter array elements: "");
    for(i=0 ; i<SIZE ; i++){
        scanf(""%d"",&array[i]);

        
        ptr[i] = &array[i];
    }

    
    maximum = *ptr[0];

    for(i=1 ; i<SIZE ; i++){

        if(maximum < *ptr[i]){
            maximum = *ptr[i];
        }
    }

    
    for(i=0 ; i<SIZE ;i++){
        printf(""Array[%d] = %d\n"",i,*ptr[i]);
    }

    printf(""Maximum number is %d"",maximum);

    return 0;
}

",0,204,255
"#define SIZE 10


void Swap(int *ptrA , int *ptrB){
    int temp;
    int i;

    for(i=0 ; i<SIZE ; i++){
        temp = *ptrA;
        *ptrA = *ptrB;
        *ptrB = temp;
        ptrA++;
        ptrB++;
    }
}

int main(void){
    setvbuf(stdout , NULL , _IONBF , 0);
    setvbuf(stderr , NULL , _IONBF , 0);

    int arrayA[SIZE];
    int arrayB[SIZE];

    int *ptrA = arrayA;
    int *ptrB = arrayB;

    int i;

    
    printf(""Enter elements of first array: "");
    for(i=0 ; i<SIZE ; i++){
        scanf(""%d"",ptrA);
        ptrA++;
    }

    printf(""Enter elements of second array: "");
    for(i=0 ; i<SIZE ; i++){
        scanf(""%d"",ptrB);
        ptrB++;
    }

    
    ptrA = arrayA;
    ptrB = arrayB;


    printf(""\n"");
    
    printf(""Array elements before swapping\n"");
    printf(""Elements of first array:\n"");
    for(i=0 ; i<SIZE ; i++){
        printf(""ArrayA[%d] = %d\n"",i,*ptrA);
        ptrA++;
    }

    printf(""\n"");
    printf(""Elements of second array:\n"");
    for(i=0 ; i<SIZE ; i++){
        printf(""ArrayB[%d] = %d\n"",i,*ptrB);
        ptrB++;
    }

    
    Swap(arrayA,arrayB);

    
    ptrA = arrayA;
    ptrB = arrayB;

    printf(""\n"");
    
    printf(""Array elements after swapping\n"");
    printf(""Elements of first array:\n"");
    for(i=0 ; i<SIZE ; i++){
        printf(""ArrayA[%d] = %d\n"",i,*ptrA);
        ptrA++;
    }

    printf(""\n"");
    printf(""Elements of second array:\n"");
    for(i=0 ; i<SIZE ; i++){
        printf(""ArrayB[%d] = %d\n"",i,*ptrB);
        ptrB++;
    }

    return 0;
}
",0,205,605
"int OutputArray[256];

int * PrintReverseInclusive(int LowerNumber,int UpperNumber,int * result_size)
{
    int i;
    *result_size = 0;
    
    if(LowerNumber > UpperNumber)
    {
        OutputArray[0] = 0xFF;
        OutputArray[1] = 0xFF;
        *result_size = 2;
    }
    else
    {
        
        for(i=UpperNumber;i>=LowerNumber;i--)
        {
            OutputArray[*result_size] = i;
            (*result_size)++;
        }
    }
    return OutputArray;
}

int main(void) {
    int count;
    int n1 = 5,n2=10;
    int *ptr;
    int arr_size_used = 0;

    ptr = PrintReverseInclusive(n1,n2,&arr_size_used);

    printf(""Output Array = "");

    
    for(count=0;count<arr_size_used;count++)
    {
        
        printf(""%d "",ptr[count]);
    }
    printf(""\nOutput Array Size = %d"",arr_size_used);
    return 0;
}
",0,206,313
"int LinearSearch(int arr[] , int element , int size ){
    int i;

    
    for(i =0; i <size ; i++){
        if(arr[i] == element)
            return i;           
    }
    return -1;  
}

int main(void){
    setvbuf(stdout , NULL , _IONBF , 0);
    setvbuf(stderr , NULL , _IONBF , 0);
    int i ;
    int size = 5;
    int arr[size];
    int result, element;
    printf(""Enter array of numbers:"");

    
    for(i=0 ; i<size ; i++){
        scanf(""%d"",&arr[i]);
    }

    printf(""Enter required element:"");

    
    scanf(""%d"",&element);

    
    result = LinearSearch(arr, element ,size);

    if(result == -1){
        printf(""Item is not on the list"");
    }
    else{
        printf(""The index of required item is %d"",result);
    }
    return 0;
}

",0,207,271
"void Swap(int *X, int *Y){
    *X = *X ^ *Y;
    *Y = *X ^ *Y;
    *X = *X ^ *Y;
}

int main(void){
    setvbuf(stdout , NULL , _IONBF , 0);
    setvbuf(stderr , NULL , _IONBF , 0);

    int num1 , num2 ;
    void (*ptr)(int *,int *) = Swap;

    
    printf(""Enter first number: "");
    scanf(""%d"",&num1);

    printf(""Enter second number: "");
    scanf(""%d"",&num2);

    
    printf(""Displaying two number before swapping\n"");
    printf(""First number is %d , Second number is %d\n"",num1,num2);

    
    (*ptr)(&num1 , &num2);

    
    printf(""Displaying two numbers after swapping\n"");
    printf(""First number is %d , Second number is %d"",num1,num2);

    return 0;
}
",0,208,264
"char arr[256];


char* LastLetters(char *str){

    while(*str != '\0'){
        str++;
    }

    arr[0] = *(--str);

    arr[1] = ' ';

    arr[2] = *(--str);

    arr[3] = '\0';

    return arr;
}

int main(void){
    setvbuf(stdout , NULL , _IONBF , 0);
    setvbuf(stderr , NULL , _IONBF , 0);

    char str[256];

    printf(""Enter a string: "");
    gets(str);

    printf(""Reversed string: %s"",LastLetters(str));

    return 0;
}
",0,209,190
"#define SIZE 10

void ReverseArray(int *ptr){ 
    int i;
    int temp;

    
    for(i=0 ; i<SIZE/2 ;i++){
        temp = *ptr;
        *ptr = *(ptr + (SIZE-1) - i*2);
        *(ptr + (SIZE-1) - i*2) = temp;
        ptr++;
    }
}

int main(void){
    setvbuf(stdout, NULL ,_IONBF , 0);
    setvbuf(stderr, NULL ,_IONBF , 0);
    int arr[SIZE];
    int i;
    int *ptr = arr;

    
    printf(""Enter array elements: "");
    for(i=0 ; i<SIZE ;i++){
        scanf(""%d"",ptr);
        ptr++;
    }

    
    for(i=0 ; i<SIZE ;i++){
        printf(""Array element before re-arranging: arr[%d] = %d\n"",i,arr[i]);
    }

    
    ReverseArray(arr);

    ptr = arr;           
    
    for(i=0 ; i<SIZE ;i++){
        printf(""Array element after re-arranging: arr[%d] = %d\n"",i,*ptr);
        ptr++;
    }

    return 0;
}
",0,210,335
"#define ERROR 0
#define SUCCESS 1


int removeDuplicates(int arr_old[], int n_old, int arr_new[], int *n_new)
{
    int i=0;

    
    if (n_old==0)
        return ERROR;

    for (i=0 ; i<n_old-1 ; i++)
    {
        
        if (arr_old[i] != arr_old[i+1])
        {
            arr_new[*n_new] = arr_old[i];
            (*n_new)++;
        }

    }

    
    arr_new[*n_new] = arr_old[i];
    (*n_new)++;

    return SUCCESS;
}

int main(void)
{
    int arr1[10] = {1,2,3,3,3,4,4,5,5,5};
    int arr2[10];
    int arr2_usedSize = 0;
    int ret,i;

    
    ret = removeDuplicates(arr1,10,arr2,&arr2_usedSize);

    if(ret == SUCCESS)
    {
        for(i=0;i<arr2_usedSize;i++)
        {
            printf(""%d \t"",arr2[i]);
        }
    }
}
",0,211,340
"int countOnes(unsigned char number){
    unsigned char mask = 0x80;                          
    int ones = 0;
    
    for(int i = 0; i<8 ; i++){

        if((number<<i) & mask){
            ++ones;
        }
    }
    return ones;
}

int main(void){
    setvbuf(stdout , NULL , _IONBF , 0);                            
    setvbuf(stderr , NULL , _IONBF , 0);
    unsigned int number;
    int ones_count;
    printf(""Enter an 8-bit number: "");
    scanf(""%d"",&number);                                            
    ones_count = countOnes(number);                                 
    printf(""Number of 1's in given number is %d"",ones_count);
    return 0;
}
",0,212,207
"#define NO_ERROR_VALID_OPERATION 0
#define ERROR_INVALID_OPERATION 1


float calculate(float a , float b , char operator , int *error_ptr){
    float result;
    switch(operator){

            case '+':result = a+b;
                     *error_ptr = NO_ERROR_VALID_OPERATION;
                     break;

            case'-':result = a-b;
                    *error_ptr = NO_ERROR_VALID_OPERATION;
                    break;

            case'*':result = a*b;
                    *error_ptr = NO_ERROR_VALID_OPERATION;
                    break;

            case'/':result = a/b;
                    *error_ptr = NO_ERROR_VALID_OPERATION;
                    break;

            default:printf(""ERROR INVALID INPUT OPERATION\n"");
                    *error_ptr = ERROR_INVALID_OPERATION;
                    break;
    }
    return result;
}

int main(void){
        setvbuf(stdout , NULL , _IONBF , 0);                            
        setvbuf(stderr , NULL , _IONBF , 0);
        char op;
        float number1;
        float number2;
        float result;
        int error = NO_ERROR_VALID_OPERATION;       
        printf(""Enter the required operation: "");
        scanf(""%c"",&op);                            
        printf(""Enter first number: "");
        scanf(""%f"",&number1);                       
        printf(""Enter second number: "");
        scanf(""%f"",&number2);                       
        result = calculate(number1 , number2 , op , &error);        
        if( error == NO_ERROR_VALID_OPERATION ){
            printf(""Result = %f"",result);
        }
        else if( error == ERROR_INVALID_OPERATION ){
            printf(""No result , invalid operation"");
        }
        return 0;
}
",0,213,485
"#define TRUE 1
#define FALSE 0

int CheckString(char s[]){
    int i=0 ,j=0;
    int result = TRUE;

    
    while(s[i] != '\0'){

        j = i+1;  
            while(s[j] != '\0'){
                
                if(s[i] == s[j]){
                    result = FALSE;
                }
                j++;
            }
            i++;
        }

        return result;
}

int main(void){
    int result;
    char str[20];
    gets(str);                       

    
    result = CheckString(str);

    if(result == TRUE){
        printf(""All Characters are distinct"");
    }
    else if(result == FALSE){
        printf(""Repeated characters exist"");
    }
    return 0;
}
",0,214,219
"#define TRUE 1
#define FALSE 0


int CheckIdentical(int array_A[], int array_B[] ,int size){
    int i;

    
    for(i=0 ; i<size ; i++){
        if(array_A[i] != array_B[i]){
            return 1;
        }
    }

    
    return 0;
}

int main(void){
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);

    int size = 5;
    int arrayA[size];
    int arrayB[size];
    int i;
    int result;

    printf(""Enter array A elements: "");
    
    for(i=0 ; i<size ; i++){
        scanf(""%d"",&arrayA[i]);
    }


    printf(""Enter array B elements: "");
    
    for(i=0 ; i<size ; i++){
        scanf(""%d"",&arrayB[i]);
    }

    
    result = CheckIdentical(arrayA, arrayB ,size);

    if(result == TRUE){
        printf(""Two arrays are not identical"");
    }
    else if(result == FALSE){
        printf(""Two arrays are identical"");
    }

    return 0;
}
",0,215,333
"int * Swap(int a_size,int *a,int b_size,int *b)
{
    int temp;
    int i;
    for(i=0;i<b_size;i++)
    {
        temp = a[i];
        a[i] = b[i];
        b[i] = temp;
    }
    return a;
}


int main(void)
{
    setvbuf(stdout , NULL , _IONBF , 0);
    setvbuf(stderr , NULL , _IONBF , 0);

    int i;
    int a_size = 10;
    int b_size = 5;
    int array_A[a_size];
    int array_B[b_size];

    printf(""Enter Array A elements: "");
    
    for(i=0 ; i < a_size ; i++){
        scanf(""%d"",&array_A[i]);
            }

    printf(""\n"");

    printf(""Enter Array B elements: "");
    
    for(i=0 ; i < b_size ; i++){
        scanf(""%d"",&array_B[i]);
        }

    printf(""Array A before the Swap : "");
    
    for(i=0;i<a_size;i++)
    {
        printf(""%d "",array_A[i]);
    }
    printf(""\n"");

    printf(""Array B before the Swap : "");
    
    for(i=0;i<b_size;i++)
    {
        printf(""%d "",array_B[i]);
    }
    printf(""\n"");

    Swap(a_size,array_A,b_size,array_B);

    printf(""Array A after the Swap : "");
    
    for(i=0;i<b_size;i++)
    {
        printf(""%d "",array_A[i]);
    }
    printf(""\n"");

    printf(""Array B after the Swap : "");
    
    for(i=0;i<b_size;i++)
    {
        printf(""%d "",array_B[i]);
    }
    printf(""\n"");
    return 0;
}
",0,216,536
"#define MAX 1000

long oblicz(int A[], int n)
{
    long w = A[0];
    for (int i = 1; i <= n ; i++)
    {
        w = w*2 + A[i];
    }
    return w;
}

int main()
{
    int A[MAX];
    long w;
    int n;
    printf(""podaj liczbe cyfr wczytywanej liczby binarnej: "");
    scanf(""%d"", &n);
    printf(""Podaj %d cyfr liczby (od lewej): "", n);
    for (int i = 0; i < n; i++)
    {
        printf(""A[%d] = "", i);
        scanf(""%d"", &A[i]);
    }

    w = oblicz(A, n-1);
    printf(""Iteracyjnie: wynik = %ld"", w);
    printf(""(10)"");

    return 0;
}",1,217,248
"int main()
{
    double a, b, c;

    printf(""Podaj 3 liczby typu double:\n"");
    scanf(""%lf\n%lf\n%lf"", &a, &b, &c);

    if (a > b && a > c)
    {
        if (b > c)
        {
            printf(""%.2lf, %.2lf, %.2lf"", c, b,a);
        } else
            printf(""%.2lf, %.2lf, %.2lf"", b, c, a);
    }

    if (b > a && b > c)
    {
        if (a > c)
        {
            printf(""%.2lf, %.2lf, %.2lf"", c, a, b);
        } else
            printf(""%.2lf, %.2lf, %.2lf"", a, c, b);
    }

    if (c > a && c > b)
    {
        if (a > b)
        {
            printf(""%.2lf, %.2lf, %.2lf"", b, a, c);
        } else
            printf(""%.2lf, %.2lf, %.2lf"", a, b, c);
    }

    return 0;
}",1,218,319
"int main()
{
    int sum1 = 0;
    int sum2 = 0;
    int sum3 = 0;
    int i = 1;
    int j = 1;

    printf(""Petla for:\n"");
    for (int i = 1; i <=100; i +=2)
    {
        sum1 += i;
        printf (""%d\n"", sum1 );
    }

    printf(""\nPetla while:\n"");
    while (i <= 100)
    {
        sum2 += i;
        printf(""%d\n"", sum2);
        i += 2;
    }

    printf(""\nPetla do while:\n"");
    do {
        sum3 += j;
        printf(""%d\n"", sum3);
        j += 2;
    } while (j <= 100);

    return 0;
}",1,219,224
"typedef enum { false, true } bool;

bool czy_pierwsza(int n)
{
    if (n <2)
        return false;

    for (int i = 2; i*i <= n ; i++) {
        if (n % i == 0)
            return false;
    }

    return true;
}

int main()
{
    unsigned int n;

    printf(""Podaj liczbe naturlana: "");
    scanf(""%d"", &n);

    if (czy_pierwsza(n))
        printf(""Liczba %u jest pierwsza.\n"", n);
    else
        printf(""Liczba %u nie jest pierwsza.\n"", n);

    return 0;
}",1,220,182
"typedef enum { false, true } bool;

bool czy_pierwsza(int n)
{
    if (n <2)
        return false;

    for (int i = 2; i*i <= n ; i++) {
        if (n % i == 0)
            return false;
    }

    return true;
}

int main()
{
    unsigned int n;

    printf(""Podaj liczbe naturlana: "");
    scanf(""%d"", &n);

    if (czy_pierwsza(n))
        printf(""Liczba %u jest pierwsza.\n"", n);
    else
        printf(""Liczba %u nie jest pierwsza.\n"", n);

    return 0;
}",1,221,182
"#define MAX 1000

long oblicz(int A[], int n)
{
    long w = A[0];
    for (int i = 1; i <= n ; i++)
    {
        w = w*2 + A[i];
    }
    return w;
}

int main()
{
    int A[MAX];
    long w;
    int n;
    printf(""podaj liczbe cyfr wczytywanej liczby binarnej: "");
    scanf(""%d"", &n);
    printf(""Podaj %d cyfr liczby (od lewej): "", n);
    for (int i = 0; i < n; i++)
    {
        printf(""A[%d] = "", i);
        scanf(""%d"", &A[i]);
    }

    w = oblicz(A, n-1);
    printf(""Iteracyjnie: wynik = %ld"", w);
    printf(""(10)"");

    return 0;
}",1,222,248
"int main()
{
    long double min, max, kolejna, suma = 0, srednia;

    printf(""Podaj liczby rzeczywsite, po wpisaniu 0 program zakonczy wczytywanie.\nLiczby:\n"");
    scanf(""%Lf"", &kolejna);

    suma += kolejna;


    if (kolejna != 0)
    {
        int i = 1;
        min = kolejna;
        max = kolejna;
        scanf(""%Lf"", &kolejna);
        suma += kolejna;
        srednia = suma / i++;
        while (kolejna)
        {
            if (kolejna > max)
                max = kolejna;
            else {
                if (kolejna < min)
                    min = kolejna;
            }
            scanf(""%Lf"", &kolejna);
            suma += kolejna;
            srednia = suma / i++;
        }

        printf(""min = %.2Lf, max = %.2Lf\n"", min, max);
        printf(""suma = %.2Lf, "", suma);
        printf(""srednia = %.2Lf, "", srednia);
    }
    else
        printf(""Ciag wejsciowy jest pusty.\n"");

    return 0;
}
",1,223,337
"int main()
{
    int sum1 = 0;
    int sum2 = 0;
    int sum3 = 0;
    int i = 1;
    int j = 1;

    printf(""Petla for:\n"");
    for (int i = 1; i <=100; i +=2)
    {
        sum1 += i;
        printf (""%d\n"", sum1 );
    }

    printf(""\nPetla while:\n"");
    while (i <= 100)
    {
        sum2 += i;
        printf(""%d\n"", sum2);
        i += 2;
    }

    printf(""\nPetla do while:\n"");
    do {
        sum3 += j;
        printf(""%d\n"", sum3);
        j += 2;
    } while (j <= 100);

    return 0;
}",1,224,224
"int main()
{
    long double min, max, kolejna, suma = 0, srednia;

    printf(""Podaj liczby rzeczywsite, po wpisaniu 0 program zakonczy wczytywanie.\nLiczby:\n"");
    scanf(""%Lf"", &kolejna);

    suma += kolejna;


    if (kolejna != 0)
    {
        int i = 1;
        min = kolejna;
        max = kolejna;
        scanf(""%Lf"", &kolejna);
        suma += kolejna;
        srednia = suma / i++;
        while (kolejna)
        {
            if (kolejna > max)
                max = kolejna;
            else {
                if (kolejna < min)
                    min = kolejna;
            }
            scanf(""%Lf"", &kolejna);
            suma += kolejna;
            srednia = suma / i++;
        }

        printf(""min = %.2Lf, max = %.2Lf\n"", min, max);
        printf(""suma = %.2Lf, "", suma);
        printf(""srednia = %.2Lf, "", srednia);
    }
    else
        printf(""Ciag wejsciowy jest pusty.\n"");

    return 0;
}
",1,225,337
"int main()
{
    char ch;

    printf(""Podaj jeden znak: "");
    scanf(""%c"", &ch);

    switch (ch)
    {
        case 65:
            printf(""S"");
            break;
        case 66:
            printf(""N"");
            break;
        case 67:
            printf(""V"");
            break;
        case 68:
            printf(""F"");
            break;
        case 69:
            printf(""R"");
            break;
        case 70:
            printf(""G"");
            break;
        case 71:
            printf(""H"");
            break;
        case 72:
            printf(""J"");
            break;
        case 73:
            printf(""O"");
            break;
        case 74:
            printf(""K"");
            break;
        case 75:
            printf(""L"");
            break;
        case 76:
            printf("":"");
            break;
        case 77:
            printf(""<"");
            break;
        case 78:
            printf(""M"");
            break;
        case 79:
            printf(""P"");
            break;
        case 80:
            printf(""{"");
            break;
        case 81:
            printf(""W"");
            break;
        case 82:
            printf(""T"");
            break;
        case 83:
            printf(""D"");
            break;
        case 84:
            printf(""Y"");
            break;
        case 85:
            printf(""I"");
            break;
        case 86:
            printf(""B"");
            break;
        case 87:
            printf(""E"");
            break;
        case 88:
            printf(""C"");
            break;
        case 89:
            printf(""U"");
            break;
        case 90:
            printf(""X"");
            break;
        case 97:
            printf(""s"");
            break;
        case 98:
            printf(""n"");
            break;
        case 99:
            printf(""v"");
            break;
        case 100:
            printf(""f"");
            break;
        case 101:
            printf(""r"");
            break;
        case 102:
            printf(""g"");
            break;
        case 103:
            printf(""h"");
            break;
        case 104:
            printf(""j"");
            break;
        case 105:
            printf(""o"");
            break;
        case 106:
            printf(""k"");
            break;
        case 107:
            printf(""l"");
            break;
        case 108:
            printf("";"");
            break;
        case 109:
            printf("","");
            break;
        case 110:
            printf(""m"");
            break;
        case 111:
            printf(""p"");
            break;
        case 112:
            printf(""["");
            break;
        case 113:
            printf(""w"");
            break;
        case 114:
            printf(""t"");
            break;
        case 115:
            printf(""d"");
            break;
        case 116:
            printf(""y"");
            break;
        case 117:
            printf(""i"");
            break;
        case 118:
            printf(""b"");
            break;
        case 119:
            printf(""e"");
            break;
        case 120:
            printf(""c"");
            break;
        case 121:
            printf(""u"");
            break;
        case 122:
            printf(""x"");
            break;
        default:
            printf(""Podany znak nie jest litera."");
            break;
    }


    return 0;
}",1,226,981
"int main()
{
    double a, b, c;
    double x1, x2;
    double delta;

    printf(""Podaj liczby a, b i c:\n"");
    printf(""a = "");
    scanf(""%lf"", &a);
    printf(""b = "");
    scanf(""%lf"", &b);
    printf(""c = "");
    scanf(""%lf"", &c);

    delta = b*b - 4*a*c;

    if (delta > 0)
    {
        x1 = (-1*b +  sqrt(delta))/2*a;
        x2 = (-1*b -  sqrt(delta))/2*a;
        printf(""Miejsca zerowe funkcji f(x) = %.1lf x^2 + %.1lf x + %.1lf , x1 = %.1lf , x2 = %.1lf"", a,  b, c, x1, x2);
    }

    if (delta == 0)
    {
        x1 = (-1*b)/2*a;
        printf(""Miejsce zerowe funkcji f(x) = %.1lf x^2 + %.1lf x + %.1lf , x = %.1lf"", a,  b, c, x1);
    }

    if (delta < 0)
        printf(""Brak miejsc zerowych."");

    return 0;
}",1,227,354
"double E = 0.000001;

double pierwiastek(double p, double E)
{
    double a = 1, b = p;

    while (fabs(a - b) >= E)
    {
        a = (a + b) / 2;
        b = p / a;
    }

    return a;
}

int main()
{
    double x, y;

    printf(""Podaj liczbe, z ktorej chcesz wyznaczyc pierwiastek: "");
    scanf(""%2lf"", &x);

    y = pierwiastek(x, E);

    printf(""Pierwiastek = %.3lf"", y);

    return 0;
}",1,228,184
"struct Distance
{
   int km;
   float m;
} d1, d2, result;

void convert (struct Distance * r)
{

   if (r->m > 1000.0)
   {
      r->m = r->m - 1000.0;
      r->km++;
   }
}
int main()
{
   printf(""Enter 1st distance\n"");
   printf(""Enter Kilometres: "");
   scanf(""%d"", &d1.km);
   printf(""Enter Metres: "");
   scanf(""%f"", &d1.m);
   printf(""\nEnter 2nd distance\n"");
   printf(""Enter Kilometres: "");
   scanf(""%d"", &d2.km);
   printf(""Enter Metres: "");
   scanf(""%f"", &d2.m);

   result.km = d1.km + d2.km;
   result.m = d1.m + d2.m;

   convert(&result);

   printf(""\nSum of distances = %dkm %.1fm\n"", result.km, result.m);
   return 0;
}",2,229,283
"void rearrange( int *arr, int n)
{
    int *aux =(int*)malloc(n*sizeof(int));
    for(int i = 0 ; i < n ; i++)
    {
        if(i == 0)
        *(aux + i) = *(arr + i) * (*(arr + i+1));
        else if(i == (n - 1))
        *(aux + i) = *(arr + i) * (*(arr + i-01));
        else
        *(aux + i) = (*(arr + i-1))  * (*(arr + i + 1));
    }
    for(int i = 0 ; i < n ; i++)
    {
        *(arr + i) = *(aux + i);
    }
}
int main()
{
    int *arr;
    int n;
    printf(""Enter number of elements : "");
    scanf(""%d"", &n);
    arr = (int*)malloc(n*sizeof(int));

    for(int i = 0 ; i < n ; i++)
    {
        printf(""Enter element no %d :"", i+1);
        scanf(""%d"", arr + i);
    }
    rearrange(arr, n);
    for (int i = 0 ; i < n ; i++)
    {
        printf(""%d "", *(arr + i));
    }
}",2,230,339
"int main()
{
    int m, n;
    printf(""Enter dimensions (m,n) : "");
    scanf(""%d%d"", &m, &n);
    int **p = (int**)malloc(m*sizeof(int*));
    for(int i = 0 ; i < m ; i++)
    {
        p[i] = (int*)malloc(n*sizeof(int));
    }

    printf(""Enter elements : \n"");
    for(int i = 0 ; i < m ; i++)
    {
        for(int j = 0 ; j < n ; j++)
        {
            scanf(""%d"", &p[i][j]);
        }
    }

    printf(""\nThe matrix : \n"");
    for(int i = 0 ; i < m ; i++)
    {
        for(int j = 0 ; j < n ; j++)
        {
            printf(""%d "", p[i][j]);
        }
        printf(""\n"");
    }
    printf(""\n"");
}",2,231,250
"int main()
{
    int *arr;
    int n;
    printf(""Enter number of elements : "");
    scanf(""%d"", &n);
    arr = (int*)malloc(n*sizeof(int));

    for(int i = 0 ; i < n ; i++)
    {
        printf(""Enter element no %d :"", i+1);
        scanf(""%d"", arr + i);
    }
    int max = arr[0];
    int c = 0;
    for(int i = 0 ; i < n ; i++)
    {
        if(max == arr[i])
        {
            c++;
        }
        if(max < arr[i])
        {
            max = arr[i];
        }
    }
    printf(""Largest element is %d and it appears %d times\n"", max, c);

}",2,232,210
"void ngerearrange(int *arr, int n)
{
    int i, j;
    for (i=0; i<n; i++)
    {
        for (j = i+1; j<n; j++)
        {
            if (*(arr + i) < *(arr + j))
            {
                *(arr + i) = *(arr + j);
                break;
            }
        }
    }
}

int main()
{
    int *arr;
    int n, x, y, z;
    printf(""Enter number of elements : "");
    scanf(""%d"", &n);
    arr = (int*)malloc(n*sizeof(int));

    for (int i = 0 ; i < n ; i++)
    {
        printf(""Enter element no %d :"", i+1);
        scanf(""%d"", arr + i);
    }

    ngerearrange(arr, n);
    printf(""Rearranged Array : \n"");
    for (int i = 0 ; i < n ; i++)
    {
        printf(""%d "", *(arr + i));
    }

}",2,233,277
"struct node
{
    int data;
    struct node *next;
}*first = NULL, *even = NULL, *odd = NULL;
struct node *create(int A[], int n)
{
    struct node *p, *t, *last;
    p = (struct node*)malloc(sizeof(struct node));
    p->data = A[0];
    p->next = NULL;
    last = p;

    for(int i = 1 ; i < n ; i++)
    {
        t = (struct node*)malloc(sizeof(struct node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
    }
    return p;
}

void display(struct node *p)
{
    while(p)
    {
        printf(""%d "", p->data);
        p = p->next;
    }
    printf(""\n"");
}

void inserteven(struct node *p, int index, int key)
{
    struct node *t = (struct node *)malloc(sizeof(struct node));
    t->data = key;

    if(index == 0)
    {
        t->next = even;
        even = t;
    }
    else
    {
        for(int i = 0 ; i < index - 1 ; i++)
        {
            p = p->next;
        }
        t->next = p->next;
        p->next = t;
    }
}

void insertodd(struct node *p, int index, int key)
{
    struct node *t = (struct node *)malloc(sizeof(struct node));
    t->data = key;

    if(index == 0)
    {
        t->next = odd;
        odd = t;
    }
    else
    {
        for(int i = 0 ; i < index - 1 ; i++)
        {
            p = p->next;
        }
        t->next = p->next;
        p->next = t;
    }
}

void convert(struct node *p)
{
    int ce = 0, co = 0;
    while(p)
    {
        if(p->data%2 == 0)
        {
            inserteven(even, ce, p->data);
            ce++;
        }
        else
        {
            insertodd(odd, co, p->data);
            co++;
        }
        p = p->next;
    }

    first = even;
    p = first;
    while(p->next != NULL)
        p = p->next;
    p->next = odd;
}

int main()
{
    int n, key;
    printf(""Number of elements : "");
    scanf(""%d"", &n);
    int A[n];
    printf(""Enter elements : "");
    for(int i = 0 ; i < n ; i++)
    {
        scanf(""%d"", &A[i]);
    }
    first = create(A, n);
    convert(first);
    display(first);
}",2,234,757
"int mindist(int *arr, int n, int x, int y)
{
    int d = 100;

    for(int i = 0 ; i < n ; i++)
    {
        if(x == *(arr + i))
        {
            for(int j = i ; j < n ; j++)
            {
                if(y == *(arr + j) && d > (j - i))
                {
                    d = j - i ;
                }
            }
        }
    }
    return d;
}
int main()
{
    int *arr;
    int n, x, y, z;
    printf(""Enter number of elements : "");
    scanf(""%d"", &n);
    arr = (int*)malloc(n*sizeof(int));

    for (int i = 0 ; i < n ; i++)
    {
        printf(""Enter element no %d :"", i+1);
        scanf(""%d"", arr + i);
    }
    printf(""Enter x & y : "");
    scanf(""%d%d"", &x,&y);

    z = mindist(arr, n, x, y) ;
    printf(""The minimum distance between %d & %d : %d\n"", x, y, z);
}",2,235,309
"void swap(int *x, int *y)
{
    int temp = *x;
    *x = *y;
    *y = temp;
}
void rowsort(int **mat, int m, int n)
{
    for (int i = 0 ; i < m ; i++)
    {
        for (int j = 0 ; j < n - 1 ; j++)
        {
            for (int k = j + 1 ; k < n ; k++)
            {
                if (mat[i][j] > mat[i][k])
                swap(&mat[i][j], &mat[i][k]);
            }
        }
    }
}
void colsort(int **mat, int m , int n)
{
    for (int j = 0 ; j < n ; j++)
    {
        for (int i = 0 ; i < m - 1 ; i++)
        {
            for (int k = i + 1 ; k < m ; k++)
            {
                if (mat[i][j] < mat[k][j])
                swap(&mat[i][j], &mat[k][j]);
            }
        }
    }
}
int main()
{
    int m, n;
    printf(""Enter number of rows : "");
    scanf(""%d"", &m);
    printf(""Enter number of columns : "");
    scanf(""%d"", &n);

    int **mat ;
    mat = (int**)malloc(m*sizeof(int*));
    for(int i = 0 ; i < m ; i++)
    {
        mat[i] = (int*)malloc(n*sizeof(int));
    }
    for(int i = 0 ; i < m ; i++)
    {
        for(int j = 0 ; j < n ; j++)
        {
            printf(""Enter element at row %d, column %d : "", i, j);
            scanf(""%d"", &mat[i][j]);
        }
    }
    printf(""Before sorting : \n"");
    for(int i = 0 ; i < m ; i++)
    {
        for (int j = 0 ; j < n ; j++)
        {
            printf(""%d "", mat[i][j]);
        }
        printf(""\n"");
    }
    rowsort(mat, m ,n);
    printf(""After Sorting Rows : \n"");
    for(int i = 0 ; i < m ; i++)
    {
        for (int j = 0 ; j < n ; j++)
        {
            printf(""%d "", mat[i][j]);
        }
        printf(""\n"");
    }
    colsort(mat, m, n);
    printf(""After Sorting Columns : \n"");
    for(int i = 0 ; i < m ; i++)
    {
        for (int j = 0 ; j < n ; j++)
        {
            printf(""%d "", mat[i][j]);
        }
        printf(""\n"");
    }
}
",2,236,728
"void ngerearrange( int *arr, int n)
{
    int i, j;
    for (i=0; i<n; i++)
    {
        for (j = i+1; j<n; j++)
        {
            if (*(arr + i) < *(arr + j))
            {
                *(arr + i) = *(arr + j);
                break;
            }
        }
    }
}

int main()
{
    int *arr;
    int n, x, y, z;
    printf(""Enter number of elements : "");
    scanf(""%d"", &n);
    arr = (int*)malloc(n*sizeof(int));

    for (int i = 0 ; i < n ; i++)
    {
        printf(""Enter element no %d :"", i+1);
        scanf(""%d"", arr + i);
    }

    ngerearrange(arr, n);
    printf(""Rearranged Array : \n"");
    for (int i = 0 ; i < n ; i++)
    {
        printf(""%d "", *(arr + i));
    }

}",2,237,277
"int main()
{
    int source[100], dest[100];
    int i, size;

    printf(""Enter the size of the array : "");
    scanf(""%d"", &size);

    printf(""Enter elements of source array : "");
    for(i=0; i<size; i++)
    {
        scanf(""%d  "", &source[i]);
    }

    for(i=0; i<size; i++)
    {
        dest[i] = source[i];
    }

    printf(""\nElements of source array are : "");
    for(i=0; i<size; i++)
    {
        printf(""%d. "", source[i]);
    }

    printf(""\nElements of dest array are : "");
    for(i=0; i<size; i++)
    {
        printf(""%d  "", dest[i]);
    }

}",2,238,218
"int main()
{
    int *A;
    int n;
    int choice;
    int size = 0;
    int t;
    printf(""1 : Lower Triangular Matrix\n"");
    printf(""2 : Upper Triangular Matrix\n"");
    printf(""Enter Choice : "");
    scanf(""%d"", &choice);
    printf(""Enter Dimensions : "");
    scanf(""%d"", &n);

    switch(choice)
    {
        case 1 :
        size = n*(n + 1) / 2;
        A = (int*)malloc(size * sizeof(int));
        printf(""\nEnter elements : \n"");
        for(int i = 1 ; i <= n ; i++)
        {
            for(int j = 1 ; j <= n ; j++)
            {
                scanf(""%d"", &t);
                if(i >= j)
                    A[i*(i-1)/2 + (j-1)] = t ;
            }
        }
        printf(""\n1D array storing the elements : "");
        for(int i = 0 ; i < size ; i++)
        {
            printf(""%d "", A[i]);
        }
        printf(""\n\nDisplaying matrix from stored 1D array values :\n"");
        for(int i = 1 ; i <= n ; i++)
        {
            for(int j = 1 ; j <= n ; j++)
            {
                if(i >= j)
                    printf(""%d "", A[i*(i-1)/2 + (j-1)]);
                else
                    printf(""  "");
            }
            printf(""\n"");
        }
        break;

        case 2 :
        size = n * (n + 1) / 2;
        A = (int*)malloc(size * sizeof(int));
        printf(""\nEnter elements : \n"");
        for(int i = 1 ; i <= n ; i++)
        {
            for(int j = 1 ; j <= n ; j++)
            {
                scanf(""%d"", &t);
                if(i <= j)
                    A[(n*(i-1) - (i-1)*(i-2)/2) + (j-i)] = t ;
            }
        }
        printf(""\n1D array storing the elements : "");
        for(int i = 0 ; i < size ; i++)
        {
            printf(""%d "", A[i]);
        }
        printf(""\n\nDisplaying matrix from stored 1D array values :\n"");
        for(int i = 1 ; i <= n ; i++)
        {
            for(int j = 1 ; j <= n ; j++)
            {
                if(i <= j)
                    printf(""%d "", A[(n*(i-1) - (i-1)*(i-2)/2) + (j-i)]);
                else
                    printf(""  "");
            }
            printf(""\n"");
        }
        break;
    }

}",2,239,722
"int main()
{
    int *arr;
    int n, k, temp;
    printf(""Enter number of elements : "");
    scanf(""%d"", &n);
    arr = (int*)malloc(n*sizeof(int));

    for(int i = 0 ; i < n ; i++)
    {
        printf(""Enter element no %d :"", i+1);
        scanf(""%d"", arr + i);
    }
    printf(""Enter k : "");
    scanf(""%d"", &k);
    
    for(int i = 0 ; i < n - 1 ; i++)
    {
        for(int j = 0; j < n - 1 - i; j ++)
        {
            if(arr[j] > arr[j+1])
            {
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
    printf(""The kth smallest element : %d\n"", arr[k-1]);
    printf(""The kth largest element : %d\n"", arr[n-k]);
}",2,240,274
"int main()
{
      int *a,n,i,j,t;
      printf(""Number of elements : "");
      scanf(""%d"",&n);
      a=(int *)calloc(n, sizeof(int));
      printf(""\nEnter %d Numbers: \n\n"",n);
      for(i=0;i<=n-1;i++)
      {
            scanf(""%d"", (a+i));
      }
      for(i=0;i<n-1;i++)
      {
            for(j=0;j<n-i-1;j++)
            {
                  if(*(a+j)>*(a+j+1))
                  {
                        t=*(a+j);
                        *(a+j)=*(a+j+1);
                        *(a+j+1)=t;
                  }
            }
      }
      printf(""\nAscending Order: \n"");
      for(i=0;i<n;i++)
      printf(""%d\t"",*(a+i));
      printf(""\n"") ;
      return 0;
}",2,241,270
"int num = 0;
int** readmatrix(int **A, int m, int n)
{
    A = (int**)malloc(m * sizeof(int*));
    num = 0;
    for(int i = 0 ; i < m ; i++)
    {
         A[i] = (int*)malloc(n * sizeof(int));
    }
    printf(""Enter elements : \n"");
    for (int i = 0 ; i < m ; i++)
    {
        for (int j = 0 ; j < n ; j++)
        {
            scanf(""%d"", &A[i][j]);
            if(A[i][j] != 0)
                num++;
        }
    }
    return A;
}
int** createsparserow(int **p, int m, int n)
{
    int r = num + 1;
    int **sparse = (int**)malloc(r * sizeof(int*));
    for(int i = 0 ; i < r ; i++)
    {
        sparse[i] = (int*)malloc(3 * sizeof(int));
    }
    sparse[0][0] = m;
    sparse[0][1] = n;
    sparse[0][2] = num;

    int k = 1;
    for(int i = 0 ; i < m ; i++)
    {
        for(int j = 0 ; j < n ; j++)
        {
            if(p[i][j] != 0)
            {
                sparse[k][0] = i;
                sparse[k][1] = j;
                sparse[k][2] = p[i][j];
                k++;
            }
        }
    }
    return sparse;
}

int** createsparsecol(int **p, int m, int n)
{
    int c = num + 1;
    int **sparse = (int**)malloc(3 * sizeof(int*));
    for(int i = 0 ; i < 3 ; i++)
    {
        sparse[i] = (int*)malloc(c * sizeof(int));
    }
    sparse[0][0] = m;
    sparse[1][0] = n;
    sparse[2][0] = num;

    int k = 1;
    for(int i = 0 ; i < m ; i++)
    {
        for(int j = 0 ; j < n ; j++)
        {
            if(p[i][j] != 0)
            {
                sparse[0][k] = i;
                sparse[1][k] = j;
                sparse[2][k] = p[i][j];
                k++;
            }
        }
    }
    return sparse;
}

void displayrowmajor(int **sp)
{
    printf(""\nRow Major Representation : \n\n"");
    printf(""\tRows\t\tColumns\t\tValues\n"");
    for(int i = 0 ; i < num + 1 ; i++)
    {
        for(int j = 0 ; j < 3 ; j++)
        {
            printf(""\t%d\t"", sp[i][j]);
        }
        printf(""\n"");
    }
    printf(""\n"");
}

void displaycolmajor(int **sp)
{
    printf(""\nColumn Major Representation : \n\n"");
    for(int i = 0 ; i < 3 ; i++)
    {
        for(int j = -1 ; j < num + 1 ; j++)
        {
            if(i == 0 && j == -1)
                printf(""Row\t"");
            else if(i == 1 && j == -1)
                printf(""Col\t"");
            else if(i == 2 && j == -1)
                printf(""Val\t"");
            else
                printf(""\t%d\t"", sp[i][j]);
        }
        printf(""\n"");
    }
    printf(""\n"");
}

int main()
{
    int m, n;
    printf(""Enter number of rows and columns : "");
    scanf(""%d%d"", &m, &n);
    int **A = NULL, **sparserow = NULL, **sparsecol = NULL;
    A = readmatrix(A, m, n);
    sparserow = createsparserow(A, m, n);
    sparsecol = createsparsecol(A, m, n);
    displayrowmajor(sparserow);
    displaycolmajor(sparsecol);
}",2,242,1101
"void swap(int *x, int *y)
{
    int temp = *x;
    *x = *y;
    *y = temp;
}

void rearrange(int *arr, int n)
{
    int i = -1, j = 0;
    int t;
    while (j != n)
    {
        if (arr[j] % 2 == 0)
        {
            i++;
            
            swap(&arr[i], &arr[j]);
        }
        j++;
    }
}
int main()
{
    int *arr;
    int n;
    printf(""Enter number of elements : "");
    scanf(""%d"", &n);
    arr = (int*)malloc(n*sizeof(int));

    for(int i = 0 ; i < n ; i++)
    {
        printf(""Enter element no %d :"", i+1);
        scanf(""%d"", arr + i);
    }
    printf(""Original array : \n"");
    for(int i = 0 ; i < n ; i++)
    {
        printf(""%d "", arr[i]);
    }

    rearrange(arr, n);
    printf(""\nRearranged array : \n"");
    for(int i = 0 ; i < n ; i++)
    {
        printf(""%d "", arr[i]);
    }
}",2,243,332
"struct node
{
    int data;
    struct node* next;
}*first;

void create(int A[], int n)
{
    struct node *t, *last;
    int i;
    first = (struct node*)malloc(sizeof(struct node));
    first->data = A[0];
    first->next = NULL;
    last = first;
    
    for(i = 1 ; i < n ; i++)
    {
        t = (struct node*)malloc(sizeof(struct node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
    }
}

void display(struct node *p)
{
    while(p)
    {
        printf(""%d "", p->data);
        p = p->next;
    }
    printf(""\n"");
}

void reversedisplay(struct node *p)
{
    if(p)
    {
        reversedisplay(p->next);
        printf(""%d "", p->data);
    }
}

int main()
{
    int n;
    printf(""Enter number of elements : "");
    scanf(""%d"", &n);
    int A[n];
    printf(""Enter elements : "");
    for(int i = 0 ; i < n ; i++)
    {
        scanf(""%d"", &A[i]);
    }
    create(A, n);
    printf(""\nThe list : "");
    display(first);
    printf(""\n"");
    printf(""The elements in reverse are : "");
    reversedisplay(first);
    printf(""\n"");
}


",2,244,402
"struct node
{
    int data;
    struct node *next;
}*first;

void create(int A[], int n)
{
    struct node *t, *last;
    first = (struct node*)malloc(sizeof(struct node));
    first->data = A[0];
    first->next = NULL;
    last = first;

    for(int i = 1 ; i < n ; i++)
    {
        t = (struct node*)malloc(sizeof(struct node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
    }
}

void count_key(struct node *p, int key)
{
    int counter = 0;
    while(p)
    {
        if(p->data == key)
            counter++;
        p = p->next;
    }
    printf(""Occurences of %d : %d\n"", key, counter);
}

int main()
{
    int n, key;
    printf(""Number of elements : "");
    scanf(""%d"", &n);
    int A[n];
    printf(""Enter elements : "");
    for(int i = 0 ; i < n ; i++)
    {
        scanf(""%d"", &A[i]);
    }

    create(A, n);
    printf(""Enter key : "");
    scanf(""%d"", &key);
    count_key(first, key);
}",2,245,358
"int main()
{
    int arr1[100], n,counter=0;
    int i, j, k;

       printf(""Number of elements to be stored in the array :"");
       scanf(""%d"",&n);

       printf(""Input %d elements in the array :\n"",n);
       for(i=0;i<n;i++)
            {
          printf(""element - %d : "",i);
          scanf(""%d"",&arr1[i]);
        }

    printf(""\nThe unique elements found in the array are : \n"");
    for(i=0; i<n; i++)
    {
        counter=0;

        for(j=0; j<i-1; j++)
        {
            if(arr1[i]==arr1[j])
            {
                counter++;
            }
        }
       for(k=i+1; k<n; k++)
        {
            if(arr1[i]==arr1[k])
            {
                counter++;
            }
        }
       if(counter==0)
        {
          printf(""%d "",arr1[i]);
        }
    }
}",2,246,285
"void printPoly(int poly[], int n)
{
    for (int i = 0 ; i < n ; i++)
    {
        printf(""%d"", poly[i]);
        if (i != 0)
            printf(""x^%d"", i) ;
        if (i != n-1)
            printf("" + "");
    }
    printf(""\n"");
}

int *multiply(int A[], int B[], int n, int m)
{
    int *prod = (int*)malloc((n + m - 1)*sizeof(int));

    for (int i = 0; i < n + m - 1; i++)
        prod[i] = 0;


    for (int i = 0 ; i < n; i++)
    {
        for (int j = 0 ; j < m ; j++)
            prod[i+j] += A[i]*B[j];
    }

    printPoly(prod, n+m-1);
    return prod;
}

int main()
{
    int n, m;
    printf(""Enter number of terms for P1: "");
    scanf(""%d"", &n);
    int A[n];
    printf(""Enter coefficients according to increasing order of exponents : "");
    for(int i = 0 ; i < n ; i++)
        scanf(""%d"", &A[i]);
    printf(""\nFirst polynomial : "");
    printPoly(A, n);

    printf(""\nEnter number of terms for P2: "");
    scanf(""%d"", &m);
    int B[m];
    printf(""Enter coefficients according to increasing order of exponents : "");
    for(int i = 0 ; i < m ; i++)
        scanf(""%d"", &B[i]);
    printf(""\nSecond polynomial : "");
    printPoly(B, m);

    printf(""\nProduct : "");
    int *prod = multiply(A, B, n, m);

}",2,247,475
"void swapval(int a , int b)
{
    int t = a;
    a = b;
    b = t;
    printf(""\n\nAfter swapping by value : \n"");
    printf(""Value of a : %d\nValue of b : %d"", a, b);
}
void swapref(int *a , int *b)
{
    int t = *a;
    *a = *b;
    *b = t;
}
int main()
{
    int a, b ;
    printf(""Enter 2 variables a & b: "");
    scanf(""%d%d"", &a, &b);
    printf(""Value of a : %d\nValue of b : %d"", a, b);
    swapval(a, b);

    swapref(&a, &b);
    printf(""\n\nAfter swapping by reference : \n"");
    printf(""Value of a : %d\nValue of b : %d"", a, b);
    printf(""\n"");
}",2,248,243
"struct node
{
    int data;
    struct node *next;
}*first;

void create(int A[], int n)
{
    struct node *t, *last;
    first = (struct node*)malloc(sizeof(struct node));
    first->data = A[0];
    first->next = NULL;
    last = first;

    for(int i = 1 ; i < n ; i++)
    {
        t = (struct node*)malloc(sizeof(struct node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
    }
}

void display(struct node *p)
{
    while(p)
    {
        printf(""%d "", p->data);
        p = p->next;
    }
    printf(""\n"");
}

void delete(struct node *p, int key)
{
    int index = 1;
    struct node *q = NULL;

    if(first->data == key)
    {
        printf(""\nKey found at node : %d\n\n"", index);
    }
    else
    {
        while(p->data != key)
        {
            q = p;
            p = p->next;
            index++;
            if(p->next ==NULL && p->data != key)
            {
                printf(""\nKey is not present in list\n"");
            }
        }
        printf(""Key found at node : %d\n"", index);

        q->next = p->next;
        p->next = first;
        first = p;
        printf(""Key moved to head\n\nNew list : "");
        display(first);
    }
}

int main()
{
    int n, key, index;
    printf(""Number of elements : "");
    scanf(""%d"", &n);
    int A[n];
    printf(""Enter elements : "");
    for(int i = 0 ; i < n ; i++)
    {
        scanf(""%d"", &A[i]);
    }
    create(A, n);
    
    

    printf(""Enter key to be searched : "");
    scanf(""%d"", &key);
    delete(first, key);
}",2,249,546
"int main()
{
   int i,n,a[100];


   printf(""number of elements to store in the array :"");
   scanf(""%d"",&n);

   printf(""Input %d number of elements in the array :\n"",n);
   for(i=0;i<n;i++)
      {
      printf(""element - %d : "",i);
      scanf(""%d"",&a[i]);
      }

   printf(""\nvalues oF the array are : \n"");
   for(i=0;i<n;i++)
     {
       printf(""% 5d"",a[i]);
     }

   printf(""\n values of array in reverse are :\n"");
   for(i=n-1;i>=0;i--)
      {
       printf(""% 5d"",a[i]);
      }
   printf(""\n\n"");
}
",2,250,218
"struct node
{
    int data;
    struct node *next;
}*first;

void create(int A[], int n)
{
    struct node *t, *last;
    first = (struct node*)malloc(sizeof(struct node));
    first->data = A[0];
    first->next = NULL;
    last = first;

    for(int i = 1 ; i < n ; i++)
    {
        t = (struct node*)malloc(sizeof(struct node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
    }
}

void display(struct node *p)
{
    while(p)
    {
        printf(""%d "", p->data);
        p = p->next;
    }
    printf(""\n"");
}

void sortinsert(struct node *p, int key)
{
    struct node *t, *q;
    t = (struct node *)malloc(sizeof(struct node));
    t->data = key;

    while(p && p->data < key)
    {
        q = p;
        p = p->next;
    }
    
    if(p == first)
    {
        t->next = first;
        first = t;
    }
    else
    {
        t->next = p;
        q->next = t;
    }
}

int main()
{
    int n, key;
    printf(""Number of elements : "");
    scanf(""%d"", &n);
    int A[n];
    printf(""Enter elements : "");
    for(int i = 0 ; i < n ; i++)
        scanf(""%d"", &A[i]);
    create(A, n);

    printf(""Enter key : "");
    scanf(""%d"", &key);
    sortinsert(first, key);
    display(first);
}",2,251,465
"int main()
{
    int arr1[100], arr2[100], arr3[200];
    int n1, n2, n3;
    int i, k;
       printf(""number of elements to be stored in the first array :"");
       scanf(""%d"",&n1);

       printf(""Input %d elements in the array :\n"",n1);
       for(i=0;i<n1;i++)
            {
          printf(""element - %d : "",i);
          scanf(""%d"",&arr1[i]);
        }
       printf(""Input the number of elements to be stored in the second array :"");
       scanf(""%d"",&n2);

       printf(""Input %d elements in the array :\n"",n2);
       for(i=0;i<n2;i++)
            {
          printf(""element - %d : "",i);
          scanf(""%d"",&arr2[i]);
        }
    n3 = n1 + n2;
    for(i=0;i<n1; i++)
        {
            arr3[i] = arr1[i];
        }
       int j = 0 ;
     while(j<n2)
        {
            arr3[i] = arr2[j];
            i++;
            j++;
        }
   for(i=0;i<n3; i++)
        {
           for(k=0;k<n3-1;k++)
             {

                if(arr3[k]<=arr3[k+1])
                 {
                     
                   j=arr3[k+1];
                   arr3[k+1]=arr3[k];
                   arr3[k]=j;
                 }
              }
         }

     printf(""\nThe merged array in decending order is :\n"");
    for(i=0; i<n3; i++)
    {
        printf(""%d   "", arr3[i]);
    }
    printf(""\n"");
}",2,252,490
"struct Distance
{
   int km;
   float m;
} d1, d2, result;

void convert (struct Distance * r)
{
    
   while (r->m > 1000.0)
   {
      r->m = r->m - 1000.0;
      r->km++;
   }
}
int main()
{
   printf(""Enter 1st distance\n"");
   printf(""Enter Kilometres: "");
   scanf(""%d"", &d1.km);
   printf(""Enter Metres: "");
   scanf(""%f"", &d1.m);
   printf(""\nEnter 2nd distance\n"");
   printf(""Enter Kilometres: "");
   scanf(""%d"", &d2.km);
   printf(""Enter Metres: "");
   scanf(""%f"", &d2.m);

   result.km = d1.km + d2.km;
   result.m = d1.m + d2.m;

   convert(&result);

   printf(""\nSum of distances = %dkm %.1fm\n"", result.km, result.m);
   return 0;
}",2,253,284
"struct node
{
    int data;
    struct node *next;
}*first;

void create(int A[], int n)
{
    struct node *t, *last;
    first = (struct node*)malloc(sizeof(struct node));
    first->data = A[0];
    first->next = NULL;
    last = first;

    for(int i = 1 ; i < n ; i++)
    {
        t = (struct node*)malloc(sizeof(struct node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
    }
}

void display(struct node *p)
{
    while(p)
    {
        printf(""%d "", p->data);
        p = p->next;
    }
    printf(""\n"");
}

void remduplicates(struct node *p)
{
    struct node *q, *r, *t;
    while(p)
    {
        q = p->next;
        r = p;

        while(q)
        {
            if(p->data == q->data)
            {
                r->next = q->next;
                t = q;
                free(t);
                q = q->next;
            }
            else
            {
                r = q;
                q = q->next;
            }
        }
        p = p->next;
    }
}

int main()
{
    int n, m;
    printf(""Number of elements : "");
    scanf(""%d"", &n);
    int A[n];
    printf(""Enter elements : "");
    for(int i = 0 ; i < n ; i++)
        scanf(""%d"", &A[i]);
    create(A, n);
    remduplicates(first);
    display(first);
}",2,254,453
"int main()
{
    int arr[100];
    int i, j, n, count = 0;

    printf(""Enter size of the array : "");
    scanf(""%d"", &n);

    printf(""Enter elements in array : "");
    for(i=0; i<n; i++)
    {
        scanf(""%d"", &arr[i]);
    }

    for(i=0; i<n; i++)
    {
        for(j=i+1; j<n; j++)
        {
            if(arr[i] == arr[j])
            {
                count++;
                break;
            }
        }
    }

    printf(""\nTotal number of duplicate elements found in array = %d"", count);

    return 0;
}",2,255,192
"void reverse (int * data, int n)
{
      int i , j;
      for (i = 0 , j = n-1; i < j ; i++, j--)
      {
            int temp = *(data + i) ;
            *(data + i) = *(data + j) ;
            *(data + j) = temp ;
      }
}
int main()
{
      int i, j, n,*data;
      printf(""No of elements : "");
      scanf(""%d"", &n);
      data = (int*) calloc(n, sizeof(int));
      if(data == NULL)
      {
            printf(""Error"");
            return 1 ;
      }
      printf(""\n"");
      for(i = 0; i < n; ++i)
      {
            printf(""Enter Number %d: "", i + 1);
            scanf(""%d"", data + i);
      }
      reverse(data, n);


      printf(""\n"");
      for(i = 0; i < n; ++i)
      {
            printf(""%d "", *(data + i));
      }
            printf(""\n"");
}",2,256,281
"struct element
{
    int row;
    int col;
    int x;
};
struct sparse
{
    int r;
    int c;
    int num;
    struct element *ele;
};
int main()
{
    struct sparse s;
    int *A;
    int n, m;
    int choice;
    int size = 0;
    int t;
    printf(""1 : Diagonal Matrix\n2 : Lower Triangular Matrix\n"");
    printf(""3 : for Upper Triangular Matrix\n4 : Tri-diagonal Matrix\n"");
    printf(""5 : Toeplitz Matrix\n6 : Symmetric Matrix\n7 : Sparse Matrix\n"");
    printf(""Enter Choice : "");
    scanf(""%d"", &choice);
    printf(""Enter Dimensions (same m & n values for options 1-6: "");
    scanf(""%d%d"",&m, &n);

    switch(choice)
    {
        case 1 :
        size = n;
        A = (int*)malloc(size * sizeof(int));
        printf(""\nEnter elements : \n"");
        for(int i = 1 ; i <= n ; i++)
        {
            for(int j = 1 ; j <= n ; j++)
            {
                scanf(""%d"", &t);
                if(i == j)
                {
                    A[i - 1] = t ;
                }
            }
        }
        printf(""\n1D array storing the elements : "");
        for(int i = 0 ; i < size ; i++)
        {
            printf(""%d "", A[i]);
        }
        printf(""\n\nDisplaying matrix from stored 1D array values :\n"");
        for(int i = 1 ; i <= n ; i++)
        {
            for(int j = 1 ; j <= n ; j++)
            {
                if(i == j)
                {
                    printf(""%d "", A[i - 1]);
                }
                else
                {
                    printf(""0 "");
                }
            }
            printf(""\n"");
        }
        break;

        case 2 :
        size = n*(n + 1) / 2;
        A = (int*)malloc(size * sizeof(int));
        printf(""\nEnter elements : \n"");
        for(int i = 1 ; i <= n ; i++)
        {
            for(int j = 1 ; j <= n ; j++)
            {
                scanf(""%d"", &t);
                if(i >= j)
                {
                    
                    A[i*(i-1)/2 + (j-1)] = t ;
                }
            }
        }
        printf(""\n1D array storing the elements : "");
        for(int i = 0 ; i < size ; i++)
        {
            printf(""%d "", A[i]);
        }
        printf(""\n\nDisplaying matrix from stored 1D array values :\n"");
        for(int i = 1 ; i <= n ; i++)
        {
            for(int j = 1 ; j <= n ; j++)
            {
                if(i >= j)
                {
                    printf(""%d "", A[i*(i-1)/2 + (j-1)]);
                }
                else
                {
                    printf(""0 "");
                }
            }
            printf(""\n"");
        }
        break;

        case 3 :
        size = n * (n + 1) / 2;
        A = (int*)malloc(size * sizeof(int));
        printf(""\nEnter elements : \n"");
        for(int i = 1 ; i <= n ; i++)
        {
            for(int j = 1 ; j <= n ; j++)
            {
                scanf(""%d"", &t);
                if(i <= j)
                {
                    
                    A[(n*(i-1) - (i-1)*(i-2)/2) + (j-i)] = t ;
                }
            }
        }
        printf(""\n1D array storing the elements : "");
        for(int i = 0 ; i < size ; i++)
        {
            printf(""%d "", A[i]);
        }
        printf(""\n\nDisplaying matrix from stored 1D array values :\n"");
        for(int i = 1 ; i <= n ; i++)
        {
            for(int j = 1 ; j <= n ; j++)
            {
                if(i <= j)
                {
                    printf(""%d "", A[(n*(i-1) - (i-1)*(i-2)/2) + (j-i)]);
                }
                else
                {
                    printf(""0 "");
                }
            }
            printf(""\n"");
        }
        break;

        case 4 :
        size = (3 * n) - 2;
        A = (int*)malloc(size * sizeof(int));
        printf(""\nEnter elements : \n"");
        for(int i = 1 ; i <= n ; i++)
        {
            for(int j = 1 ; j <= n ; j++)
            {
                scanf(""%d"", &t);
                if((i - j) == 1)
                    A[i-2] = t;
                else if((i - j) == 0)
                    A[n - 1 + i - 1] = t;
                else if((i - j) == -1)
                    A[(2*n) - 1 + i - 1] = t;
            }
        }
        printf(""\n1D array storing the elements : "");
        for(int i = 0 ; i < size ; i++)
        {
            printf(""%d "", A[i]);
        }
        printf(""\n\nDisplaying matrix from stored 1D array values :\n"");
        for(int i = 1 ; i <= n ; i++)
        {
            for(int j = 1 ; j <= n ; j++)
            {
                if((i - j) == 1)
                    printf(""%d "", A[i - 2]);
                else if((i - j) == 0)
                    printf(""%d "", A[n - 1 + i - 1]);
                else if((i - j) == -1)
                    printf(""%d "", A[(2*n) - 1 + i - 1]);
                else
                    printf(""0 "");
            }
            printf(""\n"");
        }
        break;

        case 5 :
        size = (2 * n) - 1;
        A = (int*)malloc(size * sizeof(int));
        printf(""\nEnter elements : \n"");
        for(int i = 1 ; i <= n ; i++)
        {
            for(int j = 1 ; j <= n ; j++)
            {
                scanf(""%d"", &t);
                if(i <= j)
                    A[j - i] = t;
                else if(j < i)
                    A[n + i - j - 1] = t;
            }
        }
        printf(""\n1D array storing the elements : "");
        for(int i = 0 ; i < size ; i++)
        {
            printf(""%d "", A[i]);
        }
        printf(""\n\nDisplaying matrix from stored 1D array values :\n"");
        for(int i = 1 ; i <= n ; i++)
        {
            for(int j = 1 ; j <= n ; j++)
            {
                if(i <= j)
                    printf(""%d "", A[j - i]);
                else if(j < i)
                    printf(""%d "", A[n + i - j - 1]);
            }
            printf(""\n"");
        }
        break;

        case 6 :
        size = n*(n + 1) / 2;
        A = (int*)malloc(size * sizeof(int));
        printf(""\nEnter elements : \n"");
        for(int i = 1 ; i <= n ; i++)
        {
            for(int j = 1 ; j <= n ; j++)
            {
                scanf(""%d"", &t);
                if(i >= j)
                {
                    
                    A[i*(i-1)/2 + (j-1)] = t ;
                }
            }
        }
        printf(""\n1D array storing the elements : "");
        for(int i = 0 ; i < size ; i++)
        {
            printf(""%d "", A[i]);
        }
        int temp1,temp2;
        printf(""\n\nDisplaying matrix from stored 1D array values :\n"");
        for(int i = 1 ; i <= n ; i++)
        {
            for(int j = 1 ; j <= n ; j++)
            {
                if(i >= j)
                {
                    printf(""%d "", A[i*(i-1)/2 + (j-1)]);
                }
                else
                {
                    temp1 = i;
                    temp2 = j;
                    printf(""%d "", A[temp2*(temp2-1)/2 + (temp1-1)]);
                }
            }
            printf(""\n"");
        }
        break;

        case 7 :
        s.r = m;
        s.c = n;
        int k = 0;
        printf(""\nEnter number of non-zero elements : "");
        scanf(""%d"", &s.num);
        s.ele = (struct element *)malloc(s.num*sizeof(struct element));
        printf(""\nEnter all elements : \n"");
        for(int i = 1 ; i <= s.r ; i++)
        {
            for(int j = 1 ; j <= s.c ; j++)
            {
                scanf(""%d"", &t);
                if(t != 0)
                {
                    s.ele[k].row = i;
                    s.ele[k].col = j;
                    s.ele[k].x = t;
                    k++;
                }
            }
        }
        printf(""\nColumnar representation of the Sparse Matrix : \n"");
        printf(""%d "", s.r);
        for(int i = 0; i < s.num ; i++)
        {
            printf(""%d "", s.ele[i].row);
        }
        printf(""\n%d "", s.c);
        for(int i = 0; i < s.num ; i++)
        {
            printf(""%d "", s.ele[i].col);
        }
        printf(""\n%d "", s.num);
        for(int i = 0; i < s.num ; i++)
        {
            printf(""%d "", s.ele[i].x);
        }
        printf(""\nDisplaying matrix from stored columnar representation : \n"");
        k = 0;
        for(int i = 1 ; i <= s.r ; i++)
        {
            for(int j = 1 ; j <= s.c ; j++)
            {
                if(i == s.ele[k].row && j == s.ele[k].col)
                {
                    printf(""%d "", s.ele[k].x);
                    k++;
                }
                else
                {
                    printf(""0 "");
                }
            }
            printf(""\n"");
        }
    }
}",2,257,2769
"int main()
{
    int a[1000],i,n,min,max;

    printf(""Enter size of the array : "");
    scanf(""%d"",&n);

    printf(""Enter elements in array : "");
    for(i=0; i<n; i++)
    {
        scanf(""%d"",&a[i]);
    }

    min=max=a[0];
    for(i=1; i<n; i++)
    {
         if(min>a[i])
          min=a[i];
           if(max<a[i])
            max=a[i];
    }
    printf(""minimum of array is : %d"",min);
    printf(""\nmaximum of array is : %d"",max);


    return 0;
}",2,258,196
"void swap(int *x, int *y)
{
    int temp = *x;
    *x = *y;
    *y = temp;
}

void segregate (int *arr, int n)
{
    int i = 0;
    int j = n - 1;
    while(i < j)
    {
        while(arr[i] == 0 && i < j)
        i++;

        while(arr[j] == 1 && i < j)
        j--;

        if(arr[i] != 0 && arr[j] != 1 && i < j)
        {
            swap(&arr[i], &arr[j]);
            i++;
            j--;
        }
    }
}

int main()
{
    int *arr, n;
    printf(""Enter number of elements : "");
    scanf(""%d"", &n);
    arr = (int*)malloc(n*sizeof(int));
    for(int i = 0 ; i < n ; i++)
    {
        printf(""Enter element %d : "", i+1);
        scanf(""%d"", &arr[i]);
    }
    segregate(arr, n);
    printf(""Segregated array : \n"");
    for(int i = 0 ; i < n ; i++)
    {
        printf(""%d "", arr[i]);
    }

}",2,259,338
"void printPoly(int poly[], int n)
{
    for (int i = 0 ; i < n ; i++)
    {
        printf(""%d"", poly[i]);
        if (i != 0)
            printf(""x^%d"", i) ;
        if (i != n-1)
            printf("" + "");
    }
    printf(""\n"");
}

int *add(int A[], int B[], int n, int m)
{
    int max;
    if(m>n)
        max = m;
    else
        max = n;
    int *sum = (int*)malloc(max*sizeof(int));

    for (int i = 0; i<n; i++)
        sum[i] = A[i];

    for (int i=0; i<m; i++)
        sum[i] += B[i];

    printPoly(sum, max);
    return sum;
}

int main()
{
    int n, m;
    printf(""Enter number of terms for P1: "");
    scanf(""%d"", &n);
    int A[n];
    printf(""Enter coefficients according to increasing order of exponents : "");
    for(int i = 0 ; i < n ; i++)
        scanf(""%d"", &A[i]);
    printf(""\nFirst polynomial : "");
    printPoly(A, n);

    printf(""\nEnter number of terms for P2: "");
    scanf(""%d"", &m);
    int B[m];
    printf(""Enter coefficients according to increasing order of exponents : "");
    for(int i = 0 ; i < m ; i++)
        scanf(""%d"", &B[i]);
    printf(""\nSecond polynomial : "");
    printPoly(B, m);

    printf(""\nSum of P1 and P2 : "");
    int *sum = add(A, B, n, m);
}",2,260,464
"struct node
{
    int data;
    struct node *next;
}*first;

struct node_freq
{
    int data;
    int freq;
    struct node_freq *next;
}*head;

void create(int A[], int n)
{
    struct node *t, *last;
    first = (struct node*)malloc(sizeof(struct node));
    first->data = A[0];
    first->next = NULL;
    last = first;

    for(int i = 1 ; i < n ; i++)
    {
        t = (struct node*)malloc(sizeof(struct node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
    }
}

void insert(struct node_freq *p, int index, int key)
{
    struct node_freq *t = (struct node_freq *)malloc(sizeof(struct node_freq));
    t->data = key;
    t->freq = 0;

    if(index == 0)
    {
        t->next = head;
        head = t;
    }
    else
    {
        for(int i = 0 ; i < index - 1 ; i++)
        {
            p = p->next;
        }
        t->next = p->next;
        p->next = t;
    }
}

void display_freq(struct node_freq *p)
{
    while(p)
    {
        printf(""Frequency of element %d is %d\n"", p->data, p->freq);
        p = p->next;
    }
    printf(""\n"");
}

void frequency(struct node *p)
{
    struct node *q;
    int c = 0, counter;
    while(p)
    {
        counter = 0;
        q = p->next;

        while(q)
        {
            if(p->data == q->data)
            counter++;
            q = q->next;
        }
        if(counter == 0)
        {
            insert(head, c, p->data);
            c++;
        }
        p = p->next;
    }
    
    


    struct node_freq *r = head;
    while(r)
    {
        p = first;
        while(p)
        {
            if(r->data == p->data)
                r->freq++;
            p = p ->next;
        }
        r = r->next;
    }

    display_freq(head);
}

int main()
{
    int n, key;
    printf(""Number of elements : "");
    scanf(""%d"", &n);
    int A[n];
    printf(""Enter elements : "");
    for(int i = 0 ; i < n ; i++)
    {
        scanf(""%d"", &A[i]);
    }

    create(A, n);
    frequency(first);
}",2,261,746
"int main()
{
    int *arr;
    int n;
    printf(""Enter number of elements : "");
    scanf(""%d"", &n);
    arr = (int*)malloc(n*sizeof(int));

    for(int i = 0 ; i < n ; i++)
    {
        printf(""Enter element no %d :"", i+1);
        scanf(""%d"", arr + i);
    }
    int min1 = *arr;
    int max1 = *arr;
    int min2 = *arr;
    int max2 = *arr;
    for(int i = 0 ; i < n ; i++)
    {
        if(max1 < *(arr + i))
        {
            max2 = max1;
            max1 = *(arr + i);
        }
        
        else if(max2 < *(arr +i) && *(arr +i) != max1)
        {
            max2 = *(arr +i);
        }
        if(min1 > *(arr +i))
        {
            min2 = min1;
            min1 = *(arr + i);
        }
        else if(min2 > *(arr +i) && *(arr +i) != min1)
        {
            min2 = *(arr +i);
        }
    }
    printf(""Second smallest element : %d\n"", min2);
    printf(""Second largest element : %d\n"", max2);
}",2,262,354
"#include ""mulprec.h""


void clearByZero(struct NUMBER *a){
    int i;

    for (i = 0; i < KETA;i++){
        a->n[i] = 0;
    }

    setSign(a, 1);
}


void dispNumber(struct NUMBER *a){
    int i;

    if(getSign(a) == 1){
        printf(""+"");
    } else {
        printf(""-"");
    }

    for (i = KETA - 1; i >= 0;i--){
        printf(""%2d"", a->n[i]);
    }
}


void dispNumberZeroSuppress(struct NUMBER *a){
    int i;

    if(getSign(a) == 1) {
        printf(""+"");
    } else {
        printf(""-"");
    }

    for (i = KETA - 1; i >= 0; i--) {
        if(a->n[i] != 0){
            break;
        }

        if(i == 0){
            printf(""%2d"", a->n[i]);
        }
    }
    for (; i >= 0;i--) {
        printf(""%2d"", a->n[i]);
    } 
}


void setRnd(struct NUMBER *a, int k){
    int i;
    int judge;

    clearByZero(a);

    for (i = 0; i < k;i++){
        a->n[i] = random() % 10; 
    }

    judge = random() % 2; 

    switch (judge) {
        case 1:
            setSign(a, 1);
            break;
        case 0:
            setSign(a, -1);
            break;
    }
}


void copyNumber(struct NUMBER *a, struct NUMBER *b){
    int i;

    clearByZero(b);

    setSign(b, getSign(a));

    for (i = 0; i < KETA;i++){
        b->n[i] = a->n[i];
    }
}


void getAbs(struct NUMBER *a, struct NUMBER *b){
    copyNumber(a, b);
    setSign(b, 1); 
}


int isZero(struct NUMBER *a){
    int i;

    for (i = 0; i < KETA;i++){
        if(a->n[i] != 0){
            return -1;
        }
    }

    return 0;
}


int mulBy10(struct NUMBER *a, struct NUMBER *b){
    int i;

    clearByZero(b);

    setSign(b, getSign(a)); 

    
    if(a->n[KETA - 1] != 0){
        return -1;
    }

    for (i = KETA - 2; i >= 0;i--){
        b->n[i + 1] = a->n[i];
    }

    b->n[0] = 0;

    return 0;
}


int divBy10(struct NUMBER *a, struct NUMBER *b){
    int i;
    int remainder; 

    clearByZero(b);

    setSign(b, getSign(a)); 

    remainder = getSign(a) * a->n[0]; 

    for (i = 1; i <= KETA - 2;i++){
        b->n[i - 1] = a->n[i];
    }

    b->n[KETA - 1] = 0;

    return remainder;
}


int setInt(struct NUMBER *a, int x) {
    int digit = 1; 
    int i;

    for (int i = x; i >= 10; i /= 10) { 
        digit++;
        if(digit > KETA) {
            return -1;
        }
    }

    clearByZero(a);

    if(x > 0){
        setSign(a, 1);
    } else {
        setSign(a, -1);
    }

    x = abs(x);

    for (i = 0; i < KETA;i++){
        a->n[i] = x % 10;
        x /= 10;
    }

    
    

    return 0;
}


void setText(struct NUMBER *a, int x) {
    FILE *fp;
    int i;

    if ((fp = fopen(""check.txt"", ""a"")) == NULL) {
        printf(""ãã¡ã¤ã«ããªã¼ãã³ã§ãã¾ããã\n"");
    } else {
        
        fprintf(fp, ""%d\t"", x);
        
        for (i = KETA - 1; i >= 0; i--) {
            if(getSign(a) != 0){
                break;
            }

            if(i == 0){
                fprintf(fp, ""%d"", a->n[i]);
            }
        }
        for (; i >= 0;i--) {
            fprintf(fp, ""%d"", a->n[i]);
        }
        fprintf(fp, ""\n"");

        fclose(fp);
    }
}


void checkText() {
    FILE *fp;
    int i;
    int int_num;
    int mul_num;

    if ((fp = fopen(""check.txt"", ""r"")) == NULL) {
        printf(""ãã¡ã¤ã«ããªã¼ãã³ã§ãã¾ããã\n"");
    } else {
        for (i = 0; i < TRY;i++){
            
            fscanf(fp, ""%d"", &int_num);
            
            fscanf(fp, ""%d\n"", &mul_num);

            if(int_num != mul_num){
                printf(""å¤ãéãã¾ã\nint = %d\nmul = %d"", int_num, mul_num);
            }
        }
        fclose(fp);
    }
    
}


int setSign(struct NUMBER *a, int s) {
    if(s == 1){
        a->sign = 1;
    } else if(s == -1){
        a->sign = -1;
    } else {
        return -1;
    }

    return 0;
}


int getSign(struct NUMBER *a) {
    if(a->sign == 1){ 
        return 1;
    }
    
    return -1;
}


int numComp(struct NUMBER *a, struct NUMBER *b) {
    int sa = getSign(a);
    int sb = getSign(b);
    int i;

    if(sa > sb){ 
        return 1;
    }

    if(sa < sb){ 
        return -1;
    }

    if(sa == 1 && sb == 1){ 
        for (i = KETA - 1; i >= 0;i--){
            if(a->n[i] > b->n[i]){ 
                return 1;
            } else if(a->n[i] < b->n[i]){
                return -1;
            }
        }

        return 0; 
    }

    if(sa == -1 && sb == -1){ 
        for (i = KETA - 1; i >= 0;i--){
            if(a->n[i] > b->n[i]){ 
                return -1;
            } else if(a->n[i] < b->n[i]){
                return 1;
            }
        }

        return 0; 
    }

    
    return 100;
}


int add(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {
    int d; 
    int e = 0; 
    int i;
    struct NUMBER a_abs, b_abs; 

    clearByZero(c);

    if(getSign(a) > 0 && getSign(b) > 0){ 
        for (i = 0; i < KETA;i++){
            d = a->n[i] + b->n[i] + e;
            c->n[i] = d % 10;
            e = (d - c->n[i]) / 10; 
        }

        if(e != 0){ 
            return -1;
        }

    } else if(getSign(a) > 0 && getSign(b) < 0){ 
        getAbs(b, &b_abs);
        sub(a, &b_abs, c);
    } else if(getSign(a) < 0 && getSign(b) > 0){ 
        getAbs(a, &a_abs);
        sub(b, &a_abs, c);
    } else if(getSign(a) < 0 && getSign(b) < 0){ 
        getAbs(a, &a_abs);
        getAbs(b, &b_abs);
        add(&a_abs, &b_abs, c);
        setSign(c, -1);
    }

    return 0;
}


int sub(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {
    int h = 0;
    int i;
    int return_val;
    int x, y; 
    struct NUMBER a_abs, b_abs; 

    clearByZero(c);

    if(getSign(a) > 0 && getSign(b) > 0){ 
        return_val = numComp(a, b); 

        switch (return_val)
        {
        case 1: 
            for (i = 0; i < KETA;i++){
                x = a->n[i] - h;
                y = b->n[i];
                if(a->n[i] < b->n[i]){
                    c->n[i] = 10 + x - y;
                    h = 1; 
                } else if(a->n[i] >= b->n[i]){
                    c->n[i] = x - y;
                    h = 0; 
                }
            }
            if(h != 0){ 
                return -1;
            }
            return 0; 
        case -1: 
            sub(b, a, c);
            setSign(c, -1);
            return 0;
        case 0: 
            return 0;
        }
    } else if(getSign(a) > 0 && getSign(b) < 0){ 
        getAbs(b, &b_abs);
        add(a, &b_abs, c);
        return 0; 
    } else if(getSign(a) < 0 && getSign(b) > 0){ 
        getAbs(a, &a_abs);
        add(&a_abs, b, c);
        setSign(c, -1);
        return 0; 
    } else if(getSign(a) < 0 && getSign(b) < 0){ 
        getAbs(b, &b_abs);
        add(a, &b_abs, c);
        return 0; 
    }

    return 100; 
}


int increment(struct NUMBER *a, struct NUMBER *b) {
    struct NUMBER one;
    int r;

    setInt(&one, 1);
    r = add(a, &one, b);

    return r;
}


int decrement(struct NUMBER *a, struct NUMBER *b) {
    struct NUMBER one;
    int r;

    setInt(&one, 1);
    r = sub(a, &one, b);

    return r;
}



int multiple(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {
    int i, j, h, e, aj, bi;
    struct NUMBER tmp, d;
    int flag_a = 0; 
    int flag_b = 0; 

    clearByZero(c);

    for (i = 0; i < KETA;i++){
        bi = b->n[i];
        h = 0;
        clearByZero(&d);
        for (j = 0; j <= KETA;j++){
            aj = a->n[j];
            e = aj * bi + h; 
            d.n[j] = (e % 10); 
            e /= 10;
            h = (e % 10); 
            e /= 10;
            if(i == KETA && h != 0){ 
                return -1;
            }
        }
        add(c, &d, c);
    }

    

    return 0; 
}


int divide(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c, struct NUMBER *d) {
    struct NUMBER m, n, p, q;

    clearByZero(c);
    clearByZero(d);

    if(isZero(b) != -1){ 
        return -1;
    }

    copyNumber(a, &n);

    while(1){
        if(numComp(&n, b) != -1){ 
            increment(c, &m);
            copyNumber(&m, c);
            sub(&n, b, &m);
            copyNumber(&m, &n);
        } else { 
            copyNumber(&n, d);
            break;
        }
    }

    return 0;
}",3,263,3579
"#include ""mulprec.h""

int quickDivide(struct NUMBER *, struct NUMBER *, struct NUMBER *, struct NUMBER *);

int main(int argc, char **argv)
{
    double t1 = time(NULL);
    struct NUMBER a, b, c, d;
    
    int x, y;
    

    x = 49585;
    y = 98;


    setInt(&a, x);
    setInt(&b, y);

    printf(""x = %d\ny = %d\nx / y = %d\nx %% y = %d\n"", x, y, x / y, x % y);

    quickDivide(&a, &b, &c, &d);
    dispNumberZeroSuppress(&c);
    puts("""");
    dispNumberZeroSuppress(&d);
    puts("""");

    

    double t2 = time(NULL);
    printf(""å¦çæé:%f\n"", t2 - t1);
    
    return 0;
}


int quickDivide(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c, struct NUMBER *d) {
    struct NUMBER tmp1, tmp2, a_tmp, e;

    if(isZero(b) != -1){ 
        return -1;
    }

    
    if(getSign(a) > 0 && getSign(b) < 0){ 
        getAbs(b, &tmp1);
        divide(a, &tmp1, c, d);
        setSign(c, -1);
        return 0; 
    } else if(getSign(a) < 0 && getSign(b) > 0){ 
        getAbs(a, &tmp1);
        divide(&tmp1, b, c, d);
        setSign(c, -1);
        setSign(d, -1);
        return 0; 
    } else if(getSign(a) < 0 && getSign(b) < 0) { 
        getAbs(a, &tmp1);
        getAbs(b, &tmp2);
        divide(&tmp1, &tmp2, c, d);
        setSign(d, -1);
        return 0; 
    }

    clearByZero(c); 
    copyNumber(a, &a_tmp);
    clearByZero(d);

    while(1){
        if(numComp(&a_tmp, b) >= 0){ 
            copyNumber(b, d); 
            setInt(&e, 1); 
            while(1){ 
                if(numComp(&a_tmp, d) >= 0){
                    mulBy10(d, &tmp1);
                    copyNumber(&tmp1, d);
                    mulBy10(&e, &tmp2);
                    copyNumber(&tmp2, &e);
                } else { 
                    divBy10(d, &tmp1); 
                    copyNumber(&tmp1, d);
                    divBy10(&e, &tmp2);
                    copyNumber(&tmp2, &e);
                    break;
                }
            }
            sub(&a_tmp, d, &tmp1); 
            copyNumber(&tmp1, &a_tmp);
            add(c, &e, &tmp2); 
            copyNumber(&tmp2, c);
            
            printf(""c:"");
            dispNumberZeroSuppress(c);
            puts("""");
            printf(""d:"");
            dispNumberZeroSuppress(d);
            puts("""");
            printf(""a_tmp:"");
            dispNumberZeroSuppress(&a_tmp);
            puts("""");
        } else if(numComp(&a_tmp, b) < 0){ 
            copyNumber(&a_tmp, d);
            break; 
        }
    }

    return 0;
}",3,264,970
"#include ""mulprec.h""

int setInt(struct NUMBER *, int);
void setText(struct NUMBER *, int);
void checkText();
void dispNumberNormal(struct NUMBER *);

int main(int argc, char **argv)
{
    int i;
    srandom(time(NULL));
    struct NUMBER a;
    setInt(&a, -101);
    dispNumberZeroSuppress(&a);
    for (i = 0; i < TRY;i++){
        
        
        

        

        
        
        
        
    }
    
        

    return 0;
}


int setInt(struct NUMBER *a, int x) {
    int i;

    clearByZero(a);

    for (i = 0; i < KETA;i++){
        a->n[i] = x % 10;
        x = x / 10;
    }

    if(x > 0){
        setSign(a, 1);
    } else {
        setSign(a, -1);
    }

        
        return 0;
}


void setText(struct NUMBER *a, int x) {
    FILE *fp;
    int i;

    if ((fp = fopen(""check.txt"", ""a"")) == NULL) {
        printf(""ãã¡ã¤ã«ããªã¼ãã³ã§ãã¾ããã\n"");
    } else {
        
        fprintf(fp, ""%d\t"", x);
        
        for (i = KETA - 1; i >= 0; i--) {
            if(a->n[i] != 0){
                break;
            }

            if(i == 0){
                fprintf(fp, ""%d"", a->n[i]);
            }
        }
        for (; i >= 0;i--) {
            fprintf(fp, ""%d"", a->n[i]);
        }
        fprintf(fp, ""\n"");

        fclose(fp);
    }
}


void checkText() {
    FILE *fp;
    int i;
    int int_num;
    int mul_num;

    if ((fp = fopen(""check.txt"", ""r"")) == NULL) {
        printf(""ãã¡ã¤ã«ããªã¼ãã³ã§ãã¾ããã\n"");
    } else {
        for (i = 0; i < TRY;i++){
            
            fscanf(fp, ""%d"", &int_num);
            
            fscanf(fp, ""%d\n"", &mul_num);

            printf(""int = %d\nmul = %d\n\n"", int_num, mul_num);
        }

        fclose(fp);
    }
    
}


void dispNumberNormal(struct NUMBER *a){
    int i;

    
    for (i = KETA - 1; i >= 0; i--) {
        if(a->n[i] != 0){
            break;
        }

        if(i == 0){
            printf(""%d"", a->n[i]);
        }
    }
    for (; i >= 0;i--) {
        printf(""%d"", a->n[i]);
    } 
}

",3,265,882
"#include ""mulprec.h""

int lcm(struct NUMBER *, struct NUMBER *, struct NUMBER *);

int main(int argc, char **argv)
{
    struct NUMBER a, b, c;
    int return_val;
    int x, y;

    x = 98765;
    y = 43210;

    setInt(&a, x);
    setInt(&b, y);

    return_val = lcm(&a, &b, &c);
    dispNumberZeroSuppress(&c);
    printf(""\næ»ãå¤ = %d"", return_val);

    return 0;
}


int lcm(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {
    struct NUMBER tmp, tmp2;
    gcd(a, b, c);

    if(isZero(c) != -1){ 
        return 0;
    }

    divide(a, c, &tmp, &tmp2);
    dispNumberZeroSuppress(&tmp);
    dispNumberZeroSuppress(b);
    multiple(&tmp, b, c);

    return 0;
}",3,266,298
"#include ""mulprec.h""

int neipia(struct NUMBER *, struct NUMBER *);

int main(int argc, char **argv)
{
    
    
    double t1 = time(NULL);

    struct NUMBER a, b, c, d, one, two, three, a_tmp;
    int val;

    setInt(&one ,1);
    setInt(&two, 2);
    setInt(&three, 3);

    setInt(&b, 500); 

    printf(""ãã¤ãã¢æ°è¨ç®éå§\n"");
    neipia(&a, &b);
    dispNumber(&a);
    
    
    val = getDigit(&a);
    printf(""\nval1:%d\n"", val);
    compareNumber(&a, ""neipia.txt"", val);
    
    
    double t3 = time(NULL);
    printf(""\néä¸­æé:%f\n"", t3 - t1);
    printf(""\nå¹³æ¹æ ¹è¨ç®éå§\n"");
    divBy10(&a, &a_tmp);
    copyNumber(&a_tmp, &a);
    sqrt_newton(&a, &c);
    dispNumberZeroSuppress(&c);
    val = getDigit(&c);
    printf(""\nval2:%d\n"", val);
    compareNumber(&c, ""sqrtE.txt"", val);
    t3 = time(NULL);
    printf(""\néä¸­æé:%f\n"", t3 - t1);
    printf(""\nä¸ä¹æ ¹è¨ç®éå§\n"");
    
    
    
    


    

    mulBy10(&a, &a_tmp);
    copyNumber(&a_tmp, &a);
    curt(&a, &d);
    dispNumberZeroSuppress(&d);
    val = getDigit(&d);
    printf(""\nval3:%d\n"", val);
    compareNumber(&d, ""curtE.txt"", val);
    
    
    

    
    
    
    

    double t2 = time(NULL);
    printf(""\nå¦çæé:%f\n"", t2 - t1);
    
    return 0;
}


int neipia(struct NUMBER *a, struct NUMBER *b)
{
    struct NUMBER  n, one, divid, divided, quotient, rest;
    
    
    
    clearByZero(&divided);
    
    clearByZero(a);

    divided.n[KETA-1] = 1;
    setInt(&n,2);
    setInt(&divid,2);
    if(numComp(&n,b) == 1){
        return -1;
    }
    setInt(&one,1);
    multiple(&n,&divided,a);
    
    while(1){
        quickDivide(&divided,&divid,&quotient,&rest);
        add(a,&quotient,&rest);
        copyNumber(&rest, a);
        
        if(numComp(b,&n) == 0){
            break;
        }
        add(&n,&one,&rest);
        copyNumber(&rest, &n);
        multiple(&divid,&n,&rest);
        copyNumber(&rest, &divid);

        
    }

    return 0;
}",3,267,915
"#define KETA 15

struct NUMBER{
    int n[KETA]; 
    int sign; 
};

void dispNumberZeroSuppress(struct NUMBER *);

void dispNumber(struct NUMBER *a){
    int i;

    if(a->sign == 1){
        printf(""+"");
    } else {
        printf(""-"");
    }

    for (i = KETA - 1; i >= 0;i--){
        printf(""%2d"", a->n[i]);
    }
}


void clearByZero(struct NUMBER *a){
    int i;

    for (i = 0; i < KETA;i++){
        a->n[i] = 0;
    }

    a->sign = 1;
}


void setRnd(struct NUMBER *a, int k){
    int i;
    int judge;

    clearByZero(a);

    for (i = 0; i < k;i++){
        a->n[i] = random() % 10; 
    }

    judge = random() % 2; 

    switch (judge) {
        case 1:
            a->sign = 1;
            break;
        case 0:
            a->sign = -1;
            break;
    }
}

int main(int argc, char **argv)
{
    srandom(time(NULL));
    struct NUMBER a;

    setRnd(&a, 10);

    printf(""a = ""); 
    dispNumberZeroSuppress(&a);
    printf(""\n"");

    printf(""aãã = ""); 
    dispNumber(&a);
    printf(""\n"");

}


void dispNumberZeroSuppress(struct NUMBER *a){
    int i;

    if(a->sign == 1) {
        printf(""+"");
    } else {
        printf(""-"");
    }

    for (i = KETA - 1; i >= 0; i--) {
        if(a->n[i] != 0){
            
            break;
        }

        if(i == 0){
            
            printf(""%2d"", a->n[i]);
        }
    }
    for (; i >= 0;i--) {
        
        printf(""%2d"", a->n[i]);
    } 
}",3,268,602
"#include ""mulprec.h""

int divide(struct NUMBER *, struct NUMBER *, struct NUMBER *, struct NUMBER *);

int main(int argc, char **argv)
{
    double t1 = time(NULL);
    struct NUMBER a, b, c, d;
    
    int x, y;
    int i;

    x = 100000000;
    y = 2;

    setInt(&a, x);
    setInt(&b, y);

    printf(""x = %d\ny = %d\nx / y = %d\nx %% y = %d\n"", x, y, x / y, x % y);
    dispNumberZeroSuppress(&a);
    puts("""");
    dispNumberZeroSuppress(&b);
    puts("""");

    divide(&a, &b, &c, &d);
    dispNumberZeroSuppress(&c);
    puts("""");
    dispNumberZeroSuppress(&d);
    puts("""");

    

    double t2 = time(NULL);
    printf(""å¦çæé:%f\n"", t2 - t1);
    return 0;
}


int divide(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c, struct NUMBER *d) {
    struct NUMBER m, n, p, q;

    
    if(getSign(a) > 0 && getSign(b) < 0){ 
        getAbs(b, &p);
        divide(a, &p, c, d);
        setSign(c, -1);
        return 0; 
    } else if(getSign(a) < 0 && getSign(b) > 0){ 
        getAbs(a, &p);
        divide(&p, b, c, d);
        setSign(c, -1);
        setSign(d, -1);
        return 0; 
    } else if(getSign(a) < 0 && getSign(b) < 0) { 
        getAbs(a, &p);
        getAbs(b, &q);
        divide(&p, &q, c, d);
        setSign(d, -1);
        return 0; 
    }

    clearByZero(c);
    clearByZero(d);

    if(isZero(b) != -1){ 
        return -1;
    }

    copyNumber(a, &n);

    while(1){
        if(numComp(&n, b) != -1){ 
            increment(c, &m);
            copyNumber(&m, c);
            sub(&n, b, &m);
            copyNumber(&m, &n);
        } else { 
            copyNumber(&n, d);
            break;
        }
    }

    return 0;
}",3,269,714
"#include ""mulprec.h""


void clearByZero(struct NUMBER *a){
    int i;

    for (i = 0; i < KETA;i++){
        a->n[i] = 0;
    }

    a->sign = 1;
}


void dispNumber(struct NUMBER *a){
    int i;

    if(a->sign == 1){
        printf(""+"");
    } else {
        printf(""-"");
    }

    for (i = KETA - 1; i >= 0;i--){
        printf(""%2d"", a->n[i]);
    }
}


void dispNumberZeroSuppress(struct NUMBER *a){
    int i;

    if(a->sign == 1) {
        printf(""+"");
    } else {
        printf(""-"");
    }

    for (i = KETA - 1; i >= 0; i--) {
        if(a->n[i] != 0){
            break;
        }

        if(i == 0){
            printf(""%2d"", a->n[i]);
        }
    }
    for (; i >= 0;i--) {
        printf(""%2d"", a->n[i]);
    } 
}


void setRnd(struct NUMBER *a, int k){
    int i;
    int judge;

    clearByZero(a);

    for (i = 0; i < k;i++){
        a->n[i] = random() % 10; 
    }

    judge = random() % 2; 

    switch (judge) {
        case 1:
            a->sign = 1;
            break;
        case 0:
            a->sign = -1;
            break;
    }
}


void copyNumber(struct NUMBER *a, struct NUMBER *b){
    int i;

    clearByZero(b);

    b->sign = a->sign;

    for (i = 0; i < KETA;i++){
        b->n[i] = a->n[i];
    }
}


void getAbs(struct NUMBER *a, struct NUMBER *b){
    copyNumber(a, b);
    b->sign = 1; 
}


int isZero(struct NUMBER *a){
    int i;

    for (i = 0; i < KETA;i++){
        if(a->n[i] != 0){
            return -1;
        }
    }

    return 0;
}


int mulBy10(struct NUMBER *a, struct NUMBER *b){
    int i;

    clearByZero(b);

    b->sign = a->sign; 

    
    if(a->n[KETA - 1] != 0){
        return -1;
    }

    for (i = KETA - 2; i >= 0;i--){
        b->n[i + 1] = a->n[i];
    }

    

    b->n[0] = 0;

    return 0;
}


int divBy10(struct NUMBER *a, struct NUMBER *b){
    int i;
    int remainder; 

    clearByZero(b);

    b->sign = a->sign; 

    remainder = a->sign * a->n[0]; 

    for (i = 1; i <= KETA - 2;i++){
        b->n[i - 1] = a->n[i];
    }

    b->n[KETA - 1] = 0;

    return remainder;
}",3,270,935
"double newton(double);
double f(double);
double fdash(double);

int main(int argc, char *argv)
{
    double x;
    double x0;
    int i;

    for (i = -5; i <= 5;i++){
        x0 = (double)i;
        x = newton(x0);
        printf(""x0 = %10.6lf, x = %10.6lf\n"", x0, x); 
    }

    return 0;
}


double newton(double x0) {
    double x; 
    double b; 
    double e; 

    e = 1.e-7;
    x = x0;
    b = x0;

    while(1){
        b = x; 
        x = b - (f(b) / fdash(b));

        if(fabs(x - b) < e){ 
            break;
        }
    }

    return x;
}


double f(double x) {
    return (x * x * x - 9 * x);
}


double fdash(double x) {
    return (3 * x * x - 9.0);
}",3,271,308
"int main()
{
    int fd, pipe_fd[2];
    char buf[140];
    int childpid, status;

    fd = open(""mypipe2.c"", O_RDONLY);
    if (pipe(pipe_fd) == -1) { 
        perror(""pipe"");
        exit(1);
    }

    if ((childpid = fork()) == -1) {
        perror(""Can't fork"");
        exit(1);
    } else {
        if (childpid != 0) { 
            read(fd, buf, sizeof(buf));
            write(pipe_fd[1], buf, sizeof(buf));
            wait(&status);
        } else { 
            read(pipe_fd[0], buf, sizeof(buf));
            write(1, buf, sizeof(buf));
        }
    }
}",3,272,211
"#include ""mulprec.h""

int multiple(struct NUMBER *, struct NUMBER *, struct NUMBER *);

int main(int argc, char **argv)
{
    struct NUMBER a, b, c;
    
    int x, y;
    int i;

    srandom(time(NULL));

    for (i = 0; i < 10;i++){
        x = (random() % 1000);
        y = (random() % 1000);

        setInt(&a, x);
        setInt(&b, y);

        printf(""x = %d\ny = %d\nx * y = %d\n"", x, y, x * y);
        dispNumberZeroSuppress(&a);
        puts("""");
        dispNumberZeroSuppress(&b);
        puts("""");

        multiple(&a, &b, &c);
        setText(&c, x * y);
        checkText();
    }
        

    

    return 0;
}


int multiple(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {
    int i, j, h, e, aj, bi;
    struct NUMBER a_abs, b_abs, d, tmp;

    clearByZero(c);

    if(getSign(a) > 0 && getSign(b) > 0){ 
        for (i = 0; i < KETA;i++){
            bi = b->n[i];
            h = 0;
            clearByZero(&d);
            for (j = 0; j < KETA;j++){
                aj = a->n[j];
                e = aj * bi + h; 
                if(j + i < KETA){ 
                    d.n[j + i] = (e % 10); 
                    e /= 10;
                    h = e; 
                }
                
            }
            if(h != 0){ 
                return -1;
            }
            add(c, &d, &tmp);
            copyNumber(&tmp, c);
        }
    } else if(getSign(a) > 0 && getSign(b) < 0){ 
        getAbs(b, &b_abs);
        multiple(a, &b_abs, c);
        setSign(c, -1);
    } else if(getSign(a) < 0 && getSign(b) > 0){ 
        getAbs(a, &a_abs);
        multiple(&a_abs, b, c);
        setSign(c, -1);
    } else if(getSign(a) < 0 && getSign(b) < 0){ 
        getAbs(a, &a_abs);
        getAbs(b, &b_abs);
        multiple(&a_abs, &b_abs, c);
    }

    return 0; 
}",3,273,723
"int bisection(double, double, double *);
double f(double);
int sgn(double);

int main(int argc, char ** argv)
{
    double a, b; 
    double x; 
    int r; 

    a = 1.0;
    b = 4.0;
    r = bisection(a, b, &x);
    printf(""x = %lf\n"", x);
    printf(""æ»ãå¤ = %d\n"", r);

    return 0;
}


int bisection(double a,double b, double *x) {
    double e; 
    double d; 
    double fx; 
    int as, bs, cs; 

    e = 1.e-7;
    as = sgn(f(a)); 
    bs = sgn(f(b)); 

    if(as == bs){ 
        return -1; 
    }
    
    while(1){
        d = (a + b) / 2.0;
        fx = f(d);
        cs = sgn(fx);
        printf(""now a = %lf\n"", a);
        printf(""now b = %lf\n"", b);
        if(cs == as){
            a = d;
        }
        if(cs == bs){
            b = d;
        }
        if(fx == 0.0){ 
            break;
        }
        if(fabs(a - b) < e){ 
            break;
        }
    }

    *x = d;
    return 0;
}


double f(double x) {
    return (cos(x/2));
}


int sgn(double g) {
    if(g < 0.0){
        return -1;
    }
    if(g > 0.0){
        return 1;
    }
    return 0;
}",3,274,491
"int sqrt_newton(int);

int main(int argc, char **argv)
{
    int i, r, r1, r2, d;

    srandom(time(NULL));

    for (i = 0; i < 10;i++){
        r = random();
        r1 = sqrt_newton(r);
        r2 = (int)sqrt((double)r);
        d = r1 - r2;
        printf(""%6d - %6d = %d\n"", r1, r2, d);
    }

    return 0;
}

int sqrt_newton(int N) {
    int x;
    int b;
    int c;

    x = N / 2;
    if(x == 0){ 
        return N;
    }
    if(x < 0){ 
        return -1;
    }

    b = x;
    c = x;

    while(1){
        c = b;
        b = x;
        x = (b + (N / b)) / 2;

        if(x == b){ 
            break;
        }
        if(x == c){ 
            if(b < x){ 
                x = b;
            }
            break;
        }
    }

    return (x);
}",3,275,332
"#include ""mulprec.h""

int divide(struct NUMBER *, struct NUMBER *, struct NUMBER *, struct NUMBER *);

int main(int argc, char **argv)
{
    struct NUMBER a, b, c, d;
    int return_val;
    int x, y;

    x = 5;
    y = 3;

    setInt(&a, x);
    setInt(&b, y);

    printf(""x = %d\ny = %d\nx / y = %d\nx %% y = %d"", x, y, x / y, x % y);

    return_val = divide(&a, &b, &c, &d);
    dispNumberZeroSuppress(&c);
    dispNumberZeroSuppress(&d);
    printf(""\næ»ãå¤ = %d"", return_val);

    return 0;
}


int divide(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c, struct NUMBER *d) {
    struct NUMBER m, n, p, q;

    clearByZero(c);
    clearByZero(d);

    if(isZero(b) != -1){ 
        return -1;
    }

    copyNumber(a, &n);

    while(1){
        if(numComp(&n, b) != -1){ 
            increment(c, &m);
            copyNumber(&m, c);
            sub(&n, b, &m);
            copyNumber(&m, &n);
        } else { 
            copyNumber(&n, d);
            break;
        }
    }

    return 0;
}",3,276,415
"#include ""mulprec.h""

void tailCall(struct NUMBER *, struct NUMBER *, struct NUMBER *);
int factorial(struct NUMBER *, struct NUMBER *);

int main(int argc, char **argv)
{
    struct NUMBER a, b;
    int return_val;
    int x;

    x = 0;

    setInt(&a, x);

    printf(""x = %d\n"", x);
    return_val = factorial(&a, &b);
    dispNumberZeroSuppress(&b);
    printf(""\næ»ãå¤ = %d"", return_val);

    return 0;
}


void tailCall(struct NUMBER *a, struct NUMBER *b, struct NUMBER *sofar){
    struct NUMBER one, tmp1, tmp2;
    setInt(&one, 1);
    if(numComp(a, &one) != 1){ 
        copyNumber(sofar, b);
    } else {
        multiple(a, sofar, &tmp1);
        decrement(a, &tmp2);
        tailCall(&tmp2, b, &tmp1); 
    }
}


int factorial(struct NUMBER *a, struct NUMBER *b) {
    if(isZero(a) != -1){ 
        setInt(b, 1);
        return 0;
    } else if(getSign(a) == -1){ 
        return -2;
    }

    struct NUMBER one;
    setInt(&one, 1);

    if(numComp(a, &one) == 0){ 
        setInt(b, 1);
        return 0;
    }

    clearByZero(b);

    tailCall(a, b, &one);

    return 0;

}",3,277,456
"#include ""mulprec.h""

int gcd(struct NUMBER *, struct NUMBER *, struct NUMBER *);

int main(int argc, char **argv)
{
    struct NUMBER a, b, c;
    int return_val;
    int x, y;

    x = 1357911;
    y = 246810;

    setInt(&a, x);
    setInt(&b, y);

    return_val = gcd(&a, &b, &c);
    dispNumberZeroSuppress(&c);
    printf(""\næ»ãå¤ = %d"", return_val);

    return 0;
}


int gcd(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {
    struct NUMBER tmp, at, bt;

    getAbs(a, &tmp);
    copyNumber(&tmp, a);
    copyNumber(&tmp, &at);
    getAbs(b, &tmp);
    copyNumber(&tmp, b);
    copyNumber(&tmp, &bt);
    clearByZero(c);

    if(isZero(a) != -1 && isZero(b) != -1){ 
        return 0;
    } else if(isZero(b) != -1) { 
        copyNumber(a, c);
        return 0;
    }

    while(isZero(&tmp) == -1){
        divide(a, b, c, &tmp);
        copyNumber(b, a);
        copyNumber(&tmp, b);
    }

    
    copyNumber(a, c);
    copyNumber(&at, a);
    copyNumber(&bt, b);

    return 0;
}",3,278,434
"#include ""mulprec.h""

int simpleMultiple(int, int, int *);

int main(int argc, char **argv)
{
    int a = -5;
    int b = -3;
    int c, return_val;

    return_val = simpleMultiple(a, b, &c);
    printf(""c = %d\n"",c);
    printf(""æ»ãå¤ = %d"", return_val);

    return 0;
}


int simpleMultiple(int a, int b, int *c) {
    int i = 1;
    int tmp;
    int flag_a = 0; 
    int flag_b = 0; 

    if(a < 0){
        a = abs(a);
        flag_a++;
    } else if(b < 0){
        b = abs(b);
        flag_b++;
    }

    if(a < b){
        tmp = a;
        a = b;
        b = tmp;
    }

    *c = a;

    while(1){
        *c += a;
        i++;

        if(i == b){
            break;
        }
    }

    if(flag_a != 0 && flag_b != 0){
        
    } else if(flag_a != 0){
        *c *= -1;
    } else if(flag_b != 0){
        *c *= -1;
    }

    return 0; 
}",3,279,384
"int doubleSin(double *, double, int);
double factorial(double n) {
    if (n > 0) {
        return n * factorial(n - 1);
    } else {
        return 1;
    }
}

int main(int argc, char **argv)
{
    double a;
    double theta = 1.57;
    int n = 100;
    int return_val;

    return_val = doubleSin(&a, theta, n);
    printf(""a = %f\ntheta = %f\n"", a, theta);
    printf(""sin = %f\n"", sin(theta));
    printf(""æ»ãå¤ = %d"", return_val);

    return 0;
}


int doubleSin(double *a, double theta, int n) {
    int i;

    for (i = 0; i < n;i++){
        
        *a += pow(-1, i) / factorial(2 * i + 1) * pow(theta, 2 * i + 1);
        printf(""now = %f\n"", *a);
    }

    return 0;
}",3,280,300
"int doubleCos(double *, double, int);
double factorial(double n) {
    if (n > 0) {
        return n * factorial(n - 1);
    } else {
        return 1;
    }
}

int main(int argc, char **argv)
{
    double a;
    double theta = 3.14;
    int n = 100;
    int return_val;

    return_val = doubleCos(&a, theta, n);
    printf(""a = %f\ntheta = %f\n"", a, theta);
    printf(""cos = %f\n"", cos(theta));
    printf(""æ»ãå¤ = %d"", return_val);

    return 0;
}


int doubleCos(double *a, double theta, int n) {
    int i;

    for (i = 0; i < n;i++){
        
        *a += pow(-1, i) / factorial(2 * i) * pow(theta, 2 * i);
        
    }

    return 0;
}",3,281,282
"double newton(double);
double f(double);
double fdash(double);

int main(int argc, char *argv)
{
    double x;
    double x0;
    int i;

    for (i = -5; i <= 5;i++){
        x0 = (double)i;
        x = newton(x0);
        printf(""x0 = %10.6lf, x = %10.6lf\n"", x0, x); 
        printf(""f(x) = %10.6lf\n"", f(x));
    }

    return 0;
}


double newton(double x0) {
    double x; 
    double b; 
    double e; 

    e = 1.e-7;
    x = x0;
    b = x0;

    while(1){
        b = x; 
        x = b - (f(b) / fdash(b));
        printf(""now x = %10.6lf\n"", x);

        if(fabs(x - b) < e){ 
            break;
        }
    }

    return x;
}


double f(double x) {
    return (x * x + 4 * x + 5);
}


double fdash(double x) {
    return (2 * x + 4);
}",3,282,347
"void sigint_catcher() { 
    kill(getpid() + 1, SIGINT); 
}

int main()
{
    int i;
    int childpid, status; 
    int pipe_fd[2], pipe_position; 
    int chpid1, chpid2, status1, status2; 
    int pipe_flag = 0; 
    char dirbuf[BUFSIZ]; 
    char arrow[4] = ""> ""; 
    char buf[BUFSIZ]; 
    char **ap, *argv[10], *inputstring;
    getcwd(dirbuf, BUFSIZ); 
    printf(""%s"", dirbuf);   
    printf(""%s"", arrow);
    signal(SIGINT, sigint_catcher); 
    while (fgets(buf, BUFSIZ, stdin) != NULL) { 
        buf[strlen(buf) - 1] = '\0'; 
        inputstring = buf;
        
        for (ap = argv; (*ap = strsep(&inputstring, "" \t"")) != NULL;)
            if (**ap != '\0')
                if (++ap >= &argv[10])
                    break;

        
        i = 0;
        pipe_flag = 0;
        
        while (argv[i] != NULL) {
            if (strcmp(argv[i], ""|"") == 0) { 
                pipe_position = i; 
                argv[i] = '\0'; 
                pipe_flag++; 
                break;
            }
            i++;
        }

        if (strcmp(argv[0], ""k"") == 0) { 
            kill(atoi(argv[1]), SIGINT); 
        } else if (strcmp(argv[0], ""s"") == 0) { 
            kill(atoi(argv[1]), SIGSTOP); 
        } else if (strcmp(argv[0], ""c"") == 0) { 
            kill(atoi(argv[1]), SIGCONT); 
        } else if (strcmp(argv[0], ""cd"") == 0) { 
            if (argv[1] == NULL) { 
                chdir(getenv(""HOME"")); 
            } else {
                chdir(argv[1]); 
            }
        } else if (strcmp(argv[0], ""exit"") == 0) { 
            exit(0); 
        } else {  
            if (pipe_flag != 0) {
                
                if (pipe(pipe_fd) == -1) { 
                    perror(""pipe"");
                    exit(1);
                }
                if ((chpid1 = fork()) == 0) { 
                    
                    close(pipe_fd[0]); 
                    close(1); 
                    dup(pipe_fd[1]); 
                    execvp(argv[0], &argv[0]); 
                    exit(0); 
                } else if ((chpid2 = fork()) == 0) { 
                    
                    close(pipe_fd[1]); 
                    close(0); 
                    dup(pipe_fd[0]); 
                    execvp(argv[pipe_position + 1], &argv[pipe_position + 1]); 
                    exit(0); 
                } else {
                    
                    close(pipe_fd[0]); 
                    close(pipe_fd[1]); 
                    waitpid(chpid1, &status1, 0);    
                    waitpid(chpid2, &status2, 0);    
                    printf(""status1:%04x\n"", status1); 
                    printf(""status2:%04x\n"", status2); 
                }
            } else {
                
                if ((childpid = fork()) == 0) {
                    
                    execvp(argv[0], &argv[0]); 
                    exit(0); 
                } else {
                    
                    wait(&status); 
                    printf(""status:%04x\n"", status); 
                }
            }
        }
        getcwd(dirbuf, BUFSIZ); 
        printf(""%s"", dirbuf);   
        printf(""%s"", arrow);
    }
}",3,283,1050
"#include ""mulprec.h""

int curt(struct NUMBER *, struct NUMBER *);



        
        multiple(&ox, &two, &dx); 
        

int main(int argc, char **argv)
{
    struct NUMBER r1, ans, tmp;
    int j, r;
    

    srandom(time(NULL));

    r = 27;
    setInt(&r1, r);
    
    curt(&r1, &ans);
    printf(""r:%d\nr1:"", r);
    dispNumberZeroSuppress(&ans);
    puts("""");

    

    return 0;
}


int curt(struct NUMBER *a, struct NUMBER *b) {
    struct NUMBER x, ox, tx, px, dx, zero, one, two, three, quotient, sum, rest; 
    setInt(&zero, 0);
    setInt(&one, 1);
    setInt(&two, 2);
    setInt(&three, 3);

    quickDivide(a, &two, &x, &rest);
    if(isZero(&x) != -1 || numComp(&x, &one) == 0){ 
        copyNumber(a, b);
        return 0;
    }
    if (numComp(&x, &zero) == -1){ 
        return -1;
    }

    copyNumber(&x, &ox);

    while(1){
        copyNumber(&ox, &tx); 
        copyNumber(&x, &ox); 
        power(&ox, &two, &px); 
        quickDivide(a, &px, &quotient, &rest);
        multiple(&ox, &two, &dx); 
        add(&dx, &quotient, &sum);
        quickDivide(&sum, &three, &x, &rest);

        if(numComp(&x, &ox) == 0){ 
            break;
        }
        if(numComp(&x, &tx) == 0){ 
            if(numComp(&ox, &x) == -1){ 
                copyNumber(&ox, &x);
            }
            break;
        }
    }

    copyNumber(&x, b);
    return 0;
}",3,284,557
"#include ""mulprec.h""

int increment(struct NUMBER *, struct NUMBER *);

int main(int argc, char **argv)
{
    struct NUMBER a, b;
    int return_val;

    setInt(&a, 1);

    return_val = increment(&a, &b);
    dispNumberZeroSuppress(&a);
    dispNumberZeroSuppress(&b);
    printf(""\næ»ãå¤ = %d"", return_val);

    return 0;
}


int increment(struct NUMBER *a, struct NUMBER *b) {
    struct NUMBER one;
    int r;

    setInt(&one, 1);
    r = add(a, &one, b);

    return r;
}",3,285,195
"#include ""mulprec.h""

int decrement(struct NUMBER *, struct NUMBER *);

int main(int argc, char **argv)
{
    struct NUMBER a, b;
    int return_val;

    setInt(&a, 1);

    return_val = decrement(&a, &b);
    dispNumberZeroSuppress(&a);
    dispNumberZeroSuppress(&b);
    printf(""\næ»ãå¤ = %d"", return_val);

    return 0;
}


int decrement(struct NUMBER *a, struct NUMBER *b) {
    struct NUMBER one;
    int r;

    setInt(&one, 1);
    r = sub(a, &one, b);

    return r;
}",3,286,198
"#include ""mulprec.h""

int isPrime(struct NUMBER *);

int main(int argc, char **argv)
{
    struct NUMBER a, b, c;
    int return_val;
    int x, y;

    x = 1357911;
    y = 246810;

    setInt(&a, x);
    setInt(&b, y);

    return_val = gcd(&a, &b, &c);
    dispNumberZeroSuppress(&c);
    printf(""\næ»ãå¤ = %d"", return_val);

    return 0;
}


int isPrime(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {
    struct NUMBER tmp;
    
}",3,287,204
"#include ""mulprec.h""

int main(int argc, char **argv)
{
    struct NUMBER a, b, c, d, e;
    int r;     

    srandom(time(NULL)); 

    clearByZero(&a); 
    printf(""a = ""); 
    dispNumberZeroSuppress(&a);
    printf(""\n"");

    setRnd(&b, 10); 
    printf(""b = ""); 
    dispNumberZeroSuppress(&b);
    printf(""\n"");

    copyNumber(&b, &c); 
    printf(""c = ""); 
    dispNumberZeroSuppress(&c);
    printf(""\n"");

    r = mulBy10(&b, &d); 
    printf(""b * 10 = ""); 
    dispNumberZeroSuppress(&d);
    printf("", r = %d\n"", r);

    r = divBy10(&c, &e); 
    printf(""c / 10 = ""); 
    dispNumberZeroSuppress(&e);
    printf("", r = %d\n"", r);

    printf(""a == 0? --> %d\n"", isZero(&a)); 
    printf(""b == 0? --> %d\n"", isZero(&b));
    printf(""c == 0? --> %d\n"", isZero(&c));
    printf(""d == 0? --> %d\n"", isZero(&d));
    printf(""e == 0? --> %d\n"", isZero(&e));

    return (0);
}",3,288,376
"#include ""mulprec.h""

int factorial(struct NUMBER *, struct NUMBER *);

int main(int argc, char **argv)
{
    struct NUMBER a, b;
    int return_val;
    int x;

    x = 5;

    setInt(&a, x);

    return_val = factorial(&a, &b);
    dispNumberZeroSuppress(&b);
    printf(""\næ»ãå¤ = %d"", return_val);

    return 0;
}


int factorial(struct NUMBER *a, struct NUMBER *b) {
    
    if(getSign(a) == -1){ 
        return -2;
    }

    struct NUMBER tmp1, tmp2, num;
    setInt(&num, 1);
    int flag = 0;

    clearByZero(b);

    while(1){
        if(flag == 0){
            flag++;
            increment(&num, &tmp1);
            multiple(&num, &tmp, b);
            copyNumber(&tmp, &num);
        } else {
            increment(&num, &tmp1);
            multiple(b, &tmp1, &tmp2);
            copyNumber(&tmp2, b);
        }

        if(numComp(&tmp1, a) == 0){ 
            break;
        }
    }

    return 0;

    
        
    
}",3,289,359
"void sigint_catcher() { 
    kill(getpid() + 1, SIGINT); 
}

int main()
{
    int i;
    int childpid;
    int status;
    char buf[BUFSIZ];
    char dirbuf[BUFSIZ];
    char arrow[4] = ""> ""; 
    char **ap, *argv[10], *inputstring;
    getcwd(dirbuf, BUFSIZ); 
    printf(""%s"", dirbuf);   
    printf(""%s"", arrow);
    signal(SIGINT, sigint_catcher); 
    while (fgets(buf, BUFSIZ, stdin) != NULL) {
        buf[strlen(buf) - 1] = '\0'; 
        inputstring = buf;
        
        for (ap = argv; (*ap = strsep(&inputstring, "" \t"")) != NULL;)
            if (**ap != '\0')
                if (++ap >= &argv[10])
                    break;
        
        if (strcmp(argv[0], ""k"") == 0) { 
            kill(atoi(argv[1]), SIGINT); 
        } else if (strcmp(argv[0], ""s"") == 0) { 
            kill(atoi(argv[1]), SIGSTOP); 
        } else if (strcmp(argv[0], ""c"") == 0) { 
            kill(atoi(argv[1]), SIGCONT); 
        } else if (strcmp(argv[0], ""cd"") == 0) { 
            if (argv[1] == NULL) { 
                chdir(getenv(""HOME"")); 
            } else {
                chdir(argv[1]); 
            }
        } else if (strcmp(argv[0], ""exit"") == 0) { 
            exit(0); 
        } else if ((childpid = fork()) == 0) { 
            
            execv(argv[0], argv); 
            exit(0); 
        } else {
            
            wait(&status); 
            printf(""status:%04x\n"", status); 
        }
        getcwd(dirbuf, BUFSIZ); 
        printf(""%s"", dirbuf);   
        printf(""%s"", arrow);
    }
}",3,290,568
"int doubleLog(double *, double, int);

int main(int argc, char **argv)
{
    double a;
    double x = 4.0;
    int n = 1000;
    int return_val;

    return_val = doubleLog(&a, x, n);
    printf(""a = %f\nx = %f\n"", a, x);
    printf(""log = %f\n"", log(x));
    printf(""æ»ãå¤ = %d"", return_val);

    return 0;
}


int doubleLog(double *a, double x, int n) {
    int i;

    for (i = 0; i < n;i++){
        
        *a += 2 / (2 * i + 1) * pow((x - 1) / (x + 1), 2 * i + 1);
        
    }

    return 0;
}",3,291,236
"#include ""mulprec.h""

int simpleDivide(int, int, int *, int *);

int main(int argc, char **argv)
{
    int a = 7;
    int b = -3;
    int c, d, return_val;

    return_val = simpleDivide(a, b, &c, &d);
    printf(""c = %d\n"", c);
    printf(""d = %d\n"", d);
    printf(""æ»ãå¤ = %d"", return_val);

    return 0;
}


int simpleDivide(int x, int y, int * z, int * w){
    int k;
    int x_abs, y_abs;

    if(y == 0){
        return -1;
    }

    if(x == 0){
        z = 0;
        w = 0;
        return 0;
    }
    
    if(x > 0 && y > 0){
        k = 0;
        while(1){
            if(x < y){
                break;
            }
            x -= y;
            k++;
        }
        *z = k; 
        *w = x; 
    } else if(x > 0 && y < 0){
        y_abs = abs(y);
        simpleDivide(x, y_abs, z, w);
        *z *= -1;
        *w *= -1;
    } else if(x < 0 && y > 0){
        x_abs = abs(x);
        simpleDivide(x_abs, y, z, w);
        *z *= -1;
        *w *= -1;
    } else {
        x_abs = abs(x);
        y_abs = abs(y);
        simpleDivide(x_abs, y_abs, z, w);
    }

    return 0;
}",3,292,484
"void sigint_catcher() { 
    kill(getpid() + 1, SIGINT); 
}

int main()
{
    int i;
    int childpid, status; 
    int fd, pipe_fd[2]; 
    int chpid1, chpid2, status1, status2; 
    int pipe_flag = 0; 
    char dirbuf[BUFSIZ]; 
    char arrow[4] = ""> ""; 
    char buf[BUFSIZ]; 
    char **ap, *argv[10], *inputstring;
    getcwd(dirbuf, BUFSIZ); 
    printf(""%s"", dirbuf);   
    printf(""%s"", arrow);
    signal(SIGINT, sigint_catcher); 
    while (fgets(buf, BUFSIZ, stdin) != NULL) { 
        buf[strlen(buf) - 1] = '\0'; 
        inputstring = buf;
        
        for (ap = argv; (*ap = strsep(&inputstring, "" \t"")) != NULL;)
            if (**ap != '\0')
                if (++ap >= &argv[10])
                    break;

        
        i = 0;
        pipe_flag = 0;
        
        while (argv[i] != NULL) {
            puts(""me"");
            if (strcmp(argv[i], ""|"") == 0) { 
            puts(""neko"");
                argv[i] = '\0'; 
                pipe_flag++; 
                break;
            }
            i++;
        }

        if (strcmp(argv[0], ""k"") == 0) { 
            kill(atoi(argv[1]), SIGINT); 
        } else if (strcmp(argv[0], ""s"") == 0) { 
            kill(atoi(argv[1]), SIGSTOP); 
        } else if (strcmp(argv[0], ""c"") == 0) { 
            kill(atoi(argv[1]), SIGCONT); 
        } else if (strcmp(argv[0], ""cd"") == 0) { 
            if (argv[1] == NULL) { 
                chdir(getenv(""HOME"")); 
            } else {
                chdir(argv[1]); 
            }
        } else if (strcmp(argv[0], ""exit"") == 0) { 
            exit(0); 
        } else {  
            if (pipe_flag != 0) {
                
                puts(""me!"");
                pipe_flag = 0;
                for (i = 0; i < 10; i++) {
                    if (argv[i] == NULL && pipe_flag != 0) {
                        exit(0); 
                    } else if (argv[i] == NULL) {
                        pipe_flag++; 
                        printf(""\n"");
                    } else {
                        printf(""argv[%d]: %s\n"", i, argv[i]);
                    }
                }
            } else {
                
                if ((childpid = fork()) == 0) {
                    
                    execvp(argv[0], &argv[0]); 
                    exit(0); 
                } else {
                    
                    wait(&status); 
                    printf(""status:%04x\n"", status); 
                }
            }
        }
        getcwd(dirbuf, BUFSIZ); 
        printf(""%s"", dirbuf);   
        printf(""%s"", arrow);
    }
}",3,293,874
"#include ""mulprec.h""

int multiple(struct NUMBER *, struct NUMBER *, struct NUMBER *);

int main(int argc, char **argv)
{
    struct NUMBER a, b, c;
    int return_val;
int x, y;

    x = 16;
    y = 16;

    setInt(&a, x);
    setInt(&b, y);

    printf(""x = %d\ny = %d\nx * y = %d\n"", x, y, x * y);

    return_val = multiple(&a, &b, &c);
    printf(""\n"");
    dispNumberZeroSuppress(&c);
    printf(""\næ»ãå¤ = %d"", return_val);

    return 0;
}


int multiple(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {
    int i, j, h, e, aj, bi;
    struct NUMBER tmp, d;
    
    

    clearByZero(c);
    dispNumberZeroSuppress(a);
    dispNumberZeroSuppress(b);

    for (i = 0; i < KETA;i++){
        printf(""iã¯ããã§ãã%d\n"", i);
        bi = b->n[i];
        h = 0;
        clearByZero(&d);
        for (j = 0; j < KETA;j++){
            aj = a->n[j];
            printf(""aj:%d\nbi%d\n"", aj, bi);
            
            
            
            
            
            e = aj * bi + h; 
            printf(""e:%d\n"", e); 
            if(j + i < KETA){
                d.n[j + i] = (e % 10); 
                printf(""dl:"");
                dispNumberZeroSuppress(&d);
                puts("""");
                e /= 10;
                h = e; 
            }
        }

        if(h != 0){ 
            return -1;
        }
        printf(""c:"");
        dispNumberZeroSuppress(c);
        printf(""d:"");
        dispNumberZeroSuppress(&d);
        puts("""");
        add(c, &d, &tmp);
        copyNumber(&tmp, c);
    }

    

    return 0; 
}",3,294,608
"void sigint_catcher() { 
    printf(""-----SIGINT was sent to the childprocess!-----\n"");
    kill(getpid() + 1, SIGINT); 
}

int main()
{
    int i;
    int childpid;
    int status;
    char buf[BUFSIZ];
    char prompt[16] = ""prompt> "";
    char **ap, *argv[10], *inputstring;
    printf(""%s"", prompt);
    signal(SIGINT, sigint_catcher); 
    while (fgets(buf, BUFSIZ, stdin) != NULL) {
        buf[strlen(buf) - 1] = '\0'; 
        inputstring = buf;
        
        for (ap = argv; (*ap = strsep(&inputstring, "" \t"")) != NULL;)
            if (**ap != '\0')
                if (++ap >= &argv[10])
                    break;
        
        if ((childpid = fork()) == 0) { 
            
            execv(argv[0], argv); 
            exit(0); 
        } else {
            
            wait(&status); 
            printf(""status:%04x\n"", status); 
        }
        printf(""%s"", prompt);
    }
}",3,295,318
"#include ""mulprec.h""

int numComp(struct NUMBER *, struct NUMBER *);

int main(int argc, char **argv)
{
    struct NUMBER a, b;
    int return_val;

    srandom(time(NULL));

    clearByZero(&a);
    clearByZero(&b);

    return_val = numComp(&a, &b);
    printf(""æ»ãå¤ = %d"", return_val);

    setInt(&b, -1);
    return_val = numComp(&a, &b);
    printf(""æ»ãå¤ = %d"", return_val);

    setInt(&a, -1);
    return_val = numComp(&a, &b);
    printf(""æ»ãå¤ = %d"", return_val);

    return 0;
}


int numComp(struct NUMBER *a, struct NUMBER *b) {
    int sa = getSign(a);
    int sb = getSign(b);
    int i;

    if(sa > sb){ 
        return 1;
    }

    if(sa < sb){ 
        return -1;
    }

    if(sa == 1 && sb == 1){ 
        for (i = KETA - 1; i >= 0;i--){
            if(a->n[i] > b->n[i]){ 
                return 1;
            } else if(a->n[i] < b->n[i]){
                return -1;
            }
        }

        return 0; 
    }

    if(sa == -1 && sb == -1){ 
        for (i = KETA - 1; i >= 0;i--){
            if(a->n[i] > b->n[i]){ 
                return -1;
            } else if(a->n[i] < b->n[i]){
                return 1;
            }
        }

        return 0; 
    }

    
    return 100;
}",3,296,531
"int main() {
    
while(1){
    int n, i, flag = 0;
    printf(""Enter a positive integer: "");
    scanf(""%d"", &n);

    for (i = 2; i <= n / 2; ++i) {

        
        if (n % i == 0) {
            flag = 1;
            break;
        }
    }

    if (n == 1) {
        printf(""1 is neither prime nor composite."");
    }
    else {
        if (flag == 0)
            printf(""%d is a prime number.\n"", n);
        else
            printf(""%d is not a prime number.\n"", n);
    }

    }
}",4,297,175
"int main()
{
    int num;
    int count_sevens = 0;
    int units;

    printf(""Enter A Number : "");
    scanf(""%d"" , &num);

    while(num != 0)
    {
        units = abs(num % 10);                                          
        if(units == 7)                                                  
            count_sevens++;                                             

        num /= 10;                                                      
    }

    printf(""\nNumber Of Sevens = %d\n"" , count_sevens);

    return 0;
}
",4,298,148
"int IsPalindrome( int num );
int ReverseNum( int num );

int main()
{
    int num;

    printf(""Enter A Number : "");
    scanf(""%d"" , &num);

    if(IsPalindrome( num ))
        printf(""\n%d Is Palindrome!!\n"" , num );
    else
        printf(""\n%d Is Not Palindrome!!\n"" , num );

    return 0;
}

int IsPalindrome( int num )
{
    int reversed_num = ReverseNum( num );
    return reversed_num == num;
}

int ReverseNum( int num )
{
    int reversed_num = 0;

    while(num != 0)
    {
        reversed_num = reversed_num * 10 + num % 10;
        num /= 10;
    }
    return reversed_num;
}
",4,299,233
"int main()
{
    int number,cnt,i;
    char    hex[32];    
 
    printf(""Enter decimal number: "");
    scanf(""%d"",&number);
 
     
    cnt=0;              
    while(number>0)
    {
        switch(number%16)
        {
            case 10:
                hex[cnt]='A'; break;
            case 11:
                hex[cnt]='B'; break;
            case 12:
                hex[cnt]='C'; break;
            case 13:
                hex[cnt]='D'; break;
            case 14:
                hex[cnt]='E'; break;
            case 15:
                hex[cnt]='F'; break;
            default:
                hex[cnt]=(number%16)+0x30;  
        }
        number=number/16;
        cnt++;
    }
 
    
    printf(""Hexadecimal value is: "");
    for(i=(cnt-1); i>=0;i--)
        printf(""%c"",hex[i]);
 
    return 0;
}",4,300,284
"int main() {


while(1){
   int num, originalNum, remainder, n = 0;
   float result = 0.0;

   printf(""Enter an integer: "");
   scanf(""%d"", &num);

   originalNum = num;

   
   for (originalNum = num; originalNum != 0; ++n) {
       originalNum /= 10;
   }
   
   for (originalNum = num; originalNum != 0; originalNum /= 10) {
       remainder = originalNum % 10;

      
      result += pow(remainder, n);
   }

   
   if ((int)result == num)
    printf(""%d is an Armstrong number."", num);
   else
    printf(""%d is not an Armstrong number.\n"", num);

    }
}",4,301,205
"unsigned int My_strlen( char string[] , int size );


int main()
{
    char my_string[ 100 ];

    printf(""Enter Your String : "");
    scanf(""%99[^\n]s"" , my_string);

    printf(""\nLength Of Your String Is : %u\n"" , My_strlen( my_string , sizeof(my_string)/sizeof(char) ));

    return 0;
}

unsigned int My_strlen( char string[] , int size )
{
    for(int i = 0;i < size;i++)
        if(string[ i ] == '\0')                                 
            return i;
}
",4,302,167
"int main()
{
    char hex[32]={0};
    int  dec,i;
    int  cnt;   
    int  dig;   
 
    printf(""Enter hex value: "");
    gets(hex);
 
    cnt=0;
    dec=0;
    for(i=(strlen(hex)-1);i>=0;i--)
    {
        switch(hex[i])
        {
            case 'A':
                dig=10; break;
            case 'B':
                dig=11; break;
            case 'C':
                dig=12; break;
            case 'D':
                dig=13; break;
            case 'E':
                dig=14; break;
            case 'F':
                dig=15; break;
            default:
                dig=hex[i]-0x30;
        }
        dec= dec+ (dig)*pow((double)16,(double)cnt);
        cnt++;
    }
 
    printf(""DECIMAL value is: %d"",dec);
    return 0;
}",4,303,270
"int BinaryToDecimal( int binary );

int main()
{
    int binary;

    printf(""Enter Number In Binary Form : "");
    scanf(""%d"" , &binary);

    printf(""\nNumber = %d\n"" , BinaryToDecimal( binary ) );

    return 0;
}


int BinaryToDecimal( int binary )
{
    int PowerOfTwo = 1;
    int decimal = 0;

    while(binary != 0)
    {
        decimal += (binary % 10) * PowerOfTwo;                  
        binary /= 10;
        PowerOfTwo = PowerOfTwo << 1;                           
    }
    return decimal;
}
",4,304,170
"int main()
{
    int     number,cnt,i;
    int     oct[32];
 
    printf(""Enter decimal number: "");
    scanf(""%d"",&number);
 
     
    cnt=0;              
    while(number>0)
    {
        oct[cnt]=number%8;
        number=number/8;
        cnt++;
    }
 
    
    printf(""Octal value is: "");
    for(i=(cnt-1); i>=0;i--)
        printf(""%d"",oct[i]);
 
    return 0;
}",4,305,145
"int main(){
int m,p,s,p1;
int m1[4],i,f,f1=0,f2=0,fra1,fra2,s1,pos; 

printf(""\nEnter the memory size:""); scanf(""%d"",&m);
printf(""\nEnter the no of partitions:""); scanf(""%d"",&p);
s=m/p;
printf(""\nEach partn size is:%d"",s); printf(""\nEnter the no of processes:""); scanf(""%d"",&p1);
pos=m;
for(i=0;i<p1;i++)
{
if(pos<s)
{
printf(""\nThere is no further memory for process%d"",i+1); m1[i]=0;
break;
}
else
{
printf(""\nEnter the memory req for process%d:"",i+1); scanf(""%d"",&m1[i]);
if(m1[i]<=s)
{
printf(""\nProcess is allocated in partition%d"",i+1); fra1=s-m1[i];
printf(""\nInternal fragmentation for process is:%d"",fra1); f1=f1+fra1;
pos=pos-s;
}
else
{
printf(""\nProcess not allocated in partition%d"",i+1); s1=m1[i];
while(s1>s)
{
s1=s1-s;pos=pos-s;
}
pos=pos-s;fra2=s-s1;f2=f2+fra2;
printf(""\nExternal Fragmentation for this process is:%d"",fra2);
}
}
}
20;
printf(""\nProcess\tAllocated Memory"");
for(i=0;i<p1;i++)
printf(""\n%5d\t%5d"",i+1,m1[i]);
f=f1+f2;
printf(""\nThe tot no of fragmentation is:%d"",f); getch();
return 0;
}
",5,306,480
"void main(){
    int  r_string[100],n,f,pf=0,count=0,m[10],i, j, k,;
    printf(""Enter the length of reference string:"");
    scanf(""%d"",&n);
    printf(""Enter the reference string:"");
    for(i=0;i<n;i++)
        scanf(""%d"",&r_string[i]);
    printf(""Enter no. of frames:"");
    scanf(""%d"",&f);
    for(i=0;i<f;i++)
        m[i]=-1;
    printf(""The Page Replacement Process is:\n"");
    for(i=0;i<n;i++){
        for(k=0;k<f;k++){
            if(m[k]==r_string[i])
                break;
        }
        if(k==f){
            m[count++]=r_string[i];
            pf++;
        }
        for(j=0;j<f;j++)
            printf(""\t%d"",m[j]);
        if(k==f)
            printf(""\tPF No. %d\n"",pf);
        if(count==f)
            count=0;
    }
    printf(""\n The number of Page Faults using FIFO are %d"",pf);
}
",5,307,325
"struct pstruct {
    int fno;
    int pbit;
}ptable[10];
int pmsize,lmsize,psize,no_of_frames,no_of_pages,ftable[20],frameno;
void info(){
    printf(""Enter the Size of Physical memory: "");
    scanf(""%d"",&pmsize);
    printf(""Enter the size of Logical memory: "");
    scanf(""%d"",&lmsize);
    printf(""Enter the partition size: "");
    scanf(""%d"",&psize);
    no_of_frames=pmsize/psize;
    no_of_pages=lmsize/psize;
    printf(""The physical memory is divided into %d no.of frames\n"",no_of_frames);
    printf(""The Logical memory is divided into %d no.of pages\n"",no_of_pages);
}
void assign(){
    int i;
    for (i=0;i<no_of_pages;i++){
        ptable[i].fno = -1;
        ptable[i].pbit= -1;
    }
    for(i=0; i<no_of_frames;i++)
        ftable[i] = 32555;
    for (i=0;i<no_of_pages;i++){
        printf(""Enter the Frame number where page %d must be placed: "",i);
        scanf(""%d"",&frameno);
        ftable[frameno] = i;
        if(ptable[i].pbit == -1){
            ptable[i].fno = frameno;
            ptable[i].pbit = 1;
        }
    }
    printf(""\n\nPAGE TABLE\n\n"");
    printf(""PageAddress FrameNo. PresenceBit\n\n"");
    for (i=0;i<no_of_pages;i++)
        printf(""%d\t\t%d\t\t%d\n"",i,ptable[i].fno,ptable[i].pbit);
    printf(""\n\nFRAME TABLE\n\n"");
    printf(""FrameAddress PageNo\n\n"");
    for(i=0;i<no_of_frames;i++)
        printf(""%d\t\t%d\n"",i,ftable[i]);
}

void cphyaddr(){
    int log_add,paddr,disp,phy_add,base_add;
    printf(""Enter the Base Address: "");
    scanf(""%d"",&base_add);
    printf(""Enter the Logical Address: "");
    scanf(""%d"",&log_add);
    paddr = log_add / psize;
    disp = log_add % psize;
    if(ptable[paddr].pbit == 1 )
        phy_add = base_add + (ptable[paddr].fno*psize) + disp;
    printf(""\nThe Physical Address where the instruction present: %d"",phy_add);
}
void main(){
    info();
    assign();
    cphyaddr();
}",5,308,755
"void main()
{
int et[20],at[10],n,i,j,temp,p[10],st[10],ft[10],wt[10],ta[10]; int totwt=0,totta=0;
float awt,ata;
char pn[10][10],t[10]; clrscr();
printf(""Enter the number of process:""); scanf(""%d"",&n);
for(i=0;i<n;i++)
{
printf(""Enter process name,arrivaltime,execution time & priority:""); flushall();
scanf(""%s%d%d%d"",pn[i],&at[i],&et[i],&p[i]);
}
for(i=0;i<n;i++)
for(j=0;j<n;j++)
{
if(p[i]<p[j])
{
temp=p[i];
p[i]=p[j];
p[j]=temp;
temp=at[i];
at[i]=at[j];
at[j]=temp;
temp=et[i];
et[i]=et[j];
et[j]=temp;
strcpy(t,pn[i]);
strcpy(pn[i],pn[j]);
strcpy(pn[j],t);
}
}
for(i=0;i<n;i++)
{
if(i==0)
{
st[i]=at[i];wt[i]=st[i]-at[i];ft[i]=st[i]+et[i];ta[i]=ft[i]-at[i];
}
else
{
st[i]=ft[i-1];wt[i]=st[i]-at[i];ft[i]=st[i]+et[i];ta[i]=ft[i]-at[i];
}
totwt+=wt[i];
totta+=ta[i];
}
awt=(float)totwt/n;
ata=(float)totta/n;
printf(""\nPname\tarrivaltime\texecutiontime\tpriority\twaitingtime\ttatime"");
12
for(i=0;i<n;i++)
printf(""\n%s\t%5d\t\t%5d\t\t%5d\t\t%5d\t\t%5d"",pn[i],at[i],et[i],p[i],wt[i],ta[i]);
printf(""\nAverage waiting time is:%f"",awt);
printf(""\nAverage turnaroundtime is:%f"",ata); getch();
}",5,309,629
"void main(){
int et[30],ts,n,i,x=0,tot=0; char pn[10][10];
printf(""Enter the no of processes:""); scanf(""%d"",&n);
printf(""Enter the time quantum:""); scanf(""%d"",&ts); for(i=0;i<n;i++)
{
printf(""enter process name & estimated time:""); scanf(""%s %d"",pn[i],&et[i]);
}
printf(""The processes are:""); for(i=0;i<n;i++)
printf(""process %d: %s\n"",i+1,pn[i]); for(i=0;i<n;i++)
tot=tot+et[i];
while(x!=tot)
{
for(i=0;i<n;i++)
{
if(et[i]>ts)
{
x=x+ts;
printf(""\n %s -> %d"",pn[i],ts);
et[i]=et[i]-ts;
}
else if((et[i]<=ts)&&et[i]!=0)
{
x=x+et[i];
printf(""\n %s -> %d"",pn[i],et[i]); et[i]=0;}
}
}
printf(""\n Total Estimated Time:%d"",x); getch();
}
",5,310,324
"int max[100][100];
int alloc[100][100];
int need[100][100];
int avail[100];
int n,r;
void input();
void show();
void cal();
int main()
{
int i,j;
printf(""********** Deadlock Detection Algo ************\n"");
input();
show();
cal();
getch();
return 0;
}
void input()
{
int i,j;
printf(""Enter the no of Processes\t"");
scanf(""%d"",&n);
printf(""Enter the no of resource instances\t"");
scanf(""%d"",&r);
printf(""Enter the Max Matrix\n"");
for(i=0;i<n;i++)
{
for(j=0;j<r;j++)
{
scanf(""%d"",&max[i][j]);
}
}
 printf(""Enter the Allocation Matrix\n"");
 for(i=0;i<n;i++)
 {
for(j=0;j<r;j++)
{
scanf(""%d"",&alloc[i][j]);
}
 }
 printf(""Enter the available Resources\n"");
 for(j=0;j<r;j++)
 {
 scanf(""%d"",&avail[j]);
 }
46;
}
void show()
{
int i,j;
printf(""Process\t Allocation\t Max\t Available\t"");
for(i=0;i<n;i++)
 {
 printf(""\nP%d\t "",i+1);
 for(j=0;j<r;j++)
 {
 printf(""%d "",alloc[i][j]);
 }
 printf(""\t"");
 for(j=0;j<r;j++)
 {
 printf(""%d "",max[i][j]);
 }
 printf(""\t"");
 if(i==0)
 {
 for(j=0;j<r;j++)
 printf(""%d "",avail[j]);
 }
 }
}
void cal()
{
 int finish[100],temp,need[100][100],flag=1,k,c1=0;
 int dead[100];
 int safe[100];
 int i,j;
 for(i=0;i<n;i++)
 {
 finish[i]=0;
 }
 
 for(i=0;i<n;i++)
 {
 for(j=0;j<r;j++)
 {
 need[i][j]=max[i][j]-alloc[i][j];
 }
 }
 while(flag)
 {
 flag=0;
 for(i=0;i<n;i++)
 {
 int c=0;
 for(j=0;j<r;j++)
47;
{
if((finish[i]==0)&&(need[i][j]<=avail[j]))
{
c++;
 if(c==r)
{
 for(k=0;k<r;k++)
 {
 avail[k]+=alloc[i][j];
 finish[i]=1;
 flag=1;
 }

if(finish[i]==1)
 {
i=n;
}}}}}}
 j=0;
 flag=0;
 for(i=0;i<n;i++)
 {
 if(finish[i]==0)
 {
 dead[j]=i;
 j++;
 flag=1;
 }
 }
 if(flag==1)
 {
 printf(""\n\nSystem is in Deadlock and the Deadlock process are\n"");
 for(i=0;i<n;i++)
 {
 printf(""P%d\t"",dead[i]);
 }
 }
 else
 {
 printf(""\nNo Deadlock Occur"");
 }
}
",5,311,920
"void main(){
    int memory_size,page_size;
    printf(""Enter Memory Size:"");
    scanf(""%d"",&memory_size);
    printf(""Enter Page Size:"");
    scanf(""%d"",&page_size);
    int n=memory_size/page_size;
    printf(""No.of Pages available=%d\n"",n);
    
    int m[n],i,j;
    for(i=0;i<n;i++){
        m[i]=0;
    }
    
    int p;
    printf(""\nEnter No.of Processes:"");
    scanf(""%d"",&p);
    int rem_pages=n;
    int req_pages,process_size;
    
    for(i=0;i<p;i++){
        printf(""Enter Process %d size:"",i+1);
        scanf(""%d"",&process_size);
        req_pages=(process_size/page_size);
        if(process_size%page_size!=0) req_pages++;
        if(req_pages>rem_pages){
            printf(""Memory is lower than asked"");
            continue;
        }
        int temp[req_pages];
        printf(""Enter %d page numbers that are to be assigned to process %d:"",req_pages,i+1);
        for(j=0;j<req_pages;j++){
            scanf(""%d"",&temp[j]);
        }
        for(j=0;j<req_pages;j++){
            if(m[temp[j]]!=0){
                printf(""Page %d is already allocated"",temp[j]);
                break;
            }
            m[temp[j]]=i+1;
            rem_pages--;
        }
    }
    
    printf(""Main Memory:\n"");
    printf(""------------\n"");
    for(i=0;i<n;i++){
        if(m[i]==0)
            printf(""\tframe %d -- EMPTY\n"",i);
        else    
            printf(""\tframe %d -- process %d\n"",i,m[i]);
    }
}
",5,312,515
"main()
{
int f[50],i,st,j,len,c,k;

for(i=0;i<50;i++)
f[i]=0;
X:
printf(""\n Enter the starting block & length of file"");
scanf(""%d%d"",&st,&len);
for(j=st;j<(st+len);j++)
if(f[j]==0)
{
f[j]=1;
printf(""\n%d->%d"",j,f[j]);
}
else
{
printf(""Block already allocated"");
break;
}
if(j==(st+len))
printf(""\n the file is allocated to disk"");
printf(""\n if u want to enter more files?(y-1/n-0)"");
scanf(""%d"",&c);
if(c==1)
goto X;
else
close();
getch();
}
",5,313,218
"struct filestructure{
    char name[20];
    int starting_block;
    int no_of_blocks;
}file[20];
int i,j,disk[512];
int n;

void main(){
    for(i=0;i<512;i++)
        disk[i]=0;
        int x,y,flag=0;
    printf(""Enter no.of files:"");
    scanf(""%d"",&n);
    for(i=0;i<n;i++){
        printf(""Enter File Name:"");
        scanf(""%s"",file[i].name);
        printf(""Enter Starting Index:"");
        scanf(""%d"",&file[i].starting_block);
        printf(""Enter Size of Block:"");
        scanf(""%d"",&file[i].no_of_blocks);
        x=file[i].starting_block;
        y=file[i].no_of_blocks;
        for(j=x;j<x+y;j++){
            if(disk[j]==1){
                printf(""Sequencial Allocation is not possible\n"");
                flag=1;
                break;
            }
        }
        if(flag==0){
            for(j=x;j<x+y;j++){
                disk[j]=1;
            }
            printf(""Allocation is done sequentially\n"");
        }
    }
}
",5,314,349
"void main(){
int g=0,a[5],b[20],p=0,q=0,m=0,h,k,i,q1=1,j,u,n; char f='F';

printf(""Enter the number of pages:""); scanf(""%d"",&n);
printf(""Enter %d Page Numbers:"",n); for(i=0;i<n;i++)
scanf(""%d"",&b[i]);
for(i=0;i<n;i++)
{if(p==0)
{
if(q>=3)
q=0;
a[q]=b[i];
q++;
if(q1<3)
{
q1=q;

}
}
printf(""\n%d"",b[i]);
printf(""\t"");
for(h=0;h<q1;h++)
printf(""%d"",a[h]);
if((p==0)&&(q<=3))
{
printf(""-->%c"",f);m++;
}
p=0;
g=0;
if(q1==3)
{
for(k=0;k<q1;k++)
54;
{
if(b[i+1]==a[k])
p=1;
}
for(j=0;j<q1;j++)
{
u=0;
k=i;while(k>=(i-1)&&(k>=0))
{
if(b[k]==a[j])
u++;k--;
}
if(u==0)
q=j;
}
}
else
{
for(k=0;k<q;k++)
{
if(b[i+1]==a[k])
p=1;
}
}
}
printf(""\nNo of faults:%d"",m); getch();
}
",5,315,445
"void main(){
int et[20],at[10],n,i,j,temp,st[10],ft[10],wt[10],ta[10]; int totwt=0,totta=0;
float awt,ata;
char pn[10][10],t[10]; 

printf(""Enter the number of process:""); scanf(""%d"",&n);
for(i=0;i<n;i++)
{
printf(""Enter process name, arrival time & execution time:""); 

scanf(""%s%d%d"",pn[i],&at[i],&et[i]);
}
for(i=0;i<n;i++)
for(j=0;j<n;j++)
{
if(et[i]<et[j])
{
temp=at[i];
at[i]=at[j];
at[j]=temp;
temp=et[i];
et[i]=et[j];
et[j]=temp;
strcpy(t,pn[i]);
strcpy(pn[i],pn[j]);
strcpy(pn[j],t);
}
}
for(i=0;i<n;i++)
{
if(i==0)
st[i]=at[i]; else st[i]=ft[i-1];
wt[i]=st[i]-at[i];ft[i]=st[i]+et[i];ta[i]=ft[i]-at[i];totwt+=wt[i]; totta+=ta[i];
}
awt=(float)totwt/n;
ata=(float)totta/n;
printf(""\nPname\tarrivaltime\texecutiontime\twaitingtime\ttatime"");
for(i=0;i<n;i++)
printf(""\n%s\t%5d\t\t%5d\t\t%5d\t\t%5d"",pn[i],at[i],et[i],wt[i],ta[i]); 
printf(""\nAverage waiting time is:%f"",awt);
printf(""\nAverage turnaroundtime is:%f"",ata); getch();
}
",5,316,522
"void main(){
    int pro,res,i,j;
    printf(""Enter No.of Processes:"");
    scanf(""%d"",&pro);
    printf(""Enter No.of Resources:"");
    scanf(""%d"",&res);
    
    int res_vector[res],res_allocated[res],res_avail[res];
    printf(""Enter Resource Vector:"");
    for(i=0;i<res;i++){
        scanf(""%d"",&res_vector[i]);
        res_allocated[i]=0;
    }
    
    int max[pro][res],allocated[pro][res],needed[pro][res];
    printf(""Enter the Max Requirement matrix:\n"");
    for(i=0;i<pro;i++){
        for(j=0;j<res;j++){
            scanf(""%d"",&max[i][j]);
        }
    }
    printf(""Enter the Allocated Resource matrix:\n"");
    for(i=0;i<pro;i++){
        for(j=0;j<res;j++){
            scanf(""%d"",&allocated[i][j]);
        }
    }
    
    for(i=0;i<pro;i++){
        for(j=0;j<res;j++){
            needed[i][j]=max[i][j]-allocated[i][j];
        }
    }
    
    for(i=0;i<res;i++){
        for(j=0;j<pro;j++){
            res_allocated[i]+=allocated[j][i];
        }
        res_avail[i]=res_vector[i]-res_allocated[i];
    }
    
    int completed[pro];
    for(i=0;i<pro;i++){
        completed[i]=0;
    }
    int flag,count=0;
    x:
    for(i=0;i<pro;i++){
        flag=0;
        for(j=0;j<res;j++){
            if(res_avail[j]<needed[i][j]||completed[i]==1){
                flag=1;
                count++;
                break;
            }
        }
        if(flag==0){
            printf(""P%d "",i);
            for(j=0;j<res;j++){
                res_avail[j]+=allocated[i][j];
                allocated[i][j]=0;
                needed[i][j]=0;
            }
            completed[i]=1;
            goto x;
        }
    }
    if(count==pro){
        printf(""No Safe Sequence is Possible"");
    }
}
",5,317,663
"void main(){
    int res,pro,i,j,n;
    printf(""Enter No.of Processes:"");
    scanf(""%d"",&pro);
    printf(""Enter No.of Resources:"");
    scanf(""%d"",&res);
    int res_vector[res],res_avail[res],res_allocated[res];
    printf(""Enter Resource vector:"");
    for(i=0;i<res;i++){
        scanf(""%d"",&res_vector[i]);
        res_allocated[i]=0;
    }
    int max[pro][res],allocated[pro][res],needed[pro][res];
    printf(""Enter the Max Requirement matrix:\n"");
    for(i=0;i<pro;i++){
        for(j=0;j<res;j++){
            scanf(""%d"",&max[i][j]);
        }
    }
    printf(""Enter the Allocated Resource matrix:\n"");
    for(i=0;i<pro;i++){
        for(j=0;j<res;j++){
            scanf(""%d"",&allocated[i][j]);
        }
    }
    
    for(i=0;i<pro;i++){
        for(j=0;j<res;j++){
            needed[i][j]=max[i][j]-allocated[i][j];
        }
    }
    
    for(i=0;i<res;i++){
        for(j=0;j<pro;j++){
            res_allocated[i]+=allocated[j][i];
        }
        res_avail[i]=res_vector[i]-res_allocated[i];
    }
    
    while(pro!=0){
        printf(""Enter process number that is to be executed:"");
        scanf(""%d"",&n);
        for(i=0;i<res;i++){
            if(needed[n][i]>res_avail[i]){
                printf(""Resources cannot be allocated to this process now:\n"");
                printf(""\nIt is unsafe state"");
                exit(0);
            }
        }
        if(i==res){
            printf(""Resources are allocated to the process %d and executed\n"",n);
            for(j=0;j<res;j++){
                res_avail[j]+=allocated[n][j];
            }
        }
    pro--;
    }
    if(pro==0)
        printf(""\nIt is safe state"");
}",5,318,611
"void main(){
    int rs[50], i, j, k, n, f, count[20], m[20], min, pf=0;
    printf(""Enter number of page references:"");
    scanf(""%d"",&n);
    printf(""Enter the reference string:"");
    for(i=0;i<n;i++)
        scanf(""%d"",&rs[i]);
    printf(""Enter the available no. of frames:"");
    scanf(""%d"",&f);
    for(i=0;i<f;i++){
        count[i]=0;
        m[i]=-1;
    }
    printf(""\nThe Page Replacement Process is\n"");
    for(i=0;i<n;i++){
        for(k=0;k<f;k++){
            if(rs[i]==m[k]){
                count[k]++;
                break;
            }
        }
        if(k==f){
            if(i<f){
                m[i]=rs[i];
                count[i]++;
            }
            else{
                min = 0;
                for(j=1;j<f;j++)
                    if(count[min]>count[j])
                        min=j;
                m[min]=rs[i];
                count[min]=1;
            }
            pf++;
        }
        for(j=0;j<f;j++)
            printf(""%d\t"",m[j]);
        if(k==f)
            printf(""PF No. %d"",pf);
        print(""\n"");    
    }
    printf(""\n Total number of page faults: %d"",pf);
}
",5,319,412
"void main(){
int a[5],b[20],n,p=0,q=0,m=0,h,k,i,q1=1; char f='F';

printf(""Enter the Number of Pages: ""); 
scanf(""%d"",&n);
printf(""Enter %d Page Numbers:"",n); for(i=0;i<n;i++)
scanf(""%d"",&b[i]);
for(i=0;i<n;i++)
{if(p==0)
{
if(q>=3)
q=0;
a[q]=b[i];
q++;
if(q1<3)
{
q1=q;
}
}
printf(""\n%d"",b[i]);
printf(""\t"");
for(h=0;h<q1;h++)
printf(""%d"",a[h]);
if((p==0)&&(q<=3))
{
printf(""-->%c"",f);m++;
}
p=0;
for(k=0;k<q1;k++)
{
if(b[i+1]==a[k])
p=1;
}
}
printf(""\nNo of faults:%d"",m); 
getch();
}
",5,320,301
"int matrix[10][10],visited[10],n,i,j;
bool isCyclic(int);
void main(){
    printf(""Enter the No.of Processes present in wait for graph:"");
    scanf(""%d"",&n);
    printf(""Enter the adjacency matrix:\n"");
    for(i=0;i<n;i++){
        for(j=0;j<n;j++){
            scanf(""%d"",&matrix[i][j]);
        }
    }
    for(i=0;i<n;i++){
        visited[i]=0;
    }
    
    bool flag=false;
    for(i=0;i<n;i++){
        visited[i]=1;
        for(j=0;j<n;j++){
            if(matrix[i][j]==0) continue;
            flag = isCyclic(j);
            if(flag==true){
                printf(""Cycle is present"");
                exit(0);
            }
        }
        visited[i]=0;
    }
    if(flag==false){
        printf(""Cycle is not present"");
    }
}
bool isCyclic(int cur){
    if(visited[cur]==1){
        return true;
    }
    visited[cur]=1;
    bool flag=false;
    for(i=0;i<n;i++){
        if(matrix[cur][i]==0) continue;
        flag=isCyclic(i);
        if(flag==true)
            return true;
    }
    visited[cur]=0;
    return false;
}
",5,321,399
"struct pstruct {
    int fno;
    int pbit;
}ptable[10];
int pmsize,lmsize,psize,no_of_frames,no_of_pages,ftable[20],frameno;
void info(){
    printf(""Enter the Size of Physical memory: "");
    scanf(""%d"",&pmsize);
    printf(""Enter the size of Logical memory: "");
    scanf(""%d"",&lmsize);
    printf(""Enter the partition size: "");
    scanf(""%d"",&psize);
    no_of_frames=pmsize/psize;
    no_of_pages=lmsize/psize;
    printf(""The physical memory is divided into %d no.of frames\n"",no_of_frames);
    printf(""The Logical memory is divided into %d no.of pages\n"",no_of_pages);
}
void assign(){
    int i;
    for (i=0;i<no_of_pages;i++){
        ptable[i].fno = -1;
        ptable[i].pbit= -1;
    }
    for(i=0; i<no_of_frames;i++)
        ftable[i] = 32555;
    for (i=0;i<no_of_pages;i++){
        printf(""Enter the Frame number where page %d must be placed: "",i);
        scanf(""%d"",&frameno);
        ftable[frameno] = i;
        if(ptable[i].pbit == -1){
            ptable[i].fno = frameno;
            ptable[i].pbit = 1;
        }
    }
    printf(""\n\nPAGE TABLE\n\n"");
    printf(""PageAddress FrameNo. PresenceBit\n\n"");
    for (i=0;i<no_of_pages;i++)
        printf(""%d\t\t%d\t\t%d\n"",i,ptable[i].fno,ptable[i].pbit);
    printf(""\n\nFRAME TABLE\n\n"");
    printf(""FrameAddress PageNo\n\n"");
    for(i=0;i<no_of_frames;i++)
        printf(""%d\t\t%d\n"",i,ftable[i]);
}

void cphyaddr(){
    int log_add,paddr,disp,phy_add,base_add;
    printf(""Enter the Base Address: "");
    scanf(""%d"",&base_add);
    printf(""Enter the Logical Address: "");
    scanf(""%d"",&log_add);
    paddr = log_add / psize;
    disp = log_add % psize;
    if(ptable[paddr].pbit == 1 )
        phy_add = base_add + (ptable[paddr].fno*psize) + disp;
    printf(""\nThe Physical Address where the instruction present: %d"",phy_add);
}
void main(){
    info();
    assign();
    cphyaddr();
}
",5,322,756
"void main(){
    int n,option,frames;
    int size[10];
    int i,a[10],total=0;
    char p[10];
    printf(""No.of Processes present:"");
    scanf(""%d"",&n);
    for(i=0;i<n;i++){
        printf(""Enter the process name-"");
        scanf(""%s"",&p[i]);
        printf(""Enter the size of process-"");
        scanf(""%d"",&size[i]);
    }
    printf(""No.of Frames present:"");
    scanf(""%d"",&frames);
    while(1){
        printf(""\n1.Fixed Allocation\t2.Proportional Allocation\t3.Exit:-"");
        scanf(""%d"",&option);
        switch(option){
            case 1: for(i=0;i<n;i++){
                        printf(""\nAllocation of frames to process %c is %d"",p[i],frames/n);
                    }
                    break;
                    
            case 2: for(i=0;i<n;i++) total = total+size[i]; 
                    for(i=0;i<n;i++){
                        printf(""\nAllocation of frames for process %c is %d"",p[i],(size[i]*frames)/total);
                    }
                    break;
            case 3: exit(0);        
            default: printf(""\nInvalid Selection"");
        }
    }
}
",5,323,364
"main(){
int f[50],p,i,j,k,a,st,len,n,c;

for(i=0;i<50;i++)
f[i]=0;
printf(""\nEnter the number of blocks that are already allocated: "");
scanf(""%d"",&p);
printf(""\nEnter the blocks no.s that are already allocated:"");
for(i=0;i<p;i++)
{
scanf(""%d"",&a);
f[a]=1;
}
X:
printf(""\nEnter the starting index block & length:"");
scanf(""%d%d"",&st,&len);
k=len;
for(j=st;j<(k+st);j++)
{
if(f[j]==0)
{
f[j]=1;
printf(""\n%d->%d"",j,f[j]);
}
else
{
printf(""\n%d->file is already allocated"",j);
k++;
}
}
printf(""\nWould you like to enter more files? (YES-1/NO-0)"");
scanf(""%d"",&c);
if(c==1)
goto X;
else
close();
getch( );}
",5,324,292
"#define MAX 5

void insertion(int *,int *, int, int);

int main() {
  int nums[MAX] = {5, 4, 7, 9, 2}, target[MAX + 1], pos, input; 

  printf(""The array is\n"");

  for (int i = 0; i < MAX; i++)
    printf(""%d\t"",  *(nums + i));

  printf(""\nEnter a number and position:"");
  scanf(""%d %d"", &input, &pos );

  insertion(nums, target, input, pos);

  printf(""The array is\n"");

  for (int i = 0; i < MAX + 1; i++)
    printf(""%d\t"",  *(target + i));

  return 0;
}

void insertion(int *source, int *target, int number, int position) {
  int j = 0;

  for (j = 0; j < MAX + 1; j++) { 
    if (j < position - 1){
      *(target + j) = *(source + j);
      continue;
    }
    else if (j == position - 1) 
      *(target + j) = number;
    else { 
      *(target + j) = *(source + j - 1);
    }
  }
}
",6,325,344
"int prime(int n) {
  if (n % 2 == 0)
    return 1;
  else
  {
    for (int ii = 1; ii <= sqrt(n); ii++)
    {
      if (n % ii == 0)
       return 1;
    }
  return 0;
  }
}

int Armstrong(int num) {
    int sum = 0, target = 0, tmp;
    tmp = num;
    while (num > 0)
    {
        sum += pow(num%10, 3);
        num /= 10;
    }
    
    return  (tmp == sum ? 1 : 0);
}

int perf_check(int n) {
  int summ = 0;
  for (int ii = 1; ii <= sqrt(n) + 1; ii++)
  {
    if (n % ii == 0)
      summ += ii;
  }
  return (summ == n ? 1 : 0);
}

int main() {
  int v1, num;
  printf(""1...Prime Check\n"");
  printf(""2...Armstrong Check\n"");
  printf(""3...Perfect number Check\n"");
  scanf(""%d"",&v1);
  switch (v1) {
    case 1:
      printf(""Enter a number.\n"");
      scanf(""%d"",&num);
      printf(""%d is a %s\n"",num, prime(num) ? ""not prime"" : ""prime"");
      break;
    case 2:
      printf(""Enter a number.\n"");
      scanf(""%d"",&num);
      printf(""%d is a %s\n"",num, Armstrong(num) ? ""Armstrong number."" : ""not Armstrong number."");
      break;
    case 3:
      printf(""Enter a number.\n"");
      scanf(""%d"",&num);
      printf(""%d is a %s\n"",num, perf_check(num) ? ""perfect"" : ""not perfect"");
      break;
    default:
      printf(""ERROR (invalid input)\n"");
      exit(1);
  }
  return 0;
}







",6,326,543
"#define MAX 3

int main()
{
  int mat1[MAX][MAX], mat2[MAX][MAX], addition[MAX][MAX];

  printf(""Give values in the matrix1 row-wise.\n"");

  for (int i = 0; i < MAX; i++)
  {
    for (int j = 0; j < MAX; j++)
    {
      scanf(""%d"",&mat1[i][j]);
    }
  }

  printf(""Give values in the matrix2 row-wise.\n"");

  for (int ii = 0; ii < MAX; ii++)
  {
    for (int jj = 0; jj < MAX; jj++)
    {
      scanf(""%d"", &mat2[ii][jj]);
    }
  }

  printf(""\nThe matrix1 is\n"");
  for (int ii = 0; ii < MAX; ii++)
  {
    for (int jj = 0; jj < MAX; jj++)
    {
      printf(""%d\t"",mat1[ii][jj]);
    }
    printf(""\n"");
  }

  printf(""\nThe matrix2 is\n"");
  for (int ii = 0; ii < MAX; ii++)
  {
    for (int jj = 0; jj < MAX; jj++)
    {
      printf(""%d\t"",mat2[ii][jj]);
    }
    printf(""\n"");
  }


  printf(""\nThe matrix1 + matrix2 is\n"");
  for (int ii = 0; ii < MAX; ii++)
  {
    for (int jj = 0; jj < MAX; jj++)
    {
      printf(""%d\t"",mat1[ii][jj] + mat2[ii][jj]);
    }
    printf(""\n"");
  }

  return 0;
}
",6,327,464
"#define MAX 40

 
void merge_string(char *source1, char *source2, char *target) {
  while (*source1 != '\0') {
    *target = *source1;
    source1++;
    target++;
  }

  while (*source2 != '\0') {
    *target = *source2;
    source2++;
    target++;
  }

  *target = '\0';
}

int main() { 
  char source1[MAX], source2[MAX], target[MAX];
  printf(""Enter a string (Max %d characters)\n"", MAX);
  scanf(""%[^\n]%*c"", source1); 
  printf(""Enter another string (Max %d characters)\n"", MAX);
  scanf(""%[^\n]%*c"", source2); 
  merge_string(source1, source2, target);
  printf(""%s\n"", target);
  return 0;
}
",6,328,231
"#define MAX 5

void reverse_array(int *origin, int *rev) {
  int j = 0;
  for (int i = MAX - 1; i >= 0; i--)
    {
        *(rev + j) = *(origin + i);
        j++;
    }
}

int main() {
  int source[MAX], target[MAX];

  printf(""Enter %d numbers: "", MAX);

  for (int i = 0; i < MAX; i++)
    scanf(""%d"", source + i);

  printf(""\nThe Array is\n"");
  for (int i = 0; i < MAX; i++)
    printf(""%d\t"",  *(source + i));

  reverse_array(source, target);

  printf(""\nThe reversed Array is\n"");
  for (int i = 0; i < MAX; i++)
    printf(""%d\t"",  *(target + i));

  return 0;
}
",6,329,243
"#define MAX 5

void deletion(int *,int *, int);

int main() {
  int nums[MAX] = {5, 4, 7, 9, 2}, target[MAX - 1], pos, input; 

  printf(""The array is\n"");
  
  for (int i = 0; i < MAX; i++)
    printf(""%d\t"",  *(nums + i));

  printf(""\nEnter the position:"");
  scanf(""%d"", &pos );

  deletion(nums, target, pos);

  
  

  printf(""The array is\n"");

  for (int i = 0; i < MAX - 1; i++)
    printf(""%d\t"",  *(target + i));

  return 0;
}

void deletion(int *source, int *target, int position) {
  int j = 0;

  for (j = 0; j < MAX + 1; j++) { 
    if (j < position - 1){
      *(target + j) = *(source + j);
      continue;
    }
    else { 
      *(target + j) = *(source + j + 1);
    }
  }
}
",6,330,312
"#define MAX 20

void string_reverse(char *origin, char *rev) {
  int f = 0, cnt = 0, j = 0;
  while ( *(origin + f) != '\0' ) {
    cnt++;
    f++;
  }
  for (int i = cnt - 1; i >= 0; i--)
  {
    *(rev + j) = *(origin + i);
    j++;
  }
  *(rev + j) = '\0';
}

int pal_chk(char *norm, char *rev) {
  while (*(norm) != '\0') {
    if (*norm == *rev) {
      norm++;
      rev++;
    }
    else
      return 0;
  }
  return 1;
}

int main() {
  char origin[MAX], reverse[MAX];

  printf(""Enter a string (20): "");
  scanf(""%[^\n]%*c"", origin);

  string_reverse(origin, reverse);

  if (pal_chk(origin, reverse))
    printf(""The string ' %s ' is a Palindrome\n"", origin);
  else
    printf(""The string ' %s ' is not a Palindrome\n"", origin);

  return 0;
}
",6,331,321
"#define MAX 5

void reverse_array(int *origin, int *rev) {
  int j = 0;
  for (int i = MAX - 1; i >= 0; i--)
    {
        *(rev + j) = *(origin + i);
        j++;
    }
}

int main() {
  int source[MAX], target[MAX];

  printf(""Enter %d numbers: "", MAX);

  for (int i = 0; i < MAX; i++)
    scanf(""%d"", source + i);

  printf(""\nThe Array is\n"");
  for (int i = 0; i < MAX; i++)
    printf(""%d\t"",  *(source + i));

  reverse_array(source, target);

  printf(""\nThe reversed Array is\n"");
  for (int i = 0; i < MAX; i++)
    printf(""%d\t"",  *(target + i));
  printf(""\n"");
  return 0;
}
",6,332,248
"#define SIZE 5
void merge_array(int *, int *, int *);

int main() {
  int unsorted1[SIZE], unsorted2[SIZE], final[2*SIZE];

  printf(""Enter %d numbers in 1st array: "", SIZE);
  for (int i = 0; i < SIZE; i++)
    scanf(""%d"",unsorted1 + i);

  printf(""Enter %d numbers in 2nd array: "", SIZE);
  for (int i = 0; i < SIZE; i++)
    scanf(""%d"",unsorted2 + i);

  printf(""\nArray 1:\n"");
  for (int i = 0; i < SIZE; i++)
    printf(""%d\t"",  *(unsorted1 + i));

  printf(""\nArray 2:\n"");
  for (int i = 0; i < SIZE; i++)
    printf(""%d\t"",  *(unsorted2 + i));

  merge_array(unsorted1, unsorted2, final);

  printf(""\nMerged array\n"");

  for (int j = 0; j < (2 * SIZE); j++)
    printf(""%d  "",*(final + j));
}

void merge_array(int *source1, int *source2, int *target) {
  int j = 0;

  for (j; j < (2*SIZE); j++) {
    if (j < SIZE) {
      *(target + j) = *(source1 + j);
    }
    else {
      *(target + j) = *(source2 + j - SIZE);
    }
  }
}
",6,333,410
"void findRoots(int a, int b, int c)
{
    if (a == 0) {
        printf(""Invalid input, as a has to be non-zero.\n"");
        return;
    }

    int d = b * b - 4 * a * c;
    double sqrt_val = sqrt(abs(d));

    if (d > 0) {
        printf(""Roots are real and different \n"");
        printf(""%f\n%f"", (double)(-b + sqrt_val) / (2 * a),
            (double)(-b - sqrt_val) / (2 * a));
    }
    else if (d == 0) {
        printf(""Roots are real and same \n"");
        printf(""%f"", -(double)b / (2 * a));
    }
    else 
    {
        printf(""Roots are complex \n"");
        printf(""%f + i(%f)\n%f - i(%f)"", -(double)b / (2 * a),
            sqrt_val, -(double)b / (2 * a), sqrt_val);
    }
}


int main()
{
    int a, b, c;
    printf(""Give coefficients a, b and c in ax^2 + bx +c = 0 in order.\n"");
    scanf(""%d %d %d"",&a,&b,&c);
    
    findRoots(a, b, c);
    return 0;
}

",6,334,362
"#define MAX 25 


void string_reverse(char *, char *);

int main () {
    char source[MAX], final[MAX]; 
    printf(""Enter a string (max %d characters): "", MAX);
    
    fgets(source, MAX, stdin); 
    printf(""%s \n"", source);
    string_reverse(source, final); 
    printf(""%s \n"", final);
    return 0;
}

void string_reverse(char *origin, char *rev) {
    int f = 0, cnt = 0, j = 0; 
    
    
    
    while ( *(origin + f) != '\0' ) { 
        cnt++;
        f++;
    }
    
    for (int i = cnt - 1; i >= 0; i--)
    {
        *(rev + j) = *(origin + i);
        j++;
    }
    
    *(rev + j) = '\0'; 
    
}
",6,335,248
"void main() {
  int mat1[2][2], mat2[2][2], mat[2][2];

  printf(""Enter values in matrix 1(2*2) row-wise (a11, a12, a21, a22): "");
  for (int i = 0; i < 2; i++)
    scanf(""%d %d"",*(mat1 + i) + 0, *(mat1 + i) + 1 );

  printf(""Enter values in matrix 2(2*2) row-wise (a11, a12, a21, a22): "");
  for (int i = 0; i < 2; i++)
    scanf(""%d %d"",*(mat2 + i) + 0, *(mat2 + i) + 1 );

  printf(""\nMatrix 1(2*2)\n"");
  for (int i = 0; i < 2; i++) {
    printf(""%d %d"",*(*(mat1 + i) + 0), *(*(mat1 + i) + 1));
    printf(""\n"");
  }

  printf(""\nMatrix 2(2*2)\n"");
  for (int i = 0; i < 2; i++) {
    printf(""%d %d"",*(*(mat2 + i) + 0), *(*(mat2 + i) + 1));
    printf(""\n"");
  }

  printf(""\nMatrix1 + Matrix2 = \n"");
  for (int i = 0; i < 2; i++) {
    printf(""%d %d"",mat1[i][0] + mat2[i][0], mat1[i][1] + mat2[i][1]);
    printf(""\n"");
  }
}
",6,336,428
"int main() {
    int x = 2, y, z = 4;
    printf(""x = %d\nz = %d\n"", x,z);
    printf(""a) y = x++ + ++x => "");
    y = x++ + ++x;
    printf(""%d\n"", y);
    
    x = 2;
    printf(""b) y = ++x + ++x => "");
    y = ++x + ++x;
    printf(""%d\n"", y);

    x = 2;
    printf(""c) y = ++x + ++x + ++x => "");
    y = ++x + ++x + ++x; 
    printf(""%d\n"", y);
    
    x = 2;
    printf(""d) y = x>z = "");
    y = x > z;
    printf(""%d\n"", y);
    
    printf(""e) y = x>z?x:z = "");
    y = x > z ? x : z;
    printf(""%d\n"", y);

    return 0;
}
",6,337,260
"struct point {
    float re;
    float im;
};


struct point complex_add(struct point A, struct point B) {
    struct point C;
    C.re = A.re + B.re;
    C.im = A.im + B.im;
    return C;
}

int main(void) {
    struct point A, B, target;
    printf(""Enter first number real and imaginary part of A = (a1 + ib1): "");
    scanf(""%f %f"", &A.re, &A.im);

    printf(""Enter first number real and imaginary part of B = (a2 + ib2): "");
    scanf(""%f %f"", &B.re, &B.im);   

    target = complex_add(A, B);
    
    printf(""A + B = %4.3f + i(%4.3f)\n"", target.re, target.im);
    return 0;
}
",6,338,235
"int main()
{
  int rows, cols;
  int x, y;
  printf(""Enter matrix dimension(row * col): "");
  scanf(""%d %d"",&rows, &cols);

  int mm[rows][cols];

  printf(""Give values in the %d * %d matrix row-wise.\n"", rows, cols);

  for (int ii = 0; ii < rows; ii++)
  {
    for (int jj = 0; jj < cols; jj++)
    {
      scanf(""%d"",&mm[ii][jj]);
    }
  }

  printf(""\nThe array is\n"");
  for (int ii = 0; ii < rows; ii++)
  {
    for (int jj = 0; jj < cols; jj++)
    {
      printf(""%d\t"",mm[ii][jj]);
    }
    printf(""\n"");
  }


  printf(""Enter (row * col) of element needed: "");
  scanf(""%d %d"",&x, &y);
  if (x > rows || y > cols)
    printf(""Array index out of range\n"");
  else
    printf(""Value at %d * %d in the given array is: %d\n"",x, y, mm[x - 1][y - 1]);
    
  return 0;
}
",6,339,334
"#define MAX 5

int search(int *, int);

int main() {
  int numbers[MAX], val, pos;

  printf(""Enter %d numbers: "", MAX);
  for (int i = 0; i < MAX; i++)
    scanf(""%d"",numbers + i);

  printf(""\nArray 1:\n"");
  for (int i = 0; i < MAX; i++)
    printf(""%d\t"",  *(numbers + i));

  printf(""Enter the value to be searched\n"" );
  scanf(""%d"",&val);

  pos = search(numbers, val);

  if (pos > 0)
    printf(""%d is at position %d\n"",val, pos);
  else
    printf(""%d not found\n"",val);
}

int search(int *array, int num) {
  for (int j = 0; j < MAX; j++)
  {
    if (*(array + j) == num)
    {
      
      return (j + 1);
    }
  }
  return 0;
}
",6,340,268
"#include ""shell.h""

char *_strcpy(char *dest, char *src)
{
int i;

i = 0;
    while (src[i])
    {
        dest[i] = src[i];
        i++;
    }
dest[i] = '\0';
return (dest);
}

char *_strcat(char *dest, char *src)
{
    char *s = dest;

    while (*dest != '\0')
    {
        dest++;
    }

    while (*src != '\0')
    {
        *dest = *src;
        dest++;
        src++;
    }
    *dest = '\0';
    return (s);
}

char *_strchr(char *s, char c)
{

    do      {

        if (*s == c)
            {
            break;
            }
        }   while (*s++);

return (s);
}

int _strncmp(const char *s1, const char *s2, size_t n)
{
    size_t i;

    if (s1 == NULL)
        return (-1);
    for (i = 0; i < n && s2[i]; i++)
    {
        if (s1[i] != s2[i])
        {
            return (1);
        }
    }
    return (0);
}

char *_strdup(char *str)
{
    size_t len, i;
    char *str2;

    len = _strlen(str);
    str2 = malloc(sizeof(char) * (len + 1));
    if (!str2)
    {
        return (NULL);
    }

    for (i = 0; i <= len; i++)
    {
        str2[i] = str[i];
    }

    return (str2);
}
",7,341,468
"#include ""shell.h""

void  exit_bul(char **cmd, char *input, char **argv, int c)
{
    int statue, i = 0;

    if (cmd[1] == NULL)
    {
        free(input);
        free(cmd);
        exit(EXIT_SUCCESS);
    }
    while (cmd[1][i])
    {
        if (_isalpha(cmd[1][i++]) != 0)
        {
            _prerror(argv, c, cmd);
            break;
        }
        else
        {
            statue = _atoi(cmd[1]);
            free(input);
            free(cmd);
            exit(statue);
        }
    }
}



int change_dir(char **cmd, __attribute__((unused))int er)
{
    int value = -1;
    char cwd[PATH_MAX];

    if (cmd[1] == NULL)
        value = chdir(getenv(""HOME""));
    else if (_strcmp(cmd[1], ""-"") == 0)
    {
        value = chdir(getenv(""OLDPWD""));
    }
    else
        value = chdir(cmd[1]);

    if (value == -1)
    {
        perror(""hsh"");
        return (-1);
    }
    else if (value != -1)
    {
        getcwd(cwd, sizeof(cwd));
        setenv(""OLDPWD"", getenv(""PWD""), 1);
        setenv(""PWD"", cwd, 1);
    }
    return (0);
}

int dis_env(__attribute__((unused)) char **cmd, __attribute__((unused)) int er)
{
size_t i;
    int len;

    for (i = 0; environ[i] != NULL; i++)
    {
        len = _strlen(environ[i]);
        write(1, environ[i], len);
        write(STDOUT_FILENO, ""\n"", 1);
    }
    return (0);
}

int display_help(char **cmd, __attribute__((unused))int er)
{
    int fd, fw, rd = 1;
    char c;

    fd = open(cmd[1], O_RDONLY);
    if (fd < 0)
    {
        perror(""Error"");
        return (0);
    }
    while (rd > 0)
    {
        rd = read(fd, &c, 1);
        fw = write(STDOUT_FILENO, &c, rd);
        if (fw < 0)
        {
            return (-1);
        }
    }
    _putchar('\n');
    return (0);
}

int echo_bul(char **cmd, int st)
{
    char *path;
    unsigned int  pid = getppid();

    if (_strncmp(cmd[1], ""$?"", 2) == 0)
    {
        print_number_in(st);
        PRINTER(""\n"");
    }
    else if (_strncmp(cmd[1], ""$$"", 2) == 0)
    {
        print_number(pid);
        PRINTER(""\n"");

    }
    else if (_strncmp(cmd[1], ""$PATH"", 5) == 0)
    {
        path = _getenv(""PATH"");
        PRINTER(path);
        PRINTER(""\n"");
        free(path);

    }
    else
        return (print_echo(cmd));

    return (1);
}
",7,342,897
"#include ""binary_trees.h""

int binary_tree_is_leaf(const binary_tree_t *node)
{
    if (node == NULL)
        return (0);
    else if (node->left == NULL && node->right == NULL)
        return (1);
    return (0);
}


size_t binary_tree_height(const binary_tree_t *tree)
{
    size_t h_left, h_right;

    if (tree == NULL || binary_tree_is_leaf(tree))
        return (0);
    h_left = binary_tree_height(tree->left);
    h_right = binary_tree_height(tree->right);
    if (h_right <= h_left)
        return (h_left + 1);

    return (h_right + 1);

}


int binary_tree_is_perfect(const binary_tree_t *tree)
{
    binary_tree_t *left, *right;
    size_t l_r, l_l;

    if (tree == NULL)
        return (0);
    left = tree->left;
    right = tree->right;

    if (binary_tree_is_leaf(tree))
        return (1);
    if (left == NULL || right == NULL)
        return (0);
    l_r = binary_tree_height(right);
    l_l = binary_tree_height(left);
    if (l_r == l_l)
    {
        if (binary_tree_is_perfect(left) && binary_tree_is_perfect(right))
            return (1);
    }
    return (0);

}
",7,343,416
"#include ""binary_trees.h""




static int print_t(const binary_tree_t *tree, int offset, int depth, char **s)
{
    char b[6];
    int width, left, right, is_left, i;

    if (!tree)
        return (0);
    is_left = (tree->parent && tree->parent->left == tree);
    width = sprintf(b, ""(%03d)"", tree->n);
    left = print_t(tree->left, offset, depth + 1, s);
    right = print_t(tree->right, offset + left + width, depth + 1, s);
    for (i = 0; i < width; i++)
        s[depth][offset + left + i] = b[i];
    if (depth && is_left)
    {
        for (i = 0; i < width + right; i++)
            s[depth - 1][offset + left + width / 2 + i] = '-';
        s[depth - 1][offset + left + width / 2] = '.';
    }
    else if (depth && !is_left)
    {
        for (i = 0; i < left + width; i++)
            s[depth - 1][offset - width / 2 + i] = '-';
        s[depth - 1][offset + left + width / 2] = '.';
    }
    return (left + width + right);
}


static size_t _height(const binary_tree_t *tree)
{
    size_t height_l;
    size_t height_r;

    height_l = tree->left ? 1 + _height(tree->left) : 0;
    height_r = tree->right ? 1 + _height(tree->right) : 0;
    return (height_l > height_r ? height_l : height_r);
}


void binary_tree_print(const binary_tree_t *tree)
{
    char **s;
    size_t height, i, j;

    if (!tree)
        return;
    height = _height(tree);
    s = malloc(sizeof(*s) * (height + 1));
    if (!s)
        return;
    for (i = 0; i < height + 1; i++)
    {
        s[i] = malloc(sizeof(**s) * 255);
        if (!s[i])
            return;
        memset(s[i], 32, 255);
    }
    print_t(tree, 0, 0, s);
    for (i = 0; i < height + 1; i++)
    {
        for (j = 254; j > 1; --j)
        {
            if (s[i][j] != ' ')
                break;
            s[i][j] = '\0';
        }
        printf(""%s\n"", s[i]);
        free(s[i]);
    }
    free(s);
}
",7,344,750
"#include ""shell.h""

unsigned int check_delim(char c, const char *str)
{
    unsigned int i;

    for (i = 0; str[i] != '\0'; i++)
    {
        if (c == str[i])
            return (1);
    }
    return (0);
}


char *_strtok(char *str, const char *delim)
{
    static char *ts;
    static char *nt;
    unsigned int i;

    if (str != NULL)
        nt = str;
    ts = nt;
    if (ts == NULL)
        return (NULL);
    for (i = 0; ts[i] != '\0'; i++)
    {
        if (check_delim(ts[i], delim) == 0)
            break;
    }
    if (nt[i] == '\0' || nt[i] == '#')
    {
        nt = NULL;
        return (NULL);
    }
    ts = nt + i;
    nt = ts;
    for (i = 0; nt[i] != '\0'; i++)
    {
        if (check_delim(nt[i], delim) == 1)
            break;
    }
    if (nt[i] == '\0')
        nt = NULL;
    else
    {
        nt[i] = '\0';
        nt = nt + i + 1;
        if (*nt == '\0')
            nt = NULL;
    }
    return (ts);
}
",7,345,392
"#include ""shell.h""


void *_realloc(void *ptr, unsigned int old_size, unsigned int new_size)
{
    void *result;

    if (new_size == old_size)
        return (ptr);
    if (new_size == 0 && ptr)
    {
        free(ptr);
        return (NULL);
    }
    result = malloc(new_size);
    if (result == NULL)
        return (NULL);
    if (ptr == NULL)
    {
        fill_an_array(result, '\0', new_size);
        free(ptr);
    }
    else
    {
        _memcpy(result, ptr, old_size);
        free(ptr);
    }
    return (result);

}

void free_all(char **cmd, char *line)
{
    free(cmd);
    free(line);
    cmd = NULL;
    line = NULL;
}


char *_memcpy(char *dest, char *src, unsigned int n)
{
    unsigned int i;

    for (i = 0; i < n; i++)
    {
        dest[i] = src[i];
    }
    return (dest);
}

void *fill_an_array(void *a, int el, unsigned int len)
{
    char *p = a;
    unsigned int i = 0;

    while (i < len)
    {
        *p = el;
        p++;
        i++;
    }
    return (a);
}

void *_calloc(unsigned int size)
{
    char *a;
    unsigned int i;

    if (size == 0)
    return (NULL);
    a = malloc(size);
    if (a == NULL)
    return (NULL);
    for (i = 0; i < size; i++)
    {
        a[i] = '\0';
    }
    return (a);
}
",7,346,484
"#include ""shell.h""


int _strcmp(char *s1, char *s2)
{
int cmp = 0, i, len1, len2;
len1 = _strlen(s1);
len2 = _strlen(s2);

    if (s1 == NULL || s2 == NULL)
        return (1);
    if (len1 != len2)
        return (1);
    for (i = 0; s1[i]; i++)
    {
        if (s1[i] != s2[i])
        {
            cmp = s1[i] - s2[i];
            break;
        }
        else
            continue;
    }
    return (cmp);
}

int _isalpha(int c)
{
if (((c >= 97) && (c <= 122)) || ((c >= 65) && (c <= 90)))
{
return (1);
}
else
{
return (0);
}
}

char *_itoa(unsigned int n)
{
    int len = 0, i = 0;
    char *s;

    len = intlen(n);
    s = malloc(len + 1);
    if (!s)
        return (NULL);
    *s = '\0';
    while (n / 10)
    {
        s[i] = (n % 10) + '0';
        n /= 10;
        i++;
    }
    s[i] = (n % 10) + '0';
    array_rev(s, len);
    s[i + 1] = '\0';
    return (s);
}

void array_rev(char *arr, int len)
{
    int i;
    char tmp;

    for (i = 0; i < (len / 2); i++)
    {
        tmp = arr[i];
        arr[i] = arr[(len - 1) - i];
        arr[(len - 1) - i] = tmp;
    }
}

int intlen(int num)
{
    int len = 0;

    while (num != 0)
    {
        len++;
        num /= 10;
    }
    return (len);
}
",7,347,570
"#include ""shell.h""


int history_dis(__attribute__((unused))char **c, __attribute__((unused))int s)
{
    char *filename = "".simple_shell_history"";
    FILE *fp;
    char *line = NULL;
    size_t len = 0;
    int counter = 0;
    char *er;

    fp = fopen(filename, ""r"");
    if (fp == NULL)
    {
        return (-1);
    }
    while ((getline(&line, &len, fp)) != -1)
    {
        counter++;
        er = _itoa(counter);
        PRINTER(er);
        free(er);
        PRINTER("" "");
        PRINTER(line);

    }
    if (line)
        free(line);
    fclose(fp);
    return (0);
}

int print_echo(char **cmd)
{
    pid_t pid;
    int status;

    pid = fork();
    if (pid == 0)
    {
    if (execve(""/bin/echo"", cmd, environ) == -1)
    {
        return (-1);
    }
        exit(EXIT_FAILURE);
    }
    else if (pid < 0)
    {
        return (-1);
    }
    else
    {
        do {
            waitpid(pid, &status, WUNTRACED);
        } while (!WIFEXITED(status) && !WIFSIGNALED(status));
    }
    return (1);
}
",7,348,388
"#include ""shell.h""



int main(__attribute__((unused)) int argc, char **argv)
{
    char *input, **cmd;
    int counter = 0, statue = 1, st = 0;

    if (argv[1] != NULL)
        read_file(argv[1], argv);
    signal(SIGINT, signal_to_handel);
    while (statue)
    {
        counter++;
        if (isatty(STDIN_FILENO))
            prompt();
        input = _getline();
        if (input[0] == '\0')
        {
            continue;
        }
        history(input);
        cmd = parse_cmd(input);
        if (_strcmp(cmd[0], ""exit"") == 0)
        {
            exit_bul(cmd, input, argv, counter);
        }
        else if (check_builtin(cmd) == 0)
        {
            st = handle_builtin(cmd, st);
            free_all(cmd, input);
            continue;
        }
        else
        {
            st = check_cmd(cmd, input, counter, argv);

        }
        free_all(cmd, input);
    }
    return (statue);
}

int check_builtin(char **cmd)
{
    bul_t fun[] = {
        {""cd"", NULL},
        {""help"", NULL},
        {""echo"", NULL},
        {""history"", NULL},
        {NULL, NULL}
    };
    int i = 0;
        if (*cmd == NULL)
    {
        return (-1);
    }

    while ((fun + i)->command)
    {
        if (_strcmp(cmd[0], (fun + i)->command) == 0)
            return (0);
        i++;
    }
    return (-1);
}

void creat_envi(char **envi)
{
    int i;

    for (i = 0; environ[i]; i++)
        envi[i] = _strdup(environ[i]);
    envi[i] = NULL;
}
",7,349,522
"#include ""shell.h""



int handle_builtin(char **cmd, int er)
{
     bul_t bil[] = {
        {""cd"", change_dir},
        {""env"", dis_env},
        {""help"", display_help},
        {""echo"", echo_bul},
        {""history"", history_dis},
        {NULL, NULL}
    };
    int i = 0;

    while ((bil + i)->command)
    {
        if (_strcmp(cmd[0], (bil + i)->command) == 0)
        {
            return ((bil + i)->fun(cmd, er));
        }
        i++;
    }
    return (-1);
}

int check_cmd(char **cmd, char *input, int c, char **argv)
{
    int status;
    pid_t pid;

    if (*cmd == NULL)
    {
        return (-1);
    }

    pid = fork();
    if (pid == -1)
    {
        perror(""Error"");
        return (-1);
    }

    if (pid == 0)
    {
        if (_strncmp(*cmd, ""./"", 2) != 0 && _strncmp(*cmd, ""/"", 1) != 0)
        {
            path_cmd(cmd);
        }

        if (execve(*cmd, cmd, environ) == -1)
        {
            print_error(cmd[0], c, argv);
            free(input);
            free(cmd);
            exit(EXIT_FAILURE);
        }
        return (EXIT_SUCCESS);
    }
    wait(&status);
    return (0);
}

void signal_to_handel(int sig)
{
    if (sig == SIGINT)
    {
        PRINTER(""\n$ "");
    }
}
",7,350,455
"#include ""shell.h""

int history(char *input)
{
    char *filename = "".simple_shell_history"";
    ssize_t fd, w;
    int len = 0;

    if (!filename)
        return (-1);
    fd = open(filename, O_CREAT | O_RDWR | O_APPEND, 00600);
    if (fd < 0)
        return (-1);
    if (input)
    {
        while (input[len])
            len++;
        w = write(fd, input, len);
        if (w < 0)
            return (-1);
    }
    return (1);
}

void free_env(char **env)
{
    int i;

    for (i = 0; env[i]; i++)
    {
        free(env[i]);
    }
}
",7,351,220
"int  ClientProcess(float SharedMem[]);
int main()
{
     int    ShmID,p[2];
     pipe(p);
     float    *ShmPTR; 
     pid_t  pid; 
     int    status;
     int a[10],i;
     
     printf(""enter the 10 array elements\n"");
     for(i=0;i<10;i++)
     {
         scanf(""%d"",&a[i]);
     }
     ShmID = shmget(IPC_PRIVATE, 10*sizeof(int), IPC_CREAT | 0666); 
     if (ShmID < 0) {
          printf(""*** shmget error (server) ***\n"");
          exit(1);
     }

     printf(""Server has received a shared memory of 10 integers...\n"");
     ShmPTR = (float *) shmat(ShmID, NULL, 0);

    

     printf(""Server has attached the shared memory...\n"");
     
     for(i=0;i<10;i++)
     {
         ShmPTR[i]=a[i];
     }
     pid=fork();
     if (pid == 0) {
        float sum;
        sum=ClientProcess(ShmPTR);
        close(p[0]);
        write(p[1],&sum,sizeof(sum));
        close(p[1]);
          exit(0);
     }
     
     else{
         wait(&status);
         float sum,avg;
         close(p[1]);
         read(p[0],&sum,sizeof(sum));
         avg=sum/10;
        printf(""the average is %f\n"",avg);
        shmdt((void *) ShmPTR); 
        shmctl(ShmID, IPC_RMID, NULL);
     }
     return 0;
}
     
     
     
     int  ClientProcess(float  SharedMem[])
     {
     float sum=0,product=1;
     int i;
     
     for(i=0;i<10;i++)
     {
         sum+=(SharedMem[i]);
     }
     printf(""the sum is %f\n"",sum);
     
     for(i=0;i<10;i++)
     {
         product*=(SharedMem[i]);
     }
     printf(""the product are %f\n"",product);
     return (sum);
     }",8,352,616
"void choice_zero(char b[10]);
void choice_one(char b[10]);

int main(int argc,char *argv [])
{
    char s[10],b[10];
    int a,n;
    const int SIZE =4096;
    const char* name =""os"";
    int key,shmid;
    void* shmptr;
    if (argc<2)
    {printf(""enter the format ./'name',stringFFF,choice'1 or 0'"");}
    
    
    key=shm_open(name,O_CREAT|O_RDWR,0666);
      if (key < 0) {
          printf(""*** shmget error (server) ***\n"");
          exit(1);
     }
     ftruncate(key,SIZE);
    shmptr=mmap(0,SIZE,PROT_WRITE,MAP_SHARED,key,0);
    printf(""atached to the shared memory\n"");
    strcpy(s,argv[1]);
    n=strlen(s);
    sprintf(shmptr,""%d"",n-3);
    strcpy(b,s);
    a=atoi(argv[2]);
    if (a==0)
    {choice_zero(b);}
    else if(a==1)
    {choice_one(b);}
    else
    {return 0;}
    sleep(10);
    shmid=munmap(shmptr,SIZE);
    key=shm_unlink(name);
    
    return 1;
}
    
    
    
    void choice_one(char b[10])
{
    char p[10]=""SIOSFFF"";
    

        if (strcmp(b,p)==0)
        {printf(""the value is matching with SIOS\n"");}
        else{
        printf(""the  string is not matching with SIOS\n"");
        }
        
}
    
void choice_zero(char b[10])
{
        char r[10]=""MCISFFF"";
        if (strcmp(b,r)==0)
        {printf(""the value is matching with MCIS\n"");}
        else{
        printf(""the  string is not matching with MCIS\n"");
        }
}
    ",8,353,573
"#define SI 10

int sum_of_num(int array[],int n);
float average_of_num(int sum,int n);
float product_of_num(int array[],int n);

int i;



int main(int argc,char *argv[])
{
    int array[SI],n=0,sum;
    float product,average;


    while(atoi(argv[i])!=999)
    {
    for(i=1;i<SI;i++)
    {
        array[i]=atoi(argv[i]);
        n=n+1;
        if(atoi(argv[i])==999)
        break;

    }
    }
    
    for(i=1;i<n;i++){
    printf(""%d\n"",array[i]);}
    sum=sum_of_num(array,n);
    printf(""the sum of number is %d\n"",sum);
    average=average_of_num(sum,n);
    printf(""the average is %f\n"",average);
    product=product_of_num(array,n);
    printf(""product of number is %f"",product);
    return 0;
}



int sum_of_num(int array[],int n)
{
    int sum=0;
    for(i=1;i<n;i++)
    {
        sum+=array[i];
    }
    return sum;
}



float average_of_num(int sum,int n)
{
    float average=0;
    average=sum/(n-1);
    return average;
}



float product_of_num(int array[],int n)
{
    float product=1;
    for(i=1;i<n;i++)
    {
        product*=array[i];
    }
    return product;
}
",8,354,473
"#define SIZE 30

int main()
{
    char str[SIZE];
    int i,n=0,pid,fd[2],f1[2];
    pipe(fd);
    
    printf(""enter the string with in 30 letter or else change the string size  in pgm:\n"");
    fgets(str,sizeof(str),stdin);
    
    for(i=1;str[i]!='\0';i++)
        {
        n++;
        }
    printf(""the number of character in the string is %d\n"",n);
    
    
    
    pid=fork();
    if (pid==0)
    {
        
        printf(""inside the child process--------\n"");
        char b[SIZE],ch;
        int n,vowel=0,i=0;
        close(fd[1]);
        read(fd[0],b,sizeof(b));
        close(fd[0]);
        
        
        
        n=strlen(b);
        printf(""the string gets to the child using pipes is :%s\n"",b);
        while(i<=n)
        {
            ch=b[i];
            if(ch=='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u'||ch=='A'||ch=='E'||ch=='I'||ch=='O'||ch=='U')
            {vowel++;}
            i++;
        }
        printf(""the vowel count in the given string is %d"",vowel);
    }
    else{
        close(fd[0]);
    write(fd[1],str,sizeof(str));
    close(fd[1]);
        wait(NULL);
        printf(""\n********back to parent process******!"");
    }
        return 0;
}       
    
    

",8,355,456
"char words[15];

int main()
{
const char* name=""odd_even"";
const int SIZE=15*1024;
int shmid;
void* shmptr;
shmid=shm_open(name,O_CREAT|O_RDWR,0666);
      if (shmid< 0) {
          printf(""*** shmget error (server) ***\n"");
          exit(1);
     }
     ftruncate(shmid,SIZE);
     shmptr=mmap(0,SIZE,PROT_WRITE,MAP_SHARED,shmid,0);
     printf(""atached to the shared memory\n"");
     
    memset(words,0,sizeof(words));
    char ch;
    int wrd=0,i=0;
    FILE *fp,*fpe,*fpo;
    fp=fopen(""input.txt"",""r"");
    fpe=fopen(""even.txt"",""w+"");
    fpo=fopen(""odd.txt"",""w+"");

    while ((ch = fgetc(fp)) != EOF)
    {
    if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\0'||ch=='.')
    {
        wrd++;
        if((wrd%2)==0)
        {
            fprintf(fpe,""%s\n"",words);
        }
        else
        {
            fprintf(fpo,""%s\n"",words);
    }
    memset(words,0,sizeof(words));
    i=0;
    }
    else
    {
    words[i]=ch;
    i=i+1;
    }
    }
    fclose(fp);
    fclose(fpo);
    fclose(fpe);
    printf(""i am here\n"");
printf(""even file opening-----\n"");
fpe=fopen(""even.txt"",""r"");
sprintf(shmptr,""%s"",""even_file"");
shmptr+=15*sizeof(char);
    
while (fgets(words,sizeof(words),fpe)!=NULL)
{
    sprintf(shmptr,""%s"",words);
    shmptr+=15*sizeof(char);
}
fclose(fpe);

printf(""odd file opening-----\n"");
fpo=fopen(""odd.txt"",""r"");
sprintf(shmptr,""%s"",""odd_file"");
shmptr+=SIZE;
printf(""fine till\n"");
while (fgets(words,sizeof(words),fpo)!=NULL)
{
    sprintf(shmptr,""%s"",words);
    shmptr+=15*sizeof(char);
}
fclose(fpo);
sleep(15);
munmap(shmptr,SIZE);
shm_unlink(name);
return 0;
}




",8,356,710
"#include""shm_head.h""

#define SIZE 10

int main()
{
    key_t key;
    int array[10],i,n;
    int shmid;
    struct Memory *shmptr;
    key = ftok(""."", 'x');
    printf(""key:%d\n"",key);
    shmid = shmget(key, sizeof(struct Memory), IPC_CREAT | 0666);
     if (shmid < 0) {
          printf(""*** shmget error (server) ***\n"");
          exit(1);
     }
     
     shmptr=(struct Memory*)shmat(shmid,NULL,0);
     if ((int) shmptr == -1) {
          printf(""*** shmat error (server) ***\n"");
          exit(1);
     }
     
     printf(""enter the array elements less than 10 numbers and use 999 to stop the number\n"");
     while(array[i]!=999)
    {
    for(i=0;i<SIZE;i++)
    {
        scanf(""%d"",&array[i]);
        n=i;
        if(array[i]==999)
        break;

    }
    }
    float product=1,sum=0;
    for(i=0;i<n;i++)
    {
        sum+=array[i];
        product*=array[i];
    }
    shmptr->status  = NOT_READY;
    shmptr->arr[0]=sum;
    shmptr->arr[1]=product;
    shmptr->arr[2]=sum/n;
     shmptr->status=FILLED;
     printf(""please start the client in another window\n"");
     while (shmptr->status != TAKEN)
          sleep(1);
    shmdt((void *) shmptr);
    printf(""back to server and shared memory detached\n"");
     
     shmctl(shmid, IPC_RMID, NULL);
     exit(0);
}

     
     
     
     
     
     
     ",8,357,527
"#define SIZE 30

void *count_vowels(void *string);

int main()
{
    
    char str[SIZE];
    printf(""enter the string\n"");
    int i,n=0;
    fgets(str,sizeof(str),stdin);
    for(i=1;str[i]!='\0';i++)
        {
        n++;
        }
    printf(""the number of character in the string is %d\n"",n);
    pthread_t thread;
    pthread_create(&thread,NULL,count_vowels,&str);
    pthread_join(thread,NULL);
    
    return 0;
}

void *count_vowels(void *string)

{
    char *b=(char *)string;
    int n,i,vowel=0;
    char ch;
    n=strlen(b);
    while(i<=n)
        {
            ch=b[i];
            if(ch=='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u'||ch=='A'||ch=='E'||ch=='I'||ch=='O'||ch=='U')
            {vowel++;}
            i++;
        }
        printf(""the number of vowels in the strings is  %d\n"",vowel);
        return 0;
}",8,358,347
"struct tele
{
    char name[15],sir_name[15],number[15];
};
int main()
{
    FILE *fp;
    struct tele cust[10];
    struct tele temp;
    int choice,limit,beg=0,i,j,c,count=0,pid;
    while(1)
    {
        printf(""\ntelephone directory\n"");
        printf(""1.add\n"");
        printf(""2.display\n"");
        printf(""3.exit\n"");
        printf(""enter your choice\n"");
        scanf(""%d"",&choice);
        switch(choice)
        {
            case 1:
            fp=fopen(""details.txt"",""w+"");
                printf(""enter the number of customers\n"");
                scanf(""%d"",&limit);
                for(i=beg;i<limit+beg;i++)
                {
                    printf(""enter the name of customer no %d:\t"",i+1);
                    scanf(""%s"",cust[i].name);
                    printf(""enter the sir name:\t"");
                    scanf(""%s"",cust[i].sir_name);
                    printf(""enter the phone number\t"");
                    scanf(""%s"",cust[i].number);
                }
                beg=limit+beg;
                for(i=0;i<beg;i++)
                {
                    for(j=0;j<beg-1;j++)
                    {
                        c=strcmp(cust[j].name,cust[j+1].name);
                        if(c>0)
                        {
                            temp=cust[j];
                            cust[j]=cust[j+1];
                            cust[j+1]=temp;
                    }}
                }
                fclose(fp);
                
                break;
            case 2:
            pid=fork();
            
            if(pid==0)
            {
                printf(""entered in to the child  process!\n"");
            FILE *fp;
            
                printf(""\ncustomer details\n"");
                fp=fopen(""details.txt"",""r"");
                if(fp==NULL)
                {
                    printf(""error!"");
                    exit(1);
                }
                
                for (i=0;i<beg;i++)
                {
                    fread(&cust,sizeof(struct tele),1,fp);
                    printf(""(%d) %s %s\t :%s\n"",i+1,cust[i].name,cust[i].sir_name,cust[i].number);
                }
                fclose(fp);
            }
            else
            {
            wait(NULL);
            exit(0);
            }
            break;
            
            case 3:
                exit(0);
        }
    }
    return 0;
}
    

",8,359,707
"char words[15];
void odd_file_open();
void even_file_open();

int main()
{
    
    memset(words,0,sizeof(words));
    char ch;
    int wrd=0,i=0;
    FILE *fp,*fpe,*fpo;
    fp=fopen(""input.txt"",""r"");
    fpe=fopen(""even.txt"",""w+"");
    fpo=fopen(""odd.txt"",""w+"");

    while ((ch = fgetc(fp)) != EOF)
    {
    if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\0'||ch=='.')
    {
        wrd++;
        if((wrd%2)==0)
        {
            fprintf(fpe,""%s\n"",words);
        }
        else
        {
            fprintf(fpo,""%s\n"",words);
    }
    memset(words,0,sizeof(words));
    i=0;
    }
    else
    {
    words[i]=ch;
    i=i+1;
    }
    }
    fclose(fp);
    fclose(fpo);
    fclose(fpe);
    int pid1,pid2;
    pid1=fork();
    if (pid1==0)
    {
        printf(""inside first child\n"");
        even_file_open();
    }
    else{
        wait(NULL);
        pid2=fork();
    if (pid2==0)
       {
        printf(""inside second child\n"");
        odd_file_open();
        }
        else{
            wait(NULL);
            printf(""i am done\n"");
        }
    }
        return 0;
}
        
void even_file_open()
{
    FILE *fpe;
printf(""even file opening-----\n"");
fpe=fopen(""even.txt"",""r"");
while (fgets(words,sizeof(words),fpe)!=NULL)
{
    printf(""\t%s"",words);
}
fclose(fpe);
}
void odd_file_open()
{
    FILE *fpo;
printf(""odd file opening-----\n"");
fpo=fopen(""odd.txt"",""r"");
while (fgets(words,sizeof(words),fpo)!=NULL)
{
    printf(""\t%s"",words);
}
fclose(fpo);
}

",8,360,609
"struct tele
{
    char name[15],sir_name[15],number[15];
};
int main()
{
    FILE *fp;
    struct tele cust[50];
    struct tele temp;
    int choice,limit,beg=0,i,j,c,count=0;
    while(1)
    {
        printf(""\ntelephone directory\n"");
        printf(""1.add\n"");
        printf(""2.display\n"");
        printf(""3.exit\n"");
        printf(""enter your choice\n"");
        scanf(""%d"",&choice);
        switch(choice)
        {
            case 1:
            fp=fopen(""details.txt"",""w+"");
                printf(""enter the number of customers\n"");
                scanf(""%d"",&limit);
                for(i=beg;i<limit+beg;i++)
                {
                    printf(""enter the name of customer no %d:\t"",i+1);
                    scanf(""%s"",cust[i].name);
                    printf(""enter the sir name:\t"");
                    scanf(""%s"",cust[i].sir_name);
                    printf(""enter the phone number\t"");
                    scanf(""%s"",cust[i].number);
                }
                beg=limit+beg;
                for(i=0;i<beg;i++)
                {
                    for(j=0;j<beg-1;j++)
                    {
                        c=strcmp(cust[j].name,cust[j+1].name);
                        if(c>0)
                        {
                            temp=cust[j];
                            cust[j]=cust[j+1];
                            cust[j+1]=temp;
                    }}
                }
                fclose(fp);
                
                break;
            case 2:
                printf(""\ncustomer details\n"");
                fp=fopen(""details.txt"",""r"");
                if(fp==NULL)
                {
                    printf(""error!"");
                    exit(1);
                }
                
                for (i=0;i<beg;i++)
                {
                    fread(&cust,sizeof(struct tele),1,fp);
                    printf(""(%d) %s %s\t :%s\n"",i+1,cust[i].name,cust[i].sir_name,cust[i].number);
                }
                fclose(fp);
                break;
            case 3:
                exit(0);
        }
    }
    return 0;
}
    

",8,361,636
"#define SI 10

int i, array[SI],n=0;
float sum_of_num();
float product_of_num();



int main()
{
    int fd1[2],fd2[2];
    pipe(fd1);
    pipe(fd2);
    
    printf(""enter the array elements\n"");
    while(array[i]!=999)
    {
    for(i=0;i<SI;i++)
    {
        scanf(""%d"",&array[i]);
        n=i;
        if(array[i]==999)
        break;

    }
    }
    pid_t pid;
    pid=fork();
    if(pid==0)
    {
        printf(""inside child-----\n"");
        close(fd1[0]);
        close(fd2[0]);
        float product,sum;
        sum=sum_of_num();
        printf(""the sum is %f\n"",sum);
        write(fd1[1],&sum,sizeof(sum));
        product=product_of_num();
        printf(""the product is %f\n"",product);
        write(fd2[1],&product,sizeof(product));

        close(fd1[1]);
        close(fd2[1]);      
        
    }
    else
    {
        wait(NULL);
        printf(""-----inside parent process------\n"");
        close(fd1[1]);
        close(fd2[1]);
        float avg=0,sum,product;
        read(fd1[0],&sum,sizeof(sum));
        read(fd2[0],&product,sizeof(product));

        printf(""\tthe sum is %f\n"",sum);
        avg=sum/SI;
        printf(""\tthe average is %f\n"",avg);
        printf(""\tthe product is %f\n"",product);

        close(fd1[0]);
        close(fd2[0]);
    }
        
        return 0;
}

        
    float product_of_num()
{
    float product=1;
    for(i=0;i<n;i++)
    {
        product*=array[i];
    }
    return product;
}


float sum_of_num()
{
    float sum=0;
    for(i=0;i<n;i++)
    {
        sum+=array[i];
    }
    return sum;
}",8,362,610
"#define FILE_SIZE 100
#define LINE 20
int read_lines(char s[FILE_SIZE]);
int main()
{
    FILE *f;
    char s[FILE_SIZE];
    printf(""enter the source file path\n"");
    scanf(""%s"",s);
    read_lines(s);
    return 0;
}

int read_lines(char s[FILE_SIZE])
{
    FILE *f;
    int words,lines;
    char ch;
    f=fopen(s,""r"");
    if (f == NULL) 
    { 
        printf(""Could not open file""); 
        return 0; 
    }
    words = lines = 0;
    while ((ch = fgetc(f)) != EOF)
    {

        
        if (ch == '\n' || ch == '\0')
            lines++;

        
        if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\0')
            words++;
    }
    printf(""\tthe number of lines are :%d\n"",lines);
    printf(""\tthe number of words are :%d\n"",words);    
    fclose(f);
    return 1;
}
    
    

    
    

",8,363,315
"#define SI 10


int array[SI],i;
float sum_of_num();
float product_of_num();

int main()
{
    int pid,fd[2];
    pipe(fd);
    printf(""enter the 10 values to be calculated\n"");
    for(i=0;i<SI;i++)
    {
        scanf(""%d"",&array[i]);
    }
    pid=fork();
    if (pid==0)
    {
        printf(""inside child-----\n"");
        close(fd[0]);
        float product,sum;
        sum=sum_of_num();
        printf(""the sum is %f\n"",sum);
        write(fd[1],&sum,sizeof(sum));
        product=product_of_num();
        printf(""the product is %f\n"",product);
close(fd[1]);       
    }
    else
    {
        wait(NULL);
        printf(""-----inside parent process------\n"");
        close(fd[1]);
        float avg=0,sum;
        read(fd[0],&sum,sizeof(sum));
        printf(""\tthe sum is %f\n"",sum);
        avg=sum/SI;
        printf(""\tthe average is %f\n"",avg);
    }
    return 0;
}
    
        
    float product_of_num()
{
    float product=1;
    for(i=0;i<SI;i++)
    {
        product*=array[i];
    }
    return product;
}


float sum_of_num()
{
    float sum=0;
    for(i=0;i<SI;i++)
    {
        sum+=array[i];
    }
    return sum;
}


    
        
        

",8,364,449
"typedef struct dates{
    int day,month,year;
}date;

void comp_dat(date d1,date d2);

int main()
{
    date d1,d2;
    printf(""enter the date 1 in format DD-MM-YYYY:\t"");
    scanf(""%d-%d-%d"",&d1.day,&d1.month,&d1.year);
    printf(""enter the date 2 in format DD-MM-YYYY:\t"");
    scanf(""%d-%d-%d"",&d2.day,&d2.month,&d2.year);
    comp_dat(d1,d2);
    return 0;
}


void comp_dat(date d1,date d2)
{
    if((d1.year==d2.year)&&(d1.month==d2.month)&&(d1.day==d2.day))
    {printf(""\nBoth the dates are same"");}
    else if(d1.year>d2.year||(d1.year==d2.year&&d1.month>d2.month)||(d1.year==d2.year&&d1.month==d2.month&&d1.day>d2.day))
    {printf(""\nThe latest date is %d-%d-%d"",d1.day,d1.month,d1.year);}
    else
        {printf(""\nThe latest date is %d-%d-%d"",d2.day,d2.month,d2.year);}
}
    ",8,365,379
"#define FILE_SIZE 100

void *read_lines(void *para);
void *read_char(void *para);
char s[FILE_SIZE];
int main()
{
    pthread_t thread1,thread2;
    printf(""enter the source file path\n"");
    scanf(""%s"",s);
    pthread_create(&thread1,NULL,read_char,NULL);
    pthread_join(thread1,NULL);
    pthread_create(&thread1,NULL,read_lines,NULL);
    pthread_join(thread1,NULL);
    
    return 0;
}

void *read_char(void *para)
{
    FILE *f;
    int character=0;
    char ch;
    f=fopen(s,""r"");
    if (f == NULL) 
    { 
        printf(""Could not open file""); 
        return 0; 
    }
    while ((ch = fgetc(f)) != EOF)
    {
        if (ch != ' ' || ch != '\t' || ch != '\n' || ch != '\0'|| ch!='.')
        character++;
    }
    printf(""the character count is %d\n"",character);
    fclose(f);
    pthread_exit(NULL);
}



void *read_lines(void *para)
{
    FILE *f;
    int words;
    char ch;
    f=fopen(s,""r"");
    if (f == NULL) 
    { 
        printf(""Could not open file""); 
        return 0; 
    }
    words = 0;
    while ((ch = fgetc(f)) != EOF)
    {
        
        if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\0'|| ch=='.')
            words++;
    }
    printf(""the number of words are :%d\n"",words);  
    fclose(f);
}
    ",8,366,487
"char words[15];
void *odd_file_open(void *para);
void *even_file_open(void *para);

int main()
{
    
    memset(words,0,sizeof(words));
    char ch;
    int wrd=0,i=0;
    FILE *fp,*fpe,*fpo;
    pthread_t thread1,thread2;
    fp=fopen(""input.txt"",""r"");
    fpe=fopen(""even.txt"",""w+"");
    fpo=fopen(""odd.txt"",""w+"");

    while ((ch = fgetc(fp)) != EOF)
    {
    if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\0'||ch=='.')
    {
        wrd++;
        if((wrd%2)==0)
        {
            fprintf(fpe,""%s\n"",words);
        }
        else
        {
            fprintf(fpo,""%s\n"",words);
    }
    memset(words,0,sizeof(words));
    i=0;
    }
    else
    {
    words[i]=ch;
    i=i+1;
    }
    }
    fclose(fp);
    fclose(fpo);
    fclose(fpe);
    pthread_create(&thread1,NULL,even_file_open,NULL);
    pthread_join(thread1,NULL);
    pthread_create(&thread2,NULL,even_file_open,NULL);
    pthread_join(thread2,NULL);
    printf(""\ti am done:) \n"");
    
        return 0;
}
        
void *even_file_open(void *para)
{
    FILE *fpe;
printf(""even file opening-----\n"");
fpe=fopen(""even.txt"",""r"");
while (fgets(words,sizeof(words),fpe)!=NULL)
{
    printf(""\t%s"",words);
}
fclose(fpe);
}
void *odd_file_open(void *para)
{
    FILE *fpo;
printf(""odd file opening-----\n"");
fpo=fopen(""odd.txt"",""r"");
while (fgets(words,sizeof(words),fpo)!=NULL)
{
    printf(""\t%s"",words);
}
fclose(fpo);
}

",8,367,591
"#define SI 10



int i;

int main()
{ 
FILE *fp;
int n,sum=0;
float product=1,average;
int array[SI];

fp=fopen(""file.txt"",""w+"");
printf(""inside the file called 'file.txt'"");
printf(""\n ------writing to the file------\n"");
printf(""enter the  number of elements in array\n"");
scanf(""%d"",&n);
printf(""enter the elements in the array\n"");
for(i=0;i<n;i++)
{
    scanf(""%d"",&array[i]);
}

    for(i=0;i<n;i++)
    {
        sum=sum+array[i];
    }


    average=sum/n;
    
    for(i=0;i<n;i++)
    {
        product=product*array[i];
    }

fclose(fp);

fp=fopen(""file.txt"",""r"");
printf(""\n----reading from the file----\n"");
printf(""the array elements are \n"");
for(i=0;i<n;i++)
{
    printf(""%d\t"",array[i]);
}
printf(""\nthe sum of number is %d\n"",sum);
printf(""the average is %f\n"",average);
printf(""product of number is %f"",product);
fclose(fp);


return 0;
}",8,368,356
"#define SIZE 10
void *sum_array(void *a[SIZE]);
void* product_of_elements(void* a[SIZE]);
pthread_mutex_t mutex;
int  array[SIZE];
    int i;
int main()
{
    
    printf(""enter the array numbers\n"");
    for(i=0;i<SIZE;i++)
    {
        scanf(""%d"",&(array[i]));
    }
    pthread_t thread1, thread2;
    printf(""the thread is created\n"");
    pthread_create(&thread1, NULL, sum_array, &array);
    pthread_create(&thread2, NULL, product_of_elements,&array );
    
    
    pthread_join(thread1,NULL);
    pthread_join (thread2,NULL);
    
    
    pthread_mutex_destroy(&mutex);
    
return 0;
}


void* sum_array(void *a[SIZE])
{
    pthread_mutex_lock(&mutex);
    float sum=0;
    int *ar=(int *)a;
    printf(""inside the first thread\n"");
    for(i=0;i<SIZE;i++)
    {
        sum += ar[i];
        printf(""%f\t"",sum);
    }
    printf(""the sum is %f\n"",sum);
    float average;
    average=sum/10;
    printf(""the average is %f\n"",average);
    pthread_mutex_unlock(&mutex);
}

void* product_of_elements(void* a[SIZE])
{
    float product=1;
    int* ar=(int*) a;
    for(i=0;i<SIZE;i++)
    {
         product =ar[i] * product;
    }
    printf(""product=%f\n"",product);
}",8,369,463
"int main()
{
const char* name=""odd_even"";
const int SIZE=15*1024;
int shmid;
char words;
void* shmptr;
shmid=shm_open(name,O_CREAT|O_RDWR,0666);
      if (shmid< 0) {
          printf(""*** shmget error (server) ***\n"");
          exit(1);
     }
     ftruncate(shmid,SIZE);
     shmptr=mmap(0,SIZE,PROT_WRITE,MAP_SHARED,shmid,0);
     printf(""inside client\n"");
     while(1)
     {
         puts(shmptr);
         shmptr+=15*sizeof(char);
     }
     shm_unlink(name);
     return 0;
}",8,370,208
"#include""shm_head.h""

#define SIZE 10

int main()
{
    key_t key;
    int shmid,i;
    struct Memory *shmptr;
    key = ftok(""."", 'x');
    printf(""key:%d\n"",key);
    shmid = shmget(key, sizeof(struct Memory), IPC_CREAT | 0666);
     if (shmid < 0) {
          printf(""*** shmget error (server) ***\n"");
          exit(1);
     }
     shmptr=(struct Memory*)shmat(shmid,NULL,0);
     if ((int) shmptr == -1) {
          printf(""*** shmat error (server) ***\n"");
          exit(1);
     }
     printf(""client attached to shared memory\n"");
     printf(""sum is %f\n"",shmptr->arr[0]);
     printf(""product is %f\n"",shmptr->arr[1]);
     printf(""average is %f\n"",shmptr->arr[2]);
     shmptr->status=TAKEN;
     shmdt((void*)shmptr);
     exit(0);
}

    
     ",8,371,301
"#define FILESI 20
#define GIVE 0
#define TAKE 1

int read_count(char s[FILESI]);
 int n,m;
int main()
{
    const int SIZE=4096;
    const char* name=""vowels"";
     int     shmid;
     void* shmptr;
     char s[FILESI];
    
     printf(""enter the file path\n"");
     scanf(""%s"",s);
     read_count(s);
     shmid=shm_open(name,O_CREAT|O_RDWR,0666);
     if(shmid<0){
         perror(""shmget"");
         exit(1);
     }
     ftruncate(shmid,SIZE);
     shmptr=mmap(0,SIZE,PROT_WRITE,MAP_SHARED,shmid,0);
    printf(""shared mym attached\n"");
    sprintf(shmptr,""%d"",m);
    shmptr +=sizeof(int);
    
    sprintf(shmptr,""%d"",n);
    shmptr +=sizeof(int);
    
     printf(""open client\n"");
     
     
     sleep(10);
     
     munmap(shmptr,SIZE);
     shm_unlink(name);
     return 0;
}

int read_count(char s[FILESI])
{
    FILE(*fp);
    fp=fopen(s,""r"");
    char ch;
    if (fp==NULL){
        printf(""error in opening file\n"");
        return 0;
    }
    n=m=0;
    while((ch=fgetc(fp))!=EOF)
    {
        n++;
        if (ch=='\n'||ch=='\t'||ch=='.'||ch==' '||ch=='\0')
        m++;
    }
    
    
    fclose(fp);
    return 1;
}",8,372,487
"#define SIZE 10

int n;
void choice_zero(char b[SIZE]);
void choice_one(char b[SIZE]);

int main(int argc,char *argv [])
{
    char s[SIZE],b[SIZE];
    int a,p[2],pid;
    pipe(p);
    if (argc<2)
    {printf(""enter the format ./'name',stringFFF,choice'1 or 0'"");}
    strcpy(s,argv[1]);
    strcpy(b,s);
    a=atoi(argv[2]);
    if (a==0)
    {choice_zero(b);}
    else if(a==1)
    {choice_one(b);}
    else
    {return 1;}
    printf(""writing to child\n"");

    pid=fork();
    if(pid==0)
    {printf(""inside  child-------\n"");
    char c[SIZE];
    close(p[1]);
    read(p[0],c,10);
    n=strlen(c);
    printf(""the string count is %d\n"",(n-3));
    close(p[0]);
    }
    else{
    close(p[0]);
    write(p[1],s,10);
    close(p[1]);
    printf(""writed\n"");
        wait(NULL);
    }
    return 0;
}

void choice_one(char b[SIZE])
{
    char p[SIZE]=""SIOSFFF"";
    

        if (strcmp(b,p)==0)
        {printf(""the value is matching with SIOS\n"");}
        else{
        printf(""the  string is not matching with SIOS\n"");}
        
}
    
void choice_zero(char b[SIZE])
{
        char r[SIZE]=""MCISFFF"";
        if (strcmp(b,r)==0)
        {printf(""the value is matching with MCIS\n"");}
        else{
        printf(""the  string is not matching with MCIS\n"");
        }
}   
        ",8,373,522
"#define SIZE 10

void choice_zero(char b[SIZE]);
void choice_one(char b[SIZE]);

int n;

int main(int argc,char *argv [])
{
    char s[SIZE],b[SIZE];
    int a,i;
    if (argc<2)
    {printf(""enter the format ./'name',stringFFF,choice'1 or 0'"");}
    strcpy(s,argv[1]);
    n=strlen(s);
    
    
    strcpy(b,s);
    a=atoi(argv[2]);
    if (a==0)
    {choice_zero(b);}
    else if(a==1)
    {choice_one(b);}
    else
    {printf(""\nthe length of the given string is %d"",(n-3));}
    return 0;
}

void choice_one(char b[SIZE])
{
    char p[4]=""SIOS"";
    

        if (strncmp(b,p,4)==0)
        {printf(""the value is matching with SIOS\n"");}
        else{
        printf(""the  string is not matching with SIOS\n"");
        printf(""the length of given string is %d"",n-3);}
}
    
void choice_zero(char b[SIZE])
{
        char r[4]=""MCIS"";
        if (strncmp(b,r,4)==0)
        {printf(""the value is matching with MCIS\n"");}
        else{
        printf(""the  string is not matching with MCIS\n"");
        printf(""the length of given string is %d"",n-3);}
}   
        ",8,374,418
"#include ""get_next_line.h""

void        surrend_by_spaces(char **map)
{
    int i;
    int j;

    i = 0;
    j = 0;
    while (map[i])
    {
        while (j < g_map_width + 2)
            j++;
        map[i][j] = '\0';
        i++;
        j = 0;
    }
    i = -1;
    while (map[++i])
        map[i][0] = ' ';
    i = -1;
    while (map[0][++i])
        map[0][i] = ' ';
    i = -1;
    while (map[g_map_height][++i])
        map[g_map_height + 1][i] = ' ';
    i = -1;
    while (map[++i])
        map[i][g_map_width + 1] = ' ';
}

void        fill_map(char **map)
{
    int i;
    int j;
    int x;
    int y;

    i = 1;
    j = 1;
    x = 0;
    y = 0;
    while (x < g_map_height)
    {
        while (y < g_map_width)
        {
            if (y < ft_strlen(g_map_array[x]))
                map[i][j] = g_map_array[x][y];
            else
                map[i][j] = ' ';
            y++;
            j++;
        }
        i++;
        x++;
        j = 1;
        y = 0;
    }
}

void        longuest_line(void)
{
    int i;
    int j;
    int max;

    i = 0;
    j = 0;
    max = 0;
    while (g_map_array[i])
    {
        while (g_map_array[i][j] != '\0')
            j++;
        i++;
        if (j > max)
            max = j;
        j = 0;
    }
    g_map_width = max;
}
",9,375,552
"#include ""get_next_line.h""

int     c_w(char *str, char c)
{
    int i;
    int j;

    j = 0;
    i = 0;
    while (str[i] != '\0')
    {
        while (str[i] == c && str[i] != '\0')
        {
            i++;
        }
        if (str[i] != c && str[i] != '\0')
            j++;
        while (str[i] != c && (str[i] != '\0'))
            i++;
    }
    return (j);
}

char    **freethenipples(char **s)
{
    int i;

    i = 0;
    while (s[i])
    {
        free(s[i]);
        i++;
    }
    free(s);
    return (NULL);
}

int     s_p(char *s, char c)
{
    int i;

    i = 0;
    while (s[i] == c && s[i])
        i++;
    return (i);
}

int     len_str(char *s, int i, char c)
{
    int len;

    len = 0;
    while (s[i] != c && s[i])
    {
        len++;
        i++;
    }
    return (len);
}

char    **ft_split(char *s, char c)
{
    char    **cpy;
    int     len;
    int     k;
    int     i;
    int     start;

    k = -1;
    i = 0;
    if (!s || !(cpy = (char**)malloc(sizeof(char*) * (c_w(s, c) + 1))))
        return (0);
    while (s[i])
    {
        len = 0;
        i += s_p(&s[i], c);
        start = i;
        len = len_str(s, i, c);
        i += len;
        if (len)
            if (!(cpy[++k] = ft_substr(s, start, len)))
                return (freethenipples(cpy));
    }
    cpy[++k] = 0;
    return (cpy);
}
",9,376,577
"#include ""get_next_line.h""

void        player_init(char c, int x, int y)
{
    if (g_peeinit)
    {
        ft_putstr(""Error:\nthe map has more than one player\n"");
        exit(0);
    }
    else
    {
        g_tile_size = 16;
        g_player.x = (x * g_tile_size) + (g_tile_size / 2);
        g_player.y = (y * g_tile_size) + (g_tile_size / 2);
        g_peeinit = 1;
        if (c == 'N')
            g_player.rotation_angle = 270 * (M_PI / 180);
        else if (c == 'S')
            g_player.rotation_angle = 90 * (M_PI / 180);
        else if (c == 'E')
            g_player.rotation_angle = 0;
        else if (c == 'W')
            g_player.rotation_angle = M_PI;
        g_player.fov = 60 * (M_PI / 180);
        g_player.turn_direction = 0;
        g_player.walk_direction = 0;
        g_player.move_speed = 6;
        g_player.rotation_speed = 4 * (M_PI / 180);
    }
}

void        array_height(void)
{
    int i;

    i = 0;
    while (g_map_array[i])
        i++;
    g_map_height = i;
}

char        **map_manager(void)
{
    char    **map_array;
    int     i;
    int     j;

    j = 0;
    i = 0;
    map_array = (char**)malloc((g_map_height + 3) * sizeof(char*));
    while (i < g_map_height + 2)
    {
        map_array[i] = (char*)malloc((g_map_width + 3) * sizeof(char));
        i++;
    }
    map_array[i] = NULL;
    surrend_by_spaces(map_array);
    fill_map(map_array);
    map_errors(map_array);
    if (g_player.x == -1 || g_player.y == -1)
    {
        ft_putstr(""Error:\nPlayer or map missing\n"");
        exit(0);
    }
    return (map_array);
}

void        map_errors(char **map)
{
    int i;
    int j;

    i = 0;
    j = 0;
    while (++i <= g_map_height)
    {
        while (++j <= g_map_width)
        {
            if (map[i][j] != '1' && map[i][j] != '0' && map[i][j] != '2'
            && map[i][j] != 'N' && map[i][j] != 'W' && map[i][j] != 'E'
            && map[i][j] != 'S' && map[i][j] != ' ')
                error_redirect(0);
            else if (map[i][j] != ' ' && map[i][j] != '1')
            {
                if (map[i][j + 1] == ' ' || map[i][j - 1] == ' '
                || map[i + 1][j] == ' ' || map[i - 1][j] == ' ')
                    error_redirect(1);
                if ((map[i][j] == 'N' || map[i][j] == 'S' ||
                map[i][j] == 'E' || map[i][j] == 'W') && !g_peeinit)
                    player_init(map[i][j], j - 1, i - 1);
            }
        }
        j = 0;
    }
}

void        error_redirect(int error)
{
    if (error == 0)
        ft_putstr(""Error:\nmap has an unknown character\n"");
    else if (error == 1)
        ft_putstr(""Error:\nthe map isnt closed"");
    exit(0);
}
",9,377,1099
"#include ""get_next_line.h""

int     all_params(void)
{
    if (g_width != 0 && g_height != 0 && g_we != NULL && g_no != NULL
        && g_no != NULL && g_ea != NULL && g_fr != -1 &&
        g_fr != -1 && g_fg != -1 && g_fb != -1 && g_cr != -1 &&
        g_cg != -1 && g_cb != -1)
        return (1);
    return (0);
}

int     wrong_resolution(int width, int height)
{
    int w;
    int h;

    w = width;
    h = height;
    if (width > 2560)
        w = 2560;
    if (height > 1400)
        h = 1400;
    if (width <= 100 || height <= 100)
    {
        ft_putstr(""Error:\nresolution is < 100 px!\n"");
        exit(0);
    }
    get_resolution(w, h);
    return (1);
}

void    get_resolution(int width, int height)
{
    g_width = width;
    g_height = height;
}

void    get_frgb(int r, int g, int b)
{
    g_fr = r;
    g_fg = g;
    g_fb = b;
}

void    get_crgb(int r, int g, int b)
{
    g_cr = r;
    g_cg = g;
    g_cb = b;
}
",9,378,420
"#include ""get_next_line.h""

void    texture_error(int error)
{
    if (error == 0)
        ft_putstr(""Error\ndouble inclusion\n"");
    else if (error == 1)
        ft_putstr(""Error:\nWrong number of params/invalid file in NO!\n"");
    else if (error == 2)
        ft_putstr(""Error:\nWrong number of params/invalid file in SO!\n"");
    else if (error == 3)
        ft_putstr(""Error:\nWrong number of params/invalid file in WE!\n"");
    else if (error == 4)
        ft_putstr(""Error:\nWrong number of params/invalid file in EA!\n"");
    else if (error == 5)
        ft_putstr(""Error:\nWrong number of params/invalid file in S!\n"");
    exit(0);
}

void    free_this_shit(char *str, char **s)
{
    free(str);
    freethenipples(s);
}

void    wrong_file(char *file, int type)
{
    int re;

    if ((re = open(file, O_RDONLY) > 0) && type == 1)
        g_no = ft_strdup(file);
    else if ((re = open(file, O_RDONLY) <= 0) && type == 1)
        texture_error(1);
    if ((re = open(file, O_RDONLY) > 0) && type == 2)
        g_so = ft_strdup(file);
    else if ((re = open(file, O_RDONLY) <= 0) && type == 2)
        texture_error(2);
    if ((re = open(file, O_RDONLY) > 0) && type == 3)
        g_we = ft_strdup(file);
    else if ((re = open(file, O_RDONLY) <= 0) && type == 3)
        texture_error(3);
    if ((re = open(file, O_RDONLY) > 0) && type == 4)
        g_ea = ft_strdup(file);
    else if ((re = open(file, O_RDONLY) <= 0) && type == 4)
        texture_error(4);
    if ((re = open(file, O_RDONLY) > 0) && type == 5)
        g_s = ft_strdup(file);
    else if ((re = open(file, O_RDONLY) <= 0) && type == 5)
        texture_error(4);
}
",9,379,668
"#include ""get_next_line.h""

int     readline(void)
{
    int     fd;
    char    *line;

    fd = open(""map.cub"", O_RDONLY);
    global_init();
    while (get_next_line(fd, &line))
    {
        if (!all_params())
        {
            if (*line != '\0')
                routing(line);
        }
        else
            routing(line);
        free(line);
    }
    free(line);
    return (0);
}

void    routing(char *line)
{
    if (line[0] == 'R' && line[1] == ' ')
        get_re(line);
    else if (line[0] == 'N' && line[1] == 'O' && line[2] == ' ')
        get_no(line);
    else if (line[0] == 'S' && line[1] == 'O' && line[2] == ' ')
        get_so(line);
    else if (line[0] == 'W' && line[1] == 'E' && line[2] == ' ')
        get_we(line);
    else if (line[0] == 'E' && line[1] == 'A' && line[2] == ' ')
        get_ea(line);
    else if (line[0] == 'S' && line[1] == ' ')
        get_s(line);
    else if (line[0] == 'F' && line[1] == ' ')
        get_f(line);
    else if (line[0] == 'C' && line[1] == ' ')
        get_c(line);
    else if (all_params())
        readmap(line);
    else
    {
        ft_putstr(""one or many parametres format is wrong or missing!\n"");
        exit(0);
    }
}

int     main(void)
{
    char **ugh;

    g_player.x = -1;
    g_player.y = -1;
    readline();
    manage_map();
    longuest_line();
    array_height();
    ugh = map_manager();
}
",9,380,548
"#include ""get_next_line.h""

void    check_crgb(char **colors, int cc, int cw)
{
    if (g_cr != -1 && g_cg != -1 && g_cb != -1)
    {
        ft_putstr(""Error\ndouble includion\n"");
        exit(0);
    }
    if (cc != 3 || cw != 2)
    {
        ft_putstr(""Error\nWrong number of parametres in ceiling colors!\n"");
        exit(0);
    }
    else if (!array_is_rgb(colors))
    {
        ft_putstr(""Error\nWrong parametres in ceiling colors!\n"");
        exit(0);
    }
    else
        get_crgb(atoi(&colors[0][0]), atoi(&colors[1][0]), atoi(&colors[2][0]));
}

void    check_frgb(char **colors, int cc, int cw)
{
    if (g_cr != -1 && g_cg != -1 && g_cb != -1)
    {
        ft_putstr(""Error\ndouble includion\n"");
        exit(0);
    }
    if (cc != 3 || cw != 2)
    {
        ft_putstr(""Error\nWrong number of parametres in floor colors!\n"");
        exit(0);
    }
    else if (!array_is_rgb(colors))
    {
        ft_putstr(""Error\nWrong parametres in floor colors!\n"");
        exit(0);
    }
    else
        get_frgb(atoi(&colors[0][0]), atoi(&colors[1][0]), atoi(&colors[2][0]));
}
",9,381,434
"#include ""get_next_line.h""


void        my_mlx_pixel_put(t_data *data, int x, int y, int color)
{
    char    *dst;

    dst = data->addr + (y * data->line_length + x * (data->bits_per_pixel / 8));
    *(unsigned int*)dst = color;
}

void        draw_cube(int x, int y)
{
    int i;
    int j;

    i = x;
    j = y;
    while (j < g_tile_size + y)
    {
        while (i < g_tile_size + x)
        {
            my_mlx_pixel_put(&g_image, j, i, 0xFF0000);
            i++;
        }
        i = x;
        j++;
    }
}

void        norm_it(char **meh)
{
    int e;
    int f;
    int x;
    int y;

    e = 0;
    f = 0;
    x = 0;
    y = 0;
    while (meh[e])
    {
        while (meh[e][f])
        {
            if (meh[e][f] == '1')
                draw_cube(y, x);
            f++;
            x = x + g_tile_size;
        }
        f = 0;
        e++;
        x = 0;
        y = y + g_tile_size;
    }
}

void        draw_map(void)
{
    g_image.img = mlx_new_image(g_vars.mlx, g_width, g_height);
    g_image.addr = mlx_get_data_addr(g_image.img, &g_image.bits_per_pixel,
                    &g_image.line_length, &g_image.endian);
    norm_it(g_map_array);
}

int         has_wall(int x, int y)
{
    int ughx;
    int ughy;

    ughx = floor(x / g_tile_size);
    ughy = floor(y / g_tile_size);
    if (g_map_array[ughy][ughx] == '1')
        return (1);
    else
        return (0);
}
",9,382,611
"#include ""get_next_line.h""

void        surrend_by_spaces(char **map)
{
    int i;
    int j;

    i = 0;
    j = 0;
    while (map[i])
    {
        while (j < g_map_width + 2)
            j++;
        map[i][j] = '\0';
        i++;
        j = 0;
    }
    i = -1;
    while (map[++i])
        map[i][0] = ' ';
    i = -1;
    while (map[0][++i])
        map[0][i] = ' ';
    i = -1;
    while (map[g_map_height][++i])
        map[g_map_height + 1][i] = ' ';
    i = -1;
    while (map[++i])
        map[i][g_map_width + 1] = ' ';
}

void        fill_map(char **map)
{
    int i;
    int j;
    int x;
    int y;

    i = 1;
    j = 1;
    x = 0;
    y = 0;
    while (x < g_map_height)
    {
        while (y < g_map_width)
        {
            if (y < ft_strlen(g_map_array[x]))
                map[i][j] = g_map_array[x][y];
            else
                map[i][j] = ' ';
            y++;
            j++;
        }
        i++;
        x++;
        j = 1;
        y = 0;
    }
}

void        longuest_line(void)
{
    int i;
    int j;
    int max;

    i = 0;
    j = 0;
    max = 0;
    while (g_map_array[i])
    {
        while (g_map_array[i][j] != '\0')
            j++;
        i++;
        if (j > max)
            max = j;
        j = 0;
    }
    g_map_width = max;
}
",9,383,552
"#include ""get_next_line.h""

int     str_is_digits(char *c)
{
    int i;

    i = 0;
    if (!c)
        return (0);
    while (c[i])
    {
        if (!ft_isdigit(c[i]))
            return (0);
        i++;
    }
    return (1);
}

int     array_is_rgb(char **colors)
{
    int i;

    i = 0;
    while (colors[i])
    {
        if (str_is_digits(colors[i]))
        {
            if (!(atoi(colors[i]) <= 255) || !(atoi(colors[i]) >= 0))
            {
                ft_putstr(""Error\n Wrong colors parametres!"");
                exit(0);
            }
        }
        else
            return (0);
        i++;
    }
    return (1);
}

void    get_s(char *line)
{
    char    **par;
    char    *str;
    int     re;

    re = 0;
    par = ft_split(line, ' ');
    str = ft_strdup("""");
    if (g_s != NULL)
        texture_error(0);
    if (c_w(line, ' ') != 2)
    {
        while (++re < c_w(line, ' '))
        {
            str = ft_strjoin(str, strdup(&par[re][0]));
            if (re != c_w(line, ' ') - 1)
                str = ft_strjoin(str, strdup("" ""));
        }
        if ((re = open(str, O_RDONLY) < 0))
            texture_error(5);
        else
            g_s = ft_strdup(str);
    }
    else
        wrong_file(&par[1][0], 5);
    free_this_shit(str, par);
}

void    get_f(char *line)
{
    char    **par;
    char    **colors;
    int     cc;
    int     cw;

    cw = 0;
    par = ft_split(line, ' ');
    cc = 0;
    colors = ft_split(&par[1][0], ',');
    while (line[cc])
    {
        if (line[cc] == ',')
            cw++;
        cc++;
    }
    if (cw != 2)
    {
        ft_putstr(""Error:\n Wrong floor RGB"");
        exit(0);
    }
    cw = c_w(line, ' ');
    cc = c_w(&par[1][0], ',');
    freethenipples(par);
    check_frgb(colors, cc, cw);
    freethenipples(colors);
}

void    get_c(char *line)
{
    char    **par;
    char    **colors;
    int     cc;
    int     cw;

    cw = 0;
    par = ft_split(line, ' ');
    cc = 0;
    colors = ft_split(&par[1][0], ',');
    while (line[cc])
    {
        if (line[cc] == ',')
            cw++;
        cc++;
    }
    if (cw != 2)
    {
        ft_putstr(""Error:\n Wrong ceiling RGB"");
        exit(0);
    }
    cw = c_w(line, ' ');
    cc = c_w(&par[1][0], ',');
    freethenipples(par);
    check_crgb(colors, cc, cw);
    freethenipples(colors);
}
",9,384,953
"#include ""get_next_line.h""

void    global_init(void)
{
    g_no = NULL;
    g_so = NULL;
    g_we = NULL;
    g_ea = NULL;
    g_width = 0;
    g_height = 0;
    g_fr = -1;
    g_fg = -1;
    g_fb = -1;
    g_cr = -1;
    g_cg = -1;
    g_cb = -1;
    g_map_started = 0;
    g_map = ft_strdup("""");
}

void    ft_putchar(char c)
{
    write(1, &c, 1);
}

void    ft_putstr(char *str)
{
    int i;

    i = 0;
    while (str[i] != '\0')
    {
        ft_putchar(str[i]);
        i++;
    }
}

int     ft_isdigit(int c)
{
    if (c >= 0x30 && c <= 0x39)
        return (1);
    return (0);
}

char    *ft_strjoi(char *s1, char *s2)
{
    char    *str;
    int     i;
    int     j;

    if (!s2)
        return (s1);
    if (!s1)
        return (s2);
    str = (char*)malloc(ft_strlen(s1) + ft_strlen(s2) + 2);
    i = -1;
    while (s1[++i])
    {
        str[i] = s1[i];
    }
    j = -1;
    while (s2[++j])
    {
        str[i] = s2[j];
        i++;
    }
    str[i] = '\n';
    str[i + 1] = '\0';
    free(s1);
    return (str);
}
",9,385,507
"#include ""get_next_line.h""

double      normalangle(double rayangle)
{
    rayangle = fmod(rayangle, (2 * M_PI));
    return (rayangle);
}

void        update(void)
{
    float   newx;
    float   newy;
    float   move_step;

    g_player.rotation_angle += g_player.turn_direction *
                                g_player.rotation_speed;
    move_step = g_player.walk_direction * g_player.move_speed;
    newx = g_player.x + cos(g_player.rotation_angle) * move_step;
    newy = g_player.y + sin(g_player.rotation_angle) * move_step;
    if (!has_wall(newx, newy))
    {
        g_player.x = newx;
        g_player.y = newy;
    }
}

void        render(void)
{
    update();
    draw_map();
    cast_rays();
    mlx_put_image_to_window(g_vars.mlx, g_vars.win, g_image.img, 0, 0);
    mlx_destroy_image(g_vars.mlx, g_image.img);
}

int         key_press(int keycode)
{
    if (keycode == 13)
        g_player.walk_direction = 1;
    if (keycode == 1)
        g_player.walk_direction = -1;
    if (keycode == 0)
        g_player.turn_direction = -1;
    if (keycode == 2)
        g_player.turn_direction = 1;
    return (0);
}

int         key_release(int keycode)
{
    if (keycode == 13)
        g_player.walk_direction = 0;
    if (keycode == 1)
        g_player.walk_direction = 0;
    if (keycode == 0)
        g_player.turn_direction = 0;
    if (keycode == 2)
        g_player.turn_direction = 0;
    return (0);
}

int         move(void)
{
    mlx_hook(g_vars.win, 2, 0, key_press, &g_vars);
    render();
    mlx_hook(g_vars.win, 3, 0, key_release, &g_vars);
    return (0);
}
",9,386,637
"#include ""get_next_line.h""


void        cast_ray(int l, float angle)
{
    float   i;
    float   j;
    float   xp;
    float   yp;

    i = 0;
    while (i < l)
    {
        xp = cos(angle) * i + g_player.x;
        yp = sin(angle) * i + g_player.y;
        i++;
        my_mlx_pixel_put(&g_image, xp, yp, 0xFF0000);
    }
}

void        cast_rays(void)
{
    int     strip_id;
    float   angle;

    strip_id = 0;
    angle = g_player.rotation_angle - (g_player.fov / 2);
    while (strip_id < g_width)
    {
        normalangle(angle);
        cast_ray(50, (float)angle);
        angle += g_player.fov / g_width;
        strip_id++;
    }
}
",9,387,273
"#include ""get_next_line.h""

int pre_work(int fd, char **rest, char **line)
{
    char            *tmp;

    if (BUFFER_SIZE < 0 || !line || read(fd, NULL, 0) < 0)
        return (-1);
    *line = ft_strdup("""");
    if (rest[fd] != '\0')
    {
        if (!has_nl(rest[fd]))
        {
            *line = ft_strjoin(*line, rest[fd]);
            rest[fd] = NULL;
        }
        else
        {
            *line = ft_strjoin(*line, ft_substr(rest[fd], 0,
                has_nl(rest[fd]) - rest[fd]));
            tmp = rest[fd];
            rest[fd] = ft_strdup(&rest[fd][has_nl(rest[fd]) - rest[fd] + 1]);
            free(tmp);
            return (1);
        }
    }
    return (2);
}

int get_next_line(int fd, char **line)
{
    int             re;
    char            *str;
    static  char    *rest[1024];

    re = 0;
    if ((re = pre_work(fd, rest, line)) < 2)
        return (re);
    str = (char *)malloc(BUFFER_SIZE + 1);
    while ((re = read(fd, str, BUFFER_SIZE)))
    {
        str[re] = '\0';
        if (!has_nl(str))
            *line = ft_strjoin(*line, str);
        else
        {
            *line = ft_strjoin(*line, ft_substr(str, 0, has_nl(str) - str));
            rest[fd] = ft_strdup(&str[has_nl(str) - str + 1]);
            free(str);
            return (1);
        }
        str = (char *)malloc(BUFFER_SIZE + 1);
    }
    free(str);
    return (0);
}
",9,388,519
"#include ""get_next_line.h""

int     check_char(char *mapline, char c)
{
    int i;

    i = 0;
    while (mapline[i])
    {
        if (mapline[i] != c)
            return (0);
        i++;
    }
    return (1);
}

void    readmap(char *line)
{
    if (line[0] != '\0' && !g_map_started)
        g_map_started = 1;
    if (g_map_started && line[0] != '\0')
    {
        g_map = ft_strjoi(g_map, line);
    }
    if (g_map_started && line[0] == '\0')
    {
        ft_putstr(""Error:\nmap has a new line"");
        exit(0);
    }
}

void    manage_map(void)
{
    g_map_array = ft_split(g_map, '\n');
}

int     begins_by_nl(char **mapline)
{
    int i;

    i = 0;
    while (mapline[i] != '\0')
    {
        if (mapline[i][0] == '\n')
            return (1);
        i++;
    }
    return (0);
}
",9,389,341
"#include ""get_next_line.h""

void    texture_error(int error)
{
    if (error == 0)
        ft_putstr(""Error\ndouble inclusion\n"");
    else if (error == 1)
        ft_putstr(""Error:\nWrong number of params/invalid file in NO!\n"");
    else if (error == 2)
        ft_putstr(""Error:\nWrong number of params/invalid file in SO!\n"");
    else if (error == 3)
        ft_putstr(""Error:\nWrong number of params/invalid file in WE!\n"");
    else if (error == 4)
        ft_putstr(""Error:\nWrong number of params/invalid file in EA!\n"");
    else if (error == 5)
        ft_putstr(""Error:\nWrong number of params/invalid file in S!\n"");
    exit(0);
}

void    free_this_shit(char *str, char **s)
{
    free(str);
    freethenipples(s);
}

void    wrong_file(char *file, int type)
{
    int re;

    if ((re = open(file, O_RDONLY) > 0) && type == 1)
        g_no = ft_strdup(file);
    else if ((re = open(file, O_RDONLY) <= 0) && type == 1)
        texture_error(1);
    if ((re = open(file, O_RDONLY) > 0) && type == 2)
        g_so = ft_strdup(file);
    else if ((re = open(file, O_RDONLY) <= 0) && type == 2)
        texture_error(2);
    if ((re = open(file, O_RDONLY) > 0) && type == 3)
        g_we = ft_strdup(file);
    else if ((re = open(file, O_RDONLY) <= 0) && type == 3)
        texture_error(3);
    if ((re = open(file, O_RDONLY) > 0) && type == 4)
        g_ea = ft_strdup(file);
    else if ((re = open(file, O_RDONLY) <= 0) && type == 4)
        texture_error(4);
    if ((re = open(file, O_RDONLY) > 0) && type == 5)
        g_s = ft_strdup(file);
    else if ((re = open(file, O_RDONLY) <= 0) && type == 5)
        texture_error(4);
}
",9,390,668
"#include ""get_next_line.h""

void        player_init(char c, int x, int y)
{
    if (g_player.x != -1 || g_player.y != -1)
    {
        ft_putstr(""Error:\nthe map has more than one player\n"");
        exit(0);
    }
    else
    {
        g_player.x = (x * 32) + 16;
        g_player.y = (y * 32) + 16;
        if (c == 'N')
            g_player.rotation_angle = M_PI / 2;
        else if (c == 'S')
            g_player.rotation_angle = M_PI / 2;
        else if (c == 'E')
            g_player.rotation_angle = M_PI / 2;
        else if (c == 'W')
            g_player.rotation_angle = M_PI / 2;
    }
}

void        array_height(void)
{
    int i;

    i = 0;
    while (g_map_array[i])
        i++;
    g_map_height = i;
}

char        **map_manager(void)
{
    char    **map_array;
    int     i;
    int     j;

    j = 0;
    i = 0;
    map_array = (char**)malloc((g_map_height + 3) * sizeof(char*));
    while (i < g_map_height + 2)
    {
        map_array[i] = (char*)malloc((g_map_width + 3) * sizeof(char));
        i++;
    }
    map_array[i] = NULL;
    surrend_by_spaces(map_array);
    fill_map(map_array);
    map_errors(map_array);
    if (g_player.x == -1 || g_player.y == -1)
    {
        ft_putstr(""Error:\nPlayer or map missing\n"");
        exit(0);
    }
    return (map_array);
}

void        map_errors(char **map)
{
    int i;
    int j;

    i = 0;
    j = 0;
    while (++i <= g_map_height)
    {
        while (++j <= g_map_width)
        {
            if (map[i][j] != '1' && map[i][j] != '0' && map[i][j] != '2'
            && map[i][j] != 'N' && map[i][j] != 'W' && map[i][j] != 'E'
            && map[i][j] != 'S' && map[i][j] != ' ')
                error_redirect(0);
            else if (map[i][j] != ' ' && map[i][j] != '1')
            {
                if (map[i][j + 1] == ' ' || map[i][j - 1] == ' '
                || map[i + 1][j] == ' ' || map[i - 1][j] == ' ')
                    error_redirect(1);
                if (map[i][j] == 'N' || map[i][j] == 'S' ||
                map[i][j] == 'E' || map[i][j] == 'W')
                    player_init(map[i][j], i - 1, j - 1);
            }
        }
        j = 1;
    }
}

void        error_redirect(int error)
{
    if (error == 0)
        ft_putstr(""Error:\nmap has an unknown character\n"");
    else if (error == 1)
        ft_putstr(""Error:\nthe map isnt closed"");
    exit(0);
}
",9,391,965
"#include ""get_next_line.h""

void    global_init(void)
{
    g_no = NULL;
    g_so = NULL;
    g_we = NULL;
    g_ea = NULL;
    g_width = 0;
    g_height = 0;
    g_fr = -1;
    g_fg = -1;
    g_fb = -1;
    g_cr = -1;
    g_cg = -1;
    g_cb = -1;
    g_map_started = 0;
    g_map = ft_strdup("""");
}

void    ft_putchar(char c)
{
    write(1, &c, 1);
}

void    ft_putstr(char *str)
{
    int i;

    i = 0;
    while (str[i] != '\0')
    {
        ft_putchar(str[i]);
        i++;
    }
}

int     ft_isdigit(int c)
{
    if (c >= 0x30 && c <= 0x39)
        return (1);
    return (0);
}

char    *ft_strjoi(char *s1, char *s2)
{
    char    *str;
    int     i;
    int     j;

    if (!s2)
        return (s1);
    if (!s1)
        return (s2);
    str = (char*)malloc(ft_strlen(s1) + ft_strlen(s2) + 2);
    i = -1;
    while (s1[++i])
    {
        str[i] = s1[i];
    }
    j = -1;
    while (s2[++j])
    {
        str[i] = s2[j];
        i++;
    }
    str[i] = '\n';
    str[i + 1] = '\0';
    free(s1);
    return (str);
}
",9,392,507
"#include ""get_next_line.h""

int     all_params(void)
{
    if (g_width != 0 && g_height != 0 && g_we != NULL && g_no != NULL
        && g_no != NULL && g_ea != NULL && g_fr != -1 &&
        g_fr != -1 && g_fg != -1 && g_fb != -1 && g_cr != -1 &&
        g_cg != -1 && g_cb != -1)
        return (1);
    return (0);
}

int     wrong_resolution(int width, int height)
{
    int w;
    int h;

    w = width;
    h = height;
    if (width > 2560)
        w = 2560;
    if (height > 1400)
        h = 1400;
    if (width <= 100 || height <= 100)
    {
        ft_putstr(""Error:\nresolution is < 100 px!\n"");
        exit(0);
    }
    get_resolution(w, h);
    return (1);
}

void    get_resolution(int width, int height)
{
    g_width = width;
    g_height = height;
}

void    get_frgb(int r, int g, int b)
{
    g_fr = r;
    g_fg = g;
    g_fb = b;
}

void    get_crgb(int r, int g, int b)
{
    g_cr = r;
    g_cg = g;
    g_cb = b;
}
",9,393,420
"struct student
{
    int rno;
    float per;
    char name[30];
};
int main()
{int i,n;
    struct student x[100];
    printf(""Enter number of students:\n"");
    scanf(""%d"",&n);
    printf(""Enter Details:\n"");
    for(i=0;i<n;i++)
    {
    printf(""Enter roll number:"");
    scanf(""%d"",&x[i].rno);
    printf(""Enter name of student:"");
    scanf(""%s"",x[i].name);
    printf(""Percentage:"");
    scanf(""%f"",&x[i].per);
    }
    printf(""\n------------------------------------------"");
    printf(""Enter Details are:\n"");
    for(i=0;i<n;i++)
    {
    printf(""\nRoll number:%d\n"",x[i].rno);
    printf(""\nName:%s\n"",x[i].name);
    printf(""Percentage:%f\n"",x[i].per);
    }  
    return(0);
}
",10,394,268
"struct time
{int h,m,s;
}x,y,z;
int main()
{
printf(""____________________________________________________________________\n"");
printf(""\nEnter Duration 1"");
printf(""\nin sec:"");
scanf(""%d"",&x.s);
printf(""\nin min:"");
scanf(""%d"",&x.m);
printf(""\nin hours:"");
scanf(""%d"",&x.h);

printf(""\nEnter Duration 2"");
printf(""\nin sec:"");
scanf(""%d"",&y.s);
printf(""\nin min:"");
scanf(""%d"",&y.m);
printf(""\nin hours:"");
scanf(""%d"",&y.h);
z.h=x.h+y.h;
z.m=x.m+y.m;
z.s=x.s+y.s;

if(z.s>=60)
{z.s=z.s-60;
z.m=z.m+1;
}
if(z.m>=60)
{z.m=z.m-60;
z.h=z.h+1;
}
printf(""Final Value of time:"");
printf(""in hours:%d"",z.h);
printf(""in min:%d"",z.m);
printf(""in sec:%d"",z.s);

return 0;
}

",10,395,338
"struct student
{
    int rno;
    float per;
    char name[30];
};
int main()
{int i,n,s;
    struct student x[100];
    printf(""Enter number of students:\n"");
    scanf(""%d"",&n);
    printf(""Enter Details:\n"");
    for(i=0;i<n;i++)
    {
    printf(""Enter roll number:"");
    scanf(""%d"",&x[i].rno);
    printf(""Enter name of student:"");
    scanf(""%s"",x[i].name);
    printf(""Percentage:"");
    scanf(""%f"",&x[i].per);
    }
    printf(""\n---------------------------------\n"");
    printf(""Roll_no top be search:"");
    scanf(""%d"",&s);
    for(i=0;i<n;i++)
    {if(s==x[i].rno)
    {
    printf(""\nRoll number:%d\n"",x[i].rno);
    printf(""\nName:%s\n"",x[i].name);
    printf(""Percentage:%f\n"",x[i].per);
    } 
    }  
    return(0);
}
",10,396,302
"struct student
{
    int rno;
    float per;
    char name[30];
};
int main()
{
    struct student x;
    printf(""Enter Details:\n"");
    printf(""Enter roll number:"");
    scanf(""%d"",&x.rno);
    printf(""Enter name of student:"");
    scanf(""%s"",x.name);
    printf(""Percentage:"");
    scanf(""%f"",&x.per);
    printf(""\n--------------------------------------------------------------------------"");
    printf(""\nRoll number:%d\n"",x.rno);
    printf(""\nName:%s\n"",x.name);
    printf(""Percentage:%f\n"",x.per);
    return(0);
}









",10,397,186
"void main()
 {
  float r1,r2;
  int a,b,c,d;
  printf(""Enter value of a,b and c:"");
  scanf(""%d%d%d"",&a,&b,&c);
  d=b*b-4*a*c;
  if(d>0)
   {
    printf(""root are real"");
    r1=(-b+sqrt(d))/2*a;
    r2=(-b-sqrt(d))/2*a;
    printf(""root are %f and %f\n"",r1,r2);
    }
  else if(d==0)
   {
    printf(""root are equal"");
    r1=-b/2*a;
    r2=-b/2*a;
    printf(""root are %f and %f\n"",r1,r2);
    }
  else
   {
    printf(""root are imaginary!"");
    printf(""root are not real !!"");
    }
  }

",10,398,247
"void main()
 {
  char st[100],ch;
  printf(""Enter string:"");
  gets(st);
  for(int i=0;st[i]!='\o';i++)
   {
    if (st[i]>='A' && st[i]<='Z')
     {
      st[i]=st[i]+32;
      }
    if (st[i]>='a' && st[i]<='z')
     {
      st[i]=st[i]-32;
      }
    }
  printf(""Opposite case of the string:"");
  puts(st);
  }







",10,399,168
"void main()
 {int a[10],n,s,first,middle,last;
  printf(""Enter no of element:"");
  scanf(""%d"",&n);
  printf(""Enter element in ascending order:"");
  for(int i=0;i<n;i++)
   {scanf(""%d"",&a[i]);
    }
  printf(""Enter element to be search:"");
  scanf(""%d"",&s);
  first=0;
  last=n-1;
  middle=(first+last)/2;
  while(first<=last)
   {if(a[middle]<s)
     { first=middle+1;
      }
    else if(a[middle]==s)
     {printf(""Number is present\n"");
      break;         
      }
    else
     {last=middle-1;
      }
    middle=(first+last)/2;
    }
  if (first>last)
   { printf(""not found!!!"");
    }
  }

",10,400,245
"void main()
 {
  char st[100],ch;
  printf(""Enter string:"");
  gets(st);
  int i,n,j;
  n=strlen(st);
  i=0;
  j=n-1;
  while(i<j) 
   { 
    ch=st[i];
    st[i]=st[j];
    st[j]=ch;
    j--;
    i++;
    }
  printf(""Reverse of the string:"");
  puts(st);
  } 
  
                                                                      
 
  
  

                                       
",10,401,154
"void main()
 {
  float m1,m2,m3,m4,m5,per;
  printf(""Enter marks of five subject="");
  scanf(""%f%f%f%f%f"",&m1,&m2,&m3,&m4,&m5);
  per=(m1+m2+m3+m4+m5)/5;
  printf(""percentage=%f\n"",per);
  if(per<=100&&per>=85)
   {
    printf(""Grade=A"");
    }
  else if(per<85&&per>=75)
   {
    printf(""Grade=B"");
    }
  else if(per<75&&per>=55)
   {
    printf(""Grade=C"");
    }
  else if(per<55&&per>=40)
   {
    printf(""Grade=D"");
    }
  else
   {
    printf(""FAIL"");
    }
  }


                                       
",10,402,251
"struct NAME
{
    char fn[30],mn[30],ln[30];
};
struct date
{
    int d,m,y;
};
struct student
{
    int rno;
    float per;
    struct  NAME name;
    struct date dob;
};
int main()
{
    int u;
    struct student x;
    printf(""Enter Details:\n"");
    printf(""Enter roll number:"");
    scanf(""%d"",&x.rno);
    printf(""Enter name of student"");
    printf(""\nFirst name:"");
    scanf(""%s"",&x.name.fn);
    printf(""Middle name:"");
    scanf(""%s"",&x.name.mn);
    printf(""Last name:"");
    scanf(""%s"",&x.name.ln);
    printf(""Enter Date Of Birth"");
    printf(""\nDate:"");
    scanf(""%d"",&x.dob.d);
    printf(""Month:"");
    scanf(""%d"",&x.dob.m);
    printf(""Year:"");
    scanf(""%d"",&x.dob.y);
    printf(""Percentage:"");
    scanf(""%f"",&x.per);
    printf(""\n--------------------------------------------------------------------------"");
    printf(""\nRoll number:%d\n"",x.rno);
    printf(""\nName:%s %s %s\n"",x.name.fn,x.name.mn,x.name.ln);
    printf(""DoB:%d/%d/%d\n"",x.dob.d,x.dob.m,x.dob.y);
    printf(""Percentage:%f\n"",x.per);
    
    return(0);
}
",10,403,410
"typedef struct a
{
    int data;
    struct a* next;
}node;
node* createnode(int inp)
{
    node* newnode=malloc(sizeof(node));
    newnode->data=inp;
    newnode->next=NULL;
    return newnode;
}
void insert(node** head, int inp)
{
    node* linklist=createnode(inp);
    linklist->next=*head;
    *head=linklist;
    printf(""%d inserted\n"",(*head)->data);
}
void removeeven(node** head)
{
    while((*head)!=NULL && (*head)->data%2==0)
        *head=(*head)->next;
    node* h=*head;
    if((*head)==NULL)
        return;
    while(h->next!=NULL)
    {
        if(h->next->data%2==0)
            h->next=h->next->next;
        else
            h=h->next;
    }
}
void print(node** head)
{
    if(*head==NULL)
        printf(""\nSTACK EMPTY\n"");
    else
    {
        node* h=*head;
        printf(""\n LINK-LIST:"");
        while(h!=NULL)
        {
            printf(""  %d"",h->data);
            h=h->next;
        }
        printf(""\n"");
    }
}
int main()
{
    int n;
    node* head=NULL;
    while(1)
    {
        printf(""\n1. INSERT\n"");
        printf(""2. REMOVE EVEN\n"");
        printf(""3. PRINT\n"");
        printf(""4. EXIT\n"");
        printf(""Enter choice: "");
        scanf(""%d"",&n);
        if(n==1)
        {
            int inp;
            printf(""Enter the element: "");
            scanf(""%d"",&inp);
            insert(&head,inp);
        }
        else if(n==2)
        {
            removeeven(&head);
            printf(""All even integers removed.\n"");
        }
        else if(n==3)
            print(&head);
        else if(n==4)
        {
            printf(""Exitting program, Thank you.\n"");
            break;
        }
        else
            printf(""INVALID CHOICE, TRY AGAIN!\n"");
    }
    return 0;
}",11,404,611
"typedef struct node 
{ 
    int key; 
    struct node *left, *right; 
}list;
list *newNode(int item) 
{ 
    list *temp = (list *)malloc(sizeof(list)); 
    temp->key = item; 
    temp->left = temp->right = NULL; 
    return temp; 
} 
list* rec_insert(list* node, int key) 
{ 
    if (node == NULL) 
    return newNode(key); 
    if (key < node->key) 
        node->left = rec_insert(node->left, key); 
    else if (key > node->key) 
        node->right = rec_insert(node->right, key); 
    return node; 
}
list *insert(list* root, int n)
{
    list **temp=&root;
    while(*temp!=NULL)
    {
        if(n < (*temp)->key) temp=&(*temp)->left;
        else temp=&(*temp)->right;
    }
    *temp=newNode(n);
    return root;
}
void inorder(list *root) 
{ 
    if (root != NULL) 
    { 
        inorder(root->left); 
        printf(""   %d \n"", root->key); 
        inorder(root->right); 
    } 
}
void preorder(list *root)
{
    if (root != NULL)
    {
        printf(""   %d \n"", root->key); 
        preorder(root->left);
        preorder(root->right);
    }
}
void postorder(list *root)
{
    if (root != NULL)
    {
        postorder(root->left);
        postorder(root->right);
        printf(""   %d \n"", root->key); 
    }
}
int rec_height(list* node)
{
    if(node==NULL)
    return 0;
    else
    {
    int lheight=rec_height(node->left);
    int rheight=rec_height(node->right);
    if(lheight> rheight)
        return (lheight+1);
    else return (rheight+1);
    }
}
void mirror_ins(list* node)
{
    if(node==NULL)
    return ;
    else
    {
        list* temp;
        mirror_ins(node->left);
        mirror_ins(node->right);
        temp=node->left;
        node->left=node->right;
        node->right=temp;
    }
}
int rec_count(list* node)
{
    int x=1;
    if(node==NULL)
        return 0;
    else
    {
        x+=rec_count(node->left);
        x+=rec_count(node->right);
        return x;
    }
}
int leafcount(list* node)
{
    if(node==NULL)
        return 0;
    if(node->left==NULL && node->right==NULL)
        return 1;
    else
        return leafcount(node->left)+leafcount(node->right);
}
int InternalNodeCount(list* node)
{
    if(node==NULL ||(node->left==NULL && node->right==NULL))
        return 0;
    else
        return 1 + InternalNodeCount(node->left)+InternalNodeCount(node->right);
}
int findmax(list* node)
{
    if(node==NULL || node->right==NULL)
        return node->key;
    else
        findmax(node->right);
}
int findmin(list* node)
{
    if(node==NULL || node->left==NULL)
        return node->key;
    else
        findmin(node->left);
}
void deleteTree(list* node)
{
    if(node == NULL)
        return;
    deleteTree(node->left);
    deleteTree(node->right);
    printf(""\n Deleting Node: %d"",node->key);
    free(node);
}
int main() 
{ 
    int ch;
    list* root=NULL;
    while(1)
    {
        printf(""\n"");
        printf(""1. Insertion Using Recursive Function \n"");
        printf(""2. Insertion Using Iterative Function \n"");
        printf(""3. In-order Traversal  using a Recursive Function \n"");
        printf(""4. Pre-order Traversal  using a Recursive Function \n"");
        printf(""5. Post-order Traversal  using a Recursive Function \n"");
        printf(""6. Determine the height of the Binary Search Tree \n"");
        printf(""7. Construct the Binary Search Tree which is mirror image of the given Binary Search Tree \n"");
        printf(""8. Count the total number of nodes of the Binary Search Tree \n"");
        printf(""9. Count the total number of leaf nodes of the Binary Search Tree \n"");
        printf(""10. Count the total number of internal nodes of the Binary Search Tree \n"");
        printf(""11. Find maximum and minimum elements in the Binary Search Tree \n"");
        printf(""12. Deallocate the memory space occupied by Binary Search Tree \n"");
        printf(""13. Exit Program \n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&ch);
        if (ch==1)
        {
            int n;
            printf(""Enter the element: "");
            scanf(""%d"",&n);
            root=rec_insert(root,n);
            printf(""%d inserted in Binary Tree\n"",n);
        }
        else if(ch==2)
        {
            int n;
            printf(""Enter the element: "");
            scanf(""%d"",&n);
            root=insert(root,n);
            printf(""%d inserted in Binary Tree\n"",n);
        }
        else if(ch==3)
        {
            printf(""\nIN-ORDER\n"");
            inorder(root);
        }
        else if(ch==4)
        {
            printf(""\nPRE-ORDER\n"");
            preorder(root);
        }
        else if(ch==5)
        {
            printf(""\nPOST-ORDER\n"");
            postorder(root);
        }
        else if (ch==6)
        {
            printf(""Height of tree= %d\n"",rec_height(root));
        }
        else if (ch==7)
        {
            mirror_ins(root);
            printf(""Mirror of tree constructed\n"");
        }
        else if (ch==8)
        {
            printf(""Total number of nodes= %d\n"",rec_count(root));
        }
        else if (ch==9)   
        {
            printf(""Number of leaf nodes= %d\n"",leafcount(root));
        }
        else if (ch==10)
        {
            printf(""Number of internal nodes= %d\n"",InternalNodeCount(root));
        }
        else if (ch==11)
        {
            printf(""Maximum= %d\n"",findmax(root));
            printf(""Minimum= %d\n"",findmin(root));
        }
        else if (ch==12)
        {
            deleteTree(root);
            root=NULL;
        }
        else if (ch==13)
        {
            printf(""Thank You.\n"");
            break;
        }
        else
            printf(""Invalid Choice.\n"");
    }
    return 0; 
}",11,405,1849
"typedef struct x
{
    int data;
    struct x* left;
    struct x* right;
}node;
node* createNode(int n)
{
    node* newNode=(node*)malloc(sizeof(node));
    newNode->data=n;
    newNode->left=NULL;
    newNode->right=NULL;
    return newNode;
}
node* insertion(node* root, int n)
{
    if(root==NULL) return createNode(n);
    else if(n < root->data) root->left=insertion(root->left,n);
    else if(n > root->data) root->right=insertion(root->right,n);
    return root; 
}
int search(node* root, int key)
{
    if (root==NULL)
        return 0;
    else
    {
        if (key<root->data)
            search(root->left,key);
        else if(key>root->data)
            search(root->right,key);
        else
            return 1;
    }
}
node* deletion(node* root, int n)
{
    if (root==NULL) return root;
    if (n<root->data)
        root->left=deletion(root->left,n);
    else if (n>root->data)
        root->right=deletion(root->right,n);
    else
    {
        if(root->left==NULL)
        {
            node* temp=root->right;
            free(root);
            return temp;
        }
        else if(root->right==NULL)
        {
            node* temp=root->left;
            free(root);
            return temp;
        }
        node* temp=root->right;
        while (temp&&temp->left!=NULL)
            temp=temp->left;
        root->data=temp->data;
        root->right=deletion(root->right,temp->data);
    }
    return root;
}
void display(node* root,int n)
{
    if (root==NULL)
    {
        for (int i = 0; i < n-2; i++)
            printf("" "");
        printf(""NULL\n"");
    }
    else
    {
        display(root->right,n+5);
        for (int i = 0; i < n+2; i++)
            printf("" "");
        printf(""/\n"");
        for (int i = 0; i < n; i++)
            printf("" "");
        printf(""%d\n"",root->data);
        for (int i = 0; i < n+2; i++)
            printf("" "");
        printf(""\\\n"");
        display(root->left,n+5);
    }
}
int nodes(node* root)
{
    if(root==NULL)
        return 0;
    else
        return 1 + nodes(root->left) + nodes(root->right);
}
void inorder(node* root)
{
    node* stack[nodes(root)];
    int c=-1;
    node* cur=root;
    while(1)
    {
        while (cur)
        {
            stack[++c]=cur;
            cur=cur->left;
        }
        if (c!=-1)
        {
            printf(""\t%d\n"",stack[c--]->data);
            cur=stack[c+1]->right;
        }
        else
            break;
    }
}
void preorder(node* root) 
{ 
    int c=-1;
    node* stack[nodes(root)];
    stack[++c]=root;
    while(c!=-1)
    {
        printf(""\t%d\n"",stack[c--]->data);
        node* temp=stack[c+1];
        if(temp->right)
            stack[++c]=temp->right;
        if(temp->left)
            stack[++c]=temp->left;
    }
}
int main()
{
    int ch;
    node* root=NULL;
    while (1)
    {
        printf(""\n1. INSERTION OF INTEGER\n"");
        printf(""2. DELETION OF INTEGER\n"");
        printf(""3. DISPLAY TREE\n"");
        printf(""4. IN-ORDER TRAVERSAL\n"");
        printf(""5. PRE-ORDER TRAVERSAL\n"");
        printf(""6. EXIT\n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&ch);
        if(ch==1)
        {
            int n;
            printf(""Please enter an element: "");
            scanf(""%d"",&n);
            root=insertion(root,n);
            printf(""%d inserted in BINARY SEARCH TREE.\n"",n);
        }
        else if(ch==2)
        {
            int n;
            printf(""Please enter the element to be deleted: "");
            scanf(""%d"",&n);
            if(search(root,n)==1)
            {
                root=deletion(root,n);
                printf(""%d deleted from BINARY SEARCH TREE.\n"",n);
            }
            else
                printf(""COULDN'T DELETE %d. NOT FOUND IN BS TREE.\n"");
        }
        else if(ch==3)
        {
            printf(""\n"");
            display(root,1);
        }
        else if(ch==4)
        {
            if(root==NULL)
                printf(""\tTREE EMPTY\n"");
            else
            {
                printf(""\n     IN-ORDER\n"");
                inorder(root);
            }
        }
        else if(ch==5)
        {
            if(root==NULL)
                printf(""\tTREE EMPTY\n"");
            else
            {
                printf(""\n     PRE-ORDER\n"");
                preorder(root);
            }
        }
        else if(ch==6)
        {
            printf(""Exitting Program, Thank You.\n"");
            break;
        }
        else
            printf(""INVALID CHOICE! TRY AGAIN\n"");
    }
    return 0;
}",11,406,1533
"typedef struct a
{
    int data;
    struct a* next;
}node;
node* createnode(int inp)
{
    node* newnode=malloc(sizeof(node));
    newnode->data=inp;
    newnode->next=NULL;
    return newnode;
}
void sequential_insert(node** head, int inp)
{
    node* linklist=createnode(inp);
    linklist->next=*head;
    *head=linklist;
    printf(""%d inserted\n"",(*head)->data);
}
void sorted_insert(node** head, int inp)
{
    node* newnode=createnode(inp);
    if(*head==NULL||newnode->data < (*head)->data)
    {
        newnode->next=*head;
        *head=newnode;
        printf(""%d inserted\n"",(*head)->data);
    }
    else
    {
        node* temp=*head;
        while(temp->next!=NULL&&temp->next->data < newnode->data)
            temp=temp->next;
        newnode->next=temp->next;
        temp->next=newnode;
        printf(""%d inserted\n"",temp->next->data);
    }
}
void print(node** head)
{
    if(*head==NULL)
        printf(""STACK EMPTY\n"");
    else
    {
        node* h=*head;
        printf(""      STACK      \n"");
        while(h!=NULL)
        {
            printf(""\t%d\n"",h->data);
            h=h->next;
        }
    }
}
int main()
{
    int ch;
    while(1)
    {
        printf(""\n1. SORTED ORDER\n"");
        printf(""2. SEQUENTIAL ORDER\n"");
        printf(""3. EXIT PROGRAM\n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&ch);
        if (ch==1)
        {
            int n;
            node* head=NULL;
            while(1)
            {
                printf(""\n1. INSERT\n"");
                printf(""2. PRINT\n"");
                printf(""3. EXIT\n"");
                printf(""Enter choice: "");
                scanf(""%d"",&n);
                if (n==1)
                {
                    int inp;
                    printf(""Enter the element: "");
                    scanf(""%d"",&inp);
                    sorted_insert(&head,inp);
                }
                else if (n==2)
                    print(&head);
                else if (n==3)
                {
                    printf(""Exitting, Thank you.\n"");
                    break;
                }
                else
                    printf(""INVALID CHOICE, TRY AGAIN\n"");
            }
        }
        else if(ch==2)
        {
            int n;
            node* head=NULL;
            while(1)
            {
                printf(""\n1. INSERT\n"");
                printf(""2. PRINT\n"");
                printf(""3. EXIT\n"");
                printf(""Enter choice: "");
                scanf(""%d"",&n);
                if(n==1)
                {
                    int inp;
                    printf(""Enter the element: "");
                    scanf(""%d"",&inp);
                    sequential_insert(&head,inp);
                }
                else if(n==2)
                    print(&head);
                else if(n==3)
                {
                    printf(""Exitting, Thank you.\n"");
                    break;
                }
                else
                    printf(""INVALID CHOICE, TRY AGAIN!\n"");
            }
        }
        else if(ch==3)
        {
            printf(""Exitting program, Thank you.\n"");
            break;
        }
        else
            printf(""SORRY, INVALID CHOICE, TRY AGAIN!\n"");
    }
    return 0;
}",11,407,992
"typedef struct x
{
    int data;
    struct x* next;
}node;
node* createNode(int n)
{
    node* newNode=(node*)malloc(sizeof(node));
    newNode->data=n;
    newNode->next=NULL;
    return newNode;
}
void sort_insertion(node** head, int n)
{
    node* cll=createNode(n);
    if (*head==NULL)
    {
        *head=cll;
        cll->next=cll;
    }
    else if((*head)->data >= cll->data)
    {
        node* last=*head;
        while(last->next!=(*head))
            last=last->next;
        cll->next=*head;
        last->next=cll;
        *head=cll;
    }
    else if((*head)->data < cll->data)
    {
        node* temp=*head;
        while(temp->next!=*head && temp->next->data<cll->data)
            temp=temp->next;
        cll->next=temp->next;
        temp->next=cll;
    }
}
void seq_insertion(node** head, int n)
{
    node* cll=createNode(n);
    if(*head==NULL)
    {
        *head=cll;
        cll->next=cll;
    }
    else
    {
        cll->next=*head;
        node* last=*head;
        while(last->next!=(*head))
            last=last->next;
        last->next=cll;
        *head=cll;
    }
}
node* search(node* head, int n)
{
    node* cll=head;
    do
    {
        if(cll->data==n)
            return cll;
        cll=cll->next;
    }
    while(cll!=head);
    return NULL;
}
void deletion(node** head, node* del)
{
    if (*head==del)
    {
        if((*head)->next==*head)
            *head=NULL;
        else
        {
            node* last=*head;
            while(last->next!=(*head))
                last=last->next;
            *head=(*head)->next;
            last->next=*head;
        }
    }
    else
    {
        node* temp=*head;
        while(temp->next!=del)
            temp=temp->next;
        temp->next=del->next;
    }
    free(del);
}
void print(node* head)
{
    node* temp=head;
    do
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    while(temp!=head);
}
int main()
{
    while (1)
    {
        int ch;
        printf(""\n1. SORTED ORDER INSERTION\n"");
        printf(""2. SEQUENTIAL ORDER INSERTION\n"");
        printf(""3. EXIT PROGRAM\n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&ch);
        if(ch==1)
        {
            printf(""\n\tSORTED ORDER\n"");
            node* head=NULL;
            int c;
            while(1)
            {
                int c;
                printf(""\n1. ENTER AN INTEGER\n"");
                printf(""2. DELETE AN INTEGER\n"");
                printf(""3. DISPLAY CONTENT OF CIRCULAR LINK-LIST\n"");
                printf(""4. EXIT SORTED ORDER INSERTION\n"");
                printf(""Enter your choice: "");
                scanf(""%d"",&c);
                if(c==1)
                {
                    int n;
                    printf(""Please enter an element: "");
                    scanf(""%d"",&n);
                    sort_insertion(&head,n);
                    printf(""%d inserted using SORTED ORDER INSERTION.\n"",n);
                }
                else if(c==2)
                {
                    if (head==NULL)
                        printf(""\nCAN'T DELETE. LIST EMPTY\n"");
                    else
                    {
                        int n;
                        printf(""\nPlease enter the element to be deleted: "");
                        scanf(""%d"",&n);
                        node* del_node=search(head,n);
                        if(del_node==NULL)
                            printf(""COULDN'T DELETE %d. NOT FOUND IN LIST.\n"",n);
                        else
                        {
                            deletion(&head,del_node);
                            printf(""%d deleted from LIST.\n"",n);
                        }
                    }
                }
                else if (c==3)
                {
                    if(head==NULL)
                        printf(""\n\tLIST EMPTY\n"");
                    else
                    {
                        printf(""\nDISPLAYING CONTENTS OF CIRCULAR LINK-LIST: \n"");
                        print(head);
                        printf(""\n"");
                    }
                }
                else if (c==4)
                {
                    printf(""\nExitting Sorted Order Insertion, Thank You.\n"");
                    break;
                }
                else
                    printf(""\nINVALID CHOICE! TRY AGAIN.\n"");
            }
        }
        else if(ch==2)
        {
            printf(""\n\tSEQUENTIAL ORDER\n"");
            node* head=NULL;
            int c;
            while(1)
            {
                int c;
                printf(""\n1. ENTER AN INTEGER\n"");
                printf(""2. DELETE AN INTEGER\n"");
                printf(""3. DISPLAY CONTENT OF CIRCULAR LINK-LIST\n"");
                printf(""4. EXIT SEQUENTAIL ORDER INSERTION\n"");
                printf(""Enter your choice: "");
                scanf(""%d"",&c);
                if(c==1)
                {
                    int n;
                    printf(""Please enter an element: "");
                    scanf(""%d"",&n);
                    seq_insertion(&head,n);
                    printf(""%d inserted using SEQUENTIAL ORDER INSERTION.\n"",n);
                }
                else if(c==2)
                {
                    if (head==NULL)
                        printf(""\nCAN'T DELETE. LIST EMPTY\n"");
                    else
                    {
                        int n;
                        printf(""\nPlease enter the element to be deleted: "");
                        scanf(""%d"",&n);
                        node* del_node=search(head,n);
                        if(del_node==NULL)
                            printf(""COULDN'T DELETE %d. NOT FOUND IN LIST.\n"",n);
                        else
                        {
                            deletion(&head,del_node);
                            printf(""%d deleted from LIST.\n"",n);
                        }
                    }
                }
                else if (c==3)
                {
                    if(head==NULL)
                        printf(""\n\tLIST EMPTY\n"");
                    else
                    {
                        printf(""\nDISPLAYING CONTENTS OF CIRCULAR LINK-LIST: \n"");
                        print(head);
                        printf(""\n"");
                    }
                }
                else if (c==4)
                {
                    printf(""\nExitting Sequential Order Insertion, Thank You.\n"");
                    break;
                }
                else
                    printf(""\nINVALID CHOICE! TRY AGAIN.\n"");
            }
        }
        else if(ch==3)
        {
            printf(""\nExitting Program, Thank You.\n"");
            break;
        }
        else
            printf(""\nINVALID CHOICE! TRY AGAIN.\n"");
    }
    return 0;
}",11,408,1983
"typedef struct a
{
    int data;
    struct a* next;
}node;
node* createnode(int inp)
{
    node* newnode=malloc(sizeof(node));
    newnode->data=inp;
    newnode->next=NULL;
    return newnode;
}
void sequential_insert(node** head, int inp)
{
    node* linklist=createnode(inp);
    linklist->next=*head;
    *head=linklist;
    printf(""%d inserted\n"",(*head)->data);
}
void sorted_insert_asc(node** head, int inp)
{
    node* newnode=createnode(inp);
    if(*head==NULL||newnode->data < (*head)->data)
    {
        newnode->next=*head;
        *head=newnode;
        printf(""%d inserted\n"",(*head)->data);
    }
    else
    {
        node* temp=*head;
        while(temp->next!=NULL&&temp->next->data < newnode->data)
            temp=temp->next;
        newnode->next=temp->next;
        temp->next=newnode;
        printf(""%d inserted\n"",temp->next->data);
    }
}
void sorted_insert_dec(node** head, int inp)
{
    node* newnode=createnode(inp);
    if(*head==NULL||newnode->data > (*head)->data)
    {
        newnode->next=*head;
        *head=newnode;
        printf(""%d inserted\n"",(*head)->data);
    }
    else
    {
        node* temp=*head;
        while(temp->next!=NULL&&temp->next->data > newnode->data)
            temp=temp->next;
        newnode->next=temp->next;
        temp->next=newnode;
        printf(""%d inserted\n"",temp->next->data);
    }
}
void print(node** head)
{
    if(*head==NULL)
        printf(""STACK EMPTY\n"");
    else
    {
        node* h=*head;
        printf(""      STACK      \n"");
        while(h!=NULL)
        {
            printf(""\t%d\n"",h->data);
            h=h->next;
        }
    }
}
int main()
{
    int ch;
    while(1)
    {
        printf(""\n1. SORTED ORDER\n"");
        printf(""2. SEQUENTIAL ORDER\n"");
        printf(""3. EXIT PROGRAM\n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&ch);
        if (ch==1)
        {
            int x;
            while(1)
            {
                printf(""\n1. ASCENDING ORDER\n"");
                printf(""2. DESCENDING ORDER\n"");
                printf(""3. EXIT\n"");
                printf(""Enter choice: "");
                scanf(""%d"",&x);
                if(x==1)
                {
                    int n;
                    node* head=NULL;
                    printf(""\n\t ASCENDING ORDER\n"");
                    while(1)
                    {
                        printf(""\n1. INSERT\n"");
                        printf(""2. PRINT\n"");
                        printf(""3. EXIT\n"");
                        printf(""Enter choice: "");
                        scanf(""%d"",&n);
                        if (n==1)
                        {
                            int inp;
                            printf(""Enter the element: "");
                            scanf(""%d"",&inp);
                            sorted_insert_asc(&head,inp);;
                        }
                        else if (n==2)
                        {
                            print(&head);
                        }
                        else if (n==3)
                        {
                            printf(""Exitting, Thank you.\n"");
                            break;
                        }
                        else
                            printf(""INVALID CHOICE, TRY AGAIN\n"");
                    }
                }
                else if(x==2)
                {
                    int n;
                    node* head=NULL;
                    printf(""\n\t DESCENDING ORDER\n"");
                    while(1)
                    {
                        printf(""\n1. INSERT\n"");
                        printf(""2. PRINT\n"");
                        printf(""3. EXIT\n"");
                        printf(""Enter choice: "");
                        scanf(""%d"",&n);
                        if (n==1)
                        {
                            int inp;
                            printf(""Enter the element: "");
                            scanf(""%d"",&inp);
                            sorted_insert_dec(&head,inp);;
                        }
                        else if (n==2)
                        {
                            print(&head);
                        }
                        else if (n==3)
                        {
                            printf(""Exitting, Thank you.\n"");
                            break;
                        }
                        else
                            printf(""INVALID CHOICE, TRY AGAIN\n"");
                    }
                }
                else if(x==3)
                {
                    printf(""Exitting, Thank you.\n"");
                    break;
                }
                else
                {
                    printf(""INVALID CHOICE, TRY AGAIN\n"");
                }
            }
        }
        else if(ch==2)
        {
            int n;
            node* head=NULL;
            while(1)
            {
                printf(""\n1. INSERT\n"");
                printf(""2. PRINT\n"");
                printf(""3. EXIT\n"");
                printf(""Enter choice: "");
                scanf(""%d"",&n);
                if(n==1)
                {
                    int inp;
                    printf(""Enter the element: "");
                    scanf(""%d"",&inp);
                    sequential_insert(&head,inp);
                }
                else if(n==2)
                    print(&head);
                else if(n==3)
                {
                    printf(""Exitting, Thank you.\n"");
                    break;
                }
                else
                    printf(""INVALID CHOICE, TRY AGAIN!\n"");
            }
        }
        else if(ch==3)
        {
            printf(""Exitting program, Thank you.\n"");
                break;
        }
        else
            printf(""SORRY, INVALID CHOICE, TRY AGAIN!\n"");
    }
    return 0;
}",11,409,1622
"typedef struct n{
    int key;
    struct n *left, *right;
}list;
typedef struct{
    int top;
    unsigned int size;
    int* arr;
}stack;
list* initialise_tree(list* root){
    root=NULL;
    return root;
}
stack* initialise_stack(unsigned int x){
    stack* ret=(stack*) malloc(sizeof(stack));
    ret->top=-1;
    ret->size=x;
    ret->arr=(int*)malloc(x * sizeof(int));
    return ret;
}
list *newNode(int item){
    list *temp = (list*)malloc(sizeof(list));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp; 
}
list* insert(list* node, int key){
    if (node == NULL)
    return newNode(key); 
    if (key < node->key) 
        node->left = insert(node->left, key);
    else if (key > node->key) 
        node->right = insert(node->right, key); 
    return node;
}
int is_full(stack* stk){
    if(stk->top==(stk->size-1))
        return 1;
    else
        return 0;
}
void push(stack* stk, int n){
    if(is_full(stk))
        printf(""OVERFLOW OCCURRED!\n"");
    else{
        stk->arr[++stk->top]=n;
        printf(""%d pushed to stack.\n"",stk->arr[stk->top]);
    }
}
int is_empty(stack* stk){
    if(stk->top==-1)
        return 1;
    else
        return 0;
}
list* minValNode(list* node){
    list* curr=node;
    while(curr && curr->left!=NULL)
        curr=curr->left;
    return curr;
}
int find(list* root, int n){
    if (root==NULL)
        return 0;
    else{
        if (n<root->key)
            find(root->left,n);
        else if(n>root->key)
            find(root->right,n);
        else
            return 1;
    }
}
list* del_Node(list* node, int n){
    if(node==NULL)
        return node;
    if(n<node->key)
        node->left=del_Node(node->left,n);
    else if(n>node->key)
        node->right=del_Node(node->right,n);
    else{
        if(node->left==NULL){
            list*temp=node->right;
            free(node);
            return temp;
        }
        else if (node->right==NULL){
            list* temp=node->left;
            free(node);
            return temp;
        }
        list* temp=minValNode(node->right);
        node->key=temp->key;
        node->right=del_Node(node->right,temp->key);
    }
    return node;
}
void pop(stack* stk){
    if(is_empty(stk))
        printf(""STACK EMPTY!\n"");
    else
        printf(""%d popped from stack.\n"",stk->arr[stk->top--]);
}
void preorder(list* node){
    int top=-1;
    list *s[50];
    while(1){
        while(node!=NULL){
            printf("" %d"",node->key);
            s[++top]=node;
            node=node->left;
        }
        if(top==-1)
            break;
        node=s[top]->right;
        top=top-1;
    }
    printf(""\n"");
}
void display(stack* stk){
    if(stk->top==-1)
        printf(""STACK EMPTY\n"");
    else{
        printf(""  STACK\n"");
        for(int i=stk->top; i>=0; i--)
            printf(""    %d\n"",stk->arr[i]);
    }
}
void display_tree(list* root, int n){
    if (root==NULL){
        for (int i = 0; i < n-2; i++)
            printf("" "");
        printf(""NULL\n"");
    }
    else{
        display_tree(root->right,n+5);
        for (int i = 0; i < n+2; i++)
            printf("" "");
        printf(""/\n"");
        for (int i = 0; i < n; i++)
            printf("" "");
        printf(""%d\n"",root->key);
        for (int i = 0; i < n+2; i++)
            printf("" "");
        printf(""\\\n"");
        display_tree(root->left,n+5);
    }
}
int main(){
    int ch,d,x;
    stack *stk;
    list *T, *root;
    while(1){
        printf(""\n"");
        printf(""1. Initialise Binary Search Tree \n"");
        printf(""2. Initialise the stack \n"");
        printf(""3. Insert in Tree \n"");
        printf(""4. Push in stack \n"");
        printf(""5. Delete an element from tree \n"");
        printf(""6. Pop from stack \n"");
        printf(""7. Pre-Order Traversal of Tree \n"");
        printf(""8. Display the stack \n"");
        printf(""9. Display Graphical Tree \n"");
        printf(""10. Exit Program \n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&ch);
        if(ch==1){
            root=initialise_tree(root);
            printf(""Binary Search Tree Initialised. \n"");
        }
        else if(ch==2){
            printf(""Enter size of the working Stack:\n"");
            scanf(""%d"",&x);
            stk=initialise_stack(x);
            printf(""Stack initialised. \n"");
        }
        else if (ch==3){
            int n;
            printf(""Enter the element: "");
            scanf(""%d"",&n);
            root=insert(root,n);
            printf(""%d inserted in Binary Tree\n"",n);
        }
        else if (ch==4){
            int n;
            printf(""Enter the element: "");
            scanf(""%d"",&n);
            push(stk,n);
        }
        else if (ch==5){
            int d;
            printf(""Enter No.to be deleted: "");
            scanf(""%d"",&d);
            if(find(root,d)==1){
                root=del_Node(root,d);
                printf(""%d has been Deleted \n"",d);
            }
            else
                printf(""%d not found in tree.\n"");
        }
        else if(ch==6)
            pop(stk);
        else if(ch==7){
            if(root==NULL)
                printf(""SORRY, TREE EMPTY\n"");
            else{
                printf(""\nPRE-ORDER:\n"");
                preorder(root);
            }
        }
        else if(ch==8)
            display(stk);
        else if(ch==9)
            display_tree(root,1);
        else if(ch==10){
            printf(""Exitting, Thank You.\n"");
            break;
        }
        else
            printf(""Invalid Choice.\n"");
    }
    return 0;
}",11,410,1880
"typedef struct x
{
    int data;
    struct x* left;
    struct x* right;
}node;
node* createNode(int n)
{
    node* newNode=(node*)malloc(sizeof(node));
    newNode->data=n;
    newNode->left=NULL;
    newNode->right=NULL;
    return newNode;
}
node* rec_insertion(node* root, int n)
{
    if(root==NULL) return createNode(n);
    else if(n<root->data) root->left=rec_insertion(root->left,n);
    else if(n>root->data) root->right=rec_insertion(root->right,n);
    return root;
}
void iter_insertion(node** root, int n)
{
    node*** temp=&root;
    while(**temp!=NULL)
    {
        if(n < (**temp)->data) *temp=&(**temp)->left;
        else *temp=&(**temp)->right;
    }
    **temp=createNode(n);
}
void rec_inorder(node* root) 
{ 
    if (root != NULL) 
    { 
        rec_inorder(root->left); 
        printf(""\t%d\n"", root->data); 
        rec_inorder(root->right); 
    } 
}
void rec_preorder(node* root) 
{ 
    if (root != NULL) 
    {
        printf(""\t%d\n"", root->data); 
        rec_preorder(root->left);
        rec_preorder(root->right);
    } 
} 
void rec_postorder(node* root) 
{ 
    if (root != NULL) 
    { 
        rec_postorder(root->left);
        rec_postorder(root->right);
        printf(""\t%d\n"", root->data); 
    }
}
int height(node* root)
{
    if(root==NULL)
        return 0;
    else
    {
        int lheight=height(root->left);
        int rheight=height(root->right);
        if(lheight>rheight)
            return lheight+1;
        else
            return rheight+1;
    }
}
void mirror_image(node** root)
{
    node* temp;
    if((*root)!=NULL)
    {
        mirror_image(&(*root)->left);
        mirror_image(&(*root)->right);
        temp=(*root)->left;
        (*root)->left=(*root)->right;
        (*root)->right=temp;
    }
}
int count_totalnodes(node* root)
{
    if(root==NULL)
        return 0;
    else
        return 1 + count_totalnodes(root->left) + count_totalnodes(root->right);
}
int count_leafnodes(node* root)
{
    if (root==NULL)
        return 0;
    if (root->left == NULL && root->right == NULL)
        return 1;
    else
        return count_leafnodes(root->left) + count_leafnodes(root->right);
}
int count_internalnodes(node* root)
{
    if(root == NULL || (root->left == NULL && root->right == NULL))
        return 0;
    else
        return 1 + count_internalnodes(root->left)+count_internalnodes(root->right);
}
int largest_element(node* root)
{
    if(root==NULL||root->right==NULL)
        return root->data;
    else
        largest_element(root->right);
}
int smallest_element(node* root)
{
    if(root==NULL||root->left==NULL)
        return root->data;
    else
        smallest_element(root->left);
}
void deallocate_space(node* root)
{
    if((root)!=NULL)
    {
        deallocate_space(root->left);
        deallocate_space(root->right);
        printf(""\nDeallocating space occupied by element: %d"",root->data);
        free(root);
    }
}
int main()
{
    int ch;
    node* root=NULL;
    while (1)
    {
        printf(""\n1. RECURSIVE INSERTION\n"");
        printf(""2. ITERATIVE INSERTION\n"");
        printf(""3. IN-ORDER TRAVERSAL\n"");
        printf(""4. PRE-ORDER TRAVERSAL\n"");
        printf(""5. POST-ORDER TRAVERSAL\n"");
        printf(""6. HEIGHT OF BINARY TREE\n"");
        printf(""7. CONSTRUCT MIRROR IMAGE\n"");
        printf(""8. COUNT TOTAL NUMBER OF NODES\n"");
        printf(""9. COUNT TOTAL NUMBER OF LEAF NODES\n"");
        printf(""10. COUNT TOTAL NUMBER OF INTERNAL NODES\n"");
        printf(""11. MAX AND MIN ELEMENTS IN THE BINARY TREE\n"");
        printf(""12. DEALLOCATE SPACE OCCUPIED BY BINARY TREE\n"");
        printf(""13. EXIT\n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&ch);
        if(ch==1)
        {
            int n;
            printf(""Please enter an element: "");
            scanf(""%d"",&n);
            root=rec_insertion(root,n);
            printf(""\n%d inserted in BINARY SEARCH TREE using Recursive Insertion\n"",n);
        }
        else if(ch==2)
        {
            int n;
            printf(""Please enter an element: "");
            scanf(""%d"",&n);
            iter_insertion(&root,n);
            printf(""\n%d inserted in BINARY SEARCH TREE using Iterative Insertion\n"",n);
        }
        else if(ch==3)
        {
            if(root==NULL)
                printf(""\n\tTREE EMPTY\n"");
            else
            {
                printf(""\n     IN-ORDER\n"");
                rec_inorder(root);
            }
        }
        else if(ch==4)
        {
            if(root==NULL)
                printf(""\n\tTREE EMPTY\n"");
            else
            {
                printf(""\n     PRE-ORDER\n"");
                rec_preorder(root);
            }
        }
        else if(ch==5)  
        {
            if(root==NULL)
                printf(""\n\tTREE EMPTY\n"");
            else
            {
                printf(""\n     POST-ORDER\n"");
                rec_postorder(root);
            }
        }
        else if(ch==6)
            printf(""\nHeight of the tree: %d\n"",height(root));
        else if(ch==7)
        {
            mirror_image(&root);
            printf(""\nImage Tree Created\n"");
        }
        else if(ch==8)
                printf(""\nTotal number of nodes: %d\n"",count_totalnodes(root));
        else if(ch==9)
            printf(""\nNumber of leaf nodes: %d\n"",count_leafnodes(root));
        else if(ch==10)
            printf(""\nNumber of internal nodes: %d\n"",count_internalnodes(root));
        else if(ch==11)
        {
            printf(""\nMaximum element: %d\n"",largest_element(root));
            printf(""Minimum element: %d\n"",smallest_element(root));
        }
        else if(ch==12)
        {
            deallocate_space(root);
            root=NULL;
            printf(""\n\nDeallocated the space occupied by Binary Tree.\n"");
        }
        else if(ch==13)
        {
            
            printf(""\nExitting Program, Thank You.\n"");
            break;
        }
        else
            printf(""\nINVALID CHOICE! TRY AGAIN\n"");
    }
    return 0;
}",11,411,2022
"#define SRC 'A'
#define INTER 'B'
#define DEST 'C'
void move(int n, char src, char dest, char inter);
int main()
{
    int n;
    scanf(""%d"", &n);                
    printf(""Number of disks: %d\n"", n);
    move(n, SRC, DEST, INTER);
    return 0;
}
void move(int n,char src, char dest, char inter)
{
    if(n<1)
        printf(""ERROR"");
    else
    {
        static int c=0;
        if(n==1)
        {
            c++;
            printf(""%d: Move top disk from %c to %c\n"",c,src,dest);
            return;
        }
        move(n-1,src,inter,dest);
        c++;
        printf(""%d: Move top disk from %c to %c\n"",c,src,dest);
        move(n-1,inter,dest,src);
    }
}
",11,412,254
"#define MAX 100
#define NAME_SIZE 50
typedef struct x{
    int rollNo;
    char name[50];
}StudentType;
int enterStudents(StudentType students[]){
    int c=0;
    while(1)
    {
        if(c>NAME_SIZE){
            printf(""OVERFLOW"");
            break;
        }
        scanf(""%d"",&students[c].rollNo);
        if(students[c].rollNo==0)
            break;
        scanf(""%[^\n]s"",students[c].name);
        c++;
    }
    if(c==0){
        printf(""Empty list"");
        exit(1);
    }
    return c;
}
void sortStudents(StudentType students[], int n ){
    StudentType t;
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n-i;j++)
        {
            if(students[j].rollNo<students[j+1].rollNo)
            {
                t=students[j];
                students[j]=students[j+1];
                students[j+1]=t;
            }
        }
    }
}
void dispStudents ( StudentType students[], int n ) {
    int i;
    for (i=0; i<n; i++)
        printf(""#%d Roll: %d | Name:%s\n"",i+1, students[i].rollNo, students[i].name );
}

int main() {
    int n;
    StudentType students[MAX]; 
    
    n = enterStudents( students );    
    sortStudents( students, n );
    
    dispStudents( students, n );
    return 0;
}",11,413,450
"typedef struct s
{
    int data;
    struct s* next;
}node;
node* createNode(node* head, int n)
{
    node* newnode=malloc(sizeof(node));
    newnode->data=n;
    newnode->next=head;
    return newnode;
}
node* push(node* head, int data)
{
    if(head==NULL)
        return createNode(head,data);
    else
        head->next=push(head->next,data);
    return head;
}
node* pop(node* head)
{
    if(head==NULL)
        printf(""CAN'T POP, STACK EMPTY\n"");
    else if(head->next==NULL)
    {
        printf(""%d popped from stack\n"",head->data);
        free(head);
        return NULL;
    }
    else
    {
        head->next=pop(head->next);
        return head;
    }
}
void delete(node** head, int key)
{
    if(*head==NULL)
        printf(""CAN'T DELETE, STACK EMPTY\n"");
    else
    {
        int c=0,f=0;
        node* prev;
        node* cur=*head;
        while(cur != NULL)
        {
            c++;
            if(c==1)
            {    if (cur->data==key)
                {
                    *head=cur->next;
                    free(cur);
                    cur=*head;
                    f=1;c=0;
                }
                else
                {
                    prev=cur;
                    cur=cur->next;
                }
            }
            else
            {
                if(cur->data==key)
                {
                    prev->next=cur->next;
                    free(cur);
                    cur=prev->next;
                    f=1;
                }
                else
                {
                    prev=cur;
                    cur=cur->next;
                }
            }
        }
        if(f==0)
            printf(""NO MATCH FOUND\n"");
        else
            printf(""Match found!\nAll matching elements deleted successfully.\n"");
    }
}
node* rec_reverse(node* head)
{
    if(head == NULL || head->next == NULL)
        return head;
    node* revHead = rec_reverse(head->next);
    head->next->next = head;
    head->next = NULL; 
    return revHead;
}
int count(node* head)
{
    if(head==NULL)
        return 0;
    else
        return count(head->next)+1;
}
node* print(node* head)
{
    if(head==NULL)
        return NULL;
    else if(head->next==NULL)
    {
        printf(""      STACK      \n"");
        return head;
    }
    else
    {
        printf(""\t%d\n"",(print(head->next))->data);
        return head;
    }
}
int main()
{
    int ch;
    node* head=NULL;
    while(1)
    {
        printf(""\n"");
        printf(""1. PUSH\n"");
        printf(""2. POP\n"");
        printf(""3. DELETE\n"");
        printf(""4. REVERSE\n"");
        printf(""5. COUNT\n"");
        printf(""6. PRINT\n"");
        printf(""7. EXIT\n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&ch);
        if (ch==1)
        {
            int n;
            printf(""Enter the element: "");
            scanf(""%d"",&n);
            head=push(head, n);
        }
        else if (ch==2)
            head=pop(head);
        else if (ch==3)
        {
            int key;
            printf(""Enter the element you want to delete: "");
            scanf(""%d"",&key);
            delete(&head,key);
        }
        else if (ch==4)
        {
            if(head==NULL)
                printf(""CAN'T REVERSE, STACK EMPTY\n"");
            else
            {
                head=rec_reverse(head);
                printf(""Link-List Reversed\n"");
            }
        }
        else if (ch==5)
            printf(""Count of elements are= %d\n"",count(head));
        else if (ch==6)
        {
            node* temp=print(head);
            if(temp==NULL)
                printf(""CAN'T PRINT, STACK EMPTY\n"");
            else
                printf(""\t%d\n"",temp->data);
        }
        else if (ch==7)
        {
            printf(""Exitting program, Thank you.\n"");
            break;
        }
        else
            printf(""Invalid, choice try again.\n"");
    }
    return 0;
}",11,414,1232
"void merge(int a[], int m, int b[], int n, int sorted[]);
int main()
{
  int a[100], b[100], m, n, c, sorted[200];
  
  scanf(""%d"", &m); 
  for (c = 0; c < m; c++){
    scanf(""%d"", &a[c]); 
  }
  scanf(""%d"", &n); 
  for (c = 0; c < n; c++){
    scanf(""%d"", &b[c]); 
  }
  merge(a, m, b, n, sorted);
  
  printf(""Sorted array:\n"");
  for (c = 0; c < m + n; c++) {
    printf(""%d\n"", sorted[c]);
  }
  return 0;
}
void merge(int a[], int m, int b[], int n, int sorted[])
{
    int i,j,f;
    for(i=0;i<m;i++)
        sorted[i]=a[i];
    for(j=m,i=0;j<m+n;j++,i++)
        sorted[j]=b[i];
    for(i=0;i<m+n;i++)
    {
        for(j=0;j<(m+n)-i-1;j++)
        {
            if(sorted[j]>sorted[j+1])
            {
                f=sorted[j];
                sorted[j]=sorted[j+1];
                sorted[j+1]=f;
            }
        }
    }
}
",11,415,398
"typedef struct{
    int n;
    int** arr;
}graph;
typedef struct{
    int end;
    int* items;
}queue;
typedef struct{
    int top;
    int* items;
}stack;
void input(graph* g){
    int i,j,f,x=1;
    while(x){
        printf(""\nEnter the number of vertices: "");
        scanf(""%d"",&g->n);
        if(g->n>0)
            x=0;
        else
            printf(""Invalid input. Try again.\n"");
    }
    g->arr=(int**) malloc(sizeof(int*)*g->n);
    for(i=0;i<g->n;i++)
        g->arr[i]=(int*)malloc(sizeof(int)*g->n);
    for(i=0;i<g->n;i++)
        for(j=0;j<g->n;j++)
            g->arr[i][j]=-1;
    for(i=0;i<g->n;i++)
        for(j=0;j<g->n;j++){
            if(g->arr[i][j]==1 || g->arr[i][j]==0)
                continue;
            if(i==j){
                g->arr[i][j]=0;
                continue;
            }
            x=1;
            while(x){
                printf(""Is there an edge between %c and %c (Yes=1 & No=0): "",'A'+i,'A'+j);
                scanf(""%d"",&f);
                if(f==0 || f==1){
                    g->arr[i][j]=f;
                    g->arr[j][i]=f;
                    x=0;
                }
                else
                    printf(""Invalid input. Try again.\n"");
            }
        }
}
void initialiseQueue(queue* q, int n){
    q->end=-1;
    q->items=(int*) malloc(sizeof(int)*n);
}
void initialiseStack(stack* s, int n){
    s->top=-1;
    s->items=(int*)malloc(sizeof(int)*n);
}
void enqueue(queue* q, int n){
    q->items[++(q->end)]=n;
}
void push(stack* s, int n){
    s->items[++(s->top)]=n;
}
int dequeue(queue* q){
    int ret=q->items[0];
    for(int i=0; i<q->end; i++)
        q->items[i]=q->items[i+1];
    q->end--;
    return ret;
}
void pop(stack* s){
    s->top--;
}
int peek(stack* s){
    return s->items[s->top];
}
void bfs(graph g, int s){
    queue q;
    initialiseQueue(&q,g.n);
    int visited[g.n],i,f;
    for(i=0;i<g.n;i++)
        visited[i]=0;
    visited[s]=1;
    enqueue(&q,s);
    printf(""\nFollowing is the BFS Traversal (starting from %c): \n"",'A'+s);
    while(q.end!=-1){
        f=dequeue(&q);
        printf(""%c\t"",'A'+f);
        for (i = 0; i < g.n; i++)
            if(g.arr[f][i])
                if(!visited[i]){
                    visited[i]=1;
                    enqueue(&q,i);
                }
    }
}
void dfs(graph g, int x){
    stack s;
    initialiseStack(&s,g.n);
    int visited[g.n],i,f,t;
    for(i=0;i<g.n;i++)
        visited[i]=0;
    printf(""\nFollowing is the DFS Traversal (starting from %c): \n"",'A'+x);
    visited[x]=1;
    printf(""%c\t"",'A'+x);
    push(&s,x);
    while(s.top!=-1){
        f=peek(&s);
        t=1;
        for(i=0; i<g.n; i++)
            if(g.arr[f][i])
                if(!visited[i]){
                    visited[i]=1;
                    printf(""%c\t"",'A'+i);
                    push(&s,i);
                    t=0;
                    break;
                }
        if(t)
            pop(&s);
    }
}
void free_graph(graph* g){
    for(int i=0; i<g->n; i++)
        free(g->arr[i]);
    free(g->arr);
}
int main(){
    graph g;
    input(&g);
    while(1){
        int f=1,s,ch=1;
        printf(""\n\n****************\n"");
        printf(""1. BFS Traversal\n"");
        printf(""2. DFS Traversal\n"");
        printf(""3. EXIT\n"");
        printf(""Select the traversal you want to execute: "");
        scanf(""%d"",&ch);
        if(ch==1){
            printf(""\n\' If"");
            for(int i=0; i<g.n;i++)
                printf("" %c=%d"",'A'+i,i+1);
            printf("" \'\nEnter the initial vertex: "");
            while(f){
                scanf(""%d"",&s);
                if(s>0 && s<g.n+1)
                    f=0;
                else
                    printf(""Invalid input. Try again.\n"");
            }
            bfs(g,s-1);
        }
        else if(ch==2){
            printf(""\n\' If"");
            for(int i=0; i<g.n;i++)
                printf("" %c=%d"",'A'+i,i+1);
            printf("" \'\nEnter the initial vertex: "");
            while(f){
                scanf(""%d"",&s);
                if(s>0 && s<g.n+1)
                    f=0;
                else
                    printf(""Invalid input. Try again.\n"");
            }
            dfs(g,s-1);
        }
        else if(ch==3)
            break;
        else
            printf(""\nInvalid input. Try again.\n"");
    }
    printf(""\nExitting program. Thank You.\n"");
    free_graph(&g);
}",11,416,1653
"int main()
{
    int n, arr[10], c=0, ch;
    while(1)
    {
        printf(""1. To enter elements in the array\n"");
        printf(""2. To delete elements from the array\n"");
        printf(""3. Print the array\n"");
        printf(""4. Exit\n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&ch);
        if (ch==1)
        {
            if (c+1>10)
                    printf(""Array full. Try deleting elements.\n\n"");
            else
                scanf(""%d"",&arr[c++]);
        }
        else if(ch==2)
        {
            if(c-1<0)
                printf(""Array empty, try adding elements.\n\n"");
            else
                arr[c--]=0;
        }
        else if(ch==3)
        {
            for(int j=0;j<c;j++)
            {
                printf(""%d "",arr[j]);
            }
            printf(""\n\n"");
        }
        else if (ch==4)
        {
            printf(""Exitting program, Thank you.\n"");
            break;
        }
        else
        {
            printf(""Invalid, choice try again\n\n"");
        }
    }
    return 0;
}",11,417,330
"typedef struct
{
    int top;
    unsigned int size;
    int* arr;
}stack;
stack* createstack(unsigned int x)
{
    stack* ret=(stack* ) malloc(sizeof(stack));
    ret->top=-1;
    ret->size=x;
    ret->arr=(int* )malloc(x * sizeof(int));
    return ret;
}
void push(stack* stk, int n)
{
    if(stk->top==(stk->size-1))
        printf(""OVERFLOW!\n"");
    else
    {
        stk->arr[++stk->top]=n;
        printf(""%d pushed to stack.\n"",stk->arr[stk->top]);
    }
}
void pop(stack* stk)
{
    if(stk->top==-1)
        printf(""STACK EMPTY!\n"");
    else
        printf(""%d popped from stack.\n"",stk->arr[stk->top--]);
}
void peek(stack* stk)
{
    if(stk->top==-1)
        printf(""SORRY, STACK EMPTY!\n"");
    else
        printf(""Top element is %d\n"",stk->arr[stk->top]);
}
int main()
{
    int ch,x;
    printf(""Enter size of the working Stack:\n"");
    scanf(""%d"",&x);
    stack* stk=createstack(x);
    while(1)
    {
        printf(""\n"");
        printf(""1. PUSH\n"");
        printf(""2. POP\n"");
        printf(""3. PEEK\n"");
        printf(""4. EXIT\n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&ch);
        if (ch==1)
        {
            int n;
            scanf(""%d"",&n);
            push(stk,n);
        }
        else if(ch==2)
            pop(stk);
        else if(ch==3)
            peek(stk);
        else if (ch==4)
        {
            printf(""Exitting program, Thank you.\n"");
            break;
        }
        else
            printf(""Invalid, choice try again.\n"");
    }
    return 0;
}",11,418,572
"typedef struct{
    int n;
    int** mat;
}gph;
typedef struct{
    int end;
    int* items;
}que;
void input(gph* g){
    int i,j,f,x=1;
    while(x){
        printf(""\nEnter the number of vertices: "");
        scanf(""%d"",&g->n);
        if(g->n>0)
            x=0;
        else
            printf(""Invalid input.\n"");
    }
    g->mat=(int**) malloc(sizeof(int*)*g->n);
    for(i=0;i<g->n;i++)
        g->mat[i]=(int*)malloc(sizeof(int)*g->n);
    for(i=0;i<g->n;i++)
        for(j=0;j<g->n;j++)
            g->mat[i][j]=-1;
    for(i=0;i<g->n;i++)
        for(j=0;j<g->n;j++){
            if(g->mat[i][j]==1 || g->mat[i][j]==0)
                continue;
            if(i==j){
                g->mat[i][j]=0;
                continue;
            }
            x=1;
            while(x){
                printf(""Is there an edge between %c and %c (Yes=1 & No=0): "",'A'+i,'A'+j);
                scanf(""%d"",&f);
                if(f==0 || f==1){
                    g->mat[i][j]=f;
                    g->mat[j][i]=f;
                    x=0;
                }
                else
                    printf(""Invalid input.\n"");
            }
        }
}
void initialiseQueue(que* q, int n){
    q->end=-1;
    q->items=(int*) malloc(sizeof(int)*n);
}
void enqueue(que* q, int n){
    q->items[++(q->end)]=n;
}
int dequeue(que* q){
    int ret=q->items[0];
    for(int i=0; i<q->end; i++)
        q->items[i]=q->items[i+1];
    q->end--;
    return ret;
}
void bfs(gph g, int s){
    que q;
    initialiseQueue(&q,g.n);
    int visited[g.n],i,f;
    for(i=0;i<g.n;i++)
        visited[i]=0;
    visited[s]=1;
    enqueue(&q,s);
    printf(""\nFollowing is the BFS Traversal (starting from %c): \n"",'A'+s);
    while(q.end!=-1){
        f=dequeue(&q);
        printf(""%c\t"",'A'+f);
        for (i = 0; i < g.n; i++)
            if(g.mat[f][i])
                if(!visited[i]){
                    visited[i]=1;
                    enqueue(&q,i);
                }
    }
}
void free_graph(gph* g){
    for(int i=0; i<g->n; i++)
        free(g->mat[i]);
    free(g->mat);
}
int main(){
    gph g;
    int f=1,s;
    input(&g);
    printf(""\n\' If"");
    for(int i=0; i<g.n;i++)
        printf("" %c=%d"",'A'+i,i+1);
    printf("" \'\nEnter the initial vertex: "");
    while(f){
        scanf(""%d"",&s);
        if(s>0 && s<g.n+1)
            f=0;
        else
            printf(""Invalid input.\n"");
    }
    bfs(g,s-1);
    free_graph(&g);
}",11,419,988
"int N;
void printboard(int arr[N][N]){
    static int n=1;
    printf(""\nSolution No. %d: \n"",n++);
    for (int i = 0; i < N; i++){
        for (int j = 0; j < N; j++){
            if(arr[i][j])
                printf("" R "");
            else
                printf("" - "");
        }
        printf(""\n"");
    }
}
int safe(int arr[N][N], int row, int col){
    for (int i = 0; i < row; i++)
        if(arr[row][i])
            return 0;
    for (int i = 0; i < col; i++)
        if(arr[row][i])
            return 0;
    return 1;
}
void rooks(int arr[N][N], int c){
    if(c>=N){
        printboard(arr);
        int trs[N][N], t=0;
        for (int i = 0; i < N; i++)
            for (int j = 0; j < N; j++)
                trs[j][i]=arr[i][j];
        for (int i = 0; i < N; i++)
            for (int j = 0; j < N; j++)
                if(trs[i][j]==arr[i][j])
                    t++;
        if(t!=(N*N))
            printboard(trs);
        return;
    }
    for (int i = 0; i < N; i++){
        if(safe(arr,i,c)){
            arr[i][c]=1;
            rooks(arr,c+1);
            arr[i][c]=0;
        }
    }
}
int main(){
    int x=1;
    while(x){
        printf(""Enter valid N i.e for no of rows and columns: "");
        scanf(""%d"",&N);
        if(N>0)
            x=0;
    }
    int arr[N][N];
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            arr[i][j]=0;
    rooks(arr,0);
    return 0;
}",11,420,571
"long convert(int decimalnum)
{
    long binarynum = 0;
    int rem, temp = 1;
    while (decimalnum!=0)
    {
        rem = decimalnum%2;
        decimalnum = decimalnum / 2;
        binarynum = binarynum + rem*temp;
        temp = temp * 10;
    }
    return binarynum;
}
int check(int num)
{
    long bin=convert(num);
    int last = bin%10;
    if(last==0)
        return 1;
    else
        return 2;
}
int main()
{
    int t,n,i,j,parity,chk;
    scanf(""%d"",&t);
    for (int i = 0; i < t; i++)
    {
        scanf(""%d"",&n);
        int arr[n];
        for (int j = 0; j < n; j++)
            scanf(""%d"",arr+j);
        for (int j = 0; j < n; j++)
        {
            chk=check(arr[j]);
            if(j==0)
                parity=chk;
            else if(parity!=chk)
            {
                parity=0; 
                break;
            }
            else 
                continue;
        }
        if(parity==0)
            printf(""NO\n"");
        else
            printf(""YES\n"");
    }
    return 0;
}",11,421,365
"int sum(int n)
{
    int ans=0,f;
    if(n<0)
        n=-n;
    if (n>0)
    {
        while(n>0)
        {
            f=n%10;
            ans+=f;
            n=n/10;
        }
    }
    return ans;
}
int evensum(int n)
{
    int ans=0,f;
    if(n<0)
        n=-n;
    if (n>0)
    {
        while(n>0)
        {
            f=n%10;
            if(f%2==0)
                ans+=f;
            n=n/10;
        }
    }
    return ans;
}
int oddsum(int n)
{
    int ans=0,f;
    if(n<0)
        n=-n;
    if (n>0)
    {
        while(n>0)
        {
            f=n%10;
            if(f%2!=0)
                ans+=f;
            n=n/10;
        }
    }
    return ans;
}
int main()
{
    int ch;
    while(1)
    {
        int n,ans=0;
        printf(""\n1. Sum of the digits of a given number\n"");
        printf(""2. Sum of even digits of a given number\n"");
        printf(""3. Sum of the odd digits of a given number\n"");
        printf(""4. Exit program\n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&ch);
        if (ch==1)
        {
            printf(""\nEnter the integer: "");
            scanf(""%d"",&n);
            ans=sum(n);
            printf(""Sum of digits of %d = %d\n"",n,ans);
        }
        else if(ch==2)
        {
            printf(""\nEnter the integer: "");
            scanf(""%d"",&n);
            ans=evensum(n);
            printf(""Sum of even digits of %d = %d\n"",n,ans);
        }
        else if(ch==3)
        {
            printf(""\nEnter the integer: "");
            scanf(""%d"",&n);
            ans=oddsum(n);
            printf(""Sum of odd digits of %d = %d\n"",n,ans);
        }
        else if(ch==4)
        {
            printf(""\nExitting program. Thank you.\n"");
            break;
        }
        else
            printf(""\nINVALID CHOICE. TRY AGAIN!\n"");
    }
    return 0;
}",11,422,666
"#define NROWS 10
#define NCOLS  10
int isValidRC(int r,int c)
{
    if(r>NROWS||r<=0)
    {
        printf(""ERROR: Number of rows must be 1-10"");
        return 0;
    }
    else if(c>NCOLS||c<=0)
    {
        printf(""ERROR: Number of columns must be 1-10"");
        return 0;
    }
    else
    return 1;
}
void readMat(int mat[NROWS][NCOLS],int r,int c)
{
    for(int i=0;i<r;i++)
    {
        for(int j=0;j<c;j++)
            scanf(""%d"",&mat[i][j]);
    }
}
void multMat(int r1,int c1,int mat1[][NCOLS],int r2,int c2,int mat2[][NCOLS],int sum[][NCOLS])
{
    if(c1!=r2)
    {
        printf(""ERROR: Number of columns in 1st matrix must equal number of rows in 2nd Matrix"");
        exit(1);
    }
    else
    {
    for(int i=0;i<r1;i++)
    {
        for(int j=0;j<c2;j++)
        {
            sum[i][j]=0;
        }
    }
    for(int i=0;i<r1;i++)
    {
        for(int j=0;j<c2;j++)
        {
            for(int k=0;k<c1;k++)
            {
                sum[i][j]+=mat1[i][k]*mat2[k][j];
            }
        }
    }
    }
}
void dispMat(int sum[][NCOLS],int r1,int c2)
{
    for(int i=0;i<r1;i++)
    {
        for(int j=0;j<c2;j++)
        {
            printf(""%d "",sum[i][j]);
        }
        printf(""\n"");
    }
}
int main()
{
        int r1, c1, mat1[NROWS][NCOLS],r2, c2, mat2[NROWS][NCOLS],sum[NROWS][NCOLS];
        scanf(""%d%d"", &r1, &c1);
        if (!isValidRC(r1, c1)) return 1;
        readMat(mat1, r1, c1);
        scanf(""%d%d"", &r2, &c2);
        if (!isValidRC(r2, c2)) return 1;
        readMat(mat2, r2, c2);
        multMat(r1, c1, mat1, r2, c2, mat2, sum);
        dispMat(sum, r1, c2);
        return 0;
}
",11,423,740
"#define MAX 100
int bSearch(int arr[],int n,int val,int* p){
    static int c=0;
    static int l=0;
    if(n==0){
        printf(""ERROR: Empty list\n"");
        exit(1);
    }
    if(n<l){
        printf(""ERROR:Not found\n"");
        exit(1);
    }
    int m=(l+n)/2;
    if(arr[m]==val){
        *p=m;
        return c;
    }
    c++;
    if(arr[m]>val)
        return bSearch(arr, m-1, val, p);
    else
    {
        l=m+1;
        return bSearch(arr, n, val, p);
    }
}
int main()
{
    int arr[MAX], pos, n, val, passes;
    
    scanf(""%d"",&n);
    
    for(int i=0;i<n;i++)
        scanf(""%d"",&arr[i]);
    
    scanf(""%d"",&val);
    passes = bSearch(arr, n, val, &pos);
    printf(""%d found at index: %d. Number of passes: %d"", val, pos, passes);
    return 0;
}",11,424,323
"typedef struct s
{
    int data;
    struct s* next;
}node;
node* createNode()
{
    node* newnode=malloc(sizeof(node));
    newnode->data=0;
    newnode->next=NULL;
    return newnode;
}
void push(node** head, int n)
{
    node* linklist=createNode();
    linklist->data=n;
    linklist->next=*head;
    *head=linklist;
    printf(""%d pushed to stack\n"",n);
}
int isempty(node* head)
{
    if(head==NULL)
        return 1;
    else
        return 0;
}
void pop(node** head)
{
    if(isempty(*head))
        printf(""STACK EMPTY\n"");
    else
    {
        node* temp=*head;
        *head=(*head)->next;
        printf(""%d popped from stack\n"",temp->data);
        free(temp);
    }
}
int main()
{
    int ch;
    node* head=NULL;
    while(1)
    {
        printf(""\n"");
        printf(""1. PUSH\n"");
        printf(""2. POP\n"");
        printf(""3. EXIT\n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&ch);
        if (ch==1)
        {
            int n;
            scanf(""%d"",&n);
            push(&head,n);
        }
        else if (ch==2)
            pop(&head);
        else if (ch==3)
        {
            printf(""Exitting program, Thank you.\n"");
            break;
        }
        else
            printf(""Invalid, choice try again.\n"");
    }
    return 0;
}",11,425,449
"int n;
static int c=1;
void printArray(int arr[])
{
    int i;
    for (i=0; i < n; i++)
        printf(""%d "", arr[i]);
    printf(""\n"");
}
void swap(int* a, int* b)
{
    int t = *a;
    *a = *b;
    *b = t;
}
int partition (int arr[], int low, int high)
{
    int pivot = high;
    int i = low,j=high;
    while (i < j) {
        while (arr[i] < arr[pivot] && i <= high)
            i++;
        while (arr[j] >= arr[pivot] && j >= low)
            j--;
        if(i<j)
            swap(&arr[i],&arr[j]);
    }
    swap(&arr[i],&arr[pivot]);
    return (i);
}
void quickSort(int arr[], int low, int high)
{
    if (low < high)
    {
        printf(""%d: "",c++);
        printArray(arr);
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
int main()
{
    
    scanf(""%d"",&n);
    if(n<1||n>50)
    {
        printf(""ERROR"");
        exit(1);
    }
    int arr[n];
    for (int i = 0; i < n; i++)
        scanf(""%d"",&arr[i]);
    printf(""Original: "");
    printArray(arr);
    printf(""%d: "",c++);
    printArray(arr);
    quickSort(arr, 0, n-1);
    printf(""Sorted: "");
    printArray(arr);
    return 0;
}",11,426,475
"int N;
int safe(int arr[N][N], int row, int col){
    int i,j;
    for ( i = 0; i < col; i++){
        if(arr[row][i])
            return 0;
    }
    for ( i = row, j = col; i >= 0 && j >= 0; i--, j--){
        if(arr[i][j])
            return 0;
    }
    for ( i = row, j = col; i < N && j >= 0; i++, j--){
        if(arr[i][j])
            return 0;
    }
    return 1;
}
int queens(int arr[N][N],int n){
    if(n>=N)
        return 1;
    for (int i = 0; i < N; i++)
    {
        if(safe(arr,i,n)){
            arr[i][n]=1;
            if(queens(arr,n+1))
                return 1;
            arr[i][n]=0;
        }
    }
    return 0;
}
int main(){
    int n=1;
    while(n){
        printf(""Enter valid N i.e no of rows and columns: "");
        scanf(""%d"",&N);
        if(N>0)
            n=0;
    }
    int arr[N][N];
    for (int i = 0; i < N; i++){
        for (int j = 0; j < N; j++)
            arr[i][j]=0;
    }
    int ans=queens(arr,0);
    if(ans==0)
        printf(""\nSolution doesn't exist.\n"");
    else{
        printf(""\nSolution by placing queens at:"");
        for (int i = 0; i < N; i++)
            for (int j = 0; j < N; j++)
                if(arr[i][j])
                    printf("" %d,%d"",i,j);
        printf("".\n"");
    }
    return 0;
}",11,427,515
"typedef struct{
    int n;
    int** mat;
}gph;
typedef struct{
    int top;
    int* items;
}stk;
void input(gph* g){
    int i,j,f,x=1;
    while(x){
        printf(""\nEnter the number of vertices: "");
        scanf(""%d"",&g->n);
        if(g->n>0)
            x=0;
        else
            printf(""Invalid input.\n"");
    }
    g->mat=(int**) malloc(sizeof(int*)*g->n);
    for(i=0;i<g->n;i++)
        g->mat[i]=(int*)malloc(sizeof(int)*g->n);
    for(i=0;i<g->n;i++)
        for(j=0;j<g->n;j++)
            g->mat[i][j]=-1;
    for(i=0;i<g->n;i++)
        for(j=0;j<g->n;j++){
            if(g->mat[i][j]==1 || g->mat[i][j]==0)
                continue;
            if(i==j){
                g->mat[i][j]=0;
                continue;
            }
            x=1;
            while(x){
                printf(""Is there an edge between %c and %c (Yes=1 & No=0): "",'A'+i,'A'+j);
                scanf(""%d"",&f);
                if(f==0 || f==1){
                    g->mat[i][j]=f;
                    g->mat[j][i]=f;
                    x=0;
                }
                else
                    printf(""Invalid input.\n"");
            }
        }
}
void initialise(stk* s, int n){
    s->top=-1;
    s->items=(int*)malloc(sizeof(int)*n);
}
void push(stk* s, int n){
    s->items[++(s->top)]=n;
}
int peek(stk* s){
    return s->items[s->top];
}
void pop(stk* s){
    s->top--;
}
void dfs(gph g, int x){
    stk s;
    initialise(&s,g.n);
    int visited[g.n],i,f,t;
    for(i=0;i<g.n;i++)
        visited[i]=0;
    printf(""\nFollowing is the DFS Traversal (starting from %c): \n"",'A'+x);
    visited[x]=1;
    printf(""%c\t"",'A'+x);
    push(&s,x);
    while(s.top!=-1){
        f=peek(&s);
        t=1;
        for(i=0; i<g.n; i++)
            if(g.mat[f][i])
                if(!visited[i]){
                    visited[i]=1;
                    printf(""%c\t"",'A'+i);
                    push(&s,i);
                    t=0;
                    break;
                }
        if(t)
            pop(&s);
    }
}
void free_graph(gph* g){
    for(int i=0; i<g->n; i++)
        free(g->mat[i]);
    free(g->mat);
}
int main(){
    gph g;
    int f=1,x;
    input(&g);
    printf(""\n\' If"");
    for(int i=0; i<g.n;i++)
        printf("" %c=%d"",'A'+i,i+1);
    printf("" \'\nEnter the initial vertex: "");
    while(f){
        scanf(""%d"",&x);
        if(x>0 && x<g.n+1)
            f=0;
        else
            printf(""Invalid input.\n"");
    }
    dfs(g,x-1);
    free_graph(&g);
}",11,428,1006
"typedef struct x
{
    struct x* prev;
    int data;
    struct x* next;
}node;
void sort_insertion(node** head, int n)
{
    node* dll=(node*)malloc(sizeof(node));
    dll->data=n;
    dll->next=NULL;
    dll->prev=NULL;
    if(*head==NULL)
        *head=dll;
    else if(dll->data <= (*head)->data)
    {
        (*head)->prev=dll;
        dll->next=*head;
        *head=dll;
    }
    else
    {
        node* temp=*head;
        while(temp->next != NULL && temp->next->data < dll->data)
            temp=temp->next;
        dll->prev=temp;
        dll->next=temp->next;
        temp->next=dll;
        if(dll->next!=NULL)
            dll->next->prev=dll;
    }
}
void seq_insertion(node** head, int n)
{
    node* dll=(node*)malloc(sizeof(node));
    dll->data=n;
    dll->next=*head;
    dll->prev=NULL;
    if (*head!=NULL)
        (*head)->prev=dll;
    *head=dll;
}
node* search_node(node* head, int n) 
{
    node* dll=head;
    while (dll!=NULL)
    {
        if(dll->data==n)
            return dll;
        dll=dll->next;
    }
    return NULL;
}
void deletion(node** head, node* del)
{
    if (*head==del)
        *head=del->next;
    else 
    {
        if (del->next!=NULL)
            del->next->prev=del->prev;
        if (del->prev!=NULL)
            del->prev->next=del->next;
    }
    free(del);
}
void printforward(node* head)
{
    node* dll=head;
    while (dll!=NULL)
    {
        printf(""%d  "",dll->data);
        dll=dll->next;
    }
}
void printreversed(node* head)
{
    node* dll=head;
    while (dll->next!=NULL)
        dll=dll->next;
    while(dll!=NULL)
    {
        printf(""%d  "",dll->data);
        dll=dll->prev;
    }
}
int main()
{
    while (1)
    {
        int ch;
        printf(""\n1. SORTED ORDER INSERTION\n"");
        printf(""2. SEQUENTIAL ORDER INSERTION\n"");
        printf(""3. EXIT PROGRAM\n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&ch);
        if(ch==1)
        {
            printf(""\n\tSORTED ORDER\n"");
            node* head=NULL;
            int c;
            while(1)
            {
                int c;
                printf(""\n1. ENTER AN INTEGER\n"");
                printf(""2. DELETE AN INTEGER\n"");
                printf(""3. TRAVERSAL IN FORWARD DIRECTION\n"");
                printf(""4. TRAVERSAL IN REVERSE DIRECTION\n"");
                printf(""5. EXIT SORTED ORDER INSERTION\n"");
                printf(""Enter your choice: "");
                scanf(""%d"",&c);
                if(c==1)
                {
                    int n;
                    printf(""Please enter an element: "");
                    scanf(""%d"",&n);
                    sort_insertion(&head,n);
                    printf(""%d inserted using SORTED ORDER INSERTION.\n"",n);
                }
                else if(c==2)
                {
                    int n;
                    printf(""\nPlease enter the element to be deleted: "");
                    scanf(""%d"",&n);
                    if (head==NULL)
                        printf(""COULDN'T DELETE %d. LIST EMPTY\n"",n);
                    else
                    {
                        node* del_node=search_node(head,n);
                        if(del_node==NULL)
                        printf(""COULDN'T DELETE %d. NOT FOUND IN LIST.\n"",n);
                        else
                        {
                            deletion(&head,del_node);
                            printf(""%d deleted from LIST.\n"",n);
                        }
                    }
                }
                else if (c==3)
                {
                    if(head==NULL)
                        printf(""\n\tLIST EMPTY\n"");
                    else
                    {
                        printf(""\nTRAVERSAL IN FORWARD DIRECTION: \n"");
                        printforward(head);
                        printf(""\n"");
                    }
                }
                else if (c==4)
                {
                    if(head==NULL)
                        printf(""\n\tLIST EMPTY\n"");
                    else
                    {
                        printf(""\nTRAVERSAL IN REVERSE DIRECTION: \n"");
                        printreversed(head);
                        printf(""\n"");
                    }
                }
                else if (c==5)
                {
                    printf(""\nExitting Sorted Order Insertion, Thank You.\n"");
                    break;
                }
                else
                    printf(""\nINVALID CHOICE! TRY AGAIN.\n"");
            }
        }
        else if(ch==2)
        {
            printf(""\n\tSEQUENTIAL ORDER\n"");
            node* head=NULL;
            int c;
            while(1)
            {
                printf(""\n1. ENTER AN INTEGER\n"");
                printf(""2. DELETE AN INTEGER\n"");
                printf(""3. TRAVERSAL IN FORWARD DIRECTION\n"");
                printf(""4. TRAVERSAL IN REVERSE DIRECTION\n"");
                printf(""5. EXIT SEQUENTIAL ORDER INSERTION\n"");
                printf(""Enter your choice: "");
                scanf(""%d"",&c);
                if(c==1)
                {
                    int n;
                    printf(""Please enter an element: "");
                    scanf(""%d"",&n);
                    seq_insertion(&head,n);
                    printf(""%d inserted using SEQUENTIAL ORDER INSERTION.\n"",n);
                }
                else if(c==2)
                {
                    int n;
                    printf(""\nPlease enter the element to be deleted: "");
                    scanf(""%d"",&n);
                    if (head==NULL)
                        printf(""COULDN'T DELETE %d. LIST EMPTY\n"",n);
                    else
                    {
                        node* del_node=search_node(head,n);
                        if(del_node==NULL)
                            printf(""COULDN'T DELETE %d. NOT FOUND IN LIST.\n"",n);
                        else
                        {
                            deletion(&head,del_node);
                            printf(""%d deleted from LIST.\n"",n);
                        }
                    }
                }
                else if (c==3)
                {
                    if(head==NULL)
                        printf(""\n\tLIST EMPTY\n"");
                    else
                    {
                        printf(""\nTRAVERSAL IN FORWARD DIRECTION: \n"");
                        printforward(head);
                        printf(""\n"");
                    }
                }
                else if (c==4)
                {
                    if(head==NULL)
                        printf(""\n\tLIST EMPTY\n"");
                    else
                    {
                        printf(""\nTRAVERSAL IN REVERSE DIRECTION: \n"");
                        printreversed(head);
                        printf(""\n"");
                    }
                }
                else if(c==5)
                {
                    printf(""\nExitting Sequential Order Insertion, Thank You.\n"");
                    break;
                }
                else
                    printf(""\nINVALID CHOICE! TRY AGAIN.\n"");
            }
        }
        else if(ch==3)
        {
            printf(""\nExitting Program, Thank You.\n"");
            break;
        }
        else
            printf(""\nINVALID CHOICE! TRY AGAIN.\n"");
    }
    return 0;
}",11,429,2095
"typedef struct{
    int n;
    int** arr;
}graph;
typedef struct{
    int top;
    int* items;
}stack;
void input(graph* g){
    int i,j,f,x=1;
    while(x){
        printf(""\nEnter the number of vertices: "");
        scanf(""%d"",&g->n);
        if(g->n>0)
            x=0;
        else
            printf(""Invalid input. Try again.\n"");
    }
    g->arr=(int**) malloc(sizeof(int*)*g->n);
    for(i=0;i<g->n;i++)
        g->arr[i]=(int*)malloc(sizeof(int)*g->n);
    for(i=0;i<g->n;i++)
        for(j=0;j<g->n;j++)
            g->arr[i][j]=-1;
    for(i=0;i<g->n;i++)
        for(j=0;j<g->n;j++){
            if(g->arr[i][j]==1 || g->arr[i][j]==0)
                continue;
            if(i==j){
                g->arr[i][j]=0;
                continue;
            }
            x=1;
            while(x){
                printf(""Is there an edge between %c and %c (Yes=1 & No=0): "",'A'+i,'A'+j);
                scanf(""%d"",&f);
                if(f==0 || f==1){
                    g->arr[i][j]=f;
                    g->arr[j][i]=f;
                    x=0;
                }
                else
                    printf(""Invalid input. Try again.\n"");
            }
        }
}
void initialiseStack(stack* s, int n){
    s->top=-1;
    s->items=(int*)malloc(sizeof(int)*n);
}
void push(stack* s, int n){
    s->items[++(s->top)]=n;
}
int peek(stack* s){
    return s->items[s->top];
}
void pop(stack* s){
    s->top--;
}
void dfs(graph g, int x){
    stack s;
    initialiseStack(&s,g.n);
    int visited[g.n],i,f,t;
    for(i=0;i<g.n;i++)
        visited[i]=0;
    printf(""\nFollowing is the DFS Traversal (starting from %c): \n"",'A'+x);
    visited[x]=1;
    printf(""%c\t"",'A'+x);
    push(&s,x);
    while(s.top!=-1){
        f=peek(&s);
        t=1;
        for(i=0; i<g.n; i++)
            if(g.arr[f][i])
                if(!visited[i]){
                    visited[i]=1;
                    printf(""%c\t"",'A'+i);
                    push(&s,i);
                    t=0;
                    break;
                }
        if(t)
            pop(&s);
    }
}
void free_graph(graph* g){
    for(int i=0; i<g->n; i++)
        free(g->arr[i]);
    free(g->arr);
}
int main(){
    graph g;
    int f=1,x;
    input(&g);
    printf(""\n\' If"");
    for(int i=0; i<g.n;i++)
        printf("" %c=%d"",'A'+i,i+1);
    printf("" \'\nEnter the initial vertex: "");
    while(f){
        scanf(""%d"",&x);
        if(x>0 && x<g.n+1)
            f=0;
        else
            printf(""Invalid input. Try again.\n"");
    }
    dfs(g,x-1);
    free_graph(&g);
}",11,430,1006
"typedef struct q{
    int coeff;
    int pow;
    struct q* next;
}node;
void createNode(int c, int p, node** exp)
{
    if(c==0)
        return;
    node* x=*exp;
    while(x)
    {
        if(x->pow == p)
        {
            if(x->coeff < 0 && c < 0)
                x->coeff=-(x->coeff+c);
            else
                x->coeff=x->coeff+c;
            return;
        }
        x=x->next;
    }
    node* ret=(node*) malloc(sizeof(node));
    ret->coeff=c;
    ret->pow=p;
    if(*exp==NULL)
    {
        ret->next=*exp;
        *exp=ret;
    }
    else
    {
            if(p > (*exp)->pow)
            {
                ret->next=*exp;
                *exp=ret;
            }
            else
            {
                x=*exp;
                while(x->next!=NULL && x->next->pow > p)
                    x=x->next;
                ret->next=x->next;
                x->next=ret;
            }
    }
}
node* poly_add_sub(char task, node* exp1, node* exp2)
{
    node* res=NULL;
    while(exp1 || exp2)
    {
        if(!exp2)
        {
            createNode(exp1->coeff,exp1->pow,&res);
            exp1=exp1->next;
        }
        else if(!exp1)
        {
            if(task=='+')
                createNode(exp2->coeff,exp2->pow,&res);
            else
            createNode(-(exp2->coeff),exp2->pow,&res);
            exp2=exp2->next;
        }
        else if(exp1->pow > exp2->pow)
        {
            createNode(exp1->coeff,exp1->pow,&res);
            exp1=exp1->next;
        }
        else if(exp1->pow < exp2->pow)
        {
            if(task=='+')
                createNode(exp2->coeff,exp2->pow,&res);
            else
                createNode(-(exp2->coeff),exp2->pow,&res);
            exp2=exp2->next;
        }
        else if(exp1->pow == exp2->pow )
        {
            if(task=='+' && (exp1->coeff + exp2->coeff)!=0)
                createNode(exp1->coeff+exp2->coeff,exp1->pow,&res);
            else if(task=='-' && (exp1->coeff - exp2->coeff)!=0)
                createNode(exp1->coeff-exp2->coeff,exp1->pow,&res);
            exp1=exp1->next;
            exp2=exp2->next;
        }
    }
    return res;
}
node* poly_mul(node* exp1, node* exp2)
{
    node* res=NULL;
    node* t=exp2;
    while(exp1)
    {
        while(t)
        {
            createNode(exp1->coeff * t->coeff,exp1->pow + t->pow,&res);
            t=t->next;
        }
        t=exp2;
        exp1=exp1->next;
    }
    return res;
}
void display(node* res)
{
    int f=0;
    while(res)
    {
        if(res->coeff>0)
        {
            if(f==0)
                printf("" %dx^%d "",res->coeff,res->pow);
            else
                printf(""+ %dx^%d "",res->coeff,res->pow);
        }
        else if(res->coeff<0)
            printf(""- %dx^%d "",-res->coeff,res->pow);
        f=1;
        res=res->next;
    }
}
int main()
{
    {
        node* exp1=NULL; node* exp2=NULL;
        char fexp[51],sexp[51];
        printf(""Input in this format \"" +/- ax^y +/- ... +/- ... \""\n"");
        printf(""Enter 1st Exp. = "");
        gets(fexp);
        printf(""Enter 2nd Exp. = "");
        gets(sexp);
        if(strlen(fexp)==0 && strlen(sexp)==0)
        {
            printf(""No expression found.\n"");
            exit(1);
        }
        else if(strlen(fexp)>=51 || strlen(sexp)>=51)
        {
            printf(""Expressions too lengthy.\n"");
            exit(1);
        }
        else if(strlen(fexp)!=0 && strlen(sexp)==0)
            printf("" %s\n"",fexp);
        else if(strlen(fexp)==0 && strlen(sexp)!=0)
            printf("" %s\n"",sexp);
        else
        {
            {
                if(fexp[0]!='-'){
                    for(int i=50; i>0; i--) fexp[i]=fexp[i-1];
                    fexp[0]='+';
                }
                int t=0,c1=0,c2=0;
                char a[10],b[10];
                for(int i=0; i<=strlen(fexp); i++)
                {
                    if(fexp[i]==' ')
                        continue;
                    else if(t==0)
                    {
                        if(fexp[i]=='x'){
                            t=1;
                            i++;
                            if(fexp[i+1]=='-' && fexp[i+2]!=' ')
                            {
                                i++;
                                b[c2++]=fexp[i];
                            }
                        }
                        else
                            a[c1++]=fexp[i];
                    }
                    else if(fexp[i]=='+' || fexp[i]=='-' || fexp[i]=='\0')
                        {
                            t=0;
                            if(atoi(a)!=0)
                                createNode(atoi(a),atoi(b),&exp1);
                            if(fexp[i]!='\0')
                            {
                                for (int j = 0; j < 10; j++)
                                    a[j]=b[j]='\0';
                                c1=c2=0;
                                a[c1++]=fexp[i];
                            }
                        }
                    else if(t==1)
                            b[c2++]=fexp[i];
                }
            }
            {
                if(sexp[0]!='-'){
                    for(int i=50; i>0; i--) sexp[i]=sexp[i-1];
                    sexp[0]='+';
                }
                int t=0,c1=0,c2=0;
                char a[10],b[10];
                for(int i=0; i<=strlen(sexp); i++)
                {
                    if(sexp[i]==' ')
                        continue;
                    else if(t==0)
                    {
                        if(sexp[i]=='x'){
                            t=1;
                            i++;
                            if(sexp[i+1]=='-')
                            {
                                i++;
                                b[c2++]=sexp[i];
                            }
                        }
                        else
                            a[c1++]=sexp[i];
                    }
                    else if(t==1)
                    {
                        if(sexp[i]=='+' || sexp[i]=='-' || sexp[i]=='\0')
                        {
                            t=0;
                            if(atoi(a)!=0)
                                createNode(atoi(a),atoi(b),&exp2);
                            if(sexp[i]!='\0')
                            {
                                for (int j = 0; j < 10; j++)
                                    a[j]=b[j]='\0';
                                c1=c2=0;
                                a[c1++]=sexp[i];
                            }
                        }
                        else
                            b[c2++]=sexp[i];
                    }
                }
            }
            while(1)
            {
                int ch;
                printf(""\n\n1. ADDITION\n"");
                printf(""2. SUBTRACTION\n"");
                printf(""3. MULTIPLICATION\n"");
                printf(""4. PRINT EXPRESSIONS\n"");
                printf(""5. EXIT PROGRAM\n"");
                printf(""What operation do you want to perform: "");
                scanf(""%d"",&ch);
                if(ch==5)
                {
                    printf(""Exitting Program, Thank You.\n"");
                    break;
                }
                switch (ch)
                {
                case 1:
                    printf(""\n"");
                    display(poly_add_sub('+',exp1,exp2));
                    break;
                case 2:
                    printf(""\n"");
                    display(poly_add_sub('-',exp1,exp2));
                    break;
                case 3:
                    printf(""\n"");
                    display(poly_mul(exp1,exp2));
                    break;
                case 4:
                    printf(""\nExpression 1: "");
                    display(exp1);
                    printf(""\nExpression 2: "");
                    display(exp2);
                    break;
                default:
                    printf(""Invalid choice!\n"");
                    break;
                }
            }
        }
    }
    return 0;
}",11,431,2534
"typedef struct x
{
    int data;
    struct x* left;
    struct x* right;
}node;
node* createNode(int n)
{
    node* newNode=(node*)malloc(sizeof(node));
    newNode->data=n;
    newNode->left=NULL;
    newNode->right=NULL;
    return newNode;
}
node* rec_insertion(node* root, int n)
{
    if(root==NULL) return createNode(n);
    else if(n<root->data) root->left=rec_insertion(root->left,n);
    else if(n>root->data) root->right=rec_insertion(root->right,n);
    return root;
}
void iter_insertion(node** root, int n)
{
    node*** temp=&root;
    while(**temp!=NULL)
    {
        if(n < (**temp)->data) *temp=&(**temp)->left;
        else *temp=&(**temp)->right;
    }
    **temp=createNode(n);
}
void rec_inorder(node* root) 
{ 
    if (root != NULL) 
    { 
        rec_inorder(root->left); 
        printf(""\t%d\n"", root->data); 
        rec_inorder(root->right); 
    } 
}
void rec_preorder(node* root) 
{ 
    if (root != NULL) 
    {
        printf(""\t%d\n"", root->data); 
        rec_preorder(root->left);
        rec_preorder(root->right);
    }
} 
void rec_postorder(node* root) 
{ 
    if (root != NULL) 
    { 
        rec_postorder(root->left);
        rec_postorder(root->right);
        printf(""\t%d\n"", root->data); 
    }
} 
int main()
{
    int ch;
    node* root=NULL;
    while (1)
    {
        printf(""\n1. RECURSIVE INSERTION\n"");
        printf(""2. ITERATIVE INSERTION\n"");
        printf(""3. IN-ORDER TRAVERSAL\n"");
        printf(""4. PRE-ORDER TRAVERSAL\n"");
        printf(""5. POST-ORDER TRAVERSAL\n"");
        printf(""6. EXIT\n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&ch);
        if(ch==1)
        {
            int n;
            printf(""Please enter an element: "");
            scanf(""%d"",&n);
            root=rec_insertion(root,n);
            printf(""%d inserted in BINARY SEARCH TREE using Recursive Insertion\n"",n);
        }
        else if(ch==2)
        {
            int n;
            printf(""Please enter an element: "");
            scanf(""%d"",&n);
            iter_insertion(&root,n);
            printf(""%d inserted in BINARY SEARCH TREE using Iterative Insertion\n"",n);
        }
        else if(ch==3)
        {
            printf(""\n     IN-ORDER\n"");
            rec_inorder(root);
        }
        else if(ch==4)
        {
            printf(""\n     PRE-ORDER\n"");
            rec_preorder(root);
        }
        else if(ch==5)
        {
            printf(""\n     POST-ORDER\n"");
            rec_postorder(root);
        }
        else if(ch==6)
        {
            printf(""Exitting Program, Thank You.\n"");
            break;
        }
        else
            printf(""INVALID CHOICE! TRY AGAIN\n"");
    }
    return 0;
}",11,432,943
"int N;
void printboard(int arr[N][N]){
    static int n=1;
    printf(""\nSolution No. %d: \n"",n++);
    for (int i = 0; i < N; i++){
        for (int j = 0; j < N; j++){
            if(arr[i][j])
                printf("" R "");
            else
                printf("" - "");
        }
        printf(""\n"");
    }
}
int safe(int arr[N][N], int row, int col){
    int i,j;
    for (i = row-1, j = col-1; i >= 0 && j >= 0; i--, j--)
        if(arr[i][j])
            return 0;
    for (i = row+1, j = col+1; i < N && j < N; i++, j++)
        if(arr[i][j])
            return 0;
    for (i = row+1, j = col-1; i < N && j >= 0; i++, j--)
        if(arr[i][j])
            return 0;
    for (i = row-1, j = col+1; i >= 0 && j < N; i--, j++)
        if(arr[i][j])
            return 0;
    return 1;
}
void bishops(int arr[N][N], int c){
    if(c>=N){
        printboard(arr);
        if(N>1){
            int trs[N][N];
            for (int i = 0; i < N; i++)
                for (int j = 0; j < N; j++)
                    trs[j][i]=arr[i][j];
            printboard(trs);
        }
        return;
    }
    for (int i = 0; i < N; i++){
        if(safe(arr,i,c)){
            arr[i][c]=1;
            bishops(arr,c+1);
            arr[i][c]=0;
        }
    }
}
int main(){
    int x=1;
    while(x){
        printf(""Enter valid N i.e. for no of rows and columns: "");
        scanf(""%d"",&N);
        if(N>0)
            x=0;
    }
    int arr[N][N];
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            arr[i][j]=0;
    bishops(arr,0);
    return 0;
}",11,433,644
"void inputArray(int arr[], int len){   
    for (int i = 0; i < len; i++)
        scanf(""%d"", &arr[i]);
}
void printArray(int arr[], int len){   
    for (int i = 0; i < len; i++)
            printf(""%d "", arr[i]);
    printf(""\n"");
}
void selectionSort(int arr[], int len){ 
    int min,i,j,t;
    for(i=0;i<len-1;i++)
    {
        min=i;   
        for(j=i+1;j<len;j++)   
        {
            if(arr[j]<arr[min])
                min=j;;
        }
        t=arr[i];
        arr[i]=arr[min];   
        arr[min]=t;
        printf(""Pass %d: "",i+1); 
        printArray(arr,len);   
    }
}
int main(){
    int len;
    scanf(""%d"", &len);   
    int arr[len];
    if (len<=0){   
            printf(""ERROR: Empty list\n"");
            exit(1);
    }
    inputArray( arr, len );   
    selectionSort(arr, len);   
    printf(""Sorted: "");
        printArray(arr,len);   
    return 0;
}
",11,434,341
"#define MAX 50
typedef struct
{
    int top;
    unsigned int size;
    float* arr;
}stack;
stack* createStack(unsigned int x)
{
    stack* ret=(stack*) malloc(sizeof(stack));
    ret->top=-1;
    ret->size=x;
    ret->arr=(float*) malloc(x * sizeof(float));
    return ret;
}
int reverse(int x)
{
    int f=0;
    while(x>0){
        f=(f*10)+x%10;
        x=x/10;
    }
    return f;
}
float c2i(char x)
{
    return (int)x - (int)'0';
}
void push(stack* stk, float n)
{
    printf(""Pushed %f\n"",n);
    stk->arr[++(stk->top)]=n;
}
float pop(stack* stk)
{
    printf(""\nPopped %f\n"",stk->arr[stk->top]);
    return stk->arr[stk->top--];
}
int isOperator(char ch)
{
    if (ch=='+' || ch=='-' || ch=='*' || ch=='/')
        return 1;
    else
        return 0;
}
float operation(float f, char x, float s)
{
    if (x=='+')
        return f+s;
    if (x=='-')
        return f-s;
    if (x=='*')
        return f*s;
    else
        return f/s;
}
float evaluatePrefix(char exp[])
{
    stack* stk=createStack(strlen(exp));
    int i=strlen(exp)-1;
    float f=0,s=0,t=0;
    while (i>=0)
    {
        if((exp[i]==',' && exp[i-1]==',') || (exp[i]==' ' && exp[i-1]==' '))
            i--;
        else if((exp[i]==',' && exp[i-1]==' ') || (exp[i]==' ' && exp[i-1]==','))
        {
            printf(""Invalid operator or operand encountered.\n"");
            return 0;
        }
        else if((int)exp[i]>47 && (int)exp[i]<58)
            t=(t*10)+c2i(exp[i]);
        else if(exp[i]==',' || exp[i]==' ')
        {
            push(stk,reverse(t));
            t=0;
        }
        else if(isOperator(exp[i]))
        {
            if(stk->top-2<-1)
            {
                printf(""Underflow, not enough operands.\n"");
                return 0;
            }
            f=pop(stk);
            s=pop(stk);
            push(stk,operation(f,exp[i],s));
            if(i-1>-1)
                i--;
        }
        else
        {
            printf(""Invalid operator or operand encountered.\n"");
            return 0;
        }
        i--;
    }
    if(stk->top!=0)
    {
        printf(""Overflow, too may operands.\n"");
        return 0;
    }
    return stk->arr[stk->top];
}
int main()
{
    while(1)
    {
        char exp[MAX+1];
        printf(""\nTo exit enter a blank expression.\n"");
        printf(""Enter a postfix expression: "");
        gets(exp);
        if(strlen(exp)>50){
            printf(""Overflow, expression length greater than 50.\n"");
            break;
        }
        else if(strlen(exp)==0){
            printf(""No expression found.\n"");
            break;
        }
        else
        { 
            float ans=evaluatePrefix(exp);
            if(ans)
                printf(""Prefix Evaluation: %.2f\n"",ans);
        }
    }
    return 0;
}",11,435,1030
"typedef struct{
    int n;
    int** arr;
}graph;
typedef struct{
    int end;
    int* items;
}queue;
void input(graph* g){
    int i,j,f,x=1;
    while(x){
        printf(""\nEnter the number of vertices: "");
        scanf(""%d"",&g->n);
        if(g->n>0)
            x=0;
        else
            printf(""Invalid input. Try again.\n"");
    }
    g->arr=(int**) malloc(sizeof(int*)*g->n);
    for(i=0;i<g->n;i++)
        g->arr[i]=(int*)malloc(sizeof(int)*g->n);
    for(i=0;i<g->n;i++)
        for(j=0;j<g->n;j++)
            g->arr[i][j]=-1;
    for(i=0;i<g->n;i++)
        for(j=0;j<g->n;j++){
            if(g->arr[i][j]==1 || g->arr[i][j]==0)
                continue;
            if(i==j){
                g->arr[i][j]=0;
                continue;
            }
            x=1;
            while(x){
                printf(""Is there an edge between %c and %c (Yes=1 & No=0): "",'A'+i,'A'+j);
                scanf(""%d"",&f);
                if(f==0 || f==1){
                    g->arr[i][j]=f;
                    g->arr[j][i]=f;
                    x=0;
                }
                else
                    printf(""Invalid input. Try again.\n"");
            }
        }
}
void initialiseQueue(queue* q, int n){
    q->end=-1;
    q->items=(int*) malloc(sizeof(int)*n);
}
void enqueue(queue* q, int n){
    q->items[++(q->end)]=n;
}
int dequeue(queue* q){
    int ret=q->items[0];
    for(int i=0; i<q->end; i++)
        q->items[i]=q->items[i+1];
    q->end--;
    return ret;
}
void bfs(graph g, int s){
    queue q;
    initialiseQueue(&q,g.n);
    int visited[g.n],i,f;
    for(i=0;i<g.n;i++)
        visited[i]=0;
    visited[s]=1;
    enqueue(&q,s);
    printf(""\nFollowing is the BFS Traversal (starting from %c): \n"",'A'+s);
    while(q.end!=-1){
        f=dequeue(&q);
        printf(""%c\t"",'A'+f);
        for (i = 0; i < g.n; i++)
            if(g.arr[f][i])
                if(!visited[i]){
                    visited[i]=1;
                    enqueue(&q,i);
                }
    }
}
void free_graph(graph* g){
    for(int i=0; i<g->n; i++)
        free(g->arr[i]);
    free(g->arr);
}
int main(){
    graph g;
    int f=1,s;
    input(&g);
    printf(""\n\' If"");
    for(int i=0; i<g.n;i++)
        printf("" %c=%d"",'A'+i,i+1);
    printf("" \'\nEnter the initial vertex: "");
    while(f){
        scanf(""%d"",&s);
        if(s>0 && s<g.n+1)
            f=0;
        else
            printf(""Invalid input. Try again.\n"");
    }
    bfs(g,s-1);
    free_graph(&g);
}",11,436,992
"typedef struct s
{
    int data;
    struct s* next;
}node;
node* createNode(node* head, int n)
{
    node* newnode=malloc(sizeof(node));
    newnode->data=n;
    newnode->next=head;
    return newnode;
}
node* insert(node* head, int data)
{
    if(head==NULL)
        return createNode(head,data);
    else
        head->next=insert(head->next,data);
    return head;
}
void delete(node** head, int key)
{
    if(*head==NULL)
        printf(""Oops! Can't delete, STACK EMPTY\n"");
    else
    {
        int c=0,f=0;
        node* prev;
        node* cur=*head;
        while(cur != NULL)
        {
            c++;
            if(c==1)
            {    
                if (cur->data==key)
                {
                    *head=cur->next;
                    free(cur);
                    cur=*head;
                    f=1;c=0;
                }
                else
                {
                    prev=cur;
                    cur=cur->next;
                }
            }
            else
            {
                if(cur->data==key)
                {
                    prev->next=cur->next;
                    free(cur);
                    cur=prev->next;
                    f=1;
                }
                else
                {
                    prev=cur;
                    cur=cur->next;
                }
            }
        }
        if(f==0)
            printf(""NO MATCH FOUND\n"");
        else
            printf(""MATCH FOUND!\nAll matching elements deleted\n"");
    }
}
node* rec_reverse(node* head)
{
    if(head == NULL || head->next == NULL)
        return head;
    node* revHead = rec_reverse(head->next);
    head->next->next = head;
    head->next = NULL; 
    return revHead;
}
int count(node* head)
{
    if(head==NULL)
        return 0;
    else
        return count(head->next)+1;
}
node* print(node* head)
{
    if(head==NULL)
        return NULL;
    else if(head->next==NULL)
    {
        printf(""      STACK      \n"");
        return head;
    }
    else
    {
        printf(""\t%d\n"",(print(head->next))->data);
        return head;
    }
}
int main()
{
    int ch;
    node* head=NULL;
    while(1)
    {
        printf(""\n"");
        printf(""1. INSERT\n"");
        printf(""2. DELETE\n"");
        printf(""3. REVERSE\n"");
        printf(""4. COUNT\n"");
        printf(""5. PRINT\n"");
        printf(""6. EXIT\n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&ch);
        if (ch==1)
        {
            int n;
            printf(""Enter the element: "");
            scanf(""%d"",&n);
            head=insert(head, n);
        }
        else if (ch==2)
        {
            int key;
            printf(""Enter the element you want to delete: "");
            scanf(""%d"",&key);
            delete(&head,key);
        }
        else if (ch==3)
        {
            if(head==NULL)
                printf(""Oops!, Can't REVERSE, STACK EMPTY\n"");
            else
            {
                head=rec_reverse(head);
                printf(""Link-List Reversed\n"");
            }
        }
        else if (ch==4)
            printf(""Count of elements are= %d\n"",count(head));
        else if (ch==5)
        {
            node* temp=print(head);
            if(temp==NULL)
                printf(""CAN'T PRINT, STACK EMPTY\n"");
            else
                printf(""\t%d\n"",temp->data);
        }
        else if (ch==6)
        {
            printf(""Exitting program, Thank you.\n"");
            break;
        }
        else
            printf(""Invalid, choice try again.\n"");
    }
    return 0;
}",11,437,1098
"int max(int* arr, int n){
    int m=0;
    for (int i = 0; i < n; i++){
        if(arr[i]>m)
            m=arr[i];
    }
    return m;
}
int min(int* arr, int n){
    int m=arr[0];
    for (int i = 0; i < n; i++){
        if(arr[i]<m)
            m=arr[i];
    }
    return m;
}
int main(){
    int n;
    int* arr;
    printf(""Enter the size of the dynamic array: "");
    scanf(""%d"",&n);
    arr=(int*) malloc(sizeof(int)*n);
    for (int i = 0; i < n; i++){
        printf(""Enter the %dth element: "",i+1);
        scanf(""%d"",&arr[i]);
    }
    printf(""\nMaximum Element = %d\n"",max(arr,n));
    printf(""Minimum Element = %d\n"",min(arr,n));
}",11,438,267
"#define MAX 50
int arr[MAX], n;
static int c=1;
void printArray()
{
    int i;
    for (i=0; i < n; i++)
        printf(""%d "", arr[i]);
    printf(""\n"");
}
void merge_array(int a, int b, int c, int d) {
    int temp[n];
    int i = a, j = c, k = 0;
    while (i <= b && j <= d) {
        if (arr [i] < arr[j])
            temp[k++] = arr [i++];
        else
            temp[k++] = arr[j++];
    }
    while (i <= b)
        temp[k++] = arr[i++];
    while (j <= d)
        temp[k++] = arr[j++];
    for (i = a, j = 0; i <= d; i++, j++)
        arr[i] = temp[j];
}
void merge_sort(int i, int j) {
    int m;
    if (i < j) {
        m = (i + j) / 2;
        merge_sort(i, m);
        merge_sort(m + 1, j);
        merge_array(i, m, m + 1, j);
        printf(""%d: "",c++);
        printArray();
    }
}
int main() {
    int i;
    scanf(""%d"",&n);
    if(n<1||n>50)
    {
        printf(""ERROR"");
        exit(1);
    }
    for (i = 0; i < n; i++)
        scanf(""%d"", &arr[i]);
    printf(""Original: "");
    printArray();
    merge_sort(0, n - 1);
    printf(""Sorted: "");
    printArray();
    return 0;
}",11,439,465
"#define MAX 125
#define NAME_SIZE 50
typedef struct student {
    int rollNo;
    char name[NAME_SIZE];
} studentType;
void dispStudents ( studentType students[], int n ) {
    int i;
    for (i=0; i<n; i++)
        printf(""#%d Roll: %d | Name:%s\n"",i+1, students[i].rollNo, students[i].name );
}
int enterStudents( studentType students[MAX] )
{
    int i;
    for (i = 0; i < MAX; i++)
    {
        scanf(""%d"",&students[i].rollNo);
        if(students[i].rollNo==0)
            break;
        scanf(""%[^\n]s"",students[i].name);
    }
    return i;
}

int main() {
    int n;
    studentType students[MAX]; 
    
    n = enterStudents( students );
    
    dispStudents( students, n );
    return 0;
}",11,440,269
"typedef struct n
{ 
    int key;
    struct n *prev, *next; 
}list;
void sort_insertion(list** head, int n)
{
    list* node=(list*)malloc(sizeof(list));
    node->key=n;
    node->next=NULL;
    node->prev=NULL;
    if(*head==NULL)
        *head=node;
    else if(node->key <= (*head)->key)
    {
        (*head)->prev=node;
        node->next=*head;
        *head=node;
    }
    else
    {
        list* temp=*head;
        while(temp->next != NULL && temp->next->key < node->key)
            temp=temp->next;
        node->prev=temp;
        node->next=temp->next;
        temp->next=node;
        if(node->next!=NULL)
            node->next->prev=node;
    }
}
void seq_insertion(list** head, int n)
{
    list* dll=(list*)malloc(sizeof(list));
    dll->key=n;
    dll->next=*head;
    dll->prev=NULL;
    if (*head!=NULL)
        (*head)->prev=dll;
    *head=dll;
}
list* search_node(list* head, int n) 
{
    list* dll=head;
    while (dll!=NULL)
    {
        if(dll->key==n)
            return dll;
        dll=dll->next;
    }
    return NULL;
}
void deletion(list** head, list* del)
{
    if (*head==del)
        *head=del->next;
    else 
    {
        if (del->next!=NULL)
            del->next->prev=del->prev;
        if (del->prev!=NULL)
            del->prev->next=del->next;
    }
    free(del);
}
void printfwd(list* head)
{
    list* dll=head;
    while (dll!=NULL)
    {
        printf(""%d  "",dll->key);
        dll=dll->next;
    }
}
void printrev(list* head)
{
    list* dll=head;
    while (dll->next!=NULL)
        dll=dll->next;
    while(dll!=NULL)
    {
        printf(""%d  "",dll->key);
        dll=dll->prev;
    }
}
int main()
{
    while (1)
    {
        int ch;
        printf(""\n1. SORTED ORDER INSERTION\n"");
        printf(""2. SEQUENTIAL ORDER INSERTION\n"");
        printf(""3. EXIT PROGRAM\n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&ch);
        if(ch==1)
        {
            list* head=NULL;
            int c;
            while(1)
            {
                int c;
                printf(""\n1. ENTER AN INTEGER\n"");
                printf(""2. DELETE AN INTEGER\n"");
                printf(""3. TRAVERSAL IN FORWARD DIRECTION\n"");
                printf(""4. TRAVERSAL IN REVERSE DIRECTION\n"");
                printf(""5. EXIT SORTED ORDER INSERTION\n"");
                printf(""Enter your choice: "");
                scanf(""%d"",&c);
                if(c==1)
                {
                    int n;
                    printf(""Please enter an element: "");
                    scanf(""%d"",&n);
                    sort_insertion(&head,n);
                    printf(""%d inserted using SORTED ORDER INSERTION.\n"",n);
                }
                else if(c==2)
                {
                    int n;
                    printf(""\nPlease enter the element to be deleted: "");
                    scanf(""%d"",&n);
                    if (head==NULL)
                        printf(""COULDN'T DELETE %d. LIST IS EMPTY\n"",n);
                    else
                    {
                        list* del_node=search_node(head,n);
                        if(del_node==NULL)
                        printf(""COULDN'T DELETE %d. NOT FOUND IN LIST.\n"",n);
                        else
                        {
                            deletion(&head,del_node);
                            printf(""%d deleted from LIST.\n"",n);
                        }
                    }
                }
                else if (c==3)
                {
                    if(head==NULL)
                        printf(""\n\tLIST IS EMPTY\n"");
                    else
                    {
                        printf(""\nTRAVERSAL IN FORWARD DIRECTION: \n"");
                        printfwd(head);
                        printf(""\n"");
                    }
                }
                else if (c==4)
                {
                    if(head==NULL)
                        printf(""\n\tLIST IS EMPTY\n"");
                    else
                    {
                        printf(""\nTRAVERSAL IN REVERSE DIRECTION: \n"");
                        printrev(head);
                        printf(""\n"");
                    }
                }
                else if (c==5)
                {
                    printf(""\nExitting Sorted Order Insertion, Thank You.\n"");
                    break;
                }
                else
                    printf(""\nINVALID CHOICE! TRY AGAIN.\n"");
            }
        }
        else if(ch==2)
        {
            list* head=NULL;
            int c;
            while(1)
            {
                printf(""\n1. ENTER AN INTEGER\n"");
                printf(""2. DELETE AN INTEGER\n"");
                printf(""3. TRAVERSAL IN FORWARD DIRECTION\n"");
                printf(""4. TRAVERSAL IN REVERSE DIRECTION\n"");
                printf(""5. EXIT SORTED ORDER INSERTION\n"");
                printf(""Enter your choice: "");
                scanf(""%d"",&c);
                if(c==1)
                {
                    int n;
                    printf(""Please enter an element: "");
                    scanf(""%d"",&n);
                    seq_insertion(&head,n);
                    printf(""%d inserted using SEQUENTIAL ORDER INSERTION.\n"",n);
                }
                else if(c==2)
                {
                    int n;
                    printf(""\nPlease enter the element to be deleted: "");
                    scanf(""%d"",&n);
                    if (head==NULL)
                        printf(""COULDN'T DELETE %d. LIST IS EMPTY\n"",n);
                    else
                    {
                        list* del_node=search_node(head,n);
                        if(del_node==NULL)
                        printf(""COULDN'T DELETE %d. NOT FOUND IN LIST.\n"",n);
                        else
                        {
                            deletion(&head,del_node);
                            printf(""%d deleted from LIST.\n"",n);
                        }
                    }
                }
                else if (c==3)
                {
                    if(head==NULL)
                        printf(""\n\tLIST IS EMPTY\n"");
                    else
                    {
                        printf(""\nTRAVERSAL IN FORWARD DIRECTION: \n"");
                        printfwd(head);
                        printf(""\n"");
                    }
                }
                else if (c==4)
                {
                    if(head==NULL)
                        printf(""\n\tLIST IS EMPTY\n"");
                    else
                    {
                        printf(""\nTRAVERSAL IN REVERSE DIRECTION: \n"");
                        printrev(head);
                        printf(""\n"");
                    }
                }
                else if(c==5)
                {
                    printf(""\nExitting Sorted Order Insertion, Thank You.\n"");
                    break;
                }
                else
                    printf(""\nINVALID CHOICE! TRY AGAIN.\n"");
            }
        }
        else if(ch==3)
        {
            printf(""\nExitting Program, Thank You.\n"");
            break;
        }
        else
            printf(""\nINVALID CHOICE! TRY AGAIN.\n"");
    }
    return 0;
}",11,441,2062
"int N;
void display(int arr[N][N]){
    static int n=1;
    printf(""\nSolution No. %d: \n"",n++);
    for (int i = 0; i < N; i++){
        if(i==0){
            for (int k = 0; k < N; k++)
                printf("" ---"");
            printf(""\n"");
        }
        printf(""|"");
        for (int j = 0; j < N; j++){
            if(arr[i][j])
                printf("" R |"");
            else
                printf(""   |"");
        }
        printf(""\n"");
        for (int k = 0; k < N; k++)
            printf("" ---"");
        printf(""\n"");
    }
}
int safe(int arr[N][N], int row, int col){
    for (int i = 0; i < row; i++)
        if(arr[row][i])
            return 0;
    for (int i = 0; i < col; i++)
        if(arr[row][i])
            return 0;
    return 1;
}
void rooks(int arr[N][N], int n){
    if(n>=N){
        display(arr);
        int trs[N][N], t=0;
        for (int i = 0; i < N; i++)
            for (int j = 0; j < N; j++)
                trs[j][i]=arr[i][j];
        for (int i = 0; i < N; i++)
            for (int j = 0; j < N; j++)
                if(trs[i][j]==arr[i][j])
                    t++;
        if(t!=(N*N))
            display(trs);
        return;
    }
    for (int i = 0; i < N; i++){
        if(safe(arr,i,n)){
            arr[i][n]=1;
            rooks(arr,n+1);
            arr[i][n]=0;
        }
    }
}
int main(){
    int n=1;
    while(n){
        printf(""Enter valid N i.e no of rows and columns: "");
        scanf(""%d"",&N);
        if(N>0)
            n=0;
    }
    int arr[N][N];
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            arr[i][j]=0;
    rooks(arr,0);
    return 0;
}",11,442,642
"typedef struct
{
    int top;
    unsigned int size;
    int* arr;
}stack;
stack* createstack(unsigned int x)
{
    stack* ret=(stack* ) malloc(sizeof(stack));
    ret->top=-1;
    ret->size=x;
    ret->arr=(int* )malloc(x * sizeof(int));
    return ret;
}
int is_full(stack* stk)
{
    if(stk->top==(stk->size-1))
        return 1;
    else
        return 0;
}
void push(stack* stk, int n)
{
    if(is_full(stk))
        printf(""OVERFLOW!\n"");
    else
    {
        stk->arr[++stk->top]=n;
        printf(""%d pushed to stack.\n"",stk->arr[stk->top]);
    }
}
int is_empty(stack* stk)
{
    if(stk->top==-1)
        return 1;
    else
        return 0;
}
void pop(stack* stk)
{
    if(is_empty(stk))
        printf(""STACK EMPTY!\n"");
    else
        printf(""%d popped from stack.\n"",stk->arr[stk->top--]);
}
int main()
{
    int ch,x;
    printf(""Enter size of the working Stack:\n"");
    scanf(""%d"",&x);
    stack* stk=createstack(x);
    while(1)
    {
        printf(""\n"");
        printf(""1. PUSH\n"");
        printf(""2. POP\n"");
        printf(""3. EXIT\n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&ch);
        if (ch==1)
        {
            int n;
            scanf(""%d"",&n);
            push(stk,n);
        }
        else if(ch==2)
            pop(stk);
        else if(ch==3)
        {
            printf(""Exitting program, Thank you.\n"");
            break;
        }
        else
            printf(""Invalid, choice try again.\n"");
    }
    return 0;
}",11,443,558
"#define MAX 50
typedef struct
{
    int top;
    unsigned int size;
    float* arr;
}stack;
stack* createStack(unsigned int x)
{
    stack* ret=(stack*) malloc(sizeof(stack));
    ret->top=-1;
    ret->size=x;
    ret->arr=(float*) malloc(x * sizeof(float));
    return ret;
}
float c2i(char x)
{
    return (int)x - (int)'0';
}
void push(stack* stk, float n)
{
    stk->arr[++(stk->top)]=n;
}
float pop(stack* stk)
{
    return stk->arr[stk->top--];
}
int isOperator(char ch)
{
    if (ch=='+' || ch=='-' || ch=='*' || ch=='/')
        return 1;
    else
        return 0;
}
float operation(float f, char x, float s)
{
    if (x=='+')
        return f+s;
    if (x=='-')
        return f-s;
    if (x=='*')
        return f*s;
    else
        return f/s;
}
float evaluatePostfix(char exp[])
{
    stack* stk=createStack(strlen(exp));
    int i=0;
    float f=0,s=0,t=0;
    while (exp[i]!='\0')
    {
        if((exp[i]==',' && exp[i+1]==',') || (exp[i]==' ' && exp[i+1]==' '))
            i++;
        else if((exp[i]==',' && exp[i+1]==' ') || (exp[i]==' ' && exp[i+1]==','))
        {
            printf(""Invalid operator or operand encountered.\n"");
            return 0;
        }
        else if((int)exp[i]>47 && (int)exp[i]<58)
            t=(t*10)+c2i(exp[i]);
        else if(exp[i]==',' || exp[i]==' ')
        {
            push(stk,t);
            t=0;
        }
        else if(isOperator(exp[i]))
        {
            if(stk->top-2<-1)
            {
                printf(""Underflow, not enough operands.\n"");
                return 0;
            }
            s=pop(stk);
            f=pop(stk);
            push(stk,operation(f,exp[i],s));
            if(i+1<stk->size)
                i++;
        }
        else
        {
            printf(""Invalid operator or operand encountered.\n"");
            return 0;
        }
        i++;
    }
    if(stk->top!=0)
    {
        printf(""Overflow, too may operands.\n"");
        return 0;
    }
    return stk->arr[stk->top];
}
int main()
{
    while(1)
    {
        char exp[MAX+1];
        printf(""\nTo exit enter a blank expression.\n"");
        printf(""Enter a postfix expression: "");
        gets(exp);
        if(strlen(exp)>50){
            printf(""Overflow, expression length greater than 50.\n"");
            break;
        }
        else if(strlen(exp)==0){
            printf(""No expression found.\n"");
            break;
        }
        else
        { 
            float ans=evaluatePostfix(exp);
            if(ans)
                printf(""Postfix Evaluation: %.2f\n"",ans);
        }
    }
    return 0;
}",11,444,938
"struct Node
{
    int data;
    struct Node *next;
    struct Node *prev;
};

typedef struct Node NODE;
typedef struct Node * PNODE;
typedef struct Node ** PPNODE;

void InsertLast(PPNODE Head, PPNODE Tail, int value)
{
    PNODE newn = NULL;
    
    newn = (PNODE)malloc(sizeof(NODE));
    
    newn->data = value;
    newn->next = NULL;
    newn->prev = NULL;
    
    if((*Head ==NULL) && (*Tail == NULL))       
    {
        *Head = newn;
        *Tail = newn;
    }
    else            
    {
        (*Tail)->next = newn;
        newn->prev = *Tail;
        *Tail = (*Tail) ->next;   
    }
    (*Tail)->next = *Head;
    (*Head)->prev = *Tail;
}

void InsertFirst(PPNODE Head, PPNODE Tail, int value)
{
    PNODE newn = NULL;
    
    newn = (PNODE)malloc(sizeof(NODE));
    
    newn->data = value;
    newn->next = NULL;
    newn->prev = NULL;
    
    if((*Head ==NULL) && (*Tail == NULL))       
    {
        *Head = newn;
        *Tail = newn;
    }
    else            
    {
        newn->next = *Head;
        (*Head)->prev = newn;
        *Head = (*Head)->prev;
    }
    (*Tail)->next = *Head;
    (*Head)->prev = *Tail;
}

void Display(PNODE Head, PNODE Tail)
{
        if((Head == NULL) && (Tail == NULL))
        {
            return;
        }
        do
        {
            printf(""|%d| <-> "",Head->data);
            Head = Head->next;
        }while(Head != Tail->next);
}

int Count(PNODE Head, PNODE Tail)
{
    int iCnt = 0;
    
        if((Head == NULL) && (Tail == NULL))
        {
            return 0;
        }
    
        do
        {
            iCnt++;
            Head = Head->next;
        }while(Head != Tail->next);

    return iCnt;
}

void DeleteFirst(PPNODE Head, PPNODE Tail)
{
    if(*Head == NULL && *Tail == NULL)  
    {
        return;
    }
    
    if(*Head == *Tail)  
    {
        free(*Head);
        *Head = NULL;
        *Tail = NULL;
    }
    else    
    {
        *Head = (*Head)->next;
        free((*Tail)->next);    
    
        (*Head)->prev = *Tail;
        (*Tail)->next = *Head;
    }
}

void DeleteLast(PPNODE Head, PPNODE Tail)
{
    if(*Head == NULL && *Tail == NULL)  
    {
        return;
    }
    
    if(*Head == *Tail)  
    {
        free(*Head);
        *Head = NULL;
        *Tail = NULL;
    }
    else    
    {
        *Tail  = (*Tail )->prev;
        free((*Tail)->next);      
        
        (*Head)->prev = *Tail;
        (*Tail)->next = *Head;
    }
}

void InsertAtPos(PPNODE Head, PPNODE Tail, int value, int pos)
{
    int count = 0, i= 0;
    PNODE temp = *Head;
    PNODE newn = NULL;
    
    count = Count(*Head, *Tail);
    
    if((pos < 1) || (pos > (count + 1)))
    {
        return;
    }
    if(pos == 1)
    {
        InsertFirst(Head, Tail, value);
    }
    else if(pos == count + 1)
    {
        InsertLast(Head,Tail,value);
    }
    else
    {
        newn= (PNODE)malloc(sizeof(NODE));
        
        newn->next = NULL;
        newn->prev = NULL;
        newn->data = value;
        
        for(i = 1; i< pos-1; i++)
        {
            temp = temp->next;
        }
        
        newn->next = temp->next;
        temp->next->prev = newn;
        
        temp->next = newn;
        newn->prev = temp;
    }
}

void DeleteAtPos(PPNODE Head,PPNODE Tail, int pos)
{
    int cnt = 0,i = 0;
    PNODE temp = *Head;
    
    cnt = Count(*Head, *Tail);
    
    if((pos < 1) || (pos > cnt))
    {
        return;
    }
    if(pos == 1)
    {
        DeleteFirst(Head, Tail);
    }
    else if(pos == cnt)
    {
        DeleteLast(Head, Tail);
    }
    else
    {
        for(i = 1; i<pos-1; i++)
        {
            temp =temp->next;
        }
        temp->next = temp->next->next;
        free(temp->next->prev);
        temp->next->prev = temp;
    }
}
int main()
{
    PNODE First = NULL;
    PNODE Last = NULL;          
    int no = 0, iRet = 0;
    
    printf(""Enter number : "");
    scanf(""%d"",&no);
    InsertFirst(&First,&Last,no);
    
    printf(""Enter number : "");
    scanf(""%d"",&no);
    InsertFirst(&First,&Last,no);
    
    printf(""Enter number : "");
    scanf(""%d"",&no);
    InsertFirst(&First,&Last,no);
    
    printf(""Enter number : "");
    scanf(""%d"",&no);
    InsertFirst(&First,&Last,no);
    
    printf(""Contents of linked lista are \n"");
    Display(First, Last);
    
    iRet = Count(First,Last);
    
    printf(""\nNumber of lements are %d\n"",iRet);
    
    DeleteLast(&First,&Last);
    DeleteFirst(&First,&Last);
    
    printf(""Contents of linked lista are \n"");
    Display(First, Last);
    
        return 0;
}
",12,445,1701
"typedef struct Employee
{
    int Eno;
    char EName[20];
    struct Employee *next;
}NODE, *PNODE,**PPNODE;

void InsertFirst(PPNODE Head)
{
    PNODE newn = (PNODE)malloc(sizeof(NODE));
    printf(""Enter employee ID\n"");
    scanf(""%d"",&(newn->Eno));
    
    printf(""Enter name\n"");
    scanf("" %[^'\n']s"",newn->EName);
    
    if(*Head == NULL)
    {
        *Head = newn;
    }
    else
    {
        newn->next = *Head;
        *Head = newn;
    }
}

void Display(PNODE Head)
{
    while(Head != NULL)
    {
        printf(""Emplyee number : %d\t Name : %s\n"",Head->Eno, Head->EName);
        Head = Head->next;
    }
}

int main()
{
    PNODE First = NULL;
    
    InsertFirst(&First);
        InsertFirst(&First);
        InsertFirst(&First);
    
    printf(""Information of Employess\n"");
    
    Display(First);
    
    return 0;
}
",12,446,320
"int FormIp(int no1,int no2,int no3,int no4)
{

    int ret=0;

    no1=no1 & 0x000000ff;

    no2=no2 & 0x000000ff;

    no3=no3 & 0x000000ff;

    no4=no4 & 0x000000ff;


    no1=no1<<24;

    no2=no2<<16;

    no3=no3<<8;

    ret= no1 | no2 | no3 |no4;


    return ret;
}

void split(int no)
{
    int a,b,c,d;

    a=no & 0xff000000;

    b=no & 0x00ff0000;

    c=no & 0x0000ff00;

    d=no & 0x000000ff;

    a = a>>24;

    b=b>>16;

    c=c>>8;

    
    
    printf(""\nfirt number is : %d\n"",a);
    
    printf(""second number is :%d\n"",b);

    printf(""third number is :%d\n"",c);

    printf(""fourt number is :%d\n"",d);



}
int main()
{
    int iRet=0;
    int a=0,b=0,c=0,d=0;
    printf(""enter ip addres\n"");
    printf(""first value :"");
    scanf(""%d"",&a);
    
    printf(""second value :"");
        scanf(""%d"",&b);

    printf(""third value :"");
        scanf(""%d"",&c);

    printf(""fourth value :"");
        scanf(""%d"",&d);


    iRet=FormIp(a,b,c,d);

    printf(""IP address  in one integer  is : %d"",iRet);

    split(iRet);

    return 0;
}
",12,447,550
"typedef int BOOL;

# define TRUE 1

#define FALSE 0

BOOL CheckBit(int iNo)
{
    int iMask = 0X00000E00;
    
    int iResult = 0;
    if(iNo < 0)
    {
        iNo = -iNo;
    }
    iResult = iNo & iMask;
    
    if(iResult == iMask)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
int main()
{
    int iNo = 0;
    BOOL bRet = FALSE;
    
    printf(""Enter number\n"");
    scanf(""%d"",&iNo);
        
    bRet = CheckBit(iNo);
    if(bRet == TRUE)
    {
        printf(""6th,7th and 12th bit is on\n"");
    }
    else
    {
        printf(""One of the bit or all bits are Off\n"");
    }
    return 0;
}




",12,448,267
"struct node
{
    int data;
    struct node *next;
};

typedef struct node NODE;
typedef struct node * PNODE;
typedef struct node ** PPNODE;

void InsertFirst(PPNODE Head, PPNODE Tail, int value)
{
    PNODE newn = NULL;
    newn = (PNODE)malloc(sizeof(NODE));
    newn->data = value;
    newn->next = NULL;

    if((*Head == NULL) && (*Tail == NULL))
    {
        *Head = newn;
        *Tail = newn;
    }
    else
    {
        newn->next = *Head;
        *Head = newn;
    }
    (*Tail)->next = *Head;
}

void InsertLast(PPNODE Head, PPNODE Tail, int value)
{
    PNODE newn = NULL;
    newn = (PNODE)malloc(sizeof(NODE));
    newn->data = value;
    newn->next = NULL;

    if((*Head == NULL) && (*Tail == NULL))
    {
        *Head = newn;
        *Tail = newn;
    }
    else
    {
        (*Tail)->next = newn;
        *Tail = newn;
    }
    (*Tail)->next = *Head;
}

void Display(PNODE Head, PNODE Tail)
{
    if((Head == NULL) && (Tail == NULL))
    {
        return;
    }

    do
    {
        printf(""|%d|<->"",Head->data);
        Head = Head->next;
    }while(Head!= Tail->next);
    printf(""\n"");
}

int Count(PNODE Head, PNODE Tail)
{
    int iCnt = 0;

    if((Head == NULL) && (Tail == NULL))
    {
        return 0;
    }

    do
    {
        iCnt++;
        Head = Head->next;
    }while(Head!= Tail->next);

    return iCnt;
}

void DeleteFirst(PPNODE Head, PPNODE Tail)
{
    if((*Head == NULL) && (*Tail == NULL))
    {
        return;
    }
    if(*Head == *Tail)
    {
        free(*Head);
        *Head = NULL;
        *Tail = NULL;
        return;
    }
    else
    {
        *Head = (*Head)->next;
        free((*Tail)->next);
        (*Tail)->next = *Head;
    }
}

void DeleteLast(PPNODE Head, PPNODE Tail)
{
    PNODE temp = *Head;

    if((*Head == NULL) && (*Tail == NULL))
    {
        return;
    }
    if(*Head == *Tail)
    {
        free(*Head);
        *Head = NULL;
        *Tail = NULL;
        return;
    }
    else
    {
        while(temp->next != *Tail)
        {
            temp = temp->next;
        }

        free(*Tail);
        *Tail = temp;
        (*Tail)->next = *Head;
    }
}

void InsertAtPos(PPNODE Head, PPNODE Tail, int value, int pos)
{
    int iCnt = 0, i = 0;
    PNODE temp = *Head;
    PNODE newn = NULL;

    iCnt = Count(*Head, *Tail);

    if((pos < 1) || (pos > iCnt+1))
    {
        return;
    }

    if(pos == 1)
    {
        InsertFirst(Head, Tail, value);
    }
    else if(pos == iCnt +1)
    {
        InsertLast(Head,Tail, value);
    }
    else
    {
        for(i = 1; i<pos-1;i++)
        {
            temp = temp->next;
        }
        newn = (PNODE)malloc(sizeof(NODE));
        newn->data = value;
        newn->next = NULL;

        newn->next = temp->next;
        temp->next = newn;
    }
}

void DeleteAtPos(PPNODE Head, PPNODE Tail,int pos)
{
    PNODE temp1 = *Head;
    PNODE temp2 = NULL;
    int iCnt = 0, i = 0;

    iCnt = Count(*Head,*Tail);

    if((pos < 1) || (pos > iCnt))
    {
        return;
    }
    if(pos == 1)
    {
        DeleteFirst(Head, Tail);
    }
    else if(pos == iCnt)
    {
        DeleteLast(Head, Tail);
    }
    else
    {
        for(i = 1; i< pos-1; i++)
        {
            temp1 = temp1->next;
        }

        temp2 = temp1->next;
        temp1->next = temp2->next;
        free(temp2);
    }
}

int main()
{
    PNODE First = NULL;
    PNODE Last = NULL;

    int choice = 1, no = 0, pos = 0;

    printf(""-----------------------------\n"");
    printf(""Singly Circular Linked List\n"");
    printf(""-----------------------------\n"");

    while(choice!= 0)   
    {
        printf(""-----------------------------\n"");
        printf(""Enter your choice : \n"");
        printf(""1: Inser first\n2: Insert Last\n3: Insert at position \n4: Delete first: \n5: Delete Last\n"");
        printf(""6: Delete at position \n7: Display \n8: Count: \n0: Exit\n"");
        scanf(""%d"", &choice);
        printf(""-----------------------------\n"");

        switch(choice)
        {
            case 1:
                printf(""Enter number : \n"");
                scanf(""%d"",&no);
                InsertFirst(&First, &Last,no);
                break;

            case 2:
                printf(""Enter number : \n"");
                scanf(""%d"",&no);
                InsertLast(&First, &Last,no);
                break;

            case 3 :
                printf(""Enter number : \n"");
                scanf(""%d"",&no);
                printf(""Enter position : \n"");
                scanf(""%d"",&pos);
                InsertAtPos(&First, &Last,no,pos);
                break;

            case 4:
                DeleteFirst(&First, &Last);
                break;

            case 5 :
                DeleteLast(&First,&Last);
                break;

            case 6:
                 printf(""Enter position : \n"");
                 scanf(""%d"",&pos);
                 DeleteAtPos(&First, &Last,pos);
                 break;

            case 7:
                Display(First, Last);
                break;

            case 8:
                printf(""Number of node are %d\n"", Count(First, Last));
                break;

            case 0:
                printf(""Thank you for using the application...\n"");
                break;

            default:
                printf(""Error : Wrong choice..\n"");
        }
    }

    return 0;
}

",12,449,1876
"void StrrevX(char str[])
{
    int iStart = 0, iEnd = 0;
    char temp = '\0';
    
    if(str == NULL)
    {
        return;
    }
    
    
    while(str[iEnd] != '\0')        
    {
        iEnd++;
    }
    iEnd --;
    
    while(iStart < iEnd)            
    {
        temp = str[iStart];
        str[iStart] = str[iEnd];
        str[iEnd] = temp;
        
        iStart++;
        iEnd--;
    }
}

int main()
{
    char arr[30];
    
    printf(""Please enter the string\n"");

    scanf(""%[^'\n']s"",arr);
        
    StrrevX(arr);
    
    printf(""Reverse string is %s\n"",arr);
    
    return 0;
}

",12,450,235
"typedef int BOOL;

# define TRUE 1

#define FALSE 0

BOOL CheckBit(int iNo)
{
    int iMask = 0X00000860;
    
    int iResult = 0;
    if(iNo < 0)
    {
        iNo = -iNo;
    }
    iResult = iNo & iMask;
    
    if(iResult == iMask)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
int main()
{
    int iNo = 0;
    BOOL bRet = FALSE;
    
    printf(""Enter number\n"");
    scanf(""%d"",&iNo);
        
    bRet = CheckBit(iNo);
    if(bRet == TRUE)
    {
        printf(""10th,11th and 12th bit is on\n"");
    }
    else
    {
        printf(""One of the bit or all bits are Off\n"");
    }
    return 0;
}




",12,451,269
"int SumI(int iNo)
{
    int iSum = 0;
   
    while(iNo != 0)
   
    {
   
            iSum = iSum + (iNo % 10);
       
        iNo = iNo / 10;
    }
    return iSum;
}

int SumR(int iNo)
{
    static int iSum = 0;
 
    if(iNo != 0)
 
    {
 
            iSum = iSum + (iNo % 10);
     
        iNo = iNo / 10;
        
        SumR(iNo);
    }
    return iSum;
}

int main()
{
    int no = 0, iRet = 0;

    printf(""Enter first number\n"");
 
    scanf(""%d"",&no);
 
    iRet = SumR(no);
 
    printf(""Result is %d"",iRet);
    
    return 0;
}
",12,452,252
"int FileSize(char *name)
{
    int fd = 0, ret = 0;

    fd = open(name,O_RDONLY);
    if(fd == -1)
    {
        printf(""Unable to open file\n"");
        return -1;
    }
    
    ret = lseek(fd,0,SEEK_END); 
    
    close(fd);

    return ret;
}

int main()
{
    char name[20];
    int ret = 0;
    
    printf(""Enter file name\n"");
    scanf(""%s"",name);
    
   ret = FileSize(name);
    
    printf(""File size is : %d\n"",ret);
    
    return 0;
}
",12,453,193
"int StrlenI(char *str)
{
    int i = 0;
    
    while(str[i] != '\0')
    {
        i++;
    }
    return i;
}

int StrlenR(char *str)
{
    static int i = 0;
    
    if(str[i] != '\0')
    {
        i++;
        StrlenR(str);
    }
    return i;
}

int main()
{
    int iRet = 0;
 
    char Arr[30] = {'\0'};
    
 
    printf(""Enter string\n"");
 
    scanf(""%[^'\n']s"",Arr);
    
    iRet = StrlenR(Arr);
 
    printf(""Length is %d\n\n"",iRet);
    
    return 0;
}
",12,454,213
"void FileRead(char *name, int position)
{
    int fd = 0, ret = 0;
    char Mug[10] = {'\0'};
    fd = open(name,O_RDONLY);
    if(fd == -1)
    {
        printf(""Unable to open file\n"");
        return;
    }
    
    ret = lseek(fd,position,SEEK_SET);
    printf(""Return value of lseek : %d\n"",ret);
    
    ret = read(fd,Mug,10);
    printf(""Data from the file is : \n"");
    
    printf(""Return value of read : %d\n"",ret);
    write(1,Mug,ret);
    
    printf(""\n"");
    close(fd);
}
int main()
{
    char name[20];
    int value = 0;
    
    printf(""Enter file name\n"");
    scanf(""%s"",name);
    
    printf(""Enter the position\n"");
    scanf(""%d"",&value);
    
    FileRead(name,value);
    
    return 0;
}
",12,455,287
"void DisplayWholeFile(char FName[])
{
    int fd = 0;
    char arr[100] = {'\0'};
    int ret = 0;
    
    
    fd = open(FName, O_RDONLY);
    if(fd == -1)
    {
        printf(""Unable to open file\n"");
        return;
    }
    printf(""Data from the file is : \n"");
    
    
    
    while((ret = read(fd,arr,100)) != 0)     
    {
        
        write(1,arr,ret);  
    }
    close(fd);
}

int main()
{
    char name[50] = {'\0'};
    
    printf(""Enter file name\n"");
    scanf(""%s"",name);
    
    DisplayWholeFile(name);
    return 0;
}
",12,456,225
"int Frequency(char str[], char ch)
{
    int iCnt = 0, i = 0;
    
    if(str == NULL)
    {
        return -1;
    }
    
    
    while(str[i] != '\0')
    {
        if(str[i] == ch)
        {
            iCnt++;
        }
        i++;
    }
    
    
    for(i = 0; str[i] != '\0'; i++)
    {
        if(str[i] == ch)
        {
            iCnt++;
        }
    }
    
    while(*str != '\0')
    {
        if(*str == ch)
        {
            iCnt++;
        }
        str++;
    }
    
    
    return iCnt;
}

int main()
{
    char arr[30];
    char cValue = '\0';
    
    int iRet = 0;
    
    printf(""Please enter the string\n"");
    scanf(""%[^'\n']s"",arr);
    
    
    
    printf(""Please enter the character to calculate the frequency\n"");
    scanf("" %c"",&cValue);       
    
    iRet = Frequency(arr,cValue);
    
    printf(""Total Frequency is %d\n"",iRet);
    
    return 0;
}






























",12,457,374
"void StrcatXX(char *Src, char *Dest)
{
    if(  (Src == NULL) ||  (Dest == NULL)   )
    {
        return;
    }
    
    
    
    while(*Dest != '\0')   
    {
        Dest++;                
    }
        
    *Dest = ' ';        
    
    Dest++;
   
    while(*Src != '\0')
   {
       *Dest = *Src;
       Src++;
       Dest++;
   }
    
    *Dest = '\0';
}

int main()
{
    char arr[30] = {'\0'};   

    char brr[30] = {'\0'};   
    
    printf(""Please enter first string\n"");

    scanf(""%[^'\n']s"",arr);
    
    printf(""Please enter second string\n"");
  
    scanf("" %[^'\n']s"",brr);
        
    StrcatXX(arr,brr);       
    
    printf(""String after concatination %s\n"",brr);
    
    return 0;
}


",12,458,279
"struct node
{
    int data;
    struct node *next;
};

typedef struct node NODE;
typedef struct node * PNODE;
typedef  struct node ** PPNODE;

void Push(PPNODE Head, int value)   
{
    PNODE newn = (PNODE) malloc(sizeof(NODE));
    newn->data = value;
    newn->next = NULL;
    if(*Head == NULL)
    {
        *Head = newn;
    }
    else
    {
        newn->next = *Head;
        *Head = newn;
    }
}
int Pop(PPNODE Head)        
{
    int no = 0;
    PNODE temp = *Head;
    
    if(*Head == NULL)
    {
        printf(""Stack is empty\n"");
        return -1;
    }
    else
    {
        no = (*Head)->data;         
        *Head = (*Head)->next;
        free(temp);
        return no;
    }
}

int Peep(PNODE Head)    
{
    int no = 0;
    
    if(Head == NULL)
    {
        printf(""Stack is empty\n"");
        return -1;
    }
    else
    {
        no = Head->data;
        return no;
    }
}

void Display(PNODE Head)    
{
    while(Head != NULL)
    {
        printf(""|%d|->"",Head->data);
        Head = Head->next;
    }
    printf(""\n"");
}

int Count(PNODE Head)       
{
    int iCnt = 0;
    
    while(Head != NULL)
    {
        iCnt++;
        Head = Head->next;
    }
    return iCnt;
}

int main()
{
    PNODE First = NULL;
    int choice = 1, no = 0;
    
    printf(""Dynamic implementation of stack\n"");
    
    while(choice != 0)
    {
        printf(""\n 1: Push the element"");
        printf(""\n 2: Pop the elemet"");
        printf(""\n 3: Display the elemets of stack"");
        printf(""\n 4: Count the number of elements of stack"");
        printf(""\n 5: Peep the element"");
        printf(""\n 0: Exit the application\n"");
        
        printf(""Please enter your choice : \n"");
        scanf(""%d"",&choice);
        
        switch (choice)
        {
            case 1:
                printf(""Enter the element that you want to insert\n"");
                scanf(""%d"",&no);
                Push(&First, no);
                break;
                
            case 2 :
                no = Pop(&First);
                printf(""Poped element is : %d\n"",no);
                break;
              
            case 3 :
                Display(First);
                break;
                
            case 4:
                printf(""Number of elements are : %d\n"",Count(First));
                break;
                
            case 5:
                printf(""Peeped element is : %d\n"",Peep(First));
                break;
                
            case 0:
                printf(""Thank you for using the application\n"");
                break;
                
            default:
                printf(""Wrong choice\n"");
        } 
    }
    
    return 0;
}








",12,459,861
"int main()
{
    char name[20] = {'\0'};
    char arr[50] = {'\0'};
    int fd = 0;     
    int ret = 0, length = 0;
    char temp;
    
    printf(""Enter file name\n"");
    scanf(""%s"",name);
    
    fd = open(name,O_RDWR); 
    if(fd == -1)
    {
        printf(""Unable to open file\n"");
    }
    else
    {
        printf(""File succesfully opened with fd %d\n"",fd);
    }
    
    ret = read(fd,arr,10);
    if(ret == -1)
    {
        printf(""Unable to read from the file\n"");
    }
    else
    {
        printf(""Data succesfully read\n"");
    }
    printf(""Data from file is : %s\n"",arr);
    
    close(fd);
    return 0;
}


",12,460,255
"void DisplayS()     
{
    printf(""Hello\n"");
    printf(""Hello\n"");
    printf(""Hello\n"");
    printf(""Hello\n"");
}

void DisplayI()                
{
    int i = 0;
    
    for(i = 1; i<=4;i++)
    {
        printf(""Hello\n"");      
    }
}

void DisplayR()
{
    static int i = 1;
    
    if(i<=4)
    {
        printf(""Hello\n"");
        i++;
        DisplayR();
    }
}

int main()
{
    int value = 10;
    
    DisplayR();
    
    printf(""End of main"");
    return 0;
}
",12,461,186
"void DisplayBinary(int iValue)
{
    int iRem = 0;
 
    if(iValue < 0)
    {
        iValue = -iValue;
    }
    
    while(iValue != 0)
    {
        iRem = iValue % 2;
 
    iValue = iValue / 2;
 
    printf(""%d"",iRem);
    }
}
int main()
{
    int iNo = 0;
    
    printf(""Enter number\n"");
 
    scanf(""%d"",&iNo);
        
    DisplayBinary(iNo);
    
    return 0;
}

",12,462,162
"int SearchFirstOcc(char str[], char ch)
{
    int i = 0;
    
    if((str == NULL) || (ch == '\0'))
    {
        return -1;
    }
    
    while(str[i] != '\0')
    {
            if(str[i] == ch)
            {
                break;
            }
        i++;
    }
    
    if(str[i] == ch)        
    {
        return i;
    }
    else                        
    {
        return -1;
    }

}





int main()
{
    char arr[30];

    char cValue = '\0';
    
    int iRet = 0;
    
    printf(""Please enter the string\n"");

    scanf(""%[^'\n']s"",arr);
        
    printf(""Please enter the character\n"");

    scanf("" %c"",&cValue);
    
    iRet = SearchFirstOcc(arr,cValue);
    
    if(iRet == -1)
    {
        printf(""There is no such character\n"");
    }
    else
    {
        printf(""First occurance of character at : %d\n"",iRet);
    }
    
    return 0;
}



",12,463,322
"int SearchLastOcc(char str[], char ch)
{
    int i = 0;
    int iPos = -1;

    if((str == NULL) || (ch == '\0'))
    {
        return -1;
    }
    
    while(str[i] != '\0')
    {
        if(str[i] == ch)
        {
            iPos = i;
        }
        i++;
    }
    
    return iPos;
}

int main()
{
    char arr[30];

    char cValue = '\0';
    
    int iRet = 0;
    
    printf(""Please enter the string\n"");

    scanf(""%[^'\n']s"",arr);
        
    printf(""Please enter the character\n"");

    scanf("" %c"",&cValue);
    
    iRet = SearchLastOcc(arr,cValue);
    
    if(iRet == -1)
    {
        printf(""There is no such character\n"");
    }
    else
    {
        printf(""Last occurance of character at : %d\n"",iRet);
    }
    
    return 0;
}


",12,464,293
"int CountOne(int iValue)
{
    int iRem = 0;

    int iCnt = 0;

    if(iValue < 0)
    {
        iValue = -iValue;
    }
    
    while(iValue != 0)
    {
        iRem = iValue % 2;

    if(iRem == 1)
        {
            iCnt++;
        }
        iValue = iValue / 2;
    }
    return iCnt;
}
int main()
{
    int iNo = 0;

    int iRet = 0;
    
    printf(""Enter number\n"");

    scanf(""%d"",&iNo);
        
    iRet = CountOne(iNo);
    
    printf(""Number of 1's in the numer is : %d\n"",iRet);
    
    return 0;
}

",12,465,226
"void FileCopyAppend(char *src,char *dest)
{
    int fdscr = 0, fddest = 0, ret = 0, i = 1;
    char Mug[100] = {'\0'};
    
    fdscr = open(src,O_RDONLY);
    if(fdscr == -1)
    {
        printf(""Unable to open source file\n"");
        return;
    }
    fddest = open(dest, O_WRONLY | O_APPEND);
    if(fddest == -1)
    {
        printf(""Unable to open destination file\n"");
        close(fdscr);
        return;
    }
    
    while((ret = read(fdscr,Mug,sizeof(Mug))) != 0)
    {
        printf(""Iteration : %d Size Read : %d\n"", i, ret);
        i++;
        write(fddest, Mug,ret);
    }
    
    close(fdscr);
    close(fddest);
}

int main()
{
    char name1[20];
    char name2[20];
    
    printf(""Enter source file name\n"");
    scanf(""%s"",name1);
    
    printf(""Enter destination file name\n"");
    scanf(""%s"",name2);
    
    FileCopyAppend(name1,name2);
    
    return 0;
}
",12,466,356
"void DisplayI(int no)
{
    while(no > 0)
    {
        printf(""%d\n"",no);
        no--;
    }
}

void DisplayR(int no)
{
        if(no > 0)
        {
            printf(""%d\t"",no);
            no--;
            DisplayR(no);
        }
}

int main()
{
    int value = 0;
    printf(""Enter number\n"");
    scanf(""%d"",&value);     
    
    DisplayR(value);
    
    printf(""End of main"");
    return 0;
}

",12,467,155
"void StrcpyX(char Src[], char Dest[])
{
    int i = 0;
    
    if( (Src == NULL) ||(Dest == NULL))
    {
        return;
    }
    while(Src[i] != '\0')
    {
        Dest[i] = Src[i];
        i++;
    }
    Dest[i] = '\0';
}

int main()
{
    char arr[30] = {'\0'};   
    char brr[30] = {'\0'};   
    
    printf(""Please enter the string\n"");

    scanf(""%[^'\n']s"",arr);
        
    StrcpyX(arr,brr);
    
    printf(""String after copy : %s\n"",brr);
    
    return 0;
}

",12,468,206
"int DigitCount(char *str)
{
    int iCnt = 0;
    
    if(str == NULL)
    {
        return -1;
    }
    
    while(*str != '\0')
    {
        if((*str >= '0') && (*str <= '9'))
        {
            iCnt++;
        }
        str++;
    }
        
    return iCnt;
}

int main()
{
    char arr[30] = {'\0'};
    
    int iRet = 0;
    
    printf(""Please enter string\n"");
    
    scanf(""%[^'\n']s"",arr);
    
    iRet = DigitCount(arr);
    
    printf(""Number of digits are %d\n"",iRet);
    
    return 0;
}


",12,469,207
"int StrlenCap(char str[])
{
    int iCnt = 0, i = 0;
    
    if(str == NULL)
    {
        return -1;
    }
    
    while(str[i] != '\0')
    {
        if((str[i] >= 'A') && (str[i] <= 'Z'))
        {
            iCnt++;
        }
        
        i++;
    }
    
    return iCnt;
}

int main()
{
    char arr[30];
    
    int iRet = 0;
    
    printf(""Please enter the string\n"");
    
    scanf(""%[^'\n']s"",arr);
    
    iRet = StrlenCap(arr);
    
    printf(""Total number of capital characters are %d\n"",iRet);
    
    return 0;
}
",12,470,216
"int main()
{
    char name[20] = {'\0'};
    char arr[50] = {'\0'};
    int fd = 0;     
    int ret = 0, length = 0;
    char temp;
    
    printf(""Enter file name\n"");
    scanf(""%s"",name);
    
    fd = open(name,O_RDWR | O_CREAT, 0777); 
    if(fd == -1)
    {
        printf(""Unable to create file\n"");
    }
    else
    {
        printf(""File succesfully created with fd %d\n"",fd);
    }
    printf(""Enter the data that you want to write in the file\n"");
    scanf("" %[^'\n']s"",arr);
    length = strlen(arr);
    
    ret = write(fd,arr,length);
    if(ret == -1)
    {
        printf(""Unable to write in the file\n"");
    }
    else
    {
        printf(""Data succesfully written in the file %d\n"",ret);
    }
    
    close(fd);
    return 0;
}

",12,471,296
"int PowerI(int X, int Y)
{
    int Result = 1;
    while(Y != 0)
    {
        Result = Result * X;
        Y--;
    }
    return Result;
}

int PowerR(int X, int Y)
{
    static int Result = 1;
    if(Y != 0)
    {
        Result = Result * X;
        Y--;
        PowerR(X,Y);
    }
    return Result;
}

int main()
{
    int no1 = 0, no2 = 0, iRet = 0;

    printf(""Enter first number\n"");
    scanf(""%d"",&no1);
    
    printf(""Enter second number\n"");
    scanf(""%d"",&no2);
    
    iRet = PowerR(no1,no2);
    
    printf(""Result is %d"",iRet);
    
    return 0;
}
",12,472,236
"void FileCopy(char *src,char *dest)
{
    int fdscr = 0, fddest = 0, ret = 0, i = 1;
    char Mug[100] = {'\0'};
    
    fdscr = open(src,O_RDONLY);
    if(fdscr == -1)
    {
        printf(""Unable to open source file\n"");
        return;
    }
    fddest = open(dest, O_RDWR | O_CREAT, 0777);
    if(fddest == -1)
    {
        printf(""Unable to open destination file\n"");
        close(fdscr);
        return;
    }
    
    while((ret = read(fdscr,Mug,sizeof(Mug))) != 0)
    {
        printf(""Iteration : %d Size Read : %d\n"", i, ret);
        i++;
        write(fddest, Mug,ret);
    }
    
    close(fdscr);
    close(fddest);
}

int main()
{
    char name1[20];
    char name2[20];
    
    printf(""Enter source file name\n"");
    scanf(""%s"",name1);
    
    printf(""Enter destination file name\n"");
    scanf(""%s"",name2);
    
    FileCopy(name1,name2);
    
    return 0;
}
",12,473,360
"int ToggleBit(int iNo, int iPos)
{
    int iMask = 0x00000001;
    
    int iResult = 0;
    if(iNo < 0)
    {
        iNo = -iNo;
    }
    
    if((iPos < 1) || (iPos > 32))
    {
        return 0;
    }
    
    iMask = iMask << (iPos -1);
    
    iResult = iNo ^ iMask;
    
    return iResult;
}

int main()
{
    int iNo = 0, iPos = 0, iRet = 0;
    
    printf(""Enter number\n"");
    scanf(""%d"",&iNo);
    
    printf(""Enter the position\n"");
    scanf(""%d"",&iPos);
        
    iRet = ToggleBit(iNo,iPos);
    
    printf(""Modified number after bit toggle is : %d\n"",iRet);

    return 0;
}




",12,474,267
"#include ""monty.h""


unsigned int print_dlistint(const stack_t *h)
{
    unsigned int n = 0;

    while (h)
    {
        printf(""%i\n"", h->n);
        n++;
        h = h->next;
    }
    return (n);
}


unsigned int _strlen(char *s)
{
    unsigned int n, len;

    n = len = 0;
    while (*(s + n) != '\0')
    {
        n++;
        len++;
    }
    return (len);
}


unsigned int dlistint_len(const stack_t *h)
{
    unsigned int n = 0;

    if (h == NULL)
    {
        return (0);
    }
    while (h != NULL)
    {
        n++;
        h = h->next;
    }
    return (n);
}


void free_dlistint(stack_t *head)
{
    stack_t *aux;

    while (head != NULL)
    {
        aux = head;
        head = head->next;
        free(aux);
    }
}
",13,475,298
"#include ""sort.h""


void merge_sort(int *array, size_t size)
{
    int n = (int)size;
    int *brray;

    if (size < 2)
        return;
    brray = malloc(sizeof(int) * size);
    CopyArray(array, 0, n, brray);
    TopDownSplitMerge(brray, 0, n, array);
    free(brray);
}


void TopDownSplitMerge(int B[], int iBegin, int iEnd, int A[])
{
    int iMiddle, index;

    if (iEnd - iBegin <= 1)
        return;
    iMiddle = (iEnd + iBegin) / 2;

    TopDownSplitMerge(A, iBegin,  iMiddle, B);
    TopDownSplitMerge(A, iMiddle, iEnd, B);

    printf(""Merging...\n"");
    TopDownMerge(B, iBegin, iMiddle, iEnd, A);
    printf(""[Done]: "");
    for (index = iBegin; index < iEnd; index++)
    {
        printf(""%d"", A[index]);
        if (index != iEnd - 1)
            printf("", "");
    }
    printf(""\n"");
}



void TopDownMerge(int A[], int iBegin, int iMiddle, int iEnd, int B[])
{
    int i = iBegin, j = iMiddle, k, index;

    for (k = iBegin; k < iEnd; k++)
    {
        if (i < iMiddle && (j >= iEnd || A[i] <= A[j]))
        {
            B[k] = A[i];
            i = i + 1;
        }
        else
        {
            B[k] = A[j];
            j = j + 1;
        }
    }
    printf(""[left]: "");
    for (index = iBegin; index < iMiddle; index++)
    {
        printf(""%d"", A[index]);
        if (index != iMiddle - 1)
            printf("", "");
    }
    printf(""\n"");
    printf(""[right]: "");
    for (index = iMiddle; index < iEnd; index++)
    {
        printf(""%d"", A[index]);
        if (index != iEnd - 1)
            printf("", "");
    }
    printf(""\n"");
}


void CopyArray(int A[], int iBegin, int iEnd, int B[])
{
    int k;

    for (k = iBegin; k < iEnd; k++)
        B[k] = A[k];
}
",13,476,654
"#include ""sort.h""


void counting_sort(int *array, size_t size)
{
    int i, j, max = 0;
    int *new_arr, *new_new;

    if (size < 2)
        return;

    for (i = 0; i <= (int)size; i++)
    {
        if (array[i] > max)
            max = array[i];
    }
    max += 1;
    new_arr = (int *) malloc(sizeof(int) * max);
    for (i = 0; i <= max; i++)
        new_arr[i] = 0;

    for (i = 0; i < (int)size; i++)
        new_arr[array[i]] += 1;

    for (i = 0; i < max; i++)
    {
        j = i + 1;
        new_arr[j] += new_arr[i];
    }
    print_array(new_arr, max);

    new_new = malloc(sizeof(int) * size);

    for (i = 0; i < (int)size; i++)
    {
        new_arr[array[i]] -= 1;
        new_new[new_arr[array[i]]] = array[i];
    }
    for (i = 0; i < (int)size; i++)
        array[i] = new_new[i];

    free(new_new);
    free(new_arr);
}
",13,477,378
"#include ""sort.h""


void selection_sort(int *array, size_t size)
{
    size_t i, j;
    int lower = 0, position = 0, first = 0;

    if (size < 2)
        return;
    for (i = 0; i < size; i++)
    {
        first = array[i];
        lower = first;
        for (j = i; j < size; j++)
        {
            if (lower > array[j])
            {
                lower = array[j];
                position = j;
            }
        }
        if (lower < first)
        {
            array[i] = lower;
            array[position] = first;
            print_array(array, size);
        }
    }
}
",13,478,197
"#include ""monty.h""




void push_func(stack_t **stack, unsigned int line_number)
{
    int n;
    stack_t *new = malloc(sizeof(stack_t));
    (void)line_number;

    if (!new)
    {
        free(new);
        return;
    }
    n = atoi(code[1]);
    new->n = n;
    new->prev = NULL;
    if (!*stack)
    {
        new->next = NULL;
        *stack = new;
    }
    else
    {
        new->next = *stack;
        (*stack)->prev = new;
        *stack = new;
    }
}
",13,479,177
"#include ""monty.h""

int get_bytecode(char *filename)
{
    FILE *fp;
    char *line = NULL;
    unsigned int line_number = 0;
    size_t len = 0;
    ssize_t read;
    stack_t *stack = NULL;

    fp = fopen(filename, ""r"");
    if (fp == NULL)
    {
        printf(""Error: Can't open file %s\n"", filename);
        exit(EXIT_FAILURE);
    }
    while ((read = getline(&line, &len, fp)) != -1)
    {
        line_number++;
        split_buffer(line);
        if (code[0] == NULL)
            continue;
        if (strcmp(code[0], ""push"") == 0 && check_number(code[1]) == 1)
        {
            printf(""L%d: usage: push integer\n"", (line_number));
            free(line);
            free_dlistint(stack);
            fclose(fp);
            exit(EXIT_FAILURE);
        }
        if (analize(&stack, line_number) == 0)
        {
            printf(""L%d: unknown instruction %s\n"", line_number, code[0]);
            free_dlistint(stack);
            free(line);
            fclose(fp);
            exit(EXIT_FAILURE);
        }
    }
    free(line);
    free_dlistint(stack);
    fclose(fp);
    return (0);
}
",13,480,390
"#include ""sort.h""



void shell_sort(int *array, size_t size)
{
    size_t n = 0, i, j;
    int temp = 0;

    if (size < 2)
        return;

    while (n <= size)
        n = (n * 3) + 1;

    while (n > 1)
    {
        n = (n - 1) / 3;
        for (i = 0; i < size - n; i++)
        {
            for (j = i + n; j > 0 && j >= n; j -= n)
            {
                if (array[j] < array[j - n])
                {
                    temp = array[j - n];
                    array[j - n] = array[j];
                    array[j] = temp;
                }
            }
        }
        print_array(array, size);
    }
}
",13,481,237
"#include ""sort.h""


void radix_sort(int *array, size_t size)
{
    int digits = 0, i, j, max_num = 0, start = 0, len, at_index = 0, div = 10, temp, a;
    int *arr_aux;
    int *arr_aux2;

    len = (int)size;
    arr_aux = malloc(sizeof(int) * size);
    arr_aux2 = malloc(sizeof(int) * size);
    arr_cpy(array, arr_aux2, len);
    for(i = 0; i < len; i++)
    {
        if(array[i] > max_num)
            max_num = array[i];
    }
    while(max_num > 0)
    {
        max_num = max_num / 10;
        digits++;
    }

    while(digits >= 0)
    {
        for(a = 0; a < len; a++)
        {
            if(arr_aux2[a] != 0)
                arr_aux[a] = arr_aux2[a] % 10;
            else
                arr_aux[a] = arr_aux2[a];
        }
        print_array(arr_aux, size);
        for(start = 0; start < len; start++)
        {
            at_index = get_index_lower(arr_aux, start, len);
            printf(""index: %d\n"", at_index);
            temp = array[start];
            array[start] = array[at_index];
            array[at_index] = temp;
        }
        print_array(arr_aux2, size);
        for(j = 1; j < len; j++)
        {
            arr_aux2[i] = arr_aux2[i] / div; 
        }
        div = div * 10;
        
        digits--;
    }
}



void arr_cpy(int *array1, int *array2, int size)
{
    int i;

    for(i = 0; i < size; i++)
    {
        array2[i] = array1[i];
    }
}

int get_index_lower(int *array, int start, int size)
{
    int min = 0, index = 0, i = start;

    for(i = 0; i < size; i++)
    {
        if (array[i] < min)
            min = array[i];
            index = i;
    }
    return(index);
}",13,482,648
"#include ""sort.h""


void insertion_sort_list(listint_t **list)
{
    listint_t *temp_n, *temp_sort, *swapper;

    if (!list || *list == NULL)
        return;

    if ((*list)->next == NULL)
        return;

    temp_n = *list;

    while (temp_n != NULL)
    {
        temp_sort = temp_n;
        if (temp_sort->prev != NULL)
        {
            while (temp_sort->n < (temp_sort->prev)->n && temp_sort->prev != NULL)
            {
                swapper = temp_sort->prev;
                if (swapper->prev == NULL)
                {
                    swap(temp_sort, swapper, list);
                    print_list(*list);
                    break;
                }
                swap(temp_sort, swapper, list);
                print_list(*list);
            }
        }
        temp_n = temp_n->next;
    }
}


listint_t **swap(listint_t *temp_sort, listint_t *swapper, listint_t **list)
{
    listint_t *aux_prev, *aux_next = temp_sort->next;

    swapper = temp_sort->prev;
    if (temp_sort->next == NULL && swapper->prev == NULL)
    {
        temp_sort->next = temp_sort->prev;
        temp_sort->prev = NULL;
        swapper->prev = swapper->next;
        swapper->next = NULL;
        *list = temp_sort;
    }
    else if (swapper->prev == NULL)
    {
        temp_sort->prev = NULL;
        temp_sort->next = swapper;
        swapper->prev = temp_sort;
        swapper->next = aux_next;
        aux_next->prev = swapper;
        *list = temp_sort;
    }
    else if (temp_sort->next == NULL)
    {
        aux_prev = swapper->prev;
        aux_prev->next = temp_sort;
        temp_sort->prev = aux_prev;
        temp_sort->next = swapper;
        swapper->prev = temp_sort;
        swapper->next = NULL;
    }
    else
    {
        aux_prev = swapper->prev;
        aux_prev->next = temp_sort;
        temp_sort->prev = aux_prev;
        temp_sort->next = swapper;
        swapper->next = aux_next;
        swapper->prev = temp_sort;
        aux_next->prev = swapper;
    }
    return (list);
}
",13,483,670
"#include ""monty.h""


int analize(stack_t **stack, unsigned int line_number)
{
    int type_i;
    instruction_t type[] = {
                {""push"", push_func},
                {""pall"", pall_func},
                {""pint"", pint_func},
                {""pop"", pop_func},
                {""swap"", swap_func},
                {""add"", add_func},
                {""nop"", nop_func},
                {""sub"", sub_func},
                {""div"", div_func},
                {""mul"", mul_func},
                {""mod"", mod_func},
                {NULL, NULL}
    };

    for (type_i = 0; type[type_i].opcode != NULL; type_i++)
    {
        if (strcmp(code[0], type[type_i].opcode) == 0)
        {
            type[type_i].f(stack, line_number);
            break;
        }
    }
    if (type[type_i].opcode == NULL)
    {
        return (0);
    }
    return (1);
}
",13,484,278
"#define MAXLON 1000


pthread_t thread1, thmain;
pthread_attr_t attr;

void *cuenta (void *);

void *cuenta (void *arg){
    int pos, cont = 0, leidos;
    char cadena[MAXLON];
    int fd;

    fd = open((char) arg, O_RDONLY);
    while ((leidos = read(fd, cadena, MAXLON)) != 0)
    {
        for(pos = 0; pos < leidos; pos++){
            if((cadena[pos] == 'a') || (cadena[pos] == 'A')) cont++;
        }
    }
    printf(""Fichero %s: %d caracteres 'a' o 'A' encontrados \n"", (char) arg, cont);
    close(fd);
    pthread_exit(NULL);
}

int main(int argc, char *argv[]){
    thmain = pthread_self();
    
    pthread_attr_init(&attr);

    printf(""Soy la funcion main y voy a lanzar un thread \n"");

    pthread_create(&thread1, &attr, cuenta,""ejemplo.txt"");

    sleep(2);
    printf(""Fichero ejemplo.txt: 30 caracteres 'a' o 'A' encontrados\n"");

    printf(""Soy main: he lanzado un thread y termino\n"");

    pthread_exit(NULL);

}",14,485,372
"int buffer[10]={0,0,0,0,0,0,0,0,0,0};
sem_t semaforo;

void *fhilo1(void *arg){
    int i;

    printf(""\nEstoy llenando el buffer \n"");

    for(i = 0; i < 10; i++){
        sem_trywait(&semaforo);
        
        buffer[i] = i+1;
        sem_post(&semaforo);
    }

    sleep(random()%3);
    pthread_exit(NULL);
}
void *fhilo2(void *arg){
    int i;

    printf(""\nLos valores del buffer son: \n"");

    for(i = 0; i < 10; i++){
        sem_trywait(&semaforo); 
        printf(""%d, "",buffer[i]);
        buffer[i] = 0;
        sem_post(&semaforo);
    }

    sleep(random()%3);
    printf(""\n"");

    for(i = 0; i < 10; i++){
        printf(""%d, "",buffer[i]);
    }
    pthread_exit(NULL);
}

int main(int argc, char const *argv[])
{
    pthread_t hilo1,hilo2;
    time_t t;
    srandom(time(&t));

    sem_init(&semaforo,0,10);

    while(1){
        pthread_create(&hilo1,NULL, *fhilo1,NULL);
        pthread_create(&hilo2,NULL, *fhilo2,NULL);

        if(buffer[0] == 0) pthread_join(hilo1,NULL);
        else pthread_join(hilo2,NULL);
    }
    

    sem_destroy(&semaforo);

    return 0;
}
",14,486,484
"#include ""mpi.h""

int main(int argc, char **argv){
  MPI_Init(NULL, NULL);
 double A[10000];
 double B[10000];
 int world_rank;
  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);
  int world_size;
  MPI_Comm_size(MPI_COMM_WORLD, &world_size);

  if (world_size < 2) {
    fprintf(stderr, ""World size must be greater than 1 for %s\n"", argv[0]);
    MPI_Abort(MPI_COMM_WORLD, 1);
  }


  if (world_rank != 0) {

    int i = 0;

    for(i; i < 10000; i++){
        A[i]=world_rank;
    }
    MPI_Recv(&B, 10000, MPI_INT, world_rank - 1, 0, MPI_COMM_WORLD,
             MPI_STATUS_IGNORE);
    printf(""Process %d received B[109] %d from process %d\n"", world_rank, B[109],
           world_rank - 1);
  } else {
    int i = 0;
    for(i; i < 10000; i++){
        A[i]=world_rank;
    }
  }

  MPI_Send(&A, 10000, MPI_INT, (world_rank + 1) % world_size, 0,
           MPI_COMM_WORLD);
  
  
  
  if (world_rank == 0) {
    MPI_Recv(&B, 10000, MPI_INT, world_size - 1, 0, MPI_COMM_WORLD,
             MPI_STATUS_IGNORE);
    printf(""Process %d received B[109] %d from process %i\n"", world_rank, B[109],
           1);
  }
  MPI_Finalize();



}",14,487,541
"pthread_mutex_t count_mutex;
pthread_cond_t count_threshold_cv;
int buffer[10]={0,0,0,0,0,0,0,0,0,0};
void *productor(void *arg){
    int i = 0;
    printf(""Lleno el buffer para mi consumidor\n"");
    pthread_mutex_lock(&count_mutex); 
    for(i; i < 10;i++ ){
        buffer[i]=i+1;
    }
    printf(""He terminado y permito a mi consumidor leer el buffer\n"");
    pthread_cond_signal(&count_threshold_cv);
    pthread_mutex_unlock(&count_mutex);
    sleep(1);
    pthread_exit(NULL);
}

void *consumidor(void *arg){
int i = 0;
    printf(""Voy a esperar a que se llenen los datos\n"");
    pthread_mutex_lock(&count_mutex);
    pthread_cond_wait(&count_threshold_cv, &count_mutex); 
    printf(""Voy a leer los datos y limpiar el buffer\n"");
    for(i; i < 10;i++ ){
 
        printf(""%d, "",buffer[i]);
        buffer[i]=0;
        pthread_mutex_unlock(&count_mutex);
    }
    printf(""\n"");
    sleep(2);
    pthread_exit(NULL);
}


int main(int argc, char const *argv[])
{
    pthread_t hilo1,hilo2;
    pthread_attr_t attr;

    pthread_mutex_init(&count_mutex, NULL);   
    pthread_cond_init (&count_threshold_cv, NULL);

    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
    while(1){
        pthread_create(&hilo1,&attr, *productor,NULL);
        pthread_create(&hilo2,&attr, *consumidor,NULL);
        pthread_join(hilo1,NULL);
        pthread_join(hilo2,NULL);

    }
    pthread_attr_destroy(&attr);   
    pthread_mutex_destroy(&count_mutex);   
    pthread_cond_destroy(&count_threshold_cv);   
    pthread_exit (NULL);
    return 0;
}
",14,488,630
"#include ""mpi.h""
int main(int argc, char **argv){

 int rank, count;
 char msg[20];
 MPI_Status status;   
 MPI_Init( &argc , &argv);
 MPI_Comm_rank( MPI_COMM_WORLD ,&rank);
 int i= 0;
 while(i<10){
     if(rank==0){
     strcpy(msg,""Hello World"");
     MPI_Send( msg , 13 , MPI_CHAR , 1 , 100 , MPI_COMM_WORLD);

    MPI_Recv( msg , 13 , MPI_CHAR , 1 , 100 , MPI_COMM_WORLD , &status);
            printf(""Master: El mensaje es: %s\n"",msg);


     
    }else
    {
        MPI_Recv( msg , 13 , MPI_CHAR , 0 , 100 , MPI_COMM_WORLD , &status);
        printf(""Secundario: El mensaje es: %s\n"",msg);
        strcpy(msg,""Bye World"");
        MPI_Send( msg , 13 , MPI_CHAR , 0 , 100 , MPI_COMM_WORLD);
    }
    i++;
 }
    

    MPI_Finalize();


}",14,489,341
"void *func1 (void*);
void *func2 (void*);

pthread_t thread1, thread2, thmain;
pthread_attr_t attr;
pthread_mutex_t mutex;

int num1;
int num2;


void *func1 (void *arg){
    
    int suma = 1;
    int size=(int) arg;
    for(int i = 1; i < size; i++){
        suma = suma * (int) arg;
        arg--;
    }
    printf(""Soy el thread 1 y estoy calculando el factorial de %d que es: %d \n"", size, suma);
    pthread_exit(NULL);
}

void *func2 (void *arg){
    int err;
    if(err = pthread_join(thread1, NULL)){
        printf(""Error al esperar a thread1 \n "");
    }else{
        int suma = 1;
        int size=(int) arg;
        for(int i = 1; i < size; i++){
            suma = suma * (int) arg;
            arg--;
        }
        printf(""Soy el thread 2 y estoy calculando el factorial de %d que es: %d \n"", size, suma);
    }
    pthread_exit(NULL);
}

int main(void){
    thmain = pthread_self();
    
    pthread_attr_init(&attr);

    printf(""Soy la funcion main y voy a lanzar los dos threads \n"");

    pthread_create(&thread1, &attr, func1, 4);
    pthread_create(&thread2, &attr, func2, 5);

    sleep(2);

    printf(""Soy main: he lanzado los dos threads y termino\n"");

    pthread_exit(NULL);
}",14,490,461
"int main(int argc, char** argv)
{
    clock_t t_ini, t_fin;
    double secs;

    int nproc=50;
    int myrank;

    t_ini = clock();

    MPI_Init(&argc,&argv);
    
    MPI_Comm_size (MPI_COMM_WORLD, &nproc);
    MPI_Comm_rank (MPI_COMM_WORLD,&myrank);

    printf(""Hola mundo, soy el proceso %d de un total de %d \n"",myrank,nproc);

    MPI_Finalize();

    t_fin = clock();

    secs = (double)(t_fin - t_ini)/ CLOCKS_PER_SEC;
    printf(""%.16g milisegundos\n"", secs * 1000.0);
    
    return 0;
}
",14,491,231
"void get_media(FILE *fd, char *tipo){
    char cadena[100];
    float suma = 0.1;
    float num[50];

    if(fd == NULL){
        fputs(""File error"", stderr);
        exit(1);
    }

    char *eptr;
    while(feof(fd) == 0){
        
        strcpy(cadena, fgets(cadena,100 ,fd));
        float result = strtod(cadena, &eptr);
        suma += result;
    }

    fclose(fd);

    printf(""%s: La media de los milisegundos es: %f\n"",tipo, suma/50);
}


int main(int argc, char** argv)
{
    FILE *fd;
    fd = fopen(""miliParalelo.txt"", ""r"");
    get_media(fd, ""Paralelo"");

    fd = fopen(""mili.txt"", ""r"");
    get_media(fd, ""Serie"");
    
    return 0;
}",14,492,280
"int Par[10];
    int Impar[10];

int main(int argc, char *argv[]){
    pid_t pid1, pid2;
    int status1=0,status2=0;
    int my_pipe[2];
    int my_pipe2[2];


    if (pipe(my_pipe2)==-1){ 
        fprintf(stderr, ""Pipe Failed"" ); 
        return 1; 
    } 
    if (pipe(my_pipe)==-1){ 
        fprintf(stderr, ""Pipe Failed"" ); 
        return 1; 
    } 
    

    if((pid1=fork())==0){
        
        close(my_pipe[0]);
        printf(""Child %d\n"", getpid());
        int impar=1;
        for(int i=0;i<10;i++){
            Impar[i]=impar*impar;    
            impar+=2;
        }

        write(my_pipe[1],&Impar,sizeof(Impar)+1);
        exit(EXIT_SUCCESS);
        
    }else{
        if((pid2=fork())==0){
            
            close(my_pipe2[0]);
            printf(""Child %d\n"", getpid());
            int par=2;
            for(int i=0;i<10;i++){
                Par[i]=par*par;
                par+=2;
            } 
            write(my_pipe2[1],&Par,sizeof(Par)+1);
            
            
            exit(EXIT_SUCCESS);
            
        
        }else{
            printf(""Father%d\n"", getpid());

            waitpid(pid1,&status1,2);
            close(my_pipe[1]);

            waitpid(pid2,&status2,2);
            close(my_pipe2[1]);
            
           
            int ParS[10];
            int ImparS[10];
            int Total[20];

            
            
            read(my_pipe[0],ImparS,sizeof(ImparS));
            read(my_pipe2[0],ParS,sizeof(ParS));

            int indexImpar=0;
            int indexPar=0;

            

            for(int i = 0; i < 20;){
                Total[i]=ImparS[indexImpar];
                i++;
                indexImpar++;
                Total[i]=ParS[indexPar];
                i++;
                indexPar++;
            }

            for(int i=0;i<20;i++) printf(""%i "", Total[i]);
            
        }
    }
    return 0;
}",14,493,678
"int main(int argc, char** argv){
    int size, rank, value;
    MPI_Status status;

    MPI_Init(&argc,&argv);

    MPI_Comm_size (MPI_COMM_WORLD, &size);
    MPI_Comm_rank (MPI_COMM_WORLD, &rank);

    if(rank == 0){
        printf(""Introduce el valor que quieres que se comunique: "");
        scanf(""%d"", &value);
        printf(""[%d]: envio el dato: %d a [%d]\n"", rank, value, rank+1);
        MPI_Send(&value, 1, MPI_INT, rank+1, size, MPI_COMM_WORLD);
    }else{
        MPI_Recv(&value, 1, MPI_INT, rank-1, size, MPI_COMM_WORLD, &status);
        if(rank < size-1) {
            printf(""[%d]: recibo el dato: %d de [%d] y lo envio a [%d]\n"", rank, value, rank-1, rank+1);
            MPI_Send(&value, 1, MPI_INT, rank+1, size, MPI_COMM_WORLD);
        }else{
            printf(""[%d]: recibo el dato: %d de [%d] y termino\n"", rank, value, rank-1);
        }
    }

    MPI_Finalize();
    
    return 0;
}",14,494,381
"int main(int argc, char *argv[]) {
    int rank, 
    size, 
    valor; 
    MPI_Status status; 

    MPI_Init(&argc, &argv); 
    
    MPI_Comm_size(MPI_COMM_WORLD, &size); 
    MPI_Comm_rank(MPI_COMM_WORLD, &rank); 
    
    srand(time(NULL));

    if (rank == 0) {
        valor = rand() % 4 + 1;
        valor *= valor;
    }

    printf(""[%d]: Antes del Bcast, el valor es %d \n"", rank, valor);

    MPI_Bcast(&valor, 1, MPI_INT, 0, MPI_COMM_WORLD);
    
    printf(""[%d]: Despues del Bcast, el valor es %d \n"", rank, valor);

    MPI_Finalize();

    return 0;
} ",14,495,249
"#include ""mpi.h""

int main(int argc, char **argv){
  MPI_Init(NULL, NULL);
 double A[10000];
 double B[10000];
 int world_rank;
  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);
  int world_size;
  MPI_Comm_size(MPI_COMM_WORLD, &world_size);


  if (world_rank != 0) {

    int i = 0;

    for(i; i < 10000; i++){
        A[i]=world_rank;
    }
    MPI_Recv(&B, 10000, MPI_INT, world_rank - 1, 0, MPI_COMM_WORLD,
             MPI_STATUS_IGNORE);
    printf(""Process %d received B[109] = %d from process %d\n"", world_rank, B[109],
           world_rank - 1);
  } else {
    int i = 0;
    for(i; i < 10000; i++){
        A[i]=world_rank;
    }
  }
    printf(""%d =>rank to : %d\n"",world_rank,(world_rank + 1) % world_size);
  MPI_Send(&A, 10000, MPI_INT, (world_rank + 1) % world_size, 0,
           MPI_COMM_WORLD);

  if (world_rank == 0) {
    MPI_Recv(&B, 10000, MPI_INT, world_size - 1, 0, MPI_COMM_WORLD,
             MPI_STATUS_IGNORE);
    printf(""Process %d received B[109] = %d \n"", world_rank, 3);
  }
  MPI_Finalize();



}",14,496,492
"int matriz[4][4] = {
    {1,2,3,4},
    {5,6,7,8},
    {9,10,11,12},
    {13,14,15,16}
};

int main(int argc, char* argv[]){
    int size, rank, buffer[16];

    MPI_Init(&argc, &argv);
    
    MPI_Comm_size(MPI_COMM_WORLD, &size);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);

    int my_row[4];
    
    for(int i = 0; i < 4; i++ ){
        my_row[i] = matriz[i][rank];
    }
 
    MPI_Allgather(&my_row, 4, MPI_INT, buffer, 4, MPI_INT, MPI_COMM_WORLD);
    MPI_Allgather(&my_row, 4, MPI_INT, buffer, 4, MPI_INT, MPI_COMM_WORLD);
    MPI_Allgather(&my_row, 4, MPI_INT, buffer, 4, MPI_INT, MPI_COMM_WORLD);
    MPI_Allgather(&my_row, 4, MPI_INT, buffer, 4, MPI_INT, MPI_COMM_WORLD);

    if(rank==0){
        for(int j = 0; j < 16; j++){
            printf(""%d "", buffer[j]);
            if(j == 3 || j == 7 || j == 11) printf(""\n"");
        }
        printf(""\n"");
    }

    MPI_Finalize();
 
    return 0;
}",14,497,451
"int main(int argc, char *argv[]){
    pid_t pid1;
    int status1=0,status2=0;
    int my_pipe[2];


    if (pipe(my_pipe)==-1){ 
        fprintf(stderr, ""Pipe Failed"" ); 
        return 1; 
    } 
    

    if((pid1=fork())==0){
        
        close(my_pipe[0]);
        printf(""Child %d\n"", getpid());

        char buffer[240];
        strcpy(buffer,""Envio este mensaje a mi padre usando las pipes aprendidas en la practica 3\n"");
        write(my_pipe[1],&buffer,sizeof(buffer));
        exit(EXIT_SUCCESS);
        
    }else{
        
            printf(""Father%d\n"", getpid());

            waitpid(pid1,&status1,2);
            close(my_pipe[1]);

            char buffer[240];
            
            
            read(my_pipe[0],buffer,sizeof(buffer));
            printf(buffer);
    }
    return 0;
}",14,498,290
"int main ()
{
    
    int a,b;
    
    printf(""lÃ¼tfen bir sayÄ± giriniz:"");
    scanf(""%d"",&a);
    
    
    printf(""lÃ¼tfen bir sayÄ± giriniz:"");
    scanf(""%d"",&b);
    
    if(a<b)
        printf(""a b'den kÃ¼Ã§Ã¼ktÃ¼r"");
        
    
    else if(a>b)
        printf(""a b'den bÃ¼yÃ¼ktÃ¼r"");
    
    else 
        printf(""a b ye eÅittir"");
            
    
    return 0;
    }
",15,499,172
"int main()
{
   

    int dizi[10]={1,23,4,534,123,564,89,34,76,0};

    int i,j,temp;

   for(j=0;j<10;j++)
   {
        for(i=0;i<10;i++)
        {   
            if(dizi[i]>dizi[i+1])
            {
            temp=dizi[i];
            dizi[i]=dizi[i+1];
            dizi[i+1]=temp;
            }
        }
   }   
    printf(""sÄ±ralanmÄ±Å dizi:\n"");
    
    for(i=0;i<10;i++)
    printf(""%d\n"",dizi[i]);




    
    



}",15,500,223
"int main ()
{
    
    int n;
    
    printf(""ders notunuzu 0-100 arasÄ±nda giriniz:"");
    scanf(""%d"",&n);
    
    if (n<=100 && n>=0)
    {
            
        if(90<=n)
            printf(""harf notunuz A"");
    
    
        else if(80<=n && n<90)
            printf(""harf notunuz B"");
    
    
        else if(70<=n && n<80)
            printf(""harf notunuz C"");   
        
        else 
            printf(""harf notunuz F"");
    }
    
    else 
    {
        printf(""girilen deÄer tanÄ±msÄ±z"");
        return 1;
    }
    
    return 0;
    }
",15,501,222
"int main ()
{
    
    
    
    int s1,s2,s3;
    
    printf(""lÃ¼tfen Ã¼Ã§ tane sayÄ± giriniz:"");
    scanf(""%d %d %d"",&s1,&s2,&s3);
    
    if(s1<s2 && s1<s3)
        printf(""en kÃ¼Ã§Ã¼k sayÄ± %d\n"",s1);
        
    if(s2<s1 && s2<s3)
        printf(""en kÃ¼Ã§Ã¼k sayÄ± %d\n"",s2);
    
    if(s3<s1 && s3<s2)
        printf(""en kÃ¼Ã§Ã¼k sayÄ± %d\n"",s3);
    
    
    
    if(s1>s2 && s1>s3)
        printf(""en bÃ¼yÃ¼k sayÄ± %d"",s1);
        
    
    if(s2>s1 && s2>s3)
        printf(""en bÃ¼yÃ¼k sayÄ± %d"",s2);   
    
    
    if(s3>s1 && s3>s2)
        printf(""en bÃ¼yÃ¼k sayÄ± %d"",s3);
    
    return 0;
    
    }
",15,502,338
"#define BOYUT 11

int mutDeger(int x,int y);

int main()
{
    
    int toplam=0,i,arr[BOYUT];
        
    for(i=0;i<BOYUT;i++)
    {
        printf(""%d. deÄeri giriniz:"",i+1);
        scanf(""%d"",&arr[i]);
    }

    arr[BOYUT]=0;

    for(i=0;i<BOYUT;i+=2)
    {   
        toplam+=mutDeger(arr[i],arr[i+1]);

    } 
     
     printf(""%d\n"",toplam);
}


int mutDeger(int x,int y)
{
    x+=y;

    if(x<0)
    {
        x*=-1;

        printf(""%d\n"",x);
    } 

    else
        printf(""%d\n"",x);

    return x;
}",15,503,258
"int main ()
{

 int num1=1 , num2=1 , sum=0;   
 int n,i;

 printf(""fibonacci dizisinin kaÃ§ elemanÄ±nÄ± yazdÄ±rmak istersiniz:"");
 scanf(""%d"",&n);
num2

 for(i=0;i<n;i++)
 {

        if(n==1)
    { printf(""%d\n"",num1);}

    else if(i==0)
    { printf(""%d %d "",num1,num2);
      if(n==2)
            return 0;

    }

    else 
    {
     sum=num1+num2;
     num1=num2;
     num2=sum;
     printf(""%d "",sum);

    }


            
                    

}   

    return 0;
}







",15,504,231
"int main()
{
  #define CITY  2
  #define WEEK  7
  
  const int x=5;



  int temperature[CITY][WEEK];

  
  for (int i = 0; i < CITY; ++i)
  {
    for (int j = 0; j < WEEK; ++j)
    {
      printf(""City %d, Day %d: "", i + 1, j + 1);
      scanf(""%d"", &temperature[i][j]);
    }
  }
  printf(""\nDisplaying values: \n\n"");

  
  for (int i = 0; i < CITY; ++i)
  {
    for (int j = 0; j < WEEK; ++j)
    {
      printf(""City %d, Day %d = %d\n"", i + 1, j + 1, temperature[i][j]);
    }
  }
  return 0;
}

",15,505,246
"int main() 
{ 
    int array[2]; 
 
    
    
    printf(""element 0: %d\n"",array[0]); 
    printf(""element 1: %d\n"",array[1]);
    printf(""%p\n"",&array[0]);
    printf(""%p\n"",&array[1]);

    printf(""element 2: %d\n"", array[2]);
    printf(""%p\n"",&array[2]);
    printf(""element 3: %d\n"", array[3]);
    printf(""%p\n"",&array[3]);
    printf(""element -1: %d\n"", array[-1]);
    printf(""%p\n"",&array[-1]);
    
    
    
        
    return 0; 

}
",15,506,192
"Definition Function 
---------------------------
non void 

function_type function_name (parametres)  (int x, char y) 
{
    commands;
    return x ;
}


void -> geriye deÄer dÃ¶ndÃ¼rmeyen fonksiyonlar

void  (int x, char y) 
{
    commands;
    printf(""asddsa"");
}

* -> pointer dÃ¶ndÃ¼ren

int * addr  (int x, char y) 
{
    commands;
    printf(""asddsa"");
}




int x (int a, int b)
{
    int sum =a+b;
    return sum;
}


int toplam (int a, int b)
{
    int sum =a+b;
    return sum;
}














main -> ana fonksiyon

Call Function 
---------------------------

function_type function_name (parametres)
{
    commands;
}



void main ()
{
    function_name(paramatres); 
}



",15,507,288
"int asalKontrol (int x,int y);

int main()
{
    int asal,num1;

    printf(""pozitif bir tam sayÄ± giriniz:\n"");
    scanf(""%d"",&num1);

    if(num1==1)
    {
        printf(""1 asal deÄildir\n"");
        
        return 0;    
    }

    asal=asalKontrol(num1,(num1/2));  

    if(asal==1)
        printf(""%d asaldÄ±r\n"",num1);

    else
         printf(""%d asal deÄildir\n"",num1);

   return 0;     
}

int asalKontrol (int x,int y)  
{                                           
    if(y==1)
        return 1;
    else
    {
        if(x%y==0)  
            return 0;

        else
            asalKontrol(x,y-1);    
    }    

}",15,508,265
"int main ()

{
    int i,k,l,yildiz;
    
    printf(""boyut giriniz:"");
    scanf(""%d"",&yildiz);

    if(yildiz<0)
    {
        printf(""hatalÄ± giriÅ"");
        return 1;
    }

    for(i=1;i<=yildiz;i++)
    {
         for(k=1;k<=yildiz-i;k++)
             printf("" "");
     
          for(l=1;l<=i;l++)
              printf(""*"");

      printf(""\n"");
     }


    return 0;

}
",15,509,168
"#define SIZE 11

void yaz (int arr[SIZE]);
int oku (int arr[SIZE]);


void main (void)
{
    int numara[SIZE];

    printf(""%s,\n"",""okul numaranÄ±zÄ± giriniz:"");

    numara=oku(numara);
    
    

}


void yaz (int arr[SIZE])
{
    int i;
    
    for(i=0;i<SIZE;i++)
        printf(""%d"",arr[i]);

}


int oku (int arr[SIZE])
{
    int i;

    for(i=0;i<SIZE;i++)
        scanf(""%d"",&arr[i]);

    return arr;    
}",15,510,190
"int fibonacci(int n);

int main()
{
    int n,i=1,c;

    printf(""serinin gitmesini istediÄiniz n deÄerini giriniz:\n"");
    scanf(""%d"",&n);

    printf(""Fibonacci dizisi\n"");

    for(c=1;c<=n;c++) 
    {
        printf(""%d\n"",fibonacci(i));    
        i++;       
    }

 return 0;   

}

int fibonacci(int n)
{
    if(n==0)
     return 0;

    else if (n==1)  
        return 1;
    
    else    
        return(fibonacci(n-1)+fibonacci(n-2));  
                   
               
} 



1  1   2 ",15,511,225
"#define SIZE 5
 
int tabanDonusumu(int arr[SIZE]);
int ustAlma(int ust);

int main (void)
{
    int i,binary[SIZE];

    printf(""%s\n"",""onluk tabana dÃ¶nÃ¼ÅtÃ¼rmek istediÄiniz binary deÄerini giriniz:"");

    for(i=0;i<SIZE;i++)
        scanf(""%d"",&binary[i]);

    printf(""binary sayÄ±:"");

    for(i=0;i<SIZE;i++)
        printf(""%d"",binary[i]);

    printf(""\n onluk biÃ§im:%d"",tabanDonusumu(binary));

}

int tabanDonusumu(int arr[SIZE])
{
    int i,j=0,ust,decimal;

    for(i=SIZE-1;i>0;i--,j++)
    {
        ust=ustAlma(j);
        decimal+=ust*arr[i];

    }
    
    return decimal;

}

int ustAlma(int ust)
{
    int i,deger=1;

    for(i=1;i<=ust;i++)
        deger*=2;  

    if(ust==0)
    deger=1;
    
    return deger;
}





  
",15,512,361
"int i=1; 

void sum (int num,int n);

int main()
{
    int num,n;

    printf(""arttÄ±rmak istediÄiniz deÄeri giriniz:\n"");
    scanf(""%d"",&n);

    printf(""hangi deÄerden itibaren arttÄ±rmak istediÄinizi giriniz:\n"");
    scanf(""%d"",&num);
    
    sum(num,n);
        
}

void sum (int num,int n)
{   
    
    num++;
    i++;

    if(i <= n)
    {
       sum(num,n);    
    }

    else
    {
         printf(""\nSum is %d\n"",num);
    }   


        
}
",15,513,209
"int main ()
{
    
    
    
        int secim ;
        
        printf(""\t---MENU---\t\n1-selamla\n2-toplama\n3-teklik kontrolÃ¼\n0-Ã§Ä±kÄ±Å\nsecim:"");
        
        scanf(""%d"",&secim);
        
        switch (secim)
        {
            
            case (0):
                return 0;
                
                break;
                
            case (1):
                printf(""helllo world\n"");
                
                break;
            
            case (2):
                {
                    int s1,s2;
                    
                    printf(""iki sayÄ± giriniz:"");
                    scanf(""%d %d"",&s1,&s2);
                
                    printf(""toplam: %d\n"",s1+s2);
                    
                }
                
                break;
                
            case(3):
                {
                    int s1;
                                    
                    printf(""bir sayÄ± giriniz"");
                    scanf(""%d"",&s1);
                    
                    if(s1%2==1)
                        printf(""sayÄ± tektir\n"");
                        
                    else 
                        printf(""sayÄ± Ã§ifttir\n"");
                }
                    
                break;
            
            
            
            default:
            {
                printf(""girilen iÅlem geÃ§ersiz\n"");
                return 1;
                
            }
            
                
            
        }
    
    
    
    
    return 0;
    
    
    
    
    
    }
",15,514,425
"int faktoriyel(int num);


int main ()
{
    int num,fact=0;

    printf(""faktÃ¶riyelini Ã¶Ärenmek istediÄiniz sayÄ±yÄ± giriniz:\n"");
    scanf(""%d"",&num);

    fact=faktoriyel(num);

    if(fact>0)
        printf(""\n[%d]! = [%d]\n"",num,fact);
   
return 0;

}

int faktoriyel(int num)
{
    int res=0;

    if(num <= 0)
        printf(""\nerror !\n"");
    

    else if (num==1)
        return num;

    else
    {
        res=num*faktoriyel(num-1);  
        
    }   
   return -1; 
}",15,515,228
"int main ()
{
    
    int n;
    
    printf(""ders notunuzu 0-100 arasÄ±nda giriniz:"");
    scanf(""%d"",&n);
    
            
        if(90<=n && n<=100)
            printf(""harf notunuz A"");
    
    
        else if(80<=n && n<90)
            printf(""harf notunuz B"");
    
    
        else if(70<=n && n<80)
            printf(""harf notunuz C"");   
        
        else 
            {
                if(0<=n && n<=100)
                printf(""harf notunuz F"");
                
                else 
                  printf(""geÃ§ersiz not girildi"");
            
        }
    
    return 0;
    }

",15,516,214
"int main()
{
    int n,i ; 
    int max,min,maxIndis,minIndis;
    
    

    printf(""%s"",""dizinin boyutunu giriniz:"")   ;
    scanf(""%d"",&n);

    int arr[n];

    for(i=0;i<n;i++)
    {
        printf(""%s\n"",""eleman giriniz:"");
        scanf(""%d"",&arr[i]);
    }

    max=min=arr[0];
    maxIndis=minIndis=0;

    for(i=1;i<n;i++)
    {
        if(min>arr[i])
        {
            min=arr[i];
            minIndis=i;
        }

        if(max<arr[i])
        {
            max=arr[i];
            maxIndis=i;
        }
    }

    printf(""en bÃ¼yÃ¼k deÄer:%d\nen bÃ¼yÃ¼k deÄer sÄ±rasÄ±:%d\n"",max,maxIndis+1);
    printf(""en kÃ¼Ã§Ã¼k deÄer:%d\nen kÃ¼Ã§Ã¼k deÄer sÄ±rasÄ±:%d\n"",min,minIndis+1);

    return 0;
}


",15,517,347
"#define BOYUT 2

int main()
{
    int m1[BOYUT][BOYUT];
    int m2[BOYUT][BOYUT];
    int toplam[BOYUT][BOYUT];
    int i,j;

    for(i=0;i<BOYUT;i++)
        for(j=0;j<BOYUT;j++)
        {
            printf(""%s"",""deÄer giriniz:\n"");
            scanf(""%d"",&m1[i][j]);
        }

    for(i=0;i<BOYUT;i++)
        for(j=0;j<BOYUT;j++)
        {
            printf(""%s"",""deÄer giriniz:\n"");
            scanf(""%d"",&m2[i][j]);
        }

    for(i=0;i<BOYUT;i++)
        for(j=0;j<BOYUT;j++)
            toplam[i][j]=m1[i][j] + m2[i][j];

    for(i=0;i<BOYUT;i++)
        for(j=0;j<BOYUT;j++)
            printf(""toplam[%d][%d]=%d\n"",i,j,toplam[i][j]);

    return 0;

}",15,518,336
"int main()
{
    
    int max,min,s1,s2,s3;
    
    
    printf(""lÃ¼tfen Ã¼Ã§ tane sayÄ± giriniz:"");
    scanf(""%d %d %d"",&s1,&s2,&s3);
    
    
    min=s1;
    max=s1;
    
    if(max<s2)
        max=s2;
        
    if(max<s3)
        max=s3;
        
    
    
    if(min>s2)
        min=s2;
    
    if(min>s3)
        min=s3;
        
        
    printf(""en bÃ¼yÃ¼k : %d\nen kÃ¼Ã§Ã¼k: %d"",max,min);
    
    return 0;
    }
",15,519,217
"int main ()
{

 int num1=1 , num2=1 , sum=0;   
 int n,i;

 printf(""fibonacci dizisinin kaÃ§ elemanÄ±nÄ± yazdÄ±rmak istersiniz:"");
 scanf(""%d"",&n);

 if(n<0)
 {
     printf(""hatalÄ± giriÅ\n"");
     return 1;
 }

 for(i=0;i<n;i++)
 {

        if(n==1)
    { printf(""%d\n"",num1);}

    else if(i==0)
    { printf(""%d %d "",num1,num2);
      if(n==2)
            return 0;

    }

    else 
    {
     sum=num1+num2;
     num1=num2;
     num2=sum;
     printf(""%d "",sum);

    }


            
                    

}   

    return 0;




}
",15,520,259
"int main ()
{
    int i,j;
    int yildiz;
    
    printf(""lÃ¼tfen boyut giriniz"");
    scanf(""%d"",&yildiz);
       
    if(yildiz<0)
    {   
      printf(""hatalÄ± giriÅ yaptÄ±nÄ±z"");
      return (1);
    }
    
    for(i=0;i<yildiz;i++)
    {
      for(j=0;j<=i;j++)
       printf(""*"");

      printf(""\n"");
                

    }


    return 0;
}
",15,521,160
"int count =0;
     void merge(int[50],int,int,int); 
     void merge_sort(int[50],int,int); 
     void main()
      {
       void getdata(int[50],int);
       void putdata(int[50],int);
       int i,a[50],n;
       printf(""Enter the value of n \n"");
       scanf(""%d"",&n);
       getdata(a,n);
       printf(""Before sorting \n"");
       putdata(a,n);
       merge_sort(a,0,n-1);
       printf(""After sorting \n"");
       putdata(a,n);
       printf(""value of count=%d \n"",count);
      }
     void getdata(int x[50],int n)
       {
        int k;
        printf(""enter the value  for sorting\n"");
        for(k=0;k<n;k++)
        {
         scanf(""%d"",&x[k]);
        }     
       }
     void putdata(int x[50], int n)
       {
        int k;
        for(k=0;k<n;k++)
         {
          printf(""%d\t"",x[k]);
         }
          printf(""\n"");
        }
     void merge(int a[], int p, int q, int r) 
        { 
         int i, j, k; 
         int n1 =q-p+1; 
         int n2 =r-q; 
         count++;
         int L[n1],R[n2]; 
         count++;
         for(i=0;i<n1;i++)
          {
              count++;
              count++;
           L[i]=a[p+i];
           count++;
          }
         for(j=0;j<n2;j++)
          {
              count++;
              count++;
           R[j]=a[q+1+j];
           count++;
          }
         i=0; 
         j=0; 
         k=p; 
         count++;
         while(i<n1 && j<n2) 
          {
              count++;
           if(L[i] <= R[j]) 
            {
                count++;
            a[k]=L[i]; 
            count++;
            i++; 
            count++;
            } 
           else 
            {
                count++;
            a[k]=R[j];
            count++;
            j++; 
            count++;
            } 
            count++;
           k++;
           
          } 
          
         while(i<n1) 
          {
              count++;
           a[k]=L[i];
           count++;
           i++;
           count++;
           k++; 
           count++;
          } 
          
         while(j<n2) 
          {
           count++;
           a[k]=R[j];
           count++;
           j++; 
           count++;
           k++; 
           count++;
          }
        } 
       void merge_sort(int a[50],int p,int r)
        {
         int q;
         count++;
     if(p<r)
       { 
             count++;
             q=(p+r)/2;
             count++;
             merge_sort(a,p,q);
             count++;
             merge_sort(a,q+1,r);
             count++;
             merge(a,p,q,r);
             count++;
            }
           }
",16,522,868
"void main()
{
  int a[2][2], b[2][2], c[2][2], i, j, p1, p2, p3, p4 , p5, p6, p7,az,bz,cz,d,e,f,g,h;
  printf(""Enter elements of first matrix: "");
  for(i = 0;i < 2; i++)
  {
      for(j = 0;j < 2; j++)
      {
           scanf(""%d"", &a[i][j]);
      }
  }
  printf(""Enter elements of second matrix: "");
  for(i = 0; i < 2; i++)
  {
      for(j = 0;j < 2; j++)
      {
           scanf(""%d"", &b[i][j]);
           
      }
  }

  az=a[0][0];
  bz=a[0][1];
  cz=a[1][0];
  d=a[1][1];
  e=b[0][0];
  f=b[0][1];
  g=b[1][0];
  h=b[1][1];
  p1=az*(f-h);
  p2=(az+bz)*h;
  p3=(cz+d)*e;
  p4=d*(g-e);
  p5=(az+d)*(e+h);
  p6=(bz-d)*(g+h);
  p7=(az-cz)*(e+f);
  
  c[0][0] = p5+p4-p2+p6;
  c[0][1] = p1+p2;
  c[1][0] = p3+p4;
  c[1][1] = p1+p5-p3-p7;
 
   printf(""\nAfter multiplication\n"");
   for(i = 0; i < 2 ; i++){
      printf(""\n"");
      for(j = 0;j < 2; j++)
           printf(""%d\t"", c[i][j]);
   }
 
}
",16,523,524
"int count =0;
       int partition(int [50],int,int); 
       void quick_sort(int[50],int,int);
       int myrandom(int,int);
     void main()
      {
       void getdata(int[50],int);
       void putdata(int[50],int);
       int i,a[50],n;
       printf(""Enter the value of n \n"");
       scanf(""%d"",&n);
       getdata(a,n);
       printf(""Before sorting \n"");
       putdata(a,n);
       quick_sort(a,0,n-1);
       printf(""After sorting \n"");
       putdata(a,n);
       printf(""value of count=%d \n"",count);
      }
     void getdata(int x[50],int n)
       {
        int k;
        printf(""enter the value  for sorting\n"");
        for(k=0;k<n;k++)
        {
         scanf(""%d"",&x[k]);
        }     
       }
     void putdata(int x[50], int n)
       {
        int k;
        for(k=0;k<n;k++)
         {
          printf(""%d\t"",x[k]);
         }
          printf(""\n"");
        }
      int myrandom(int lower,int upper)
      {
          int num;
          srand(time(0));
          num = (rand() % (upper - lower + 1) + lower);
          return num;
      }
        
    int partition(int a[50],int p,int r)
   {
    int x,i,j,temp,y;
    y=myrandom(p,r-1);
    temp=a[y];
    a[y]=a[r];
    a[r]=temp;
    x=a[r];
    i=p-1;
    count++;
    for(j=p;j<=r-1;j++)
    {
        count++;
        if(a[j]<=x)
        {
        count++;
            i=i+1;
        count++;
            temp=a[j];
        count++;
            a[j]=a[i];
        count++;
            a[i]=temp;
        count++;
        }
        count++;
    }
    count++;
    temp =a[r];
    count++;
    a[r]=a[i+1];                       
    count++;
    a[i+1]=temp;
    count++;
    return i+1;
    }

void quick_sort(int a[50],int p,int r)
{   
    int q;
    count++;
    if(p<r)
    {
        count++;
        q=partition(a,p,r);
        count++;
        quick_sort(a,p,q-1);
        count++;
        quick_sort(a,q+1,r);
        count++;
    }
}
",16,524,739
"void magic(int);
void main()
{
    int n;
    printf(""Enter the number to be checked \n"");
    scanf(""%d"",&n);
    magic(n);
}
void magic(int n)
{
    int i,sum=0,num=n;
        while (n > 0 || sum > 9) 
    { 
        if (n == 0) 
        { 
            n = sum; 
            sum = 0; 
        } 
        sum =sum + n % 10; 
        n = n / 10; 
    } 
     if(sum==1)
     {
         printf(""%d is a magic number"",num);
     }
     else
     {
         printf(""%d is not a magic number"",num);
     }
}
",16,525,200
"int main()
{
    int a[100];
    int n,i,count=0,item;
    printf(""Enter the size of array"");
    scanf(""%d"",&n);
    printf(""Enter the numbers in array \n"");
    for(i=0;i<n;i++)
    {
        scanf(""%d"",&a[i]);
    }
    printf(""The elements in array are: \n"");
     for(i=0;i<n;i++)
    {
        printf(""%d"",a[i]);
    }
    printf(""Enter the no. to be searched \n"");
    scanf(""%d"",&item);
    count++;
    for(i=0;i<n;i++)
    {
        count++;
        if(a[i]==item)
        {
            count++;
            printf(""\n Number found at position %d \n"",i);
            count++;
            break;
        }
        count++;
    }
    if(i==n)
    {
        printf(""No.not found"");  
    }
    printf(""Count=%d"",count);
}
",16,526,272
"int count = 0;
void main()
{
  void getdata(int[50],int);
  void putdata(int[50],int);
  int binary_search(int a[50],int,int);
    int a[50],n,item,loc;
    printf(""Enter the value of n\n"");
    scanf(""%d"",&n);
    getdata(a,n);
    printf(""Enter the item to be searched\n"");
    scanf(""%d"",&item);
    printf(""The given array is \n"");
    putdata(a,n);
    loc=binary_search( a,n,item);
    if(loc>=0)
{
printf(""element found at %d\n"",loc);
}
else
{
printf(""Item not found\n"");
}
   
    printf(""Value of count=%d \n"",count);
}
    void getdata(int x[50],int n)
      {
        int k;
        printf(""enter the values in the array\n"");
        for(k=0;k<n;k++)
        {
         scanf(""%d"",&x[k]);
        } 
       }
    void putdata(int x[50], int n)
       {
          int k;
          for(k=0;k<n;k++)
         {
          printf(""%d\t"",x[k]);
         }
          printf(""\n"");
       }
       int binary_search(int x[50],int n,int item)
       {
        int i,lb=0,ub=n-1,mid;
        count++;
        while(lb<=ub)
        {
         count++;
         mid=(lb+ub)/2;
         count++;
         if(x[mid]==item)
            {
            count++;
            return mid;
            count++;
            }
            
         else if(item>x[mid])
            {
            count++;
            lb=mid+1;
            count++;
            }
            
         else
            {
            count++;
            ub=mid-1;
            count++;
            }
        }
        count++;
        return -1;
        count++;
       }

",16,527,537
"int count = 0;
void main()
{
  void getdata(int[50],int);
  void putdata(int[50],int);
  void improvised_bubble_sort(int a[50],int);
    int a[50],n;
    printf(""Enter the value of n\n"");
    scanf(""%d"",&n);
    getdata(a,n);
    printf(""Before sorting \n"");
    putdata(a,n);
    improvised_bubble_sort( a,n);
    printf(""After sorting \n"");
    putdata(a,n);
    printf(""Value of count=%d \n"",count);
}
    void getdata(int x[50],int n)
      {
        int k;
        printf(""enter the value for sorting\n"");
        for(k=0;k<n;k++)
        {
         scanf(""%d"",&x[k]);
        } 
       }
    void putdata(int x[50], int n)
       {
          int k;
          for(k=0;k<n;k++)
         {
          printf(""%d\t"",x[k]);
         }
          printf(""\n"");
       }
    void improvised_bubble_sort(int a[50],int n)
    {
       int i,j,temp,flag=1;
       count++;
       for(i=1;i<n && flag;i++)
       {
           count++;
           count++;
           flag=0;
           for(j=0;j<n-i;j++)
           {
               count++;
               count++;
               if(a[j]>a[j+1])
               {
                   count++;
                   temp=a[j];
                   count++;
                   a[j]=a[j+1];
                   count++;
                   a[j+1]=temp;
                   count++;
                   flag=1;
                   count++;
               }
           }
       }
    }
",16,528,495
"long int static count=0;
void TOH(int n,char A,char B,char C)
{
if(n==1)
{
count++;
printf(""\nMove %c to %c"",A,B);
count++;
}
else
{
TOH(n-1,A,C,B);
count++;
printf(""\nMove %c to %c"",A,B);
count++;
TOH(n-1,C,B,A);
count++;
}
}
int main()
{
int n = 0;
char A='A',B='B',C='C';
printf(""Enter the number of disc:"");
scanf(""%d"",&n);
TOH(n,A,B,C);
printf(""\n\nCount=%ld"",count);
printf(""\n"");
return 0;
}
",16,529,201
"int count = 0;
void main()
{
  void getdata(int[50],int);
  void putdata(int[50],int);
  void bubble_sort(int a[50],int);
    int a[50],n;
    printf(""Enter the value of n\n"");
    scanf(""%d"",&n);
    getdata(a,n);
    printf(""Before sorting \n"");
    putdata(a,n);
    bubble_sort( a,n);
    printf(""After sorting \n"");
    putdata(a,n);
    printf(""Value of count=%d \n"",count);
}
    void getdata(int x[50],int n)
      {
        int k;
        printf(""enter the value for sorting\n"");
        for(k=0;k<n;k++)
        {
         scanf(""%d"",&x[k]);
        } 
       }
    void putdata(int x[50], int n)
       {
          int k;
          for(k=0;k<n;k++)
         {
          printf(""%d\t"",x[k]);
         }
          printf(""\n"");
       }
    void bubble_sort(int a[50],int n)
    {
       int i,j,temp;
       count++;
       for(i=1;i<n;i++)
       {
           count++;
           count++;
           for(j=0;j<n-i;j++)
           {
               count++;
               count++;
               if(a[j]>a[j+1])
               {
                   count++;
                   temp=a[j];
                   count++;
                   a[j]=a[j+1];
                   count++;
                   a[j+1]=temp;
                   count++;
               }
           }
       }
    }
",16,530,462
"int count=0;
void selectionsort(int[],int);
void main()
{
     void getdata(int[50],int);  
     void putdata(int[50],int);  
     int i,a[50],n;  
     printf(""Enter the value of n\n"");    
     scanf(""%d"",&n);  
     getdata(a,n);    
     printf(""Before sorting \n"");    
     putdata(a,n);
     selectionsort(a,n);     
     printf(""After sorting \n"");    
     putdata(a,n);     
     printf(""value of count=%d \n"",count);
}
    void getdata(int x[50],int n)

       {
        int k;
        printf(""enter the value  for sorting\n"");
        for(k=0;k<n;k++)
        {
         scanf(""%d"",&x[k]);
        } }
     void putdata(int x[50], int n)

         {
          int k;
          for(k=0;k<n;k++)
         {
          printf(""%d\t"",x[k]);
           }
          printf(""\n"");
          }
void selectionsort(int numbers[],int array_size)
{
    int i,j,T,min;
    count++;
    for(i=0;i<array_size;i++)
    {
        count++;
        min=i;
        count++;
        for(j=i+1;j<array_size;j++)
        {
            count++;
            if(numbers[j]<numbers[min])
            {
                count++;
                min=j;
                count++;
            }
        }
        count++;
        if(i!=min)
        {
        count++;
        T=numbers[min];
        count++;
        numbers[min]=numbers[i];
        count++;
        numbers[i]=T;
        count++;
        }
    }
}
",16,531,490
"void main()
{
int i,j,m,n;
char x[50];
char y[50];
int c[51][51];
char b[51][51];
printf(""Enter the first string\n"");
scanf(""%s"",x);
printf(""Enter the second string\n"");
scanf(""%s"",y);
m=strlen(x);
n=strlen(y);
for(i=1;i<=m;i++)
{
c[i][0]=0;
}
for(j=0;j<=n;j++)
{
c[0][j]=0;
}
for(i=1;i<=m;i++)
{
    for(j=1;j<=n;j++)
    {
        if(x[i-1]==y[j-1])
        {
        c[i][j]=c[i-1][j-1]+1;
        b[i][j]=92;
        }
        else if(c[i-1][j]>=c[i][j-1])
        {
            c[i][j]=c[i-1][j];
            b[i][j]='^';
        }
        else
        {
            c[i][j]=c[i][j-1];
            b[i][j]='<';   
        }
    }
}
for(i=0;i<=m;i++)
{
    for(j=0;j<=n;j++)
    {
        printf(""%d "",c[i][j]);
    }
    printf(""\n"");
}
for(i=1;i<=m;i++)
{
    for(j=1;j<=n;j++)
    {
        printf(""%c "",b[i][j]);
    }
    printf(""\n"");
}
        
}
",16,532,451
"int count=0;
void max_heapify(int[100],int,int);
void build_max_heap(int[100],int);
void heapsort(int[100],int);
    void main()
    {
        void getdata(int[100],int);  
        void putdata(int[100],int);  
        int a[100],n;  
        printf(""Enter the value of n\n"");    
        scanf(""%d"",&n);  
        getdata(a,n);    
        printf(""Before sorting \n"");    
        putdata(a,n);
        heapsort(a,n);
        printf(""After sorting \n"");    
        putdata(a,n);     
        printf(""value of count=%d \n"",count);
    }
    void getdata(int x[100],int n)
    {
        int k;
        printf(""enter the value  for sorting\n"");
        for(k=0;k<n;k++)
        {
         scanf(""%d"",&x[k]);
        } 
    }
    void putdata(int x[100], int n)
    {
          int k;
          for(k=0;k<n;k++)
         {
          printf(""%d\t"",x[k]);
         }
          printf(""\n"");
    }
    void max_heapify(int a[100],int n,int i)
    {
        int temp;
        int largest=i;
        int left=2*i+1;
        int right=2*i+2;
        count++;
        if(left<n && a[left]>a[largest])
        {
            count++;
            largest=left;
            count++;
        }
        count++;
        if(right<n && a[right]>a[largest])
        {
            count++;
            largest=right;
            count++;
        }
        count++;
        if(largest!=i)
        {
            count++;
            temp=a[i];
            count++;
            a[i]=a[largest];
            count++;
            a[largest]=temp;
            count++;
            max_heapify(a,n,largest);
            count++;
        }
    }
    void build_max_heap(int a[100],int n)
    {
        int i;
        count++;
        for(i=(n/2)-1;i>=0;i--)
        {
            count++;
            max_heapify(a,n,i);
            count++;
        }
    }
    void heapsort(int a[100],int n)
    {
        int temp,i;
        count++;
        build_max_heap(a,n);
        count++;
        for(i=n-1;i>0;i--)
        {
            count++;
            temp=a[0];
            count++;
            a[0]=a[i];
            count++;
            a[i]=temp;
            count++;
            max_heapify(a,i,0);
            count++;
        }
    }
",16,533,787
"int count=0;
void counting_sort(int[],int,int);
void main()
{
    int n,k=0,A[30],i;
    printf(""Enter the value of n \n"");
    scanf(""%d"",&n);
    printf(""Enter the values to be sorted\n"");
    for (i=1;i<=n;i++)
    {
        scanf(""%d"",&A[i]);
        if (A[i]>k) 
        {
            k=A[i];
        }
    }
    counting_sort(A, k, n);
    printf(""\nValue of count=%d"",count);
}
void counting_sort(int A[], int k, int n)
{
    int i, j,B[30],C[100];
    count++;
    for (i=0;i<=k;i++)
    {
        C[i]=0;
        count++;
        }
        count++;
    for (j=1;j<=n;j++){
        C[A[j]]=C[A[j]]+1;
        count++;
        }
        count++;
    for (i=1;i<=k;i++){
        C[i]=C[i]+C[i-1];
        count++;
        }
        count++;
    for (j=n;j>=1;j--)
    {
        count++;
        B[C[A[j]]]=A[j];
        count++;
        C[A[j]]=C[A[j]]-1;
        count++;
    }
    printf(""Array after sorting\n "");
    for (i=1;i<=n;i++)
        printf(""%d "",B[i]);
}
",16,534,423
"#include ""nrf_dfu_flash.h""
#include ""nrf_dfu_types.h""

#include ""nrf_fstorage.h""
#include ""nrf_fstorage_sd.h""
#include ""nrf_fstorage_nvmc.h""


#define NRF_LOG_MODULE_NAME nrf_dfu_flash
#include ""nrf_log.h""

#if NRF_DFU_FLASH_CONFIG_LOG_ENABLED
#define NRF_LOG_LEVEL BLE_SCAN_CONFIG_LOG_LEVEL
#define NRF_LOG_INFO_COLOR BLE_SCAN_CONFIG_INFO_COLOR
#define NRF_LOG_DEBUG_COLOR BLE_SCAN_CONFIG_DEBUG_COLOR
#else 
#define NRF_LOG_LEVEL 4
#endif 
#include ""nrf_log.h""
NRF_LOG_MODULE_REGISTER();


void dfu_fstorage_evt_handler(nrf_fstorage_evt_t * p_evt);


NRF_FSTORAGE_DEF(nrf_fstorage_t m_fs) =
{
        .evt_handler = dfu_fstorage_evt_handler,
        .start_addr  = MBR_SIZE,
        .end_addr    = BOOTLOADER_SETTINGS_ADDRESS + BOOTLOADER_SETTINGS_PAGE_SIZE
};

static uint32_t m_flash_operations_pending;

void dfu_fstorage_evt_handler(nrf_fstorage_evt_t * p_evt)
{
        if (NRF_LOG_ENABLED && (m_flash_operations_pending > 0))
        {
                m_flash_operations_pending--;
        }

        if (p_evt->result == NRF_SUCCESS)
        {
                NRF_LOG_DEBUG(""Flash %s success: addr=%p, pending %d"",
                              (p_evt->id == NRF_FSTORAGE_EVT_WRITE_RESULT) ? ""write"" : ""erase"",
                              p_evt->addr, m_flash_operations_pending);
        }
        else
        {
                NRF_LOG_DEBUG(""Flash %s failed (0x%x): addr=%p, len=0x%x bytes, pending %d"",
                              (p_evt->id == NRF_FSTORAGE_EVT_WRITE_RESULT) ? ""write"" : ""erase"",
                              p_evt->result, p_evt->addr, p_evt->len, m_flash_operations_pending);
        }

        if (p_evt->p_param)
        {
                
                ((nrf_dfu_flash_callback_t)(p_evt->p_param))((void*)p_evt->p_src);
                
        }
}


ret_code_t nrf_dfu_flash_init(bool sd_irq_initialized)
{
        nrf_fstorage_api_t * p_api_impl;

        
#if defined(BLE_STACK_SUPPORT_REQD) || defined(ANT_STACK_SUPPORT_REQD)
        if (sd_irq_initialized)
        {
                NRF_LOG_DEBUG(""Initializing nrf_fstorage_sd backend."");
                p_api_impl = &nrf_fstorage_sd;
        }
        else
#endif
        {
                NRF_LOG_DEBUG(""Initializing nrf_fstorage_nvmc backend."");
                p_api_impl = &nrf_fstorage_nvmc;
        }



        return nrf_fstorage_init(&m_fs, p_api_impl, NULL);
}


ret_code_t nrf_dfu_flash_store(uint32_t dest,
                               void const * p_src,
                               uint32_t len,
                               nrf_dfu_flash_callback_t callback)
{
        ret_code_t rc;

        NRF_LOG_DEBUG(""nrf_fstorage_write(addr=%p, src=%p, len=%d bytes), queue usage: %d"",
                      dest, p_src, len, m_flash_operations_pending);

        
        rc = nrf_fstorage_write(&m_fs, dest, p_src, len, (void *)callback);
        

        if ((NRF_LOG_ENABLED) && (rc == NRF_SUCCESS))
        {
                m_flash_operations_pending++;
        }
        else
        {
                NRF_LOG_WARNING(""nrf_fstorage_write() failed with error 0x%x."", rc);
        }

        return rc;
}


ret_code_t nrf_dfu_flash_erase(uint32_t page_addr,
                               uint32_t num_pages,
                               nrf_dfu_flash_callback_t callback)
{
        ret_code_t rc;

        NRF_LOG_DEBUG(""nrf_fstorage_erase(addr=0x%p, len=%d pages), queue usage: %d"",
                      page_addr, num_pages, m_flash_operations_pending);

        
        rc = nrf_fstorage_erase(&m_fs, page_addr, num_pages, (void *)callback);
        

        if ((NRF_LOG_ENABLED) && (rc == NRF_SUCCESS))
        {
                m_flash_operations_pending++;
        }
        else
        {
                NRF_LOG_WARNING(""nrf_fstorage_erase() failed with error 0x%x."", rc);
        }

        return rc;
}
",17,535,1475
"#include ""sdk_common.h""
#if NRF_MODULE_ENABLED(BLE_NUS_C)


#include ""ble.h""
#include ""ble_nus_c.h""
#include ""ble_gattc.h""
#include ""ble_srv_common.h""
#include ""app_error.h""

#define NRF_LOG_MODULE_NAME ble_nus_c
#include ""nrf_log.h""
NRF_LOG_MODULE_REGISTER();

#define TX_BUFFER_MASK         0x07                  
#define TX_BUFFER_SIZE         (TX_BUFFER_MASK + 1)  

#define WRITE_MESSAGE_LENGTH   BLE_CCCD_VALUE_LEN    
#define WRITE_MESSAGE_LENGTH   BLE_CCCD_VALUE_LEN    

typedef enum
{
        READ_REQ, 
        WRITE_REQ 
} tx_request_t;


typedef struct
{
        uint8_t gattc_value[WRITE_MESSAGE_LENGTH];               
        ble_gattc_write_params_t gattc_params;                   
} write_params_t;


typedef struct
{
        uint16_t conn_handle;  
        tx_request_t type;     
        union
        {
                uint16_t read_handle; 
                write_params_t write_req; 
        } req;
} tx_message_t;

static tx_message_t m_tx_buffer[TX_BUFFER_SIZE];  
static uint32_t m_tx_insert_index = 0;            
static uint32_t m_tx_index = 0;                   


static void tx_buffer_process(void)
{
        if (m_tx_index != m_tx_insert_index)
        {
                uint32_t err_code;

                if (m_tx_buffer[m_tx_index].type == READ_REQ)
                {
                        err_code = sd_ble_gattc_read(m_tx_buffer[m_tx_index].conn_handle,
                                                     m_tx_buffer[m_tx_index].req.read_handle,
                                                     0);
                }
                else
                {
                        err_code = sd_ble_gattc_write(m_tx_buffer[m_tx_index].conn_handle,
                                                      &m_tx_buffer[m_tx_index].req.write_req.gattc_params);
                }
                if (err_code == NRF_SUCCESS)
                {
                        NRF_LOG_DEBUG(""SD Read/Write API returns Success.."");
                        m_tx_index++;
                        m_tx_index &= TX_BUFFER_MASK;
                }
                else
                {
                        NRF_LOG_DEBUG(""SD Read/Write API returns error. This message sending will be ""
                                      ""attempted again.."");
                }
        }
}


void ble_nus_c_on_db_disc_evt(ble_nus_c_t * p_ble_nus_c, ble_db_discovery_evt_t * p_evt)
{
        ble_nus_c_evt_t nus_c_evt;
        memset(&nus_c_evt,0,sizeof(ble_nus_c_evt_t));

        ble_gatt_db_char_t * p_chars = p_evt->params.discovered_db.charateristics;

        
        if (    (p_evt->evt_type == BLE_DB_DISCOVERY_COMPLETE)
                &&  (p_evt->params.discovered_db.srv_uuid.uuid == BLE_UUID_NUS_SERVICE)
                &&  (p_evt->params.discovered_db.srv_uuid.type == p_ble_nus_c->uuid_type))
        {
                for (uint32_t i = 0; i < p_evt->params.discovered_db.char_count; i++)
                {
                        switch (p_chars[i].characteristic.uuid.uuid)
                        {
                        case BLE_UUID_NUS_RX_CHARACTERISTIC:
                                nus_c_evt.handles.nus_rx_handle = p_chars[i].characteristic.handle_value;
                                break;

                        case BLE_UUID_NUS_TX_CHARACTERISTIC:
                                nus_c_evt.handles.nus_tx_handle = p_chars[i].characteristic.handle_value;
                                nus_c_evt.handles.nus_tx_cccd_handle = p_chars[i].cccd_handle;
                                break;

                        default:
                                break;
                        }
                }
                NRF_LOG_DEBUG(""NUS Service discovered at peer."");
                if (p_ble_nus_c->evt_handler != NULL)
                {
                        if (p_ble_nus_c->conn_handle != BLE_CONN_HANDLE_INVALID)
                        {
                                nus_c_evt.conn_handle = p_evt->conn_handle;
                                nus_c_evt.evt_type    = BLE_NUS_C_EVT_DISCOVERY_COMPLETE;
                                p_ble_nus_c->evt_handler(p_ble_nus_c, &nus_c_evt);
                        }
                }
        }
}


static void on_write_rsp(ble_nus_c_t * p_ble_nus_c, ble_evt_t const * p_ble_evt)
{
        
        if (p_ble_nus_c->conn_handle != p_ble_evt->evt.gattc_evt.conn_handle)
        {
                return;
        }
        
        tx_buffer_process();
}




static void on_hvx(ble_nus_c_t * p_ble_nus_c, ble_evt_t const * p_ble_evt)
{
        
        if (p_ble_nus_c->conn_handle != p_ble_evt->evt.gattc_evt.conn_handle)
        {
                return;
        }
        
        if ((p_ble_evt->evt.gattc_evt.params.hvx.handle == p_ble_nus_c->handles.nus_tx_handle) \
            && (p_ble_nus_c->evt_handler != NULL))
        {
                
                {
                        ble_nus_c_evt_t ble_nus_c_evt;

                        ble_nus_c_evt.evt_type                   = BLE_NUS_C_EVT_NUS_TX_EVT;
                        ble_nus_c_evt.conn_handle                = p_ble_nus_c->conn_handle;
                        ble_nus_c_evt.p_data   = (uint8_t *)p_ble_evt->evt.gattc_evt.params.hvx.data;
                        ble_nus_c_evt.data_len = p_ble_evt->evt.gattc_evt.params.hvx.len;

                        p_ble_nus_c->evt_handler(p_ble_nus_c, &ble_nus_c_evt);
                        NRF_LOG_DEBUG(""Client sending data."");
                }
        }
}

uint32_t ble_nus_c_init(ble_nus_c_t * p_ble_nus_c, ble_nus_c_init_t * p_ble_nus_c_init)
{
        uint32_t err_code;
        ble_uuid_t uart_uuid;
        ble_uuid128_t nus_base_uuid = NUS_BASE_UUID;

        VERIFY_PARAM_NOT_NULL(p_ble_nus_c);
        VERIFY_PARAM_NOT_NULL(p_ble_nus_c_init);

        p_ble_nus_c->conn_handle           = BLE_CONN_HANDLE_INVALID;
        p_ble_nus_c->handles.nus_tx_handle = BLE_GATT_HANDLE_INVALID;
        p_ble_nus_c->handles.nus_rx_handle = BLE_GATT_HANDLE_INVALID;
        p_ble_nus_c->evt_handler           = p_ble_nus_c_init->evt_handler;

        err_code = sd_ble_uuid_vs_add(&nus_base_uuid, &p_ble_nus_c->uuid_type);
        VERIFY_SUCCESS(err_code);

        uart_uuid.type = p_ble_nus_c->uuid_type;
        uart_uuid.uuid = BLE_UUID_NUS_SERVICE;

        return ble_db_discovery_evt_register(&uart_uuid);
}

void ble_nus_c_on_ble_evt(ble_evt_t const * p_ble_evt, void * p_context)
{
        ble_nus_c_t * p_ble_nus_c = (ble_nus_c_t *)p_context;

        if ((p_ble_nus_c == NULL) || (p_ble_evt == NULL))
        {
                return;
        }

        if ( (p_ble_nus_c->conn_handle != BLE_CONN_HANDLE_INVALID)
             &&(p_ble_nus_c->conn_handle != p_ble_evt->evt.gap_evt.conn_handle)
             )
        {
                return;
        }

        switch (p_ble_evt->header.evt_id)
        {
        case BLE_GATTC_EVT_HVX:
                on_hvx(p_ble_nus_c, p_ble_evt);
                break;

        case BLE_GATTC_EVT_WRITE_RSP:
                on_write_rsp(p_ble_nus_c, p_ble_evt);
                break;

        case BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE:

                break;

        case BLE_GAP_EVT_DISCONNECTED:
                if (p_ble_evt->evt.gap_evt.conn_handle == p_ble_nus_c->conn_handle
                    && p_ble_nus_c->evt_handler != NULL)
                {
                        ble_nus_c_evt_t nus_c_evt;

                        nus_c_evt.evt_type = BLE_NUS_C_EVT_DISCONNECTED;
                        nus_c_evt.conn_handle = p_ble_evt->evt.gap_evt.conn_handle;

                        p_ble_nus_c->conn_handle = BLE_CONN_HANDLE_INVALID;
                        p_ble_nus_c->evt_handler(p_ble_nus_c, &nus_c_evt);
                }
                break;

        default:
                
                break;
        }
}


static uint32_t cccd_configure(uint16_t conn_handle, uint16_t cccd_handle, bool enable)
{
        NRF_LOG_DEBUG(""Configuring CCCD. CCCD Handle = %d, Connection Handle = %d"",
                      cccd_handle,conn_handle);

        tx_message_t * p_msg;
        uint16_t cccd_val = enable ? BLE_GATT_HVX_NOTIFICATION : 0;

        p_msg              = &m_tx_buffer[m_tx_insert_index++];
        m_tx_insert_index &= TX_BUFFER_MASK;

        p_msg->req.write_req.gattc_params.handle   = cccd_handle;
        p_msg->req.write_req.gattc_params.len      = WRITE_MESSAGE_LENGTH;
        p_msg->req.write_req.gattc_params.p_value  = p_msg->req.write_req.gattc_value;
        p_msg->req.write_req.gattc_params.offset   = 0;
        p_msg->req.write_req.gattc_params.write_op = BLE_GATT_OP_WRITE_REQ;
        p_msg->req.write_req.gattc_value[0]        = LSB_16(cccd_val);
        p_msg->req.write_req.gattc_value[1]        = MSB_16(cccd_val);
        p_msg->conn_handle                         = conn_handle;
        p_msg->type                                = WRITE_REQ;

        tx_buffer_process();
        return NRF_SUCCESS;
}


uint32_t ble_nus_c_tx_notif_enable(ble_nus_c_t * p_ble_nus_c)
{
        VERIFY_PARAM_NOT_NULL(p_ble_nus_c);

        if ( (p_ble_nus_c->conn_handle == BLE_CONN_HANDLE_INVALID)
             ||(p_ble_nus_c->handles.nus_tx_cccd_handle == BLE_GATT_HANDLE_INVALID)
             )
        {
                return NRF_ERROR_INVALID_STATE;
        }
        return cccd_configure(p_ble_nus_c->conn_handle,p_ble_nus_c->handles.nus_tx_cccd_handle, true);
}


uint32_t ble_nus_c_string_send(ble_nus_c_t * p_ble_nus_c, uint8_t * p_string, uint16_t length)
{
        VERIFY_PARAM_NOT_NULL(p_ble_nus_c);

        if (length > BLE_NUS_MAX_DATA_LEN)
        {
                NRF_LOG_WARNING(""Content too long."");
                return NRF_ERROR_INVALID_PARAM;
        }
        if (p_ble_nus_c->conn_handle == BLE_CONN_HANDLE_INVALID)
        {
                NRF_LOG_WARNING(""Connection handle invalid."");
                return NRF_ERROR_INVALID_STATE;
        }

        ble_gattc_write_params_t const write_params =
        {
                .write_op = BLE_GATT_OP_WRITE_CMD,
                .flags    = BLE_GATT_EXEC_WRITE_FLAG_PREPARED_WRITE,
                .handle   = p_ble_nus_c->handles.nus_rx_handle,
                .offset   = 0,
                .len      = length,
                .p_value  = p_string
        };

        return sd_ble_gattc_write(p_ble_nus_c->conn_handle, &write_params);
}


uint32_t ble_nus_c_handles_assign(ble_nus_c_t               * p_ble_nus,
                                  uint16_t conn_handle,
                                  ble_nus_c_handles_t const * p_peer_handles)
{
        VERIFY_PARAM_NOT_NULL(p_ble_nus);

        p_ble_nus->conn_handle = conn_handle;
        if (p_peer_handles != NULL)
        {
                p_ble_nus->handles.nus_tx_cccd_handle = p_peer_handles->nus_tx_cccd_handle;
                p_ble_nus->handles.nus_tx_handle      = p_peer_handles->nus_tx_handle;
                p_ble_nus->handles.nus_rx_handle      = p_peer_handles->nus_rx_handle;
        }
        return NRF_SUCCESS;
}
#endif 
",17,536,4260
"#include ""sdk_common.h""
#if NRF_MODULE_ENABLED(BLE_LBS)
#include ""ble_lbs_extended.h""
#include ""ble_srv_common.h""



static void on_write(ble_lbs_t * p_lbs, ble_evt_t const * p_ble_evt)
{
    ble_gatts_evt_write_t const * p_evt_write = &p_ble_evt->evt.gatts_evt.params.write;

    if ((p_evt_write->handle == p_lbs->led_char_handles.value_handle)
        && (p_evt_write->len == 1)
        && (p_lbs->led_write_handler != NULL))
    {
        p_lbs->led_write_handler(p_ble_evt->evt.gap_evt.conn_handle, p_lbs, p_evt_write->data[0]);
    }
    else if ((p_evt_write->handle == p_lbs->led_col_char_handles.value_handle)
        && (p_evt_write->len == 4)
        && (p_lbs->led_col_write_handler != NULL))
    {
        uint32_t color = p_evt_write->data[0] << 16 | p_evt_write->data[1] << 8 | p_evt_write->data[2] << 0;
        p_lbs->led_col_write_handler(p_ble_evt->evt.gap_evt.conn_handle, p_lbs, color);
    }
}


void ble_lbs_on_ble_evt(ble_evt_t const * p_ble_evt, void * p_context)
{
    ble_lbs_t * p_lbs = (ble_lbs_t *)p_context;

    switch (p_ble_evt->header.evt_id)
    {
        case BLE_GATTS_EVT_WRITE:
            on_write(p_lbs, p_ble_evt);
            break;

        default:
            
            break;
    }
}


uint32_t ble_lbs_init(ble_lbs_t * p_lbs, const ble_lbs_init_t * p_lbs_init)
{
    uint32_t              err_code;
    ble_uuid_t            ble_uuid;
    ble_add_char_params_t add_char_params;

    
    p_lbs->led_write_handler = p_lbs_init->led_write_handler;
    p_lbs->led_col_write_handler = p_lbs_init->led_col_write_handler;

    
    ble_uuid128_t base_uuid = {LBS_UUID_BASE};
    err_code = sd_ble_uuid_vs_add(&base_uuid, &p_lbs->uuid_type);
    VERIFY_SUCCESS(err_code);

    ble_uuid.type = p_lbs->uuid_type;
    ble_uuid.uuid = LBS_UUID_SERVICE;

    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_lbs->service_handle);
    VERIFY_SUCCESS(err_code);

    
    memset(&add_char_params, 0, sizeof(add_char_params));
    add_char_params.uuid              = LBS_UUID_BUTTON_CHAR;
    add_char_params.uuid_type         = p_lbs->uuid_type;
    add_char_params.init_len          = sizeof(uint8_t);
    add_char_params.max_len           = sizeof(uint8_t);
    add_char_params.char_props.read   = 1;
    add_char_params.char_props.notify = 1;

    add_char_params.read_access       = SEC_OPEN;
    add_char_params.cccd_write_access = SEC_OPEN;

    err_code = characteristic_add(p_lbs->service_handle,
                                  &add_char_params,
                                  &p_lbs->button_char_handles);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    }

    
    memset(&add_char_params, 0, sizeof(add_char_params));
    add_char_params.uuid             = LBS_UUID_LED_CHAR;
    add_char_params.uuid_type        = p_lbs->uuid_type;
    add_char_params.init_len         = sizeof(uint8_t);
    add_char_params.max_len          = sizeof(uint8_t);
    add_char_params.char_props.read  = 1;
    add_char_params.char_props.write = 1;

    add_char_params.read_access  = SEC_OPEN;
    add_char_params.write_access = SEC_OPEN;

    err_code = characteristic_add(p_lbs->service_handle, &add_char_params, &p_lbs->led_char_handles);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    }

    
    memset(&add_char_params, 0, sizeof(add_char_params));
    add_char_params.uuid             = LBS_UUID_LED_COL_CHAR;
    add_char_params.uuid_type        = p_lbs->uuid_type;
    add_char_params.init_len         = sizeof(uint32_t);
    add_char_params.max_len          = sizeof(uint32_t);
    add_char_params.char_props.read  = 1;
    add_char_params.char_props.write = 1;

    add_char_params.read_access  = SEC_OPEN;
    add_char_params.write_access = SEC_OPEN;

    err_code = characteristic_add(p_lbs->service_handle, &add_char_params, &p_lbs->led_col_char_handles);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    }
}


uint32_t ble_lbs_on_button_change(uint16_t conn_handle, ble_lbs_t * p_lbs, uint8_t button_state)
{
    ble_gatts_hvx_params_t params;
    uint16_t len = sizeof(button_state);

    memset(&params, 0, sizeof(params));
    params.type   = BLE_GATT_HVX_NOTIFICATION;
    params.handle = p_lbs->button_char_handles.value_handle;
    params.p_data = &button_state;
    params.p_len  = &len;

    return sd_ble_gatts_hvx(conn_handle, &params);
}
#endif 
",17,537,1846
"#include ""sdk_config.h""

#if NRF_FSTORAGE_ENABLED

#include ""nrf_fstorage.h""


#include ""sdk_errors.h""
#include ""sdk_macros.h""
#include ""nrf_section.h""

#define NRF_LOG_MODULE_NAME nrf_fstorage
#include ""nrf_log.h""
NRF_LOG_MODULE_REGISTER();



NRF_SECTION_DEF(fs_data, nrf_fstorage_t);



#define NRF_FSTORAGE_PARAM_CHECK(_cond, _err)                                                       \
    NRF_PARAM_CHECK(NRF_FSTORAGE, _cond, _err, NRF_LOG_ERROR)


static bool addr_is_aligned32(uint32_t addr);
static bool addr_is_page_aligned(nrf_fstorage_t const * p_fs, uint32_t addr);
static bool addr_is_within_bounds(nrf_fstorage_t const * p_fs, uint32_t addr, uint32_t len);


ret_code_t nrf_fstorage_init(nrf_fstorage_t     * p_fs,
                             nrf_fstorage_api_t * p_api,
                             void               * p_param)
{
    NRF_FSTORAGE_PARAM_CHECK(p_fs,  NRF_ERROR_NULL);
    NRF_FSTORAGE_PARAM_CHECK(p_api, NRF_ERROR_NULL);

    p_fs->p_api = p_api;

    return (p_fs->p_api)->init(p_fs, p_param);
}


ret_code_t nrf_fstorage_uninit(nrf_fstorage_t * p_fs,
                               void           * p_param)
{
    ret_code_t rc;

    NRF_FSTORAGE_PARAM_CHECK(p_fs,        NRF_ERROR_NULL);
    NRF_FSTORAGE_PARAM_CHECK(p_fs->p_api, NRF_ERROR_INVALID_STATE);

    rc = (p_fs->p_api)->uninit(p_fs, p_param);

    
    p_fs->p_api        = NULL;
    p_fs->p_flash_info = NULL;

    return rc;
}


ret_code_t nrf_fstorage_read(nrf_fstorage_t const * p_fs,
                             uint32_t               src,
                             void                 * p_dest,
                             uint32_t               len)
{
    NRF_FSTORAGE_PARAM_CHECK(p_fs,        NRF_ERROR_NULL);
    NRF_FSTORAGE_PARAM_CHECK(p_dest,      NRF_ERROR_NULL);
    NRF_FSTORAGE_PARAM_CHECK(p_fs->p_api, NRF_ERROR_INVALID_STATE);
    NRF_FSTORAGE_PARAM_CHECK(len,         NRF_ERROR_INVALID_LENGTH);

    
    NRF_FSTORAGE_PARAM_CHECK(addr_is_aligned32(src),                NRF_ERROR_INVALID_ADDR);
    NRF_FSTORAGE_PARAM_CHECK(addr_is_within_bounds(p_fs, src, len), NRF_ERROR_INVALID_ADDR);

    return (p_fs->p_api)->read(p_fs, src, p_dest, len);
}


ret_code_t nrf_fstorage_write(nrf_fstorage_t const * p_fs,
                              uint32_t               dest,
                              void           const * p_src,
                              uint32_t               len,
                              void                 * p_context)
{
    NRF_FSTORAGE_PARAM_CHECK(p_fs,        NRF_ERROR_NULL);
    NRF_FSTORAGE_PARAM_CHECK(p_src,       NRF_ERROR_NULL);
    NRF_FSTORAGE_PARAM_CHECK(p_fs->p_api, NRF_ERROR_INVALID_STATE);
    NRF_FSTORAGE_PARAM_CHECK(len,         NRF_ERROR_INVALID_LENGTH);

    
    NRF_FSTORAGE_PARAM_CHECK(!(len % p_fs->p_flash_info->program_unit), NRF_ERROR_INVALID_LENGTH);

    
    NRF_FSTORAGE_PARAM_CHECK(addr_is_aligned32(dest),                NRF_ERROR_INVALID_ADDR);
    NRF_FSTORAGE_PARAM_CHECK(addr_is_aligned32((uint32_t)p_src),     NRF_ERROR_INVALID_ADDR);
    NRF_FSTORAGE_PARAM_CHECK(addr_is_within_bounds(p_fs, dest, len), NRF_ERROR_INVALID_ADDR);

    return (p_fs->p_api)->write(p_fs, dest, p_src, len, p_context);
}


ret_code_t nrf_fstorage_erase(nrf_fstorage_t const * p_fs,
                              uint32_t               page_addr,
                              uint32_t               len,
                              void                 * p_context)
{
    NRF_FSTORAGE_PARAM_CHECK(p_fs,        NRF_ERROR_NULL);
    NRF_FSTORAGE_PARAM_CHECK(p_fs->p_api, NRF_ERROR_INVALID_STATE);
    NRF_FSTORAGE_PARAM_CHECK(len,         NRF_ERROR_INVALID_LENGTH);

    
    NRF_FSTORAGE_PARAM_CHECK(addr_is_page_aligned(p_fs, page_addr), NRF_ERROR_INVALID_ADDR);

    NRF_FSTORAGE_PARAM_CHECK(
        addr_is_within_bounds(p_fs, page_addr, (len * p_fs->p_flash_info->erase_unit)),
        NRF_ERROR_INVALID_ADDR
    );

    return (p_fs->p_api)->erase(p_fs, page_addr, len, p_context);
}


uint8_t const * nrf_fstorage_rmap(nrf_fstorage_t const * p_fs, uint32_t addr)
{
    if ((p_fs == NULL) || (p_fs->p_api == NULL))
    {
        return NULL;
    }

    return (p_fs->p_api)->rmap(p_fs, addr);
}


uint8_t * nrf_fstorage_wmap(nrf_fstorage_t const * p_fs, uint32_t addr)
{
    if ((p_fs == NULL) || (p_fs->p_api == NULL))
    {
        return NULL;
    }

    return (p_fs->p_api)->wmap(p_fs, addr);
}


bool nrf_fstorage_is_busy(nrf_fstorage_t const * p_fs)
{
    
    if ((p_fs == NULL) || (p_fs->p_api == NULL))
    {
        for (uint32_t i = 0; i < NRF_FSTORAGE_INSTANCE_CNT; i++)
        {
            p_fs = NRF_FSTORAGE_INSTANCE_GET(i);    
            if (p_fs->p_api != NULL)
            {
                
                if (p_fs->p_api->is_busy(p_fs))
                {
                    return true;
                }
            }
        }

        return false;
    }

    return p_fs->p_api->is_busy(p_fs);
}


static bool addr_is_within_bounds(nrf_fstorage_t const * p_fs,
                                  uint32_t               addr,
                                  uint32_t               len)
{
    return (   (addr           >= p_fs->start_addr)
            && (addr + len - 1 <= p_fs->end_addr));
}


static bool addr_is_aligned32(uint32_t addr)
{
    return !(addr & 0x03);
}


static bool addr_is_page_aligned(nrf_fstorage_t const * p_fs,
                                 uint32_t               addr)
{
    return (addr & (p_fs->p_flash_info->erase_unit - 1)) == 0;
}


#endif 
",17,538,2228
"#include ""nrf_assert.h""
#include ""nrf_gpio.h""
#include ""sdk_config.h""
#include ""sdk_errors.h""
#include ""drv_ws2812.h""
#include ""drv_ws2812_gfx_glue_layer.h""


ret_code_t drv_ws2812_gfx_glue_init(void)
{
    return drv_ws2812_init();
}


void drv_ws2812_gfx_glue_uninit(void)
{
    
}


void drv_ws2812_gfx_glue_pixel_draw(uint16_t x, uint16_t y, uint32_t color)
{
    drv_ws2812_pixel_draw(x, y, color);
}


void drv_ws2812_gfx_glue_rect_draw(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint32_t color)
{
    drv_ws2812_rectangle_draw(x, y, width, height, color);
}


void drv_ws2812_gfx_glue_display(void)
{
    drv_ws2812_display();
}


void drv_ws2812_gfx_glue_rotation_set(nrf_lcd_rotation_t rotation)
{
    
}


void drv_ws2812_gfx_glue_display_invert(bool invert)
{
    
}


",17,539,432
"#include ""sdk_common.h""
#if NRF_MODULE_ENABLED(BLE_NUS)
#include ""ble.h""
#include ""ble_nus.h""
#include ""ble_srv_common.h""

#define NRF_LOG_MODULE_NAME ble_nus
#if BLE_NUS_CONFIG_LOG_ENABLED
#define NRF_LOG_LEVEL       BLE_NUS_CONFIG_LOG_LEVEL
#define NRF_LOG_INFO_COLOR  BLE_NUS_CONFIG_INFO_COLOR
#define NRF_LOG_DEBUG_COLOR BLE_NUS_CONFIG_DEBUG_COLOR
#else 
#define NRF_LOG_LEVEL       0
#endif 
#include ""nrf_log.h""
NRF_LOG_MODULE_REGISTER();

#define BLE_UUID_NUS_TX_CHARACTERISTIC 0x0003               
#define BLE_UUID_NUS_RX_CHARACTERISTIC 0x0002               

#define BLE_NUS_MAX_RX_CHAR_LEN        BLE_NUS_MAX_DATA_LEN 
#define BLE_NUS_MAX_TX_CHAR_LEN        BLE_NUS_MAX_DATA_LEN 

#define NUS_BASE_UUID                  {{0x9E, 0xCA, 0xDC, 0x24, 0x0E, 0xE5, 0xA9, 0xE0, 0x93, 0xF3, 0xA3, 0xB5, 0x00, 0x00, 0x40, 0x6E}} 



static void on_connect(ble_nus_t * p_nus, ble_evt_t const * p_ble_evt)
{
    ret_code_t                 err_code;
    ble_nus_evt_t              evt;
    ble_gatts_value_t          gatts_val;
    uint8_t                    cccd_value[2];
    ble_nus_client_context_t * p_client = NULL;

    err_code = blcm_link_ctx_get(p_nus->p_link_ctx_storage,
                                 p_ble_evt->evt.gap_evt.conn_handle,
                                 (void *) &p_client);
    if (err_code != NRF_SUCCESS)
    {
        NRF_LOG_ERROR(""Link context for 0x%02X connection handle could not be fetched."",
                      p_ble_evt->evt.gap_evt.conn_handle);
    }

    
    memset(&gatts_val, 0, sizeof(ble_gatts_value_t));
    gatts_val.p_value = cccd_value;
    gatts_val.len     = sizeof(cccd_value);
    gatts_val.offset  = 0;

    err_code = sd_ble_gatts_value_get(p_ble_evt->evt.gap_evt.conn_handle,
                                      p_nus->rx_handles.cccd_handle,
                                      &gatts_val);

    if ((err_code == NRF_SUCCESS)     &&
        (p_nus->data_handler != NULL) &&
        ble_srv_is_notification_enabled(gatts_val.p_value))
    {
        if (p_client != NULL)
        {
            p_client->is_notification_enabled = true;
        }

        memset(&evt, 0, sizeof(ble_nus_evt_t));
        evt.type        = BLE_NUS_EVT_COMM_STARTED;
        evt.p_nus       = p_nus;
        evt.conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
        evt.p_link_ctx  = p_client;

        p_nus->data_handler(&evt);
    }
}



static void on_write(ble_nus_t * p_nus, ble_evt_t const * p_ble_evt)
{
    ret_code_t                    err_code;
    ble_nus_evt_t                 evt;
    ble_nus_client_context_t    * p_client;
    ble_gatts_evt_write_t const * p_evt_write = &p_ble_evt->evt.gatts_evt.params.write;

    err_code = blcm_link_ctx_get(p_nus->p_link_ctx_storage,
                                 p_ble_evt->evt.gatts_evt.conn_handle,
                                 (void *) &p_client);
    if (err_code != NRF_SUCCESS)
    {
        NRF_LOG_ERROR(""Link context for 0x%02X connection handle could not be fetched."",
                      p_ble_evt->evt.gatts_evt.conn_handle);
    }

    memset(&evt, 0, sizeof(ble_nus_evt_t));
    evt.p_nus       = p_nus;
    evt.conn_handle = p_ble_evt->evt.gatts_evt.conn_handle;
    evt.p_link_ctx  = p_client;

    if ((p_evt_write->handle == p_nus->tx_handles.cccd_handle) &&
        (p_evt_write->len == 2))
    {
        if (p_client != NULL)
        {
            if (ble_srv_is_notification_enabled(p_evt_write->data))
            {
                p_client->is_notification_enabled = true;
                evt.type                          = BLE_NUS_EVT_COMM_STARTED;
            }
            else
            {
                p_client->is_notification_enabled = false;
                evt.type                          = BLE_NUS_EVT_COMM_STOPPED;
            }

            if (p_nus->data_handler != NULL)
            {
                p_nus->data_handler(&evt);
            }

        }
    }
    else if ((p_evt_write->handle == p_nus->rx_handles.value_handle) &&
             (p_nus->data_handler != NULL))
    {
        evt.type                  = BLE_NUS_EVT_RX_DATA;
        evt.params.rx_data.p_data = p_evt_write->data;
        evt.params.rx_data.length = p_evt_write->len;

        p_nus->data_handler(&evt);
    }
    else
    {
        
    }
}



static void on_hvx_tx_complete(ble_nus_t * p_nus, ble_evt_t const * p_ble_evt)
{
    ret_code_t                 err_code;
    ble_nus_evt_t              evt;
    ble_nus_client_context_t * p_client;

    err_code = blcm_link_ctx_get(p_nus->p_link_ctx_storage,
                                 p_ble_evt->evt.gatts_evt.conn_handle,
                                 (void *) &p_client);
    if (err_code != NRF_SUCCESS)
    {
        NRF_LOG_ERROR(""Link context for 0x%02X connection handle could not be fetched."",
                      p_ble_evt->evt.gatts_evt.conn_handle);
        return;
    }

    if (p_client->is_notification_enabled)
    {
        memset(&evt, 0, sizeof(ble_nus_evt_t));
        evt.type        = BLE_NUS_EVT_TX_RDY;
        evt.p_nus       = p_nus;
        evt.conn_handle = p_ble_evt->evt.gatts_evt.conn_handle;
        evt.p_link_ctx  = p_client;

        p_nus->data_handler(&evt);
    }
}


void ble_nus_on_ble_evt(ble_evt_t const * p_ble_evt, void * p_context)
{
    if ((p_context == NULL) || (p_ble_evt == NULL))
    {
        return;
    }

    ble_nus_t * p_nus = (ble_nus_t *)p_context;

    switch (p_ble_evt->header.evt_id)
    {
        case BLE_GAP_EVT_CONNECTED:
            on_connect(p_nus, p_ble_evt);
            break;

        case BLE_GATTS_EVT_WRITE:
            on_write(p_nus, p_ble_evt);
            break;

        case BLE_GATTS_EVT_HVN_TX_COMPLETE:
            on_hvx_tx_complete(p_nus, p_ble_evt);
            break;

        default:
            
            break;
    }
}


uint32_t ble_nus_init(ble_nus_t * p_nus, ble_nus_init_t const * p_nus_init)
{
    ret_code_t            err_code;
    ble_uuid_t            ble_uuid;
    ble_uuid128_t         nus_base_uuid = NUS_BASE_UUID;
    ble_add_char_params_t add_char_params;

    VERIFY_PARAM_NOT_NULL(p_nus);
    VERIFY_PARAM_NOT_NULL(p_nus_init);

    
    p_nus->data_handler = p_nus_init->data_handler;

    
    
    err_code = sd_ble_uuid_vs_add(&nus_base_uuid, &p_nus->uuid_type);
    VERIFY_SUCCESS(err_code);

    ble_uuid.type = p_nus->uuid_type;
    ble_uuid.uuid = BLE_UUID_NUS_SERVICE;

    
    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY,
                                        &ble_uuid,
                                        &p_nus->service_handle);
    
    VERIFY_SUCCESS(err_code);

    
    memset(&add_char_params, 0, sizeof(add_char_params));
    add_char_params.uuid                     = BLE_UUID_NUS_RX_CHARACTERISTIC;
    add_char_params.uuid_type                = p_nus->uuid_type;
    add_char_params.max_len                  = BLE_NUS_MAX_RX_CHAR_LEN;
    add_char_params.init_len                 = sizeof(uint8_t);
    add_char_params.is_var_len               = true;
    add_char_params.char_props.write         = 1;
    add_char_params.char_props.write_wo_resp = 1;

    add_char_params.read_access  = SEC_OPEN;
    add_char_params.write_access = SEC_OPEN;

    err_code = characteristic_add(p_nus->service_handle, &add_char_params, &p_nus->rx_handles);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    }

    
    
    memset(&add_char_params, 0, sizeof(add_char_params));
    add_char_params.uuid              = BLE_UUID_NUS_TX_CHARACTERISTIC;
    add_char_params.uuid_type         = p_nus->uuid_type;
    add_char_params.max_len           = BLE_NUS_MAX_TX_CHAR_LEN;
    add_char_params.init_len          = sizeof(uint8_t);
    add_char_params.is_var_len        = true;
    add_char_params.char_props.notify = 1;

    add_char_params.read_access       = SEC_OPEN;
    add_char_params.write_access      = SEC_OPEN;
    add_char_params.cccd_write_access = SEC_OPEN;

    return characteristic_add(p_nus->service_handle, &add_char_params, &p_nus->tx_handles);
    
}


uint32_t ble_nus_data_send(ble_nus_t * p_nus,
                           uint8_t   * p_data,
                           uint16_t  * p_length,
                           uint16_t    conn_handle)
{
    ret_code_t                 err_code;
    ble_gatts_hvx_params_t     hvx_params;
    ble_nus_client_context_t * p_client;

    VERIFY_PARAM_NOT_NULL(p_nus);

    err_code = blcm_link_ctx_get(p_nus->p_link_ctx_storage, conn_handle, (void *) &p_client);
    VERIFY_SUCCESS(err_code);

    if ((conn_handle == BLE_CONN_HANDLE_INVALID) || (p_client == NULL))
    {
        return NRF_ERROR_NOT_FOUND;
    }

    if (!p_client->is_notification_enabled)
    {
        return NRF_ERROR_INVALID_STATE;
    }

    if (*p_length > BLE_NUS_MAX_DATA_LEN)
    {
        return NRF_ERROR_INVALID_PARAM;
    }

    memset(&hvx_params, 0, sizeof(hvx_params));

    hvx_params.handle = p_nus->tx_handles.value_handle;
    hvx_params.p_data = p_data;
    hvx_params.p_len  = p_length;
    hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;

    return sd_ble_gatts_hvx(conn_handle, &hvx_params);
}


#endif 
",17,540,3767
"#include ""drv_ws2812.h""

#define WS2812_T1H                  14 | 0x8000
#define WS2812_T0H                  6 | 0x8000

#if defined(NEOPIXEL_RING)
#define LED_MATRIX_TOTAL_BYTE_WIDTH LED_MATRIX_WIDTH * LED_MATRIX_HEIGHT * 4
#define LED_MATRIX_TOTAL_BIT_WIDTH  LED_MATRIX_TOTAL_BYTE_WIDTH * 8
#else
#define LED_MATRIX_TOTAL_BYTE_WIDTH LED_MATRIX_WIDTH * LED_MATRIX_HEIGHT * 3
#define LED_MATRIX_TOTAL_BIT_WIDTH  LED_MATRIX_TOTAL_BYTE_WIDTH * 8
#endif


static rgb_color_t led_matrix_buffer[LED_MATRIX_WIDTH][LED_MATRIX_HEIGHT];

static nrfx_pwm_t m_pwm0 = NRFX_PWM_INSTANCE(0);
static nrf_pwm_values_individual_t pwm_duty_cycle_values[LED_MATRIX_TOTAL_BIT_WIDTH];
volatile bool pwm_sequencue_finished = true;

void pwm_handler(nrfx_pwm_evt_type_t event_type)
{
    switch(event_type)
    {
    case NRFX_PWM_EVT_FINISHED:
        pwm_sequencue_finished = true;
        break;
    default:
        break;
    }
}

static nrf_pwm_sequence_t pwm_sequence =
{
    .values.p_individual = pwm_duty_cycle_values,
    .length          = (sizeof(pwm_duty_cycle_values) / sizeof(uint16_t)),
    .repeats         = 0,
    .end_delay       = 0
};

static uint32_t pwm_init(void)
{
    nrfx_pwm_config_t pwm_config = NRFX_PWM_DEFAULT_CONFIG;
    pwm_config.output_pins[0] = NRFX_PWM_PIN_NOT_USED; 
    pwm_config.output_pins[1] = WS2812_PIN; 
    pwm_config.output_pins[2] = NRFX_PWM_PIN_NOT_USED;
    pwm_config.output_pins[3] = NRFX_PWM_PIN_NOT_USED;
    pwm_config.load_mode    = NRF_PWM_LOAD_INDIVIDUAL;
    
    pwm_config.top_value    = 20; 
    pwm_config.base_clock   = NRF_PWM_CLK_16MHz;
    
    return nrfx_pwm_init(&m_pwm0, &pwm_config, pwm_handler);
}



static void convert_rgb_to_pwm_sequence(void)
{
    uint8_t * ptr = (uint8_t *)led_matrix_buffer;
    uint32_t i = 0;
    for(int led = 0; led < LED_MATRIX_TOTAL_BYTE_WIDTH; led++)
    {
        for(int bit = 7; bit >= 0; bit--)
        {
            uint8_t b = (*ptr >> bit) & 0x01;
            uint16_t pwm = 0;
            if(b == 1)
            {
                pwm = WS2812_T1H;
            }
            else
            {
                pwm = WS2812_T0H;
            }
            pwm_duty_cycle_values[i++].channel_1 = pwm;
        }
        ptr++;
    }
}

uint32_t drv_ws2812_init(void)
{   
    volatile uint32_t size = sizeof(led_matrix_buffer);
    memset(led_matrix_buffer, 0x00, sizeof(led_matrix_buffer));   
    return pwm_init();
}

uint32_t drv_ws2812_display(void)
{
    if(!pwm_sequencue_finished) 
    {
        return NRF_ERROR_BUSY;
    }
    convert_rgb_to_pwm_sequence();
    pwm_sequencue_finished = false;
    uint32_t err_code = nrfx_pwm_simple_playback(&m_pwm0, &pwm_sequence, 1, NRFX_PWM_FLAG_STOP);
    return err_code;
}

uint32_t drv_ws2812_pixel_draw(uint16_t x, uint16_t y, uint32_t color)
{
    uint32_t err_code = NRF_SUCCESS;
    if(x > LED_MATRIX_WIDTH - 1)
    {
        err_code = NRF_ERROR_INVALID_PARAM;
    }
    if(y > LED_MATRIX_HEIGHT - 1)
    {
    err_code = NRF_ERROR_INVALID_PARAM;
    }
 
#if defined(NEOPIXEL_RING)
    led_matrix_buffer[x][y].w = (color & 0xFF000000) >> 24;
#endif
    led_matrix_buffer[x][y].r = (color & 0x00FF0000) >> 16;
    led_matrix_buffer[x][y].g = (color & 0x0000FF00) >> 8;
    led_matrix_buffer[x][y].b = (color & 0x000000FF);
    
    return err_code;
}

uint32_t drv_ws2812_rectangle_draw(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint32_t color)
{
    uint32_t err_code;
    for(int h = y; h < (y + height); h++)
    {
        for(int w = x; w < (x + width); w++)
        {
            err_code = drv_ws2812_pixel_draw(w, h, color);
            if(err_code) return err_code;
        }
    }
    return NRF_SUCCESS;
}

",17,541,1753
"#include ""nordic_common.h""
#include ""app_error.h""
#include ""app_util.h""
#include ""bsp_btn_ble.h""
#include ""ble.h""
#include ""ble_gap.h""
#include ""ble_hci.h""
#include ""nrf_sdh.h""
#include ""nrf_sdh_ble.h""
#include ""nrf_sdh_soc.h""

#include ""nrf_ble_gatt.h""
#include ""app_scheduler.h""

#include ""nrf_log_ctrl.h""
#include ""nrf_log.h""
#include ""nrf_log_default_backends.h""

#define BLE_GAP_QOS_CHANNEL_SURVERY_INTERVAL      0
#define NUM_REPORTS_BEFORE_AVERAGE_PRINTOUT       100

#define ADVERTISING_CHANNEL_37      37
#define ADVERTISING_CHANNEL_38      38
#define ADVERTISING_CHANNEL_39      39

typedef struct
{
        uint8_t index;
        bool channel_enable;
        float ch_energy;
} channel_energy_t;

static uint32_t m_num_channel_survey_reports_received;
static channel_energy_t ch_config_energy[BLE_GAP_CHANNEL_COUNT];
static channel_energy_t m_average_ch_energy[BLE_GAP_CHANNEL_COUNT];
static bool update_channel_survey_status = false;

bool get_channel_map_status(void)
{
        return update_channel_survey_status;
}

uint32_t connection_channel_survey_start(void)
{
        ret_code_t err_code = sd_ble_gap_qos_channel_survey_start(BLE_GAP_QOS_CHANNEL_SURVERY_INTERVAL);
        APP_ERROR_CHECK(err_code);
        return err_code;
}

uint32_t connection_channel_survey_stop(void)
{
        ret_code_t err_code = sd_ble_gap_qos_channel_survey_stop();
        APP_ERROR_CHECK(err_code);
        return err_code;
}

static void sort_channel_survey(void)
{
        int n, c, d;
        float t;
        uint8_t index = 0;
        n = BLE_GAP_CHANNEL_COUNT;
        for (c = 1; c <= n - 1; c++)
        {
                d = c;
                while ( d > 0 && m_average_ch_energy[d-1].ch_energy > m_average_ch_energy[d].ch_energy)
                {
                        t          = m_average_ch_energy[d].ch_energy;
                        index      = m_average_ch_energy[d].index;
                        m_average_ch_energy[d].ch_energy   = m_average_ch_energy[d-1].ch_energy;
                        m_average_ch_energy[d].index       = m_average_ch_energy[d-1].index;
                        m_average_ch_energy[d-1].ch_energy = t;
                        m_average_ch_energy[d-1].index     = index;
                        d--;
                }
        }
        return;
}

void update_and_sort_channel_survey_handler(void * p_event_data, uint16_t size)
{
        NRF_LOG_INFO(""Channel energy report:\n--------------\n"");
        for (uint8_t i = 0; i < BLE_GAP_CHANNEL_COUNT; i++)
        {
                int8_t channel_energy = m_average_ch_energy[i].ch_energy;
                m_average_ch_energy[i].index = i;
        }
        NRF_LOG_DEBUG(""00-04: %4d %4d %4d %4d %4d"", \
                      (int8_t)m_average_ch_energy[0].ch_energy, \
                      (int8_t)m_average_ch_energy[1].ch_energy, \
                      (int8_t)m_average_ch_energy[2].ch_energy, \
                      (int8_t)m_average_ch_energy[3].ch_energy, \
                      (int8_t)m_average_ch_energy[4].ch_energy  \
                      );
        NRF_LOG_DEBUG(""05-09: %4d %4d %4d %4d %4d"", \
                      (int8_t)m_average_ch_energy[5].ch_energy, \
                      (int8_t)m_average_ch_energy[6].ch_energy, \
                      (int8_t)m_average_ch_energy[7].ch_energy, \
                      (int8_t)m_average_ch_energy[8].ch_energy, \
                      (int8_t)m_average_ch_energy[9].ch_energy  \
                      );
        NRF_LOG_DEBUG(""10-14: %4d %4d %4d %4d %4d"", \
                      (int8_t)m_average_ch_energy[10].ch_energy, \
                      (int8_t)m_average_ch_energy[11].ch_energy, \
                      (int8_t)m_average_ch_energy[12].ch_energy, \
                      (int8_t)m_average_ch_energy[13].ch_energy, \
                      (int8_t)m_average_ch_energy[14].ch_energy  \
                      );
        NRF_LOG_DEBUG(""15-19: %4d %4d %4d %4d %4d"", \
                      (int8_t)m_average_ch_energy[15].ch_energy, \
                      (int8_t)m_average_ch_energy[16].ch_energy, \
                      (int8_t)m_average_ch_energy[17].ch_energy, \
                      (int8_t)m_average_ch_energy[18].ch_energy, \
                      (int8_t)m_average_ch_energy[19].ch_energy  \
                      );
        NRF_LOG_DEBUG(""20-24: %4d %4d %4d %4d %4d"", \
                      (int8_t)m_average_ch_energy[20].ch_energy, \
                      (int8_t)m_average_ch_energy[21].ch_energy, \
                      (int8_t)m_average_ch_energy[22].ch_energy, \
                      (int8_t)m_average_ch_energy[23].ch_energy, \
                      (int8_t)m_average_ch_energy[24].ch_energy  \
                      );
        NRF_LOG_DEBUG(""25-29: %4d %4d %4d %4d %4d"", \
                      (int8_t)m_average_ch_energy[25].ch_energy, \
                      (int8_t)m_average_ch_energy[26].ch_energy, \
                      (int8_t)m_average_ch_energy[27].ch_energy, \
                      (int8_t)m_average_ch_energy[28].ch_energy, \
                      (int8_t)m_average_ch_energy[29].ch_energy  \
                      );

        NRF_LOG_DEBUG(""30-34: %4d %4d %4d %4d %4d"", \
                      (int8_t)m_average_ch_energy[30].ch_energy, \
                      (int8_t)m_average_ch_energy[31].ch_energy, \
                      (int8_t)m_average_ch_energy[32].ch_energy, \
                      (int8_t)m_average_ch_energy[33].ch_energy, \
                      (int8_t)m_average_ch_energy[34].ch_energy  \
                      );
        NRF_LOG_DEBUG(""35-39: %4d %4d %4d %4d %4d"", \
                      (int8_t)m_average_ch_energy[35].ch_energy, \
                      (int8_t)m_average_ch_energy[36].ch_energy, \
                      (int8_t)m_average_ch_energy[37].ch_energy, \
                      (int8_t)m_average_ch_energy[38].ch_energy, \
                      (int8_t)m_average_ch_energy[39].ch_energy  \
                      );

        sort_channel_survey();

        NRF_LOG_DEBUG(""Top Best Clean Channel Index:"");

        NRF_LOG_DEBUG(""%02d %02d %02d %02d %02d"",  \
                      m_average_ch_energy[0].index,  \
                      m_average_ch_energy[1].index,  \
                      m_average_ch_energy[2].index,  \
                      m_average_ch_energy[3].index,  \
                      m_average_ch_energy[4].index   \
                      );

        NRF_LOG_DEBUG(""%02d %02d %02d %02d %02d"",  \
                      m_average_ch_energy[5].index,  \
                      m_average_ch_energy[6].index,  \
                      m_average_ch_energy[7].index,  \
                      m_average_ch_energy[8].index,  \
                      m_average_ch_energy[9].index   \
                      );

        NRF_LOG_DEBUG(""%02d %02d %02d %02d %02d"",  \
                      m_average_ch_energy[10].index,  \
                      m_average_ch_energy[11].index,  \
                      m_average_ch_energy[12].index,  \
                      m_average_ch_energy[13].index,  \
                      m_average_ch_energy[14].index   \
                      );

        NRF_LOG_DEBUG(""%02d %02d %02d %02d %02d"",  \
                      m_average_ch_energy[15].index,  \
                      m_average_ch_energy[16].index,  \
                      m_average_ch_energy[17].index,  \
                      m_average_ch_energy[18].index,  \
                      m_average_ch_energy[19].index   \
                      );
        NRF_LOG_DEBUG(""%02d %02d %02d %02d %02d"",  \
                      m_average_ch_energy[20].index,  \
                      m_average_ch_energy[21].index,  \
                      m_average_ch_energy[22].index,  \
                      m_average_ch_energy[23].index,  \
                      m_average_ch_energy[24].index   \
                      );
        NRF_LOG_DEBUG(""%02d %02d %02d %02d %02d"",  \
                      m_average_ch_energy[25].index,  \
                      m_average_ch_energy[26].index,  \
                      m_average_ch_energy[27].index,  \
                      m_average_ch_energy[28].index,  \
                      m_average_ch_energy[29].index   \
                      );
        NRF_LOG_DEBUG(""%02d %02d %02d %02d %02d"",  \
                      m_average_ch_energy[30].index,  \
                      m_average_ch_energy[31].index,  \
                      m_average_ch_energy[32].index,  \
                      m_average_ch_energy[33].index,  \
                      m_average_ch_energy[34].index   \
                      );
        NRF_LOG_DEBUG(""%02d %02d"",  \
                      m_average_ch_energy[35].index,  \
                      m_average_ch_energy[36].index
                      );

        update_channel_survey_status = true;

}



uint32_t channel_map_request_update(uint16_t conn_handle, uint8_t first_best_channel_number)
{
        ret_code_t err_code;
        uint8_t number_channel_request = 0;
        ble_gap_opt_ch_map_t channel_map = {0};

        if (conn_handle == BLE_CONN_HANDLE_INVALID)
        {
                NRF_LOG_ERROR(""Failure: because of disconnection!"");
                return -1;
        }

        NRF_LOG_DEBUG(""channel_map_request_update!!"");

        channel_map.conn_handle = conn_handle;  

        for (uint8_t i=0; i < BLE_GAP_CHANNEL_COUNT; i++)
        {
                uint8_t freq_index = m_average_ch_energy[i].index;

                if (freq_index != ADVERTISING_CHANNEL_37 && freq_index != ADVERTISING_CHANNEL_38 && freq_index != ADVERTISING_CHANNEL_39)
                {
                        if (freq_index < 8)
                        {
                                channel_map.ch_map[0] |= 1 << (freq_index);
                                
                        }
                        else if (freq_index < 16)
                        {
                                channel_map.ch_map[1] |= 1 << (freq_index-8);
                                
                        }
                        else if (freq_index < 24)
                        {
                                channel_map.ch_map[2] |= 1 << (freq_index-16);
                                
                        }
                        else if (freq_index < 32)
                        {
                                channel_map.ch_map[3] |= 1 << (freq_index-24);
                                
                        }
                        else
                        {
                                channel_map.ch_map[4] |= 1 << (freq_index-32);
                                
                        }
                        number_channel_request++;
                }
                if (number_channel_request > first_best_channel_number)
                {
                        break;
                }
        }
        NRF_LOG_HEXDUMP_DEBUG(channel_map.ch_map, 5);

        err_code = sd_ble_opt_set(BLE_GAP_OPT_CH_MAP, (ble_opt_t *)&channel_map);
        APP_ERROR_CHECK(err_code);

        update_channel_survey_status = false;
}

static void process_channel_survey_report(ble_gap_evt_qos_channel_survey_report_t * p_report)
{
        for (uint8_t i = 0; i < BLE_GAP_CHANNEL_COUNT; i++)
        {
                float energy_sample = p_report->channel_energy[i];

                if (energy_sample == BLE_GAP_POWER_LEVEL_INVALID)
                {
                        continue;
                }

                if (m_num_channel_survey_reports_received == 0)
                {
                        m_average_ch_energy[i].ch_energy = energy_sample;
                }
                else
                {
                        m_average_ch_energy[i].ch_energy =  (m_num_channel_survey_reports_received * m_average_ch_energy[i].ch_energy + energy_sample)
                                                           / (m_num_channel_survey_reports_received + 1);
                }
        }
}

uint32_t channel_survey_get_report_event(ble_gap_evt_qos_channel_survey_report_t *channel_survey_report)
{
        uint32_t err_code;

        process_channel_survey_report(channel_survey_report);
        m_num_channel_survey_reports_received++;

        if (m_num_channel_survey_reports_received > NUM_REPORTS_BEFORE_AVERAGE_PRINTOUT)
        {
                err_code = sd_ble_gap_qos_channel_survey_stop();
                APP_ERROR_CHECK(err_code);

                

                err_code = app_sched_event_put(NULL, 0, update_and_sort_channel_survey_handler);
                APP_ERROR_CHECK(err_code);

                m_num_channel_survey_reports_received = 0;
        }

}
",17,542,4563
"#include ""sdk_common.h""

#include ""sdk_config.h""


#if 1


#include ""app_error.h""
#include ""nrf_assert.h""
#include ""sdk_macros.h""
#include ""ble_advdata.h""

#include ""nrf_ble_whitelist.h""



static bool m_whitelist_is_running = false;

static ble_gap_addr_t const * m_whitelist_addr_ptrs[BLE_GAP_WHITELIST_ADDR_MAX_COUNT];
static ble_gap_addr_t m_whitelist_addrs[BLE_GAP_WHITELIST_ADDR_MAX_COUNT];
static uint8_t m_addr_cnt = 0;

ret_code_t nrf_ble_whitelist_add(ble_gap_addr_t *addr, uint8_t * whitelist_count)
{

        if (m_addr_cnt >= BLE_GAP_WHITELIST_ADDR_MAX_COUNT)
                return NRF_ERROR_DATA_SIZE;

        for (uint32_t i = 0; i < BLE_GAP_WHITELIST_ADDR_MAX_COUNT; i++)
        {
                if (memcmp(&m_whitelist_addrs[i], addr, sizeof(ble_gap_addr_t))==0)
                {
                        
                        return NRF_ERROR_INVALID_PARAM;
                }
        }

        memcpy(&m_whitelist_addrs[m_addr_cnt], addr, sizeof(ble_gap_addr_t));

        m_addr_cnt++;

        
        *whitelist_count = m_addr_cnt;

        return NRF_SUCCESS;
}

ret_code_t nrf_ble_whitelist_enable(void)
{
        ret_code_t ret;

        m_whitelist_is_running = true;

        if (m_addr_cnt == 0)
        {
                return NRF_ERROR_DATA_SIZE;
        }

        for (uint32_t i = 0; i < BLE_GAP_WHITELIST_ADDR_MAX_COUNT; i++)
        {
                m_whitelist_addr_ptrs[i] = &m_whitelist_addrs[i];
        }

        ret = sd_ble_gap_whitelist_set(m_whitelist_addr_ptrs, m_addr_cnt);
        APP_ERROR_CHECK(ret);

        return NRF_SUCCESS;
}


uint8_t nrf_ble_whitelist_cnt(void)
{
        return m_addr_cnt;
}

ret_code_t nrf_ble_whitelist_clear(void)
{
        ret_code_t ret;
        memset(m_whitelist_addrs, 0, sizeof(m_whitelist_addrs));
        m_addr_cnt = 0;

        ret = sd_ble_gap_whitelist_set(NULL, 0);
        APP_ERROR_CHECK(ret);


        m_whitelist_is_running = false;
        return ret;
}


bool nrf_ble_whitelist_is_running(void)
{
        return m_whitelist_is_running;
}



#endif 
",17,543,865
"#include ""nrf_dfu_flash.h""
#include ""nrf_dfu_types.h""

#include ""nrf_fstorage.h""
#include ""nrf_fstorage_sd.h""
#include ""nrf_fstorage_nvmc.h""


#define NRF_LOG_MODULE_NAME nrf_dfu_flash
#include ""nrf_log.h""

#if NRF_DFU_FLASH_CONFIG_LOG_ENABLED
#define NRF_LOG_LEVEL BLE_SCAN_CONFIG_LOG_LEVEL
#define NRF_LOG_INFO_COLOR BLE_SCAN_CONFIG_INFO_COLOR
#define NRF_LOG_DEBUG_COLOR BLE_SCAN_CONFIG_DEBUG_COLOR
#else 
#define NRF_LOG_LEVEL 4
#endif 
#include ""nrf_log.h""
NRF_LOG_MODULE_REGISTER();


void dfu_fstorage_evt_handler(nrf_fstorage_evt_t * p_evt);


NRF_FSTORAGE_DEF(nrf_fstorage_t m_fs) =
{
        .evt_handler = dfu_fstorage_evt_handler,
        .start_addr  = 0x40000,
        .end_addr    = 0x50000
};

static uint32_t m_flash_operations_pending;

void dfu_fstorage_evt_handler(nrf_fstorage_evt_t * p_evt)
{
        if (NRF_LOG_ENABLED && (m_flash_operations_pending > 0))
        {
                m_flash_operations_pending--;
        }

        if (p_evt->result == NRF_SUCCESS)
        {
                NRF_LOG_DEBUG(""Flash %s success: addr=%p, pending %d"",
                              (p_evt->id == NRF_FSTORAGE_EVT_WRITE_RESULT) ? ""write"" : ""erase"",
                              p_evt->addr, m_flash_operations_pending);
        }
        else
        {
                NRF_LOG_DEBUG(""Flash %s failed (0x%x): addr=%p, len=0x%x bytes, pending %d"",
                              (p_evt->id == NRF_FSTORAGE_EVT_WRITE_RESULT) ? ""write"" : ""erase"",
                              p_evt->result, p_evt->addr, p_evt->len, m_flash_operations_pending);
        }

        if (p_evt->p_param)
        {
                
                ((nrf_dfu_flash_callback_t)(p_evt->p_param))((void*)p_evt->p_src);
                
        }
}


ret_code_t nrf_dfu_flash_init(bool sd_irq_initialized)
{
        nrf_fstorage_api_t * p_api_impl;

        
#if defined(BLE_STACK_SUPPORT_REQD) || defined(ANT_STACK_SUPPORT_REQD)
        if (sd_irq_initialized)
        {
                NRF_LOG_DEBUG(""Initializing nrf_fstorage_sd backend."");
                p_api_impl = &nrf_fstorage_sd;
        }
        else
#endif
        {
                NRF_LOG_DEBUG(""Initializing nrf_fstorage_nvmc backend."");
                p_api_impl = &nrf_fstorage_nvmc;
        }

        return nrf_fstorage_init(&m_fs, p_api_impl, NULL);
}


ret_code_t nrf_dfu_flash_store(uint32_t dest,
                               void const * p_src,
                               uint32_t len,
                               nrf_dfu_flash_callback_t callback)
{
        ret_code_t rc;

        NRF_LOG_DEBUG(""nrf_fstorage_write(addr=%p, src=%p, len=%d bytes), queue usage: %d"",
                      dest, p_src, len, m_flash_operations_pending);

        
        rc = nrf_fstorage_write(&m_fs, dest, p_src, len, (void *)callback);
        

        if ((NRF_LOG_ENABLED) && (rc == NRF_SUCCESS))
        {
                m_flash_operations_pending++;
        }
        else
        {
                NRF_LOG_WARNING(""nrf_fstorage_write() failed with error 0x%x."", rc);
        }

        return rc;
}


ret_code_t nrf_dfu_flash_erase(uint32_t page_addr,
                               uint32_t num_pages,
                               nrf_dfu_flash_callback_t callback)
{
        ret_code_t rc;

        NRF_LOG_DEBUG(""nrf_fstorage_erase(addr=0x%p, len=%d pages), queue usage: %d"",
                      page_addr, num_pages, m_flash_operations_pending);

        
        rc = nrf_fstorage_erase(&m_fs, page_addr, num_pages, (void *)callback);
        

        if ((NRF_LOG_ENABLED) && (rc == NRF_SUCCESS))
        {
                m_flash_operations_pending++;
        }
        else
        {
                NRF_LOG_WARNING(""nrf_fstorage_erase() failed with error 0x%x."", rc);
        }

        return rc;
}
",17,544,1458
"#include ""nordic_common.h""
#include ""app_error.h""
#include ""app_util.h""
#include ""bsp_btn_ble.h""
#include ""ble.h""
#include ""ble_gap.h""
#include ""ble_hci.h""
#include ""nrf_sdh.h""
#include ""nrf_sdh_ble.h""
#include ""nrf_sdh_soc.h""
#include ""nrf_ble_gatt.h""
#include ""nrf_pwr_mgmt.h""

#include ""packet_error_rate.h""

#include ""nrf_log_ctrl.h""
#include ""nrf_log.h""
#include ""nrf_log_default_backends.h""

static uint32_t u32_radio_packet_ready_per_interval = 0;
static uint32_t u32_radio_packet_crcok_per_interval = 0;

static packet_error_t m_accumlated_radio_packet;

static uint32_t radio_packet_success_rate = 0;
static uint32_t radio_packet_ready = 0;
static uint32_t radio_packet_crcok = 0;

void timer_1_init()
{
        NRF_TIMER_TX_READY->TASKS_CLEAR = 1;
        NRF_TIMER_TX_READY->BITMODE = TIMER_BITMODE_BITMODE_32Bit << TIMER_BITMODE_BITMODE_Pos;
        NRF_TIMER_TX_READY->PRESCALER = 4;
        NRF_TIMER_TX_READY->SHORTS = TIMER_SHORTS_COMPARE0_CLEAR_Msk << TIMER_SHORTS_COMPARE0_CLEAR_Pos;
        NRF_TIMER_TX_READY->MODE = TIMER_MODE_MODE_LowPowerCounter << TIMER_MODE_MODE_Pos;
        NRF_TIMER_TX_READY->CC[TIMER_RELOAD_CC_NUM] = TIMER_RELOAD;
        NRF_TIMER_TX_READY->TASKS_START = 1;
}

void timer_2_init()
{
        NRF_TIMER_RX_CRCOK->TASKS_CLEAR = 1;
        NRF_TIMER_RX_CRCOK->BITMODE = TIMER_BITMODE_BITMODE_32Bit << TIMER_BITMODE_BITMODE_Pos;
        NRF_TIMER_RX_CRCOK->PRESCALER = 4;
        NRF_TIMER_RX_CRCOK->SHORTS = TIMER_SHORTS_COMPARE0_CLEAR_Msk << TIMER_SHORTS_COMPARE0_CLEAR_Pos;
        NRF_TIMER_RX_CRCOK->MODE = TIMER_MODE_MODE_LowPowerCounter << TIMER_MODE_MODE_Pos;
        NRF_TIMER_RX_CRCOK->CC[TIMER_RELOAD_CC_NUM] = TIMER_RELOAD;
        NRF_TIMER_RX_CRCOK->TASKS_START = 1;
}

void packet_error_rate_reset_counter(void)
{
        memset(&m_accumlated_radio_packet, 0, sizeof(m_accumlated_radio_packet));
        radio_packet_success_rate = 0;
        radio_packet_ready = 0;
        radio_packet_crcok = 0;
}

void packet_error_rate_detect_enable(void)
{
        timer_1_init();
        timer_2_init();

        
        NRF_GPIO->DIRSET       = ( 1UL << GPIO_PER_PIN_FOR_TX_READY       |
                                   1UL << GPIO_PER_PIN_FOR_RX_CRCOK );

        
        NRF_GPIO->OUTCLR       = ( 1UL << GPIO_PER_PIN_FOR_TX_READY       |
                                   1UL << GPIO_PER_PIN_FOR_RX_CRCOK );

        NRF_GPIO->OUTSET       = ( 1UL << GPIO_PER_PIN_FOR_TX_READY       |
                                   1UL << GPIO_PER_PIN_FOR_RX_CRCOK );

        NRF_GPIO->OUTCLR       = ( 1UL << GPIO_PER_PIN_FOR_TX_READY       |
                                   1UL << GPIO_PER_PIN_FOR_RX_CRCOK );


        

        NRF_GPIOTE->CONFIG[GPIOTE_CHANNEL_TX_READY] =
                (GPIOTE_CONFIG_POLARITY_Toggle << GPIOTE_CONFIG_POLARITY_Pos) |
                (GPIO_PER_PIN_FOR_TX_READY << GPIOTE_CONFIG_PSEL_Pos)              |
                (GPIOTE_CONFIG_MODE_Task << GPIOTE_CONFIG_MODE_Pos);

        NRF_GPIOTE->CONFIG[GPIOTE_CHANNEL_RX_CRCOK] =
                (GPIOTE_CONFIG_POLARITY_Toggle << GPIOTE_CONFIG_POLARITY_Pos) |
                (GPIO_PER_PIN_FOR_RX_CRCOK << GPIOTE_CONFIG_PSEL_Pos)             |
                (GPIOTE_CONFIG_MODE_Task << GPIOTE_CONFIG_MODE_Pos);

#if defined (NRF52840_XXAA)
        
        NRF_PPI->CH[PPI_CHANNEL_FOR_TX_READY_GPIO_EVT].TEP = (uint32_t)(&NRF_GPIOTE->TASKS_OUT[GPIOTE_CHANNEL_TX_READY]);
        NRF_PPI->CH[PPI_CHANNEL_FOR_TX_READY_GPIO_EVT].EEP = (uint32_t)(&NRF_RADIO->EVENTS_TXREADY);

        
        NRF_PPI->CH[PPI_CHANNEL_FOR_RX_CRCOK_GPIO_EVT].TEP = (uint32_t)(&NRF_GPIOTE->TASKS_OUT[GPIOTE_CHANNEL_RX_CRCOK]);
        NRF_PPI->CH[PPI_CHANNEL_FOR_RX_CRCOK_GPIO_EVT].EEP = (uint32_t)(&NRF_RADIO->EVENTS_CRCOK);

        NRF_PPI->CH[PPI_CHANNEL_FOR_TX_READY_TIMER_EVT].TEP = (uint32_t)(&NRF_TIMER_TX_READY->TASKS_COUNT);
        NRF_PPI->CH[PPI_CHANNEL_FOR_TX_READY_TIMER_EVT].EEP = (uint32_t)(&NRF_RADIO->EVENTS_TXREADY);

        NRF_PPI->CH[PPI_CHANNEL_FOR_RX_CRCOK_TIMER_EVT].TEP = (uint32_t)(&NRF_TIMER_RX_CRCOK->TASKS_COUNT);
        NRF_PPI->CH[PPI_CHANNEL_FOR_RX_CRCOK_TIMER_EVT].EEP = (uint32_t)(&NRF_RADIO->EVENTS_CRCOK);

#else
        
        NRF_PPI->CH[PPI_CHANNEL_FOR_TX_READY_GPIO_EVT].TEP = (uint32_t)(&NRF_GPIOTE->TASKS_OUT[GPIOTE_CHANNEL_TX_READY]);
        NRF_PPI->CH[PPI_CHANNEL_FOR_TX_READY_GPIO_EVT].EEP = (uint32_t)(&NRF_RADIO->EVENTS_READY);

        
        NRF_PPI->CH[PPI_CHANNEL_FOR_RX_CRCOK_GPIO_EVT].TEP = (uint32_t)(&NRF_GPIOTE->TASKS_OUT[GPIOTE_CHANNEL_RX_CRCOK]);
        NRF_PPI->CH[PPI_CHANNEL_FOR_RX_CRCOK_GPIO_EVT].EEP = (uint32_t)(&NRF_RADIO->EVENTS_CRCOK);

        NRF_PPI->CH[PPI_CHANNEL_FOR_TX_READY_TIMER_EVT].TEP = (uint32_t)(&NRF_TIMER_TX_READY->TASKS_COUNT);
        NRF_PPI->CH[PPI_CHANNEL_FOR_TX_READY_TIMER_EVT].EEP = (uint32_t)(&NRF_RADIO->EVENTS_READY);

        NRF_PPI->CH[PPI_CHANNEL_FOR_RX_CRCOK_TIMER_EVT].TEP = (uint32_t)(&NRF_TIMER_RX_CRCOK->TASKS_COUNT);
        NRF_PPI->CH[PPI_CHANNEL_FOR_RX_CRCOK_TIMER_EVT].EEP = (uint32_t)(&NRF_RADIO->EVENTS_CRCOK);
#endif 
        
        NRF_PPI->CHENSET =  (1 << PPI_CHANNEL_FOR_TX_READY_GPIO_EVT)  |
                           (1 << PPI_CHANNEL_FOR_RX_CRCOK_GPIO_EVT) |
                           (1 << PPI_CHANNEL_FOR_TX_READY_TIMER_EVT) |
                           (1 << PPI_CHANNEL_FOR_RX_CRCOK_TIMER_EVT);
}

void packet_error_rate_detect_disable(void)
{
        
        NRF_PPI->CHENCLR =  (1 << PPI_CHANNEL_FOR_TX_READY_GPIO_EVT)  |
                           (1 << PPI_CHANNEL_FOR_RX_CRCOK_GPIO_EVT) |
                           (1 << PPI_CHANNEL_FOR_TX_READY_TIMER_EVT) |
                           (1 << PPI_CHANNEL_FOR_RX_CRCOK_TIMER_EVT);

        NRF_TIMER_TX_READY->TASKS_CLEAR = 1;
        NRF_TIMER_RX_CRCOK->TASKS_CLEAR = 1;

        NRF_TIMER_TX_READY->TASKS_STOP = 1;
        NRF_TIMER_RX_CRCOK->TASKS_STOP = 1;

        u32_radio_packet_ready_per_interval = 0;
        u32_radio_packet_crcok_per_interval = 0;
}

uint32_t packet_error_rate_timeout_handler(void)
{
        
        NRF_TIMER_TX_READY->TASKS_CAPTURE[0] = 1;
        NRF_TIMER_RX_CRCOK->TASKS_CAPTURE[0] = 1;

#if defined (NRF52840_XXAA)
        radio_packet_ready = NRF_TIMER_TX_READY->CC[0] - u32_radio_packet_ready_per_interval;
#else
        radio_packet_ready = NRF_TIMER_TX_READY->CC[0]/2 - u32_radio_packet_ready_per_interval;
#endif
        radio_packet_crcok = NRF_TIMER_RX_CRCOK->CC[0] - u32_radio_packet_crcok_per_interval;

        radio_packet_success_rate = (radio_packet_crcok * 100)/(radio_packet_ready);

#if defined (NRF52840_XXAA)
        u32_radio_packet_ready_per_interval = NRF_TIMER_TX_READY->CC[0];
#else
        u32_radio_packet_ready_per_interval = NRF_TIMER_TX_READY->CC[0]/2;
#endif
        u32_radio_packet_crcok_per_interval = NRF_TIMER_RX_CRCOK->CC[0];

        
        NRF_LOG_DEBUG(""PER Timeout %d, %d"", radio_packet_ready, radio_packet_crcok);
        
        

        
        

        

        m_accumlated_radio_packet.radio_packet_crcok += radio_packet_crcok;
        m_accumlated_radio_packet.radio_packet_ready += radio_packet_ready;

        NRF_LOG_DEBUG(""PER accumulated %d, %d"", m_accumlated_radio_packet.radio_packet_ready, m_accumlated_radio_packet.radio_packet_crcok);

        m_accumlated_radio_packet.radio_packet_success_rate = (m_accumlated_radio_packet.radio_packet_crcok * 100)/(m_accumlated_radio_packet.radio_packet_ready);

        if (radio_packet_ready > 0xFFFF0000)
        {
                u32_radio_packet_ready_per_interval = 0;
                u32_radio_packet_crcok_per_interval = 0;
                packet_error_rate_detect_disable();
                packet_error_rate_detect_enable();
        }
        return radio_packet_success_rate;
}

uint32_t get_packet_success_rate(void)
{
        return radio_packet_success_rate;
}

void get_accumlated_packet_success_rate(packet_error_t *per)
{
      *per = m_accumlated_radio_packet;
}

",17,545,3804
"#include ""sdk_common.h""

#if NRF_MODULE_ENABLED(ILI9341)

#include ""nrf_lcd_ext.h""
#include ""nrf_drv_spi.h""
#include ""nrf_delay.h""
#include ""nrf_gpio.h""
#include ""boards.h""


#define ILI9341_NOP         0x00
#define ILI9341_SWRESET     0x01
#define ILI9341_RDDID       0x04
#define ILI9341_RDDST       0x09

#define ILI9341_SLPIN       0x10
#define ILI9341_SLPOUT      0x11
#define ILI9341_PTLON       0x12
#define ILI9341_NORON       0x13

#define ILI9341_RDMODE      0x0A
#define ILI9341_RDMADCTL    0x0B
#define ILI9341_RDPIXFMT    0x0C
#define ILI9341_RDIMGFMT    0x0D
#define ILI9341_RDSELFDIAG  0x0F

#define ILI9341_INVOFF      0x20
#define ILI9341_INVON       0x21
#define ILI9341_GAMMASET    0x26
#define ILI9341_DISPOFF     0x28
#define ILI9341_DISPON      0x29

#define ILI9341_CASET       0x2A
#define ILI9341_PASET       0x2B
#define ILI9341_RAMWR       0x2C
#define ILI9341_RAMRD       0x2E

#define ILI9341_PTLAR       0x30
#define ILI9341_MADCTL      0x36
#define ILI9341_PIXFMT      0x3A

#define ILI9341_FRMCTR1     0xB1
#define ILI9341_FRMCTR2     0xB2
#define ILI9341_FRMCTR3     0xB3
#define ILI9341_INVCTR      0xB4
#define ILI9341_DFUNCTR     0xB6

#define ILI9341_PWCTR1      0xC0
#define ILI9341_PWCTR2      0xC1
#define ILI9341_PWCTR3      0xC2
#define ILI9341_PWCTR4      0xC3
#define ILI9341_PWCTR5      0xC4
#define ILI9341_VMCTR1      0xC5
#define ILI9341_VMCTR2      0xC7
#define ILI9341_PWCTRSEQ    0xCB
#define ILI9341_PWCTRA      0xCD
#define ILI9341_PWCTRB      0xCF

#define ILI9341_RDID1       0xDA
#define ILI9341_RDID2       0xDB
#define ILI9341_RDID3       0xDC
#define ILI9341_RDID4       0xDD

#define ILI9341_GMCTRP1     0xE0
#define ILI9341_GMCTRN1     0xE1
#define ILI9341_DGMCTR1     0xE2
#define ILI9341_DGMCTR2     0xE3
#define ILI9341_TIMCTRA     0xE8
#define ILI9341_TIMCTRB     0xEA

#define ILI9341_ENGMCTR     0xF2
#define ILI9341_INCTR       0xF6
#define ILI9341_PUMP        0xF7

#define ILI9341_MADCTL_MY  0x80
#define ILI9341_MADCTL_MX  0x40
#define ILI9341_MADCTL_MV  0x20
#define ILI9341_MADCTL_ML  0x10
#define ILI9341_MADCTL_RGB 0x00
#define ILI9341_MADCTL_BGR 0x08
#define ILI9341_MADCTL_MH  0x04

static const nrf_drv_spi_t spi = NRF_DRV_SPI_INSTANCE(ILI9341_SPI_INSTANCE);

static inline void spi_write(const void * data, size_t size)
{
    APP_ERROR_CHECK(nrf_drv_spi_transfer(&spi, data, size, NULL, 0));
}

static inline void write_command(uint8_t c)
{
    nrf_gpio_pin_clear(ILI9341_DC_PIN);
    spi_write(&c, sizeof(c));
}

static inline void write_data(uint8_t c)
{
    nrf_gpio_pin_set(ILI9341_DC_PIN);
    spi_write(&c, sizeof(c));
}

static void set_addr_window(uint16_t x_0, uint16_t y_0, uint16_t x_1, uint16_t y_1)
{
    ASSERT(x_0 <= x_1);
    ASSERT(y_0 <= y_1);

    write_command(ILI9341_CASET);
    write_data(x_0 >> 8);
    write_data(x_0);
    write_data(x_1 >> 8);
    write_data(x_1);
    write_command(ILI9341_PASET);
    write_data(y_0 >> 8);
    write_data(y_0);
    write_data(y_1 >> 8);
    write_data(y_1);
    write_command(ILI9341_RAMWR);
}

static void command_list(void)
{
    write_command(ILI9341_SWRESET);
    nrf_delay_ms(120);
    write_command(ILI9341_DISPOFF);
    nrf_delay_ms(120);
    write_command(ILI9341_PWCTRB);
    write_data(0x00);
    write_data(0XC1);
    write_data(0X30);

    write_command(ILI9341_TIMCTRA);
    write_data(0x85);
    write_data(0x00);
    write_data(0x78);

    write_command(ILI9341_PWCTRSEQ);
    write_data(0x39);
    write_data(0x2C);
    write_data(0x00);
    write_data(0x34);
    write_data(0x02);

    write_command(ILI9341_PUMP);
    write_data(0x20);

    write_command(ILI9341_TIMCTRB);
    write_data(0x00);
    write_data(0x00);

    write_command(ILI9341_PWCTR1);
    write_data(0x23);

    write_command(ILI9341_PWCTR2);
    write_data(0x10);

    write_command(ILI9341_VMCTR1);
    write_data(0x3e);
    write_data(0x28);

    write_command(ILI9341_VMCTR2);
    write_data(0x86);

    write_command(ILI9341_MADCTL);
    write_data(0x48);

    write_command(ILI9341_PIXFMT);
    write_data(0x55);

    write_command(ILI9341_FRMCTR1);
    write_data(0x00);
    write_data(0x18);

    write_command(ILI9341_DFUNCTR);
    write_data(0x08);
    write_data(0x82);
    write_data(0x27);

    write_command(ILI9341_ENGMCTR);
    write_data(0x00);

    write_command(ILI9341_GAMMASET);
    write_data(0x01);

    write_command(ILI9341_GMCTRP1);
    write_data(0x0F);
    write_data(0x31);
    write_data(0x2B);
    write_data(0x0C);
    write_data(0x0E);
    write_data(0x08);
    write_data(0x4E);
    write_data(0xF1);
    write_data(0x37);
    write_data(0x07);
    write_data(0x10);
    write_data(0x03);
    write_data(0x0E);
    write_data(0x09);
    write_data(0x00);

    write_command(ILI9341_GMCTRN1);
    write_data(0x00);
    write_data(0x0E);
    write_data(0x14);
    write_data(0x03);
    write_data(0x11);
    write_data(0x07);
    write_data(0x31);
    write_data(0xC1);
    write_data(0x48);
    write_data(0x08);
    write_data(0x0F);
    write_data(0x0C);
    write_data(0x31);
    write_data(0x36);
    write_data(0x0F);

    write_command(ILI9341_SLPOUT);
    nrf_delay_ms(120);
    write_command(ILI9341_DISPON);
}

static ret_code_t hardware_init(void)
{
    ret_code_t err_code;

    nrf_gpio_cfg_output(ILI9341_DC_PIN);

    nrf_drv_spi_config_t spi_config = NRF_DRV_SPI_DEFAULT_CONFIG;

    spi_config.sck_pin  = ILI9341_SCK_PIN;
    spi_config.miso_pin = ILI9341_MISO_PIN;
    spi_config.mosi_pin = ILI9341_MOSI_PIN;
    spi_config.ss_pin   = ILI9341_SS_PIN;
    spi_config.frequency = SPI_FREQUENCY_FREQUENCY_M4;

    err_code = nrf_drv_spi_init(&spi, &spi_config, NULL, NULL);
    return err_code;
}

static ret_code_t ili9341_init(void)
{
    ret_code_t err_code;

    err_code = hardware_init();
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    }

    command_list();

    return err_code;
}

static void ili9341_uninit(void)
{
    nrf_drv_spi_uninit(&spi);
}

static void ili9341_pixel_draw(uint16_t x, uint16_t y, uint32_t color)
{
    set_addr_window(x, y, x, y);

    const uint8_t data[2] = {color >> 8, color};

    nrf_gpio_pin_set(ILI9341_DC_PIN);

    spi_write(data, sizeof(data));

    nrf_gpio_pin_clear(ILI9341_DC_PIN);
}

static void ili9341_rect_draw_old(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint32_t color)
{
    set_addr_window(x, y, x + width - 1, y + height - 1);

    const uint8_t data[2] = {color >> 8, color};

    nrf_gpio_pin_set(ILI9341_DC_PIN);

    
    uint32_t i = (height * width + 7) / 8;


    switch ((height * width) % 8) {
        case 0:
            do {
                spi_write(data, sizeof(data));
        case 7:
                spi_write(data, sizeof(data));
        case 6:
                spi_write(data, sizeof(data));
        case 5:
                spi_write(data, sizeof(data));
        case 4:
                spi_write(data, sizeof(data));
        case 3:
                spi_write(data, sizeof(data));
        case 2:
                spi_write(data, sizeof(data));
        case 1:
                spi_write(data, sizeof(data));
            } while (--i > 0);
        default:
            break;
    }


    nrf_gpio_pin_clear(ILI9341_DC_PIN);
}

static void ili9341_rect_draw(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint32_t color)
{
    static uint8_t data[32];
    
    set_addr_window(x, y, x + width - 1, y + height - 1);

    for(int i = 0; i < 16; i++)
    {
       data[i*2] = color >> 8;
       data[i*2+1] = color;
    }

    nrf_gpio_pin_set(ILI9341_DC_PIN);

    uint32_t bytes_left = height * width * 2;

    do
    {
        if(bytes_left > 32)
        {
            spi_write(data, sizeof(data));
            bytes_left -= 16;
        }
        else
        {
           spi_write(data, bytes_left);
           bytes_left = 0;
        }
    
    }while(bytes_left > 0); 

    nrf_gpio_pin_clear(ILI9341_DC_PIN);
}

static void ili9341_buffer_draw(uint16_t x, uint16_t y, uint16_t width, uint16_t height, void * p_data, uint32_t length)
{
    uint32_t spi_max_length, spi_length;
    
    set_addr_window(x, y, x + width - 1, y + height - 1);

    nrf_gpio_pin_set(ILI9341_DC_PIN);
    spi_max_length = 250; 
    do
    {
        spi_length = (length > spi_max_length) ? spi_max_length : length;
        spi_write(p_data, spi_length);
        length -= spi_length;
        p_data += spi_length;        
    }while(length > 0);

    nrf_gpio_pin_clear(ILI9341_DC_PIN);    
}

static void ili9341_dummy_display(void)
{
    
}

static void ili9341_rotation_set(nrf_lcd_rotation_t rotation)
{
    write_command(ILI9341_MADCTL);
    switch (rotation) {
        case NRF_LCD_ROTATE_0:
            write_data(ILI9341_MADCTL_MX | ILI9341_MADCTL_BGR);
            break;
        case NRF_LCD_ROTATE_90:
            write_data(ILI9341_MADCTL_MV | ILI9341_MADCTL_BGR);
            break;
        case NRF_LCD_ROTATE_180:
            write_data(ILI9341_MADCTL_MY | ILI9341_MADCTL_BGR);
            break;
        case NRF_LCD_ROTATE_270:
            write_data(ILI9341_MADCTL_MX | ILI9341_MADCTL_MY | ILI9341_MADCTL_MV | ILI9341_MADCTL_BGR);
            break;
        default:
            break;
    }
}

static void ili9341_display_invert(bool invert)
{
    write_command(invert ? ILI9341_INVON : ILI9341_INVOFF);
}

static lcd_cb_t ili9341_cb = {
    .height = ILI9341_HEIGHT,
    .width = ILI9341_WIDTH
};


const nrf_lcd_t nrf_lcd_ili9341 = {
    .lcd_init = ili9341_init,
    .lcd_uninit = ili9341_uninit,
    .lcd_pixel_draw = ili9341_pixel_draw,
    .lcd_rect_draw = ili9341_rect_draw,
    .lcd_buffer_draw = ili9341_buffer_draw,
    .lcd_display = ili9341_dummy_display,
    .lcd_rotation_set = ili9341_rotation_set,
    .lcd_display_invert = ili9341_display_invert,
    .p_lcd_cb = &ili9341_cb
};

#endif 
",17,546,4879
"#include ""sdk_common.h""
#if NRF_MODULE_ENABLED(BLE_LBS_C)

#include ""ble_lbs_c_extended.h""
#include ""ble_db_discovery.h""
#include ""ble_types.h""
#include ""ble_srv_common.h""
#include ""ble_gattc.h""
#define NRF_LOG_MODULE_NAME ble_lbs_c
#include ""nrf_log.h""
NRF_LOG_MODULE_REGISTER();

#define TX_BUFFER_MASK         0x07                  
#define TX_BUFFER_SIZE         (TX_BUFFER_MASK + 1)  

#define WRITE_MESSAGE_LENGTH   BLE_CCCD_VALUE_LEN    
#define WRITE_MESSAGE_LENGTH   BLE_CCCD_VALUE_LEN    

typedef enum
{
    READ_REQ,  
    WRITE_REQ  
} tx_request_t;


typedef struct
{
    uint8_t                  gattc_value[WRITE_MESSAGE_LENGTH];  
    ble_gattc_write_params_t gattc_params;                       
} write_params_t;


typedef struct
{
    uint16_t     conn_handle;  
    tx_request_t type;         
    union
    {
        uint16_t       read_handle;  
        write_params_t write_req;    
    } req;
} tx_message_t;


static tx_message_t m_tx_buffer[TX_BUFFER_SIZE];  
static uint32_t     m_tx_insert_index = 0;        
static uint32_t     m_tx_index = 0;               



static void tx_buffer_process(void)
{
    if (m_tx_index != m_tx_insert_index)
    {
        uint32_t err_code;

        if (m_tx_buffer[m_tx_index].type == READ_REQ)
        {
            err_code = sd_ble_gattc_read(m_tx_buffer[m_tx_index].conn_handle,
                                         m_tx_buffer[m_tx_index].req.read_handle,
                                         0);
        }
        else
        {
            err_code = sd_ble_gattc_write(m_tx_buffer[m_tx_index].conn_handle,
                                          &m_tx_buffer[m_tx_index].req.write_req.gattc_params);
        }
        if (err_code == NRF_SUCCESS)
        {
            NRF_LOG_DEBUG(""SD Read/Write API returns Success.."");
            m_tx_index++;
            m_tx_index &= TX_BUFFER_MASK;
        }
        else
        {
            NRF_LOG_DEBUG(""SD Read/Write API returns error. This message sending will be ""
                ""attempted again.."");
        }
    }
}



static void on_write_rsp(ble_lbs_c_t * p_ble_lbs_c, ble_evt_t const * p_ble_evt)
{
    
    if (p_ble_lbs_c->conn_handle != p_ble_evt->evt.gattc_evt.conn_handle)
    {
        return;
    }
    
    tx_buffer_process();
}



static void on_hvx(ble_lbs_c_t * p_ble_lbs_c, ble_evt_t const * p_ble_evt)
{
    
    if (p_ble_lbs_c->conn_handle != p_ble_evt->evt.gattc_evt.conn_handle)
    {
        return;
    }
    
    if (p_ble_evt->evt.gattc_evt.params.hvx.handle == p_ble_lbs_c->peer_lbs_db.button_handle)
    {
        if (p_ble_evt->evt.gattc_evt.params.hvx.len == 1)
        {
            ble_lbs_c_evt_t ble_lbs_c_evt;

            ble_lbs_c_evt.evt_type                   = BLE_LBS_C_EVT_BUTTON_NOTIFICATION;
            ble_lbs_c_evt.conn_handle                = p_ble_lbs_c->conn_handle;
            ble_lbs_c_evt.params.button.button_state = p_ble_evt->evt.gattc_evt.params.hvx.data[0];
            p_ble_lbs_c->evt_handler(p_ble_lbs_c, &ble_lbs_c_evt);
        }
    }
}



static void on_disconnected(ble_lbs_c_t * p_ble_lbs_c, ble_evt_t const * p_ble_evt)
{
    if (p_ble_lbs_c->conn_handle == p_ble_evt->evt.gap_evt.conn_handle)
    {
        p_ble_lbs_c->conn_handle                    = BLE_CONN_HANDLE_INVALID;
        p_ble_lbs_c->peer_lbs_db.button_cccd_handle = BLE_GATT_HANDLE_INVALID;
        p_ble_lbs_c->peer_lbs_db.button_handle      = BLE_GATT_HANDLE_INVALID;
        p_ble_lbs_c->peer_lbs_db.led_handle         = BLE_GATT_HANDLE_INVALID;
        p_ble_lbs_c->peer_lbs_db.led_color_handle   = BLE_GATT_HANDLE_INVALID;
    }
}


void ble_lbs_on_db_disc_evt(ble_lbs_c_t * p_ble_lbs_c, ble_db_discovery_evt_t const * p_evt)
{
    
    if (p_evt->evt_type == BLE_DB_DISCOVERY_COMPLETE &&
        p_evt->params.discovered_db.srv_uuid.uuid == LBS_UUID_SERVICE &&
        p_evt->params.discovered_db.srv_uuid.type == p_ble_lbs_c->uuid_type)
    {
        ble_lbs_c_evt_t evt;

        evt.evt_type    = BLE_LBS_C_EVT_DISCOVERY_COMPLETE;
        evt.conn_handle = p_evt->conn_handle;

        for (uint32_t i = 0; i < p_evt->params.discovered_db.char_count; i++)
        {
            const ble_gatt_db_char_t * p_char = &(p_evt->params.discovered_db.charateristics[i]);
            switch (p_char->characteristic.uuid.uuid)
            {
                case LBS_UUID_LED_CHAR:
                    evt.params.peer_db.led_handle = p_char->characteristic.handle_value;
                    break;
                case LBS_UUID_LED_COL_CHAR:
                    evt.params.peer_db.led_color_handle = p_char->characteristic.handle_value;
                    break;
                case LBS_UUID_BUTTON_CHAR:
                    evt.params.peer_db.button_handle      = p_char->characteristic.handle_value;
                    evt.params.peer_db.button_cccd_handle = p_char->cccd_handle;
                    break;

                default:
                    break;
            }
        }

        NRF_LOG_DEBUG(""Led Button Service discovered at peer."");
        
        if (p_ble_lbs_c->conn_handle != BLE_CONN_HANDLE_INVALID)
        {
            if ((p_ble_lbs_c->peer_lbs_db.led_handle         == BLE_GATT_HANDLE_INVALID)&&
                (p_ble_lbs_c->peer_lbs_db.led_color_handle   == BLE_GATT_HANDLE_INVALID)&&
                (p_ble_lbs_c->peer_lbs_db.button_handle      == BLE_GATT_HANDLE_INVALID)&&
                (p_ble_lbs_c->peer_lbs_db.button_cccd_handle == BLE_GATT_HANDLE_INVALID))
            {
                p_ble_lbs_c->peer_lbs_db = evt.params.peer_db;
            }
        }

        p_ble_lbs_c->evt_handler(p_ble_lbs_c, &evt);

    }
}


uint32_t ble_lbs_c_init(ble_lbs_c_t * p_ble_lbs_c, ble_lbs_c_init_t * p_ble_lbs_c_init)
{
    uint32_t      err_code;
    ble_uuid_t    lbs_uuid;
    ble_uuid128_t lbs_base_uuid = {LBS_UUID_BASE};

    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c);
    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c_init);
    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c_init->evt_handler);

    p_ble_lbs_c->peer_lbs_db.button_cccd_handle = BLE_GATT_HANDLE_INVALID;
    p_ble_lbs_c->peer_lbs_db.button_handle      = BLE_GATT_HANDLE_INVALID;
    p_ble_lbs_c->peer_lbs_db.led_handle         = BLE_GATT_HANDLE_INVALID;
    p_ble_lbs_c->peer_lbs_db.led_color_handle   = BLE_GATT_HANDLE_INVALID;
    p_ble_lbs_c->conn_handle                    = BLE_CONN_HANDLE_INVALID;
    p_ble_lbs_c->evt_handler                    = p_ble_lbs_c_init->evt_handler;

    err_code = sd_ble_uuid_vs_add(&lbs_base_uuid, &p_ble_lbs_c->uuid_type);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    }
    VERIFY_SUCCESS(err_code);

    lbs_uuid.type = p_ble_lbs_c->uuid_type;
    lbs_uuid.uuid = LBS_UUID_SERVICE;

    return ble_db_discovery_evt_register(&lbs_uuid);
}

void ble_lbs_c_on_ble_evt(ble_evt_t const * p_ble_evt, void * p_context)
{
    if ((p_context == NULL) || (p_ble_evt == NULL))
    {
        return;
    }

    ble_lbs_c_t * p_ble_lbs_c = (ble_lbs_c_t *)p_context;

    switch (p_ble_evt->header.evt_id)
    {
        case BLE_GATTC_EVT_HVX:
            on_hvx(p_ble_lbs_c, p_ble_evt);
            break;

        case BLE_GATTC_EVT_WRITE_RSP:
            on_write_rsp(p_ble_lbs_c, p_ble_evt);
            break;

        case BLE_GAP_EVT_DISCONNECTED:
            on_disconnected(p_ble_lbs_c, p_ble_evt);
            break;

        default:
            break;
    }
}



static uint32_t cccd_configure(uint16_t conn_handle, uint16_t handle_cccd, bool enable)
{
    NRF_LOG_DEBUG(""Configuring CCCD. CCCD Handle = %d, Connection Handle = %d"",
        handle_cccd,conn_handle);

    tx_message_t * p_msg;
    uint16_t       cccd_val = enable ? BLE_GATT_HVX_NOTIFICATION : 0;

    p_msg              = &m_tx_buffer[m_tx_insert_index++];
    m_tx_insert_index &= TX_BUFFER_MASK;

    p_msg->req.write_req.gattc_params.handle   = handle_cccd;
    p_msg->req.write_req.gattc_params.len      = WRITE_MESSAGE_LENGTH;
    p_msg->req.write_req.gattc_params.p_value  = p_msg->req.write_req.gattc_value;
    p_msg->req.write_req.gattc_params.offset   = 0;
    p_msg->req.write_req.gattc_params.write_op = BLE_GATT_OP_WRITE_REQ;
    p_msg->req.write_req.gattc_value[0]        = LSB_16(cccd_val);
    p_msg->req.write_req.gattc_value[1]        = MSB_16(cccd_val);
    p_msg->conn_handle                         = conn_handle;
    p_msg->type                                = WRITE_REQ;

    tx_buffer_process();
    return NRF_SUCCESS;
}


uint32_t ble_lbs_c_button_notif_enable(ble_lbs_c_t * p_ble_lbs_c)
{
    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c);

    if (p_ble_lbs_c->conn_handle == BLE_CONN_HANDLE_INVALID)
    {
        return NRF_ERROR_INVALID_STATE;
    }

    return cccd_configure(p_ble_lbs_c->conn_handle,
                          p_ble_lbs_c->peer_lbs_db.button_cccd_handle,
                          true);
}


uint32_t ble_lbs_led_status_send(ble_lbs_c_t * p_ble_lbs_c, uint8_t status)
{
    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c);

    if (p_ble_lbs_c->conn_handle == BLE_CONN_HANDLE_INVALID)
    {
        return NRF_ERROR_INVALID_STATE;
    }

    NRF_LOG_DEBUG(""writing LED status 0x%x"", status);

    tx_message_t * p_msg;

    p_msg              = &m_tx_buffer[m_tx_insert_index++];
    m_tx_insert_index &= TX_BUFFER_MASK;

    p_msg->req.write_req.gattc_params.handle   = p_ble_lbs_c->peer_lbs_db.led_handle;
    p_msg->req.write_req.gattc_params.len      = sizeof(status);
    p_msg->req.write_req.gattc_params.p_value  = p_msg->req.write_req.gattc_value;
    p_msg->req.write_req.gattc_params.offset   = 0;
    p_msg->req.write_req.gattc_params.write_op = BLE_GATT_OP_WRITE_CMD;
    p_msg->req.write_req.gattc_value[0]        = status;
    p_msg->conn_handle                         = p_ble_lbs_c->conn_handle;
    p_msg->type                                = WRITE_REQ;

    tx_buffer_process();
    return NRF_SUCCESS;
}


uint32_t ble_lbs_led_color_send(ble_lbs_c_t * p_ble_lbs_c, uint8_t *colors)
{
    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c);

    if (p_ble_lbs_c->conn_handle == BLE_CONN_HANDLE_INVALID)
    {
        return NRF_ERROR_INVALID_STATE;
    }

    if (p_ble_lbs_c->peer_lbs_db.led_color_handle == BLE_GATT_HANDLE_INVALID)
    {
        return NRF_ERROR_INVALID_STATE;
    }

    NRF_LOG_INFO(""writing LED color %i, %i, %i"", colors[0], colors[1], colors[2]);

    tx_message_t * p_msg;

    p_msg              = &m_tx_buffer[m_tx_insert_index++];
    m_tx_insert_index &= TX_BUFFER_MASK;

    p_msg->req.write_req.gattc_params.handle   = p_ble_lbs_c->peer_lbs_db.led_color_handle;
    p_msg->req.write_req.gattc_params.len      = 4;
    p_msg->req.write_req.gattc_params.p_value  = p_msg->req.write_req.gattc_value;
    p_msg->req.write_req.gattc_params.offset   = 0;
    p_msg->req.write_req.gattc_params.write_op = BLE_GATT_OP_WRITE_CMD;
    memcpy(p_msg->req.write_req.gattc_value, colors, 3);
    p_msg->conn_handle                         = p_ble_lbs_c->conn_handle;
    p_msg->type                                = WRITE_REQ;

    tx_buffer_process();
    return NRF_SUCCESS;
}


uint32_t ble_lbs_c_handles_assign(ble_lbs_c_t    * p_ble_lbs_c,
                                  uint16_t         conn_handle,
                                  const lbs_db_t * p_peer_handles)
{
    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c);

    p_ble_lbs_c->conn_handle = conn_handle;
    if (p_peer_handles != NULL)
    {
        p_ble_lbs_c->peer_lbs_db = *p_peer_handles;
    }
    return NRF_SUCCESS;
}

#endif 
",17,547,4950
"#define PORT ""8888"" 

#define MAXDATASIZE 100 


void *get_in_addr(struct sockaddr *sa)
{
    if (sa->sa_family == AF_INET) {
        return &(((struct sockaddr_in*)sa)->sin_addr);
    }

    return &(((struct sockaddr_in6*)sa)->sin6_addr);
}

int main(int argc, char *argv[])
{
    int sockfd, numbytes;  
    char buf[MAXDATASIZE];
    struct addrinfo hints, *servinfo, *p;
    int rv;
    char s[INET6_ADDRSTRLEN];

    if (argc != 2) {
        fprintf(stderr,""usage: client hostname\n"");
        exit(1);
    }

    memset(&hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    if ((rv = getaddrinfo(argv[1], PORT, &hints, &servinfo)) != 0) {
        fprintf(stderr, ""getaddrinfo: %s\n"", gai_strerror(rv));
        return 1;
    }

    
    for(p = servinfo; p != NULL; p = p->ai_next) {
        if ((sockfd = socket(p->ai_family, p->ai_socktype,
                p->ai_protocol)) == -1) {
            perror(""client: socket"");
            continue;
        }

        if (connect(sockfd, p->ai_addr, p->ai_addrlen) == -1) {
            perror(""client: connect"");
            close(sockfd);
            continue;
        }

        break;
    }

    if (p == NULL) {
        fprintf(stderr, ""client: failed to connect\n"");
        return 2;
    }

    inet_ntop(p->ai_family, get_in_addr((struct sockaddr *)p->ai_addr),
            s, sizeof s);
    printf(""client: connecting to %s\n"", s);

    freeaddrinfo(servinfo); 

    if ((numbytes = recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
        perror(""recv"");
        exit(1);
    }

    buf[numbytes] = '\0';

    printf(""client: received '%s'\n"",buf);

    close(sockfd);

    return 0;
}
",18,548,659
"FILE* F1;
FILE* F2;

int flag =0;

int a[200];
int* read(int n)
{
        flag++;
        int i;
        int s = sizeof(int);
        int* arr1= (int*)malloc(s * n);
        for(i = 0; i<n; i++)
        {
                fscanf(F1, ""%d"", (arr1+i));
        }
        return arr1;

}



void display(int arr2[], int n)
{   
        int i;
        for(i = 0; i<n; i++)
        {
                fprintf(F2, ""%d "", arr2[i]);
        }

}

float findMedian(int X[],int Y[],int m,int n)
{
    float median;
    int s = sizeof(int);
    
    int j=0; int k =0;
    int i=0;

    while(i<m+n)
    {
        if(j<m && k<n)
        {
            if(X[j]<=Y[k])
            {
                a[i] = X[j];
                j++;
            }
            else
            {
                a[i] = Y[k];
                k++;
            }
            i++;
        }
    
        else if(j == m)
        {
            a[i]=Y[k];
            k++;
            i++;
        }
        else if(k == n)
        {
            a[i]=X[j];
            j++;
            i++;
        }

    }

    if((m+n)%2 != 0)
    {
        median = a[(m+n)/2];
        return median;
    }
    else
    {
        median = (a[(m+n-1)/2]+a[(m+n-1)/2+1])/2.0;
        return median;
    }
}

int main(int argc, char* argv[])
{
    
        int num; char s;int size1, size2;
        int* arr1;
        int* arr2;
        F1 = fopen(argv[1], ""r"");
        F2 = fopen(argv[2], ""w"");
        while(1)
        {
        fscanf(F1 ,""%c %d"",&s, &num);
        if(s == 'r')
        {
            if(flag%2==0)
            {
                size1 = num;
                arr1 = read(num);
            }
            else if(flag%2==1)
            {
                size2 = num;
                arr2 = read(num);
            }
        }
        else if(s == 'f')
        {
                float p = findMedian(arr1,arr2,size1,size2);
        if((size1+size2)%2 == 0)
        {
                fprintf(F2,""%0.2f\n"", p);
        }
        else
            fprintf(F2, ""%d\n"", (int)p);
        }

        else if(s == 'd')
        {
        float med = findMedian(arr1, arr2, size1, size2);
                display(a, size1+size2);
                fprintf(F2, ""\n"");
        }
        else if(s == 't')
                return 0;
        }
        fclose(F1);
        fclose(F2);

}
",18,549,877
"#define PORT 8080
#define BUFSIZE 1024


void server_set_up(int *sockfd, struct sockaddr_in *server_addr);

void connection_accept(fd_set *master, int *fdmax, int sockfd, struct sockaddr_in *client_addr);

void send_recv(int i, fd_set *master, int sockfd, int fdmax);

int main()
{
    fd_set master, read_fds;

    int fdmax, i;
    int sockfd = 0;

    struct sockaddr_in server_addr, client_addr;

    
    FD_ZERO(&master);
    FD_ZERO(&read_fds);

    server_set_up(&sockfd, &server_addr);

    
    FD_SET(sockfd, &master);

    
    fdmax = sockfd;

    while (1)
    {
        
        read_fds = master;

        
        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)
        {
            perror(""select"");
            exit(4);
        }

        
        for (i = 0; i <= fdmax; i++)
        {
            if (FD_ISSET(i, &read_fds))
            {
                if (i == sockfd)
                    
                    
                    connection_accept(&master, &fdmax, sockfd, &client_addr);
                else
                    
                    send_recv(i, &master, sockfd, fdmax);
            }
        }
    }
    return 0;
}

void server_set_up(int *sockfd, struct sockaddr_in *server_addr)
{
    if ((*sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
    {
        perror(""Socket"");
        exit(1);
    }

    
    server_addr->sin_family = AF_INET;
    server_addr->sin_port = htons(PORT);
    server_addr->sin_addr.s_addr = INADDR_ANY;

    

    
    if (bind(*sockfd, (struct sockaddr *)server_addr, sizeof(struct sockaddr)) == -1)
    {
        perror(""Unable to bind"");
        exit(1);
    }
    printf(""TCP Server Bound to Port: %d\n"", PORT);
    
    if (listen(*sockfd, 10) == -1)
    {
        perror(""listen"");
        exit(1);
    }
    printf(""TCP Server Waiting for Client Requests...\n"");
    fflush(stdout);
}


void connection_accept(fd_set *master, int *fdmax, int sockfd, struct sockaddr_in *client_addr)
{
    socklen_t addrlen = sizeof(struct sockaddr_in);
    int newsockfd;

    if ((newsockfd = accept(sockfd, (struct sockaddr *)client_addr, &addrlen)) == -1)
    {
        perror(""accept"");
        exit(1);
    } 
    else 
    {
        
        FD_SET(newsockfd, master);
        
        if (newsockfd > *fdmax)
            *fdmax = newsockfd;
        printf(""New connection at %s : %d \n"", inet_ntoa(client_addr->sin_addr), ntohs(client_addr->sin_port));
    }
}

void send_recv(int i, fd_set *master, int sockfd, int fdmax) 
{
    int recv_size, j;
    char recv_buf[BUFSIZE], buf[BUFSIZE];
    if ((recv_size = recv(i, recv_buf, BUFSIZE, 0)) <= 0)
    {
        if (recv_size == 0)
            printf(""Socket with FD: %d Hung Up\n"", i);
        else
            perror(""recv"");

        
        
        close(i);
        FD_CLR(i, master);
    }
    else
    {
        for (j = 0; j <= fdmax; j++)
        {
            
            if (FD_ISSET(j, master))
            {
                if (j != sockfd && j != i)
                {
                    if (send(j, recv_buf, recv_size, 0) == -1)
                    {
                        perror(""send"");
                    }
                }
            }
        }
        printf(""%s\n"", recv_buf);
        bzero(recv_buf, BUFSIZE);
    }
}",18,550,1222
"#define MAX_CLIENTS 100
#define BUFFER_SZ 2048

static _Atomic unsigned int cli_count = 0;
static int uid = 10;


typedef struct{
    struct sockaddr_in address;
    int sockfd;
    int uid;
    char name[32];
} client_t;

client_t *clients[MAX_CLIENTS];

pthread_mutex_t clients_mutex = PTHREAD_MUTEX_INITIALIZER;

void str_overwrite_stdout() {
    printf(""\r%s"", ""> "");
    fflush(stdout);
}

void str_trim_lf (char* arr, int length) {
  int i;
  for (i = 0; i < length; i++) { 
    if (arr[i] == '\n') {
      arr[i] = '\0';
      break;
    }
  }
}

void print_client_addr(struct sockaddr_in addr){
    printf(""%d.%d.%d.%d"",
        addr.sin_addr.s_addr & 0xff,
        (addr.sin_addr.s_addr & 0xff00) >> 8,
        (addr.sin_addr.s_addr & 0xff0000) >> 16,
        (addr.sin_addr.s_addr & 0xff000000) >> 24);
}


void queue_add(client_t *cl){
    pthread_mutex_lock(&clients_mutex);

    for(int i=0; i < MAX_CLIENTS; ++i){
        if(!clients[i]){
            clients[i] = cl;
            break;
        }
    }

    pthread_mutex_unlock(&clients_mutex);
}


void queue_remove(int uid){
    pthread_mutex_lock(&clients_mutex);

    for(int i=0; i < MAX_CLIENTS; ++i){
        if(clients[i]){
            if(clients[i]->uid == uid){
                clients[i] = NULL;
                break;
            }
        }
    }

    pthread_mutex_unlock(&clients_mutex);
}


void send_message(char *s, int uid){
    pthread_mutex_lock(&clients_mutex);

    for(int i=0; i<MAX_CLIENTS; ++i){
        if(clients[i]){
            if(clients[i]->uid != uid){
                if(write(clients[i]->sockfd, s, strlen(s)) < 0){
                    perror(""ERROR: write to descriptor failed"");
                    break;
                }
            }
        }
    }

    pthread_mutex_unlock(&clients_mutex);
}


void *handle_client(void *arg){
    char buff_out[BUFFER_SZ];
    char name[32];
    int leave_flag = 0;

    cli_count++;
    client_t *cli = (client_t *)arg;

    
    if(recv(cli->sockfd, name, 32, 0) <= 0 || strlen(name) <  2 || strlen(name) >= 32-1){
        printf(""Didn't enter the name.\n"");
        leave_flag = 1;
    } else{
        strcpy(cli->name, name);
        sprintf(buff_out, ""%s has joined\n"", cli->name);
        printf(""%s"", buff_out);
        send_message(buff_out, cli->uid);
    }

    bzero(buff_out, BUFFER_SZ);

    while(1){
        if (leave_flag) {
            break;
        }

        int receive = recv(cli->sockfd, buff_out, BUFFER_SZ, 0);
        if (receive > 0){
            if(strlen(buff_out) > 0){
                send_message(buff_out, cli->uid);

                str_trim_lf(buff_out, strlen(buff_out));
                printf(""%s -> %s\n"", buff_out, cli->name);
            }
        } else if (receive == 0 || strcmp(buff_out, ""exit"") == 0){
            sprintf(buff_out, ""%s has left\n"", cli->name);
            printf(""%s"", buff_out);
            send_message(buff_out, cli->uid);
            leave_flag = 1;
        } else {
            printf(""ERROR: -1\n"");
            leave_flag = 1;
        }

        bzero(buff_out, BUFFER_SZ);
    }

  
    close(cli->sockfd);
  queue_remove(cli->uid);
  free(cli);
  cli_count--;
  pthread_detach(pthread_self());

    return NULL;
}

int main(int argc, char **argv){
    if(argc != 2){
        printf(""Usage: %s <port>\n"", argv[0]);
        return EXIT_FAILURE;
    }

    char *ip = ""127.0.0.1"";
    int port = atoi(argv[1]);
    int option = 1;
    int listenfd = 0, connfd = 0;
  struct sockaddr_in serv_addr;
  struct sockaddr_in cli_addr;
  pthread_t tid;

  
  listenfd = socket(AF_INET, SOCK_STREAM, 0);
  serv_addr.sin_family = AF_INET;
  serv_addr.sin_addr.s_addr = inet_addr(ip);
  serv_addr.sin_port = htons(port);

  
    signal(SIGPIPE, SIG_IGN);

    if(setsockopt(listenfd, SOL_SOCKET,(SO_REUSEPORT | SO_REUSEADDR),(char*)&option,sizeof(option)) < 0){
        perror(""ERROR: setsockopt failed"");
    return EXIT_FAILURE;
    }

    
  if(bind(listenfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
    perror(""ERROR: Socket binding failed"");
    return EXIT_FAILURE;
  }

  
  if (listen(listenfd, 10) < 0) {
    perror(""ERROR: Socket listening failed"");
    return EXIT_FAILURE;
    }

    printf(""=== WELCOME TO THE CHATROOM ===\n"");

    while(1){
        socklen_t clilen = sizeof(cli_addr);
        connfd = accept(listenfd, (struct sockaddr*)&cli_addr, &clilen);

        
        if((cli_count + 1) == MAX_CLIENTS){
            printf(""Max clients reached. Rejected: "");
            print_client_addr(cli_addr);
            printf("":%d\n"", cli_addr.sin_port);
            close(connfd);
            continue;
        }

        
        client_t *cli = (client_t *)malloc(sizeof(client_t));
        cli->address = cli_addr;
        cli->sockfd = connfd;
        cli->uid = uid++;

        
        queue_add(cli);
        pthread_create(&tid, NULL, &handle_client, (void*)cli);

        
        sleep(1);
    }

    return EXIT_SUCCESS;
}",18,551,1936
"#define PORT ""8888""   


void *get_in_addr(struct sockaddr *sa)
{
    if (sa->sa_family == AF_INET) {
        return &(((struct sockaddr_in*)sa)->sin_addr);
    }

    return &(((struct sockaddr_in6*)sa)->sin6_addr);
}

int main(void)
{
    fd_set master;    
    fd_set read_fds;  
    int fdmax;        

    int listener;     
    int newfd;        
    struct sockaddr_storage remoteaddr; 
    socklen_t addrlen;

    char buf[256];    
    int nbytes;

    char remoteIP[INET6_ADDRSTRLEN];

    int yes=1;        
    int i, j, rv;

    struct addrinfo hints, *ai, *p;

    FD_ZERO(&master);    
    FD_ZERO(&read_fds);

    
    memset(&hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;
    if ((rv = getaddrinfo(NULL, PORT, &hints, &ai)) != 0) {
        fprintf(stderr, ""selectserver: %s\n"", gai_strerror(rv));
        exit(1);
    }
    
    for(p = ai; p != NULL; p = p->ai_next) {
        listener = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
        if (listener < 0) { 
            continue;
        }
        
        
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));

        if (bind(listener, p->ai_addr, p->ai_addrlen) < 0) {
            close(listener);
            continue;
        }

        break;
    }

    
    if (p == NULL) {
        fprintf(stderr, ""selectserver: failed to bind\n"");
        exit(2);
    }

    freeaddrinfo(ai); 

    
    if (listen(listener, 10) == -1) {
        perror(""listen"");
        exit(3);
    }

    
    FD_SET(listener, &master);

    
    fdmax = listener; 

    
    for(;;) {
        read_fds = master; 
        if (select(fdmax+1, &read_fds, NULL, NULL, NULL) == -1) {
            perror(""select"");
            exit(4);
        }

        
        for(i = 0; i <= fdmax; i++) {
            if (FD_ISSET(i, &read_fds)) { 
                if (i == listener) {
                    
                    addrlen = sizeof remoteaddr;
                    newfd = accept(listener,
                        (struct sockaddr *)&remoteaddr,
                        &addrlen);

                    if (newfd == -1) {
                        perror(""accept"");
                    } else {
                        FD_SET(newfd, &master); 
                        if (newfd > fdmax) {    
                            fdmax = newfd;
                        }
                        printf(""selectserver: new connection from %s on ""
                            ""socket %d\n"",
                            inet_ntop(remoteaddr.ss_family,
                                get_in_addr((struct sockaddr*)&remoteaddr),
                                remoteIP, INET6_ADDRSTRLEN),
                            newfd);
                    }
                } else {
                    
                    if ((nbytes = recv(i, buf, sizeof buf, 0)) <= 0) {
                        
                        if (nbytes == 0) {
                            
                            printf(""selectserver: socket %d hung up\n"", i);
                        } else {
                            perror(""recv"");
                        }
                        close(i); 
                        FD_CLR(i, &master); 
                    } else {
                        
                        for(j = 0; j <= fdmax; j++) {
                            
                            if (FD_ISSET(j, &master)) {
                                
                                if (j != listener && j != i) {
                                    if (send(j, buf, nbytes, 0) == -1) {
                                        perror(""send"");
                                    }
                                }
                            }
                        }
                    }
                } 
            } 
        } 
    } 
    
    return 0;
}",18,552,1213
"#define PORT 8080
#define BUFSIZE 1024

struct message {
    int type;
    char data[BUFSIZE];
};


void server_set_up(int *sockfd, struct sockaddr_in *server_addr);

void connection_accept(fd_set *master, int *fdmax, int sockfd, struct sockaddr_in *client_addr);

void send_recv(int i, fd_set *master, int sockfd, int fdmax);

int main()
{
    fd_set master, read_fds;

    int fdmax, i;
    int sockfd = 0;

    struct sockaddr_in server_addr, client_addr;

    
    FD_ZERO(&master);
    FD_ZERO(&read_fds);

    server_set_up(&sockfd, &server_addr);

    
    FD_SET(sockfd, &master);

    
    fdmax = sockfd;

    while (1)
    {
        
        read_fds = master;

        
        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)
        {
            perror(""select"");
            exit(4);
        }

        
        for (i = 0; i <= fdmax; i++)
        {
            if (FD_ISSET(i, &read_fds))
            {
                if (i == sockfd)
                    
                    
                    connection_accept(&master, &fdmax, sockfd, &client_addr);
                else
                    
                    send_recv(i, &master, sockfd, fdmax);
            }
        }
    }
    return 0;
}

void server_set_up(int *sockfd, struct sockaddr_in *server_addr)
{
    if ((*sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
    {
        perror(""Socket"");
        exit(1);
    }

    
    server_addr->sin_family = AF_INET;
    server_addr->sin_port = htons(PORT);
    server_addr->sin_addr.s_addr = INADDR_ANY;

    

    
    if (bind(*sockfd, (struct sockaddr *)server_addr, sizeof(struct sockaddr)) == -1)
    {
        perror(""Unable to bind"");
        exit(1);
    }
    printf(""TCP Server Bound to Port: %d\n"", PORT);
    
    if (listen(*sockfd, 10) == -1)
    {
        perror(""listen"");
        exit(1);
    }
    printf(""TCP Server Waiting for Client Requests...\n"");
    fflush(stdout);
}


void connection_accept(fd_set *master, int *fdmax, int sockfd, struct sockaddr_in *client_addr)
{
    socklen_t addrlen = sizeof(struct sockaddr_in);
    int newsockfd;

    if ((newsockfd = accept(sockfd, (struct sockaddr *)client_addr, &addrlen)) == -1)
    {
        perror(""accept"");
        exit(1);
    } 
    else 
    {
        
        FD_SET(newsockfd, master);
        
        if (newsockfd > *fdmax)
            *fdmax = newsockfd;
        printf(""New connection at %s : %d \n"", inet_ntoa(client_addr->sin_addr), ntohs(client_addr->sin_port));
    }
}

void send_recv(int i, fd_set *master, int sockfd, int fdmax) 
{
    int recv_size, j;
    char recv_buf[BUFSIZE], buf[BUFSIZE];
    if ((recv_size = recv(i, recv_buf, BUFSIZE, 0)) <= 0)
    {
        if (recv_size == 0)
            printf(""Socket with FD: %d Hung Up\n"", i);
        else
            perror(""recv"");

        
        
        close(i);
        FD_CLR(i, master);
    }
    else
    {
        for (j = 0; j <= fdmax; j++)
        {
            
            if (FD_ISSET(j, master))
            {
                if (j != sockfd && j != i)
                {
                    if (send(j, recv_buf, recv_size, 0) == -1)
                    {
                        perror(""send"");
                    }
                }
            }
        }
        printf(""%s\n"", recv_buf);
        bzero(recv_buf, BUFSIZE);
    }
}",18,553,1243
"struct stack{
    int top;
    int cap;
    char* A;
};

int StackOverflow(struct stack* stk)
{
    if(stk->top==stk->cap-1)
        return 1;
    else 
        return 0;
}
int StackEmpty(struct stack* stk)
{
    if(stk->top==-1)
        return 1;
    else
        return 0;
}
void push(struct stack* stk, char elem){
    if(StackOverflow(stk))
    {
        printf(""%d\n"", 999);
        return;
    }
    stk->top++;
    stk->A[stk->top]=elem;
        
};
char pop(struct stack* stk){
    if(StackEmpty(stk))
    {
        printf(""%d\n"", -1);
        return('b');
    }
    stk->top--;
    return(stk->A[stk->top+1]);
};


int isMatchingPair(char character1, char character2) 
{ 
   if (character1 == '(' && character2 == ')') 
     return 1; 
   else if (character1 == '{' && character2 == '}') 
     return 1; 
   else if (character1 == '[' && character2 == ']') 
     return 1; 
   else
     return 0; 
} 


int checkParantheses(char* exp,struct stack* stk)
{
    int i;char popped;
    for(i=0;i<stk->cap;i++)
    {
        if(exp[i]=='('||exp[i]=='{'||exp[i]=='[')
        {
            push(stk,exp[i]);
        }
        else if(exp[i]==')'||exp[i]=='}'||exp[i]==']')
        {
            popped=pop(stk);
            if(!(isMatchingPair(popped,exp[i])))
            {
                return 0;
            }
        }
    }
    return 1;
}

int main()
{

    char sel;
    int p;
    FILE* fp1;
    FILE* fp2;
    fp1=fopen(""input.txt"",""r""); 
    fp2=fopen(""output.txt"",""w"");    
    char exp[10000];        
    while(1)    
    {
        int i=0;
        fscanf(fp1,""%c"",&sel);
        if(sel=='e')
        {
            fgetc(fp1);
            fscanf(fp1,""%[^\n]"",exp);
            i=strlen(exp);
            fgetc(fp1);
            struct stack* stk=(struct stack*)malloc(sizeof(struct stack));
            stk->A=(char*)malloc(i);
            stk->top=-1;
            stk->cap=i;
            
            p=checkParantheses(exp,stk);
            if(p==0)
            {
                fprintf(fp2, ""NO\n"");
            }
            else
                fprintf(fp2,""YES\n"");
        }
        else if(sel=='s')
            break;
    }

}















",18,554,850
"#define PORT 8080
#define BUFFER_SIZE 1024
#define SERVE_BACKLOG 3

#define MAX_THREADS 100


int sockets[MAX_THREADS]={0};

void* communication(void* new_socket);


int main(int argc, char const *argv[]) 
{ 
    int server_fd, new_socket, n; 
    struct sockaddr_in server_address, client_address; 
    char buffer[BUFFER_SIZE] = {0}; 
    
    
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) 
    { 
        perror(""socket failed""); 
        exit(EXIT_FAILURE); 
    } 
    printf(""TCP Socket Created!\n"");

    
    
    server_address.sin_family = AF_INET; 
    server_address.sin_addr.s_addr = INADDR_ANY; 
    server_address.sin_port = htons( PORT ); 
    
    
    if (bind(server_fd, (struct sockaddr *)&server_address, sizeof(server_address))<0) 
    { 
        perror(""bind failed""); 
        exit(EXIT_FAILURE); 
    }
    printf(""Socket bound to 0.0.0.0: 8080\n"");

    
    if(listen(server_fd, SERVE_BACKLOG) < 0) 
    { 
        perror(""listen""); 
        exit(EXIT_FAILURE); 
    } 
    printf(""Listening on Port: 8080\n"");
    int i = 0;
    while(1) {
        
        
        int addrlen = sizeof(client_address); 
        if ((new_socket = accept(server_fd, (struct sockaddr *)&client_address, (socklen_t*)&addrlen))<0) 
        { 
            perror(""accept""); 
            exit(EXIT_FAILURE); 
        } 
        
        
        
        
        printf(""Connected to %s:%d\n"", inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));

        pthread_t t;
        int* pclient = malloc(sizeof(int));
        *pclient = new_socket;
        sockets[i++] = new_socket;
        
        

        pthread_create(&t, NULL, communication, pclient);

    }
    
    close(server_fd);
    printf(""Server Closed.\n"");
    return 0; 
} 

void* broadcast(char* buffer, int socketfd) {
    for(int i = 0; i<50; i++) {
        if(sockets[i]!=0) {
            char name[5] = ""Name:"";
            strcat(name, buffer);
            send(sockets[i], name, strlen(name) , 0);
        } else {
            break;
        }
    }
}

void* communication(void* pclient) {
    int new_socket = *((int*)pclient);
    free(pclient);
    int n;
    char buffer[BUFFER_SIZE] = {0}; 
    while(1) {
        bzero(buffer, BUFFER_SIZE);
        n = recv( new_socket , buffer, BUFFER_SIZE, 0); 
        if(n<0) {
            printf(""Reading Error!\n"");
        }
        printf(""Client: %s\n"", buffer);
        if(strncmp(buffer, ""close"", 5)==0) {
            printf(""Client with Socketfd: %d disconnected!\n"", new_socket);
            bzero(buffer, BUFFER_SIZE);
            return NULL;
        }
        
        
        
        
        
        
        
        send(new_socket , buffer , strlen(buffer) , 0); 
    }
    return NULL;
}

",18,555,1023
"#define PORT 8080 

int main(int argc, char const *argv[]) 
{ 
    int server_fd, new_socket, n; 
    struct sockaddr_in server_address, client_address; 
    char buffer[1024] = {0}; 
    
    
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) 
    { 
        perror(""socket failed""); 
        exit(EXIT_FAILURE); 
    } 
    printf(""TCP Socket Created!\n"");

    
    
    server_address.sin_family = AF_INET; 
    server_address.sin_addr.s_addr = INADDR_ANY; 
    server_address.sin_port = htons( PORT ); 
    
    
    if (bind(server_fd, (struct sockaddr *)&server_address, sizeof(server_address))<0) 
    { 
        perror(""bind failed""); 
        exit(EXIT_FAILURE); 
    }
    printf(""Socket bound to 0.0.0.0: 8080\n"");

    
    if(listen(server_fd, 3) < 0) 
    { 
        perror(""listen""); 
        exit(EXIT_FAILURE); 
    } 
    printf(""Listening on Port: 8080\n"");

    
    
    int addrlen = sizeof(client_address); 
    if ((new_socket = accept(server_fd, (struct sockaddr *)&client_address, (socklen_t*)&addrlen))<0) 
    { 
        perror(""accept""); 
        exit(EXIT_FAILURE); 
    } 
    
    
    
    
    printf(""Connected to %s:%d\n"", inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));

    
    while(1) {
        bzero(buffer, 1024);
        n = recv( new_socket , buffer, 1024, 0); 
        if(n<0) {
            printf(""Reading Error!\n"");
        }
        printf(""Client: %s\n"", buffer);
        bzero(buffer, 1024);
        printf(""Enter Server's Message:"");
        fgets(buffer, 1024, stdin);
        if(strncmp(buffer, ""close"", 5)==0) {
            close(new_socket);
            break;
        }
        send(new_socket , buffer , strlen(buffer) , 0 ); 
    }

    
    close(server_fd);
    printf(""Server Closed.\n"");
    return 0; 
} 

",18,556,710
"#define BUFSIZE 1024
#define LO ""127.0.0.1""
#define PORT 8080


void str_trim_lf(char *arr, int length);

void connect_request(int *sockfd, struct sockaddr_in *server_addr);
void send_recv(int i, int sockfd, char name[32], fd_set* master);

int main()
{
    int sockfd, fdmax, i;
    struct sockaddr_in server_addr;
    fd_set master;
    fd_set read_fds;
    char name[32];
    char new_entry_message[42];

    
    printf(""Please enter your name: "");
    fgets(name, 32, stdin);
    str_trim_lf(name, strlen(name));

    if (strlen(name) > 32 || strlen(name) < 2)
    {
        printf(""Name must be less than 30 and more than 2 characters.\n"");
        return EXIT_FAILURE;
    }

    connect_request(&sockfd, &server_addr);

    
    strcpy(new_entry_message, name);
    strcat(new_entry_message, "" joined!"");
    send(sockfd, new_entry_message, 32, 0);

    
    FD_ZERO(&master);
    FD_ZERO(&read_fds);

    
    
    FD_SET(0, &master);
    FD_SET(sockfd, &master);

    
    printf(""\n--------------------- WELCOME TO THE CHATROOM ---------------------\n"");

    fdmax = sockfd;

    while (1)
    {
        
        read_fds = master;
        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)
        {
            perror(""select"");
            exit(4);
        }
        
        for (i = 0; i <= fdmax; i++)
            if (FD_ISSET(i, &read_fds))
               send_recv(i, sockfd, name, &master);
    }
    
    printf(""Bye\n"");
    close(sockfd);
    return 0;
}


void connect_request(int *sockfd, struct sockaddr_in *server_addr)
{
    if ((*sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
    {
        perror(""Socket"");
        exit(1);
    }

    server_addr->sin_family = AF_INET;
    server_addr->sin_port = htons(PORT);
    server_addr->sin_addr.s_addr = inet_addr(LO);

    if (connect(*sockfd, (struct sockaddr *)server_addr, sizeof(struct sockaddr)) == -1)
    {
        perror(""connect"");
        exit(1);
    }
}

void send_recv(int i, int sockfd, char name[32], fd_set* master)
{
    char in_buf[BUFSIZE];
    char send_buf[BUFSIZE+32]="""";
    char recv_buf[BUFSIZE];
    char disconnect_mssge[32];
    int nbyte_recvd;
    if (i == 0)
    {
        fgets(in_buf, BUFSIZE, stdin);
        str_trim_lf(in_buf, BUFSIZE);

        sprintf(send_buf, ""%s > %s"", name, in_buf);

        if (strncmp(in_buf,""tata"", 4) == 0)
        {
            sprintf(disconnect_mssge,""%s left the chat."", name);
            send(sockfd, disconnect_mssge, strlen(disconnect_mssge), 0);
            FD_CLR(i, master);
            close(i);
            close(sockfd);
            exit(0);
        }
        else
            send(sockfd, send_buf, strlen(send_buf), 0);
        bzero(send_buf, BUFSIZE);
    }
    else
    {
        nbyte_recvd = recv(sockfd, recv_buf, BUFSIZE, 0);
        recv_buf[nbyte_recvd] = '\0';
        printf(""%s\n"", recv_buf);
    }
}


void str_trim_lf(char *arr, int length) {
    int i;
    for (i = 0; i < length; i++)
    {
        
        if (arr[i] == '\n')
        {
            arr[i] = '\0';
            break;
        }
    }
}

",18,557,1228
"FILE* F1;
FILE* F2;

int search_shift(int a[],int n)
{
    int str = 0;
    int end = n-1;
    int mid = (end + str)/2;
    if(a[n-1] > a[str])
    {
        return 0;
    }
    while(end>str)
    {
        mid = (end+str)/2;
        if(a[mid-1]> a[mid]){
            return mid;
        }
        else if(a[mid-1]<=a[mid] && a[mid]<=a[end])
        {
            end = mid;
        }
        else if(a[mid - 1]<= a[mid] && a[mid]>=a[end])
        {
            str = mid;
        }
    }
    return 0;
        
}
int* read(int n)
{
        int i;
        int s = sizeof(int);
        int* arr1= (int*)malloc(s * n);
        for(i = 0; i<n; i++)
        {
                fscanf(F1, ""%d"", (arr1+i));
        }
        return arr1;
}

void display(int arr2[], int n)
{
        int i;
        for(i = 0; i<n; i++)
        {
                fprintf(F2, ""%d "", arr2[i]);
        }

}

int main(int argc, char* argv[])
{
    int search_shift(int a[], int);
    int num; char s;int size;
        int* arr;
        F1 = fopen(argv[1], ""r"");
        F2 = fopen(argv[2], ""w"");
        while(1)
        {
        fscanf(F1 ,""%c"",&s);
        if(s == 'r')
        {
        fscanf(F1, ""%d"", &num);
                size = num;
                arr = read(num);

        }
        else if(s == 's')
        {
                int p = search_shift(arr, size);
                fprintf(F2,""%d\n"", p);
        }

        else if(s == 'd')
        {
                display(arr, size);
                fprintf(F2, ""\n"");
        }
    else if(s == 't')
        return 0;
    }
    fclose(F1);
    fclose(F2);
}
",18,558,630
"FILE *F1;
FILE *F2;

void read(int A[],int n)
{
    int i;
    for(i=0;i<n;i++)
    fscanf(F1,""%d"",&A[i]);
}

void checkSubset(int X[],int m,int Y[],int n)
{
    int i,j,flag=0;
    for(i=0;i<n;i++)
     {
         for(j=0;j<m;j++)
         {
             if(Y[i]==X[j])
              {
                  flag++;
                  break;
              }
         }  
     }
     if(flag==n)
       fprintf(F2,""true"");
     else
       fprintf(F2,""false"");
}
int main(int argc,char *argv[])
{
    char s;
    int m,n,x,p,k;
    int *X,*Y;
    int count=0;
    F1=fopen(argv[1],""r"");
    F2=fopen(argv[2],""w"");
    if(F1==NULL)
        printf(""cant open file"");
    else
        {
        while(1)
         {
            fscanf(F1,""%c"",&s);
            if(s=='r')
                {
                    count++;
                    if(count%2!=0)
                     { 
                         fscanf(F1,"" %d"",&m);
                         X = (int*) malloc(m* sizeof(int));
                         read(X,m);
                     }
                    else
                     {
                         fscanf(F1,"" %d"",&n);
                         Y = (int*) malloc(n* sizeof(int));
                         read(Y,n);
                     }
                 }    
            else if(s=='c')
                 {        
                      checkSubset(X,m,Y,n);
                 }
            else if(s=='t')
                break;
            }

         }
    fclose(F1);
    fclose(F2);

}
",18,559,534
"struct Node{
    int data;
    struct Node* next;
};

typedef struct Node* node;

node createNode()
{
    node t=(node)malloc(sizeof(struct Node));
    if(t==NULL)
        {
            printf(""Memory not allocated for node"");
            exit(0);
        }
    t->next=NULL;
    return t;
}


void enqueue(struct Node** head_ref, int new_data) 
{ 
    struct Node* new_node = createNode();
    struct Node *last = *head_ref;
    new_node->data  = new_data; 

    if (*head_ref == NULL) 
    { 
       *head_ref = new_node; 
       return; 
    }   
    while (last->next != NULL) 
        last = last->next; 
    last->next = new_node; 
    return;     
}

int find_size(node head)
{
    node p;
    int n=0;
    p=head;
    while(p!=NULL)
    {
        n++;
        p=p->next;
    }
    return n;
}

void print(node head,int n,FILE *fp2)
{

  node temp=head;
  int count=0;
  node p=head;
  if(head==NULL)
    {
      fprintf(fp2,""-1\n"");
      return;
    }
  int size=find_size(head);

  if(n==0 || n>size)
  {
    while(temp!=NULL)
   {
    fprintf(fp2,""%d"",temp->data);
    temp=temp->next;
    if(temp==NULL)
    {
      if(n>size)
        fprintf(fp2,"" END"");
      fprintf(fp2,""\n"");
    }
    else
      fprintf(fp2,"" "");
   }
   return;
  }
  if(n>0 && n<=size)
   {
    while(count<n)
    {
      fprintf(fp2,""%d"",p->data);
      p=p->next;
      count++;
      if(count==n)
        fprintf(fp2,""\n"");
      else 
        fprintf(fp2,"" "");
    }   
   }
}


int dequeue(node* head)
{
  node p;
  int dequeued;
  if(*head==NULL)
      return -1;
  dequeued=(*head)->data;
  p=(*head)->next;
  free(*head);
  *head=p;
  return dequeued;
}

int main()
{
    FILE* fp1;
    FILE* fp2;
    fp1=fopen(""input.txt"",""r"");
    fp2=fopen(""output.txt"",""w"");
    node Q=NULL;
    char sel;
    int elem,num,temp=0;
    while(1)
    {
        fscanf(fp1,""%c"",&sel);
        if(sel=='e')
        {
            fscanf(fp1,""%d"",&elem);
            enqueue(&Q, elem);
        }
        else if(sel=='p')
        {
            fscanf(fp1,""%d"",&num);
            print(Q,num,fp2);
        }
        else if(sel=='d')
        {
            temp=dequeue(&Q);
            fprintf(fp2,""%d\n"",temp);
        }
        else if(sel=='s')
        {
            break;
        }
    }
    fclose(fp1);
    fclose(fp2);
}",18,560,927
"#define PORT     8089 
#define MAXLINE 1024 


int main() { 
    int sockfd; 
    char buffer[MAXLINE]; 
    char *hello = ""Hello from server""; 
    struct sockaddr_in servaddr, cliaddr; 
    
    
    if ( (sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) { 
        perror(""socket creation failed""); 
        exit(EXIT_FAILURE); 
    } 
    
    memset(&servaddr, 0, sizeof(servaddr)); 
    memset(&cliaddr, 0, sizeof(cliaddr)); 
    
    
    servaddr.sin_family = AF_INET; 
    servaddr.sin_addr.s_addr = INADDR_ANY; 
    servaddr.sin_port = htons(PORT); 
    
    
    if ( bind(sockfd, (const struct sockaddr *)&servaddr, sizeof(servaddr)) < 0 ) 
    { 
        perror(""bind failed""); 
        exit(EXIT_FAILURE); 
    } 
    
    int len, n; 

    len = sizeof(cliaddr); 

    n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL, ( struct sockaddr *) &cliaddr, &len); 
    buffer[n] = '\0'; 
    printf(""Client : %s\n"", buffer); 
    sendto(sockfd, (const char *)hello, strlen(hello),MSG_CONFIRM, (const struct sockaddr *) &cliaddr, 
            len); 
    printf(""Hello message sent.\n""); 
    
    return 0; 
} 
",18,561,443
"FILE *F1;
FILE *F2;

struct bucket
{
    int count;
    int* value;
};


void read(int A[],int n)
{
  int i;
  for(i=0;i<n;i++)
   fscanf(F1,""%d"",&A[i]);
}
void display(int A[],int n)
{
  int i;
  for(i=0;i<n;i++)
  {
        fprintf(F2,""%d "",A[i]);
        if(i==(n-1))
        fprintf(F2,""\n"");}
}
int findMax_digits(int a[],int n)
{
  int i,digits=0,num;
  int max=0;
  int level=1;
  for(i=1;i<n;i++)
   {
     if(a[i]>a[max])
       max=i;
   }
  num=a[max];
  if(num==0)
   return 0;
  while(num>=level)
   {
     digits++;
     level*=2;
   }
  return digits;
}
void form_binary(int a[],int n,int q,int bin[n][q])
{

  int i,j,num;
  for(i=0;i<n;i++)
   {
    num=a[i];
    j=q-1;
    while(num>0)
      {
           bin[i][j]=num%2;
           num/=2;
           j--;
      }
   }
}
void count_ones(int n,int q,int a[n][q],int one[])
{
int i,j;
  for(i=0;i<n;i++)
    for(j=0;j<q;j++)
        {if(a[i][j]==1)
         one[i]++;
        }
}

void insertionSort(int arr[], int n)
{
    int i, key, j;
    for (i = 1; i < n; i++)
    {
        key = arr[i];
        j = i - 1;
        while (j >= 0 && arr[j] > key)
        {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
 }
void bucketSort(int A[],int n)
 {  int i,j,k,flag=0;
    int dig=0;
    dig=findMax_digits(A,n);
    int binarr[n][dig];
    for (i = 0; i < n; i++)
     for (j = 0; j < dig; j++)
      binarr[i][j]=0;
    form_binary(A,n,dig,binarr);
    int one[n];
    for (i = 0; i < n; i++)
     {one[i]=0;
      }
    count_ones(n,dig,binarr,one);
    int max=0;
    for(i=1;i<n;i++)
     {
       if(one[i]>one[max])
       max=i;
     }
    int bucket_nos;
     bucket_nos=one[max]+1;

    struct bucket buckets[bucket_nos];
    for (i = 0; i <= bucket_nos; i++)
    {
        buckets[i].count = 0;
        buckets[i].value = (int*)malloc(sizeof(int) * n);
    }

    for (i = 0; i < n; i++)
      buckets[one[i]].value[buckets[one[i]].count++] = A[i];
    for (k = 0, i = 0; i <= bucket_nos; i++)
    {
        if(buckets[i].count!=0)
          insertionSort(buckets[i].value,buckets[i].count);
        for (j = 0; j < buckets[i].count; j++)
                    A[k + j] = buckets[i].value[j];
        k+=buckets[i].count;
    }

        for(i=0;i<= bucket_nos;i++)
        {
                if(buckets[i].count!=0)
                display(buckets[i].value,buckets[i].count);

        }
}

int main(int argc,char *argv[])
  {     char ch;
        int n,x,p;
        int *arr;
        F1=fopen(argv[1],""r"");
        F2=fopen(argv[2],""w"");
        if(F1==NULL)
         printf(""cant open file"");
        else
          {
          while(1)
           {
             fscanf(F1,""%c"",&ch);
             if(ch=='r')
             {
               fscanf(F1,"" %d"",&n);
               arr= (int*) malloc(n* sizeof(int));
               read(arr,n);
             }
            else if(ch=='d')
             {
               fscanf(F1,""%d"",&p);
               display(arr,n);
             }
             else if(ch=='s')
             {
              bucketSort(arr,n);
             }
             else if(ch=='t')
               break;
           }

         }
   fclose(F1);
   fclose(F2);

}
                       
",18,562,1392
"FILE* F1;
FILE* F2;
int* read(int n)
{
        int i;
        int s = sizeof(int);
        int* arr1= (int*)malloc(s * n);
        for(i = 0; i<n; i++)
        {
                fscanf(F1, ""%d"", (arr1+i));
        }
        return arr1;
}



void display(int arr2[], int n)
{
        int i;
        for(i = 0; i<n; i++)
        {
                fprintf(F2, ""%d "", arr2[i]);
        }

}


void swap(int *a, int *b) 
{ 
    int temp = *a; 
    *a = *b; 
    *b = temp; 
} 
  
void bubbleSort(int arr[], int n) 
{ 
   int i, j; 
   for (i = 0; i < n-1; i++)       
       for (j = 0; j < n-i-1; j++)
    { 
       if(arr[j]>=0 && arr[j+1]>=0)
       {
           if (arr[j] > arr[j+1]) 
              swap(&arr[j], &arr[j+1]);
       } 
       else if(arr[j]>0 && arr[j+1]<0)
       {
          for(int m = 0; m<n-j; m++)
          {
            if(arr[j+m]<arr[j] && arr[j+m]>=0)
            {
              swap(&arr[j+m], &arr[j]);
              break;
            }
          }
       }
       else if(arr[j]<0)
          continue;
   }
} 


int main(int argc, char* argv[]) 
{ 
    int num; char s;int size;
        int* arr;
        F1 = fopen(argv[1], ""r"");
        F2 = fopen(argv[2], ""w"");
        while(1)
        {
        fscanf(F1 ,""%c %d"",&s, &num);
        if(s == 'r')
        {
                size = num;
                arr = read(num);

        }
        else if(s == 's')
        {
                bubbleSort(arr, size);
        display(arr, size);
        }

        else if(s == 'd')
        {
                display(arr, size);
                fprintf(F2, ""\n"");
        }
        else if(s == 't')
                return 0;
        }
} 
",18,563,675
"struct Stack 
{ 
    int top; 
    unsigned capacity; 
    int* array; 
}; 
  
struct Stack* createStack( unsigned capacity ) 
{ 
    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack)); 
  
    if (!stack)  
        return NULL; 
  
    stack->top = -1; 
    stack->capacity = capacity; 
  
    stack->array = (int*) malloc(stack->capacity * sizeof(int)); 
  
    if (!stack->array) 
        return NULL; 
    return stack; 
} 
int isEmpty(struct Stack* stack) 
{ 
    return stack->top == -1 ; 
} 
char peek(struct Stack* stack) 
{ 
    return stack->array[stack->top]; 
} 
char pop(struct Stack* stack) 
{ 
    if (!isEmpty(stack)) 
        return stack->array[stack->top--] ; 
    return '$'; 
} 
void push(struct Stack* stack, char op) 
{ 
    stack->array[++stack->top] = op; 
} 
  
int isOperand(char ch) 
{ 
    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'); 
} 
  
int Prec(char ch) 
{ 
    switch (ch) 
    { 
    case '+': 
    case '-': 
        return 1; 
  
    case '*': 
    case '/': 
        return 2; 
  
    case '^': 
        return 3; 
    } 
    return -1; 
} 
  
void infixToPostfix(char* exp) 
{ 
    int i, k; 
  
    struct Stack* stack = createStack(strlen(exp));  

    for (i = 0, k = -1; exp[i]; ++i) 
    { 
 
        if (isOperand(exp[i])) 
            exp[++k] = exp[i]; 
          
        else if (exp[i] == '(') 
            push(stack, exp[i]); 
          

        else if (exp[i] == ')') 
        { 
            while (!isEmpty(stack) && peek(stack) != '(') 
                exp[++k] = pop(stack); 
            if (!isEmpty(stack) && peek(stack) != '(') 
                return;             
            else
                pop(stack); 
        } 
        else
        { 
            while (!isEmpty(stack) && Prec(exp[i]) <= Prec(peek(stack))) 
                exp[++k] = pop(stack); 
            push(stack, exp[i]); 
        } 
  
    } 

    while (!isEmpty(stack)) 
        exp[++k] = pop(stack); 
  
    exp[++k] = '\0'; 
} 

int main(int argc,char *argv[])
{
    char ch,temp;
    char exp[10000];
    FILE *fp1;
    FILE *fp2;
    fp1=fopen(""input.txt"",""r"");
    fp2=fopen(""output.txt"",""w"");
    while(1)
         {
            fscanf(fp1,""%c"",&ch);
            if(ch=='e')
            {
                fgetc(fp1);
                fscanf(fp1,""%[^\n]"",exp);
                infixToPostfix(exp);
                fprintf(fp2,""%s\n"",exp);
            }
            else if(ch=='s')
                break;

        }

    fclose(fp1);
    fclose(fp2);
    return 0;
}
",18,564,963
"#define PORT 8080
#define BUFFER_SIZE 1024
#define SERVE_BACKLOG 3

void communication(int new_socket);


int main(int argc, char const *argv[]) 
{ 
    int server_fd, new_socket, n; 
    struct sockaddr_in server_address, client_address; 
    char buffer[BUFFER_SIZE] = {0}; 
    
    
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) 
    { 
        perror(""socket failed""); 
        exit(EXIT_FAILURE); 
    } 
    printf(""TCP Socket Created!\n"");

    
    
    server_address.sin_family = AF_INET; 
    server_address.sin_addr.s_addr = INADDR_ANY; 
    server_address.sin_port = htons( PORT ); 
    
    
    if (bind(server_fd, (struct sockaddr *)&server_address, sizeof(server_address))<0) 
    { 
        perror(""bind failed""); 
        exit(EXIT_FAILURE); 
    }
    printf(""Socket bound to 0.0.0.0: 8080\n"");

    
    if(listen(server_fd, SERVE_BACKLOG) < 0) 
    { 
        perror(""listen""); 
        exit(EXIT_FAILURE); 
    } 
    printf(""Listening on Port: 8080\n"");

    while(1) {
        
        
        int addrlen = sizeof(client_address); 
        if ((new_socket = accept(server_fd, (struct sockaddr *)&client_address, (socklen_t*)&addrlen))<0) 
        { 
            perror(""accept""); 
            exit(EXIT_FAILURE); 
        } 
        
        
        
        
        printf(""Connected to %s:%d\n"", inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));

        
        communication(new_socket);

    }
    
    close(server_fd);
    printf(""Server Closed.\n"");
    return 0; 
} 

void communication(int new_socket) {
    int n;
    char buffer[BUFFER_SIZE] = {0}; 
    while(1) {
        bzero(buffer, BUFFER_SIZE);
        n = recv( new_socket , buffer, BUFFER_SIZE, 0); 
        if(n<0) {
            printf(""Reading Error!\n"");
        }
        printf(""Client: %s\n"", buffer);
        if(strncmp(buffer, ""close"", 5)==0) {
            printf(""Client with Socketfd: %d disconnected!\n"", new_socket);
            bzero(buffer, BUFFER_SIZE);
            return;
        }
        bzero(buffer, BUFFER_SIZE);
        printf(""Enter Server's Message:"");
        fgets(buffer, BUFFER_SIZE, stdin);
        if(strncmp(buffer, ""close"", 5)==0) {
            close(new_socket);
            break;
        }
        send(new_socket , buffer , strlen(buffer) , 0 ); 
    }
}

",18,565,859
"#define PORT     8089 
#define MAXLINE 1024 


int main() { 
    int sockfd; 
    char buffer[MAXLINE]; 
    char *hello = ""Hello from server""; 
    struct sockaddr_in servaddr, cliaddr; 
    
    
    if ( (sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) { 
        perror(""socket creation failed""); 
        exit(EXIT_FAILURE); 
    } 
    
    memset(&servaddr, 0, sizeof(servaddr)); 
    memset(&cliaddr, 0, sizeof(cliaddr)); 
    
    
    servaddr.sin_family = AF_INET; 
    servaddr.sin_addr.s_addr = INADDR_ANY; 
    servaddr.sin_port = htons(PORT); 
    
    
    if ( bind(sockfd, (const struct sockaddr *)&servaddr, 
            sizeof(servaddr)) < 0 ) 
    { 
        perror(""bind failed""); 
        exit(EXIT_FAILURE); 
    } 
    
    int len, n; 

    len = sizeof(cliaddr); 

    n = recvfrom(sockfd, (char *)buffer, MAXLINE, 
                MSG_WAITALL, ( struct sockaddr *) &cliaddr, 
                &len); 
    buffer[n] = '\0'; 
    printf(""Client : %s\n"", buffer); 
    sendto(sockfd, (const char *)hello, strlen(hello), 
        MSG_CONFIRM, (const struct sockaddr *) &cliaddr, 
            len); 
    printf(""Hello message sent.\n""); 
    
    return 0; 
} 
",18,566,455
"#define SERVER ""127.0.0.1""
#define BUFLEN 512  
#define PORT 8888   

void error(char *s)
{
    perror(s);
    exit(1);
}



int main(void)
{
    struct sockaddr_in si_client;
    int socket_udp, i, slen=sizeof(si_client);
    char buf[BUFLEN];
    char message[BUFLEN];

    if ((socket_udp=socket(AF_INET, SOCK_DGRAM, 0)) == -1)
    {
        error(""socket"");
    }

    memset((char *) &si_client, 0, sizeof(si_client));

    si_client.sin_family = AF_INET;
    si_client.sin_port = htons(PORT);
    if (inet_aton(SERVER , &si_client.sin_addr) == 0) 
    {
        fprintf(stderr, ""inet_aton() failed\n"");
        exit(1);
    }

    while(1)
    {
        printf(""Enter message : "");
        fgets(message, 512, stdin);
        
        if(strncmp(message, ""close"", 5)==0) {
            close(socket_udp);
            exit(0);
        }
        
        if (sendto(socket_udp, message, strlen(message) , 0 , (struct sockaddr *) &si_client, slen)==-1)
        {
            error(""sendto()"");
        }
        
        
        memset(buf,'\0', BUFLEN);

        
        
        if (recvfrom(socket_udp, buf, BUFLEN, 0, (struct sockaddr *) &si_client, &slen) == -1)
        {
            error(""recvfrom()"");
        }
        
        puts(buf);
    }

    close(socket_udp);
    return 0;
}",18,567,518
"#define BUFSIZE 1024
#define LO ""127.0.0.1""
#define PORT 8080







struct message
{
    int type;
    char name[32];
    char data[BUFSIZE];
};

void trim_newline(char *arr, int length);

void connect_request(int *sockfd, struct sockaddr_in *server_addr);
void send_recv(int i, int sockfd, char name[32], fd_set *master);

int main()
{
    int sockfd, fdmax, i;
    struct sockaddr_in server_addr;
    fd_set master;
    fd_set read_fds;
    char name[32];
    char password[32];
    char new_entry_message[45];

    
    printf(""Please enter your name: "");
    fgets(name, 32, stdin);
    trim_newline(name, strlen(name));
    if (strlen(name) > 32 || strlen(name) < 2)
    {
        printf(""Name must be less than 30 and more than 2 characters.\n"");
        return EXIT_FAILURE;
    }
    printf(""Please enter your password: "");
    fgets(password, 32, stdin);
    trim_newline(password, strlen(password));

    
    connect_request(&sockfd, &server_addr);

    
    struct message new_member_message;
    new_member_message.type = 1;
    strcpy(new_member_message.name, name);
    strcpy(new_member_message.data, password);
    send(sockfd, &new_member_message, sizeof(struct message), 0);

    
    FD_ZERO(&master);
    FD_ZERO(&read_fds);

    
    
    FD_SET(0, &master);
    FD_SET(sockfd, &master);

    printf(""\nWelcome to Project COBRA\n"");

    fdmax = sockfd;
    while (1)
    {
        
        read_fds = master;
        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)
        {
            perror(""select"");
            exit(4);
        }
        
        for (i = 0; i <= fdmax; i++)
            if (FD_ISSET(i, &read_fds))
                send_recv(i, sockfd, name, &master);
    }
    close(sockfd);
    return 0;
}

void connect_request(int *sockfd, struct sockaddr_in *server_addr)
{
    if ((*sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
    {
        perror(""Socket"");
        exit(1);
    }

    server_addr->sin_family = AF_INET;
    server_addr->sin_port = htons(PORT);
    server_addr->sin_addr.s_addr = inet_addr(LO);

    if (connect(*sockfd, (struct sockaddr *)server_addr, sizeof(struct sockaddr)) == -1)
    {
        perror(""connect"");
        exit(1);
    }
}
int cnt = 0;
void send_recv(int i, int sockfd, char name[32], fd_set *master)
{
    char in_buf[BUFSIZE];
    char send_buf[BUFSIZE + 32] = """";
    char recv_buf[BUFSIZE];
    char disconnect_mssge[32];
    struct message send_message, recv_message;
    int nbyte_recvd;
    if (i == 0)
    {
        fgets(in_buf, BUFSIZE, stdin);
        trim_newline(in_buf, BUFSIZE);

        
        send_message.type = 0;
        strcpy(send_message.name, name);
        sprintf(send_message.data, ""%s"", in_buf);

        if (strncmp(in_buf, ""bye"", 3) == 0)
        {
            send_message.type = 2;
            sprintf(send_message.data, ""left the discussion"");
            send(sockfd, &send_message, sizeof(struct message), 0);
            FD_CLR(i, master);
            close(i);
            close(sockfd);
            exit(0);
        }
        else
            send(sockfd, &send_message, sizeof(struct message), 0);
        bzero(in_buf, BUFSIZE);
    }
    else
    {
        nbyte_recvd = recv(sockfd, &recv_message, sizeof(struct message), 0);
        if (nbyte_recvd == 0) {
            close(sockfd);
            exit(1);
        }
        if (recv_message.type == 0)
        {
            printf(""[%s]: %s\n"", recv_message.name, recv_message.data);
        }
        else if (recv_message.type == 1)
        {
            printf(""%s joined the chat!\n"", recv_message.name);
        }
        else if (recv_message.type == 2)
        {
            printf(""%s left the chat!\n"", recv_message.name);
        }
        else if (recv_message.type == 3)
        {
            printf(""%d. %s is present\n"", ++cnt, recv_message.name);
        }
        else if (recv_message.type == 4) 
        {
            printf(""Sorry Wrong Password. Try Again to Enter\n"");
            close(sockfd);
            exit(0);
        }
    }
}

void trim_newline(char *arr, int length)
{
    int i;
    for (i = 0; i < length; i++)
    {
        
        if (arr[i] == '\n')
        {
            arr[i] = '\0';
            break;
        }
    }
}
",18,568,1572
"#define MAX 80 
#define PORT 8080 
#define SA struct sockaddr 


void comm(int sockfd) 
{ 
    char buff[MAX]; 
    int n; 
    
    while(1) { 
        bzero(buff, MAX); 

        
        read(sockfd, buff, sizeof(buff)); 
        
        printf(""From client: %s\t To client : "", buff); 
        bzero(buff, MAX); 
        n = 0; 
        
        while ((buff[n++] = getchar()) != '\n'); 

        
        write(sockfd, buff, sizeof(buff)); 

        
        if (strncmp(""close"", buff, 5) == 0) { 
            printf(""Server Exit!\n""); 
            break; 
        } 
    } 
} 


int main() 
{ 
    int sockfd, connfd, len; 
    struct sockaddr_in servaddr, cli; 

    
    sockfd = socket(AF_INET, SOCK_STREAM, 0); 
    if (sockfd == -1) { 
        printf(""socket creation failed...\n""); 
        exit(0); 
    } 
    else
        printf(""Socket successfully created..\n""); 
    bzero(&servaddr, sizeof(servaddr)); 

    
    servaddr.sin_family = AF_INET; 
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY); 
    servaddr.sin_port = htons(PORT); 

    
    if ((bind(sockfd, (SA*)&servaddr, sizeof(servaddr))) != 0) { 
        printf(""socket bind failed...\n""); 
        exit(0); 
    } 
    else
        printf(""Socket successfully binded..\n""); 

    
    if ((listen(sockfd, 5)) != 0) { 
        printf(""Listen failed...\n""); 
        exit(0); 
    } 
    else
        printf(""Server listening..\n""); 
    len = sizeof(cli); 

    
    connfd = accept(sockfd, (SA*)&cli, &len); 
    if (connfd < 0) { 
        printf(""server acccept failed...\n""); 
        exit(0); 
    } 
    else
        printf(""server acccept the client...\n""); 

    
    comm(connfd); 

    
    close(sockfd); 
} 

",18,569,643
"struct stack{
    int top;
    int cap;
    int* A;
};

int StackOverflow(struct stack* stk)
{
    if(stk->top==stk->cap-1)
        return 1;
    else 
        return 0;
}
int StackEmpty(struct stack* stk)
{
    if(stk->top==-1)
        return 1;
    else
        return 0;
}
void push(struct stack* stk, int elem,FILE* fp2){
    if(StackOverflow(stk))
    {
        fprintf(fp2, ""%d\n"", 999);
        return;
    }
    stk->top++;
    stk->A[stk->top]=elem;
        
};
void pop(struct stack* stk,FILE* fp2){
    if(StackEmpty(stk))
    {
        fprintf(fp2, ""%d\n"", -1);
        return;
    }
    stk->top--;
    fprintf(fp2,""%d\n"",stk->A[stk->top+1]);
};
void print(struct stack* stk,int n,FILE* fp2)
{
    int i;
    int top1=stk->top;
    if(StackEmpty(stk))
    {
        fprintf(fp2, ""%d\n"",-1);
        return;
    }
    if(n==0)
    {
        for(i=top1;i>=0;i--)
        {
            fprintf(fp2, ""%d "",stk->A[i]);
        }
        fprintf(fp2, ""\n"");
    }
    else if(n>0)
    {
        if(n<=top1+1)
        {
            for(i=0;i<n;i++)
                {
                    fprintf(fp2, ""%d "", stk->A[top1-i]);
                }
                        fprintf(fp2, ""\n"");
        }
        else if(n>top1+1)
        {
            for(i=top1;i>=0;i--)
            {
                fprintf(fp2, ""%d "",stk->A[i]);
            }
            fprintf(fp2, ""END\n"");
        }   
    }
}
int main()
{
    int num;
    char sel;
    int n1; int capacity;

    FILE* fp1;
    FILE* fp2;
    fp1=fopen(""input.txt"",""r"");
    fp2=fopen(""output.txt"",""w"");

    fscanf(fp1,""%d"",&capacity);
    
    struct stack* stk=(struct stack*)malloc(sizeof(struct stack));
    stk->cap=capacity;
    stk->top=-1;
    stk->A=(int*)malloc(sizeof(int)*capacity);


    while(1){
    fscanf(fp1,""%c"",&sel);
    if(sel=='p')
    {
        fscanf(fp1,""%d"",&n1);
        push(stk,n1,fp2);
    }
    else if(sel=='t')
    {
        pop(stk,fp2);
    }
    else if(sel=='d')
    {
        fscanf(fp1,""%d"",&num);
        print(stk,num,fp2);
    }
    else if(sel=='s')
    {
        break;
    }
}
}
",18,570,885
"#define LENGTH 2048


volatile sig_atomic_t flag = 0;
int sockfd = 0;
char name[32];
char new_entry_message[42];

void str_overwrite_stdout()
{
    printf(""%s"", ""> "");
    fflush(stdout);
}

void str_trim_lf(char *arr, int length)
{
    int i;
    for (i = 0; i < length; i++)
    {
        
        if (arr[i] == '\n')
        {
            arr[i] = '\0';
            break;
        }
    }
}

void catch_ctrl_c_and_exit(int sig)
{
    flag = 1;
}

void send_msg_handler()
{
    char message[LENGTH] = {};
    char buffer[LENGTH + 32] = {};

    while (1)
    {
        str_overwrite_stdout();
        fgets(message, LENGTH, stdin);
        str_trim_lf(message, LENGTH);

        if (strcmp(message, ""exit"") == 0)
        {
            break;
        }
        else
        {
            sprintf(buffer, ""%s: %s\n"", name, message);
            send(sockfd, buffer, strlen(buffer), 0);
        }

        bzero(message, LENGTH);
        bzero(buffer, LENGTH + 32);
    }
    catch_ctrl_c_and_exit(2);
}

void recv_msg_handler()
{
    char message[LENGTH] = {};
    while (1)
    {
        int receive = recv(sockfd, message, LENGTH, 0);
        if (receive > 0)
        {
            printf(""%s"", message);
            str_overwrite_stdout();
        }
        else if (receive == 0)
        {
            break;
        }
        else
        {
            
        }
        memset(message, 0, sizeof(message));
    }
}

int main(int argc, char **argv)
{
    if (argc != 2)
    {
        printf(""Usage: %s <port>\n"", argv[0]);
        return EXIT_FAILURE;
    }

    char *ip = ""127.0.0.1"";
    int port = atoi(argv[1]);

    signal(SIGINT, catch_ctrl_c_and_exit);

    printf(""Please enter your name: "");
    fgets(name, 32, stdin);
    str_trim_lf(name, strlen(name));

    if (strlen(name) > 32 || strlen(name) < 2)
    {
        printf(""Name must be less than 30 and more than 2 characters.\n"");
        return EXIT_FAILURE;
    }

    struct sockaddr_in server_addr;

    
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr(ip);
    server_addr.sin_port = htons(port);

    
    int err = connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));
    if (err == -1)
    {
        printf(""ERROR: connect\n"");
        return EXIT_FAILURE;
    }

    strcpy(new_entry_message, name);
    strcat(new_entry_message, "" joined!"");
    
    send(sockfd, new_entry_message, 32, 0);

    printf(""=== WELCOME TO THE CHATROOM ===\n"");

    pthread_t send_msg_thread;
    if (pthread_create(&send_msg_thread, NULL, (void *)send_msg_handler, NULL) != 0)
    {
        printf(""ERROR: pthread\n"");
        return EXIT_FAILURE;
    }

    pthread_t recv_msg_thread;
    if (pthread_create(&recv_msg_thread, NULL, (void *)recv_msg_handler, NULL) != 0)
    {
        printf(""ERROR: pthread\n"");
        return EXIT_FAILURE;
    }

    while (1)
    {
        if (flag)
        {
            printf(""\nBye.\n"");
            break;
        }
    }

    close(sockfd);

    return EXIT_SUCCESS;
}",18,571,1170
"struct Queue
{
    int rear,front;
    int size;
    int *arr;
};

typedef struct Queue queue;

int isFull(queue Q)
{
    if( (Q.front == Q.rear + 1) || (Q.front == 0 && Q.rear == Q.size-1))
        return 1;
    return 0;
}
int isEmpty(queue Q)
{
    if(Q.front == -1)
        return 1;
    return 0;
}
int enqueue(queue *Qref,int element)
{
    if(isFull(*Qref))
        return -999;
    else
    {
        if((*Qref).front == -1)
            (*Qref).front = 0;
        (*Qref).rear = ((*Qref).rear + 1) % (*Qref).size;
        (*Qref).arr[(*Qref).rear] = element;
    }
    return 0;
}
int dequeue(queue *Qref)
{
    int element;
    if(isEmpty(*Qref))
        return(-1);
    else
      {
        element = (*Qref).arr[(*Qref).front];
        if ((*Qref).front == (*Qref).rear)
        {
            (*Qref).front = -1;
            (*Qref).rear = -1;
        } 
        else
            (*Qref).front = ((*Qref).front + 1) % (*Qref).size;
        return(element);
      }
}

int length(queue Q)
{
    int l;
    if (Q.front == -1)
       return 0;
    if (Q.rear >= Q.front)
        l=Q.rear-Q.front+1;
    else
        l=Q.size-Q.front+2+Q.rear;
    return l;
}

void print(queue Q,int n,FILE *fp2)
{
    int i,l,c=0;
    l=length(Q);
    if (Q.front == -1)
    {
        fprintf(fp2,""-1\n"");
        return;
    }
    if(n>0 || n==0)
     {
        if(n==0)
          n=l;
        if (Q.rear >= Q.front)
         {
          for (i = Q.front; i <= Q.rear; i++)
            {
                if(c<n)
                 fprintf(fp2,""%d"",Q.arr[i]);
                if(i!=Q.rear)
                 fprintf(fp2,"" "");
                 c++;  
              }
             if(c<n)
              fprintf(fp2,"" END\n"");
             else
              fprintf(fp2,""\n"");
          }
     
       
        else
        {
          for (i = Q.front; i < Q.size; i++)
            {
                if(c<n)
                 fprintf(fp2,""%d "", Q.arr[i]);
                c++;
            }      
          for (i = 0; i <= Q.rear; i++)
            {  
                if(c<=n)
                 fprintf(fp2,""%d"", Q.arr[i]);
                c++;
                if(i!=Q.rear)
                 fprintf(fp2,"" "");
            }
            if(c<n)
              fprintf(fp2,"" END\n"");
            else
              fprintf(fp2,""\n"");
         }
 
    }
}

int main()
{
    char sel;
    int p,q,n,element;
    FILE *fp1;
    FILE *fp2;
    fp1=fopen(""input.txt"",""r"");
    fp2=fopen(""output.txt"",""w"");
    queue Q;
    Q.rear=-1;
    Q.front=-1;

    fscanf(fp1,""%d"",&(Q.size));
    Q.arr=(int*)malloc(sizeof(int)*(Q.size));
    while(1)
         {
            fscanf(fp1,""%c"",&sel);
              if(sel=='e')
                {
                    fscanf(fp1,""%d"",&element);
                    p=enqueue(&Q,element);

                    if(p==-999)
                      fprintf(fp2,""%d\n"",p);
                }  
            else if(sel=='p')
                 {
                    fscanf(fp1,""%d"",&n);
                    print(Q,n,fp2);
                 }
            else if(sel=='d')
                {
                    q=dequeue(&Q);
                    fprintf(fp2,""%d\n"",q);
                }
            else if(sel=='s')
                break;
         }

  fclose(fp1);
  fclose(fp2);
  return 0;
}
",18,572,1243
"#define BUFLEN 512  
#define PORT 8888   

void error(char *s)
{
    perror(s);
    exit(1);
}




int main(void)
{
    struct sockaddr_in si_server, si_client;
    
    int socket_udp, i, slen = sizeof(si_client) , recv_len;
    char buf[BUFLEN];
    
    
    if ((socket_udp=socket(AF_INET, SOCK_DGRAM, 0)) == -1)
    {
        error(""socket"");
    }
    printf(""UDP Socket created!\n"");

    
    memset((char *) &si_server, 0, sizeof(si_server));
    
    
    si_server.sin_family = AF_INET;
    si_server.sin_port = htons(PORT);
    si_server.sin_addr.s_addr = htonl(INADDR_ANY);
    
    
    if( bind(socket_udp , (struct sockaddr*)&si_server, sizeof(si_server) ) == -1)
    {
        close(socket_udp);
        error(""bind"");
    }
    printf(""Socket bound to 0.0.0.0: 8888\n"");
    
    while(1)
    {
        printf(""Waiting for data...\n"");
        fflush(stdout);
        bzero(buf, BUFLEN);

        
        
        if ((recv_len = recvfrom(socket_udp, buf, BUFLEN, MSG_WAITALL, (struct sockaddr *) &si_client, &slen)) == -1)
        {
            error(""recvfrom()"");
        }
        
        
        printf(""\n--------- DATA PACKET ------------------\n"");
        printf(""Received Data Packet from %s:%d\n"", inet_ntoa(si_client.sin_addr), ntohs(si_client.sin_port));
        printf(""Data: %s\n"" , buf);
        printf(""----------------------------------------\n\n"");
        
        
        if (sendto(socket_udp, buf, recv_len, 0, (struct sockaddr*) &si_client, slen) == -1)
        {
            error(""sendto()"");
        }
        
        bzero(buf, BUFLEN);
    }

    close(socket_udp);
    return 0;
}",18,573,635
"#define PORT 8080       
#define LO ""127.0.0.1""  

int main(int argc, char const *argv[]) 
{ 
    int socket_client = 0, n; 
    struct sockaddr_in serv_addr; 
    char buffer[1024] = {0}; 

    
    if ((socket_client = socket(AF_INET, SOCK_STREAM, 0)) < 0) 
    { 
        printf(""\n Socket creation error \n""); 
        return -1; 
    }

    
    serv_addr.sin_family = AF_INET; 
    serv_addr.sin_port = htons(PORT); 
    
    
    if(inet_pton(AF_INET, LO , &serv_addr.sin_addr)<=0) 
    { 
        printf(""\nInvalid address/ Address not supported \n""); 
        return -1; 
    } 

    
    if (connect(socket_client, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) 
    { 
        printf(""\nConnection Failed \n""); 
        return -1; 
    }
    
    
    while(1) {
        bzero(buffer, 1024);
        printf(""Enter Client's Message: "");
        fgets(buffer, 1024, stdin);
        char bye[5] = ""close"";
        if(strncmp(buffer, ""close"", 5)==0) {
            n = send(socket_client , bye, 1024, 0); 
            
            close(socket_client);
            break;
        }
        n = send(socket_client , buffer, 1024, 0); 
        if(n<0) {
            printf(""Reading Error!\n"");
        }
        bzero(buffer, 1024);
        n = recv(socket_client , buffer, 1024, 0); 

        printf(""Server: %s\n"", buffer);
        bzero(buffer, 1024);

    }
    printf(""Client Closed Connection.\n""); 
    return 0; 
} 

",18,574,559
"FILE* F1;
FILE* F2;


int* read(int n)
{
        int i;
        int s = sizeof(int);
        int* arr1= (int*)malloc(s * n);
        for(i = 0; i<n; i++)
        {
                fscanf(F1, ""%d"", (arr1+i));
        }
        return arr1;
}



void display(int arr2[], int n)
{
        int i;
        for(i = 0; i<n; i++)
        {
                fprintf(F2, ""%d "", arr2[i]);
        }

}


void sort(int a[], int n)
{
    int i = 1;
    int shift, cmp;
    for(i = 1; i<n; i++)
    {
        int key = a[i];
        int j = i-1;
        cmp = 0;shift = 0;
        while(j>=0 && a[j]<key)
        {
            a[j+1]= a[j];
            j = j-1;
            cmp++;
            shift++;
        }
            a[j+1] = key;
            if(j != -1)
            {
                cmp++;
            }
            if( j != i-1)
            {
                shift++;
            }
            fprintf(F2, ""%d %d\n"", cmp, shift);
            display(a, n);
            fprintf(F2, ""\n"");

    }

}

int main(int argc, char* argv[])
{
    int num; char s;int size;
        int* arr;
        F1 = fopen(argv[1], ""r"");
        F2 = fopen(argv[2], ""w"");
        while(1)
        {
        fscanf(F1 ,""%c %d"",&s, &num);
        if(s == 'r')
        {
                size = num;
                arr = read(num);

        }
        else if(s == 's')
        {
                sort(arr, size);
        }

        else if(s == 'd')
        {
                display(arr, num);
                fprintf(F2, ""\n"");
        }
        else if(s == 't')
                return 0;
        }
        fclose(F1);
        fclose(F2);
    
}

",18,575,613
"struct stack{
        int stk[50];
        int top;
        };

int evaluatepostfix(int a,int b, char c,FILE* F2)
{
int res=1;
if(c=='+')
    return a+b;
if(c=='-')
        return b-a;
if(c=='*')
        return a*b;
if(c=='/')
        return b/a;
if(c=='^')
{
for(int i=1;i<=a;i++)
{
res*=b;
}
return res;
}
printf(""invalid operator"");
fprintf(F2,""-999"");
exit(0);
}
int pop(struct stack* A)
{
int q;
q=A->stk[A->top];
return q;
}

struct stack* push(struct stack* A,int elt)
{

                A->top=A->top+1;
                A->stk[A->top]=elt;
        return A;
}

int main()
{       FILE* F1;
        FILE *F2;
        F1 = fopen(""input.txt"",""r"");
        F2 = fopen(""output.txt"",""w"");
        if(F1 == NULL)
        {
                printf(""input file not found"");
                exit(0);
        }


          int flag=-1;;
      char a,check;
      char c;
          int p,size,elt,q,t1,t2,res;
          struct stack AA;
          struct stack *A=&AA;
          A->top=-1;
      
        while(1)
        {
                fscanf(F1,""%c"",&a);
               if(a=='e' || a=='s');
                else
               {
                        printf(""invalid char input "");
                        fprintf(F2,""-999"");
                        exit(0);
                }
                if(a=='e')
                {  
                fscanf(F1,"" "");
        while(1)
        {
        fscanf(F1,""%c"",&check);
        if(check=='e' || check =='s' || check=='\n')
        {    fseek(F1,-1,1);
            break;}
        else
            fseek(F1,-1,1);
        

        t2=ftell(F1);
        if(fscanf(F1,""%d"",&elt));
        else
        {
        flag=1;  
        
        t1=ftell(F1);
        if(t1!=t2)
        {
        fseek(F1,-1,1);
        }
        fscanf(F1,""%c"",&c);
        }
    
    
        if(flag==-1)
        {
        A=push(A,elt);
        }

        if(flag==1)
        {   int e1=pop(A);
            A->top=A->top-1;
            int e2=pop(A);
             A->top=A->top-1;
            res=evaluatepostfix(e1,e2,c,F2);
            A=push(A,res);
        }
        flag=-1;
        fscanf(F1,"" "");
        }
        fprintf(F2,""%d\n"",A->stk[A->top]);
        A->top=-1;
        } 
                if(a=='s')
                        exit(0);
                fscanf(F1,""\n"");
        }
        return 0;
}





",18,576,899
"#define BUFSIZE 1024
#define LO ""127.0.0.1""
#define PORT 8080


void str_trim_lf(char *arr, int length);

void connect_request(int *sockfd, struct sockaddr_in *server_addr);
void send_recv(int i, int sockfd, char name[32], fd_set* master);

int main()
{
    int sockfd, fdmax, i;
    struct sockaddr_in server_addr;
    fd_set master;
    fd_set read_fds;
    char name[32];
    char new_entry_message[42];

    
    printf(""Please enter your name: "");
    fgets(name, 32, stdin);
    str_trim_lf(name, strlen(name));

    if (strlen(name) > 32 || strlen(name) < 2)
    {
        printf(""Name must be less than 30 and more than 2 characters.\n"");
        return EXIT_FAILURE;
    }

    connect_request(&sockfd, &server_addr);

    
    strcpy(new_entry_message, name);
    strcat(new_entry_message, "" joined!"");
    send(sockfd, new_entry_message, 32, 0);

    
    FD_ZERO(&master);
    FD_ZERO(&read_fds);

    
    
    FD_SET(0, &master);
    FD_SET(sockfd, &master);

    
    printf(""\n--------------------- WELCOME TO THE CHATROOM ---------------------\n"");

    fdmax = sockfd;

    while (1)
    {
        
        read_fds = master;
        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)
        {
            perror(""select"");
            exit(4);
        }
        
        for (i = 0; i <= fdmax; i++)
            if (FD_ISSET(i, &read_fds))
               send_recv(i, sockfd, name, &master);
    }
    
    printf(""Bye\n"");
    close(sockfd);
    return 0;
}


void connect_request(int *sockfd, struct sockaddr_in *server_addr)
{
    if ((*sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
    {
        perror(""Socket"");
        exit(1);
    }

    server_addr->sin_family = AF_INET;
    server_addr->sin_port = htons(PORT);
    server_addr->sin_addr.s_addr = inet_addr(LO);

    if (connect(*sockfd, (struct sockaddr *)server_addr, sizeof(struct sockaddr)) == -1)
    {
        perror(""connect"");
        exit(1);
    }
}

void send_recv(int i, int sockfd, char name[32], fd_set* master)
{
    char in_buf[BUFSIZE];
    char send_buf[BUFSIZE+32]="""";
    char recv_buf[BUFSIZE];
    char disconnect_mssge[32];
    int nbyte_recvd;
    if (i == 0)
    {
        fgets(in_buf, BUFSIZE, stdin);
        str_trim_lf(in_buf, BUFSIZE);

        sprintf(send_buf, ""%s > %s"", name, in_buf);

        if (strncmp(in_buf,""tata"", 4) == 0)
        {
            sprintf(disconnect_mssge,""%s left the chat."", name);
            send(sockfd, disconnect_mssge, strlen(disconnect_mssge), 0);
            FD_CLR(i, master);
            close(i);
            close(sockfd);
            exit(0);
        }
        else
            send(sockfd, send_buf, strlen(send_buf), 0);
        bzero(send_buf, BUFSIZE);
    }
    else
    {
        nbyte_recvd = recv(sockfd, recv_buf, BUFSIZE, 0);
        recv_buf[nbyte_recvd] = '\0';
        printf(""%s\n"", recv_buf);
    }
}


void str_trim_lf(char *arr, int length) {
    int i;
    for (i = 0; i < length; i++)
    {
        
        if (arr[i] == '\n')
        {
            arr[i] = '\0';
            break;
        }
    }
}

",18,577,1228
"#define LENGTH 2048


volatile sig_atomic_t flag = 0;
int sockfd = 0;
char name[32];

void str_overwrite_stdout() {
  printf(""%s"", ""> "");
  fflush(stdout);
}

void str_trim_lf (char* arr, int length) {
  int i;
  for (i = 0; i < length; i++) { 
    if (arr[i] == '\n') {
      arr[i] = '\0';
      break;
    }
  }
}

void catch_ctrl_c_and_exit(int sig) {
    flag = 1;
}

void send_msg_handler() {
  char message[LENGTH] = {};
    char buffer[LENGTH + 32] = {};

  while(1) {
    str_overwrite_stdout();
    fgets(message, LENGTH, stdin);
    str_trim_lf(message, LENGTH);

    if (strcmp(message, ""exit"") == 0) {
            break;
    } else {
      sprintf(buffer, ""%s: %s\n"", name, message);
      send(sockfd, buffer, strlen(buffer), 0);
    }

        bzero(message, LENGTH);
    bzero(buffer, LENGTH + 32);
  }
  catch_ctrl_c_and_exit(2);
}

void recv_msg_handler() {
    char message[LENGTH] = {};
  while (1) {
        int receive = recv(sockfd, message, LENGTH, 0);
    if (receive > 0) {
      printf(""%s"", message);
      str_overwrite_stdout();
    } else if (receive == 0) {
            break;
    } else {
            
        }
        memset(message, 0, sizeof(message));
  }
}

int main(int argc, char **argv){
    if(argc != 2){
        printf(""Usage: %s <port>\n"", argv[0]);
        return EXIT_FAILURE;
    }

    char *ip = ""127.0.0.1"";
    int port = atoi(argv[1]);

    signal(SIGINT, catch_ctrl_c_and_exit);

    printf(""Please enter your name: "");
  fgets(name, 32, stdin);
  str_trim_lf(name, strlen(name));


    if (strlen(name) > 32 || strlen(name) < 2){
        printf(""Name must be less than 30 and more than 2 characters.\n"");
        return EXIT_FAILURE;
    }

    struct sockaddr_in server_addr;

    
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
  server_addr.sin_family = AF_INET;
  server_addr.sin_addr.s_addr = inet_addr(ip);
  server_addr.sin_port = htons(port);


  
  int err = connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));
  if (err == -1) {
        printf(""ERROR: connect\n"");
        return EXIT_FAILURE;
    }

    
    send(sockfd, name, 32, 0);

    printf(""=== WELCOME TO THE CHATROOM ===\n"");

    pthread_t send_msg_thread;
  if(pthread_create(&send_msg_thread, NULL, (void *) send_msg_handler, NULL) != 0){
        printf(""ERROR: pthread\n"");
    return EXIT_FAILURE;
    }

    pthread_t recv_msg_thread;
  if(pthread_create(&recv_msg_thread, NULL, (void *) recv_msg_handler, NULL) != 0){
        printf(""ERROR: pthread\n"");
        return EXIT_FAILURE;
    }

    while (1){
        if(flag){
            printf(""\nBye\n"");
            break;
    }
    }

    close(sockfd);

    return EXIT_SUCCESS;
}",18,578,1078
"#define MAX 80 
#define PORT 8080 
#define SA struct sockaddr 


void comm(int sockfd) 
{ 
    char buff[MAX]; 
    int n; 
    while(1) { 
        bzero(buff, sizeof(buff)); 
        printf(""Write Client's Message: ""); 
        n = 0; 
        while ((buff[n++] = getchar()) != '\n'); 
        write(sockfd, buff, sizeof(buff)); 
        bzero(buff, sizeof(buff)); 
        read(sockfd, buff, sizeof(buff)); 
        printf(""Server: %s\n"", buff); 
        if ((strncmp(buff, ""close"", 5)) == 0) { 
            printf(""Client Exited\n""); 
            break; 
        } 
    } 
} 

int main() 
{ 
    int sockfd, connfd; 
    struct sockaddr_in servaddr, cli; 

    
    sockfd = socket(AF_INET, SOCK_STREAM, 0); 
    if (sockfd == -1) { 
        printf(""socket creation failed...\n""); 
        exit(0); 
    } 
    else
        printf(""Socket successfully created..\n""); 
    bzero(&servaddr, sizeof(servaddr)); 

    
    servaddr.sin_family = AF_INET; 
    servaddr.sin_addr.s_addr = inet_addr(""127.0.0.1""); 
    servaddr.sin_port = htons(PORT); 

    
    if (connect(sockfd, (SA*)&servaddr, sizeof(servaddr)) != 0) { 
        printf(""connection with the server failed...\n""); 
        exit(0); 
    } 
    else
        printf(""connected to the server..\n""); 

    
    comm(sockfd); 

    
    close(sockfd); 
} 

",18,579,502
"typedef int set_pointer;

typedef struct _Edge {
    int ui;
    int uj;
    int distance;
} edge;
typedef edge set_of_edges;

typedef struct _Universe {
    int parent;
    int depth;
} universe;
universe *U;

void makeset(int i) {
    U[i].parent = i;
    U[i].depth = 0;
}

set_pointer find(int i) {
    int j;
    j = i;
    while(U[j].parent != j)
        j = U[j].parent;

    return j;
}

void merge(set_pointer p, set_pointer q) {
    if(U[p].depth == U[q].depth) {
        U[p].depth += 1;
        U[q].parent = p;
    }
    else if(U[p].depth < U[q].depth) U[p].parent = q;
    else U[q].parent = p;
}

bool equal(set_pointer p, set_pointer q) {
    if(p == q) return true;
    else return false;
}

void initial(int n) {
    int i;
    for(i = 0; i < n; i++) makeset(i);
}

int compare(const void *a, const void *b) {
    edge *u = (edge *)a;
    edge *v = (edge *)b;

    if(u->distance < v->distance) return -1;
    if(u->distance > v->distance) return 1;
    return 0;
}

int num_of_Vertex, num_of_Edges;
void kruskal(int n, int m, set_of_edges *E, set_of_edges *F) {
    int i, j;
    set_pointer p, q;
    edge e;

    qsort(E, num_of_Edges, sizeof(edge), compare);
    initial(num_of_Vertex);

    while(n < num_of_Vertex) {
        e.ui = E[m].ui;
        e.uj = E[m].uj;
        e.distance = E[m].distance;

        i = e.ui;
        j = e.uj;

        p = find(i);
        q = find(j);

        if(!equal(p, q)) {
            merge(p, q);
            F[n-1].ui = e.ui;
            F[n-1].uj = e.uj;
            F[n-1].distance = e.distance;

            n++;
        }

        m++;
    }
}

int main() {
   printf(""-----input-----\n"");
   printf(""num of Vertex = "");
   scanf(""%d"", &num_of_Vertex);
   printf(""num of Edges = "");
   scanf(""%d"", &num_of_Edges);

   U = (universe *)malloc(sizeof(universe) * num_of_Vertex);
   edge *E = (edge *)malloc(sizeof(edge) * num_of_Edges);
   edge *F = (edge *)malloc(sizeof(edge) * num_of_Edges);

   for(int i = 0; i < num_of_Edges; i++) {
       printf(""insert edge = "");
       scanf(""%d %d %d"", &E[i].ui, &E[i].uj, &E[i].distance);
   }

   kruskal(1, 0, E, F);

   int value = 0; 
   printf(""\n-----output-----\n"");
   for(int i = 0; i < num_of_Vertex -1; i++) {
        printf(""v%d - v%d = %d\n"", F[i].ui, F[i].uj, F[i].distance);
        value += F[i].distance;
   }
   printf(""minimum spannig tree value = %d\n"", value);
}






















",19,580,1022
"#include ""person.h""

int heapsize = 0;
void swap(Person *x, Person *y) {
    Person temp = *x;
    *x = *y;
    *y = temp;
}

void insert_heap(Person *person, Person *p) {
    int i = ++heapsize;

    memcpy(&person[i], p, sizeof(Person));

    while((i != 1) && (strcmp(person[i].sn, person[i/2].sn) == -1)) {
        swap(&person[i], &person[i/2]);
        i = i/2;
    }

}

Person delete_heap(Person *person) {
    int parent, child;
    Person item, temp;

    item = person[1];
    temp = person[heapsize--];
    parent = 1;
    child = 2;

    while(child <= heapsize) {
        if((child < heapsize) && (strcmp(person[child].sn, person[child+1].sn) == 1)) {
            child++;
        }
        if(strcmp(temp.sn, person[child].sn) == -1)
            break;
        swap(&person[parent], &person[child]);
        parent = child;
        child *= 2;
    }

    person[parent] = temp;

    return item;
}

void readPage(FILE *fp, char *pagebuf, int pagenum) {
    fseek(fp, PAGE_SIZE * pagenum, SEEK_SET);
    fread(pagebuf, sizeof(char), PAGE_SIZE, fp);
}

void writePage(FILE *fp, const char *pagebuf, int pagenum) {
    fseek(fp, PAGE_SIZE * pagenum, SEEK_SET);
    fwrite(pagebuf, sizeof(char), PAGE_SIZE, fp);
}


void pack(char *recordbuf, const Person *p) {
    sprintf(recordbuf, ""%s#%s#%s#%s#%s#%s#"", p -> sn, p -> name, p -> age,  p -> addr, p -> phone, p -> email);
    memset(recordbuf + strlen(recordbuf), (char)0xFF, RECORD_SIZE - strlen(recordbuf));
}

void unpack(const char *recordbuf, Person *p) {
    sscanf(recordbuf, ""%[^'#']#%[^'#']#%[^'#']#%[^'#']#%[^'#']#%[^'#']#"",
    p -> sn, p -> name, p -> age, p -> addr, p -> phone, p -> email);
}

void setHeadPage(char *pagebuf, int pageNum, int recordNum, int deletePageNum, int deleteRecordNum) {
    memset(pagebuf, 0xFF, PAGE_SIZE);
    memcpy(pagebuf, &pageNum, sizeof(int));
    memcpy(pagebuf+4, &recordNum, sizeof(int));
    memcpy(pagebuf+8, &deletePageNum, sizeof(int));
    memcpy(pagebuf+12, &deleteRecordNum, sizeof(int));
}

int main(int argc, char* argv[]) {
    
    FILE *fp1;
    FILE *fp2;

    fp1 = fopen(argv[2], ""r+"");
    fp2 = fopen(argv[3], ""w+"");


    char pagebuf[PAGE_SIZE + 1] = { }; 
    memset(pagebuf, (char)0xFF, PAGE_SIZE);
    char *recordbuf = malloc(sizeof(char) * RECORD_SIZE);

    int pageNum;
    int recordNum;
    int recordPerPage = PAGE_SIZE / RECORD_SIZE;
    int recordCount = 0;
    int recordCount_2 = 0;

    readPage(fp1, pagebuf, 0);
    memcpy(&pageNum, pagebuf, sizeof(int));
    memcpy(&recordNum, pagebuf+4, sizeof(int));

    char filebuf[PAGE_SIZE * pageNum + 1];
    Person person[recordPerPage * pageNum];
    Person *p = (Person*)malloc(sizeof(Person));

    for(int i = 1; i < pageNum; i++) {
        readPage(fp1, pagebuf, i);
        for(int j = 0; j < recordPerPage; j++) {
            if(recordCount == recordNum) break;
            recordCount++;
            int index = j * RECORD_SIZE;
            int position = (i-1) * recordPerPage + j;
            memcpy(recordbuf, pagebuf + index, RECORD_SIZE);
            if(recordbuf[0] == '*' || recordbuf[0] == (char)0xFF) continue;
            unpack(recordbuf, p);
            insert_heap(person, p);
            recordCount_2++;
        }
    }

    recordCount = 0;
    readPage(fp1, pagebuf, 0);
    if(recordCount_2 % 2 == 0) pageNum = recordCount_2 / recordPerPage + 1;
    else pageNum = recordCount_2 / recordPerPage + 2;
    setHeadPage(pagebuf, pageNum, recordCount_2, -1, -1);
    writePage(fp2, pagebuf, 0);

    for(int i = 1; i < pageNum; i++) {
        memset(pagebuf, (char)0xFF, PAGE_SIZE);
        for(int j = 0; j < recordPerPage; j++) {
            if(recordCount == recordCount_2) break;
            recordCount++;
            int index = j * RECORD_SIZE;
            int position = (i-1) * recordPerPage + j;
            memset(recordbuf, (char)0xFF, RECORD_SIZE);
            Person temp = delete_heap(person);
            pack(recordbuf, &temp);
            memcpy(pagebuf + index, recordbuf, RECORD_SIZE);
        }
        writePage(fp2, pagebuf, i);
    }
}
    

",19,581,1548
"int main(int argc, char *argv[]) {

    int wfd, rfd;
    char buffer[101];
    size_t count;

    if((wfd = open(argv[1], O_RDWR)) == -1) {
        perror(""file1 openning error"");
        return 1;
    }

    if((rfd = open(argv[2], O_RDONLY)) == -1) {
        perror(""file2 openning error"");
        return 1;
    }

    if(lseek(wfd, 0, SEEK_END) == -1) {
        perror(""lseek END error"");
        close(rfd);
        close(wfd);
        return 1;
    }

    while((count = read(rfd, buffer, 100)) > 0) {
        if(write(wfd, buffer, count) < count) {
            perror(""file merge error"");
            close(rfd);
            close(wfd);
            return 1;
        }
    }

    puts(""file merge success"");

    close(rfd);
    close(wfd);

    return 0;
}
",19,582,299
"typedef int index;

int **M;

int **init_matrix(int n) {
    int **matrix = (int **)malloc(sizeof(int *) * n);
    for(int i = 0; i < n; i++) {
        matrix[i] = (int *)malloc(sizeof(int) * n);
    }
    
    return matrix;
}

int minimum(int i, int j, int **M, int *d) {
    int min = 999, index = 0;

    for(int k = i; k <= j -1; k++) {
        if(M[i][k] + M[k+1][j] + d[i-1] * d[k] * d[j] < min) {
            min = M[i][k] + M[k+1][j] + d[i-1] * d[k] * d[j];
            index = k;
        }
    }
    return index;
}


int minmult(int n, int *d, int **P) {
    index i, j, k, diagonal;

    for(int i = 1; i <= n; i++)
        M[i][i] = 0;

    for(diagonal = 1; diagonal <= n - 1; diagonal++) {
        for(i = 1; i <= n - diagonal; i++) {
            j = i + diagonal;
            k = minimum(i, j, M, d);
            M[i][j] = M[i][k] + M[k+1][j] + d[i-1] * d[k] * d[j];
            P[i][j] = k;
        }
    }
    
    printf(""M = \n"");
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++)
            printf(""%-4d"", M[i][j]);
        printf(""\n"");
    }
    printf(""\n"");

    return M[1][n];
}

void order(index i, index j, int **P) {
    int k;

    if(i == j) printf(""A%d "", i);
    else {
        k = P[i][j];
        printf(""( "");
        order(i, k, P);
        order(k+1, j, P);
        printf("") "");
    }
}
        

void main() {
    int n;

    printf(""n = "");
    scanf(""%d"", &n);
    printf(""\n"");

    int **A = init_matrix(n);
    int **P = init_matrix(n + 1);
    M = init_matrix(n + 1);

    int *d = (int *)malloc(sizeof(int) * (n + 1));

    for(int i = 0; i < n; i++) {
        printf(""A%d = "", i);
        scanf(""%d %d"", &A[i][0], &A[i][1]);
    }
    printf(""\n"");
    
    d[0] = A[0][0];
    for(int i = 0; i < n; i++)
        d[i + 1] = A[i][1]; 

    printf(""bestcase = %d\n\n"", minmult(n, d, P));

    printf(""P = \n"");
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++)
            printf(""%4d"", P[i][j]);
        printf(""\n"");
    }
    printf(""\n"");

    printf(""order = "");
    order(0, n, P);
    printf(""\n"");

    printf(""\n"");
    for(int diagonal = 1; diagonal <= n - 1; diagonal++) {
        for(int i = 1; i <= n - diagonal; i++) {
            int j = i + diagonal;
            printf(""M[%d][%d] = "", i, j);
            order(i, j, P);
            printf(""= %d\n"", M[i][j]);
        }
        printf(""\n"");
    }
}
",19,583,1036
"typedef int index;

float sum(int i, int j, float *p) {
    float result = 0;

    for(int k = i; k <= j; k++)
        result += p[k];

    return result;
}

int min(int i, int j, float **A, float *p) {
    int index;
    float min = 999;
    
    for(int k = i; k <= j; k++) {
        if(A[i][k-1] + A[k+1][j] + sum(i, j, p) < min) {
            min = A[i][k-1] + A[k+1][j] + sum(i, j, p);
            index = k;
        }
    }

    return index;
}

void optsearchtree(int n, float *p, float *minavg, index **R) {
    index i, j, k, diagonal;
    float **A = (float **)malloc(sizeof(float *) * (n + 2));
    for(int t = 0; t < n + 2; t++)
        A[t] = (float *)malloc(sizeof(float) * (n + 1));

    for(i = 1; i <= n; i++) {
        A[i][i-1] = 0;
        A[i][i] = p[i];
        R[i][i] = i;
        R[i][i-1] = 0;
    }

    A[n+1][n] = 0;
    R[n+1][n] = 0;

    for(diagonal = 1; diagonal <= n-1; diagonal++) {
        for(i = 1; i <= n - diagonal; i++) {
            j = i + diagonal;
            k = min(i, j, A, p);
            A[i][j] = A[i][k-1] + A[k+1][j] + sum(i, j, p);
            R[i][j] = k;
        }
    }

    printf(""A = \n"");
    for(int i = 1; i <= n + 1; i++) {
        for(int j = 0; j <= n; j++)
            printf(""%.3f "", A[i][j]);
        printf(""\n"");
    }
    printf(""\n"");

    *minavg = A[1][n];
}

void main() {
    int n;
    float minavg;

    printf(""n = "");
    scanf(""%d"", &n);
    printf(""\n"");

    float *p = (float *)malloc(sizeof(float) * (n + 1));
    int **R = (int **)malloc(sizeof(int *) * (n + 2));
    for(int i = 0; i < n + 2; i++)
        R[i] = (int *)malloc(sizeof(int) * (n + 1));

    for(int i = 1; i <= n; i++) {
        printf(""Key[%d] = "", i);
        scanf(""%f"", &p[i]);
    }
    printf(""\n"");

    optsearchtree(n, p, &minavg, R);
    
    printf(""minavg = %.3f\n\n"", minavg);

    printf(""R = \n"");
    for(int i = 1; i <= n + 1; i++) {
        for(int j = 0; j <= n; j++)
            printf(""%d "", R[i][j]);
        printf(""\n"");
    }
}
",19,584,895
"int n;
int *col;

bool promising(int i) {
    bool swtch = true;
    int k = 1;
    
    while(k < i && swtch) {
        if(col[i] == col[k] || abs(col[i] - col[k]) == abs(i - k))
            swtch = false;
        k++;
    }
    return swtch;
}

void queens(int i) {
    for(int j = 1; j <= n; j++)
        printf(""%d "", col[j]);
    printf(""\n"");

    if(promising(i)) {
        if(i == n) {
            printf(""\nSolution = "");
            for(int j = 1; j <= n; j++)
                printf(""%d "", col[j]);
            printf(""\n"");
            exit(1);
        }
        else {
            for(int j = 1; j <= n; j++) {
                col[i+1] = j;
                queens(i+1);
            }
        }
    }
}

void main() {
    
    printf(""n = "");
    scanf(""%d"", &n);
    printf(""\n"");

    col = (int *)malloc(sizeof(int) * (n + 1));

    queens(0);

}
",19,585,334
"int main(int argc, char *argv[]) {
    
    char c;
    int rfd;
    int offset = atoi(argv[2]);
    int readbyte = atoi(argv[3]);
    int count = 0;

    if((rfd = open(argv[1], O_RDONLY)) == -1) {
        perror(""file openning error"");
        return 1;
    }

    if(lseek(rfd, offset, SEEK_SET) == -1) {
        perror(""lseek error"");
        close(rfd);
        return 1;
    }
    
    while(read(rfd, &c, 1) !=0 && count < readbyte) {
        write(1, &c, 1);
        count++;
    }

    puts(""file read success"");

    close(rfd);
    
    return 0;
}
    


",19,586,231
"int main(int argc, char *argv[]) {

    int fd;
    int offset = atoi(argv[2]);
    int deletebyte = atoi(argv[3]);
    int filelen, templen;
    char *temp;

    if((fd = open(argv[1], O_RDWR)) == -1) {
        perror(""file openning error"");
        return 1;
    }

    if((filelen = lseek(fd, 0, SEEK_END)) == -1) {
        perror(""lseek END error"");
        close(fd);
        return 1;
    }

    templen = filelen - offset - deletebyte;
    temp = malloc(sizeof(char) * templen + 1);

    if(lseek(fd, offset +deletebyte, SEEK_SET) == -1) {
        perror(""lseek error"");
        close(fd);
        return 1;
    }
    
    read(fd, temp, templen);
    
    if(lseek(fd, offset, SEEK_SET) == -1) {
        perror(""lseek error"");
        close(fd);
        return 1;
    }

    write(fd, temp, templen);

    if(truncate(argv[1], filelen - deletebyte) == -1) {
        perror(""truncate error"");
        close(fd);
        return 1;
    }

    puts(""file delete success"");

    close(fd);
    free(temp);
    return 0;
}
",19,587,399
"typedef struct set_of_edges {
    int from;
    int end;
    int distance;
} edge;

int *nearest, *distance;

void prim(int n, int **W, edge *F) {
    int i, vnear, min;
    edge e;

    for(i = 2; i <= n; i++) {
        nearest[i] = 1;
        distance[i] = W[1][i];
    }

    printf(""nearest = "");
    for(i = 2; i <= n; i++) printf(""%d "", nearest[i]);
    printf(""\ndistance = "");
    for(i = 2; i <= n; i++) printf(""%d "", distance[i]);
    printf(""\n\n"");

    for(int j = 0; j < n -1; j++) {
        min = 999;
        for(i = 2; i <= n; i++) 
            if(0 <= distance[i] && distance[i] <= min) {
                min = distance[i];
                vnear = i;
            }
        
        e.from = nearest[vnear];
        e.end = vnear;
        e.distance = distance[vnear];

        F[j].from = e.from;
        F[j].end = e.end;
        F[j].distance = e.distance;

        distance[vnear] = -1;

        printf(""path : V%d -> V%d distance %d\n\n"", e.from, e.end, e.distance);

        for(i = 2; i <= n; i++)
            if(W[i][vnear] < distance[i]) {
                distance[i] = W[i][vnear];
                nearest[i] = vnear;
            }

        printf(""nearest = "");
        for(i = 2; i <= n; i++) printf(""%d "", nearest[i]);
        printf(""\ndistance = "");
        for(i = 2; i <= n; i++) printf(""%d "", distance[i]);
        printf(""\n\n"");

    }
}
void main() {
    int n = 0;

    printf(""n = "");
    scanf(""%d"", &n);
    printf(""\n"");

    int **W = (int **)malloc(sizeof(int *) * (n + 1));
    for(int i = 0; i <= n; i++)
        W[i] = (int *)malloc(sizeof(int) * (n + 1));
    nearest = (int *)malloc(sizeof(int) * (n + 1));
    distance = (int *)malloc(sizeof(int) * (n + 1));
    edge *F = (edge *)malloc(sizeof(edge) * n);

    printf(""W = \n"");
    for(int i = 1; i <= n; i++) 
        for(int j = 1; j <= n; j++) 
            scanf(""%d"", &W[i][j]);
    printf(""\n"");

    prim(n, W, F);
}
",19,588,755
"int n, m, **W, *vcolor;

bool promising(int i) {
    bool swtch = true;
    int j = 1;

    while(j < i && swtch) {
        if(W[i][j] && vcolor[i] == vcolor[j]) swtch = false;
        j++;
    }

    return swtch;
}

void m_coloring(int i) {
    
    for(int color = 1; color <= n; color++)
        printf(""%d "", vcolor[color]);
    printf(""\n"");

    if(promising(i)) {
        if(i == n) {
            printf(""volor = "");
            for(int color = 1; color <= n; color++)
                printf(""%d "", vcolor[color]);
            printf(""\n"");
        }
        else {
            for(int color = 1; color <= m; color++) {
                vcolor[i+1] = color;
                m_coloring(i+1);
            }
        }
    }
}

void main() {
    printf(""n = "");
    scanf(""%d"", &n);
    printf(""m = "");
    scanf(""%d"", &m);
    printf(""\n"");

    W = (int **)malloc(sizeof(int *) * (n+1));
    for(int i = 0; i <= n; i++)
        W[i] = (int *)malloc(sizeof(int) * (n+1));
    vcolor = (int *)malloc(sizeof(int) * (n+1));
    memset(vcolor, 0, sizeof(int) * (n+1));

    printf(""W = \n"");
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            scanf(""%d"", &W[i][j]);
    printf(""\n"");

    m_coloring(0);
}

",19,589,486
"int W;
int *w, *include, *save;

bool promising(int i, int weight, int total) {
    if(! ((weight + total >= W) && (weight == W || weight + w[i+1] <= W))) {
        if(weight + total >= W) printf(""weight + total >= W\n"");
        else if(weight == W || weight + w[i+1] <= W) {
            if (!(weight + w[i+1] <= W)) printf(""weight + w[i+1] <= W\n"");
            else if(!(weight == W)) printf(""weight == W\n"");
        }
    }
    else if(weight == W) printf("" <- this is the solution\n"");
    else printf(""\n"");

    return (weight + total >= W)
        && (weight == W || weight + w[i+1] <= W);
}

void sum_of_subsets(int i, int weight, int total) {
    printf(""total: %d\n"", total);
    for(int j = 1; j <= i; j++)
        printf(""%d "", include[j]);

    if(promising(i, weight, total)) {
        if(weight == W) {
            for(int j = 1; j <= i; j++)
                save[i] = include[i];
        }
        else {
            include[i+1] = 1;
            sum_of_subsets(i+1, weight + w[i+1], total - w[i+1]);
            include[i+1] = 0;
            sum_of_subsets(i+1, weight, total - w[i+1]);
        }
    }
}

void main() {
    int n, total;

    printf(""n = "");
    scanf(""%d"", &n);
    printf(""W = "");
    scanf(""%d"", &W);
    printf(""\n"");

    w = (int *)malloc(sizeof(int) * (n+1));
    include = (int *)malloc(sizeof(int) * (n+1));
    save = (int *)malloc(sizeof(int) * (n+1));

    for(int i = 1; i <= n; i++) {
        printf(""w[%d] : "", i);
        scanf(""%d"", &w[i]);
    }
    printf(""\n"");

    for(int i = 1; i <= n; i++) total += w[i];

    sum_of_subsets(0, 0, total);
}
",19,590,621
"#define SUFFLE_NUM 10000

void GenRecordSequence(int *list, int n);
void swap(int *a, int *b);

int main(int argc, char* argv[]) {

    FILE *fp = fopen(argv[1], ""r"");

    struct timeval startTime, endTime;
    int diffTime;

    int *read_order_list;
    int num_of_records;
    int i;
    char buffer[101];

    fseek(fp, 0, SEEK_END);
    num_of_records = ftell(fp) / 100;
    read_order_list = malloc(sizeof(int) * num_of_records +1);

    GenRecordSequence(read_order_list, num_of_records);

    gettimeofday(&startTime, NULL);

    for(i=0; i<num_of_records; i++) {
        fseek(fp, read_order_list[i]*100, SEEK_SET);
        fread(buffer, sizeof(char), 100, fp);
        memset(buffer, 0, 100);
    }

    gettimeofday(&endTime, NULL);
    diffTime = (endTime.tv_usec - startTime.tv_usec) * 1000;
    printf(""#records: %d timecost: %d us\n"", num_of_records, diffTime);

    return 0;
}

void GenRecordSequence(int *list, int n) {

    int i, j, k;

    srand((unsigned int)time(0));

    for(i=0; i<n; i++)
        list[i] = i;

    for(i=0; i<SUFFLE_NUM; i++) {
        j = rand() % n;
        k = rand() % n;
        swap(&list[j], &list[k]);
    }

    return;
}

void swap(int *a, int *b) {
    
    int tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;

    return;
}
",19,591,557
"int main(int argc, char *argv[]) {

    int fd;
    int offset = atoi(argv[2]);
    int inputlen = strlen(argv[3]);
    int  filelen, diflen; 
    char *temp;
    
    if((fd = open(argv[1], O_RDWR)) == -1) {
        perror(""file openning error"");
        return 1;
    }

    if((filelen = lseek(fd, 0, SEEK_END)) == -1) {
        perror(""lseek END error"");
        close(fd);
        return 1;
    }

    diflen = filelen - offset;
    temp = malloc(sizeof(char) * diflen + 1);

    if(lseek(fd, offset, SEEK_SET) == -1) {
        perror(""lseek offset error"");
        close(fd);
        return 1;
    }

    read(fd, temp, diflen);


    if(lseek(fd, offset, SEEK_SET) == -1) {
        perror(""lseek offset error"");
        close(fd);
        return 1;
    }

    write(fd, argv[3], inputlen);
    write(fd, temp, diflen);

    puts(""file insert success"");

    close(fd);
    free(temp);
    return 0;
}    
",19,592,358
"typedef int index;
#define YES 1
#define NO 0

int n, W, maxprofit, numbest;
int *bestset, *include, *p, *w;

bool promising(int, int, int);

void knapsack(index i, int profit, int weight) {
    printf(""index\t = %d\n"", i);
    printf(""profit\t = %d\n"", profit);
    printf(""weight\t = %d\n"", weight);

    if((weight <= W) && (profit > maxprofit)) {
        maxprofit = profit;
        numbest = i;
        for(int j = 1; j <= n; j++)
            bestset[j] = include[j];
        printf(""maxprofit = %d\n"", maxprofit);
    }

    if(promising(i, profit, weight)) {
        include[i+1] = YES;
        knapsack(i+1, profit+p[i+1], weight+w[i+1]);
        include[i+1] = NO;
        knapsack(i+1, profit, weight);
    }
}

bool promising(index i, int profit, int weight) {
    index j, k;
    int totweight;
    float bound;

    if(weight >= W) {
        printf(""x\n"");
        printf(""\n"");
        return false;
    }
    else {
        j = i+1;
        bound = profit;
        totweight = weight;
        while((j <= n) && (totweight + w[j] <= W)) {
            totweight = totweight + w[j];
            bound = bound + p[j];
            j++;
        }

        k = j;
        if(k <= n) 
            bound = bound + (W-totweight) * p[k] / w[k];
        printf(""bound\t = %.0f\n"", bound);

        if(bound > maxprofit) {
            printf(""\n"");
            return true;
        }
        else {
            printf(""x\n\n"");
            return false;
        }

        return bound > maxprofit;
    }
}


void main() {

    printf(""n = "");
    scanf(""%d"", &n);
    printf(""W = "");
    scanf(""%d"", &W);

    w = (int *)malloc(sizeof(int) * n + 1);
    p = (int *)malloc(sizeof(int) * n + 1);
    bestset = (int *)malloc(sizeof(int) * n + 1);
    include = (int *)malloc(sizeof(int) * n + 1);
    
    printf(""w[1...n] = "");
    for(int i = 1; i <= n; i++)
        scanf(""%d"", &w[i]);
    printf(""p[1...n] = "");
    for(int i = 1; i <= n; i++)
        scanf(""%d"", &p[i]);
    printf(""\n"");

    knapsack(0, 0, 0);

    printf(""bestset[1..n] = "");
    for(int i = 1; i <= numbest; i++)
        printf(""%d "", bestset[i]);
    printf(""\n"");

    free(w);
    free(p);
    free(bestset);
    free(include);
}
",19,593,842
"int main(int argc, char *argv[]) {

    int rfd, wfd;
    char buffer[101];
    size_t count;

    if((rfd = open(argv[1], O_RDONLY)) == -1) {
        perror(""rfd file opening error"");
        return 1;
    }
    if((wfd = open(argv[2], O_WRONLY|O_CREAT|O_TRUNC, 0751)) == -1) {
        perror(""wfd file openning error"");
        return 1;
    }
    while((count = read(rfd, buffer, 100)) > 0) {
        if(write(wfd, buffer, count) < count) {
            perror(""file copying error"");
            close(rfd);
            close(wfd);
            return 1;
        }
    }

    puts(""file copying success"");

    close(rfd);
    close(wfd);

    return 0;
}
",19,594,255
"void floyd2(int n, int **W, int **D, int **P) {
    int i, j, k; 

    for(i = 0; i <= n; i++) 
        for(j = 0; j <= n; j++) 
            P[i][j] = 0;

    for(i = 0; i <= n; i++) 
        for(j = 0; j <= n; j++) 
            D[i][j] = W[i][j]; 

    for(k = 1; k <= n; k++) 
        for(i = 1; i <= n; i++)
            for(j = 1; j <= n; j++)
                if(D[i][k] + D[k][j] < D[i][j]) { 
                    P[i][j] = k; 
                    D[i][j] = D[i][k] + D[k][j]; 
                }
}

void path(int q, int r, int **P) {
    if(P[q][r] != 0) { 
        path(q, P[q][r], P); 
        printf(""v%d -> "", P[q][r]);
        path(P[q][r], r, P);
    }
}

int** init_matrix(int size) { 
    int **matrix = (int**)malloc(sizeof(int*) * size); 
    for(int i = 0; i < size; i++) {
        matrix[i] = (int*)malloc(sizeof(int) * size);
        memset(matrix[i], 0, sizeof(int)*size); 
    }

    return matrix;
}

void main() {

    int n = 5; 
    int **W = init_matrix(n + 1); 
    int **D = init_matrix(n + 1); 
    int **P = init_matrix(n + 1);

    for(int i = 1; i <= n; i++) 
        for(int j = 1; j <= n; j++)
            scanf(""%d"", &W[i][j]);

    floyd2(n, W, D, P); 

    printf(""\n"");
    for(int i = 1; i <= n; i++) { 
        for(int j = 1; j <= n; j++)
            printf(""%d "", D[i][j]);
        printf(""\n"");
    }
        
    printf(""\n"");
    for(int i = 1; i <= n; i++) { 
        for(int j = 1; j <= n; j++)
            printf(""%d "", P[i][j]);
        printf(""\n"");
    }
    
    printf(""\n"");
    for(int i = 1; i <= n; i++) { 
        for(int j = 1; j <= n; j++) {
            if(P[i][j] != 0) {
                printf(""Path v%d ~ v%d: v%d -> "", i, j, i); 
                path(i, j, P);
                printf(""v%d\n"", j);
            }
        }
    }
}
",19,595,789
"#define INF 9999

typedef int number;
typedef int index;

typedef struct _Edge {
    int j;
    int touch;
    int length;
} edge;

typedef edge set_of_edges;

void dijkstra(int n, number **W, set_of_edges *F) {
    index i, vnear;
    edge e;
    index touch[n];
    number length[n];

    for(i = 1; i < n; i++) {
        touch[i] = 1;
        length[i] = W[0][i];
    }

    for(int j = 0; j < n-1; j++) {
        int min = INF;
        for(i = 1; i < n; i++) {
            if(0 <= length[i] && length[i] <= min) {
                min = length[i];
                vnear = i;
            }
        }
        
        e.j = vnear;
        e.touch = touch[vnear];
        e.length = length[vnear];

        F[vnear].j = e.j;
        F[vnear].touch = e.touch;
        F[vnear].length = e.length;

        
        for(i = 1; i < n; i++) {
            if(length[vnear] + W[vnear][i] < length[i]) {
                length[i] = length[vnear] + W[vnear][i];
                touch[i] = vnear + 1;
            }
        }
        length[vnear] = -1;
    }
}

int main() {
    int num_of_Vertex;

    printf(""-----input-----\n"");
    printf(""num of Vertex = "");
    scanf(""%d"", &num_of_Vertex);

    edge F[num_of_Vertex];
    number **W = (int **)malloc(sizeof(int) * num_of_Vertex);
    for(int i = 0; i < num_of_Vertex; i++)
        W[i] = (int *)malloc(sizeof(int) * num_of_Vertex);

    printf(""insert weight graph\n"");
    for(int i = 0; i < num_of_Vertex; i++)
        for(int j = 0; j < num_of_Vertex; j++)
            scanf(""%d"", &W[i][j]);

    dijkstra(num_of_Vertex, W, F);

    printf(""\n-----output-----\n"");
    for(int i = 1; i < num_of_Vertex; i++) 
        printf(""1 -> %d, length = %d, touch = %d\n"",
                F[i].j + 1, F[i].length, F[i].touch);
}
",19,596,703
"int main(int argc, char *argv[]) {

    FILE *fp;

    fp = fopen(argv[1], ""r+"");

    long offset = atol(argv[2]);
    int deletelen = atoi(argv[3]);

    fseek(fp, 0, SEEK_END);
    int filelen = ftell(fp);
    char *buf = malloc(sizeof(char) * (filelen - offset - deletelen) +1);
    char ch;
    int count = 0;

    fseek(fp, offset + deletelen, SEEK_SET);

    while((ch = fgetc(fp)) != EOF) {
        buf[count] = ch;
        count++;
    }

    fseek(fp, offset, SEEK_SET);

    fwrite(buf, sizeof(char), strlen(buf), fp);

    truncate(argv[1], filelen - deletelen);

    fclose(fp);
    free(buf);

    return 0;
}
",19,597,260
"int main(void){
    long house_nr = 0, nr_presents = 0;

    while(1){
        
        for(long i = 1; i <= house_nr; i++){
            
            if((house_nr%i == 0) && (house_nr / i < 50)){   
                    
                    nr_presents += i * 11;
            }
        }

        
        if(nr_presents >= 33100000){
            printf(""answer=%ld\n"", house_nr);
            break;
        }

        if(house_nr%10000 == 0)
            printf(""%ld - %ld\n"", house_nr, nr_presents);
        house_nr++;
        nr_presents = 0;
    }

    return EXIT_SUCCESS;
}
",20,598,214
"#define NR_OF_COLS 16

int main(void){
    long answer = 0;
    int numbers[NR_OF_COLS], numbers_index = 0;

    FILE * fp_data;
    if(!(fp_data = fopen(""data"", ""r""))){
        fprintf(stderr, ""Error opening file\n"");
        return EXIT_FAILURE;
    }

    char * data_read = NULL, * curr_number;
    size_t len = 0;
    ssize_t read;

    while((read = getline(&data_read, &len, fp_data)) != -1){
        
        
        curr_number = strtok(data_read, ""\t"");
        while(curr_number != NULL){
            numbers[numbers_index] = atoi(curr_number);
            numbers_index++;
            curr_number = strtok(NULL, ""\t"");
        }

        numbers_index = 0;

        
        for(int i = 0; i < NR_OF_COLS; i++){
            for(int j = i + 1; j < NR_OF_COLS; j++){
                if(numbers[i] % numbers[j] == 0){
                    answer += (numbers[i] / numbers[j]);
                    break;
                }
                else if(numbers[j] % numbers[i] == 0){
                    answer += (numbers[j] / numbers[i]);
                    break;
                }
            }
        }
    }

    printf(""answer=%ld\n"", answer);

    free(data_read);
    free(curr_number);
    fclose(fp_data);
    return EXIT_SUCCESS;
}",20,599,427
"#define DATA_TO_FILL 35651584

char input[60000000] = ""11110010111001001"";
char dummy[60000000], checksum[60000000];


int main(void){
    
    while(strlen(input) < DATA_TO_FILL){
        int len = strlen(input);

        
        input[len - 1] = '0';

        
        for(int i = len, j = len; i >= 0; i--, j++){
            if(input[i] == '0'){
                input[j] = '1';
            }
            else{
                input[j] = '0';
            }

        }
    }

    
    input[DATA_TO_FILL] = '\0';
    strcpy(checksum, input);
    
    
    while((strlen(checksum))%2 == 0){
        memset(dummy, 0, sizeof(dummy));

        int len = strlen(checksum);
        for(int i = 0, j = 0; i < len; i += 2, j++){
            if(checksum[i] == checksum[i + 1]){
                dummy[j] = '1';
            }
            else{
                dummy[j] = '0';
            }
        }
        strcpy(checksum, dummy);
    }

    printf(""checksum=%s (len=%ld)\n"", checksum, strlen(checksum));

    return EXIT_SUCCESS;
}
",20,600,412
"#define _GNU_SOURCE





#include ""md5.c""

int main(){
   char * msg = ""abbhdwsy"", * dummy = NULL;
   char code[9] = ""--------\0""; int code_counter = 0;
   bool done[8] = {false};

   long index = 0;
   size_t len = 0;
   uint8_t * md5_result;

   clock_t start = clock(), diff;
   while(1){
      asprintf(&dummy,""%s%ld"" , msg, index);
      len = strlen(dummy);
      md5(dummy, len);

      md5_result = (uint8_t *) &h0;

      char str[10];
      sprintf(str, ""%2.2X%2.2X%2.2X%2.2X"", md5_result[0], md5_result[1], md5_result[2], md5_result[3]);

      if(strncmp(str, ""00000"", 5) == 0){
         printf(""hash found - input=%s - MD5=%s - index=%ld\n"", dummy, str, index);
         int index = str[5] - '0';

         if(code_counter >= 8){
            printf(""done! code=%s\n"", code);
            diff = clock() - start;
            int msec = diff * 1000 / CLOCKS_PER_SEC;
            printf(""time: %ds %dms"", msec/1000, msec%1000);
            break;
         }
         else{
            if( (index < 8) && (done[index] == false) ){
               code[index] = str[6];
               done[index] = true;
               code_counter++;
               printf(""current code = %s\n\n"", code);
            }
         }
      }
      index++;
   }
   return 0;
}
",20,601,496
"void parse_instructions(void);

int regs[4] = {0};
int curr_instr = 0, max_instr = 0;

struct instructions_s {
    enum instructions {cpy_reg, cpy_val, inc, dec, jnz_reg, jnz_val} cmd;
    int x;
    int y;
} instr[1000];


int main(void){
    parse_instructions();
    max_instr = curr_instr;
    curr_instr = 0;

    regs[2] = 1;

    while(curr_instr < max_instr){
        switch(instr[curr_instr].cmd){
            case 0 :
                regs[instr[curr_instr].y] = regs[instr[curr_instr].x];
                curr_instr++;
                break;

            case 1 :
                regs[instr[curr_instr].y] = instr[curr_instr].x;
                curr_instr++;
                break;

            case 2 :
                regs[instr[curr_instr].x]++;
                curr_instr++;
                break;

            case 3 :
                regs[instr[curr_instr].x]--;
                curr_instr++;
                break;

            case 4 :
                if(regs[instr[curr_instr].x] != 0){
                    curr_instr += instr[curr_instr].y;
                }
                else{
                    curr_instr++;
                }
                break;

            case 5:
                if(instr[curr_instr].x != 0){
                    curr_instr += instr[curr_instr].y;
                }
                else{
                    curr_instr++;
                }
                break;

            default :
                printf(""Not a valid instruction!\n"");
                exit(EXIT_FAILURE);
        }
    }

    printf(""ans=%d\n"", regs[0]);
    return EXIT_SUCCESS;
}

void parse_instructions(void){
    FILE *fp;
    char * data_read = NULL;
    size_t len; ssize_t read;

    if(!(fp = fopen(""data"", ""r""))){
        fprintf(stderr, ""Error opening file\n"");
        exit(EXIT_FAILURE);
    }

    while((read = getline(&data_read, &len, fp)) != -1){
        data_read[strcspn(data_read, ""\r\n"")] = 0;  

        switch(data_read[0]){
            case 'c' :
                if(isalpha(data_read[4]) != 0){         
                    instr[curr_instr].cmd = cpy_reg;
                    instr[curr_instr].x = data_read[4] - 97;
                    instr[curr_instr].y = data_read[6] - 97;
                }
                else{                                               
                    instr[curr_instr].cmd = cpy_val;
                    instr[curr_instr].x = atoi(data_read + 4);
                    instr[curr_instr].y = data_read[strlen(data_read) - 1] - 97;
                }
                break;

            case 'i' :
                instr[curr_instr].cmd = inc;
                instr[curr_instr].x = data_read[4] - 97;
                break;

            case 'd' :
                instr[curr_instr].cmd = dec;
                instr[curr_instr].x = data_read[4] - 97;
                break;

            case 'j' :
                if(isalpha(data_read[4]) != 0){
                    instr[curr_instr].cmd = jnz_reg;
                    instr[curr_instr].x = data_read[4] - 97;
                    instr[curr_instr].y = atoi(data_read + 6);
                }
                else{
                    instr[curr_instr].cmd = jnz_reg;
                    instr[curr_instr].x = atoi(data_read + 4);
                    instr[curr_instr].y = atoi(data_read + 6);
                }
                break;

            default :
                printf(""Not a valid instruction!\n"");
                exit(EXIT_FAILURE);
        }

        curr_instr++;
    }

    
    fclose(fp);
    free(data_read);
}",20,602,1186
"#define NR_ELEMENTS 20
#define LITERS_TO_STORE 150

int main(void){
    int input[NR_ELEMENTS] = {50, 44, 11, 49, 42, 46, 18, 32, 26, 40, 21, 7, 18, 43, 10, 47, 36, 24, 22, 40};
    int multiplier[NR_ELEMENTS] = {0};
    int nr_jars_needed[10] = {0};
    int result = 0, nr_jars = 0;

    
    
    
    
    for(int i = 0; i < pow(2, NR_ELEMENTS); i++){
        for(int j = 0; j < NR_ELEMENTS; j++){
            multiplier[NR_ELEMENTS - 1 - j] = (i >> (NR_ELEMENTS - 1 -j)) & 1;
        }

        
        
        for(int k = 0; k < NR_ELEMENTS; k++){
            result += input[k] * multiplier[k];
            if(multiplier[k] == 1){
                nr_jars++;
            }
        }

        
        
        if(result == LITERS_TO_STORE){
            nr_jars_needed[nr_jars]++;
        }

        result = 0;
        nr_jars = 0;
    }

    
    for(int i = 0; i < 10; i++){
        if(nr_jars_needed[i] > 0){
            printf(""answer=%d\n"", nr_jars_needed[i]);
            break;
        }
    }

    return EXIT_SUCCESS;
}",20,603,481
"int main(void){
    int num1, num2, product, i, str_len, answer;
    char numb_str[18];
    bool palindromic = true;

    for(num1 = 0; num1 < 1000; num1++){
        for(num2 = 0; num2 < 1000; num2++){
            product = num1 * num2;

            
            sprintf(numb_str, ""%d"", product);
            str_len = strlen(numb_str);

            
            for(i = 0; i < str_len / 2; i++){
                if(numb_str[i] != numb_str[str_len - 1 - i]){
                    palindromic = false;
                    break;
                }
            }

            
            
            if(palindromic && product > answer){
                answer = product;
            }

            palindromic = true;
        }
    }
    
    printf(""answer=%d\n"", answer);
    return EXIT_SUCCESS;
}",20,604,271
"char str[] = ""R4,R1,L2,R1,L1,L1,R1,L5,R1,R5,L2,R3,L3,L4,R4,R4,R3,L5,L1,R5,R3,L4,R1,R5,L1,R3,L2,R3,R1,L4,L1,R1,L1,L5,R1,L2,R2,L3,L5,R1,R5,L1,R188,L3,R2,R52,R5,L3,R79,L1,R5,R186,R2,R1,L3,L5,L2,R2,R4,R5,R5,L5,L4,R5,R3,L4,R4,L4,L4,R5,L4,L3,L1,L4,R1,R2,L5,R3,L4,R3,L3,L5,R1,R1,L3,R2,R1,R2,R2,L4,R5,R1,R3,R2,L2,L2,L1,R2,L1,L3,R5,R1,R4,R5,R2,R2,R4,R4,R1,L3,R4,L2,R2,R1,R3,L5,R5,R2,R5,L1,R2,R4,L1,R5,L3,L3,R1,L4,R2,L2,R1,L1,R4,R3,L2,L3,R3,L2,R1,L4,R5,L1,R5,L2,L1,L5,L2,L5,L2,L4,L2,R3"";

enum e_coord {NORTH, EAST, SOUTH, WEST};

enum e_coord coord_next = NORTH;
enum e_coord coord_prev = NORTH;

int current_char = 0, current_step = 0, dummy_step = 0;
char c;
signed int x = 0, y = 0;


int main() {
   while (str[current_char] != '\0') {
      c = str[current_char];

      if(c != ',') {
         if(c == 'R'){
            (coord_prev == WEST) ? coord_next = NORTH : coord_next++;
         }

         else if(c == 'L') {
            (coord_prev == NORTH) ? coord_next = WEST : coord_next--;
         }

         else {
            current_step = c - '0';
            dummy_step = dummy_step * 10 + current_step;

            if( (str[current_char + 1] == ',') || (str[current_char + 1] == '\0') ) {
               if(dummy_step != 0){
                  current_step = dummy_step;
                  dummy_step = 0;
               }

               coord_prev = coord_next;

               switch(coord_next){
                  case NORTH :
                     y += current_step;
                     break;
                  case EAST :
                     x += current_step;
                     break;
                  case SOUTH :
                     y -= current_step;
                     break;
                  case WEST :
                     x -= current_step;
                     break;
                  }
            }
         }
      }
      current_char++;
   }

   printf(""done! (x=%d, y=%d => total=%d)\n"", x, y, abs(x) + abs(y));
   return 0;
}
",20,605,960
"int main(void){
    int i, j;
    long answer = 0;
    bool is_prime = true;


    for(i = 2; i < 2000000; i++){
        
        for(j = 2; j <= i/2; j++){
            if(i % j == 0){
                is_prime = false;
                break;
            }
        }

        if(is_prime){
            answer += i;
        }

        is_prime = true;
    }

    printf(""answer=%ld\n"", answer);
    return EXIT_SUCCESS;
}
",20,606,156
"int main(void){
    long a = 722, b = 354;
    char a_hex[100], b_hex[100];
    int answer = 0;

    for(int i = 0; i < 5000000; i++){
        do{
            a *= 16807;
            a = a % 2147483647;
        }while(a % 4 != 0);

        do{
            b *= 48271;
            b = b % 2147483647;
        }while(b % 8 != 0);

        sprintf(a_hex, ""%020X"", (int) a);
        sprintf(b_hex, ""%020X"", (int) b);

        int diff_flag = 0;
        for(int i = 16; i < 20; i++){
            if(a_hex[i] != b_hex[i]){
                diff_flag = 1;
            }
        }

        (diff_flag == 0) ? (answer++) : (diff_flag = 0);
    }

    printf(""answer=%d\n"", answer);

    return EXIT_SUCCESS;
}
",20,607,325
"#define STEP_SIZE 301
#define TOTAL_LEN 2018
int array[TOTAL_LEN];

int main(void){
    int curr_nr = 0, curr_pos = 0;

    while(curr_nr < TOTAL_LEN - 1){
        for(int i = 0; i < STEP_SIZE; i++){
            if(curr_pos < curr_nr){
                curr_pos++;
            }
            else{
                curr_pos = 0;
            }
        }
        curr_pos++;

        
        for(int i = curr_nr; i > curr_pos; i--){
            array[i] = array[i - 1];
        }

        curr_nr++;
        array[curr_pos] = curr_nr;
    }

    printf(""answer=%d\n"", array[curr_pos + 1]);
    return EXIT_SUCCESS;
}
",20,608,240
"int main(void){
    int answer1 = 0, answer2 = 0, curr_level = 1;
    FILE *fp;

    int garbage_flag = 0;

    
    if(!(fp = fopen(""data"", ""r""))){
        fprintf(stderr, ""Error opening file\n"");
        return EXIT_FAILURE;
    }

    char c;
    while((c = fgetc(fp)) != EOF){
        if(garbage_flag == 0){
            switch(c){
                case '{' :
                    answer1 += curr_level;
                    curr_level++;
                    break;
                case '}' :
                    curr_level--;
                    break;
                case '<' :
                    garbage_flag = 1;
                    break;
                case '!' :
                    fgetc(fp); 
                    break;
            }
        }
        else{
            switch(c){
                case '>' :
                    garbage_flag = 0;
                    break;
                case '!' :
                    fgetc(fp); 
                    break;
                default :
                    answer2++;
            }
        }
    }

    printf(""answer1=%d\nanswer2=%d\n"", answer1, answer2);

    fclose(fp);
    return EXIT_SUCCESS;
}
",20,609,341
"#define ROWS 6
#define COLS 50

bool screen[ROWS][COLS] = {false};
int x = 0, y = 0, char_index;
char * loc;

int main(){
   FILE * fp_data;
   fp_data = fopen(""data"", ""r"");

   char * data_read = NULL;
   size_t len = 0;
   ssize_t read;

   while((read = getline(&data_read, &len, fp_data)) != -1){
      if(strstr(data_read, ""rect"") != NULL){
         loc = strstr(data_read, ""rect "");
         char_index = (int)(loc - data_read) + 5;
         while(isdigit(data_read[char_index]) != 0){
            x = x * 10 + (data_read[char_index] - '0');
            char_index++;
         }
         char_index++;
         while(isdigit(data_read[char_index]) != 0){
            y = y * 10 + (data_read[char_index] - '0');
            char_index++;
         }

         for(int row = 0; row < y; row++){
            for(int col = 0; col < x; col++){
               screen[row][col] = true;
            }
         }
      }

      else{
         loc = strstr(data_read, ""="");
         char_index = (int)(loc - data_read);
         while(isdigit(data_read[char_index + 1]) != 0){
            x = x * 10 + data_read[char_index + 1] - '0';
            char_index++;
         }

         loc = strstr(data_read, ""by "");
         char_index = (int)(loc - data_read);
         while(isdigit(data_read[char_index + 3]) != 0){
            y = y * 10 + data_read[char_index + 3] - '0';
            char_index++;
         }

         if(strstr(data_read, ""column"") != NULL){
            for(int pixels_down = 0; pixels_down < y; pixels_down++){
               bool temp = screen[ROWS - 1][x];
               for(int i = (ROWS - 1); i > 0; i--){
                  screen[i][x] = screen[i - 1][x];
               }
               screen[0][x] = temp;
            }
         }
         else if(strstr(data_read, ""row"") != NULL){
            x ^= y; 
            y ^= x;
            x ^= y;

            for(int pixels_right = 0; pixels_right < x; pixels_right++){
               bool temp = screen[y][COLS - 1];
               for(int i = (COLS - 1); i > 0; i--){
                  screen[y][i] = screen[y][i - 1];
               }
               screen[y][0] = temp;
            }
         }
      }
      x = 0; y = 0;
   }

   int lit_pixels = 0;
   for(int row = 0; row < ROWS; row++){
      for(int col = 0; col < COLS; col++){
         if(screen[row][col] == true){
            printf(""#"");
            lit_pixels++;
         }
         else{
            printf(""."");
         }
      }
      printf(""\n"");
   }

   printf(""\nanswer=%d\n"", lit_pixels);
   return 0;
}
",20,610,921
"int main(void){
    FILE *fp;
    if(!(fp = fopen(""data"", ""r""))){
        fprintf(stderr, ""Error opening file\n"");
        return EXIT_FAILURE;
    }

    char current_char, next_char;       
    long answer = 0;                        

    
    while((next_char = fgetc(fp)) != EOF) {
        if(current_char == next_char){
            answer += (current_char - '0'); 
        }

        current_char = next_char;
    }

    
    
    fseek(fp, 0, SEEK_SET);
    current_char = fgetc(fp);
    fseek(fp, -1, SEEK_END);
    next_char = fgetc(fp);

    if(current_char == next_char){
        answer += (current_char - '0');
    }

    printf(""answer=%ld\n"", answer);

    fclose(fp);
    return EXIT_SUCCESS;
}",20,611,265
"int main(void){
    long a = 722, b = 354;
    char a_hex[100], b_hex[100];
    int answer = 0;

    for(int i = 0; i < 40000000; i++){
        a *= 16807;
        b *= 48271;

        a = a % 2147483647;
        b = b % 2147483647;

        sprintf(a_hex, ""%020X"", (int) a);
        sprintf(b_hex, ""%020X"", (int) b);

        int diff_flag = 0;
        for(int i = 16; i < 20; i++){
            if(a_hex[i] != b_hex[i]){
                diff_flag = 1;
            }
        }

        (diff_flag == 0) ? (answer++) : (diff_flag = 0);
    }

    printf(""answer=%d\n"", answer);

    return EXIT_SUCCESS;
}
",20,612,292
"void parse_instructions(void);

int regs[4] = {0};
int curr_instr = 0, max_instr = 0;

struct instructions_s {
    enum instructions {cpy_reg, cpy_val, inc, dec, jnz_reg, jnz_val} cmd;
    int x;
    int y;
} instr[1000];


int main(void){
    parse_instructions();
    max_instr = curr_instr;
    curr_instr = 0;

    while(curr_instr < max_instr){
        switch(instr[curr_instr].cmd){
            case 0 :
                regs[instr[curr_instr].y] = regs[instr[curr_instr].x];
                curr_instr++;
                break;

            case 1 :
                regs[instr[curr_instr].y] = instr[curr_instr].x;
                curr_instr++;
                break;

            case 2 :
                regs[instr[curr_instr].x]++;
                curr_instr++;
                break;

            case 3 :
                regs[instr[curr_instr].x]--;
                curr_instr++;
                break;

            case 4 :
                if(regs[instr[curr_instr].x] != 0){
                    curr_instr += instr[curr_instr].y;
                }
                else{
                    curr_instr++;
                }
                break;

            case 5:
                if(instr[curr_instr].x != 0){
                    curr_instr += instr[curr_instr].y;
                }
                else{
                    curr_instr++;
                }
                break;

            default :
                printf(""Not a valid instruction!\n"");
                exit(EXIT_FAILURE);
        }
    }

    printf(""ans=%d\n"", regs[0]);
    return EXIT_SUCCESS;
}

void parse_instructions(void){
    FILE *fp;
    char * data_read = NULL;
    size_t len; ssize_t read;

    if(!(fp = fopen(""data"", ""r""))){
        fprintf(stderr, ""Error opening file\n"");
        exit(EXIT_FAILURE);
    }

    while((read = getline(&data_read, &len, fp)) != -1){
        data_read[strcspn(data_read, ""\r\n"")] = 0;  

        switch(data_read[0]){
            case 'c' :
                if(isalpha(data_read[4]) != 0){         
                    instr[curr_instr].cmd = cpy_reg;
                    instr[curr_instr].x = data_read[4] - 97;
                    instr[curr_instr].y = data_read[6] - 97;
                }
                else{                                               
                    instr[curr_instr].cmd = cpy_val;
                    instr[curr_instr].x = atoi(data_read + 4);
                    instr[curr_instr].y = data_read[strlen(data_read) - 1] - 97;
                }
                break;

            case 'i' :
                instr[curr_instr].cmd = inc;
                instr[curr_instr].x = data_read[4] - 97;
                break;

            case 'd' :
                instr[curr_instr].cmd = dec;
                instr[curr_instr].x = data_read[4] - 97;
                break;

            case 'j' :
                if(isalpha(data_read[4]) != 0){
                    instr[curr_instr].cmd = jnz_reg;
                    instr[curr_instr].x = data_read[4] - 97;
                    instr[curr_instr].y = atoi(data_read + 6);
                }
                else{
                    instr[curr_instr].cmd = jnz_reg;
                    instr[curr_instr].x = atoi(data_read + 4);
                    instr[curr_instr].y = atoi(data_read + 6);
                }
                break;

            default :
                printf(""Not a valid instruction!\n"");
                exit(EXIT_FAILURE);
        }

        curr_instr++;
    }

    
    fclose(fp);
    free(data_read);
}",20,613,1174
"char line_nodash[100];
char line_brackets[20];
long char_counter = 0, total_sector = 0;
char c = 'a';
int line_counter = 0, sector_ID = 0, processed = 0;

int main() {
   FILE * fp_data;
   fp_data = fopen(""data"", ""r"");

   char * data_read = NULL;
   size_t size = 0;

   fseek(fp_data, 0, SEEK_END);
   size = ftell(fp_data);
   rewind(fp_data);
   data_read = malloc((size + 1) * sizeof(* data_read));

   fread(data_read, size, 1, fp_data);
   data_read[size] = '\0';


   while(1){
      c = data_read[char_counter];
      if(c == '\0'){
         printf(""TOTAL=%ld (processed=%d)\n"", total_sector, processed);
         return 0;
      }

      while(c != '\n'){
         if(c == '['){
            char_counter++; size = 0;

            while(data_read[char_counter] != ']'){
               line_brackets[size] = data_read[char_counter];
               char_counter++; size++;
            }
            line_brackets[size] = '\0';
         }
         else{
            if(isalpha(c)){ 
               line_nodash[line_counter] = c;
               line_counter++;
            }
            if(isdigit(c)){
               sector_ID = sector_ID * 10 + (c - '0');
            }
            char_counter++;
         }

         c = data_read[char_counter];
      }

      line_nodash[line_counter] = '\0';
      line_counter = 0;
      char_counter++;
      #ifdef DEBUG
         printf(""line=%s\tbrackets=%s\tID=%d\n"", line_nodash, line_brackets, sector_ID);
      #endif

      int count[26] = {0}, parse_count = 0;

      while(line_nodash[parse_count] != '\0'){
         count[line_nodash[parse_count] - 'a']++;
         parse_count++;
      }

      #ifdef DEBUG
         for(int j = 0; j < 26; j++){
            if(count[j] != 0){

                  printf(""%c => %d\n"", j + 'a', count[j]);

            }
         }
      #endif

      parse_count = 0;
      int ok_counter = 0;
      bool is_ok = true;
      while(line_brackets[parse_count] != '\0'){
            if( (count[line_brackets[parse_count] - 'a']) < (count[line_brackets[parse_count + 1] - 'a']) ){ 
               is_ok = false;
               #ifdef DEBUG
                  printf(""smaller\n"");
               #endif
               break;
            }

            if( (count[line_brackets[parse_count] - 'a']) > (count[line_brackets[parse_count + 1] - 'a']) ){
               #ifdef DEBUG
                  printf(""bigger\n"");
               #endif
               ok_counter++;
            }

            if( (count[line_brackets[parse_count] - 'a']) == (count[line_brackets[parse_count + 1] - 'a']) ){
               if( (line_brackets[parse_count]) < (line_brackets[parse_count + 1]) ){ 
                  #ifdef DEBUG
                     printf(""same ok\n"");
                  #endif
                  ok_counter++;
               }
               else{
                  is_ok = false;
                  #ifdef DEBUG
                     printf(""same not ok\n"");
                  #endif
                  break;
               }
            }

         #ifdef DEBUG
            printf(""%c is %d\n"", line_brackets[parse_count], count[line_brackets[parse_count] - 'a']);
         #endif
         parse_count++;
      }

      if(is_ok){
         #ifdef DEBUG
            printf(""string is ok\n"");
         #endif
         total_sector += sector_ID;
      }
      #ifdef DEBUG
         else{
            printf(""string is not ok\n"");
         }
      #endif

      sector_ID = 0;
      processed++;
   }
   printf(""TOTAL=%ld (processed=%d)\n"", total_sector, processed);
   return 0;
}
",20,614,1200
"long answer = 0;
char * data_read = NULL;
size_t len; ssize_t read;
FILE *fp;

char *pass[50];

int main(void){
    int i = 0, j = 0;
    int not_valid_flag = 0;

    
    if(!(fp = fopen(""data"", ""r""))){
        fprintf(stderr, ""Error opening file\n"");
        return EXIT_FAILURE;
    }

    
    while((read = getline(&data_read, &len, fp)) != -1){
        data_read[strcspn(data_read, ""\r\n"")] = 0;  

        pass[i] = strtok(data_read, "" "");
        while(data_read != NULL){
            data_read = strtok(NULL, "" "");
            i++;
            pass[i] = data_read;
        }

        i = 0;
        while(pass[i] != NULL){
            j = i + 1;
            
            while(pass[j] != NULL){
                if(strcmp(pass[i], pass[j]) == 0){
                    not_valid_flag = 1;
                }
                j++;
            }
            i++;
        }

        if(not_valid_flag == 0){
            answer++;
        }

        not_valid_flag = 0;
        i = 0;
    }


    printf(""answer=%ld\n"", answer);

    free(data_read);
    fclose(fp);
    return EXIT_SUCCESS;
}",20,615,402
"#define SIZE_GRID 100
#define NR_OF_TIMES 100


bool lights[SIZE_GRID + 2][SIZE_GRID + 2] = {false};
bool dummy[SIZE_GRID + 2][SIZE_GRID + 2] = {false};

int main(void){
    
    FILE * fp_data;
    fp_data = fopen(""data"", ""r"");
    char * data_read = NULL;
    size_t len = 0;
    ssize_t read;
    int x_coord = 1, y_coord = 1;
    int nr_neighbours = 0, nr_lights_on = 0;

    
    while((read = getline(&data_read, &len, fp_data)) != -1){
        while(y_coord < SIZE_GRID + 1){
            if(data_read[y_coord - 1] == '#'){
                lights[x_coord][y_coord] = true;
            }
            else{
                lights[x_coord][y_coord] = false;
            }
            y_coord++;
        }
        y_coord = 1;
        x_coord++;
    }

    
    for(int times = 0; times < NR_OF_TIMES; times++){
        
        for(int i = 1; i < SIZE_GRID + 1; i++){
            for(int j = 1; j < SIZE_GRID + 1; j++){
                dummy[i][j] = lights[i][j];
            }
        }

        for(int i = 1; i < SIZE_GRID + 1; i++){
            for(int j = 1; j < SIZE_GRID + 1; j++){
                
                for(int k = -1; k < 2; k++){
                    for(int l = -1; l < 2; l++){
                        if(dummy[i + k][j + l]){
                            nr_neighbours++;
                        }
                    }
                }
                
                if(dummy[i][j]) nr_neighbours--;

                if(dummy[i][j]){
                    
                    if((nr_neighbours != 2) && (nr_neighbours != 3)){
                        lights[i][j] = false;
                    }
                }
                else{
                    
                    if(nr_neighbours == 3){
                        lights[i][j] = true;
                    }
                }

                nr_neighbours = 0;
            }
        }
    }

    for(int i = 1; i < SIZE_GRID + 1; i++){
        for(int j = 1; j < SIZE_GRID + 1; j++){
            if(lights[i][j]) nr_lights_on++;
        }
    }

    printf(""answer=%d\n"", nr_lights_on);

    return EXIT_SUCCESS;
}",20,616,779
"int main(void){
    int i = 1, j, sum = 0, nr_of_divisors = 0;

    while(1){
        
        for(j = 1; j <= i; j++){
            sum += j;
        }

        
        for(j = 1; j <= sum; j++){
            if(sum % j == 0) nr_of_divisors++;
        }

        
        if(nr_of_divisors > 500){
            printf(""answer=%d (nr=%d, nr_div=%d)\n"", sum, i, nr_of_divisors);
            break;
        }

        printf(""(%10d) %d\n"", i, nr_of_divisors);

        i++;
        sum = 0;
        nr_of_divisors = 0;
    }

    return EXIT_SUCCESS;
}",20,617,228
"long answer = 0;
int input[1001];
char * data_read = NULL;
size_t len; ssize_t read;
FILE *fp;

int main(void){
    
    if(!(fp = fopen(""data"", ""r""))){
        fprintf(stderr, ""Error opening file\n"");
        return EXIT_FAILURE;
    }

    
    
    int current_line = 0;
    while((read = getline(&data_read, &len, fp)) != -1){
        data_read[strcspn(data_read, ""\r\n"")] = 0;  
        input[current_line] = atoi(data_read);
        current_line++;
    }

    int next_pos = 0;
    int input_len = current_line;
    int current_pos = 0;

    while(next_pos < input_len){
        next_pos += input[current_pos];
        input[current_pos] < 3 ? input[current_pos]++ : input[current_pos]--;
        answer++;
        current_pos = next_pos;
    }

    printf(""answer=%ld\n"", answer);

    free(data_read);
    fclose(fp);
    return EXIT_SUCCESS;
}",20,618,324
"#define NR_PRIME 10001


int main(void){
    long answer = 1;
    int nr_of_primes_found = 0, i;
    bool is_prime = true;

    while(1){

        
        for(i = 2; i <= answer/2; i++){
            if(answer % i == 0){
                is_prime = false;
                break;
            }
        }

        
        if(is_prime){
            nr_of_primes_found++;

            
            if(nr_of_primes_found == NR_PRIME - 1){
                break;
            }           
        }

        is_prime = true;
        answer++;
    }


    printf(""answer=%ld\n"", answer);
    return EXIT_SUCCESS;
}",20,619,208
"int main(void){
    long input = 600851475143;
    int i;


    
    while(input%2 == 0){
        printf(""%d "", 2);
        input = input/2;
    }

    
    for(i = 3; i <= sqrt(input); i += 2){
        while(input%i == 0){
            printf(""%d "", i);
            input = input/i;
        }
    }

    
    if (input > 2) printf (""%ld "", input);
    printf(""\n"");
    
    return EXIT_SUCCESS;
}",20,620,159
"#define GRID_SIZE 1000
#define NR_OF_BURSTS 10000000

int grid[GRID_SIZE][GRID_SIZE]; 

int parse_data(void); 
void print_square(void);

int main(void){
    int true_grid_size = parse_data();

    int row = GRID_SIZE/2 - 1 + true_grid_size/2, col = GRID_SIZE/2 - 1 + true_grid_size/2;
    int direction = 0; 
    int nr_infected = 0;

    for(int steps = 0; steps < NR_OF_BURSTS; steps++){
        
        switch(grid[row][col]){
            case 0 : 
                (direction > 0) ? (direction--) : (direction = 3);
                break;
            case 1 : 
                break;
            case 2 : 
                (direction < 3) ? (direction++) : (direction = 0);
                break;
            case 3 : 
                switch(direction){
                    case 0 :
                        direction = 2;
                        break;
                    case 1 :
                        direction = 3;
                        break;
                    case 2 :
                        direction = 0;
                        break;
                    case 3 :
                        direction = 1;
                        break;
                }
                break;
        }

        
        switch(grid[row][col]){
            case 0 : 
                grid[row][col]++;
                break;
            case 1 : 
                grid[row][col]++;
                nr_infected++;
                break;
            case 2 : 
                grid[row][col]++;
                break;
            case 3 : 
                grid[row][col] = 0;
                break;
        }

        
        switch(direction){
            case 0 : 
                row--;
                break;
            case 1 : 
                col++;
                break;
            case 2 : 
                row++;
                break;
            case 3 : 
                col--;
                break;
        }
    }

    printf(""answer=%d\n"", nr_infected);
    return EXIT_SUCCESS;
}

void print_square(void){
    for(int i = 0; i < GRID_SIZE; i++){
        for(int j = 0; j < GRID_SIZE; j++){
            switch(grid[i][j]){
                case 0 : 
                    printf("". "");
                    break;
                case 1 : 
                    printf(""W "");
                    break;
                case 2 : 
                    printf(""# "");
                    break;
                case 3 : 
                    printf(""F "");
                    break;
            }
        }
        printf(""\n"");
    }
    printf(""\n"");
}

int parse_data(void){
    FILE *fp;

    if(!(fp = fopen(""data"", ""r""))){
        fprintf(stderr, ""Error opening file\n"");
        exit(EXIT_FAILURE);
    }

    int curr_x = GRID_SIZE/2 - 1, curr_y = GRID_SIZE/2 - 1;
    char c;
    while( (c = fgetc(fp)) != EOF ){
        switch(c){
            case '.' :
                grid[curr_y][curr_x] = 0;
                curr_x++;
                break;
            case '#' :
                grid[curr_y][curr_x] = 2;
                curr_x++;
                break;
            case '\n' :
                curr_y++;
                curr_x = GRID_SIZE/2 - 1;
                break;
        }
    }

    
    fclose(fp);

    return (curr_y - GRID_SIZE/2 + 1);
}
",20,621,986
"int data_array[8][26] = {0};
char output[8];

int main(){
   FILE * fp_data;
   fp_data = fopen(""data"", ""r"");

   char * data_read = NULL;
   size_t len = 0;
   ssize_t read;

   while((read = getline(&data_read, &len, fp_data)) != -1){
      for(int i = 0; i < 8; i++){
         data_array[i][(int)(data_read[i] - 'a')]++;
      }
   }

   int min = 100;
   for(int i = 0; i < 8; i++){
      for(int j = 0; j < 26; j++){
         if((data_array[i][j] < min) && (data_array[i][j] != 0)){
            output[i] = j + 'a';
            min = data_array[i][j];
         }

      }
      min = 100;
   }

   printf(""answer=%s\n"", output);
   return 0;
}
",20,622,290
"#define NR_OF_SUES 500

int main(void){
    
    
    
    int sues[NR_OF_SUES][10];
    int analysis[10] = {3, 7, 2, 3, 0, 0, 5, 3, 2, 1};
    int sue_nr = 0;
    int index = 0, amount = 0;
    bool found_her = true;


    
    for(int i = 0; i < NR_OF_SUES; i++){
        for(int j = 0; j < 10; j++){
            sues[i][j] = 999;
        }
    }

    
    FILE * fp_data;
    fp_data = fopen(""data"", ""r"");
    char * data_read = NULL, * token = NULL, * dummy = NULL;
    size_t len = 0;
    ssize_t read;

    while((read = getline(&data_read, &len, fp_data)) != -1){
        char * data_dummy = data_read;

        
        token = strtok(data_dummy, "":"");
        data_dummy = strtok(NULL, """");

        
        token = strtok(data_dummy, "","");
        while(token != NULL){
            
            if(strstr(token, ""children"") != NULL){
                index = 0;
            }
            else if(strstr(token, ""cats"") != NULL){
                index = 1;
            }
            else if(strstr(token, ""samoyeds"") != NULL){
                index = 2;
            }           
            else if(strstr(token, ""pomeranians"") != NULL){
                index = 3;
            }
            else if(strstr(token, ""akitas"") != NULL){
                index = 4;
            }
            else if(strstr(token, ""vizslas"") != NULL){
                index = 5;
            }
            else if(strstr(token, ""goldfish"") != NULL){
                index = 6;
            }
            else if(strstr(token, ""trees"") != NULL){
                index = 7;
            }
            else if(strstr(token, ""cars"") != NULL){
                index = 8;
            }
            else if(strstr(token, ""perfumes"") != NULL){
                index = 9;
            }

            
            dummy = token;
            while (*dummy){
                if(isdigit(*dummy)){
                    amount = (int) strtol(dummy, &dummy, 10);
                }
                else{
                    dummy++;
                }
            }

            
            sues[sue_nr][index] = amount;
            
            
            token = strtok(NULL, "","");
        }

        sue_nr++;
    }

    
    for(int i = 0; i < NR_OF_SUES; i++){
        for(int j = 0; j < 10; j++){
            if((sues[i][j] != 999) && (sues[i][j] != analysis[j])){
                    found_her = false;
            }
        }

        if(found_her){
            printf(""answer=%d\n"", i + 1);
            break;
        }
        else{
            found_her = true;
        }
    }

    return EXIT_SUCCESS;
}",20,623,876
"#define DATA_TO_FILL 272

char input[60000000] = ""11110010111001001"";
char dummy[60000000], checksum[60000000];


int main(void){
    
    while(strlen(input) < DATA_TO_FILL){
        int len = strlen(input);

        
        input[len - 1] = '0';

        
        for(int i = len, j = len; i >= 0; i--, j++){
            if(input[i] == '0'){
                input[j] = '1';
            }
            else{
                input[j] = '0';
            }

        }
    }

    
    input[DATA_TO_FILL] = '\0';
    strcpy(checksum, input);
    
    
    while((strlen(checksum))%2 == 0){
        memset(dummy, 0, sizeof(dummy));

        int len = strlen(checksum);
        for(int i = 0, j = 0; i < len; i += 2, j++){
            if(checksum[i] == checksum[i + 1]){
                dummy[j] = '1';
            }
            else{
                dummy[j] = '0';
            }
        }
        strcpy(checksum, dummy);
    }

    printf(""checksum=%s (len=%ld)\n"", checksum, strlen(checksum));

    return EXIT_SUCCESS;
}
",20,624,407
"#define _GNU_SOURCE




#include ""md5.c""

int main(){
   char * msg = ""abbhdwsy"", * dummy = NULL;
   char code[9]; int code_counter = 0;

   long index = 0;
   size_t len = 0;
   uint8_t * md5_result;

   clock_t start = clock(), diff;
   while(1){
      asprintf(&dummy,""%s%ld"" , msg, index);
      len = strlen(dummy);
      md5(dummy, len);

      md5_result = (uint8_t *) &h0;

      char str[10];
      sprintf(str, ""%2.2X%2.2X%2.2X%2.2X"", md5_result[0], md5_result[1], md5_result[2], md5_result[3]);

      if(strncmp(str, ""00000"", 5) == 0){
         printf(""hash found - input=%s - MD5=%s - index=%ld\n"", dummy, str, index);
         code[code_counter] = str[5];
         code_counter++;
         code[code_counter] = '\0';

         if(code_counter >= 8){
            printf(""done! code=%s\n"", code);
            diff = clock() - start;
            int msec = diff * 1000 / CLOCKS_PER_SEC;
            printf(""time: %ds %dms"", msec/1000, msec%1000);
            break;
         }
         else{
            printf(""current code = %s\n\n"", code);
         }
      }
      index++;
   }
   return 0;
}
",20,625,447
"long answer = 0;
int input[1001];
char * data_read = NULL;
size_t len; ssize_t read;
FILE *fp;

int main(void){
    
    if(!(fp = fopen(""data"", ""r""))){
        fprintf(stderr, ""Error opening file\n"");
        return EXIT_FAILURE;
    }

    
    
    int current_line = 0;
    while((read = getline(&data_read, &len, fp)) != -1){
        data_read[strcspn(data_read, ""\r\n"")] = 0;  
        input[current_line] = atoi(data_read);
        current_line++;
    }

    int next_pos = 0;
    int input_len = current_line;
    int current_pos = 0;

    while(next_pos < input_len){
        next_pos += input[current_pos];
        input[current_pos]++;
        answer++;
        current_pos = next_pos;
    }

    printf(""answer=%ld\n"", answer);

    free(data_read);
    fclose(fp);
    return EXIT_SUCCESS;
}",20,626,305
"#define GRID_SIZE 1000

int grid[GRID_SIZE][GRID_SIZE]; 

int parse_data(void); 


void print_square(void){
    for(int i = 0; i < GRID_SIZE; i++){
        for(int j = 0; j < GRID_SIZE; j++){
            (grid[i][j] == 0) ? printf("". "") : printf(""# "");
        }
        printf(""\n"");
    }
    printf(""\n"");
}

int main(void){
    int true_grid_size = parse_data();

    int row = GRID_SIZE/2 - 1 + true_grid_size/2, col = GRID_SIZE/2 - 1 + true_grid_size/2;
    int direction = 0; 
    int nr_infected = 0;

    for(int steps = 0; steps < 10000; steps++){
        if(grid[row][col] == 0){ 
            
            (direction > 0) ? (direction--) : (direction = 3);

            
            nr_infected++;
            grid[row][col] = 1;
        }
        else{ 
            
            (direction < 3) ? (direction++) : (direction = 0);

            
            grid[row][col] = 0;
        }

        
        switch(direction){
            case 0 : 
                row--;
                break;
            case 1 : 
                col++;
                break;
            case 2 : 
                row++;
                break;
            case 3 : 
                col--;
                break;
        }
    }

    printf(""answer=%d\n"", nr_infected);
    return EXIT_SUCCESS;
}

int parse_data(void){
    FILE *fp;

    if(!(fp = fopen(""data"", ""r""))){
        fprintf(stderr, ""Error opening file\n"");
        exit(EXIT_FAILURE);
    }

    int curr_x = GRID_SIZE/2 - 1, curr_y = GRID_SIZE/2 - 1;
    char c;
    while( (c = fgetc(fp)) != EOF ){
        switch(c){
            case '.' :
                grid[curr_y][curr_x] = 0;
                curr_x++;
                break;
            case '#' :
                grid[curr_y][curr_x] = 1;
                curr_x++;
                break;
            case '\n' :
                curr_y++;
                curr_x = GRID_SIZE/2 - 1;
                break;
        }
    }

    
    fclose(fp);

    return (curr_y - GRID_SIZE/2 + 1);
}
",20,627,701
"int main(void){
    long answer = 0;
    int small_nr = 99999, large_nr = 0, curr_number_int = 0;

    FILE * fp_data;
    if(!(fp_data = fopen(""data"", ""r""))){
        fprintf(stderr, ""Error opening file\n"");
        return EXIT_FAILURE;
    }

    char * data_read = NULL, * curr_number;
    size_t len = 0;
    ssize_t read;

    while((read = getline(&data_read, &len, fp_data)) != -1){
        
        curr_number = strtok(data_read, ""\t"");
        while(curr_number != NULL){
            curr_number_int = atoi(curr_number);
            
            
            if(curr_number_int < small_nr){
                small_nr = curr_number_int;
            }
            if(curr_number_int > large_nr){
                large_nr = curr_number_int;
            }
            curr_number = strtok(NULL, ""\t"");
        }

        answer += (large_nr - small_nr);
        small_nr = 99999;
        large_nr = 0;
    }

    printf(""answer=%ld\n"", answer);

    free(data_read);
    free(curr_number);
    fclose(fp_data);
    return EXIT_SUCCESS;
}",20,628,370
"int main() {
   FILE * fp_data;
   fp_data = fopen(""data"", ""r"");

   char c;
   int x = 1, y = 1;

   int answer_key[3][3] = {
      {1, 2, 3},
      {4, 5, 6},
      {7, 8, 9}
   };

   for(int lines = 0; lines < 5; lines++){
      while ((c = getc(fp_data)) != ('\n') && c != EOF) {
         switch(c){
            case 'R' :
               if(y < 2) {
                  y++;
               }
               break;
            case 'L' :
               if(y > 0) {
                  y--;
               }
               break;
            case 'U' :
               if(x > 0) {
                  x--;
               }
               break;
            case 'D' :
               if(x < 2) {
                  x++;
               }
               break;
         }
      }
      printf(""%d"", answer_key[x][y]);
   }

   return 0;
}
",20,629,297
"int main(void){
    long house_nr = 0, nr_presents = 0;

    while(1){
        
        for(long i = 1; i <= house_nr; i++){
            if(house_nr%i == 0){
                
                nr_presents += i * 10;
            }
        }

        
        if(nr_presents >= 33100000){
            printf(""answer=%ld\n"", house_nr);
            break;
        }

        if(house_nr%10000 == 0)
            printf(""%ld - %ld\n"", house_nr, nr_presents);
        house_nr++;
        nr_presents = 0;
    }

    return EXIT_SUCCESS;
}",20,630,196
"int main(void){
    char input[8] = ""hepxcrrq"";
    bool incr_straight = false, banned_letter = false;
    int amount_sequence = 0;
    char first_pair[1];

    printf(""%s\n"", input);

    while(1){
        
        for(int i = 0; i < 5; i++){
            if((input[i] + 1 == input[i + 1]) && (input[i + 1] + 1 == input[i + 2])){
                incr_straight = true;
                break;
            }
        }

        
        if((strstr(input, ""i"") != NULL) || (strstr(input, ""o"") != NULL) ||
            (strstr(input, ""l"") != NULL)){
            banned_letter = true;
        }

        
        for(int i = 0; i < 7; i++){
            if(input[i] == input[i + 1]){
                if(amount_sequence == 0){
                    amount_sequence++;
                    first_pair[0] = input[i];
                }

                else if(input[i] != first_pair[0]){
                    amount_sequence++;
                }
            }
        }

        
        if(incr_straight && !banned_letter && (amount_sequence > 1)){
            break;
        }

        
        input[7]++;
        for(int i = 7; i > 0; i--){
            if(input[i] == '{'){
                input[i] = 'a';
                input[i - 1]++;
            }
            else{
                break;
            }
        }

        
        incr_straight = false;
        banned_letter = false;
        amount_sequence = 0;
    }

    printf(""%s\n"", input);

    return EXIT_SUCCESS;
}",20,631,486
"long answer = 0;
char * data_read = NULL;
size_t len; ssize_t read;
FILE *fp;

char *pass[50];

int is_anagram(char *first_string, char *second_string){
    int first_char_counter[256] = {0}, second_char_counter[256] = {0};
    int counter;

    
    if(strlen(first_string) != strlen(second_string)){
        return 0;
    }

    
    for(counter = 0; first_string[counter] != '\0'; counter++){
      first_char_counter[first_string[counter]]++;
    }

    
    for(counter = 0; second_string[counter] != '\0'; counter++){
      second_char_counter[second_string[counter]]++;
    }

    
    for(counter = 0; counter < 256; counter++){
        if(first_char_counter[counter] != second_char_counter[counter])
            return 0;
    }
    return 1;
}

int main(void){
    int i = 0, j = 0;
    int not_valid_flag = 0;

    
    if(!(fp = fopen(""data"", ""r""))){
        fprintf(stderr, ""Error opening file\n"");
        return EXIT_FAILURE;
    }

    
    while((read = getline(&data_read, &len, fp)) != -1){
        data_read[strcspn(data_read, ""\r\n"")] = 0;  

        pass[i] = strtok(data_read, "" "");
        while(data_read != NULL){
            data_read = strtok(NULL, "" "");
            i++;
            pass[i] = data_read;
        }

        i = 0;
        while(pass[i] != NULL){
            j = i + 1;

            while(pass[j] != NULL){             
                if(is_anagram(pass[i], pass[j]) == 1){
                    not_valid_flag = 1;
                }
                j++;
            }
            i++;
        }

        if(not_valid_flag == 0){
            answer++;
        }

        not_valid_flag = 0;
        i = 0;
    }

    printf(""answer=%ld\n"", answer);

    free(data_read);
    fclose(fp);
    return EXIT_SUCCESS;
}",20,632,633
"#define MAX(x, y) (((x) > (y)) ? (x) : (y))

int properties[4][5];
int line_count = 0, property_count = 0;

int main(){
   FILE * fp_data;
   fp_data = fopen(""data"", ""r"");

   char * data_read = NULL;
   size_t len = 0;
   ssize_t read;

   
   while((read = getline(&data_read, &len, fp_data)) != -1){
      for(int char_count = 0; char_count < len; char_count++){
         char c = data_read[char_count];

         if(c == '-'){
            properties[line_count][property_count] = (data_read[char_count + 1] - '0') * -1;
            property_count++;
            char_count++;
         }
         else if(isdigit(c) != 0){
            properties[line_count][property_count] = data_read[char_count] - '0';
            property_count++;
         }
      }

      line_count++;
      property_count = 0;
   }

   
   for(int i = 0; i < 4; i++){
      for(int j = 0; j < 5; j++){
         printf(""%d "", properties[i][j]);
      }
      printf(""\n"");
   }

   
   int properties_data[5];
   int score = 1, max_score = 0;
   for(int a = 0; a <= 100; a++){
      for(int b = 0; b <= 100; b++){
         for(int c = 0; c <= 100; c++){
            int d = 100 - a - b - c;

            for(int i = 0; i < 5; i++){
               properties_data[i] = a * properties[0][i] + b * properties[1][i] + c * properties[2][i] + d * properties[3][i];
               properties_data[i] = MAX(properties_data[i], 0);

               if(i < 4){ 
                  score = score * properties_data[i];
               }
            }

            if((properties_data[4] <= 500) && (score > max_score)){
               max_score = score;
            }
            score = 1;
         }
      }
   }

   printf(""max score = %d\n"", max_score);
   return 0;
}
",20,633,649
"#define NR_ELEMENTS 20
#define LITERS_TO_STORE 150

int main(void){
    int input[NR_ELEMENTS] = {50, 44, 11, 49, 42, 46, 18, 32, 26, 40, 21, 7, 18, 43, 10, 47, 36, 24, 22, 40};
    int multiplier[NR_ELEMENTS] = {0};
    int nr_combinations = 0, result = 0;

    
    
    
    
    for(int i = 0; i < pow(2, NR_ELEMENTS); i++){
        for(int j = 0; j < NR_ELEMENTS; j++){
            multiplier[NR_ELEMENTS - 1 - j] = (i >> (NR_ELEMENTS - 1 -j)) & 1;
        }

        
        for(int k = 0; k < NR_ELEMENTS; k++){
            result += input[k] * multiplier[k];
        }

        
        if(result == LITERS_TO_STORE){
            nr_combinations++;
        }

        result = 0;
    }

    printf(""answer=%d\n"", nr_combinations);

    return EXIT_SUCCESS;
}",20,634,367
"char string[4];
bool in_brackets = false;
int ip_counter = 0;

int main(){
   FILE * fp_data;
   fp_data = fopen(""data"", ""r"");

   char * data_read = NULL;
   size_t len = 0;
   ssize_t read;

   while((read = getline(&data_read, &len, fp_data)) != -1){
      char ABA[300] = """";
      char BAB[300] = """";

      for(int current_char = 0; current_char < (strlen(data_read) - 4); current_char++){
         for(int i = 0; i < 3; i++){
            string[i] = data_read[current_char + i];
         }
   

         if(strstr(string, ""["") != NULL){
            in_brackets = true;
         }
         else if(strstr(string, ""]"") != NULL){
            in_brackets = false;
         }
         else{
            if((string[0] == string[2]) && (string[0] != string[1])){
               if(in_brackets) strcat(BAB, string);
               else strcat(ABA, string);
            }
         }
      }

      char ABA_temp[4]; char BAB_temp[4];
      int ABA_loop = strlen(ABA) / 3;
      bool not_added = false;

      while(ABA_loop-- > 0){
         memcpy(ABA_temp, ABA + (ABA_loop * 3), 3); ABA_temp[3] = '\0';

         int BAB_loop = strlen(BAB) / 3;
         while(BAB_loop-- > 0){
            memcpy(BAB_temp, BAB + (BAB_loop * 3), 3); BAB_temp[3] = '\0';

            if((ABA_temp[0] == BAB_temp[1]) && (ABA_temp[1] == BAB_temp[0])){
               if(!not_added){
                  ip_counter++;
                  not_added = true;
               }
            }
         }
      }
      in_brackets = false;
   }

   printf(""answer=%d\n"", ip_counter);
   return 0;
}
",20,635,598
"#define LEFTROTATE(x, c) (((x) << (c)) | ((x) >> (32 - (c))))


uint32_t h0, h1, h2, h3;


void md5(char *initial_msg, size_t initial_len) {

    
    uint8_t *msg = NULL;

    

    

    uint32_t r[] = {7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
                    5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,
                    4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
                    6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21};

    
    uint32_t k[] = {
        0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
        0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
        0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
        0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
        0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
        0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
        0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
        0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
        0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
        0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
        0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
        0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
        0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
        0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
        0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
        0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391};

    h0 = 0x67452301;
    h1 = 0xefcdab89;
    h2 = 0x98badcfe;
    h3 = 0x10325476;

    
    
    

    
    
    

    int new_len;
    for(new_len = initial_len*8 + 1; new_len%512!=448; new_len++);
    new_len /= 8;

    msg = calloc(new_len + 64, 1); 
                                   
    memcpy(msg, initial_msg, initial_len);
    msg[initial_len] = 128; 

    uint32_t bits_len = 8*initial_len; 
    memcpy(msg + new_len, &bits_len, 4);           

    
    
    int offset;
    for(offset=0; offset<new_len; offset += (512/8)) {

        
        uint32_t *w = (uint32_t *) (msg + offset);

#ifdef DEBUG
/        printf(""offset: %d %x\n"", offset, offset);

        int j;
        for(j =0; j < 64; j++) printf(""%x "", ((uint8_t *) w)[j]);
        puts("""");
#endif

        
        uint32_t a = h0;
        uint32_t b = h1;
        uint32_t c = h2;
        uint32_t d = h3;

        
        uint32_t i;
        for(i = 0; i<64; i++) {

#ifdef ROUNDS
            uint8_t *p;
            printf(""%i: "", i);
            p=(uint8_t *)&a;
            printf(""%2.2x%2.2x%2.2x%2.2x "", p[0], p[1], p[2], p[3], a);

            p=(uint8_t *)&b;
            printf(""%2.2x%2.2x%2.2x%2.2x "", p[0], p[1], p[2], p[3], b);

            p=(uint8_t *)&c;
            printf(""%2.2x%2.2x%2.2x%2.2x "", p[0], p[1], p[2], p[3], c);

            p=(uint8_t *)&d;
            printf(""%2.2x%2.2x%2.2x%2.2x"", p[0], p[1], p[2], p[3], d);
            puts("""");
#endif


            uint32_t f, g;

             if (i < 16) {
                f = (b & c) | ((~b) & d);
                g = i;
            } else if (i < 32) {
                f = (d & b) | ((~d) & c);
                g = (5*i + 1) % 16;
            } else if (i < 48) {
                f = b ^ c ^ d;
                g = (3*i + 5) % 16;
            } else {
                f = c ^ (b | (~d));
                g = (7*i) % 16;
            }

#ifdef ROUNDS
            printf(""f=%x g=%d w[g]=%x\n"", f, g, w[g]);
#endif
            uint32_t temp = d;
            d = c;
            c = b;

            b = b + LEFTROTATE((a + f + k[i] + w[g]), r[i]);
            a = temp;



        }

        

        h0 += a;
        h1 += b;
        h2 += c;
        h3 += d;

    }

    
    free(msg);

}





































",20,636,2104
"#define MAX_NR 10000
#define NR_OF_BANKS 16
int input[NR_OF_BANKS] = {4, 1, 15, 12, 0, 9, 9, 5, 5, 8, 7, 3, 14, 5, 12, 3};

int answers[MAX_NR][NR_OF_BANKS];

int main(void){
    int redistr_index, highest_nr_of_blocks = 0;

    
    for(int bank_index = 0; bank_index < NR_OF_BANKS; bank_index++){
        answers[0][bank_index] = input[bank_index];
    }

    
    for(int step = 1; step < MAX_NR; step++){
        
        for(int bank_index = 0; bank_index < NR_OF_BANKS; bank_index++){
            if(input[bank_index] > highest_nr_of_blocks){
                redistr_index = bank_index;
                highest_nr_of_blocks = input[bank_index];
            }
        }

        
        input[redistr_index] = 0;

        
        for(int i = 0; i < highest_nr_of_blocks; i++){
            redistr_index < NR_OF_BANKS - 1 ? (redistr_index++) : (redistr_index = 0);
            input[redistr_index]++;
        }
        highest_nr_of_blocks = 0;

        
        for(int bank_index = 0; bank_index < NR_OF_BANKS; bank_index++){
            answers[step][bank_index] = input[bank_index];
        }
    }

    
    int duplicate_found = 0;
    int occurence_found = 0;
    int occurence_found_index = 0;
    int q = 0;

    while(occurence_found == 0 && q < MAX_NR){
        for(int j = q + 1; j < MAX_NR; j++){
            for(int k = 0; k < NR_OF_BANKS; k++){
                if(answers[q][k] != answers[j][k]){
                    duplicate_found = 1;
                    break;
                }
            }

            if(duplicate_found == 0){
                printf(""answer pt1=%d\n"", j);
                occurence_found = 1;
                occurence_found_index = j;
                break;
            }

            duplicate_found = 0;
        }

        q++;
    }

    for(int q = occurence_found_index + 1; q < MAX_NR; q++){
        for(int k = 0; k < NR_OF_BANKS; k++){
            if(answers[occurence_found_index][k] != answers[q][k]){
                duplicate_found = 1;
                break;
            }
        }

        if(duplicate_found == 0){
            printf(""answer pt2=%d\n"", q - occurence_found_index);
            exit(EXIT_SUCCESS);
        }
        duplicate_found = 0;
    }

    return EXIT_SUCCESS;
}
",20,637,833
"int data_array[8][26] = {0};
char output[8];

int main(){
   FILE * fp_data;
   fp_data = fopen(""data"", ""r"");

   char * data_read = NULL;
   size_t len = 0;
   ssize_t read;

   while((read = getline(&data_read, &len, fp_data)) != -1){
      for(int i = 0; i < 8; i++){
         data_array[i][(int)(data_read[i] - 'a')]++;
      }
   }

   int max = 0;
   for(int i = 0; i < 8; i++){
      for(int j = 0; j < 26; j++){
         if(data_array[i][j] > max){
            output[i] = j + 'a';
            max = data_array[i][j];
         }

      }
      max = 0;
   }

   printf(""answer=%s\n"", output);
   return 0;
}
",20,638,272
"#define NR_DISCS 6

int input[NR_DISCS][3] = {
   { 5, 0,  2}, 
   {13, 0,  7},
   {17, 0, 10},
   { 3, 0,  2},
   {19, 0,  9},
   { 7, 0,  0}
};

bool not_zero = false;
int time = 1;

int main(){
   
   for(int i = 0; i < NR_DISCS; i++){
      for(int j = 0; j < i + 1; j++){
         if(input[i][0] - 1 > input[i][2]){
            input[i][2]++;
         }
         else{
            input[i][2] = 0;
         }
      }
   }

   
   while(1){
      for(int i = 0; i < NR_DISCS; i++){
         if(input[i][0] - 1 > input[i][2]){
            input[i][2]++;
            not_zero = true;
         }
         else{
            input[i][2] = 0;
         }
      }

      
      if(!not_zero){
         printf(""answer=%d\n"", time);
         break;
      }
      else{
         not_zero = false;
      }
      time++;
   }

   return EXIT_SUCCESS;
}
",20,639,373
"int input = 347991;

void check_end(int * i, int * col, int * row){
    if(*i == input){
        printf(""answer=%d (%d, %d)\n"", (abs(*col) + abs(*row)), *col, *row);
        exit(EXIT_SUCCESS);
    }
}

int main(void){
    int current_ring_multiplier = 1;
    int col = 1, row = 0;
    int i = 2;

    while(1){
        
        for(int j = 0; j < current_ring_multiplier; j++){
            row++; i++;
            check_end(&i, &col, &row);
        }

        
        for(int j = 0; j < current_ring_multiplier + 1; j++){
            col--; i++;
            check_end(&i, &col, &row);
        }

        
        for(int j = 0; j < current_ring_multiplier + 1; j++){
            row--; i++;
            check_end(&i, &col, &row);
        }

        
        for(int j = 0; j < current_ring_multiplier + 1; j++){
            col++; i++;
            check_end(&i, &col, &row);
        }

        
        current_ring_multiplier += 2;
        col++; i++;
        check_end(&i, &col, &row);
    }

    return EXIT_SUCCESS;
}",20,640,381
"int data[9][3] = {
   {22, 8, 165},
   {8, 17, 114},
   {18 , 6 , 103},
   {25 , 6 , 145},
   {11 , 12 , 125},
   {21 , 6 , 121},
   {18 , 3 , 50},
   {20 , 4 , 75},
   {7 , 20 , 119}
};

int temp[9][3] = {0};
int distances[9] = {0}, points[9] = {0};
int longest_distance, time_flown, time_rested;

#define TOTAL_TIME 2503

int main(){
   
   memcpy(temp, data, sizeof(data));

   for(int time = 0; time < TOTAL_TIME; time++){
      
      for(int reindeer = 0; reindeer < 9; reindeer++){
         if(temp[reindeer][1] > 0){
            distances[reindeer] += data[reindeer][0];
            temp[reindeer][1]--;
         }
         else if(temp[reindeer][1] == 0){
            temp[reindeer][2]--;
            if(temp[reindeer][2] == 0){
               temp[reindeer][1] = data[reindeer][1];
               temp[reindeer][2] = data[reindeer][2];
            }
         }
      }

      
      longest_distance = 0;
      for(int reindeer = 0; reindeer < 9; reindeer++){
         if(distances[reindeer] > longest_distance){
            longest_distance = distances[reindeer];
         }
      }
      for(int reindeer = 0; reindeer < 9; reindeer++){
         if(distances[reindeer] == longest_distance){
            points[reindeer]++;
         }
      }
   }

   
   int most_points = 0;
   for(int reindeer = 0; reindeer < 9; reindeer++){
      if(points[reindeer] > most_points){
         most_points = points[reindeer];
      }
   }

   printf(""winner=%d\n"", most_points);
   return 0;
}
",20,641,623
"#define SIZE 1001

int input = 347991;
int grid[SIZE][SIZE];


int get_value(int * row, int * col){
    int value = 0;

    
    for(int i = *row - 1; i <= *row + 1; i++){
        for(int j = *col - 1; j <= *col + 1; j++){
            value += grid[i][j];
        }
    }

    
    if(value > input){
        printf(""answer=%d\n"", value);
        exit(EXIT_SUCCESS);
    }

    return value;
}


int main(void){
    
    for(int i = 0; i < SIZE; i++){
        for(int j = 0; j < SIZE; j++){
            grid[i][j] = 0;
        }
    }

    int col = (SIZE - 1) / 2, row = (SIZE - 1) / 2;
    int current_ring_multiplier = 1;
    grid[row][col] = 1;

    while(1){
        
        col++;
        grid[row][col] = get_value(&row, &col);

        
        for(int j = 0; j < current_ring_multiplier; j++){
            row--;
            grid[row][col] = get_value(&row, &col);
        }

        
        for(int j = 0; j < current_ring_multiplier + 1; j++){
            col--;
            grid[row][col] = get_value(&row, &col);
        }

        
        for(int j = 0; j < current_ring_multiplier + 1; j++){
            row++;
            grid[row][col] = get_value(&row, &col);
        }

        
        for(int j = 0; j < current_ring_multiplier + 1; j++){
            col++;
            grid[row][col] = get_value(&row, &col);
        }

        
        current_ring_multiplier += 2;
    }

    return EXIT_SUCCESS;
}",20,642,546
"char line_nodash[100];
long char_counter = 0;
char c = 'a';
int line_counter = 0, sector_ID = 0, processed = 0;

int main() {
   FILE * fp_data;
   fp_data = fopen(""data"", ""r"");

   char * data_read = NULL;
   size_t size = 0;

   fseek(fp_data, 0, SEEK_END);
   size = ftell(fp_data);
   rewind(fp_data);
   data_read = malloc((size + 1) * sizeof(* data_read));

   fread(data_read, size, 1, fp_data);
   data_read[size] = '\0';


   while(1){
      c = data_read[char_counter];
      if(c == '\0'){
         printf(""WORD NOT FOUND (processed=%d)\n"", processed);
         return 0;
      }

      while(c != '\n'){
         if(c == '['){
            char_counter++; size = 0;
         }

         else{
            if(isalpha(c)){ 
               line_nodash[line_counter] = c;
               line_counter++;
            }
            if(isdigit(c)){
               sector_ID = sector_ID * 10 + (c - '0');
            }
            char_counter++;
         }

         c = data_read[char_counter];
      }

      line_nodash[line_counter] = '\0';
      line_counter = 0;
      char_counter++;

      #ifdef DEBUG
         printf(""line=%s\tbrackets=%s\tID=%d\n"", line_nodash, line_brackets, sector_ID);
      #endif

      int key = sector_ID;

      if(key > 26){
         key %= 26;
      }
      for(int j = 0; j < strlen(line_nodash); j++) {
         int char_val = line_nodash[j] - 'a';

         if( (char_val + key) > 25){
            int keytemp = key - (26 - char_val);
            line_nodash[j] = keytemp + 'a';
         }
         else {
            line_nodash[j] += key;
         }

      }

      printf(""output=%s\n"", line_nodash);
      if(strstr(line_nodash, ""north"") != NULL){
         printf(""ID=%d (processed=%d)\n"", sector_ID, processed);
         return 0;
      }

      sector_ID = 0;
      processed++;
   }

   return 0;
}
",20,643,705
"#define NR_DISCS 7

int input[NR_DISCS][3] = {
   { 5, 0,  2}, 
   {13, 0,  7},
   {17, 0, 10},
   { 3, 0,  2},
   {19, 0,  9},
   { 7, 0,  0},
   {11, 0,  0}
};

bool not_zero = false;
int time = 1;

int main(){
   
   for(int i = 0; i < NR_DISCS; i++){
      for(int j = 0; j < i + 1; j++){
         if(input[i][0] - 1 > input[i][2]){
            input[i][2]++;
         }
         else{
            input[i][2] = 0;
         }
      }
   }

   
   while(1){
      for(int i = 0; i < NR_DISCS; i++){
         if(input[i][0] - 1 > input[i][2]){
            input[i][2]++;
            not_zero = true;
         }
         else{
            input[i][2] = 0;
         }
      }

      
      if(!not_zero){
         printf(""answer=%d\n"", time);
         break;
      }
      else{
         not_zero = false;
      }
      time++;
   }

   return EXIT_SUCCESS;
}
",20,644,385
"int data[9][3] = {
   {22, 8, 165},
   {8, 17, 114},
   {18 , 6 , 103},
   {25 , 6 , 145},
   {11 , 12 , 125},
   {21 , 6 , 121},
   {18 , 3 , 50},
   {20 , 4 , 75},
   {7 , 20 , 119}
};

int distances[9] = {0};

#define TOTAL_TIME 2503

int distance, time_flown, time_rested;

int main(){
   for(int reindeer = 0; reindeer < 9; reindeer++){
      distance = 0;
      time_flown = data[reindeer][1];
      time_rested = 0;

      for(int time = 0; time < TOTAL_TIME; time++){
         if(time_flown > 0){
            distance += data[reindeer][0];
            time_flown--;
         }

         else if(time_flown == 0){
            time_rested++;
            if(time_rested == data[reindeer][2]){
               time_flown = data[reindeer][1];
               time_rested = 0;
            }
         }
      }
      distances[reindeer] = distance;
   }

   distance = 0;
   for(int reindeer = 0; reindeer < 9; reindeer++){
      if(distances[reindeer] > distance){
         distance = distances[reindeer];
      }
   }

   printf(""winner=%d\n"", distance);
   return 0;
}
",20,645,463
"char input[1000000] = ""(172x1)(3x7)XPJ(70x4)(40x7)WKQANMDILIQOOWQZDNGORPHFNHBKKKVQEJNUVNAQ(3x2)VFV(10x1)XUNNCAFYMV(9x13)OUIKISEPR(66x13)(10x6)JHDDURBDQC(3x11)SNT(2x11)EW(16x6)WMJFKTNQEACIZXLH(5x12)KPVAD(13x8)(8x2)ELNIDSSO(11x7)RFITQIJYVQB(6x5)HTVSFUVZ(89x12)(44x5)(7x1)VHEWGTT(5x11)GLDZO(14x13)DZVEJXGSGUDJKV(24x14)(18x3)AWXPFDVHVRRUAIELQO(2x13)UW(120x7)(62x7)(21x10)JFUYPPCABHPYTIJUUIEVK(5x5)UNAMQ(17x14)TFQKSOALOJYMSMLMK(17x2)NBDXRSHFDREHZPWMM(23x5)(1x11)O(10x6)QVOCIXBIQW(5x10)FOLCQ(6635x5)(3576x2)(456x13)(449x3)(1x2)M(1x11)I(215x14)(28x2)(1x14)R(9x7)OSMSWTRTV(2x3)RP(87x2)(14x9)QACULEYKFWPHFQ(41x15)LTBJBTBTFQLLEAWJTICLZBHGAYERVARMDLCBZXYPY(4x6)CEOP(4x13)JQJI(62x5)(15x6)YQPFVDNREIYOUKL(15x15)PUSBXTHCMLGOCNT(8x4)YAUHTKIM(1x1)E(14x2)(9x1)YHUAWBSED(37x12)(14x9)(8x11)SVYXKPGZ(10x13)WTQVTWIWGP(162x9)(68x1)(1x4)I(21x14)WTBNFSPQKDFYITBOFYYQN(3x8)UOY(13x14)KCDKDKYFQNNPX(1x6)K(20x9)PMGWXQWRLRWRETULVFPW(1x3)T(20x13)(7x7)YYHNWZC(2x10)HH(22x10)XDUOOOIDYYXQKQDBLGCPSR(1297x7)(359x13)(62x9)(7x15)LRERGOG(25x15)KYQSSJBREHLNZXSLSYGIIADSC(10x15)WMFZAHRNRU(283x14)(68x12)(16x10)QGQDCKCPTECIPTOW(19x6)WMPAPTDDUABBOLYMMBR(14x1)XRZVQKCBBBMCNI(29x5)HSGAQWQRLOILWCRJOCRDFZSOTPLBH(82x1)(12x1)RENHWOTHWXPZ(39x10)BIKLBTNHOLVUWVGTPRPXXROUGEJRHRADHASJDMJ(4x13)VRRP(3x1)BFC(79x9)(39x4)OINGYXONKTSXJBCNNYZMWSYGIUMFATXEUDZQZVL(9x13)OIMKIRFAT(5x1)MIUXM(3x13)EPG(496x13)(37x4)(31x9)(2x5)MF(18x2)MEVRXNGVBHEGENHJTL(11x13)TTCEWIFBGGJ(150x4)(68x13)(9x10)KJJRCHTUM(11x10)SVUDYGHJWKF(6x12)LNWLUN(8x11)LUVPHPZC(4x8)VFUZ(32x9)(2x3)RH(5x5)OOAGL(1x15)W(2x11)WM(3x4)GFG(22x13)(8x6)ZVCSHQXP(4x8)KOXS(193x3)(25x7)PXQFECGPYZOYUWTMOTBFZGGAO(28x12)(7x4)XHUHXEN(10x4)DTXYSILNLW(1x2)Q(101x13)(16x11)MZVPYIEPSLDSIEAF(27x11)NFACRSGETEPHFJQKPTXUQNNSPWT(6x13)UADYIT(2x8)LB(19x7)QYBDEBFMFAWOTYACZQM(6x13)YEABPA(72x6)(58x13)(3x15)UOO(43x6)GRXJNNQQXQVANDHYVVQTTWIKVLPHBJMCSEOPBELMGHG(1x10)G(178x10)(12x1)(6x15)JWYUKS(93x13)(5x11)CQCXM(56x7)(9x5)FIARQLQTK(11x3)NSXGBEOBVXI(9x15)QIBUNRTPC(5x8)GBIYV(13x10)(2x6)RC(1x5)T(33x14)(3x4)END(19x6)MYZTTHSNYAYANBPGVHZ(2x14)YD(6x12)(1x5)N(3x13)TFG(224x8)(11x15)XNMAIBBNTMC(199x8)(2x10)VG(23x11)(5x11)KOKXL(7x9)MIMRNXM(121x10)(10x9)OGYRDPVNEI(27x5)XUBNCPGOKJIXZNAHHLLDRUUTPRM(25x2)FVEEUXQTUBDUDSMIRLBFQYULY(13x5)JTJASJBCCKFHV(16x6)TVTTDIFACKNORYBR(4x2)LIFO(17x2)RZGYMXWONVKWJMSVW(833x6)(586x12)(230x10)(2x13)EL(41x15)(34x11)KPHSFJQJWTINMWYVNSVVZBABFYEBZCLNMQ(17x14)CRLPIZUEIBCKNKRJJ(62x15)(9x4)XTGHEGPMK(11x12)NCNNMDWDNMI(8x2)PKWGUNYT(10x15)DVAFJQIPSK(74x10)(5x15)ZLKKA(17x11)GIERLJRIDYLPWZCKG(33x2)OASXACZZRSCLVDVNLNGQHLRLMZCTMBCYP(153x7)(2x14)UX(49x8)(11x14)GEHZYBKESFQ(2x6)TE(6x3)THQOAO(8x6)FSPDZODL(42x11)(2x12)XO(10x7)IZTTYUPKBT(11x13)PVRXUXHBKQI(35x6)(5x5)UDRJC(1x9)B(13x9)YHHERZVEFSCFX(78x11)(36x3)(1x6)X(23x14)DHLGIIMPJGKDUOPFEBPKJZB(7x12)TMWJAJD(16x12)YVALDPNTHINYQQIC(2x9)OY(90x5)(62x10)(9x6)RUUFLMWQS(28x6)TAZAAAIDBGZMYXMNGHVTBRHWFHXV(8x13)JIRKEMEB(15x5)ORKLKISZMYECJBE(178x12)(59x5)(5x9)QLOCV(6x5)XETXIX(11x15)USNLPYJLBOW(13x15)ZYMFNBNVKKQFT(11x3)PISAKCRXTWT(90x7)(52x2)(1x3)F(21x6)QFIQOUEYORICJDZVHMIOW(13x6)ONYWAVOHAIQXE(9x5)TKBIAQVJC(7x5)SUEYTHE(1x4)H(46x13)(33x3)(26x15)(1x3)Q(14x3)OHRVGRUAQFTYYS(2x6)BS(960x3)(544x15)(160x14)(15x2)(1x11)D(3x9)PXR(52x4)(9x13)ZVIVIWOIO(1x5)D(1x12)Y(8x8)CKZGFGQO(6x9)DAMZNP(75x8)(13x1)VDPXRVCMGTZIY(3x13)WMF(10x12)KDJVCJQVEC(24x3)GEKGZEIIDDDJRSZBNAIDNASO(3x15)VUI(74x5)(46x8)(6x2)GSPMZV(4x2)XOOW(9x15)COLWEPZNQ(5x13)UGBDW(15x10)TTWVRPQTREJDSJS(137x14)(65x10)(8x13)OMBDNQBZ(44x13)RVXFBIJOFAQJCLTKYBXVWALEONUACICLGJIWATGHHCZK(22x14)ZSGSVEEFHRWHXBLGCDJKZV(30x2)(2x12)GG(9x12)HJQCPKGNY(1x14)H(134x15)(5x4)YGCHW(5x10)EROTH(26x10)(7x1)OXPTTDP(8x10)OJJSDGCL(74x8)BDTYNXCCPDQCMYZJTAJOYCGMWJLOMLEQYBCYAZOLTCYNDAPXMXCHVSKJCYXZWBKGVELGTLNCEB(54x14)(14x13)(2x9)SM(1x10)U(27x3)XFJSNXIJPTSFDKVNGBDNRLQYJKQ(16x11)(10x9)BAPIHODLEG(317x8)(112x11)(30x4)(6x15)UTROFQ(11x11)UYHDNMPLNBH(28x5)ZMZKTXRTUNMVSQTUGNYDWUOFAFBA(2x4)OT(21x15)(9x3)VRSRVOEDX(1x10)W(1x12)H(86x12)(1x6)Y(25x9)ZYIPXGLABDQQRIQOWYNSVRDDS(35x5)NJIVDKLQTESWZNBIFFPADGWBQGVWPNOZKOB(3x8)JZK(98x8)(45x10)(6x5)LYJQMR(10x7)EFMGJRIYHN(1x12)W(5x11)CXUHP(40x1)(33x14)BIXNELLRAWDEQWDLFXASPCFKGYXNPZRLP(102x3)(35x15)(29x2)(1x1)P(8x2)OGCHVTFM(5x2)CVQRK(54x3)(48x4)(10x3)(5x6)IUXTW(26x7)(7x3)MCAIFSI(9x6)THFFYJGAO(1522x10)(25x12)(18x13)(12x1)(7x4)HVDYPIO(1159x6)(211x8)(154x11)(21x6)VCPDOYQRGXIJVQGRJTVWP(12x10)CEOZLAMGANTR(16x14)HRTTJOTOJYRMGUDK(79x5)(4x11)JHCB(4x15)FHRU(9x12)TVDNDJPQW(2x5)WH(30x14)LUFKTGXZTAORPRJMZESFFDVVWPVYTB(42x14)(35x14)(29x2)SAGPXWQEGTZAIADCQFBLWRLZIQGCN(135x7)(15x14)UQJYCTIFFWSUWWM(65x2)(9x9)(3x12)JUN(18x5)(12x8)RDYSFFHOCMTA(2x7)QY(14x3)(9x7)FERWVDDHQ(36x2)(11x7)ILSHNBRIBMC(13x8)SRXBXAPPTJPLF(101x14)(2x10)VE(86x10)(29x8)(23x8)KAMCCHDVKOOJCGDQJPZZMPJ(32x9)UEYJFLAOACKYLFDJWQUXGIZYWMHDKYLK(8x6)(3x3)LKI(682x13)(208x6)(76x14)(8x10)AYLZDXBI(3x9)BRC(25x10)IEATCRHBHGIKZBQTRCTXULAMN(15x12)ZHRTNMVERVGZZCG(32x3)(4x14)ERHO(7x7)NNNSCSF(5x4)TTUFM(4x7)XYWL(72x4)(3x7)SDF(29x13)OQXOWQELFOXUFEEBUPLNHMAOGLLPV(14x5)SZJGEXPPXSUXCB(3x8)KND(95x1)(28x5)(7x3)LVLVSVN(10x8)TGDBTKXVLI(10x11)WRFPBLNECA(29x1)XFGOLCPIYTKNJTXBAEATURQVVXGFP(3x14)YBZ(205x1)(16x14)(10x8)IFQMAAEMOP(32x9)(16x14)VBFTUPKSNIUAEBHA(3x14)EMW(23x11)(2x7)XS(3x7)QWS(2x12)TE(107x2)(21x12)XKLOCAHJZFYLQZMQDZUJP(28x15)VFRNAEWVNJVUZDURVOCUEISKGWWN(20x6)NXCCPUPQKGXTOWWRANDP(12x9)WRJVTTEYFJBE(146x12)(1x12)M(46x3)(12x15)ELAIIEJMLHRV(1x8)I(1x14)K(2x9)RN(1x14)E(81x6)(14x4)SHLOZXCBQTBEZF(40x2)YMEOXRNZXDIEEFLRQQDPWXILUOJQHDSUEKNXNQSP(3x2)TGQ(1x10)X(315x14)(307x10)(3x11)ZDV(260x4)(97x8)(20x11)YRELCFEJXQZADZSOJION(14x14)BGCJIBHVHEGFOD(3x14)PVA(33x13)KHUWKRRNHTHJCROVFAOIWGGOTIPKDMPRC(36x5)(2x8)HZ(22x14)YZSUXCHXDEPXIGCWUOKUXZ(62x10)(15x7)JZUDNJCWXTQAMOM(4x10)BJDT(24x14)ETEADJJYZZDODVKPPXTBTUPC(40x1)(5x9)UZDRJ(24x2)VPGSGVADLRBFODBZBMWBRJFC(24x14)(10x10)NJQVLSVHKJ(1x15)B(1402x12)(1381x11)(690x9)(163x6)(76x1)(16x11)TTKEOWZUHJMAOJVI(4x15)LGFT(3x6)MYP(17x7)CHKQJJMHHGHDXWBSO(7x7)UJLDJLX(11x12)LGBIGRGMTBV(21x6)RISOUTKGCNPQLLDWNLYEA(5x14)IZRZO(19x8)(13x7)ZYNNYQLEROHNK(23x9)(3x13)KRN(9x5)(4x5)OXVO(185x5)(52x6)(6x4)QOSUZS(18x6)GUQOGCRNSAKDCOCTSE(10x14)KGZBUGVIIH(40x10)(6x12)CMZQRR(1x5)Q(15x11)WEKZHYYCTPIPOZJ(58x8)(1x4)A(6x8)ABJIRX(11x15)EQFJHQOVGLY(6x3)YYQMKZ(7x7)LKJYEWV(5x4)BPTKB(1x4)J(284x5)(63x10)(1x8)W(11x13)MPTRNQPSBXM(15x3)VHDTUWNDEGLNCSQ(2x1)CQ(6x2)OCFRSJ(63x9)(15x12)AEYDUUWROCUABMX(12x4)RPGECWZRBHLK(1x11)O(10x4)JCBDSFSXDE(13x11)(8x4)BEHBONOK(83x2)(4x6)ANAD(3x15)LOP(20x15)TJLFCNGAYSBMWACNIOME(14x14)OLVVHGNWUVNXMR(10x12)DAHIOTLOCP(30x9)(2x12)TR(16x3)DYWYHJLMIYAHQIIE(3x8)SNV(112x15)(19x8)PBXORKYLISLHVCJVBJP(74x10)(2x8)FP(24x13)ZXILHYHYDGDNGHIPFHLMRLQS(2x11)WN(21x13)RDQDPNVEOLOSPLAHQHHMY(1x9)R(14x6)LIIRDEBBHSKXZT(372x10)(164x2)(40x7)RMPKUSRDBXNZLGDXZIAUAZNQBJEMSBUJOJNPHHHI(12x15)IAFPAWBOSBOS(76x6)(5x6)UYNUU(25x15)XPXFOEMDDICGRJONJBWMOZCIW(8x5)KJJIEDUG(15x2)IEUTKVCMTTXZNTC(11x9)IKWCZMUNCOP(61x12)(54x13)(13x12)NIOHBMYALHOUO(7x10)KFDUHJL(2x3)NM(9x9)OSVPKOFSM(5x5)VAMMP(9x3)EZLMGESLP(102x5)(26x5)(7x9)NHCIGIE(3x3)IVY(1x2)L(12x7)UXAUQLEXZGXN(46x6)(1x14)R(11x9)QTBPNKUFZOA(16x9)DLXKSEJJVMWIIHPB(157x8)(30x4)(13x15)TNSMJZJMNEUQM(4x12)HRAW(113x15)(17x4)(3x13)VQG(2x11)YK(4x9)GMIK(15x12)YGMZABAZZNHPRHP(23x4)(5x13)ZBQGH(7x3)SPNLPWT(24x1)HVEWGOENETTTKKBJHMBEFJSJ(6x14)WGBSYS(2694x1)(873x13)(591x15)(1x2)H(14x12)(9x8)(4x7)PHPZ(59x10)(10x7)EQJUHLQDSB(11x6)MHGNANYAWWK(3x8)FEN(11x12)RCPCNTVKIXQ(491x7)(78x14)(40x11)YVRYFJZMQREHNXZZPWXKNPHSUTVUGVEOPFQQBLOJ(25x1)(13x1)HQFQJIYOMZFGW(1x8)F(182x6)(86x14)(12x9)WODINQMTBDAX(6x7)JFCXXM(6x1)FKJPPD(40x2)IDAKJRAQIDKLPCCATMTFTOWNPLHKNJBTAVVHUWWN(53x8)(4x1)FXRX(9x1)DCBBRHJVU(2x2)RA(10x14)IWJGLMPMBS(1x5)H(14x2)WXKMITJBMZACIB(5x2)WLBVL(5x1)XNGOL(193x3)(6x8)ANFCUH(11x13)ZVGWPGYGIAR(72x4)(9x10)LUYDGWJLX(8x1)WUXTMRZR(2x3)FK(21x8)AGZIOWSLPHAKSUPECVOHV(4x12)FDXE(6x12)(1x8)M(68x7)(3x4)EOK(28x13)JXAMSHCQOBIUKUHUFYOOZJRMMNCW(19x4)YBUXDOFHTQVATUPANAF(1x15)H(110x13)(93x7)(87x2)(4x12)GMOE(50x11)(13x3)VHUHCBUNINBAH(9x14)ABWUPTZJB(10x1)ULUUYHAWHR(14x7)RSQMESIUXRZOVL(6x4)FBTNDA(5x7)ADGJH(139x5)(131x10)(123x14)(88x6)(1x11)A(17x13)XCWUXQVXMMRLURVHL(9x12)NBLNMYWQH(23x14)IOMVENQGFGYSOQNKKMXALXR(7x6)OWEXJQO(23x1)BGMPXSGMVQUXQJNAGUDPASW(168x14)(149x3)(17x1)(11x1)PPOPWWURQYN(119x7)(63x1)(4x14)CIWA(9x5)(4x3)YHDL(32x10)THARHNYWOIICGXLNEHOTTIEJXOLESVFO(44x2)(30x2)FMAVRVLKELMJLGHIPGCRCHJFVTBSUP(3x3)SIW(7x8)BIFVNRC(706x15)(699x8)(6x6)(1x1)B(284x11)(154x1)(26x12)BCUDXLZNEUYZIEKRPJNGEFKMNE(49x5)JNLLBDIRMRINXOUMGKJXTVCKAMZCEPVXFRIUUQXUQAHXXWERV(41x4)(5x15)JUNET(9x14)LAEKWBIYU(1x1)O(4x4)JFAB(13x4)KARCNJKHMFJFW(94x7)(64x7)(7x14)VRRWPHM(16x2)RYATIQNKHUXCZEGS(8x13)WZSZNRIH(3x7)TBE(2x4)DA(10x10)TJBORFEVFS(2x4)VE(8x15)YTADJOMR(4x2)XQAO(389x2)(171x3)(52x4)(1x6)C(14x1)QUCOESZSLGRLIJ(7x13)UVHYAWH(1x8)A(1x14)R(16x2)HOCCGBBDBBAJPVFU(52x8)(2x3)IV(20x3)BADNVTFDYEOJOSTOURIR(6x12)UAKYYR(1x12)D(3x8)RDJ(18x15)GDBLXRBQGDVOGYNIDB(7x9)RVLXMQP(146x2)(45x15)(3x3)NNY(10x14)EUROHLVNXH(4x12)JYRH(5x3)GJZII(2x1)IN(6x6)GPYYHE(70x5)(22x3)JSUZJGHKJQSJZHNHSBYXRX(11x4)CKNLLPRJDJB(11x9)EYWLHDJWYMZ(3x4)EOQ(39x11)(19x11)(12x15)ZSNCSSNGFNWK(7x11)QKRQMES(915x15)(657x4)(121x15)(21x4)(6x9)PBLEYF(5x3)JYILW(88x7)(48x6)(18x11)LHFNPRFKADOZQRHQVE(5x9)JSXCT(8x2)QOQRTIAA(7x3)NKKNWLS(16x4)URODMQWUOAUZDVTW(203x11)(196x3)(72x2)(1x12)L(2x3)AO(8x3)XROVOMDL(9x8)YZAEPPLFP(25x5)TJCBFMVSXVPIIOUHRJCUZAFPK(35x9)(22x5)BSQZOCOFMKGAVXARGGFCYV(2x1)BR(46x10)(3x1)MNZ(13x4)EBBUVWXRIWLMZ(13x8)EXOJUNPCWPYQE(9x14)(3x15)NYG(4x3)XNAD(6x3)OAGYDW(299x3)(130x5)(5x5)ZIVTZ(4x8)WRBW(73x12)(5x13)TCVNI(25x12)TLVHEMSRDZWQRIYKHDGLZVLEQ(24x3)PIOJWVRBAOPTXHUJAGHCRGNK(24x14)VCVZEHKJWAPXJDMALSUKRZAW(30x4)DMROHLLFJEFQZPAEVOYCSESESVCDPT(107x1)(19x11)XYGUSLMMCMUYFOZZCSG(9x13)(4x5)TMYS(2x1)BK(1x3)L(46x13)(40x7)JGIWCASPBLNAZSSBXMFLCZNHCLRYKJTSKTRIYXZD(7x7)SIMRJYC(243x12)(219x7)(4x8)XKYN(202x11)(26x11)(4x11)JIBP(3x12)TUQ(1x12)U(78x11)(10x12)PYKJEJKLOP(7x12)MGGQRIM(6x3)WDBTTC(10x6)EFUZOEPGTG(15x8)ULWOSKACKQHHDTH(2x5)OX(24x4)(1x13)Q(3x10)PLC(2x11)AZ(40x14)(4x3)IOIG(7x15)QQTGOCG(4x1)TTYK(4x1)KMKT(11x2)DUFCFLWJKDO(4988x11)(514x13)(184x10)(176x15)(168x14)(49x8)(11x13)NGQSRMSYVIT(5x13)LIGXA(13x13)QLVGLJOXJZEMA(14x3)BHSJULNXUJNMLB(21x13)QWVNZXHEHTXEDXQKZCKZH(59x3)(23x14)IZNXJWCWIXNWKNQDTNQUAEO(23x6)GDBWPQKJXRWQSZJUZRGBNNF(14x4)(9x7)RQPHPKUPM(7x9)QVUICMY(269x12)(34x4)(11x1)IODKMJLLLKQ(10x15)KDIWUXJCVN(221x12)(47x9)(12x12)RCNHOSXDVYYI(21x11)(3x4)IJG(8x4)XBPLQPKV(150x6)(75x15)(2x6)DH(23x10)WKXGJRDSEZTLPKCMMUZZMXF(7x7)WURAPMO(3x4)RIC(12x6)MFVQJUULXSZX(9x7)LSYQTUAPN(47x14)(3x10)YZI(7x6)YHUFAXO(1x4)M(14x4)LANLTXIEINNYBW(6x3)(1x1)W(8x9)FNIRZGYT(3676x12)(585x11)(242x2)(19x8)(12x15)OWCUIMOZCPJU(210x4)(107x13)(10x14)BTVYEADZIL(39x12)UMDJKKZWWGKFLEFWKVTRGZMWUTEWWFYSVMIVJQF(3x10)NEL(28x11)MLIMLBMEATHPEVTQRQTHBUOCFZMW(65x2)(23x12)SGEKZUXQNIGZURVKPNAISOY(21x2)UGJLXKWJVUFGJURKHTETM(2x11)XQ(17x13)CTOVPHTPJVNUSQZLY(329x9)(27x4)(20x15)(6x7)SWYPVM(3x10)ICH(105x3)(7x2)(2x1)QZ(11x11)(5x14)XUSZN(69x8)(7x12)VCQYFSA(24x7)EFVFKBFLRAJTGXEQGICZSOSE(10x7)CNXAKLLDBZ(4x13)XFXW(20x5)(13x15)SQZPVKWYCGMLX(96x12)(9x10)QNJNUKACF(14x3)WBKWFXIFFTAGKJ(2x11)TM(47x7)(9x4)WKFDSSPUO(12x2)TNCXEWMSFUPL(3x7)BCH(1x10)W(49x5)(23x10)(17x8)LMJYTUJGSCJDSMNZI(1x14)A(7x3)DYODODD(735x4)(2x13)CT(147x12)(140x1)(10x14)(5x6)KBFDG(74x11)(3x7)ASG(6x1)BAMUUR(11x1)HYWHOBKJIPH(22x14)ROJWCVIRBUVOXMHEBMHRBD(4x6)IHCB(36x9)(2x12)KI(1x1)I(16x4)TYYWOESVEYUUSCSQ(272x12)(6x13)YBZCAF(2x12)XV(12x10)(7x5)EOKMUXF(91x8)(4x3)CYOY(76x4)(2x6)QT(29x5)NMTVCDRMTLDIVOECJLYHZUBPYGOFD(4x5)IAJR(11x10)YPFPNDBONFO(2x3)WI(129x6)(77x2)(10x14)PAQKAHBQAX(2x4)YV(19x1)KXUKEJINNRYFXQJKRSM(10x2)YJAIIRZOWD(7x4)MDVMTGB(19x6)(4x9)MMQC(5x6)VZZVQ(2x7)XE(2x3)EQ(2x1)MA(202x9)(183x5)(13x5)YGYLMWENWKOEP(8x15)MIAMCHRA(67x15)(2x14)RP(10x5)NVJOFHUZFU(19x13)ELUOKNLHOOIAYZOCIMD(10x13)DQTLOMUCCQ(70x4)(11x1)KZALNOFLDHG(15x13)WLWZWHTUHWOZLES(9x10)FMITUKLQU(3x14)WCL(2x6)CK(6x10)(1x2)W(76x10)(2x8)ML(62x11)(48x11)(4x12)IRUH(4x3)DBQU(22x15)DYDBCSWMYSBLRNSNGRWCEU(1x15)Z(745x3)(23x1)(6x8)OKKJKF(7x1)(2x1)UU(709x5)(217x7)(116x3)(41x11)OAOMKCXJMJKKPSYWLNBFUDEVLICRKCGHRTGCIUAXZ(17x12)SKMYSNPPLDSOKIKXI(10x2)AYWGQTPNPX(12x14)GQFNEYXBYAAN(4x2)DWAS(12x13)MGXEWSKMSNTH(69x8)(7x6)LEFUMOK(19x4)UREDJOQURHFQCDSOZKZ(8x13)QPNYHWBW(12x2)JVUTOZHSWMXS(143x9)(79x6)(5x6)ZLLEG(4x13)ZAKG(2x6)QM(32x5)ADNXICFDFEOECVZHIVQKALYWLJGUSOSI(9x9)AWIAWSRJZ(52x5)(5x6)QSJGP(10x1)KDADHYYLCR(4x9)BQEP(1x1)Z(6x9)OMYNHU(103x7)(86x5)(2x13)AB(45x6)PQHXQFEMSNVRLACWAKQOYTZVLYPGBLAVMANXZHEMATRCF(14x4)YEVRVCORQWAJYG(2x3)AC(6x4)(1x4)W(135x15)(4x9)NULK(79x7)(7x10)RVBBWHN(3x12)MEL(33x9)FQIMGFZZTZBDCAYWARBLFRRQTJROKZXOJ(6x8)PWSZAR(2x5)ZR(13x8)RGRLYMPEYXDYF(15x15)EKZSLEASGQCSSAQ(76x5)(3x1)GDV(14x4)BYSPLEVMSPGXHS(4x2)LIDY(33x9)(27x4)ZWOLHCSTTPJZTODWETGHTNMAPAF(1215x14)(142x4)(14x1)ODRTZPGCANTMRQ(11x12)FFJIYPJJDPY(18x13)(12x7)PHABYHRKCIBS(72x12)TLUCYATALAFMLBSLTDHFNEGCVYKQFKPHVAMBSCYPSYMMGFGEPKMZRVXAZLGQQGCAQVIDKQCZ(119x10)(100x8)(6x6)ZKHOPF(37x8)JZJYXJTGQWXJKOWCEGRYFWORONDPKWDHGQFWR(9x10)JZTDQPVOV(7x11)MNMFBYO(12x9)(6x12)TEOCNK(6x11)(1x9)U(413x10)(1x12)W(357x6)(81x1)(20x13)AXMPRMJPLLNQTKNAKAKL(15x11)NCYQCFJRFVEBMBE(10x15)IDMWCCMJMT(9x15)KDITVSFLX(8x13)LWDZHEIH(85x4)(9x8)DNTHBQVEK(3x12)RCQ(17x5)IONTLMAHANUFDOIZZ(3x1)IKC(24x10)YQLVKHSGEHGXGFYSVJGHUHUA(109x4)(4x12)XZEO(12x5)HEZUPCXXEENI(12x12)OMJTLBITZWOB(13x13)YWOEGEYKAOZJS(36x8)VUZJQCVRHXSSCZNTEFKDZLVHDVCJSREVEVCB(43x6)(2x4)RT(4x12)CIZV(20x6)HHICUGNPVNOEZZGDLIZY(36x6)WRYFVILIDECKLNDCCWDEBAAPNRQVLQTWUQRC(260x7)(81x9)(5x1)XTIWO(7x2)(2x7)HZ(47x3)(6x5)EJMXOK(10x14)CVISHTXMOH(6x12)QCQAWT(1x12)V(1x3)Y(165x10)(21x10)PSYSIOEUPVJSLHBRVCOJD(39x12)(12x14)UBTGKOQEIYFM(5x4)CLHJC(5x4)FWNYB(9x13)ZHUPCPRPR(39x13)(10x15)YKYHEZRRDL(3x9)TRX(8x15)STWMOZDH(23x10)(2x9)ZM(2x7)MV(3x13)OQK(243x11)(210x8)(42x14)(17x12)JIOXSDZFXPPALZIKA(12x5)VJLEWBRVXMCD(23x2)VNXQYVPIRTMBGPKVZNTOFOG(61x6)(7x4)NSPFDMJ(9x14)TVHJEJSSJ(2x13)IJ(13x9)QTFHJIOJOQAOA(1x11)C(59x3)(6x11)MSQZOU(31x14)VLYOENWNIUSCUPMSOZEFABALZGGUXSZ(3x12)MIA(13x5)XZEMQZEXZTHJP(1x14)O(358x8)(162x14)(39x11)(13x5)(7x10)ZEJGPTO(1x12)V(8x7)PFNFRIMK(8x12)(2x13)LL(47x1)(41x8)(1x6)W(16x10)KZDYKHCTWZXEKCNJ(6x11)BKPJMJ(42x15)MMVAWYBRUXHRRXCVQBRTDORBFQQBOOHMVEKUQKJQTP(58x11)(28x5)NMWGTZUQBNENKBJWXUSTOSCMPLCZ(18x7)XIOSACAMZDWOJMBKQD(105x2)(72x12)(48x12)(5x10)XABVT(4x1)FENC(3x3)FPK(3x2)BMX(7x2)CTTSNTO(11x2)(5x14)XLVEE(2x1)PI(6x10)XMZISE(2x6)AK(6x1)ZPYKXO(774x3)(10x4)QTZHPYSXNC(720x15)(226x14)(40x9)(2x10)BT(17x14)(2x15)SO(4x2)ECYN(2x10)JM(7x4)XOBYLTV(120x3)(1x3)N(19x12)PEGBFGRTJFJSVIQZTNS(2x5)JD(41x13)(3x13)YTK(6x4)FUJASF(5x10)NHCVS(5x7)EBSJH(27x3)MMLCNRRAUAKKAGPBUHZQKMJVRLY(35x8)(12x5)EUFDLSCJNJIW(1x11)F(5x8)OICJN(178x3)(1x5)O(164x12)(69x5)(1x3)Y(13x7)NJGIFSDNRZGUN(20x2)CHUHUOZQHKOBNBNITRCT(3x13)XHS(4x4)HCZB(47x10)(13x13)HKZXATQZXPKJC(3x6)LFO(5x2)ZUTAK(4x8)JGZZ(13x1)BPKJSEMKXVWPD(10x8)CFBDPLWXUF(4x11)DYMH(283x14)(100x12)(9x14)LWMYUMEGI(79x7)(73x7)FBVHIBPTQYOPEWFQTFYYLGGOYUBRWFHKOXUWAZPIAVVVOWQGVUUKSSIGQWGTGTVMFEUSTYTQV(55x2)(10x14)IKRUCTQUXX(32x5)(20x2)JNEGAYZJAEFMMZNDQAYI(1x5)N(36x10)(12x10)PFTBHPEYKBFW(11x7)YRKUEULAVQO(65x9)(13x12)NKUIAGSIXWKEW(38x10)(4x8)IVPO(12x2)ENSUUWUGMFDE(6x5)GBZVEV(1x4)H(18x4)(12x6)(6x15)(1x6)C(1798x6)(725x7)(718x4)(128x9)(72x4)(41x6)XHDCTSCOLQXDITGBJPZCFXWLCBVNRWZKIHXOYRZQE(2x11)AL(10x11)CKPZHZXSEL(44x2)(38x2)(24x12)KQQVZKDYTAXJIECUHRNEEHIE(2x5)MR(2x14)EX(525x9)(135x3)(24x1)(6x4)AJAHVA(8x4)FCQQTUCX(42x9)(16x1)YJXDRMKLAJWGHRSL(9x8)CYVVQKOEQ(1x8)S(11x7)CGKRJUPVKDK(28x3)HQMZNCYOAIJBKRAGXYWTWOMEDSBE(1x4)U(16x13)UWNXBMZLSDWJWXRY(13x14)VALDTDWVJQQYY(48x4)(8x5)(3x2)HCC(28x13)(10x14)UFDCSYFEPI(5x11)NPDJR(279x1)(72x15)(15x11)CZESSYYLTNHNNEL(4x12)SCJE(2x4)IK(2x13)UO(19x8)AXUVJUCVOZYXECUHXTP(101x2)(7x3)MUNLZOM(5x7)GYXMB(13x2)UGNTFKQKQNSBU(27x9)IVJLAPCSRKKUBGNZXYELDTFXXDJ(20x12)KHMCDFDXECBLOWYPQFYZ(13x2)VDLMHMTQWHSIS(66x11)(6x14)RHRBCF(12x12)QBPGBNHZPQMS(28x11)BMIFCPCTBLKBIXCWFNLFSAOGHDWA(36x10)(30x1)KQYVYKBALRKIFSCOPWNQPYGRSSDAFY(1057x14)(320x8)(131x14)(124x3)(6x1)(1x8)Y(11x11)RYCMRYHAPAM(12x4)(7x2)LMPRCHR(65x7)(20x12)FBGHCCVXKKFXNJJWLKIU(16x10)KIYAZDBPNWXQXAKQ(9x11)EEQGTCDVB(1x3)I(132x2)(125x1)(20x12)HBEZQGFLJSFHGOYMLHSG(19x7)(3x5)THM(6x4)XKBKJV(7x12)(2x8)DF(14x12)(8x14)AXZPIRCT(33x9)(20x11)JCTTWVAOXNBCDBCUVNCX(1x9)J(36x9)(30x9)GCKYVYDUIBAWHSKBTTAHOYQWUQJHIV(699x2)(400x2)(45x10)(2x12)DY(31x7)(2x13)CP(6x11)TCMIXN(5x13)GBDVM(3x11)JAD(136x14)(11x1)ABIOQIJMVTI(6x10)NNTWTD(29x6)(1x14)Q(16x9)NNLMOVNFVJLXXLJJ(66x6)(4x3)RAZW(11x3)EQUJQECMCRI(10x14)DWLVSFXKGZ(5x15)RGJPT(7x1)RDFSOXE(74x8)(5x8)NEBHU(7x15)UEWKNIH(45x7)(19x3)TLAIFAYOOOCZMBIKVOU(4x6)OZBT(5x14)JEPAV(108x8)(2x15)LU(21x7)(3x6)JAV(2x3)LL(1x6)J(2x12)DX(59x6)(12x4)QXLWMASKAATM(10x7)OWRCRLMNRR(1x6)X(5x8)FBCAK(3x13)SIC(211x15)(2x6)IG(196x10)(54x8)(10x6)ZVIJHGXDTL(4x6)WCBN(2x12)IP(7x4)YLCWERN(4x1)LVRK(59x7)(5x5)JSDEV(4x14)FJFZ(17x7)KGBZBEJEIMCGUMSPZ(3x8)TAF(3x7)JTW(64x12)(2x11)BL(7x8)EQAGDIV(1x4)X(13x12)WDLMTJDUILHTJ(11x13)CBRRLLSHSWI(1x1)G(61x3)(3x7)CVG(27x9)(3x5)WIL(13x1)KFMXZGHEODGKB(2x1)QU(7x11)(1x13)S(18x5)VCSBJGLOOVXYTVMKOJ(143x10)(74x5)(25x12)IRMWONJTNGIJCGCTHVQOPQPIB(2x13)EY(6x8)NWOYXV(17x1)VBWAHETINYXRWMUVH(14x6)XEWNDODPNFJNFR(36x10)(5x1)XVRMW(3x15)PEE(4x9)RIJF(3x3)SYV(19x8)(12x13)(1x4)P(1x2)H(13x7)UKWAWHHQFYDWF(96x11)(5x12)PRKUK(13x14)RDQYSCYBCMONV(36x9)(3x15)ZOZ(8x15)PSPDGSWF(8x6)BMEGXZMZ(17x7)RQNGEXECJCUYFXPMB(163x14)(75x12)(9x9)YKFJTBRHE(44x15)DDSGHUAIXMRFTUHJZKDCTCLFREDDDHFAFQXALBIGIEMS(5x3)ZFRYZ(66x4)(7x8)KMXIZSU(34x15)ETTRETRSNLYOQZNWUXCNGPPUJPQNFYYEEC(7x12)RFTTNRF(3x12)HVO(97x15)(9x13)EASXOBURZ(14x14)EPODGHCXUDADRA(7x10)ECBRZCQ(22x13)SCAQGLZJTRSFEBTFFDTDRZ(13x7)RHQRORLJVNLWN(6x2)INZFFT"";

int compression_list[10000][2];
int compression_list_index = 0;

int main(void){
    long total_len = 0;
    int count = 0, multiplier_len = 0;
    int chars = 0, times = 0;

    while(input[count] != '\0'){
        
        if(input[count] == '('){
            count++;
            
            
            while(input[count] != 'x'){
                chars = chars * 10 + (input[count] - '0'); 
                multiplier_len++;
                count++;
            }
                count++;

            
            while(input[count] != ')'){
                times = times * 10 + (input[count] - '0'); 
                multiplier_len++;
                count++;
            }

            multiplier_len += 3;

            for(int i = 0; i < compression_list_index; i++){
                if(compression_list[i][0] != 0){
                    compression_list[i][0] -= multiplier_len;
                }
            }

            compression_list[compression_list_index][0] = chars;
            compression_list[compression_list_index][1] = times;
            compression_list_index++;

            chars = 0; 
            times = 0;
            multiplier_len = 0;
        }
        else{
            int total_multiplier = 1;
            for(int i = 0; i < compression_list_index; i++){
                if(compression_list[i][0] != 0){
                    total_multiplier *= compression_list[i][1];
                    compression_list[i][0] -= 1;
                }
            }
            total_len += total_multiplier;
        }

        count++;
    }

    printf(""answer=%ld\n"", total_len);

    return EXIT_SUCCESS;
}",20,646,14837
"int main(void){
    int answer = 0, i, j;
    int product = 1;

    int input[20][20] = {
        { 8,  2, 22, 97, 38, 15,  0, 40,  0, 75,  4,  5,  7, 78, 52, 12, 50, 77, 91,  8},
        {49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48,  4, 56, 62,  0},
        {81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30,  3, 49, 13, 36, 65},
        {52, 70, 95, 23,  4, 60, 11, 42, 69, 24, 68, 56,  1, 32, 56, 71, 37,  2, 36, 91},
        {22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80},
        {24, 47, 32, 60, 99, 03, 45,  2, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50},
        {32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70},
        {67, 26, 20, 68,  2, 62, 12, 20, 95, 63, 94, 39, 63,  8, 40, 91, 66, 49, 94, 21},
        {24, 55, 58,  5, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72},
        {21, 36, 23,  9, 75,  0, 76, 44, 20, 45, 35, 14,  0, 61, 33, 97, 34, 31, 33, 95},
        {78, 17, 53, 28, 22, 75, 31, 67, 15, 94,  3, 80,  4, 62, 16, 14,  9, 53, 56, 92},
        {16, 39,  5, 42, 96, 35, 31, 47, 55, 58, 88, 24,  0, 17, 54, 24, 36, 29, 85, 57},
        {86, 56,  0, 48, 35, 71, 89,  7,  5, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58},
        {19, 80, 81, 68,  5, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77,  4, 89, 55, 40},
        { 4, 52,  8, 83, 97, 35, 99, 16,  7, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66},
        {88, 36, 68, 87, 57, 62, 20, 72,  3, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69},
        { 4, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18,  8, 46, 29, 32, 40, 62, 76, 36},
        {20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74,  4, 36, 16},
        {20, 73, 35, 29, 78, 31, 90,  1, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57,  5, 54},
        { 1, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52,  1, 89, 19, 67, 48}
    };

    
    for(i = 0; i < 20; i++){
        for(j = 0; j < 17; j++){
            product = input[i][j] * input[i][j + 1] * input[i][j + 2] * input[i][j + 3];
            if(product > answer) answer = product;
        }
    }

    
    for(i = 0; i < 17; i++){
        for(j = 0; j < 20; j++){
            product = input[i][j] * input[i + 1][j] * input[i + 2][j] * input[i + 3][j];
            if(product > answer) answer = product;
        }
    }

    
    for(i = 0; i < 17; i++){
        for(j = 0; j < 17; j++){
            product = input[i][j] * input[i + 1][j + 1] * input[i + 2][j + 2] * input[i + 3][j + 3];
            if(product > answer) answer = product;  
        }
    }

    
    for(i = 0; i < 17; i++){
        for(j = 0; j < 17; j++){
            product = input[i][j + 3] * input[i + 1][j + 2] * input[i + 2][j + 1] * input[i + 3][j];
            if(product > answer) answer = product;  
        }
    }

    printf(""answer=%d\n"", answer);
    return EXIT_SUCCESS;
}",20,647,2068
"int main(void){
    long answer = 1;
    int div_nr;
    bool div_by_nr = true;

    while(1){
        
        for(div_nr = 1; div_nr <= 20; div_nr++){
            if(answer % div_nr != 0){
                div_by_nr = false;
                break;
            }
        }

        
        if(div_by_nr){
            break;
        }

        div_by_nr = true;
        answer++;
    }

    printf(""answer=%ld\n"", answer);
    return EXIT_SUCCESS;
}",20,648,158
"#define SIZE_GRID 100
#define NR_OF_TIMES 100


bool lights[SIZE_GRID + 2][SIZE_GRID + 2] = {false};
bool dummy[SIZE_GRID + 2][SIZE_GRID + 2] = {false};

int main(void){
    
    FILE * fp_data;
    fp_data = fopen(""data"", ""r"");
    char * data_read = NULL;
    size_t len = 0;
    ssize_t read;
    int x_coord = 1, y_coord = 1;
    int nr_neighbours = 0, nr_lights_on = 0;

    
    while((read = getline(&data_read, &len, fp_data)) != -1){
        while(y_coord < SIZE_GRID + 1){
            if(data_read[y_coord - 1] == '#'){
                lights[x_coord][y_coord] = true;
            }
            else{
                lights[x_coord][y_coord] = false;
            }
            y_coord++;
        }
        y_coord = 1;
        x_coord++;
    }

    
    lights[1][1] = true;
    lights[1][SIZE_GRID] = true;
    lights[SIZE_GRID][1] = true;
    lights[SIZE_GRID][SIZE_GRID] = true;

    
    for(int times = 0; times < NR_OF_TIMES; times++){
        
        for(int i = 1; i < SIZE_GRID + 1; i++){
            for(int j = 1; j < SIZE_GRID + 1; j++){
                dummy[i][j] = lights[i][j];
            }
        }

        for(int i = 1; i < SIZE_GRID + 1; i++){
            for(int j = 1; j < SIZE_GRID + 1; j++){
                
                for(int k = -1; k < 2; k++){
                    for(int l = -1; l < 2; l++){
                        if(dummy[i + k][j + l]){
                            nr_neighbours++;
                        }
                    }
                }
                
                if(dummy[i][j]) nr_neighbours--;

                if(dummy[i][j]){
                    
                    if((nr_neighbours != 2) && (nr_neighbours != 3)){
                        lights[i][j] = false;
                    }
                }
                else{
                    
                    if(nr_neighbours == 3){
                        lights[i][j] = true;
                    }
                }

                
                lights[1][1] = true;
                lights[1][SIZE_GRID] = true;
                lights[SIZE_GRID][1] = true;
                lights[SIZE_GRID][SIZE_GRID] = true;

                nr_neighbours = 0;
            }
        }
    }

    for(int i = 1; i < SIZE_GRID + 1; i++){
        for(int j = 1; j < SIZE_GRID + 1; j++){
            if(lights[i][j]) nr_lights_on++;
        }
    }

    printf(""answer=%d\n"", nr_lights_on);

    return EXIT_SUCCESS;
}",20,649,897
"char string[4];
bool in_brackets = false, approved_IP[2] = {false, true};
int ip_counter = 0;

int main(){
   FILE * fp_data;
   fp_data = fopen(""data"", ""r"");

   char * data_read = NULL;
   size_t len = 0;
   ssize_t read;

   while((read = getline(&data_read, &len, fp_data)) != -1){
      for(int current_char = 0; current_char < (strlen(data_read) - 5); current_char++){
         for(int i = 0; i < 4; i++){
            string[i] = data_read[current_char + i];
         }
   

         if(strstr(string, ""["") != NULL){
            in_brackets = true;
         }
         else if(strstr(string, ""]"") != NULL){
            in_brackets = false;
         }
         else{
            if((string[0] == string[3]) && (string[1] == string[2]) && (string[0] != string[1])){
               if(in_brackets) approved_IP[1] = false;
               if(!in_brackets) approved_IP[0] = true;
            }
         }
      }
      if(approved_IP[0] && approved_IP[1]){
         ip_counter++;
      }
      approved_IP[0] = false;
      approved_IP[1] = true;
      in_brackets = false;
   }

   printf(""answer=%d\n"", ip_counter);
   return 0;
}
",20,650,416
"#define NR_OF_INPUT 1000

char * data_read = NULL;
size_t len; ssize_t read;
FILE *fp;

struct data{
    char name[100];
    int value;
    int highest_value;
};

struct data registers[NR_OF_INPUT];
int nr_of_reg = 0;

void parse_data(void);

int main(void){
    parse_data();

    rewind(fp);
    while((read = getline(&data_read, &len, fp)) != -1){
        data_read[strcspn(data_read, ""\r\n"")] = 0;  

        char * pch, reg_to_manipulate[100], reg_with_condition[100];
        int inc_or_dec; 
        int inc_dec_nr;
        int condition; 
        int condition_nr;

        
        pch = strtok(data_read, "" "");
        strcpy(reg_to_manipulate, pch);

        
        pch = strtok(NULL, "" "");
        (strncmp(pch, ""inc"", 3) == 0) ? (inc_or_dec = 0) : (inc_or_dec = 1);

        
        pch = strtok(NULL, "" "");
        inc_dec_nr = atoi(pch);

        
        pch = strtok(NULL, "" "");

        
        pch = strtok(NULL, "" "");
        strcpy(reg_with_condition, pch);

        
        pch = strtok(NULL, "" "");
        if(strcmp(pch, ""=="") == 0)      condition = 0;
        else if(strcmp(pch, ""!="") == 0) condition = 1;
        else if(strcmp(pch, ""<"")  == 0) condition = 2;
        else if(strcmp(pch, ""<="") == 0) condition = 3;
        else if(strcmp(pch, "">"")  == 0) condition = 4;
        else if(strcmp(pch, "">="") == 0) condition = 5;

        
        pch = strtok(NULL, "" "");
        condition_nr = atoi(pch);

        
        int reg_with_condition_index;
        for(int i = 0; i < nr_of_reg; i++){
            if(strcmp(registers[i].name, reg_with_condition) == 0){
                reg_with_condition_index = i;
                break;
            }
        }

        
        int condition_met_flag = 0;
        switch(condition){
            case 0 :
                if(registers[reg_with_condition_index].value == condition_nr) condition_met_flag = 1;
                break;
            case 1 :
                if(registers[reg_with_condition_index].value != condition_nr) condition_met_flag = 1;
                break;
            case 2 :
                if(registers[reg_with_condition_index].value < condition_nr) condition_met_flag = 1;
                break;
            case 3 :
                if(registers[reg_with_condition_index].value <= condition_nr) condition_met_flag = 1;
                break;
            case 4 :
                if(registers[reg_with_condition_index].value > condition_nr) condition_met_flag = 1;
                break;
            case 5 :
                if(registers[reg_with_condition_index].value >= condition_nr) condition_met_flag = 1;
                break;
            default :
                condition_met_flag = 0;
                break;
        }

        
        if(condition_met_flag == 1){
            int reg_to_manipulate_index;
            for(int i = 0; i < nr_of_reg; i++){
                if(strcmp(registers[i].name, reg_to_manipulate) == 0){
                    reg_to_manipulate_index = i;
                    break;
                }
            }

            if(inc_or_dec == 0){ 
                registers[reg_to_manipulate_index].value += (inc_dec_nr);
            }
            else{ 
                registers[reg_to_manipulate_index].value -= (inc_dec_nr);
            }

            if(registers[reg_to_manipulate_index].value > registers[reg_to_manipulate_index].highest_value){
                registers[reg_to_manipulate_index].highest_value = registers[reg_to_manipulate_index].value;
            }
        }
    }

    
    int answer1 = 0, answer2 = 0;
    for(int i = 0; i < nr_of_reg; i++){
        if(registers[i].value > answer1) answer1 = registers[i].value;
        if(registers[i].highest_value > answer2) answer2 = registers[i].highest_value;
    }

    printf(""answer1=%d, answer2=%d\n"", answer1, answer2);

    free(data_read);
    fclose(fp);
    return EXIT_SUCCESS;
}


void parse_data(void){
    
    if(!(fp = fopen(""data"", ""r""))){
        fprintf(stderr, ""Error opening file\n"");
        exit(EXIT_FAILURE);
    }

    
    
    int curr_line = 0;
    while((read = getline(&data_read, &len, fp)) != -1){
        data_read[strcspn(data_read, ""\r\n"")] = 0;  

        
        char * pch = NULL;
        pch = strchr(data_read, ' ');

        char dummy[100];
        strncpy(dummy, data_read, pch - data_read);
        dummy[pch - data_read] = '\0';

        int duplicate_flag = 0;
        for(int i = 0; i < nr_of_reg; i++){
            if(strcmp(registers[i].name, dummy) == 0){
                duplicate_flag = 1;
            }
        }
        if(duplicate_flag != 1){
            strcpy(registers[nr_of_reg].name, dummy);
            nr_of_reg++;
        }

        curr_line++;
    }
}
",20,651,1648
"char input[1000000] = ""(172x1)(3x7)XPJ(70x4)(40x7)WKQANMDILIQOOWQZDNGORPHFNHBKKKVQEJNUVNAQ(3x2)VFV(10x1)XUNNCAFYMV(9x13)OUIKISEPR(66x13)(10x6)JHDDURBDQC(3x11)SNT(2x11)EW(16x6)WMJFKTNQEACIZXLH(5x12)KPVAD(13x8)(8x2)ELNIDSSO(11x7)RFITQIJYVQB(6x5)HTVSFUVZ(89x12)(44x5)(7x1)VHEWGTT(5x11)GLDZO(14x13)DZVEJXGSGUDJKV(24x14)(18x3)AWXPFDVHVRRUAIELQO(2x13)UW(120x7)(62x7)(21x10)JFUYPPCABHPYTIJUUIEVK(5x5)UNAMQ(17x14)TFQKSOALOJYMSMLMK(17x2)NBDXRSHFDREHZPWMM(23x5)(1x11)O(10x6)QVOCIXBIQW(5x10)FOLCQ(6635x5)(3576x2)(456x13)(449x3)(1x2)M(1x11)I(215x14)(28x2)(1x14)R(9x7)OSMSWTRTV(2x3)RP(87x2)(14x9)QACULEYKFWPHFQ(41x15)LTBJBTBTFQLLEAWJTICLZBHGAYERVARMDLCBZXYPY(4x6)CEOP(4x13)JQJI(62x5)(15x6)YQPFVDNREIYOUKL(15x15)PUSBXTHCMLGOCNT(8x4)YAUHTKIM(1x1)E(14x2)(9x1)YHUAWBSED(37x12)(14x9)(8x11)SVYXKPGZ(10x13)WTQVTWIWGP(162x9)(68x1)(1x4)I(21x14)WTBNFSPQKDFYITBOFYYQN(3x8)UOY(13x14)KCDKDKYFQNNPX(1x6)K(20x9)PMGWXQWRLRWRETULVFPW(1x3)T(20x13)(7x7)YYHNWZC(2x10)HH(22x10)XDUOOOIDYYXQKQDBLGCPSR(1297x7)(359x13)(62x9)(7x15)LRERGOG(25x15)KYQSSJBREHLNZXSLSYGIIADSC(10x15)WMFZAHRNRU(283x14)(68x12)(16x10)QGQDCKCPTECIPTOW(19x6)WMPAPTDDUABBOLYMMBR(14x1)XRZVQKCBBBMCNI(29x5)HSGAQWQRLOILWCRJOCRDFZSOTPLBH(82x1)(12x1)RENHWOTHWXPZ(39x10)BIKLBTNHOLVUWVGTPRPXXROUGEJRHRADHASJDMJ(4x13)VRRP(3x1)BFC(79x9)(39x4)OINGYXONKTSXJBCNNYZMWSYGIUMFATXEUDZQZVL(9x13)OIMKIRFAT(5x1)MIUXM(3x13)EPG(496x13)(37x4)(31x9)(2x5)MF(18x2)MEVRXNGVBHEGENHJTL(11x13)TTCEWIFBGGJ(150x4)(68x13)(9x10)KJJRCHTUM(11x10)SVUDYGHJWKF(6x12)LNWLUN(8x11)LUVPHPZC(4x8)VFUZ(32x9)(2x3)RH(5x5)OOAGL(1x15)W(2x11)WM(3x4)GFG(22x13)(8x6)ZVCSHQXP(4x8)KOXS(193x3)(25x7)PXQFECGPYZOYUWTMOTBFZGGAO(28x12)(7x4)XHUHXEN(10x4)DTXYSILNLW(1x2)Q(101x13)(16x11)MZVPYIEPSLDSIEAF(27x11)NFACRSGETEPHFJQKPTXUQNNSPWT(6x13)UADYIT(2x8)LB(19x7)QYBDEBFMFAWOTYACZQM(6x13)YEABPA(72x6)(58x13)(3x15)UOO(43x6)GRXJNNQQXQVANDHYVVQTTWIKVLPHBJMCSEOPBELMGHG(1x10)G(178x10)(12x1)(6x15)JWYUKS(93x13)(5x11)CQCXM(56x7)(9x5)FIARQLQTK(11x3)NSXGBEOBVXI(9x15)QIBUNRTPC(5x8)GBIYV(13x10)(2x6)RC(1x5)T(33x14)(3x4)END(19x6)MYZTTHSNYAYANBPGVHZ(2x14)YD(6x12)(1x5)N(3x13)TFG(224x8)(11x15)XNMAIBBNTMC(199x8)(2x10)VG(23x11)(5x11)KOKXL(7x9)MIMRNXM(121x10)(10x9)OGYRDPVNEI(27x5)XUBNCPGOKJIXZNAHHLLDRUUTPRM(25x2)FVEEUXQTUBDUDSMIRLBFQYULY(13x5)JTJASJBCCKFHV(16x6)TVTTDIFACKNORYBR(4x2)LIFO(17x2)RZGYMXWONVKWJMSVW(833x6)(586x12)(230x10)(2x13)EL(41x15)(34x11)KPHSFJQJWTINMWYVNSVVZBABFYEBZCLNMQ(17x14)CRLPIZUEIBCKNKRJJ(62x15)(9x4)XTGHEGPMK(11x12)NCNNMDWDNMI(8x2)PKWGUNYT(10x15)DVAFJQIPSK(74x10)(5x15)ZLKKA(17x11)GIERLJRIDYLPWZCKG(33x2)OASXACZZRSCLVDVNLNGQHLRLMZCTMBCYP(153x7)(2x14)UX(49x8)(11x14)GEHZYBKESFQ(2x6)TE(6x3)THQOAO(8x6)FSPDZODL(42x11)(2x12)XO(10x7)IZTTYUPKBT(11x13)PVRXUXHBKQI(35x6)(5x5)UDRJC(1x9)B(13x9)YHHERZVEFSCFX(78x11)(36x3)(1x6)X(23x14)DHLGIIMPJGKDUOPFEBPKJZB(7x12)TMWJAJD(16x12)YVALDPNTHINYQQIC(2x9)OY(90x5)(62x10)(9x6)RUUFLMWQS(28x6)TAZAAAIDBGZMYXMNGHVTBRHWFHXV(8x13)JIRKEMEB(15x5)ORKLKISZMYECJBE(178x12)(59x5)(5x9)QLOCV(6x5)XETXIX(11x15)USNLPYJLBOW(13x15)ZYMFNBNVKKQFT(11x3)PISAKCRXTWT(90x7)(52x2)(1x3)F(21x6)QFIQOUEYORICJDZVHMIOW(13x6)ONYWAVOHAIQXE(9x5)TKBIAQVJC(7x5)SUEYTHE(1x4)H(46x13)(33x3)(26x15)(1x3)Q(14x3)OHRVGRUAQFTYYS(2x6)BS(960x3)(544x15)(160x14)(15x2)(1x11)D(3x9)PXR(52x4)(9x13)ZVIVIWOIO(1x5)D(1x12)Y(8x8)CKZGFGQO(6x9)DAMZNP(75x8)(13x1)VDPXRVCMGTZIY(3x13)WMF(10x12)KDJVCJQVEC(24x3)GEKGZEIIDDDJRSZBNAIDNASO(3x15)VUI(74x5)(46x8)(6x2)GSPMZV(4x2)XOOW(9x15)COLWEPZNQ(5x13)UGBDW(15x10)TTWVRPQTREJDSJS(137x14)(65x10)(8x13)OMBDNQBZ(44x13)RVXFBIJOFAQJCLTKYBXVWALEONUACICLGJIWATGHHCZK(22x14)ZSGSVEEFHRWHXBLGCDJKZV(30x2)(2x12)GG(9x12)HJQCPKGNY(1x14)H(134x15)(5x4)YGCHW(5x10)EROTH(26x10)(7x1)OXPTTDP(8x10)OJJSDGCL(74x8)BDTYNXCCPDQCMYZJTAJOYCGMWJLOMLEQYBCYAZOLTCYNDAPXMXCHVSKJCYXZWBKGVELGTLNCEB(54x14)(14x13)(2x9)SM(1x10)U(27x3)XFJSNXIJPTSFDKVNGBDNRLQYJKQ(16x11)(10x9)BAPIHODLEG(317x8)(112x11)(30x4)(6x15)UTROFQ(11x11)UYHDNMPLNBH(28x5)ZMZKTXRTUNMVSQTUGNYDWUOFAFBA(2x4)OT(21x15)(9x3)VRSRVOEDX(1x10)W(1x12)H(86x12)(1x6)Y(25x9)ZYIPXGLABDQQRIQOWYNSVRDDS(35x5)NJIVDKLQTESWZNBIFFPADGWBQGVWPNOZKOB(3x8)JZK(98x8)(45x10)(6x5)LYJQMR(10x7)EFMGJRIYHN(1x12)W(5x11)CXUHP(40x1)(33x14)BIXNELLRAWDEQWDLFXASPCFKGYXNPZRLP(102x3)(35x15)(29x2)(1x1)P(8x2)OGCHVTFM(5x2)CVQRK(54x3)(48x4)(10x3)(5x6)IUXTW(26x7)(7x3)MCAIFSI(9x6)THFFYJGAO(1522x10)(25x12)(18x13)(12x1)(7x4)HVDYPIO(1159x6)(211x8)(154x11)(21x6)VCPDOYQRGXIJVQGRJTVWP(12x10)CEOZLAMGANTR(16x14)HRTTJOTOJYRMGUDK(79x5)(4x11)JHCB(4x15)FHRU(9x12)TVDNDJPQW(2x5)WH(30x14)LUFKTGXZTAORPRJMZESFFDVVWPVYTB(42x14)(35x14)(29x2)SAGPXWQEGTZAIADCQFBLWRLZIQGCN(135x7)(15x14)UQJYCTIFFWSUWWM(65x2)(9x9)(3x12)JUN(18x5)(12x8)RDYSFFHOCMTA(2x7)QY(14x3)(9x7)FERWVDDHQ(36x2)(11x7)ILSHNBRIBMC(13x8)SRXBXAPPTJPLF(101x14)(2x10)VE(86x10)(29x8)(23x8)KAMCCHDVKOOJCGDQJPZZMPJ(32x9)UEYJFLAOACKYLFDJWQUXGIZYWMHDKYLK(8x6)(3x3)LKI(682x13)(208x6)(76x14)(8x10)AYLZDXBI(3x9)BRC(25x10)IEATCRHBHGIKZBQTRCTXULAMN(15x12)ZHRTNMVERVGZZCG(32x3)(4x14)ERHO(7x7)NNNSCSF(5x4)TTUFM(4x7)XYWL(72x4)(3x7)SDF(29x13)OQXOWQELFOXUFEEBUPLNHMAOGLLPV(14x5)SZJGEXPPXSUXCB(3x8)KND(95x1)(28x5)(7x3)LVLVSVN(10x8)TGDBTKXVLI(10x11)WRFPBLNECA(29x1)XFGOLCPIYTKNJTXBAEATURQVVXGFP(3x14)YBZ(205x1)(16x14)(10x8)IFQMAAEMOP(32x9)(16x14)VBFTUPKSNIUAEBHA(3x14)EMW(23x11)(2x7)XS(3x7)QWS(2x12)TE(107x2)(21x12)XKLOCAHJZFYLQZMQDZUJP(28x15)VFRNAEWVNJVUZDURVOCUEISKGWWN(20x6)NXCCPUPQKGXTOWWRANDP(12x9)WRJVTTEYFJBE(146x12)(1x12)M(46x3)(12x15)ELAIIEJMLHRV(1x8)I(1x14)K(2x9)RN(1x14)E(81x6)(14x4)SHLOZXCBQTBEZF(40x2)YMEOXRNZXDIEEFLRQQDPWXILUOJQHDSUEKNXNQSP(3x2)TGQ(1x10)X(315x14)(307x10)(3x11)ZDV(260x4)(97x8)(20x11)YRELCFEJXQZADZSOJION(14x14)BGCJIBHVHEGFOD(3x14)PVA(33x13)KHUWKRRNHTHJCROVFAOIWGGOTIPKDMPRC(36x5)(2x8)HZ(22x14)YZSUXCHXDEPXIGCWUOKUXZ(62x10)(15x7)JZUDNJCWXTQAMOM(4x10)BJDT(24x14)ETEADJJYZZDODVKPPXTBTUPC(40x1)(5x9)UZDRJ(24x2)VPGSGVADLRBFODBZBMWBRJFC(24x14)(10x10)NJQVLSVHKJ(1x15)B(1402x12)(1381x11)(690x9)(163x6)(76x1)(16x11)TTKEOWZUHJMAOJVI(4x15)LGFT(3x6)MYP(17x7)CHKQJJMHHGHDXWBSO(7x7)UJLDJLX(11x12)LGBIGRGMTBV(21x6)RISOUTKGCNPQLLDWNLYEA(5x14)IZRZO(19x8)(13x7)ZYNNYQLEROHNK(23x9)(3x13)KRN(9x5)(4x5)OXVO(185x5)(52x6)(6x4)QOSUZS(18x6)GUQOGCRNSAKDCOCTSE(10x14)KGZBUGVIIH(40x10)(6x12)CMZQRR(1x5)Q(15x11)WEKZHYYCTPIPOZJ(58x8)(1x4)A(6x8)ABJIRX(11x15)EQFJHQOVGLY(6x3)YYQMKZ(7x7)LKJYEWV(5x4)BPTKB(1x4)J(284x5)(63x10)(1x8)W(11x13)MPTRNQPSBXM(15x3)VHDTUWNDEGLNCSQ(2x1)CQ(6x2)OCFRSJ(63x9)(15x12)AEYDUUWROCUABMX(12x4)RPGECWZRBHLK(1x11)O(10x4)JCBDSFSXDE(13x11)(8x4)BEHBONOK(83x2)(4x6)ANAD(3x15)LOP(20x15)TJLFCNGAYSBMWACNIOME(14x14)OLVVHGNWUVNXMR(10x12)DAHIOTLOCP(30x9)(2x12)TR(16x3)DYWYHJLMIYAHQIIE(3x8)SNV(112x15)(19x8)PBXORKYLISLHVCJVBJP(74x10)(2x8)FP(24x13)ZXILHYHYDGDNGHIPFHLMRLQS(2x11)WN(21x13)RDQDPNVEOLOSPLAHQHHMY(1x9)R(14x6)LIIRDEBBHSKXZT(372x10)(164x2)(40x7)RMPKUSRDBXNZLGDXZIAUAZNQBJEMSBUJOJNPHHHI(12x15)IAFPAWBOSBOS(76x6)(5x6)UYNUU(25x15)XPXFOEMDDICGRJONJBWMOZCIW(8x5)KJJIEDUG(15x2)IEUTKVCMTTXZNTC(11x9)IKWCZMUNCOP(61x12)(54x13)(13x12)NIOHBMYALHOUO(7x10)KFDUHJL(2x3)NM(9x9)OSVPKOFSM(5x5)VAMMP(9x3)EZLMGESLP(102x5)(26x5)(7x9)NHCIGIE(3x3)IVY(1x2)L(12x7)UXAUQLEXZGXN(46x6)(1x14)R(11x9)QTBPNKUFZOA(16x9)DLXKSEJJVMWIIHPB(157x8)(30x4)(13x15)TNSMJZJMNEUQM(4x12)HRAW(113x15)(17x4)(3x13)VQG(2x11)YK(4x9)GMIK(15x12)YGMZABAZZNHPRHP(23x4)(5x13)ZBQGH(7x3)SPNLPWT(24x1)HVEWGOENETTTKKBJHMBEFJSJ(6x14)WGBSYS(2694x1)(873x13)(591x15)(1x2)H(14x12)(9x8)(4x7)PHPZ(59x10)(10x7)EQJUHLQDSB(11x6)MHGNANYAWWK(3x8)FEN(11x12)RCPCNTVKIXQ(491x7)(78x14)(40x11)YVRYFJZMQREHNXZZPWXKNPHSUTVUGVEOPFQQBLOJ(25x1)(13x1)HQFQJIYOMZFGW(1x8)F(182x6)(86x14)(12x9)WODINQMTBDAX(6x7)JFCXXM(6x1)FKJPPD(40x2)IDAKJRAQIDKLPCCATMTFTOWNPLHKNJBTAVVHUWWN(53x8)(4x1)FXRX(9x1)DCBBRHJVU(2x2)RA(10x14)IWJGLMPMBS(1x5)H(14x2)WXKMITJBMZACIB(5x2)WLBVL(5x1)XNGOL(193x3)(6x8)ANFCUH(11x13)ZVGWPGYGIAR(72x4)(9x10)LUYDGWJLX(8x1)WUXTMRZR(2x3)FK(21x8)AGZIOWSLPHAKSUPECVOHV(4x12)FDXE(6x12)(1x8)M(68x7)(3x4)EOK(28x13)JXAMSHCQOBIUKUHUFYOOZJRMMNCW(19x4)YBUXDOFHTQVATUPANAF(1x15)H(110x13)(93x7)(87x2)(4x12)GMOE(50x11)(13x3)VHUHCBUNINBAH(9x14)ABWUPTZJB(10x1)ULUUYHAWHR(14x7)RSQMESIUXRZOVL(6x4)FBTNDA(5x7)ADGJH(139x5)(131x10)(123x14)(88x6)(1x11)A(17x13)XCWUXQVXMMRLURVHL(9x12)NBLNMYWQH(23x14)IOMVENQGFGYSOQNKKMXALXR(7x6)OWEXJQO(23x1)BGMPXSGMVQUXQJNAGUDPASW(168x14)(149x3)(17x1)(11x1)PPOPWWURQYN(119x7)(63x1)(4x14)CIWA(9x5)(4x3)YHDL(32x10)THARHNYWOIICGXLNEHOTTIEJXOLESVFO(44x2)(30x2)FMAVRVLKELMJLGHIPGCRCHJFVTBSUP(3x3)SIW(7x8)BIFVNRC(706x15)(699x8)(6x6)(1x1)B(284x11)(154x1)(26x12)BCUDXLZNEUYZIEKRPJNGEFKMNE(49x5)JNLLBDIRMRINXOUMGKJXTVCKAMZCEPVXFRIUUQXUQAHXXWERV(41x4)(5x15)JUNET(9x14)LAEKWBIYU(1x1)O(4x4)JFAB(13x4)KARCNJKHMFJFW(94x7)(64x7)(7x14)VRRWPHM(16x2)RYATIQNKHUXCZEGS(8x13)WZSZNRIH(3x7)TBE(2x4)DA(10x10)TJBORFEVFS(2x4)VE(8x15)YTADJOMR(4x2)XQAO(389x2)(171x3)(52x4)(1x6)C(14x1)QUCOESZSLGRLIJ(7x13)UVHYAWH(1x8)A(1x14)R(16x2)HOCCGBBDBBAJPVFU(52x8)(2x3)IV(20x3)BADNVTFDYEOJOSTOURIR(6x12)UAKYYR(1x12)D(3x8)RDJ(18x15)GDBLXRBQGDVOGYNIDB(7x9)RVLXMQP(146x2)(45x15)(3x3)NNY(10x14)EUROHLVNXH(4x12)JYRH(5x3)GJZII(2x1)IN(6x6)GPYYHE(70x5)(22x3)JSUZJGHKJQSJZHNHSBYXRX(11x4)CKNLLPRJDJB(11x9)EYWLHDJWYMZ(3x4)EOQ(39x11)(19x11)(12x15)ZSNCSSNGFNWK(7x11)QKRQMES(915x15)(657x4)(121x15)(21x4)(6x9)PBLEYF(5x3)JYILW(88x7)(48x6)(18x11)LHFNPRFKADOZQRHQVE(5x9)JSXCT(8x2)QOQRTIAA(7x3)NKKNWLS(16x4)URODMQWUOAUZDVTW(203x11)(196x3)(72x2)(1x12)L(2x3)AO(8x3)XROVOMDL(9x8)YZAEPPLFP(25x5)TJCBFMVSXVPIIOUHRJCUZAFPK(35x9)(22x5)BSQZOCOFMKGAVXARGGFCYV(2x1)BR(46x10)(3x1)MNZ(13x4)EBBUVWXRIWLMZ(13x8)EXOJUNPCWPYQE(9x14)(3x15)NYG(4x3)XNAD(6x3)OAGYDW(299x3)(130x5)(5x5)ZIVTZ(4x8)WRBW(73x12)(5x13)TCVNI(25x12)TLVHEMSRDZWQRIYKHDGLZVLEQ(24x3)PIOJWVRBAOPTXHUJAGHCRGNK(24x14)VCVZEHKJWAPXJDMALSUKRZAW(30x4)DMROHLLFJEFQZPAEVOYCSESESVCDPT(107x1)(19x11)XYGUSLMMCMUYFOZZCSG(9x13)(4x5)TMYS(2x1)BK(1x3)L(46x13)(40x7)JGIWCASPBLNAZSSBXMFLCZNHCLRYKJTSKTRIYXZD(7x7)SIMRJYC(243x12)(219x7)(4x8)XKYN(202x11)(26x11)(4x11)JIBP(3x12)TUQ(1x12)U(78x11)(10x12)PYKJEJKLOP(7x12)MGGQRIM(6x3)WDBTTC(10x6)EFUZOEPGTG(15x8)ULWOSKACKQHHDTH(2x5)OX(24x4)(1x13)Q(3x10)PLC(2x11)AZ(40x14)(4x3)IOIG(7x15)QQTGOCG(4x1)TTYK(4x1)KMKT(11x2)DUFCFLWJKDO(4988x11)(514x13)(184x10)(176x15)(168x14)(49x8)(11x13)NGQSRMSYVIT(5x13)LIGXA(13x13)QLVGLJOXJZEMA(14x3)BHSJULNXUJNMLB(21x13)QWVNZXHEHTXEDXQKZCKZH(59x3)(23x14)IZNXJWCWIXNWKNQDTNQUAEO(23x6)GDBWPQKJXRWQSZJUZRGBNNF(14x4)(9x7)RQPHPKUPM(7x9)QVUICMY(269x12)(34x4)(11x1)IODKMJLLLKQ(10x15)KDIWUXJCVN(221x12)(47x9)(12x12)RCNHOSXDVYYI(21x11)(3x4)IJG(8x4)XBPLQPKV(150x6)(75x15)(2x6)DH(23x10)WKXGJRDSEZTLPKCMMUZZMXF(7x7)WURAPMO(3x4)RIC(12x6)MFVQJUULXSZX(9x7)LSYQTUAPN(47x14)(3x10)YZI(7x6)YHUFAXO(1x4)M(14x4)LANLTXIEINNYBW(6x3)(1x1)W(8x9)FNIRZGYT(3676x12)(585x11)(242x2)(19x8)(12x15)OWCUIMOZCPJU(210x4)(107x13)(10x14)BTVYEADZIL(39x12)UMDJKKZWWGKFLEFWKVTRGZMWUTEWWFYSVMIVJQF(3x10)NEL(28x11)MLIMLBMEATHPEVTQRQTHBUOCFZMW(65x2)(23x12)SGEKZUXQNIGZURVKPNAISOY(21x2)UGJLXKWJVUFGJURKHTETM(2x11)XQ(17x13)CTOVPHTPJVNUSQZLY(329x9)(27x4)(20x15)(6x7)SWYPVM(3x10)ICH(105x3)(7x2)(2x1)QZ(11x11)(5x14)XUSZN(69x8)(7x12)VCQYFSA(24x7)EFVFKBFLRAJTGXEQGICZSOSE(10x7)CNXAKLLDBZ(4x13)XFXW(20x5)(13x15)SQZPVKWYCGMLX(96x12)(9x10)QNJNUKACF(14x3)WBKWFXIFFTAGKJ(2x11)TM(47x7)(9x4)WKFDSSPUO(12x2)TNCXEWMSFUPL(3x7)BCH(1x10)W(49x5)(23x10)(17x8)LMJYTUJGSCJDSMNZI(1x14)A(7x3)DYODODD(735x4)(2x13)CT(147x12)(140x1)(10x14)(5x6)KBFDG(74x11)(3x7)ASG(6x1)BAMUUR(11x1)HYWHOBKJIPH(22x14)ROJWCVIRBUVOXMHEBMHRBD(4x6)IHCB(36x9)(2x12)KI(1x1)I(16x4)TYYWOESVEYUUSCSQ(272x12)(6x13)YBZCAF(2x12)XV(12x10)(7x5)EOKMUXF(91x8)(4x3)CYOY(76x4)(2x6)QT(29x5)NMTVCDRMTLDIVOECJLYHZUBPYGOFD(4x5)IAJR(11x10)YPFPNDBONFO(2x3)WI(129x6)(77x2)(10x14)PAQKAHBQAX(2x4)YV(19x1)KXUKEJINNRYFXQJKRSM(10x2)YJAIIRZOWD(7x4)MDVMTGB(19x6)(4x9)MMQC(5x6)VZZVQ(2x7)XE(2x3)EQ(2x1)MA(202x9)(183x5)(13x5)YGYLMWENWKOEP(8x15)MIAMCHRA(67x15)(2x14)RP(10x5)NVJOFHUZFU(19x13)ELUOKNLHOOIAYZOCIMD(10x13)DQTLOMUCCQ(70x4)(11x1)KZALNOFLDHG(15x13)WLWZWHTUHWOZLES(9x10)FMITUKLQU(3x14)WCL(2x6)CK(6x10)(1x2)W(76x10)(2x8)ML(62x11)(48x11)(4x12)IRUH(4x3)DBQU(22x15)DYDBCSWMYSBLRNSNGRWCEU(1x15)Z(745x3)(23x1)(6x8)OKKJKF(7x1)(2x1)UU(709x5)(217x7)(116x3)(41x11)OAOMKCXJMJKKPSYWLNBFUDEVLICRKCGHRTGCIUAXZ(17x12)SKMYSNPPLDSOKIKXI(10x2)AYWGQTPNPX(12x14)GQFNEYXBYAAN(4x2)DWAS(12x13)MGXEWSKMSNTH(69x8)(7x6)LEFUMOK(19x4)UREDJOQURHFQCDSOZKZ(8x13)QPNYHWBW(12x2)JVUTOZHSWMXS(143x9)(79x6)(5x6)ZLLEG(4x13)ZAKG(2x6)QM(32x5)ADNXICFDFEOECVZHIVQKALYWLJGUSOSI(9x9)AWIAWSRJZ(52x5)(5x6)QSJGP(10x1)KDADHYYLCR(4x9)BQEP(1x1)Z(6x9)OMYNHU(103x7)(86x5)(2x13)AB(45x6)PQHXQFEMSNVRLACWAKQOYTZVLYPGBLAVMANXZHEMATRCF(14x4)YEVRVCORQWAJYG(2x3)AC(6x4)(1x4)W(135x15)(4x9)NULK(79x7)(7x10)RVBBWHN(3x12)MEL(33x9)FQIMGFZZTZBDCAYWARBLFRRQTJROKZXOJ(6x8)PWSZAR(2x5)ZR(13x8)RGRLYMPEYXDYF(15x15)EKZSLEASGQCSSAQ(76x5)(3x1)GDV(14x4)BYSPLEVMSPGXHS(4x2)LIDY(33x9)(27x4)ZWOLHCSTTPJZTODWETGHTNMAPAF(1215x14)(142x4)(14x1)ODRTZPGCANTMRQ(11x12)FFJIYPJJDPY(18x13)(12x7)PHABYHRKCIBS(72x12)TLUCYATALAFMLBSLTDHFNEGCVYKQFKPHVAMBSCYPSYMMGFGEPKMZRVXAZLGQQGCAQVIDKQCZ(119x10)(100x8)(6x6)ZKHOPF(37x8)JZJYXJTGQWXJKOWCEGRYFWORONDPKWDHGQFWR(9x10)JZTDQPVOV(7x11)MNMFBYO(12x9)(6x12)TEOCNK(6x11)(1x9)U(413x10)(1x12)W(357x6)(81x1)(20x13)AXMPRMJPLLNQTKNAKAKL(15x11)NCYQCFJRFVEBMBE(10x15)IDMWCCMJMT(9x15)KDITVSFLX(8x13)LWDZHEIH(85x4)(9x8)DNTHBQVEK(3x12)RCQ(17x5)IONTLMAHANUFDOIZZ(3x1)IKC(24x10)YQLVKHSGEHGXGFYSVJGHUHUA(109x4)(4x12)XZEO(12x5)HEZUPCXXEENI(12x12)OMJTLBITZWOB(13x13)YWOEGEYKAOZJS(36x8)VUZJQCVRHXSSCZNTEFKDZLVHDVCJSREVEVCB(43x6)(2x4)RT(4x12)CIZV(20x6)HHICUGNPVNOEZZGDLIZY(36x6)WRYFVILIDECKLNDCCWDEBAAPNRQVLQTWUQRC(260x7)(81x9)(5x1)XTIWO(7x2)(2x7)HZ(47x3)(6x5)EJMXOK(10x14)CVISHTXMOH(6x12)QCQAWT(1x12)V(1x3)Y(165x10)(21x10)PSYSIOEUPVJSLHBRVCOJD(39x12)(12x14)UBTGKOQEIYFM(5x4)CLHJC(5x4)FWNYB(9x13)ZHUPCPRPR(39x13)(10x15)YKYHEZRRDL(3x9)TRX(8x15)STWMOZDH(23x10)(2x9)ZM(2x7)MV(3x13)OQK(243x11)(210x8)(42x14)(17x12)JIOXSDZFXPPALZIKA(12x5)VJLEWBRVXMCD(23x2)VNXQYVPIRTMBGPKVZNTOFOG(61x6)(7x4)NSPFDMJ(9x14)TVHJEJSSJ(2x13)IJ(13x9)QTFHJIOJOQAOA(1x11)C(59x3)(6x11)MSQZOU(31x14)VLYOENWNIUSCUPMSOZEFABALZGGUXSZ(3x12)MIA(13x5)XZEMQZEXZTHJP(1x14)O(358x8)(162x14)(39x11)(13x5)(7x10)ZEJGPTO(1x12)V(8x7)PFNFRIMK(8x12)(2x13)LL(47x1)(41x8)(1x6)W(16x10)KZDYKHCTWZXEKCNJ(6x11)BKPJMJ(42x15)MMVAWYBRUXHRRXCVQBRTDORBFQQBOOHMVEKUQKJQTP(58x11)(28x5)NMWGTZUQBNENKBJWXUSTOSCMPLCZ(18x7)XIOSACAMZDWOJMBKQD(105x2)(72x12)(48x12)(5x10)XABVT(4x1)FENC(3x3)FPK(3x2)BMX(7x2)CTTSNTO(11x2)(5x14)XLVEE(2x1)PI(6x10)XMZISE(2x6)AK(6x1)ZPYKXO(774x3)(10x4)QTZHPYSXNC(720x15)(226x14)(40x9)(2x10)BT(17x14)(2x15)SO(4x2)ECYN(2x10)JM(7x4)XOBYLTV(120x3)(1x3)N(19x12)PEGBFGRTJFJSVIQZTNS(2x5)JD(41x13)(3x13)YTK(6x4)FUJASF(5x10)NHCVS(5x7)EBSJH(27x3)MMLCNRRAUAKKAGPBUHZQKMJVRLY(35x8)(12x5)EUFDLSCJNJIW(1x11)F(5x8)OICJN(178x3)(1x5)O(164x12)(69x5)(1x3)Y(13x7)NJGIFSDNRZGUN(20x2)CHUHUOZQHKOBNBNITRCT(3x13)XHS(4x4)HCZB(47x10)(13x13)HKZXATQZXPKJC(3x6)LFO(5x2)ZUTAK(4x8)JGZZ(13x1)BPKJSEMKXVWPD(10x8)CFBDPLWXUF(4x11)DYMH(283x14)(100x12)(9x14)LWMYUMEGI(79x7)(73x7)FBVHIBPTQYOPEWFQTFYYLGGOYUBRWFHKOXUWAZPIAVVVOWQGVUUKSSIGQWGTGTVMFEUSTYTQV(55x2)(10x14)IKRUCTQUXX(32x5)(20x2)JNEGAYZJAEFMMZNDQAYI(1x5)N(36x10)(12x10)PFTBHPEYKBFW(11x7)YRKUEULAVQO(65x9)(13x12)NKUIAGSIXWKEW(38x10)(4x8)IVPO(12x2)ENSUUWUGMFDE(6x5)GBZVEV(1x4)H(18x4)(12x6)(6x15)(1x6)C(1798x6)(725x7)(718x4)(128x9)(72x4)(41x6)XHDCTSCOLQXDITGBJPZCFXWLCBVNRWZKIHXOYRZQE(2x11)AL(10x11)CKPZHZXSEL(44x2)(38x2)(24x12)KQQVZKDYTAXJIECUHRNEEHIE(2x5)MR(2x14)EX(525x9)(135x3)(24x1)(6x4)AJAHVA(8x4)FCQQTUCX(42x9)(16x1)YJXDRMKLAJWGHRSL(9x8)CYVVQKOEQ(1x8)S(11x7)CGKRJUPVKDK(28x3)HQMZNCYOAIJBKRAGXYWTWOMEDSBE(1x4)U(16x13)UWNXBMZLSDWJWXRY(13x14)VALDTDWVJQQYY(48x4)(8x5)(3x2)HCC(28x13)(10x14)UFDCSYFEPI(5x11)NPDJR(279x1)(72x15)(15x11)CZESSYYLTNHNNEL(4x12)SCJE(2x4)IK(2x13)UO(19x8)AXUVJUCVOZYXECUHXTP(101x2)(7x3)MUNLZOM(5x7)GYXMB(13x2)UGNTFKQKQNSBU(27x9)IVJLAPCSRKKUBGNZXYELDTFXXDJ(20x12)KHMCDFDXECBLOWYPQFYZ(13x2)VDLMHMTQWHSIS(66x11)(6x14)RHRBCF(12x12)QBPGBNHZPQMS(28x11)BMIFCPCTBLKBIXCWFNLFSAOGHDWA(36x10)(30x1)KQYVYKBALRKIFSCOPWNQPYGRSSDAFY(1057x14)(320x8)(131x14)(124x3)(6x1)(1x8)Y(11x11)RYCMRYHAPAM(12x4)(7x2)LMPRCHR(65x7)(20x12)FBGHCCVXKKFXNJJWLKIU(16x10)KIYAZDBPNWXQXAKQ(9x11)EEQGTCDVB(1x3)I(132x2)(125x1)(20x12)HBEZQGFLJSFHGOYMLHSG(19x7)(3x5)THM(6x4)XKBKJV(7x12)(2x8)DF(14x12)(8x14)AXZPIRCT(33x9)(20x11)JCTTWVAOXNBCDBCUVNCX(1x9)J(36x9)(30x9)GCKYVYDUIBAWHSKBTTAHOYQWUQJHIV(699x2)(400x2)(45x10)(2x12)DY(31x7)(2x13)CP(6x11)TCMIXN(5x13)GBDVM(3x11)JAD(136x14)(11x1)ABIOQIJMVTI(6x10)NNTWTD(29x6)(1x14)Q(16x9)NNLMOVNFVJLXXLJJ(66x6)(4x3)RAZW(11x3)EQUJQECMCRI(10x14)DWLVSFXKGZ(5x15)RGJPT(7x1)RDFSOXE(74x8)(5x8)NEBHU(7x15)UEWKNIH(45x7)(19x3)TLAIFAYOOOCZMBIKVOU(4x6)OZBT(5x14)JEPAV(108x8)(2x15)LU(21x7)(3x6)JAV(2x3)LL(1x6)J(2x12)DX(59x6)(12x4)QXLWMASKAATM(10x7)OWRCRLMNRR(1x6)X(5x8)FBCAK(3x13)SIC(211x15)(2x6)IG(196x10)(54x8)(10x6)ZVIJHGXDTL(4x6)WCBN(2x12)IP(7x4)YLCWERN(4x1)LVRK(59x7)(5x5)JSDEV(4x14)FJFZ(17x7)KGBZBEJEIMCGUMSPZ(3x8)TAF(3x7)JTW(64x12)(2x11)BL(7x8)EQAGDIV(1x4)X(13x12)WDLMTJDUILHTJ(11x13)CBRRLLSHSWI(1x1)G(61x3)(3x7)CVG(27x9)(3x5)WIL(13x1)KFMXZGHEODGKB(2x1)QU(7x11)(1x13)S(18x5)VCSBJGLOOVXYTVMKOJ(143x10)(74x5)(25x12)IRMWONJTNGIJCGCTHVQOPQPIB(2x13)EY(6x8)NWOYXV(17x1)VBWAHETINYXRWMUVH(14x6)XEWNDODPNFJNFR(36x10)(5x1)XVRMW(3x15)PEE(4x9)RIJF(3x3)SYV(19x8)(12x13)(1x4)P(1x2)H(13x7)UKWAWHHQFYDWF(96x11)(5x12)PRKUK(13x14)RDQYSCYBCMONV(36x9)(3x15)ZOZ(8x15)PSPDGSWF(8x6)BMEGXZMZ(17x7)RQNGEXECJCUYFXPMB(163x14)(75x12)(9x9)YKFJTBRHE(44x15)DDSGHUAIXMRFTUHJZKDCTCLFREDDDHFAFQXALBIGIEMS(5x3)ZFRYZ(66x4)(7x8)KMXIZSU(34x15)ETTRETRSNLYOQZNWUXCNGPPUJPQNFYYEEC(7x12)RFTTNRF(3x12)HVO(97x15)(9x13)EASXOBURZ(14x14)EPODGHCXUDADRA(7x10)ECBRZCQ(22x13)SCAQGLZJTRSFEBTFFDTDRZ(13x7)RHQRORLJVNLWN(6x2)INZFFT"";

int main(void){
    int count = 0, total_len = 0;
    int chars = 0, times = 0;

    while(input[count] != '\0'){
        
        if(input[count] == '('){
            count++;
            
            
            while(input[count] != 'x'){
                chars = chars * 10 + (input[count] - '0'); 
                count++;
            }
                count++;

            
            while(input[count] != ')'){
                times = times * 10 + (input[count] - '0'); 
                count++;
            }

            total_len = total_len + (chars * times); 
            count = count + chars;  

            chars = 0; 
            times = 0;
        }
        else{
            total_len++;
        }

        count++;
    }

    printf(""answer=%d\n"", total_len);


    return EXIT_SUCCESS;
}
",20,652,14597
"#include""cliente.h""
#include ""notebook.h""




int hardCodearClientes(eCliente listadoClientes[], int tamanioClientes)
{
    int error = -1;
    int id[10] ={1,2,3,4,5,6,7,8,9,10};
    char nombres [10][20] = {""Juan"",""Carlos"",""Martin"",""Lucas"",""Daniel"",""Ana"",""Julia"",""Daniela"",""Maria"",""Pedro""};
    char sexos [10] = {'m','m','m','m','m','f','f','f','f','m'};

    if(listadoClientes != NULL && tamanioClientes>0)
    {
        for(int i = 0; i<tamanioClientes; i++)
        {
            listadoClientes[i].idCliente = id[i];
            strcpy(listadoClientes[i].nombre,nombres[i]);
            listadoClientes[i].sexo = sexos[i];

        }
        error = 0;
    }
    return error;
}

void mostrarCliente(eCliente unCliente)
{
    printf(""%d        %10s         %c\n"",unCliente.idCliente,unCliente.nombre,unCliente.sexo);
}

int listarClientes(eCliente listadoDeClientes[], int tamanio)
{
    int error = -1;

    if(listadoDeClientes !=NULL && tamanio>0)
    {
        system(""cls"");
        printf(""\n****  LISTADO DE CLIENTES  ****\n"");
        printf("" Id             Nombre           Sexo\n"");
        printf(""----------------------------------\n"");

        for(int i = 0 ; i<tamanio; i++)
        {
            listadoDeClientes[0].idCliente = 1;
            mostrarCliente(listadoDeClientes[i]);
        }
        error = 0;
    }
    return error;
}

int obtenerCliente(eCliente listaDeClientes[], int idCliente, int tamClientes, char nombreCliente [], char* sexoCliente)
{
    int error = -1;

    if(listaDeClientes != NULL && idCliente >0 && tamClientes >0 && nombreCliente != NULL)
    {
        for(int i = 0; i<tamClientes; i++)
        {
            if(idCliente == listaDeClientes[i].idCliente)
            {
                listaDeClientes[i].idCliente = idCliente;
                strcpy(nombreCliente,listaDeClientes[i].nombre);
                *sexoCliente = listaDeClientes[i].sexo;
                error = 0;
            }
        }
    }

    return error;
}

",21,653,728
"#include""servicio.h""
#include""utn.h""




int hardCodearServicios(eServicio listadoServicios[], int tamanioServicio)
{
    int error = -1;
    int idServicio [4]= {2000,2001,2002,2003};
    char servicio [4][25] = {""Bateria"",""Antivirus"",""Actualizacion"",""Fuente""};
    int precios[4] = {250,300,400,600};

    if(listadoServicios != NULL && tamanioServicio>0)
    {
        for(int i = 0; i<tamanioServicio; i++)
        {
            strcpy(listadoServicios[i].descripcion,servicio[i]);
            listadoServicios[i].precio = precios[i];
            listadoServicios[i].idServicio = idServicio[i];
        }
        error = 0;
    }
    return error;
}


void mostrarServicio(eServicio unServicio)
{
    printf(""%4d     %10s         %3d\n"",unServicio.idServicio,unServicio.descripcion,unServicio.precio);
}

int listarServicios(eServicio listaDeServicio[], int tamanioServicio)
{
    int error = -1;

    if(listaDeServicio !=NULL && tamanioServicio>0)
    {
        system(""cls"");
        printf(""\n****  LISTADO DE SERVICIOS  ****\n"");
        printf("" Id         Servicio        Precio\n"");
        printf(""----------------------------------\n"");

        for(int i = 0 ; i<tamanioServicio; i++)
        {
            mostrarServicio(listaDeServicio[i]);
        }
        error = 0;
    }
    return error;
}

int getIdServicio(eServicio servicios[],int tam_s)
{
    int auxId;
    listarServicios(servicios,tam_s);

    utn_getNumeroInt(&auxId,""Ingrese id"",""Error, ingrese id valido"",2000,2003,4);

    while(buscarServicios(servicios,tam_s,auxId) == -1)
    {
         utn_getNumeroInt(&auxId,""Ingrese un id valido"",""Error, ingrese id valido"",2000,2003,4);
    }

    return auxId;
}
int buscarServicios(eServicio servicios[],int tam_s,int idServicio)
{
    int indice=-1;

    for(int i=0;i<tam_s;i++)
    {
        if(servicios[i].idServicio ==idServicio)
        {
            indice=i;
            break;
        }
    }
        return indice;
}
",21,654,762
"#include""marca.h""




int hardcodearMarcas(eMarca listaDeMarcas[], int tamanioMarcas)
{
    int error = -1;
    int id [4] = { 1000,1001,1002,1003};
    char marcas [4][20]= {
        ""Compaq"",
        ""Asus"",
        ""Acer"",
        ""HP"",
    };

    for(int i = 0; i<tamanioMarcas;i++)
    {
        strcpy(listaDeMarcas[i].descripcion,marcas[i]);
        listaDeMarcas[i].idMarca = id[i];
    }


    return error;
}

void mostrarMarca(eMarca unaMarca)
{
    printf(""%4d  %10s \n"",unaMarca.idMarca,unaMarca.descripcion);
}

int listarMarcas(eMarca listaDeMarcas[], int tamanio)
{
    int error = -1;

    if(listaDeMarcas !=NULL && tamanio>0)
    {
        system(""cls"");
        printf(""\n****  LISTADO DE MARCAS  ****\n"");
        printf("" Id       Descripcion\n"");
        printf(""----------------------------------\n"");

        for(int i = 0 ; i<tamanio; i++)
        {
            mostrarMarca(listaDeMarcas[i]);
        }
        error = 0;
    }
    return error;
}
",21,655,409
"#include""tipo.h""




int hardCodearTipos(eTipo listadoDeTipos[], int tamanioTipos)
{
    int error = -1;
    int id [4] = {5000,5001,5002,5003};
    char colores [4][20]= {
        ""Gamer"",
        ""Disenio"",
        ""Ultrabook"",
        ""Normalita"",
    };

    for(int i = 0; i<tamanioTipos;i++)
    {
        strcpy(listadoDeTipos[i].descripcion,colores[i]);
        listadoDeTipos[i].idTipo = id[i];
    }


    return error;
}

void mostrarTipo(eTipo unTipo)
{
    printf("" %d         %s \n"",unTipo.idTipo,unTipo.descripcion);
}

int listarTipos(eTipo listaDetipos[], int tamanioTipos)
{
    int error = -1;

    if(listaDetipos !=NULL && tamanioTipos>0)
    {
        system(""cls"");
        printf("" ****  LISTADO DE TIPOS  ****\n"");
        printf(""Id        Descripcion\n"");
        printf(""----------------------------------\n"");

        for(int i = 0 ; i<tamanioTipos; i++)
        {
            mostrarTipo(listaDetipos[i]);
        }
        error = 0;
    }
    return error;
}
",21,656,418
"#include""marca.h""




int hardcodearMarcas(eMarca listaDeMarcas[], int tamanioMarcas)
{
    int error = -1;
    int id [4] = { 1000,1001,1002,1003};
    char marcas [4][20]= {
        ""Compaq"",
        ""Asus"",
        ""Acer"",
        ""HP"",
    };

    for(int i = 0; i<tamanioMarcas;i++)
    {
        strcpy(listaDeMarcas[i].descripcion,marcas[i]);
        listaDeMarcas[i].idMarca = id[i];
    }


    return error;
}

void mostrarMarca(eMarca unaMarca)
{
    printf(""%4d  %10s \n"",unaMarca.idMarca,unaMarca.descripcion);
}

int listarMarcas(eMarca listaDeMarcas[], int tamanio)
{
    int error = -1;

    if(listaDeMarcas !=NULL && tamanio>0)
    {
        system(""cls"");
        printf(""\n****  LISTADO DE MARCAS  ****\n"");
        printf("" Id       Descripcion\n"");
        printf(""----------------------------------\n"");

        for(int i = 0 ; i<tamanio; i++)
        {
            mostrarMarca(listaDeMarcas[i]);
        }
        error = 0;
    }
    return error;
}
",21,657,409
"#include ""notebook.h""
#include ""marca.h""
#include ""tipo.h""
#include ""servicio.h""
#include ""trabajo.h""

#define TAM_NOTEBOOKS 10
#define TAM_MARCAS 4
#define TAM_TIPOS 4
#define TAM_SERVICIOS 4
#define TAM_TRABAJOS 20
#define TAM_CLIENTES 10

char menu (char *opcionMenu);

int main()
{

    setbuf(stdout,NULL);

    eNotebook listaDeNotebooks[TAM_NOTEBOOKS];
    eMarca listadoDeMarcas[TAM_MARCAS];
    eTrabajo listadoDeTrabajos[TAM_TRABAJOS];
    eTipo listadoDeTipos[TAM_TIPOS];
    eServicio listadoDeServicios [TAM_SERVICIOS];
    eCliente listadoDeClientes [TAM_NOTEBOOKS];

    int proximoIdTrabajo = 100;
    int proximoIdNotebook = 1;
    int auxModificacion;
    int auxBaja;
    char opcionMenu;

    if(!inicializarNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !inicializarTrabajo(listadoDeTrabajos,TAM_TRABAJOS))
    {
        printf(""Sistema inicializado con exito!\n\n"");
    }else
    {
        printf(""Problema para inicializar el sistema\n"");
    }

    hardCodearTipos(listadoDeTipos,TAM_TIPOS);
    hardcodearMarcas(listadoDeMarcas,TAM_MARCAS);
    hardCodearServicios(listadoDeServicios,TAM_SERVICIOS);
    hardCodearClientes(listadoDeClientes,TAM_NOTEBOOKS);
    hardCodearTrabajos(listadoDeTrabajos,TAM_TRABAJOS);


    do
    {
        menu(&opcionMenu);

        switch(opcionMenu)
        {
            case 1:

                if(!altaNotebook(listaDeNotebooks,listadoDeClientes,listadoDeMarcas,listadoDeTipos,TAM_NOTEBOOKS,TAM_CLIENTES,proximoIdNotebook,TAM_TIPOS,TAM_MARCAS))
                {
                    proximoIdNotebook++;
                    printf(""ALTA EXITOSA!\n"");
                }
                else
                {
                    printf(""Problema para realizar el alta\n"");
                }

            break;
            case 2:
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {
                    auxModificacion = modificarNotebook(listaDeNotebooks,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_MARCAS,TAM_TIPOS);

                    if( auxModificacion == 0)
                    {
                        printf(""Modificacion exitosa\n"");
                    }
                    else if(auxModificacion == 2)
                    {
                        printf(""La modificacion ha sido cancelada por usuario\n"");
                    }
                    else
                    {
                        printf(""Se ha producido un error en la modificacion\n"");
                    }

                }else
                {
                    printf(""No hay notebooks en el listado\n"");
                }
            break;

            case 3 :
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {
                    auxBaja = bajaNotebook(listaDeNotebooks,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_TIPOS,TAM_MARCAS);

                    if( auxBaja == 0)
                    {
                        printf(""Modificacion exitosa\n"");
                    }
                    else if(auxBaja == 2)
                    {
                        printf(""La baja ha sido cancelada por usuario\n"");
                    }
                    else
                    {
                        printf(""Se ha producido un error en la baja\n"");
                    }

                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }

            break;

            case 4:
                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))
                {
                    ordenarNotebooks(listaDeNotebooks,TAM_NOTEBOOKS);
                    listarNotebook(listaDeNotebooks, listadoDeMarcas,listadoDeClientes,listadoDeTipos,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_MARCAS,TAM_TIPOS);


                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }

            break;

            case 5:
                system(""cls"");
                listarMarcas(listadoDeMarcas,TAM_MARCAS);
            break;

            case 6:
                system(""cls"");
                listarTipos(listadoDeTipos,TAM_TIPOS);

            break;

            case 7:
                system(""cls"");
                listarServicios(listadoDeServicios,TAM_SERVICIOS);
            break;

            case 8:
                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))
                {
                    if(altaTrabajo(listaDeNotebooks,listadoDeTrabajos,listadoDeServicios,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,
                            TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS,TAM_TIPOS,TAM_MARCAS,proximoIdTrabajo)==0)
                    {
                        proximoIdTrabajo++;
                        printf(""ALTA TRABAJO EXITOSA!\n"");
                    }else
                    {
                        printf(""Se produjo un error al ingresa el trabajo\n"");
                    }

                }else
                {
                    printf(""No hay notebooks en la lista, no se puede ingresar trabajo\n"");
                }

            break;

            case 9:
                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) &&
                    !verificarExistenciaTrabajo(listadoDeTrabajos,TAM_TRABAJOS))
                {
                    system(""cls"");
                    listarTrabajos(listadoDeTrabajos,listaDeNotebooks,listadoDeServicios,TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS);

                }else
                {
                    printf(""No se ingresaron trabajos o notebooks\n"");
                }

            break;

            case 10:
                system(""cls"");
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {

                    listarPorTipo(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeClientes,TAM_CLIENTES,TAM_MARCAS,listadoDeTipos,TAM_TIPOS);

                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }
            break;

            case 11:
                system(""cls"");
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {

                    listarPorMarca(listaDeNotebooks,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_MARCAS,TAM_TIPOS);

                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }
            break;

            case 12:
                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))
                {
                    contarNotebooksMarcaYTipo(listaDeNotebooks, TAM_NOTEBOOKS,listadoDeMarcas,TAM_MARCAS,listadoDeClientes, TAM_CLIENTES, listadoDeTipos, TAM_TIPOS);
                }
            break;

            case 13:
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {
                    system(""cls"");
                    listarNotebookXCadaMarca(listaDeNotebooks,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_TIPOS,TAM_MARCAS);

                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }

            break;

            case 14:
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {
                    system(""cls"");
                    marcaFavorita(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_MARCAS);
                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }

            break;

            case 15:
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {
                    system(""cls"");
                    notebookMasBarata(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_TIPOS,TAM_MARCAS);

                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }

            break;

            case 16:
                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))
                {
                    listarTrabajosXNotebook(listadoDeTrabajos,listaDeNotebooks,listadoDeClientes,listadoDeMarcas,listadoDeTipos,listadoDeServicios,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS,TAM_MARCAS,TAM_TIPOS);

                }
            break;
            case 17:
                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))
                {
                    mostrarSumaDeImportesXNotebook(listadoDeServicios, TAM_SERVICIOS, listadoDeTrabajos, listaDeNotebooks, TAM_NOTEBOOKS, listadoDeMarcas, listadoDeTipos, listadoDeClientes, TAM_CLIENTES, TAM_TIPOS, TAM_MARCAS, TAM_TRABAJOS);
                }else
                {
                    printf(""No hay notebooks o trabajos cargados\n"");
                }
            break;

        }

    }while(opcionMenu != 19);

    return 0;
}


",21,658,3123
"#include""marca.h""




int hardcodearMarcas(eMarca listaDeMarcas[], int tamanioMarcas)
{
    int error = -1;
    int id [4] = { 1000,1001,1002,1003};
    char marcas [4][20]= {
        ""Compaq"",
        ""Asus"",
        ""Acer"",
        ""HP"",
    };

    for(int i = 0; i<tamanioMarcas;i++)
    {
        strcpy(listaDeMarcas[i].descripcion,marcas[i]);
        listaDeMarcas[i].idMarca = id[i];
    }


    return error;
}

void mostrarMarca(eMarca unaMarca)
{
    printf(""%4d  %10s \n"",unaMarca.idMarca,unaMarca.descripcion);
}

int listarMarcas(eMarca listaDeMarcas[], int tamanio)
{
    int error = -1;

    if(listaDeMarcas !=NULL && tamanio>0)
    {
        system(""cls"");
        printf(""\n****  LISTADO DE MARCAS  ****\n"");
        printf("" Id       Descripcion\n"");
        printf(""----------------------------------\n"");

        for(int i = 0 ; i<tamanio; i++)
        {
            mostrarMarca(listaDeMarcas[i]);
        }
        error = 0;
    }
    return error;
}
",21,659,409
"#include ""utn.h""

int menu (int *opcionMenu)
{
    int error = -1;
    int opcion;
    if(opcionMenu != NULL)
    {
        

        printf(""*** ABM Service de Notebooks ***\n\n"");
        printf(""1  Alta Notebook\n"");
        printf(""2  Modificar Notebook\n"");
        printf(""3  Baja Notebook\n"");
        printf(""4  Listar Notebook\n"");
        printf(""5  Listar Marcas\n"");
        printf(""6  Listar Tipos\n"");
        printf(""7  Listar Servicios\n"");
        printf(""8  Alta Trabajo\n"");
        printf(""9  Listar Trabajos\n"");
        printf(""10 Listar x Tipo\n"");
        printf(""11 Listar x Marca\n"");
        printf(""12 Contar x Marca y Tipo\n"");
        printf(""13 Listar Notebooks separadas x cada Marca\n"");
        printf(""14 Mostrar Marcas mas elegidas \n"");
        printf(""15 Mostrar Notebooks mas baratas \n"");
        printf(""16 Listar trabajos por ID notebook\n"");
        printf(""17 Listar total a pagar por ID notebook\n"");
        printf(""18 Mostrar Notebooks por Servicio\n"");
        printf(""19 Mostrar servicio por fecha\n"");
        printf(""20 Salir\n"");

        if(!utn_getNumeroInt(&opcion,""\nIngrese la opcion deseada\n"",""Error, opcion invalida\n"",1,20, 4))
        {

            *opcionMenu = opcion;
        }
        error = 0;

    }
    return error;
}
",21,660,453
"#include""tipo.h""




int hardCodearTipos(eTipo listadoDeTipos[], int tamanioTipos)
{
    int error = -1;
    int id [4] = {5000,5001,5002,5003};
    char colores [4][20]= {
        ""Gamer"",
        ""Disenio"",
        ""Ultrabook"",
        ""Normalita"",
    };

    for(int i = 0; i<tamanioTipos;i++)
    {
        strcpy(listadoDeTipos[i].descripcion,colores[i]);
        listadoDeTipos[i].idTipo = id[i];
    }


    return error;
}

void mostrarTipo(eTipo unTipo)
{
    printf("" %d         %s \n"",unTipo.idTipo,unTipo.descripcion);
}

int listarTipos(eTipo listaDetipos[], int tamanioTipos)
{
    int error = -1;

    if(listaDetipos !=NULL && tamanioTipos>0)
    {
        system(""cls"");
        printf("" ****  LISTADO DE TIPOS  ****\n"");
        printf(""Id        Descripcion\n"");
        printf(""----------------------------------\n"");

        for(int i = 0 ; i<tamanioTipos; i++)
        {
            mostrarTipo(listaDetipos[i]);
        }
        error = 0;
    }
    return error;
}
",21,661,418
"#include ""notebook.h""
#include ""marca.h""
#include ""tipo.h""
#include ""servicio.h""
#include ""trabajo.h""
#include ""utn.h""
#include ""menu.h""

#define TAM_NOTEBOOKS 10
#define TAM_MARCAS 4
#define TAM_TIPOS 4
#define TAM_SERVICIOS 4
#define TAM_TRABAJOS 20
#define TAM_CLIENTES 10


int main()
{


    eNotebook listaDeNotebooks[TAM_NOTEBOOKS];
    eMarca listadoDeMarcas[TAM_MARCAS];
    eTrabajo listadoDeTrabajos[TAM_TRABAJOS];
    eTipo listadoDeTipos[TAM_TIPOS];
    eServicio listadoDeServicios [TAM_SERVICIOS];
    eCliente listadoDeClientes [TAM_CLIENTES];

    int proximoIdTrabajo = 100;
    int proximoIdNotebook = 1;
    int auxModificacion;
    int auxBaja;
    int opcionMenu;

    if(!inicializarNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !inicializarTrabajo(listadoDeTrabajos,TAM_TRABAJOS))
    {
        printf(""Sistema inicializado con exito!\n\n"");
    }else
    {
        printf(""Problema para inicializar el sistema\n"");
    }


    hardCodearTipos(listadoDeTipos,TAM_TIPOS);
    hardcodearMarcas(listadoDeMarcas,TAM_MARCAS);
    hardCodearServicios(listadoDeServicios,TAM_SERVICIOS);
    hardCodearClientes(listadoDeClientes,TAM_NOTEBOOKS);
    hardCodearTrabajos(listadoDeTrabajos,TAM_NOTEBOOKS);




    do
    {
        menu(&opcionMenu);

        switch(opcionMenu)
        {
            case 1:

                if(!altaNotebook(listaDeNotebooks,listadoDeClientes,listadoDeMarcas,listadoDeTipos,TAM_NOTEBOOKS,TAM_CLIENTES,proximoIdNotebook,TAM_TIPOS,TAM_MARCAS))
                {
                    proximoIdNotebook++;
                    printf(""ALTA EXITOSA!\n"");
                }
                else
                {
                    printf(""Problema para realizar el alta\n"");
                }

            break;
            case 2:
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {
                    auxModificacion = modificarNotebook(listaDeNotebooks,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_MARCAS,TAM_TIPOS);

                    if( auxModificacion == 0)
                    {
                        printf(""Modificacion exitosa\n"");
                    }
                    else if(auxModificacion == 2)
                    {
                        printf(""La modificacion ha sido cancelada por usuario\n"");
                    }
                    else
                    {
                        printf(""Se ha producido un error en la modificacion\n"");
                    }

                }else
                {
                    printf(""No hay notebooks en el listado\n"");
                }
            break;

            case 3 :
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {
                    auxBaja = bajaNotebook(listaDeNotebooks,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_TIPOS,TAM_MARCAS);

                    if( auxBaja == 0)
                    {
                        printf(""Modificacion exitosa\n"");
                    }
                    else if(auxBaja == 2)
                    {
                        printf(""La baja ha sido cancelada por usuario\n"");
                    }
                    else
                    {
                        printf(""Se ha producido un error en la baja\n"");
                    }

                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }

            break;

            case 4:
                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))
                {
                    ordenarNotebooks(listaDeNotebooks,TAM_NOTEBOOKS);
                    listarNotebook(listaDeNotebooks, listadoDeMarcas,listadoDeClientes,listadoDeTipos,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_MARCAS,TAM_TIPOS);


                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }

            break;

            case 5:
                system(""cls"");
                listarMarcas(listadoDeMarcas,TAM_MARCAS);
            break;

            case 6:
                system(""cls"");
                listarTipos(listadoDeTipos,TAM_TIPOS);

            break;

            case 7:
                system(""cls"");
                listarServicios(listadoDeServicios,TAM_SERVICIOS);
            break;

            case 8:
                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))
                {
                    if(altaTrabajo(listaDeNotebooks,listadoDeTrabajos,listadoDeServicios,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,
                            TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS,TAM_TIPOS,TAM_MARCAS,proximoIdTrabajo)==0)
                    {
                        proximoIdTrabajo++;
                        printf(""ALTA TRABAJO EXITOSA!\n"");
                    }else
                    {
                        printf(""Se produjo un error al ingresa el trabajo\n"");
                    }

                }else
                {
                    printf(""No hay notebooks en la lista, no se puede ingresar trabajo\n"");
                }

            break;

            case 9:
                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) &&
                    !verificarExistenciaTrabajo(listadoDeTrabajos,TAM_TRABAJOS))
                {
                    system(""cls"");
                    listarTrabajos(listadoDeTrabajos,listaDeNotebooks,listadoDeServicios,TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS);

                }else
                {
                    printf(""No se ingresaron trabajos o notebooks\n"");
                }

            break;

            case 10:
                system(""cls"");
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {

                    listarPorTipo(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeClientes,TAM_CLIENTES,TAM_MARCAS,listadoDeTipos,TAM_TIPOS);

                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }
            break;

            case 11:
                system(""cls"");
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {

                    listarPorMarca(listaDeNotebooks,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_MARCAS,TAM_TIPOS);

                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }
            break;

            case 12:
                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))
                {
                    contarNotebooksMarcaYTipo(listaDeNotebooks, TAM_NOTEBOOKS,listadoDeMarcas,TAM_MARCAS,listadoDeClientes, TAM_CLIENTES, listadoDeTipos, TAM_TIPOS);
                }
            break;

            case 13:
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {
                    system(""cls"");
                    listarNotebookXCadaMarca(listaDeNotebooks,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_TIPOS,TAM_MARCAS);

                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }

            break;

            case 14:
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {
                    system(""cls"");
                    marcaFavorita(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_MARCAS);
                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }

            break;

            case 15:
                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)
                {
                    system(""cls"");
                    notebookMasBarata(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_TIPOS,TAM_MARCAS);

                }else
                {
                    printf(""No hay notebooks en la lista\n"");
                }

            break;

            case 16:
                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))
                {
                    listarTrabajosXNotebook(listadoDeTrabajos,listaDeNotebooks,listadoDeClientes,listadoDeMarcas,listadoDeTipos,listadoDeServicios,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS,TAM_MARCAS,TAM_TIPOS);

                }
            break;
            case 17:
                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))
                {
                    mostrarSumaDeImportesXNotebook(listadoDeServicios, TAM_SERVICIOS, listadoDeTrabajos, listaDeNotebooks, TAM_NOTEBOOKS, listadoDeMarcas, listadoDeTipos, listadoDeClientes, TAM_CLIENTES, TAM_TIPOS, TAM_MARCAS, TAM_TRABAJOS);
                }else
                {
                    printf(""No hay notebooks o trabajos cargados\n"");
                }
            break;

            case 18:

                 if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))
                {
                    mostrarFechaYNotebookXServicio(listadoDeClientes,listadoDeTrabajos,TAM_TRABAJOS,listadoDeServicios,TAM_SERVICIOS,listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,TAM_MARCAS,listadoDeTipos,TAM_TIPOS,TAM_CLIENTES);

                }else
                {
                    printf(""No hay notebooks o trabajos cargados\n"");
                }

            break;

            case 19:

                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))
                {
                    mostrarServiciosXFecha(listadoDeTrabajos,TAM_TRABAJOS,listadoDeServicios,TAM_SERVICIOS);
                }else
                {
                    printf(""No hay notebooks o trabajos cargados\n"");
                }

            break;

        }

    }while(opcionMenu != 20);

    return 0;
}


",21,662,3474
"#include ""utn.h""

int menu (int *opcionMenu)
{
    int error = -1;
    int opcion;
    if(opcionMenu != NULL)
    {
        

        printf(""*** ABM Service de Notebooks ***\n\n"");
        printf(""1  Alta Notebook\n"");
        printf(""2  Modificar Notebook\n"");
        printf(""3  Baja Notebook\n"");
        printf(""4  Listar Notebook\n"");
        printf(""5  Listar Marcas\n"");
        printf(""6  Listar Tipos\n"");
        printf(""7  Listar Servicios\n"");
        printf(""8  Alta Trabajo\n"");
        printf(""9  Listar Trabajos\n"");
        printf(""10 Listar x Tipo\n"");
        printf(""11 Listar x Marca\n"");
        printf(""12 Contar x Marca y Tipo\n"");
        printf(""13 Listar Notebooks separadas x cada Marca\n"");
        printf(""14 Mostrar Marcas mas elegidas \n"");
        printf(""15 Mostrar Notebooks mas baratas \n"");
        printf(""16 Listar trabajos por ID notebook\n"");
        printf(""17 Listar total a pagar por ID notebook\n"");
        printf(""18 Mostrar Notebooks por Servicio\n"");
        printf(""19 Mostrar servicio por fecha\n"");
        printf(""20 Salir\n"");

        if(!utn_getNumeroInt(&opcion,""\nIngrese la opcion deseada\n"",""Error, opcion invalida\n"",1,20, 4))
        {

            *opcionMenu = opcion;
        }
        error = 0;

    }
    return error;
}
",21,663,453
"#include""tipo.h""




int hardCodearTipos(eTipo listadoDeTipos[], int tamanioTipos)
{
    int error = -1;
    int id [4] = {5000,5001,5002,5003};
    char colores [4][20]= {
        ""Gamer"",
        ""Disenio"",
        ""Ultrabook"",
        ""Normalita"",
    };

    for(int i = 0; i<tamanioTipos;i++)
    {
        strcpy(listadoDeTipos[i].descripcion,colores[i]);
        listadoDeTipos[i].idTipo = id[i];
    }


    return error;
}

void mostrarTipo(eTipo unTipo)
{
    printf("" %d         %s \n"",unTipo.idTipo,unTipo.descripcion);
}

int listarTipos(eTipo listaDetipos[], int tamanioTipos)
{
    int error = -1;

    if(listaDetipos !=NULL && tamanioTipos>0)
    {
        system(""cls"");
        printf("" ****  LISTADO DE TIPOS  ****\n"");
        printf(""Id        Descripcion\n"");
        printf(""----------------------------------\n"");

        for(int i = 0 ; i<tamanioTipos; i++)
        {
            mostrarTipo(listaDetipos[i]);
        }
        error = 0;
    }
    return error;
}
",21,664,418
"#include""servicio.h""
#include""utn.h""




int hardCodearServicios(eServicio listadoServicios[], int tamanioServicio)
{
    int error = -1;
    int idServicio [4]= {2000,2001,2002,2003};
    char servicio [4][25] = {""Bateria"",""Antivirus"",""Actualizacion"",""Fuente""};
    int precios[4] = {250,300,400,600};

    if(listadoServicios != NULL && tamanioServicio>0)
    {
        for(int i = 0; i<tamanioServicio; i++)
        {
            strcpy(listadoServicios[i].descripcion,servicio[i]);
            listadoServicios[i].precio = precios[i];
            listadoServicios[i].idServicio = idServicio[i];
        }
        error = 0;
    }
    return error;
}


void mostrarServicio(eServicio unServicio)
{
    printf(""%4d     %10s         %3d\n"",unServicio.idServicio,unServicio.descripcion,unServicio.precio);
}

int listarServicios(eServicio listaDeServicio[], int tamanioServicio)
{
    int error = -1;

    if(listaDeServicio !=NULL && tamanioServicio>0)
    {
        system(""cls"");
        printf(""\n****  LISTADO DE SERVICIOS  ****\n"");
        printf("" Id         Servicio        Precio\n"");
        printf(""----------------------------------\n"");

        for(int i = 0 ; i<tamanioServicio; i++)
        {
            mostrarServicio(listaDeServicio[i]);
        }
        error = 0;
    }
    return error;
}

int getIdServicio(eServicio servicios[],int tam_s)
{
    int auxId;
    listarServicios(servicios,tam_s);

    utn_getNumeroInt(&auxId,""Ingrese id"",""Error, ingrese id valido"",2000,2003,4);

    while(buscarServicios(servicios,tam_s,auxId) == -1)
    {
         utn_getNumeroInt(&auxId,""Ingrese un id valido"",""Error, ingrese id valido"",2000,2003,4);
    }

    return auxId;
}
int buscarServicios(eServicio servicios[],int tam_s,int idServicio)
{
    int indice=-1;

    for(int i=0;i<tam_s;i++)
    {
        if(servicios[i].idServicio ==idServicio)
        {
            indice=i;
            break;
        }
    }
        return indice;
}
",21,665,762
"#include ""binary_trees.h""



size_t binary_tree_nodes(const binary_tree_t *tree)
{
    size_t nodes;

    if (tree == NULL)
    {
        return (0);
    }

    nodes = 0;
    nodes = count_nodes(tree, nodes);

    return (nodes);
}



size_t count_nodes(const binary_tree_t *tree, size_t nodes)
{
    size_t left;
    size_t right;

    left = nodes;
    right = nodes;

    if (tree == NULL)
    {
        return (0);
    }

    if (tree->right != NULL || tree->right != NULL)
    {
        nodes = nodes + 1;
    }

    left = left + count_nodes(tree->left, left);
    right = right + count_nodes(tree->right, right);

    return (nodes + left + right);
}
",22,666,244
"#include ""binary_trees.h""



size_t binary_tree_height(const binary_tree_t *tree)
{
    size_t height;

    if (tree == NULL)
    {
        return (0);
    }

    height = 0;
    height =  calc_height(tree, height);
    return (height - 1);
}


size_t calc_height(const binary_tree_t *tree, size_t height)
{
    size_t left;
    size_t right;

    left = height;
    right = height;

    if (tree == NULL)
    {
        return (0);
    }

    left = left + calc_height(tree->left, height);
    right = right + calc_height(tree->right, height);

    if (right > left)
    {
        return (right + 1);
    }
    return (left + 1);
}
",22,667,236
"#include ""binary_trees.h""



size_t binary_tree_leaves(const binary_tree_t *tree)
{
    size_t leaves;

    if (tree == NULL)
    {
        return (0);
    }

    leaves = 0;
    leaves = count_leaves(tree, leaves);

    return (leaves);
}



size_t count_leaves(const binary_tree_t *tree, size_t leaves)
{
    size_t left;
    size_t right;

    left = leaves;
    right = leaves;

    if (tree == NULL)
    {
        return (0);
    }

    if (tree->left == NULL && tree->right == NULL)
    {
        return (1);
    }

    left = count_leaves(tree->left, leaves);
    right = count_leaves(tree->right, leaves);

    return (left + right);
}
",22,668,241
"#include ""sort.h""
int swap(listint_t **list, listint_t *current, int);


void cocktail_sort_list(listint_t **list)
{
    int flag;
    listint_t *tmp;

    flag = 0;
    if (list == NULL || *list == NULL || (*list)->next == NULL)
        return;
    tmp = *list;
    while (flag == 0)
    {
        flag = 1;
        while (tmp->next != NULL)
        {
            if (tmp->n > tmp->next->n)
                flag = swap(list, tmp, 0);
            else
                tmp = tmp->next;
        }
        tmp = tmp->prev;
        if (flag == 1)
            break;
        while (tmp->prev != NULL)
        {
            if (tmp->n < tmp->prev->n)
                flag = swap(list, tmp, 1);
            else
                tmp = tmp->prev;
        }
        if (flag == 1)
            break;
    }
}


int swap(listint_t **list, listint_t *current, int flag)
{
    listint_t *tmp;

    if (list == NULL || *list == NULL || current == NULL)
        return (1);

    if (flag == 1)
        current = current->prev;
    tmp = current->next;

    if (tmp != NULL)
    {
        current->next = tmp->next;
        tmp->next = current;
        tmp->prev = current->prev;
    }
    if (current->next != NULL)
        current->next->prev = current;
    if (current->prev != NULL)
        current->prev->next = tmp;
    current->prev = tmp;

    if (tmp->prev == NULL)
        *list = tmp;

    print_list(*list);
    return (0);
}
",22,669,478
"#include ""sort.h""

int partition(int *array, int lo, int hi, size_t size)
{
    int i, j, pivot, tmp;

    pivot = array[hi];
    i = lo - 1;
    j = hi + 1;
    while (1)
    {
        while (array[++i] < pivot)
        {
            ;
        }
        while (array[--j] > pivot)
        {
            ;
        }
        if (i > j)
            return (j);
        if (i != j)
        {
            tmp = array[i];
            array[i] = array[j];
            array[j] = tmp;
            print_array(array, size);
        }

    }
}

void quicksort_hoare(int *array, int lo, int hi, size_t size)
{
    int p;

    if (lo < hi)
    {
        p = partition(array, lo, hi, size);
        quicksort_hoare(array, lo, p, size);
        quicksort_hoare(array, p + 1, hi, size);
    }

}


void quick_sort_hoare(int *array, size_t size)
{
    if (array == NULL || size < 2)
        return;
    quicksort_hoare(array, 0, size - 1, size);
}
",22,670,350
"#include ""sort.h""



void selection_sort(int *array, size_t size)
{
    int min;
    size_t i;
    size_t j;
    size_t position;

    if (array == NULL)
        return;

    for (i = 0; i < size; i++)
    {
        min = array[i];
        position = i;

        for (j = i + 1; j < size; j++)
        {
            if (min > array[j])
            {
                position = j;
                min = array[j];
            }
        }
        if (position != i)
        {
            array[position] = array[i];
            array[i] = min;
            print_array(array, size);
        }
    }
}
",22,671,203
"#include ""sort.h""

void swap(int *array, int gap, int idx);



void shell_sort(int *array, size_t size)
{
    int limit;
    int idx;
    int gap;
    int up;

    if (size < 2)
        return;
    up = (int) size;
    for (gap = 1; gap < up / 3; gap = gap * 3 + 1)
    {}

    for (limit = 0; limit < up;)
    {
        idx = limit;

        while (idx < up)
        {
            if (idx + gap < up && array[idx] > array[idx + gap])
                swap(array, gap, idx);
            idx = idx + gap;
        }
        limit++;
        if (limit == gap)
        {
            gap = gap / 3;
            limit = 0;
            print_array(array, size);
        }
        if (gap < 1)
            break;
    }
}


void swap(int *array, int gap, int idx)
{
    int tmp;

    tmp = array[idx];
    array[idx] = array[idx + gap];
    array[idx + gap] = tmp;
    idx = idx - gap;
    while (idx >= 0)
    {
        if (array[idx] > array[idx + gap])
        {
            tmp = array[idx];
            array[idx] = array[idx + gap];
            array[idx + gap] = tmp;
        }

        idx = idx - gap;
    }
}
",22,672,400
"#include ""sort.h""


void insertion_sort_list(listint_t **list)
{
    listint_t *key;
    listint_t *tmp;

    if (list == NULL || *list == NULL || (*list)->next == NULL)
        return;
    key = (*list)->next;
    while (key != NULL)
    {
        if (key->next != NULL && key->next->n < key->n)
        {
            tmp = key->next;
            key->prev->next = tmp;
            if (tmp->next != NULL)
                tmp->next->prev = key;
            key->next = tmp->next;
            tmp->prev = key->prev;
            tmp->next = key;
            key->prev = tmp;
            print_list(*list);
        }
        else
        {
            tmp = key;
            key = key->next;
        }
        while (tmp->prev != NULL && tmp->n < tmp->prev->n)
        {
            tmp->prev->next = tmp->next;
            tmp->next = tmp->prev;
            if (tmp->prev->prev != NULL)
                tmp->prev->prev->next = tmp;
            tmp->prev = tmp->prev->prev;
            tmp->next->prev = tmp;
            if (tmp->next->next != NULL)
                tmp->next->next->prev = tmp->next;
            if (tmp->prev == NULL)
                *list = tmp;
            print_list(*list);
        }
    }
}
",22,673,372
"#include ""sort.h""
listint_t *swap(listint_t **current, listint_t **sorted);

void insertion_sort_list(listint_t **list)
{
    listint_t *current;
    listint_t *sorted;


    if (list == NULL || *list == NULL || (*list)->next == NULL)
        return;

    sorted = *list;
    current = (*list)->next;

    while (current != NULL)
    {
        if (sorted != NULL &&  current->n < sorted->n)
        {

            current = swap(&current, &sorted);
            sorted = current->prev;
            if (sorted == NULL)
                *list = current;
            print_list(*list);

            while (sorted != NULL && current->n < sorted->n)
            {
                current = swap(&current, &sorted);
                sorted = current->prev;
                if (sorted == NULL)
                    *list = current;
                print_list(*list);
            }
        }
        else
        {
            sorted = current;
            current = sorted->next;
        }
    }
}


listint_t *swap(listint_t **current, listint_t **sorted)
{
    listint_t *tmp;

    tmp = (*current)->next;
    if (*sorted != NULL)
        (*sorted)->next = tmp;
    if (tmp != NULL)
    {
        tmp->prev = *sorted;
    }
    if (*current != NULL)
        (*current)->next = *sorted;
        (*current)->prev = (*sorted)->prev;
    if ((*sorted)->prev != NULL)
        (*sorted)->prev->next = *current;
    ((*sorted)->prev) = *current;

    return (*current);
}
",22,674,441
"#include ""sort.h""


listint_t *create_listint(const int *array, size_t size)
{
    listint_t *list;
    listint_t *node;
    int *tmp;

    list = NULL;
    while (size--)
    {
        node = malloc(sizeof(*node));
        if (!node)
            return (NULL);
        tmp = (int *)&node->n;
        *tmp = array[size];
        node->next = list;
        node->prev = NULL;
        list = node;
        if (list->next)
            list->next->prev = list;
    }
    return (list);
}


int main(void)
{
    
    
    
    
    
    
    
    
    listint_t *list;
    int array[] = {17, 41, 5, 22, 28, 6, 5, 3, 5};
    size_t n = sizeof(array) / sizeof(array[0]);

    list = create_listint(array, n);
    if (!list)
        return (1);
    print_list(list);
    printf(""\n"");
    insertion_sort_list(&list);
    printf(""\n"");
    print_list(list);
    return (0);
}
",22,675,331
"#include ""binary_trees.h""



int binary_tree_is_full(const binary_tree_t *tree)
{

    if (tree == NULL)
    {
        return (0);
    }

    if (tree->left != NULL && tree->right == NULL)
    {
        return (0);
    }

    if (tree->left == NULL && tree->right != NULL)
    {
        return (0);
    }

    if (tree->left == NULL && tree->right == NULL)
    {
        return (1);
    }

    if (binary_tree_is_full(tree->left) == 0)
    {
        return (0);
    }

    if (binary_tree_is_full(tree->right) == 0)
    {
        return (0);
    }

    return (1);
}
",22,676,217
"int     ft_to_lower(char c, char d)
{
    if (c >= 'A' && c <= 'Z')
    {
        if (d != ' ' && d != '\t' && d != '\0')
            return (1);
    }
    return (0);
}
 
int     ft_to_upper(char c, char d)
{
    if (c >= 'a' && c <= 'z')
    {
        if (d == ' ' || d == '\t' || d == '\0')
            return (1);
    }
    return (0);
}
 
int     main(int ac, char **av)
{
    int i;
    int i2;
 
    i = 0;
    if (ac > 1)
    {
        while (i < ac)
        {
            i++;
            i2 = 0;
            while (av[i][i2] != '\0')
            {
                if (ft_to_upper(av[i][i2], av[i][i2 + 1]))
                    av[i][i2] -= 32;
                else if (ft_to_lower(av[i][i2], av[i][i2 + 1]))
                    av[i][i2] += 32;
                write(1, &av[i][i2], 1);
                i2++;
            }
            write(1, ""\n"", 1);
        }
    }
    else
        write(1, ""\n"", 1);
    return (0);
}
",23,677,386
"int     ft_len(int nb)
{
    int len;

    len = 1;
    if (nb < 0)
    {
        nb *= -1
        len++;
    }
    while (nb > 9)
    {
        nb /= 10;
        len++;
    }
    return (len);
}

int     ft_div(int nb)
{
    int div;
    div = 1;
    if (nb == 1)
        return (div);
    while (nb > 1)
    {
        div *= 10;
        nb--;
    }
    return (div);
}

char    *ft_itoa(int nbr)
{
    int     i;
    int     len;
    int     lne2;
    char    *res;

    len = ft_len(nbr);
    len2 = len;
    if (!(res = (char*)malloc(sizeof(char*) * (len + 1))))
        return (NULL);
    if (nbr == -2147483648)
        return (""-2147483648"");
    i = 0;
    if (nbr < 0)
    {
        nbr *= -1;
        len--;
        res[0] = '-';
        i++;
    }
    while (i < len2)
    {
        res[i++] = (((nbr / ft_div(len--)) % 10) + 48);
    }
    res[i] = '\0';
    return (res);
}
",23,678,408
"int     main(int argc, char **argv)
{
    int i = 1;
    int t[32] = {0};
    int j = 0;

    if (argc == 1)
    {
        write(1, ""options: abcdefghijklmnopqrstuvwxyz\n"", 36);
        return (0);
    }
    i = 1;
    while (i < argc)
    {
        j = 1;
        if (argv[i][0] == '-')
        {
            while (argv[i][j] && argv[i][j] >= 'a' && argv[i][j] <= 'z')
            {
                if (argv[i][j] == 'h')
                {
                    write(1, ""options: abcdefghijklmnopqrstuvwxyz\n"", 36);
                    return (0);
                }
                t['z' - argv[i][j] + 6] = 1;
                j++;
            }
            if (argv[i][j])
            {
                write(1, ""Invalid Option\n"", 15);
                return (0);
            }
            j++;
        }
        i++;
    }
    i = 0;
    while (i < 32)
    {
        t[i] = '0' + t[i];
        write(1, &t[i++], 1);
        if (i == 32)
            write(1, ""\n"", 1);
        else if (i % 8 == 0)
            write(1, "" "", 1);
    }
    return (0);
}
",23,679,419
"#include ""biggest_pal.h""

int     ft_strlen(char *str)
{
    int i = 0;
    while (str[i] != '\0')
        i++;
    return (i);
}

void        ft_putstr(char *str)
{
    int i = 0;
    while (str[i] != '\0')
    {
        write(1, &str[i], 1);
        i++;
    }
}

void        pal(char *str)
{
    t_pal   pal;
    t_pal   count;
    t_pal   old;
    int     i = 0;
    int     max;

    count.end = ft_strlen(str) - 1;
    max = count.end;
    while (str[i] != '\0')
    {
        count.length = 1;
        count.start = i;
        old.start = i;
        old.end = count.end;
        max = count.end;
        while (str[count.start] == str[count.end])
        {
            if (count.start == count.end || count.start + 1 == count.end)
            {
                if (old.end - old.start >= pal.length)
                {
                    pal.start = old.start;
                    pal.end = old.end + 1;
                    pal.length = old.end - old.start;
                }
                break ;
            }
            count.length++;
            count.start++;
            count.end--;
        }
        count.start = old.start;
        count.end = old.end;
        if (max == pal.length)
            break ;
        if (str[i + 1] == '\0' && count.end > 0)
        {
            count.end--;
            i = -1;
        }
        i++;
    }
    if (pal.length == 0)
    {
        ft_putstr(&str[ft_strlen(str) - 1]);
        return ;
    }
    str[pal.end] = '\0';
    ft_putstr(&str[pal.start]);
}

int         main(int ac, char **av)
{

    if (ac == 2)
    {
        pal(av[1]);
    }
    ft_putstr(""\n"");
    return (0);
}
",23,680,599
"int     ft_abs(int x)
{
    if (x < 0)
        return (x *  -1);
    return (x);
}
int     *ft_rrange(int start, int end)
{
    int     i;
    int     *tab;

    i = 0;
    if (!(tab = (int*)malloc(sizeof(int*) * (ft_abs(end - start) + 1))))
        return (NULL);
    if (end > start)
    {
        while (end >= start)
        tab[i++] = end--;
    }
    else if (end < start)
    {
        while (end <= start)
        tab[i++] = end++;
    }
    tab[i] = '\0';
    return (tab);
}
int     main ()
{
    int a;
    int *b;

    b = ft_rrange(0,-3);
    printf(""%d %d %d %d %d %d"",b[0],b[1],b[2],b[3],b[4],b[5]);
    
    return(0);
}
",23,681,279
"int     counter(char *src, int ctrl)
{
    int dir;
    int count;
    count = 0;

    if (src[ctrl] == '[')
        dir = 1;
    if (src[ctrl] == ']')
        dir = -1;
    while(src[ctrl])
    {
        if (src[ctrl] == '[')
            count++;
        if (src[ctrl] == ']')
            count--;
        if ((src[ctrl] == '[' || src[ctrl] == ']') && count == 0)
            return (ctrl);
        ctrl += dir;
    }
    return (0);
}

void    brainfuck(char *src)
{
    char    *str;
    int     pointer;
    int     ctrl;

    ctrl = 0;
    pointer = 0;
    str = (char*)malloc(sizeof(char) * 2048);
    while (src[ctrl])
    {
        if (src[ctrl] == '>')
            pointer++;
        else if (src[ctrl] == '<')
            pointer--;
        else if (src[ctrl] == '+')
            str[pointer]++;
        else if (src[ctrl] == '-')
            str[pointer]--;
        else if ((src[ctrl] == '[' && !str[pointer]) || (src[ctrl] == ']' && str[pointer]))
                ctrl = counter(src, ctrl);
        else if (src[ctrl] == '.')
            write(1, &str[pointer], 1);
        ctrl++;
    }
}
int     main(int argc, char **av)
{
    if (argc > 1)
        brainfuck(av[1]);
    else
        write(1, ""\n"", 1);
    return (0);
}
",23,682,458
"int     ft_toupper(char  a,char b)
{
    if ( a == ' ' || a == '\t')
    {
        if (b >= 'a' && b <= 'z')
            return (1);
    }
    return (0);
}

int     ft_tolower(char a, char b, int i)
{
    if (a != ' ' && a != '\t' && i != -1)
    {
        if (b >= 'A' && b <= 'Z')
            return (1);
    }
    return (0);
}

int     main(int ac, char **av)
{
    int i;
    int j;
    if (ac > 1)
    {
        i = 1;
        while (i < ac)
        {

            
            j = 0;
            while (av[i][j])
            {
                if (av[i][0] >= 'a' && av[i][0] <= 'z')
                    av[i][0] -= 32;
                else if (ft_tolower(av[i][j - 1], av[i][j], j - 1))
                    av[i][j] += 32;
                else if (ft_toupper(av[i][j - 1] , av[i][j]))
                    av[i][j] -= 32;
                write(1, &av[i][j], 1);
                j++;
            }
            i++;
            write(1, ""\n"", 1);
        }
    }
    else
        write(1, ""\n"",1);
    return (0);
}
",23,683,411
"#include ""header.h""

int is_in_range(t_m *m, int x, int y)
{
    if (x < 0 || x >= m->len || y < 1 || y >= m->ac)
        return (0);
    return (1);
}

int is_king(t_m *m, int x, int y)
{
    char    c;

    c = m->av[y][x];
    if (c == 'K')
        return (1);
    else
        return (0);
}

int is_enemy(t_m *m, int x, int y)
{
    char    c;

    c = m->av[y][x];
    if (c == 'P' || c == 'B' || c == 'R' || c == 'Q')
        return (1);
    else
        return (0);
}
",23,684,222
"int     toupperr(char a, char d)
{
    if (a >= 'a' && a <= 'z')
    {
        if (d  == ' ' || d == '\t' || d == '\0')
            return (1);
    }
    return(0);
}

int     tolowerr(char a, char d)
{
    if (a >= 'A' && a <= 'Z')
    {
        if (d != ' ' && d != '\t' && d != '\0')
        {
            return (1);
        }
    }
    return (0);
}

int     main(int ac,char **av)
{
    int     i;
    int     i2;

    i = 0;
    if (ac > 1)
    {
        while (i < ac)  
        {
            i++;
            i2 = 0;
            while (av[i][i2])
            {
                if (tolowerr(av[i][i2], av[i][i2 + 1]))
                    av[i][i2] += 32;
                else if (toupperr(av[i][i2] , av[i][i2 + 1]))
                    av[i][i2] -= 32;
                write(1, &av[i][i2], 1);
                i2++;
            }
            i++;
            write(1, ""\n"", 1);
        }
    }
    else
        write(1, ""\n"",1);
    return(0);
}
",23,685,386
"int     main(int ac, char **av)
{
    int     i;

    i = 0;
    if (ac == 2)
    {
        while (av[1][i] == ' ' || av[1][i] == '\t')
            i++;
        while (av[1][i])
        {
            if ((av[1][i] == ' ') || (av[1][i] == '\t'))
            {
                if (av[1][i + 1] > 32 && av[1][i + 1] != '\0')
                    write(1, ""   "", 3);
            }
            else if (av[1][i] != ' ' || av[1][i] != '\t')
                write(1, &av[1][i],1);
            i++;
        }
    }
    write(1, ""\n"", 1);
    return (0);
}
",23,686,226
"void    ft_putchar(char c)
{
    write(1, &c,1);
}

void    ft_putnbr(int nb)
{
    if (nb < 0)
        nb *= -1;
    if (nb > 9)
    {
        ft_putnbr(nb / 10);
        ft_putnbr(nb % 10);
    }
    else
        ft_putchar(nb + 48);
}

int     ft_atoi(char *str)
{
    int     i;
    int     sign;
    int     res;

    sign = -1;
    res = 0;
    if (str[0] == '-')
        sign *= -1;
    i = 0;
    while (str[i])
    {
        res = res * 10 + (str[i] - 48);
        i++;
    }
    return (res * sign);
}

int     main(int    ac,char **av)
{
    int     n;
    int     i;

    if (ac == 2)
    {
        n = ft_atoi(av[1]);
        i = 1;
        while (i <= 9)
        {
            ft_putnbr(i);
            write(1, "" x "", 3);
            ft_putnbr(n);
            write(1, "" = "", 3); 
            ft_putnbr(i * n);
            write(1, ""\n"", 1);
            i++;
        }
    }
    else
        write(1 , ""\n"", 1);
    return (0);
}
",23,687,418
"void    ft_putstr(char *str)
{
    int i;

    i = 0;
    while(str[i])
        write(1, &str[i++], 1);
}

char    **ft_split(char *str)
{
    int i;
    int i2;
    int i3;
    char **tab;

    i = 0;
    i2 = 0;
    tab = (char**)malloc(sizeof(char*) * 1000);
    while(str[i])
    {
        if (str[i] > 32)
        {
            i3 = 0;
            tab[i2] = (char*)malloc(sizeof(char*) * 1000);
            while (str[i] > 32)
                tab[i2][i3++] = str[i++];
            tab[i2++][i3] = '\0';
        }
        else
            i++;
    }
    tab[i2] = 0;
    return (tab);
}
int     main(int ac, char **av)
{
    int i;
    char    **word;

    i = 1;
    if(ac == 2)
    {
        word = ft_split(av[1]);
        while (word[i] != 0)
        {
            ft_putstr(word[i++]);
            write(1, "" "", 1);
        }
        ft_putstr(word[0]);
    }
    write(1, ""\n"",1);
    return (0);
}
",23,688,395
"int     main(int ac, char **av)
{
    int     i;

    i = 0;
    if (ac == 2)
    {
        while (av[1][i] == ' ' || av[1][i] == '\t')
            i++;
        while(av[1][i])
        {
            if (av[1][i] > 32)
                write(1, &av[1][i], 1);
            if (av[1][i] <= 32 && av[1][i + 1] > 32)
                write(1, "" "", 1);
            i++;
        }
    }
    write(1, ""\n"", 1);
    return (0);
}
",23,689,182
"void    ft_print_hex(unsigned char c)
{
    char *radix;
 
    radix = ""0123456789abcdef"";
    write(1, &radix[c / 16], 1);
    write(1, &radix[c % 16], 1);
}
 
void    ft_print_char(unsigned char c)
{
    if (c >= ' ' && c <= '~')
        write(1, &c, 1);
    else
        write(1, ""."", 1);
}
 
void    print_memory(const void *addr, size_t size)
{
    size_t i;
    size_t j;
    unsigned char *ptr;
 
    i = 0;
    j = 0;
    ptr = (unsigned char*)addr;
    while (i < size)
    {
        j = 0;
        while (j < 16 && i + j < size)
        {
            ft_print_hex(ptr[i + j]);
            if (j % 2)
                write(1, "" "", 1);
            j++;
        }
        while (j < 16)
        {
            write(1, ""  "", 2);
            if (j % 2)
                write(1, "" "", 1);
            j++;
        }
        j = 0;
        while (j < 16 && i + j < size)
        {
            ft_print_char(ptr[i + j]);
            j++;
        }
        write(1, ""\n"", 1);
        i += 16;
    }
}
",23,690,412
"void        ft_putchar(char c)
{
    write(1, &c, 1);
}

void        ft_putnbr(int nb)
{
    if (nb < 0)
        nb *= -1;
    if (nb > 9)
    {
        ft_putnbr(nb / 10);
        ft_putnbr(nb % 10);
    }
    else
        ft_putchar(nb + 48);
}

int     ft_atoi(char *str)
{
    int     i;
    int     res;

    i = 0;
    res = 0;
    while (str[i])
    {
        res *= 10;
        res = str[i] - 48;
        i++;
    }
    return (res);
}

int     ft_is_prime(int nb)
{
    int i;

    i = 2;
    while (i < nb)
    {
        if (nb % i == 0)
            return (0);
        i++;
    }
    return (1);
}

int     ft_add_prime_sum(int nb)
{
    int     i;
    int     sum;

    i = 2;
    sum = 0;
        if (nb <= 0)
            return (0);
    while (i <= nb)
    {
        if (ft_is_prime(i))
            sum += i;
        i++;
    }
    return (sum);
}

int     main(int ac, char **av)
{
    if (ac == 2)
        ft_putnbr(ft_add_prime_sum(ft_atoi(av[1])));
    else if (ac != 2 || ft_atoi(av[1]) < 0)
        write(1, ""0"", 1);
    write(1, ""\n"", 1);
    return (0);
}
",23,691,495
"int     ft_strlen(char *str)
{
    int     len;

    len = 0;
    while (str[len])
        len++;
    return (len);
}

int     is_piece(char p)
{
    return (p == 'P' || p == 'B' || p == 'R' || p == 'Q');
}

int     check_pawn(char **tab, int r, int c, int size)
{
    return (r - 1 >= 0
            && ((c - 1 >= 0 && tab[r - 1][c - 1] == 'K')
                || (c + 1 < size && tab[r - 1][c + 1] == 'K')));
}

int     check_bishop(char **tab, int row, int col, int size)
{
    int     r;
    int     c;

    r = row - 1;
    c = col - 1;
    while (r >= 0 && c >= 0 && !is_piece(tab[r][c]))
        if (tab[r--][c--] == 'K')
            return (1);
    r = row - 1;
    c = col + 1;
    while (r >= 0 && c < size && !is_piece(tab[r][c]))
        if (tab[r--][c++] == 'K')
            return (1);
    r = row + 1;
    c = col - 1;
    while (r < size && c >= 0 && !is_piece(tab[r][c]))
        if (tab[r++][c--] == 'K')
            return (1);
    r = row + 1;
    c = col + 1;
    while (r < size && c < size && !is_piece(tab[r][c]))
        if (tab[r++][c++] == 'K')
            return (1);
    return (0);
}

int     check_rook(char **tab, int row, int col, int size)
{
    int     r;
    int     c;

    r = row - 1;
    c = col;
    while (r >= 0 && !is_piece(tab[r][c]))
        if (tab[r--][c] == 'K')
            return (1);
    r = row;
    c = col + 1;
    while (c < size && !is_piece(tab[r][c]))
        if (tab[r][c++] == 'K')
            return (1);
    r = row + 1;
    c = col;
    while (r < size && !is_piece(tab[r][c]))
        if (tab[r++][c] == 'K')
            return (1);
    r = row;
    c = col - 1;
    while (c >= 0 && !is_piece(tab[r][c]))
        if (tab[r][c--] == 'K')
            return (1);
    return (0);
}

int     is_checkmate(char **tab, int size)
{
    int     r;
    int     c;

    r = 0;
    while (r < size)
    {
        c = 0;
        while (c < size)
        {
            if (tab[r][c] == 'P' && check_pawn(tab, r, c, size))
                return (1);
            else if (tab[r][c] == 'B' && check_bishop(tab, r, c, size))
                return (1);
            else if (tab[r][c] == 'R' && check_rook(tab, r, c, size))
                return (1);
            else if (tab[r][c] == 'Q' && (check_bishop(tab, r, c, size)
                        || check_rook(tab, r, c, size)))
                return (1);
            c++;
        }
        r++;
    }
    return (0);
}

int     main(int ac, char **av)
{
    if (ac < 2)
        return (write(1, ""\n"", 1));
    if (is_checkmate(av + 1, ac - 1))
        return (write(1, ""Success\n"", 8));
    else
        return (write(1, ""Fail\n"", 5));
}
",23,692,1097
"double e(int x,int n)
{
    static double p = 1, f = 1;
    double r;

    if(n == 0)
    {
        return 1;
    }
    r = e(x,n-1);
    p = p * x;
    f = f*n;
    return r + p/f;
}
double e1(int x,int n)
{
    static double s = 1;
    if(n == 0)
    {
        return s;
    }
    s = 1+s*x/n;
    return e1(x,n-1);
}
double ei(int x,int n)
{
    double s=1;
    int i;
    double num = 1;
    double den = 1;
    for(i = 1;i<=n;i++)
    {
        num*=x;
        den*=i;
        s+=num/den;
    }
    return s;
}

int main()
{
    printf(""%lf \n"",ei(4,10));
    return 0;
}",23,693,282
"#include ""header.h""

static int  ft_strlen(char *s)
{
    int i;

    i = 0;
    if (s != 0)
    {
        while (s[i])
        {
            ++i;
        }
    }
    return (i);
}

t_m         m_init(int ac, char **av)
{
    t_m m;

    m.debug = 1;
    m.ac = ac;
    m.av = av;
    m.len = ft_strlen(av[1]);
    m.enemy = 0;
    m.mate = 0;
    m.act_x = 0;
    m.act_y = 0;
    m.off_x = 0;
    m.off_y = 0;
    return (m);
}
",23,694,217
"int     matching(char b1, char b2)
{
    if (b1 == '(' && b2 == ')')
        return (1);
    if (b1 == '[' && b2 == ']')
        return (1);
    if (b1 == '{' && b2 == '}')
        return (1);
    return (0);
}

int     brackets(char   *str, char *store)
{
    int     ctrl;
    int     top;

    ctrl = 0;
    top = -1;
    while (str[ctrl])
    {
        if (str[ctrl] == '(' || str[ctrl] == '[' || str[ctrl] == '{')
        {
            top++;
            store[top] = str[ctrl];
        }
        if (str[ctrl] == ')' || str[ctrl] == ']' || str[ctrl] == '}')
        {
            if (!store[top])
                return(0);
            if (!matching(store[top],str[ctrl]))
                return (0);
            else
            {
                store[top] = 0;
                top--;
            }
        }
        ctrl++;
    }
    if (store[top] == 0)
        return(1);
    return (0);
}

int     main(int ac, char **av)
{
    char    store[500];

    if (ac > 1)
    {
        if (brackets(av[1],store))
            write(1, ""OK"",2);
        else
            write(1, ""Error"",5);
    }
    write(1,""\n"",1);
    return(0);
}
",23,695,419
"#include ""list.h""


int     cycle_detector(const t_list *list)
{
    const t_list *p;
    const t_list *q;

    p = list;
    q = list;
    while (p && q && q->next)
    {
        p = p->next;
        q = q->next->next;
        if (p == q)
            return (1);
    }
    return (0);
}
",23,696,116
"void sort_int_tab(int *tab, unsigned int size)
{
    int     i;
    int     tmp;

    i = 0;
    while (i < size)
    {
        if (tab[i] > tab[i + 1])
        {
            tmp = tab[i];
            tab[i] = tab[i + 1];
            tab[i + 1] = tmp;
            i = -1
        }
        i++;
    }
}
",23,697,120
"void    ft_putchar(char c)
{
    write(1, &c, 1);
}

void    ft_putnbr(int nb)
{
    if (nb < 0)
        nb *= -1;
    if (nb > 9)
    {
        ft_putnbr(nb / 10);
        ft_putnbr(nb % 10);
    }
    else
        ft_putchar(nb + 48);
}

void    ft_pgcd(int a, int b)
{
    int     cdn;
    int     i;

    i = 1;
    cdn = 0;
    while (i < a && i < b)
    {
        if (a % i == 0 && b % i == 0)
            cdn = i;
        i++;
    }
    ft_putnbr(cdn);
}

int     main(int ac, char **av)
{
    if (ac == 3)
    {
        ft_pgcd(atoi(av[1]), atoi(av[2]));
    
    }
    write(1, ""\n"", 1);
    return (0);
}
",23,698,301
"int     ft_to_lower(char c, char d, int i)
{
    if (c != ' ' && c != '\t' && i != -1)
    {
        if (d >= 'A' && d <= 'Z')
            return (1);
    }
    return (0);
}
 
int     ft_to_upper(char c, char d)
{
    if (c == ' ' || c == '\t')
    {
        if (d >= 'a' && d <= 'z')
            return (1);
    }
    return (0);
}
 
int     main(int ac, char **av)
{
    int i;
    int i2;
 
    i = 0;
    if (ac > 1)
    {
        while (i < ac)
        {
            i++;
            i2 = 0;
            while (av[i][i2] != '\0')
            {
                if (av[i][0] >= 'a' && av[i][0] <= 'z')
                    av[i][0] -= 32;
                else if (ft_to_lower(av[i][i2 - 1], av[i][i2], i2 - 1))
                    av[i][i2] += 32;
                else if (ft_to_upper(av[i][i2 - 1], av[i][i2]))
                    av[i][i2] -= 32;
                write(1, &av[i][i2], 1);
                i2++;
            }
            write(1, ""\n"", 1);
        }
    }
    else
        write(1, ""\n"", 1);
    return (0);
}
",23,699,429
"int fib(int n)
{
    int t0=0,t1=1,s=0,i;

    if(n<=1)return n;
    for(i = 2;i<=n;i++)
    {
        s=t0 + t1;
        t0 = t1;
        t1 = s;
    }
    return s;
}

int rfib(int n)
{
    if(n <=1)return n;
    return rfib(n-2) + rfib(n - 1);
}

int F[10];
int mfib(int n)
{
     if (n <= 1)
     {
         F[n] = n;
         return n;
     }
     else
     {
         if (F[n - 2] == -1)
         {
             F[n - 2] = mfib(n - 2);
         }
         if (F[n - 1] == -1)
         {
             F[n - 1] = mfib(n - 1);
         }
         F[n] = F[n - 2] + F[n - 1];
         return F[n - 2] + F[n - 1];
     }
}
     int main()
     {
         int i;
         for ( i = 0; i < 10; i++)
         {
             F[i] =-1;
         }
         printf(""%d \n"",mfib(5));
         return 0;
     }
",23,700,387
"t_list  *sort_list(t_list* lst, int (*cmp)(int, int))
{
    int swap;
    t_list  *tmp;

    tmp = lst;
    while (lst->next)
    {
        if (((*cmp)(lst->data,lst->next->data))==0)
        {
            swap = lst->data;
            lst->data = lst->next->data;
            lst->next->data = swap;
            lst = tmp;
        }
        else
            lst->lst->next;
    }
    lst= tmp;
    return (lst);
}
",23,701,149
"int     operation(int a, int b, char op)
{
    if (op == '+')
        return (a + b);
    if (op == '-')
        return (a - b);
    if (op == '*')
        return (a * b);
    if (op == '/')
    {
        if (b == 0)
            return (99);
        return (a / b);
    }
    if (op == '%')
    {
        if (b == 0)
            return (99);
        return (a % b);
    }
    return (99);
}

int     isop(char   op)
{
    if (op == '+' || op == '-' || op == '/' || op == '%' || op == '*')
        return (1);
    return(0);
}

int     isnum(char *str)
{
    int ctrl;
    ctrl = 0;
    if (str[ctrl] == '+' || str[ctrl] == '-')
        ctrl++;
    if (str[ctrl] >= 0 && str[ctrl] <= 9)
        return (1);
    return (0);
}

int     rpn_calc(char *str, int *stack)
{
    int     ctrl;
    int     top;

    top = -1;
    ctrl = 0;
    while(str[ctrl])
    {
        if(isnum(str))
        {
            top++;
            stack[top] = atoi(&str[ctrl]);
            while (str[ctr] != ' ' && str[ctrl] != '\0')
                ctrl++;
        }
        if (isop(str[ctrl]))
        {
            if (top > 0)
            {
                if(stack[top - 1] = operate(stack[top - 1],stack[top],str[ctrl]) == 99)
                    write(1, ""Error\n"",6);
                top--;
            }
            else
                write(1,""Error\n"",6);
        }
        ctrl++;
    }
    if(top == 0)
        printf(""%d\n"",stack[top]);
    else
        write(1,""Error\n"",6);
    return(0);
}
int     main(int ac, char **av)
{
    int stack[512];

    if (ac == 2)
        rpn_calc(av[1], stack);
    else
        write(1, ""Error\n"", 6);
    return (0);
}
",23,702,632
"#include ""header.h""

static void p(t_m *m, int x, int y)
{
    int att_x;
    int att_y;

    att_x = x - 1;
    att_y = y - 1;
    if (is_in_range(m, att_x, att_y) && is_king(m, att_x, att_y))
        m->mate = 1;
    att_x = x + 1;
    att_y = y - 1;
    if (is_in_range(m, att_x, att_y) && is_king(m, att_x, att_y))
        m->mate = 1;
}

static void recursive_check(t_m *m, int x, int y)
{
    if (is_in_range(m, x, y))
    {
        if (is_king(m, x, y))
            m->mate = 1;
        else if (!is_enemy(m, x, y))
            recursive_check(m, x + m->off_x, y + m->off_y);
    }
}

static void special_check(t_m *m, int x, int y)
{
    m->off_x = x;
    m->off_y = y;
    recursive_check(m, m->act_x + x, m->act_y + y);
}

void        check_enemy(t_m *m, int x, int y)
{
    m->act_x = x;
    m->act_y = y;
    if (m->enemy == 'P')
        p(m, x, y);
    if (m->enemy == 'B' || m->enemy == 'Q')
    {
        special_check(m, -1, -1);
        special_check(m, 1, -1);
        special_check(m, 1, 1);
        special_check(m, -1, 1);
    }
    if (m->enemy == 'R' || m->enemy == 'Q')
    {
        special_check(m, 0, -1);
        special_check(m, 1, 0);
        special_check(m, 0, 1);
        special_check(m, -1, 0);
    }
}
",23,703,587
"void    ft_putchar(char c)
{
    write(1, &c, 1);
}

int     ft_atoi(char *str)
{
    int     i;
    int     sign;
    int     res;

    res = 0;
    sign = 1;
    if (str[0] == '-')
        sign = -1;
    i = 0;
    while (str[i])
    {
        res = res * 10 + str[i] - 48;
        i++;
    }
    return (res * sign);
}

void    ft_print_hex(int nb)
{
    if (nb > 16)
    {
        ft_print_hex(nb / 16);
        ft_print_hex(nb % 16);
    }
    if (nb < 10)
        ft_putchar(nb + 48);
    else if (nb < 16)
        ft_putchar(nb + 87);
}

int     main(int ac, char **av)
{
    if (ac == 2)
    {
        ft_print_hex(ft_atoi(av[1]));
    }
    write(1, ""\n"", 1);
    return (0);
}
",23,704,324
"int     main(int ac, char **av)
{
    int     i;
    int     j;
    int     count;

    count = 0;
    i = 0;
    j = 0;
    if (ac == 3)
    {
        while (av[1][i] != '\0')
        {
            while (av[2][j] != '\0')
            {
                if (av[1][i] == av[2][j])
                {
                    count++;
                    break;
                }
                j++;
            }
            i++;
        }
        if (av[1][count] == '\0')
            write(1, ""1"", 1);
        else
            write(1, ""0"", 1);
    }
    write(1, ""\n"", 1);
    return (0);
}
",23,705,211
"#define MAX 10


void display(int array[MAX], int length);
void sorting(int array[MAX], int length);


void main()
{
    int i = 0;
    int size = 0;
    
    printf(""\nEnter number of elements: \n"");
    scanf(""%d"", &size);
    int input_array[size];

    printf(""\nEnter the array elements...\n"");
    for(i=0; i<size; i++)
        scanf(""%d"", &input_array[i]);

    
    printf(""\nOriginal Array is as follows:- \n"");
    display(input_array, size);

    
    printf(""\nArray after Sorting is as follows:- \n"");
    sorting(input_array, size);
}


void display(int array[MAX], int length)
{
    int i = 0;
    for(i=0; i<length; i++)
        printf(""%d\t"", array[i]);
}


void sorting(int array[MAX], int length)
{
    int i, j, temp = 0;
    int size = length;
    
    for(i=0; i<length; i++)
    {
        for(j=i+1; j<length; j++)
        {
            
            if(array[i] > array[j])
            {
                temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }
    }

    
    display(array, size);
}",24,706,383
"const int R = 3;
const int C = 3;


void display(int matrix[R][C]);
int check_Identity_Matrix(int matrix[R][C]);

void main()
{
    int i, j, k, temp, sum = 0;
    int rows = R;
    int columns = C;
    int input_matrix[R][C];
    int transposed_matrix[R][C];
    int product_matrix[R][C];
    

    printf(""\nEnter the matrix elements...\n"");
    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            scanf(""%d"", &input_matrix[i][j]);
        }
    }

    
    printf(""\nOriginal Matrix is as follows:- \n"");
    display(input_matrix);

    
    temp = rows;
    rows = columns;
    columns = rows;

    
    for(i=0; i<rows; i++)
    {
        for(j=0; j<columns; j++)
        {   
            transposed_matrix[i][j] = input_matrix[j][i];
        }
    }

    
    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            for(k=0; k<R; k++)
            {
                sum += input_matrix[i][k] * transposed_matrix[k][j];
            }
            product_matrix[i][j] = sum;
            sum = 0;
        }
    }

    
    if(check_Identity_Matrix(product_matrix) == 0)
        printf(""\nInput Matrix is orthogonal...\n"");
    else
        printf(""\nInput Matrix is NOT orthogonal...\n"");
}


void display(int matrix[R][C])
{
    int i, j = 0;

    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            printf(""%d\t"", matrix[i][j]);
        }
        printf(""\n"");
    }
}


int check_Identity_Matrix(int matrix[R][C])
{
    int i, j, flag, output = 0;
    int rows = R;
    int columns = C;

    for(i=0; i<rows; i++)
    {
        for(j=0; j<columns; j++)
        {
            
            if((i==j) && (matrix[i][j]==1))
                continue;

            else if((i!=j) && (matrix[i][j]==0))
                continue;
            
            else
            {
                flag = 1;
                break;
            }
        }

        
        if(flag == 1)
        {
            output = 1;
            break;
        }
    }

    
    return output;
}",24,707,741
"int isPerfect(int number);

void main()
{
    int lower = 0;
    int upper = 0;
    int i = 0;

    printf(""\nEnter lower bound: "");
    scanf(""%d"", &lower);
    printf(""\nEnter upper bound: "");
    scanf(""%d"", &upper);

    
    printf(""\nPerfect Numbers within %d and %d are as follows:- \n"", lower, upper); 
    for(i=lower; i<=upper; i++)
    {
        if(isPerfect(i) == 1)
            printf(""%d\t"", i);
    }
    printf(""\n"");
}


int isPerfect(int number)
{
    int i = 0;
    int sum_factors = 0;

    for(i=1; i<number; i++)
    {
        if(number%i == 0)
            sum_factors += i;
    }

    if(sum_factors == number)
        return 1;

    return 0;
}",24,708,262
"#define MAX 10


void display(int array[MAX], int length);
void sorting(int array[MAX], int length);


void main()
{
    int i = 0;
    int size = 0;
    
    printf(""\nEnter number of elements: \n"");
    scanf(""%d"", &size);
    int input_array[size];

    printf(""\nEnter the array elements...\n"");
    for(i=0; i<size; i++)
        scanf(""%d"", &input_array[i]);

    
    printf(""\nOriginal Array is as follows:- \n"");
    display(input_array, size);

    
    printf(""\nArray after Sorting is as follows:- \n"");
    sorting(input_array, size);
}


void display(int array[MAX], int length)
{
    int i = 0;
    for(i=0; i<length; i++)
        printf(""%d\t"", array[i]);

    printf(""\n"");
}


void sorting(int array[MAX], int length)
{
    int i, j, temp = 0;
    int size = length;
    
    for(i=0; i<length; i++)
    {
        for(j=i+1; j<length; j++)
        {
            
            if(array[i] < array[j])
            {
                temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }
    }

    
    display(array, size);
}",24,709,390
"#define MAX_WEIGHT 20
#define MAX_ARR_SIZE 3


struct Object
{
    char *name;
    float profit;
    float weight;
    float pw_ratio;
};


void sort_decreasing(struct Object arr[]);


void main()
{
    int i, j, k = 0;
    int remaining_weight = MAX_WEIGHT;  
    double total_profit = 0.0;

    
    struct Object obj[MAX_ARR_SIZE];

    
    obj[0].name = ""Object1"";
    obj[1].name = ""Object2"";
    obj[2].name = ""Object3"";

    
    for(i=0; i<MAX_ARR_SIZE; i++)
    {
        printf(""\nEnter PROFIT%d: "", (i+1));
        scanf(""%f"", &obj[i].profit);
        printf(""\nEnter WEIGHT%d: "", (i+1));
        scanf(""%f"", &obj[i].weight);
    }

    
    for(j=0; j<MAX_ARR_SIZE; j++)
        obj[j].pw_ratio = (obj[j].profit / obj[j].weight);
    
    
    printf(""\nObject Details:- \n"");
    for(k=0; k<MAX_ARR_SIZE; k++)
    {
        printf(""\n------------------------------"");
        printf(""\nNAME: %s"", obj[k].name);
        printf(""\nPROFIT: %f"", obj[k].profit);
        printf(""\nWEIGHT: %f"", obj[k].weight);
        printf(""\nProfit/Weight Ratio: %f"", obj[k].pw_ratio);
    }
    printf(""\n"");

    
    sort_decreasing(obj);

    
    printf(""\nObjects after Sorting:- \n"");
    for(i=0; i<MAX_ARR_SIZE; i++)
    {
        printf(""\n------------------------------"");
        printf(""\nNAME: %s"", obj[i].name);
        printf(""\nPROFIT: %f"", obj[i].profit);
        printf(""\nWEIGHT: %f"", obj[i].weight);
        printf(""\nProfit/Weight Ratio: %f"", obj[i].pw_ratio);
    }
    printf(""\n"");

    
    for(i=0; i<MAX_ARR_SIZE; i++)
    {
        if((remaining_weight>0) && (obj[i].weight<=remaining_weight))
        {
            remaining_weight = remaining_weight - obj[i].weight;
            total_profit = total_profit + obj[i].profit;
            printf(""\nObject with profit %f and weight %f is selected..."", obj[i].profit, obj[i].weight);
            printf(""\nRemaining Capacity in the KnapSack: %d"", (remaining_weight));
            printf(""\nTotal Profit upto now: %f"", total_profit);
        }
        else if(remaining_weight > 0)
        {
            total_profit = total_profit + ((obj[i].profit * remaining_weight) / obj[i].weight);
            printf(""\nObject with profit %f and weight %f is selected..."", obj[i].profit, obj[i].weight);
            printf(""\nRemaining Capacity in the KnapSack: %d"", (remaining_weight));
            printf(""\nTotal Profit upto now: %f"", total_profit);
            break;
        }   
    }

    printf(""\n\nTotal Profit of Knapsack: %f\n"", total_profit); 
}


void sort_decreasing(struct Object arr[])
{
    int i, j = 0;
    float temp = 0;
    char *temp1;

    for(i=0; i<MAX_ARR_SIZE; i++)
    {
        for(j=i+1; j<MAX_ARR_SIZE; j++)
        {
            if(arr[i].pw_ratio < arr[j].pw_ratio)
            {
                
                
                temp = arr[j].pw_ratio;
                arr[j].pw_ratio = arr[i].pw_ratio;
                arr[i].pw_ratio = temp;

                
                temp1 = arr[j].name;
                arr[j].name = arr[i].name;
                arr[i].name = temp1;

                
                temp = arr[j].profit;
                arr[j].profit = arr[i].profit;
                arr[i].profit = temp;

                
                temp = arr[j].weight;
                arr[j].weight = arr[i].weight;
                arr[i].weight = temp;
            }
        }
    }
}


",24,710,1218
"int isPerfect(int number);

void main()
{
    int number = 0;

    printf(""\nEnter any number: "");
    scanf(""%d"", &number);

    if(isPerfect(number) == 1)
        printf(""%d is a Perfect Number\n"", number);

    else
        printf(""%d is NOT a Perfect Number\n"", number);
}


int isPerfect(int number)
{
    int i = 0;
    int sum_factors = 0;

    for(i=1; i<number; i++)
    {
        if(number%i == 0)
            sum_factors += i;
    }

    if(sum_factors == number)
        return 1;

    return 0;
}",24,711,196
"int isPalindrome(int number);

void main()
{
    int n;
    printf(""Enter any number:\n"");
    scanf(""%d"", &n);
    
    if(isPalindrome(n) == 1)
        printf(""%d is a Palindrome...\n"", n);
        
    else
        printf(""%d is NOT a Palindrome...\n"", n);
}

int isPalindrome(int number)
{
    int copy=number;
    int sum=0;
    
    while(copy != 0)
    {
        sum = sum*10 + (copy%10);
        copy /= 10;
    }
    
    if(sum == number)
        return 1;
    else
        return 0;
}
",24,712,194
"int isPrime(int number);

void main()
{
    int lower = 0;
    int upper = 0;
    int count = 0;
    int i, j = 0;

    printf(""\nEnter the lower bound: "");
    scanf(""%d"", &lower);
    printf(""\nEnter the upper bound: "");
    scanf(""%d"", &upper);

    
    printf(""\nPrime Numbers within %d and %d are as follows:- \n"", lower, upper);
    for(i=lower; i<=upper; i++)
    {
        if(isPrime(i) == 1)
            printf(""%d\t"", i);
        else
            continue;
    }
    printf(""\n"");
}


int isPrime(int number)
{
    int i, count = 0;
    int flag = 0;

    for(i=1; i<=number; i++)
    {
        if(number%i == 0)
            count++;
    }

    if(count == 2)
        flag = 1;

    return flag;
}",24,713,272
"const int R = 3;
const int C = 3;


void find_Sum_Of_Rows(int matrix[R][C]);
void find_Sum_Of_Columns(int matrix[R][C]);
void display(int matrix[R][C]);

void main()
{
    int i, j = 0;
    int input_matrix[R][C];

    printf(""\nEnter the matrix elements...\n"");
    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            scanf(""%d"", &input_matrix[i][j]);
        }
    }

    
    printf(""\nInput Matrix is as follows:- \n"");
    display(input_matrix);

    
    find_Sum_Of_Rows(input_matrix);

    
    find_Sum_Of_Columns(input_matrix);
}


void find_Sum_Of_Rows(int matrix[R][C])
{
    int i, j, row_sum = 0;
    int rows = R;
    int columns = C;

    for(i=0; i<rows; i++)
    {
        row_sum = 0;
        for(j=0; j<columns; j++)
        {
            row_sum += matrix[i][j];
        }
        printf(""\nSum of Row %d: %d"", i, row_sum);
    }
}


void find_Sum_Of_Columns(int matrix[R][C])
{
    int i, j, col_sum = 0;
    int rows = R;
    int columns = C;
    int temp = 0;
    int output_matrix[R][C];

    
    temp = rows;
    rows = columns;
    columns = temp;

    
    for(i=0; i<rows; i++)
    {
        for(j=0; j<columns; j++)
        {   
            output_matrix[i][j] = matrix[j][i];
        }
    }

    
    for(i=0; i<rows; i++)
    {
        col_sum = 0;
        for(j=0; j<columns; j++)
        {
            col_sum += output_matrix[i][j];
        }
        printf(""\nSum of Column %d: %d\n"", i, col_sum);
    }
}


void display(int matrix[R][C])
{
    int i, j = 0;
    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            printf(""%d\t"", matrix[i][j]);
        }
        printf(""\n"");
    }
}",24,714,681
"#define MAX 10


void display(int array[MAX], int length);
void selection_sort(int array[MAX], int length);

void main()
{
    int i = 0;
    int size = 0;
    
    printf(""\nEnter number of elements: \n"");
    scanf(""%d"", &size);
    int input_array[size];

    printf(""\nEnter the array elements...\n"");
    for(i=0; i<size; i++)
        scanf(""%d"", &input_array[i]);

    
    printf(""\nOriginal Array is as follows:- \n"");
    display(input_array, size);

    
    selection_sort(input_array, size);

    
    printf(""\nAfter Selection Sorting:- \n"");
    display(input_array, size);
    printf(""\n"");
}


void display(int array[MAX], int length)
{
    int i = 0;
    for(i=0; i<length; i++)
        printf(""%d\t"", array[i]);

    printf(""\n"");
}


void selection_sort(int array[MAX], int length)
{
    int i, j, temp, pointer = 0;
    int size = length;

    for(i=0; i<size-1; i++)
    {
        
        pointer = i;
        for(j=i+1; j<size; j++)
        {
            
            if(array[pointer] > array[j])
            {
                
                pointer = j;
            }

            if(pointer != i)
            {
                
                temp = array[pointer];
                array[pointer] = array[i];
                array[i] = temp;
            }
        }
    }
}",24,715,436
"void main()
{
    int number = 0;
    int count = 0;
    int copy = 0;
    int second_copy = 0;
    int sum = 0;

    printf(""\nEnter any number: "");
    scanf(""%d"", &number);

    copy = number;
    second_copy = copy;
    while(copy != 0)
    {
        count++;
        copy /= 10;
    }

    
    while(second_copy != 0)
    {
        sum += pow((second_copy%10), count);
        second_copy /= 10;
    }

    if(sum == number)
        printf(""\n%d is an Armstrong Number\n"", number);

    else
        printf(""\n%d is NOT an Armstrong Number\n"", number);

}",24,716,208
"int isSparse(int arr[10][10], int rows, int cols);

void main()
{
    int arr[10][10];
    int rows=0;
    int columns=0;
    int i=0;
    int j=0;
    
    printf(""Enter number of rows: \n"");
    scanf(""%d"", &rows);
    printf(""Enter number of columns: \n"");
    scanf(""%d"", &columns);
    
    printf(""Enter the array elements...\n"");
    for(i=0; i<rows; i++)
    {
        for(j=0; j<columns; j++)
        {
            scanf(""%d"", &arr[i][j]);
        }
    }
    
    if(isSparse(arr, rows, columns) == 1)
        printf(""Given Matrix is a SPARSE MATRIX...\n"");
    else
        printf(""Given Matrix is NOT a SPARSE MATRIX...\n"");
        
}

int isSparse(int arr[10][10], int rows, int cols)
{
    int count=0;
    int i=0;
    int j=0;
    
    for(i=0; i<rows; i++)
    {
        for(j=0; j<cols; j++)
        {
            if(arr[i][j] == 0)
                count++;
            else
                continue;
        }
    }
    
    if(count > (rows*cols))
        return 1;
    else
        return 0;
}
",24,717,391
"const int R = 3;
const int C = 3;


void display(int matrix[R][C]);
int check_sparse(int matrix[R][C]);

void main()
{
    int i, j = 0;
    int input_matrix[R][C];

    printf(""\nEnter elements of input matrix...\n"");
    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            scanf(""%d"", &input_matrix[i][j]);
        }
    }

    
    printf(""\nOriginal Matrix is a follows:- \n"");
    display(input_matrix);

    
    if(check_sparse(input_matrix) == 1)
        printf(""\nIt is a Sparse Matrix...\n"");
    else
        printf(""\nIt is not a Sparse Matrix...\n"");
}


void display(int matrix[R][C])
{
    int i, j = 0;
    int rows = R;
    int columns = C;

    for(i=0; i<rows; i++)
    {
        for(j=0; j<columns; j++)
        {
            printf(""%d\t"", matrix[i][j]);
        }
        printf(""\n"");
    }
}


int check_sparse(int matrix[R][C])
{
    int i, j, output = 0;
    int size, count_zeros = 0;
    int rows = R;
    int columns = C;

    for(i=0; i<rows; i++)
    {
        for(j=0; j<columns; j++)
        {
            if(matrix[i][j] == 0)
                count_zeros++;
            else
                continue;
        }
    }

    
    size = rows * columns;
    if(count_zeros > (size/2))
        output = 1;

    return output;
}",24,718,490
"const int R = 3;
const int C = 3;


void transpose_and_display(int matrix[R][C]);
void display(int matrix[R][C]);

void main()
{
    int i, j = 0;
    int input_matrix[R][C];
    
    printf(""\nEnter the matrix elements..."");
    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            scanf(""%d"", &input_matrix[i][j]);
        }
    }

    
    printf(""\nOriginal Matrix is as follows:- \n"");
    display(input_matrix);

    
    transpose_and_display(input_matrix);
}


void transpose_and_display(int matrix[R][C])
{
    int rows = R;
    int columns = C;
    int i, j, temp = 0;
    int output_matrix[R][C];

    
    temp = columns;
    columns = rows;
    rows = temp;

    
    for(i=0; i<rows; i++)
    {
        for(j=0; j<columns; j++)
        {   
            output_matrix[i][j] = matrix[j][i];
        }
    }

    
    printf(""\nTransposed Matrix is as follows:- \n"");
    display(output_matrix);
}


void display(int matrix[R][C])
{
    int i, j = 0;
    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            printf(""%d\t"", matrix[i][j]);
        }
        printf(""\n"");
    }
}",24,719,438
"#define MAX 10


void display(int array[MAX], int length);
void odd_even_sort(int array[MAX], int length);

void main()
{
    int i = 0;
    int size = 0;
    
    printf(""\nEnter number of elements: \n"");
    scanf(""%d"", &size);
    int input_array[size];

    printf(""\nEnter the array elements...\n"");
    for(i=0; i<size; i++)
        scanf(""%d"", &input_array[i]);

    
    printf(""\nOriginal Array is as follows:- \n"");
    display(input_array, size);

    
    odd_even_sort(input_array, size);

    
    printf(""\nAfter Odd-Even Sorting:- \n"");
    display(input_array, size);
    printf(""\n"");
}


void display(int array[MAX], int length)
{
    int i = 0;
    for(i=0; i<length; i++)
        printf(""%d\t"", array[i]);

    printf(""\n"");
}


void odd_even_sort(int array[MAX], int length)
{
    int i, j, temp, flag = 0;
    int size = length;

    do
    {
        flag = 0;

        
        for(i=0; i<size-1; i=i+2)
        {
            
            if(array[i] > array[i+1])
            {
                temp = array[i+1];
                array[i+1] = array[i];
                array[i] = temp;
                flag = 1;
            }
        }

        
        for(j=1; j<size-1; j=j+2)
        {
            
            if(array[j] > array[j+1])
            {
                temp = array[j+1];
                array[j+1] = array[j];
                array[j] = temp;
                flag = 1;
            }
        }
    }while(flag);
}",24,720,522
"struct Book
{
    int book_id;
    float book_price;
    char book_name[100];
}b;


void displayBookDetails(struct Book b1);


void main()
{
    
    printf(""\nEnter Book_ID: "");
    scanf(""%d"", &b.book_id);
    printf(""\nEnter Book_Price: "");
    scanf(""%f"", &b.book_price);
    printf(""\nEnter Book_Name: "");
    scanf(""%s"", &b.book_name);

    
    displayBookDetails(b);
}


void displayBookDetails(struct Book b1)
{
    
    printf(""\nGetting the Book Details....\n"");
    printf(""\nBook_ID: %d"", b1.book_id);
    printf(""\nBook_Price: %f"", b1.book_price);
    printf(""\nBook_Name: %s"", b1.book_name);
}",24,721,234
"#define size 10


struct Stack
{
    int array[size];
    int top;
}ptr;



void push();
void pop();
void display();
int checkStackFull();
int checkStackEmpty();


void main()
{
    int choice = 0;
    int contin = 0;
    ptr.top = -1;

    do{
        printf(""\nPress 1 for PUSH"");
        printf(""\nPress 2 for POP"");
        printf(""\nPress 3 for DISPLAY"");
        printf(""\nPress 4 for EXIT"");
        printf(""\nEnter your choice: "");
        scanf(""%d"", &choice);

        switch(choice)
        {
            case 1:
                
                push();
                break;

            case 2:
                
                pop();
                break;

            case 3:
                
                display();
                break;

            case 4:
                
                exit(0);
                break;

            default:
                printf(""\nEnter a valid choice!!!"");
        }
        printf(""\nPress 1 to continue, else press any other number to EXIT: "");
        scanf(""%d"", &contin);
    }while(contin == 1);
}



void push()
{
    int flag = checkStackFull();
    if(flag == 1)
    {
        int element = 0;
        printf(""\nEnter the element to be pushed: "");
        scanf(""%d"", &element);
        ptr.array[++(ptr.top)] = element;
    }
    else
        printf(""\nStack is FULL!!!"");
}


void pop()
{
    int flag = checkStackEmpty();
    if(flag == 1)
    {
        printf(""\nPopped Element: %d"", (ptr.array[(ptr.top)--]));
    }
    else
        printf(""\nStack is EMPTY!!!"");
}


void display()
{
    int i = 0;
    int flag = checkStackEmpty();

    if(flag == 1)
    {
        printf(""\nElements present in the Stack are:- \n"");
        for(i=(ptr.top); i>-1; i--)
        {
            printf(""%d\t"", (ptr.array[i]));
        }
        printf(""\n"");
    }
    else
        printf(""\nStack is EMPTY!!!"");
}


int checkStackFull()
{
    if((ptr.top) == size-1)
        return 0;

    return 1;
}


int checkStackEmpty()
{
    if((ptr.top) == -1)
        return 0;

    return 1;
}",24,722,668
"const int R = 3;
const int C = 3;


void add_matrices(int m1[R][C], int m2[R][C]);
void subtract_matrices(int m1[R][C], int m2[R][C]);
void multiply_matrices(int m1[R][C], int m2[R][C]);
void display_matrix(int matrix[R][C]);

void main()
{
    int i, j = 0;
    int choice = 0;
    int contin = 0;

    int matrix1[R][C];
    int matrix2[R][C];
    int matrix3[R][C];

    
    printf(""\nEnter elements of Matrix1...\n"");
    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            scanf(""%d"", &matrix1[i][j]);
        }
    }
    printf(""\nEnter elements of Matrix2...\n"");
    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            scanf(""%d"", &matrix2[i][j]);
        }
    }

    do
    {
        printf(""\nPress:- "");
        printf(""\n1 for ADDITION"");
        printf(""\n2 for SUBTRACTION"");
        printf(""\n3 for  MULTIPLICATION"");
        printf(""\n4 for EXIT"");
        printf(""\nEnter your choice: "");
        scanf(""%d"", &choice);

        switch(choice)
        {
            case 1:
                add_matrices(matrix1, matrix2);
                break;

            case 2:
                subtract_matrices(matrix1, matrix2);
                break;

            case 3:
                multiply_matrices(matrix1, matrix2);
                break;

            case 4:
                exit(0);
                break;

            default:
                printf(""\nEnter a correct choice..."");
        }
        printf(""\nPress 5 to continue, else press any other number: "");
        scanf(""%d"", &contin);
    }while(contin == 5);
}


void add_matrices(int m1[R][C], int m2[R][C])
{
    int i, j = 0;
    int output[R][C];

    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            output[i][j] = m1[i][j] + m2[i][j];
        }
    }

    
    printf(""\nResultant Matrix after ADDITION:- \n"");
    display_matrix(output);
}


void subtract_matrices(int m1[R][C], int m2[R][C])
{
    int i, j = 0;
    int output[R][C];

    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            output[i][j] = m1[i][j] - m2[i][j];
        }
    }

    
    printf(""\nResultant Matrix after SUBTRACTION:- \n"");
    display_matrix(output);
}


void multiply_matrices(int m1[R][C], int m2[R][C])
{
    int i, j, k = 0;
    int sum = 0;
    int output[R][C];

    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            for(k=0; k<R; k++)
            {
                sum += m1[i][k] * m2[k][j];
            }
            output[i][j] = sum;
            sum = 0;
        }
    }

    
    printf(""\nResultant Matrix after MULTIPLICATION:- \n"");
    display_matrix(output);
}


void display_matrix(int matrix[R][C])
{
    int i, j = 0;
    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            printf(""%d\t"", matrix[i][j]);
        }
        printf(""\n"");
    }
}",24,723,1098
"int factorial(int number);
void main()
{
    float sum=0.0f;
    int n=0;
    int i=0;
        
    printf(""Enter the value of n: "");
    scanf(""%d"", &n);
    for(i=1; i<=n; i++)
    {
        sum = sum + (factorial(i)/i);   
    }
    
    
    printf(""Sum = %f"", sum);    
}

int factorial(int number)
{
    int copy=number;
    int i=0;
    int fact=1;
    
    for(i=1; i<=copy; i++)
    {
        fact = fact * i;
    }
    
    return fact;
}
",24,724,185
"#define MAX 10


void display(int array[MAX], int length);
int linear_search(int array[MAX], int length, int key);

void main()
{
    int i, size, key = 0;
        
    printf(""\nEnter number of elements: \n"");
    scanf(""%d"", &size);
    int input_array[size];

    printf(""\nEnter the array elements...\n"");
    for(i=0; i<size; i++)
        scanf(""%d"", &input_array[i]);

    
    printf(""\nOriginal Array is as follows:- \n"");
    display(input_array, size);

    
    printf(""\nEnter the key to be searched: \n"");
    scanf(""%d"", &key);

    
    printf(""\n%d is found in Index %d\n"", key, linear_search(input_array, size, key));
}


void display(int array[MAX], int length)
{
    int i = 0;
    for(i=0; i<length; i++)
        printf(""%d\t"", array[i]);

    printf(""\n"");
}


int linear_search(int array[MAX], int length, int key)
{
    int i, index = -1;
    int size = length;

    for(i=0; i<size; i++)
    {
        
        if(array[i] == key)
        {
            index = i;
            break;
        }
        else
            continue;
    }

    return index;
}",24,725,384
"const int R = 5;
const int C = 5;


void display_upper_triangular(int matrix[R][C]);
void display_lower_triangular(int matrix[R][C]);
void display(int matrix[R][C]);

void main()
{
    int i, j = 0;
    int input_matrix[R][C];

    printf(""\nEnter the matrix elements...\n"");
    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            scanf(""%d"", &input_matrix[i][j]);
        }
    }

    
    printf(""\nOriginal Matrix is as follows:- \n"");
    display(input_matrix);

    
    printf(""\nUpper Triangular Matrix is as follows:- \n"");
    display_upper_triangular(input_matrix);

    
    printf(""\nLower Triangular Matrix is as follows:- \n"");
    display_lower_triangular(input_matrix);
}


void display_upper_triangular(int matrix[R][C])
{
    int i, j = 0;

    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            
            if(i < j)
            {
                printf(""%d\t"", matrix[i][j]);
            }
            else
                continue;
        }
        printf(""\n"");
    }
}


void display_lower_triangular(int matrix[R][C])
{
    int i, j = 0;

    for(i=0; i<R; i++)
    {
        for(j=0; j<C; j++)
        {
            
            if(i > j)
                printf(""%d\t"", matrix[i][j]);
            else
                continue;
        }
        printf(""\n"");
    }
}


void display(int matrix[R][C])
{
    int i, j = 0;
    int rows = R;
    int columns = C;

    for(i=0; i<rows; i++)
    {
        for(j=0; j<columns; j++)
        {
            printf(""%d\t"", matrix[i][j]);
        }
        printf(""\n"");
    }
}",24,726,577
"float ciag(int n);

int main()
{
    int N;

    printf(""Podaj dodatnia wartosc liczby 'N': "");
    scanf(""%d"", &N);

    while(N <= 0){
        printf(""Podano bledna wartosc\n"");
        printf(""Podaj dodatnia wartosc liczby 'N': "");
        scanf(""%d"", &N);
    }

    printf(""N-ty wyraz ciagu to: %.2f"", ciag(N));

    printf(""\n"");
    return 0;
}

float ciag(int n){
    float a_n;
    if(n == 1) return 1;
    if(n == 2) return 2;
    if(n == 3) return 3;
    a_n = (ciag(n-1) + ciag(n-2) + ciag(n-3))/3; 
    return a_n;
};
",25,727,241
"int wypisz(int * array, int n);

int main()
{
    int tablica[10];
    int userNumber;
    int licznik = 0;
    int size = sizeof(tablica)/sizeof(tablica[0]);

    while(licznik < 10) {
        printf(""Podaj liczbe nr %d do tablicy: "", licznik + 1);
        scanf(""%d"", &userNumber);
        tablica[licznik] = userNumber;
        licznik++;
    }

    printf(""\n"");
    wypisz(tablica, size);

    printf(""\n"");
    return 0;
}

int wypisz(int * array, int n){
   for(int i = 0; i < n; i++){
        if(array[i] % 2 == 0) {
            printf(""Parzysta liczba %d o indeksie %d\n"", array[i], i);
        }
    }
};
",25,728,241
"void connectArrays(unsigned int, int * array1, int * array2, double * array3);

int main()
{
    int one[8] = {5, 6, 8, 8, 10, -2, 0, 121};
    int two[8] = {2, 1, 3, -4, 10, 21, 2, 233};
    double three[16];
    unsigned int naturalNumber = 8;

    printf(""Elementy tablicy1: "");
    for(int i = 0; i < (sizeof(one)/sizeof(one[0])); i++){
        printf(""%d "", one[i]);
    }
    printf(""\nElementy tablicy2: "");
    for(int i = 0; i < (sizeof(two)/sizeof(two[0])); i++){
        printf(""%d "", two[i]);
    }

    connectArrays(naturalNumber, one, two, three);

    printf(""\nElementy tablicy3: "");
    for(int i = 0; i < (sizeof(three)/sizeof(three[0])); i++){
        printf(""%.f "", three[i]);
    }

    getchar();;
    return 0;
}

void connectArrays(unsigned int n, int * array1, int * array2, double * array3){
    int i = 0;
    for(i; i < 2*n; i++){
        if(i < n){
            array3[i] = array1[i];
        } else {
            array3[i] = array2[-n+i];
        }
    }
};
",25,729,407
"void rzad_zn(char ch, int i, int j);

int main()
{
    char userChar;
    int columnStart;
    int columnEnd;

    printf(""Podaj znak: "");
    scanf(""%c"", &userChar);
    printf(""Podaj pocz\245tkow\245 kolumn\251: "");
    scanf(""%d"", &columnStart);
    printf(""Podaj ko\344cow\245 kolumn\251: "");
    scanf(""%d"", &columnEnd);

    rzad_zn(userChar,columnStart, columnEnd);

    return 0;
}

void rzad_zn(char ch, int i, int j) {
    char space = ' ';
    for(int k = i; k > 1; k--){
        putchar(space);
    }
    for(int k = i; k <= j; k++){
        putchar(ch);
    }
    return;
}
",25,730,247
"void do_binar(int n, int sys);

int main()
{
    int liczba;
    int systemLiczbowy;

    printf(""Podaj liczb\251 ca\210kowit\245 (q ko\344czy program):\n"");

    while(scanf(""%d"", &liczba) == 1){
        printf(""Podaj system liczbowy z zakresu od 2 do 10:\n"");
        scanf(""%d"", &systemLiczbowy);
        printf(""Odpowiednik w podanym systemie: "");
        do_binar(liczba, systemLiczbowy);
        putchar('\n');
        printf(""Podaj liczb\251 ca\210kowit\245 (q ko\344czy program):\n"");
    }
    return 0;
}

void do_binar(int n, int sys){
    int r;
    if(sys < 2 || sys > 10){
        printf(""Podano system liczbowy spoza zakresu!!!"");
        return;
    }

    r = n % sys;
    if(n >= sys)
        do_binar(n / sys, sys);
    putchar('0' + r);
    return;
}
",25,731,321
"#define PESEL 12

typedef struct personalInfo {
    char pesel[PESEL];
    struct person {
        char firstName[21];
        char middleName[21];
        char lastName[21];
    };
} PERSONINFO;

int main()
{
    PERSONINFO persons[] = {
        ""23232323232"", ""Adam"", ""Rick"", ""Melix"",
        ""11111111111"", ""Morty"", ""Eric"", ""Willis"",
        ""88833388822"", ""Tom"", ""George"", ""Brady""
    };

    int counter = 0;
    int size = sizeof(persons)/sizeof(*persons);
    while(counter < size){
        printf(""%7s, %7s %7s -- %s\n"", persons[counter].lastName, persons[counter].firstName, persons[counter].middleName, persons[counter].pesel);
        counter++;
    }


    getchar();
    return 0;
}
",25,732,275
"int main()
{
    char ch;
    int changeCounter = 0;

    printf(""Podaj znaki. '#' zako\344czy program!\n"");
    while((ch = getchar()) != '#') {
        if(ch == '!') {
            putchar(ch);
            putchar(ch);
            changeCounter++;
            continue;
        }
        if(ch == '.') {
            ch = '!';
            putchar(ch);
            changeCounter++;
            continue;
        }
        putchar(ch);
    }
    printf(""\nLiczba wykonanych zmian: %d\n"", changeCounter);
    getchar();
    return 0;
}

",25,733,174
"int main()
{
    float array[10];
    float userNumber;
    float sumPlus = 0;
    float sumMinus = 0;
    int licznik = 0;
    int licznikPlus = 0;
    int licznikMinus = 0;

    while(licznik < 10) {
        printf(""Podaj liczbe nr %d do tablicy: "", licznik + 1);
        scanf(""%f"", &userNumber);
        array[licznik] = userNumber;
        licznik++;
    }

    for(int i = 0; i < 10; i++){
        if(array[i] > 0){
            sumPlus += array[i];
            licznikPlus++;
        }
        if(array[i] < 0){
            sumMinus += array[i];
            licznikMinus++;
        }
    }

    if (licznikPlus != 0) {
        printf(""Srednia arytmatyczna dodatnich elementow: %.2f\n"", sumPlus/licznikPlus);
    } else {
        printf(""Srednia arytmatyczna dodatnich elementow wynosi 0\n"");
    }

    if (licznikMinus != 0) {
        printf(""Srednia arytmatyczna ujemnych elementow: %.2f\n"", sumMinus/licznikMinus);
    } else {
        printf(""Srednia arytmatyczna ujemnych elementow wynosi 0\n"");
    }

    printf(""\n"");
    return 0;
}
",25,734,391
"float powerOfTwo(int);

int main()
{
    int userNumber;
    printf(""Podaj liczbe calkowita 'n': "");
    scanf(""%d"", &userNumber);

    printf(""2 do potegi %d to: %.3f\n"", userNumber, powerOfTwo(userNumber));

    getchar();
    return 0;
}

float powerOfTwo(int n){
    float result = 1;
    if(n >= 0){
        for(int i = 0; i < n; i++){
            result = result * 2;
        }
    } else {
        for(int i = 0; i > n; i--){
            result = result * 2;
        }
        result = 1 / result;
    }
    return result;
}
",25,735,199
"int czyTrojkat(float a, float b, float c);

int main()
{
    float first, second, third;

    printf(""Podaj 1 bok: "");
    scanf(""%f"", &first);
    printf(""Podaj 2 bok: "");
    scanf(""%f"", &second);
    printf(""Podaj 3 bok: "");
    scanf(""%f"", &third);

    if(!czyTrojkat(first, second, third)){
        printf(""Podane boki nie moga utworzyc trojkata!"");
    } else {
        printf(""Podane boki tworza piekny trojkat!"");
    };

    printf(""\n"");
    return 0;
}

int czyTrojkat(float a, float b, float c){
    float max;
    float middle;
    float min;

    if(a <= 0 || b <= 0 || c <= 0){
        return 0;
    }

    if(a >= b && a >= c ) {
        max = a;
        if(b >= c) {
            min = c;
            middle = b;
        } else {
            min = b;
            middle = c;
        }
    } else if ( b >= c) {
        max = b;
        if(a >= c) {
             min = c;
             middle = b;
        } else {
             min = a;
             middle = c;
        }
    } else {
        max = c;
        if(a >= b) {
             min = b;
             middle = a;
        } else {
             min = a;
             middle = b;
        }
    }
    if(min + middle <= max){
        return 0;
    }
    return 1;
}
",25,736,439
"void copyArrayNormal(int sourceArray[], int outputArray[], int size);
void copyArrayPointer(int sourceArray[], int outputArray[], int size);

int main()
{
   int array1[7] = {8, 32, -4, 5, 6, 93, 345};
   int array2[7];
   int array3[7];
   int arraySize = sizeof(array1)/sizeof(*array1);

    copyArrayNormal(array1, array2, arraySize);
    copyArrayPointer(array1, array3, arraySize);

    printf(""array1: "");
    for(int i = 0; i < arraySize; i++){
        printf(""%d "", array1[i]);
    }
    printf(""\n"");

    printf(""array2: "");
    for(int i = 0; i < sizeof(array2)/sizeof(*array2); i++){
        printf(""%d "", array2[i]);
    }
    printf(""\n"");

    printf(""array3: "");
    for(int i = 0; i < sizeof(array3)/sizeof(*array3); i++){
        printf(""%d "", array3[i]);
    }
    printf(""\n"");

    return 0;
}

void copyArrayNormal(int sourceArray[], int outputArray[], int size){
    for(int i = 0; i < size; i++){
        outputArray[i] = sourceArray[i];
    }
};

void copyArrayPointer(int sourceArray[], int outputArray[], int size){
    int * pointerSource = sourceArray;
    int * pointerOutput = outputArray;
    for(int i = 0; i < size; i++){
        *pointerOutput = *pointerSource;
        pointerSource++;
        pointerOutput++;
    }
};
",25,737,438
"void connectArrays(unsigned int, int * array1, int * array2, double * array3);

int main()
{
    int one[8] = {5, 6, 8, 8, 10, -2, 0, 121};
    int two[8] = {2, 1, 3, -4, 10, 21, 2, 233};
    double three[16];
    unsigned int naturalNumber = 8;

    printf(""Elementy tablicy1: "");
    for(int i = 0; i < (sizeof(one)/sizeof(one[0])); i++){
        printf(""%d "", one[i]);
    }
    printf(""\nElementy tablicy2: "");
    for(int i = 0; i < (sizeof(two)/sizeof(two[0])); i++){
        printf(""%d "", two[i]);
    }

    connectArrays(naturalNumber, one, two, three);

    printf(""\nElementy tablicy3: "");
    for(int i = 0; i < (sizeof(three)/sizeof(three[0])); i++){
        printf(""%.f "", three[i]);
    }

    getchar();;
    return 0;
}

void connectArrays(unsigned int n, int * array1, int * array2, double * array3){
    int counterEven = 0;
    int counterOdd = 0;
    int i = 0;
    for(i; i < 2*n; i++){
        if(i % 2 == 0){
            array3[i] = array2[counterEven];
            counterEven++;
        } else {
            array3[i] = array1[counterOdd];
            counterOdd++;
        }
    }
};
",25,738,445
"void copyArrayNormal(int sourceArray[], int outputArray[], int size);
void copyArrayPointer(int sourceArray[], int outputArray[], int size);

int main()
{
   int array1[7] = { 8, 32, -4, 43, 200, 4000, -6432};

   int array2[3];
   int array3[3];

   int arraySize1 = sizeof(array1)/sizeof(*array1);
   int arraySize2 = sizeof(array2)/sizeof(*array2);
    int arraySize3 = sizeof(array3)/sizeof(*array3);

    copyArrayNormal(&array1[2], array2, arraySize2); 
    copyArrayPointer(&array1[2], array3, arraySize3);

    printf(""array1: "");
    for(int i = 0; i < arraySize1; i++){
            printf(""%d "", array1[i]);
    }

    printf(""\n\narray2: "");
    for(int i = 0; i < arraySize2; i++){
            printf(""%d "", array2[i]);
    }

    printf(""\n\narray3: "");
    for(int i = 0; i < arraySize3; i++){
            printf(""%d "", array3[i]);
    }

    printf(""\n"");
    return 0;
}

void copyArrayNormal(int sourceArray[], int outputArray[], int size){
    for(int i = 0; i < size; i++){
        outputArray[i] = sourceArray[i];
    }
};

void copyArrayPointer(int sourceArray[], int outputArray[], int size){
    int * pointerSource = sourceArray;
    int * pointerOutput = outputArray;
    for(int i = 0; i < size; i++){
        *pointerOutput = *pointerSource;
        pointerSource++;
        pointerOutput++;
    }
};
",25,739,472
"void copyArrayNormal(int sourceArray[], int outputArray[], int size);
void copyArrayPointer(int sourceArray[], int outputArray[], int size);

int main()
{
   int array1[7][3] = {
        {8, 32, -4},
        {5, 6, 93},
        {345, 32, -32},
        {3, 3, -3},
        {-6, -5, -5},
        {0, 0, 0},
        {0, 2, -2}
        };

   int array2[7][3];
   int array3[7][3];
   int arraySizeOut = sizeof(array1)/sizeof(*array1);
   int arraySizeIn = sizeof(array1[0])/sizeof(*array1[0]);

    for(int i = 0; i < arraySizeOut; i++){
        copyArrayNormal(array1[i], array2[i], arraySizeIn);
    }
    for(int i = 0; i < arraySizeOut; i++){
        copyArrayPointer(array1[i], array3[i], arraySizeIn);
    }

    printf(""array1"");
    for(int i = 0; i < arraySizeOut; i++){
        printf(""\nPodtablica: "");
        for(int j = 0; j < arraySizeIn; j++){
            printf(""%d "", array1[i][j]);
        }
    }

    printf(""\n\narray2"");
    for(int i = 0; i < arraySizeOut; i++){
        printf(""\nPodtablica: "");
        for(int j = 0; j < arraySizeIn; j++){
            printf(""%d "", array2[i][j]);
        }
    }


    printf(""\n\narray3"");
    for(int i = 0; i < arraySizeOut; i++){
        printf(""\nPodtablica: "");
        for(int j = 0; j < arraySizeIn; j++){
            printf(""%d "", array3[i][j]);
        }
    }

    printf(""\n"");
    return 0;
}

void copyArrayNormal(int sourceArray[], int outputArray[], int size){
    for(int i = 0; i < size; i++){
        outputArray[i] = sourceArray[i];
    }
};

void copyArrayPointer(int sourceArray[], int outputArray[], int size){
    int * pointerSource = sourceArray;
    int * pointerOutput = outputArray;
    for(int i = 0; i < size; i++){
        *pointerOutput = *pointerSource;
        pointerSource++;
        pointerOutput++;
    }
};
",25,740,662
"#define MAXTYT 40
#define MAXAUT 40
#define MAXKS 100

struct ksiazka {
    char tytul[MAXTYT];
    char autor[MAXAUT];
    float wartosc;
};

int main()
{
    struct ksiazka bibl[MAXKS]; 
    int licznik = 0;
    int index;
    float koszt = 0;

    printf(""Podaj tytul ksiazki.\n"");
    printf(""Aby zakonczyc, wcisnij [enter] na poczatku wiersza.\n"");

    while(licznik < MAXKS && gets(bibl[licznik].tytul) != NULL && bibl[licznik].tytul[0] != '\0'){
        printf(""Teraz podaj autora.\n"");
        gets(bibl[licznik].autor);
        printf(""Teraz podaj wartosc.\n"");
        scanf(""%f"", &bibl[licznik++].wartosc);
        while(getchar() != '\n')
            continue; 
        if(licznik < MAXKS)
            printf(""Podaj kolejny tytul.\n"");
    }

    printf(""Oto posortowana lista Twoich ksiazek:\n"");

    for(index = 0; index < licznik; index++){
        for(int j = 0; j < licznik; j++){
            if(strcmp(bibl[j].tytul,bibl[index].tytul)>0){
                struct ksiazka temp = bibl[index];
                bibl[index] = bibl[j];
                bibl[j] = temp;
            }
        }
    }

    for(index = 0; index < licznik; index++){
        printf(""%s, autor: %s, cena: %.2f zl\n"", bibl[index].tytul, bibl[index].autor, bibl[index].wartosc);
        koszt += bibl[index].wartosc;
    }

    printf(""----------------------------------------------------------------\n"");
    printf(""Wartosc wszystkich ksiazek: %.2f zl\n"", koszt);

    getchar();
    return 0;
}
",25,741,562
"int kwadrat(int);
int szescian(int);

int main()
{
    int userMin, userMax;

    printf(""Podaj liczb\251 dolnej granicy tabeli: "");
    scanf(""%d"", &userMin);
    printf(""Podaj liczb\251 g\242rnej granicy tabeli: "");
    scanf(""%d"", &userMax);

    printf(""\nLiczba\t\tKwadrat\t\tSze\230cian"");

    for(char i = userMin; i <= userMax; i++) {
        printf(""\n%5d\t\t%5d\t\t%5d"", i, kwadrat(i), szescian(i));
    }

    getchar();
    return 0;
}

int kwadrat(int x) {
    return x*x;
}

int szescian(int x) {
    return x*x*x;
}

",25,742,243
"int main()
{
    float a, c, x1, x2, delta;

    printf(""Prosz\251 poda\206 warto\230\206 wsp\242\210czynnika a: "");
    scanf(""%f"", &a);
    printf(""Prosz\251 poda\206 warto\230\206 wsp\242\210czynnika c: "");
    scanf(""%f"", &c);

    delta = (2*2) - 4*3*a*c;

    if(a == 0){
        printf(""\n'a' = 0!. Pierwiastek wynosi:"");
        x1 = (-3*c)/2;
        printf(""\nX1= %.2f\n"", x1);
    }else if(delta < 0){
        printf(""Rownanie nie ma rozwiazan."");
    } else {
        x1 = (-2-sqrt(delta))/(2*a);
        x2 = (-2+sqrt(delta))/(2*a);
        printf(""\nX1= %.2f\n"", x1);
        printf(""X1= %.2f\n"", x2);
    }

    printf(""\n"");
    return 0;
}
",25,743,318
"int main()
{

    float number1, number2;
    int endProgram = 0;

    while(!endProgram){

        printf(""Podaj pierwsz\245 liczb\251: "");
        if(scanf(""%f"", &number1) == 1) {

            printf(""Podaj drug\245 liczb\251: "");

            if(scanf(""%f"", &number2) == 1) {

                float wynik = (number1 - number2) / (number1 * number2);
                printf(""\nWynik: %3f\n\n"", wynik);

            } else {
            printf(""Podano b\210\251dne dane. Zako\344czenie pracy programu!\n"");
            endProgram = 1;
            }
        } else {
            printf(""Podano b\210\251dne dane. Zako\344czenie pracy programu!\n"");
            endProgram = 1;
        }
    }

    getchar();
    return 0;
}
",25,744,273
"int sequenceA(int);

int main()
{
    int userNumber;
    printf(""Podaj nieujemna liczbe calkowita 'n': "");
    scanf(""%d"", &userNumber);

    while(userNumber < 0 ){
        printf(""Podano nieprawidlowe dane!\n"");
        printf(""Podaj nieujemna liczbe calkowita 'n': "");
        scanf(""%d"", &userNumber);
    }

    printf(""Wyraz '%d' ciagu wynosi: %d\n"", userNumber, sequenceA(userNumber));

    getchar();
    return 0;
}

int sequenceA(int n){
    int a_n = 1;
    if(n > 0){ 
        a_n = 2 * sequenceA(n - 1) + 5;
    }
    return a_n;
}
",25,745,217
"int main()
{
    char ch;
    int oddSum = 0;
    int evenSum = 0;
    int oddCounter = 0;
    int evenCounter = 0;

    printf(""Podaj liczby ca\210kowite. '0' zako\344czy program!\n"");
    while((ch = getchar()) != '0') {
        if (isdigit(ch)){
            switch (ch % 2) {
                case 0 :
                evenCounter++;
                evenSum += ch - '0'; 
                break;
            default :
                oddCounter++;
                oddSum += ch - '0';
                break;
            }
        }
    }
    printf(""Liczb parzystych: %d\nSrednia warto\230\206: %d\n\n"", evenCounter, evenSum / evenCounter);
    printf(""Liczb nieparzystych: %d\nSrednia warto\230\206: %d\n"", oddCounter, oddSum / oddCounter);

    getchar();
    return 0;
}

",25,746,273
"void showArray(int sourceArray[], int size);
void multiplyByTwo(int sourceArray[], int size);

int main()
{
   int array[3][5] = {
            {8, 32, -4, 43, 200},
            {-8, 102, -8, -3, 100},
            {18, -2, -1, 21, 400},
       };

   int arraySize = sizeof(array)/sizeof(*array);

    showArray(array, arraySize);
    multiplyByTwo(array, arraySize);
    printf(""\n"");
    showArray(array, arraySize);

    printf(""\n"");
    return 0;
}

void showArray(int sourceArray[], int size){
    int * pointerSourceArray = sourceArray;
    printf(""array\n"");
    for(int i = 0; i < size; i++){
        printf(""Podtablica: "");
        for(int j = 0; j < 5; j++){
            printf(""%d "", pointerSourceArray[j+(i*5)]);
        }
        printf(""\n"");
    }
}

void multiplyByTwo(int sourceArray[], int size){
    int * pointerSourceArray = sourceArray;
    for(int i = 0; i < size*5; i++){
        *pointerSourceArray = *pointerSourceArray * 2;
        pointerSourceArray++;
    }
};
",25,747,355
"double power(double x, int y);

int main()
{
    double userNumber;
    int userPower;
    printf(""Podaj liczb\251: "");
    scanf(""%lf"", &userNumber);
    printf(""Podaj pot\251g\251 ca\210kowit\245: "");
    scanf(""%d"", &userPower);
    printf(""%.3lf do pot\251gi %d wynosi %.3lf\n"", userNumber, userPower, power(userNumber, userPower));
    return 0;
}

double power(double x, int y){
    double result = x;
    if(x == 0) return 0;
    if(y == 0) return 1;
    if(y<0){
        result = 1/x;
        x = 1/x;
        y = -y;
    }
    if(y > 0){
        result = result * power(x, y - 1);
    }
    return result;
}
",25,748,257
"#include ""months.c""
#define MAXNAME 20
#define MAXABB 3

int numberOfDays(int, int, int);

int main()
{
    int userYear;
    int userDay;
    char userMonth[MAXNAME];

    printf(""Program wyswietli liczbe dni od poczatku roku do podanego dnia miesiaca.\n"");
    printf(""Podaj numer dnia.\n"");
    scanf(""%d"", &userDay);
    printf(""Podaj (nazwe, numer lub skrot) miesiaca.\n"");
    scanf(""%s"", &userMonth);
    printf(""Podaj rok.\n"");
    scanf(""%d"", &userYear);

    printf(""Liczba dni: %d"", numberOfDays(userMonth, userDay, userYear));

    getchar();
    return 0;
}

int numberOfDays(month, day, year){
    int error = true; 
    int leapYear = false;
    int result = day;
    if((year%4==0) && ((year%400==0) || (year%100!= 0)))
        leapYear = true; 
    for (int i = 0; i < 12; i++){
        if(strcmp(month, months[i].name) == 0 || strcmp(month, months[i].abb) == 0 || atoi(month) == months[i].order){
            error = false;
            break; 
        }
        result += months[i].days;
        if(leapYear && months[i].order == 2)
            result += 1;
    }
    if(day <= 0 || day > 31){
        error = true; 
    }
    if(error == true){
        result = 0;
    }
    return result;
};
",25,749,459
"#define BASICHOUR 40
#define OVERTIME 1.5
#define TAX1 0.15
#define TAX2 0.20
#define TAX3 0.25

int main()
{
    int workHours;
    float brutto;
    float podatek;

    printf(""Podaj liczb\251 przepracowanych godzin w tygodniu: "");
    scanf(""%d"", &workHours);

    if(workHours >= 40) {
        brutto = 40 * BASICHOUR + (workHours - 40) * BASICHOUR * OVERTIME;
    } else {
        brutto = workHours * BASICHOUR;
    }

    if (brutto <= 1200) {
        podatek = brutto * TAX1;
    } else if (brutto > 1200 && brutto <= 1800) {
        podatek = 1200 * TAX1 + (brutto - 1200) * TAX2;
    } else {
        podatek = 1200 * TAX1 + (600) * TAX2 + (brutto - 1800) * TAX3;
    }

    printf(""\nWynagrodzenie brutto: %.2fz\210\n"", brutto);
    printf(""Podatek: %.2fz\210\n"", podatek);
    printf(""Wynagrodzenie netto: %.2fz\210\n"", brutto - podatek);

    getchar();
    return 0;
}

",25,750,421
"#define MIESIACE 12
#define LATA 5

void printAvgYear(float pointer[][0]);
void printAvgMonth(float apointer[][0]);

int main()
{
    const float deszcz[LATA][MIESIACE] = {
        {10.2, 8.1, 6.8, 4.2, 2.1, 1.8, 0.2, 0.3, 1.1, 2.3, 6.1, 7.4},
        {9.2, 9.8, 4.8, 3.2, 2.5, 4.8, 1.2, 0.5, 1.6, 1.3, 7.1, 7.4},
        {10.6, 5.6, 6.7, 4.4, 3.8, 1.8, 2.2, 7.3, 2.6, 4.3, 4.6, 4.6},
        {12.5, 3.7, 4.3, 0.2, 2.1, 1.7, 4.6, 0.5, 1.6, 0.3, 9.1, 2.4},
        {12.2, 9.1, 7.8, 1.2, 8.4, 1.5, 0.2, 3.5, 3.8, 1.3, 7.1, 4.4}
    };

    printAvgYear(deszcz);
    printAvgMonth(deszcz);

    printf(""\n"");
    return 0;
}

void printAvgYear(float pointer[][0]){
    float * rok;        
    float * miesiac;    
    float podsuma, suma;
    int licznik = 0;

    for(rok = *pointer, suma = 0; rok <= *pointer + 48; rok = rok + 12){
        for(miesiac = *pointer + (12*licznik) , podsuma = 0; miesiac <= *pointer + 11 + (12*licznik); miesiac++){
            podsuma += *miesiac;
        }
        printf(""%5d %12.1f\n"", 1995 + licznik, podsuma);
        licznik++;
        suma += podsuma;
    }

    printf(""\nRoczna srednia wynosi %.1f cm.\n\n"", suma/LATA);
}

void printAvgMonth(float pointer[][0]){
    float * rok;        
    float * miesiac;    
    float podsuma, suma;

    printf(""SREDNIE MIESIECZNE:\n\n"");
    printf("" Sty  Lut  Mar  Kwi  Maj  Cze  Lip  Sie  Wrz  Paz "");
    printf("" Lis  Gru\n"");

    for (miesiac = *pointer; miesiac <= *pointer + 11; miesiac++){
        for(rok = miesiac, podsuma = 0; rok <= *pointer + 48 + 11; rok = rok + 12){ 
            podsuma += *rok;
        }
        printf(""%4.1f "", podsuma/LATA);
    }
}
",25,751,845
"int wynik(float, float);

int main()
{

    float number1, number2;
    int endProgram = 0;

    while(!endProgram){

        printf(""Podaj pierwsz\245 liczb\251: "");
        if(scanf(""%f"", &number1) == 1) {

            printf(""Podaj drug\245 liczb\251: "");

            if(scanf(""%f"", &number2) == 1) {

                wynik(number1, number2);

            } else {
            printf(""Podano b\210\251dne dane. Zako\344czenie pracy programu!\n"");
            endProgram = 1;
            }
        } else {
            printf(""Podano b\210\251dne dane. Zako\344czenie pracy programu!\n"");
            endProgram = 1;
        }
    }

    getchar();
    return 0;
}

wynik(float x, float y) {
    float result = (x - y) / (x * y);
    printf(""\nWynik: %3f\n\n"", result);
    return 0;
}
",25,752,309
"void biggerElement(unsigned int, int * array1, int * array2, int * array3);

int main()
{
    int one[8] = {5, 6, 8, 8, 10, -2, 0, 121};
    int two[8] = {2, 1, 3, -4, 10, 21, 2, 233};
    int three[8];
    unsigned int naturalNumber = 8;

    printf(""Elementy tablicy1: "");
    for(int i = 0; i < (sizeof(one)/sizeof(one[0])); i++){
        printf(""%d "", one[i]);
    }
    printf(""\nElementy tablicy2: "");
    for(int i = 0; i < (sizeof(two)/sizeof(two[0])); i++){
        printf(""%d "", two[i]);
    }

    biggerElement(naturalNumber, one, two, three);

    printf(""\nElementy tablicy3: "");
    for(int i = 0; i < (sizeof(three)/sizeof(three[0])); i++){
        printf(""%d "", three[i]);
    }

    getchar();;
    return 0;
}

void biggerElement(unsigned int n, int * array1, int * array2, int * array3){
    int i = 0;
    for(i; i < n; i++){
        if(array1[i] > array2[i]){
            array3[i] = array1[i];
        } else {
            array3[i] = array2[i];
        }
    }
};
",25,753,405
"int change(int * x, int * y);

int main()
{
    int number1, number2;

    printf(""Podaj liczbe calkowita nr 1: "");
    scanf(""%d"", &number1);
    printf(""Podaj liczbe calkowita nr 2: "");
    scanf(""%d"", &number2);

    printf(""\nLiczba1: %d     Liczba2: %d\n\n"", number1, number2);
    change(&number1, &number2);
    printf(""Liczba1: %d     Liczba2: %d\n\n"", number1, number2);

    getchar();
    return 0;
}

int change(int * x, int * y){
    if(*y < *x){
        int temp = *x;
        *x = *y;
        *y = temp;
    }
    return 0;
}
",25,754,226
"void copyArrays(unsigned int, int * array1, int * array2);

int main()
{
    int one[5] = {5, 6, 8, 8, 10};
    int two[5];

    printf(""Elementy tablicy1: "");
    for(int i = 0; i < (sizeof(one)/sizeof(one[0])); i++){
        printf(""%d "", one[i]);
    }

    copyArrays(5, one, two);

    printf(""\nElementy tablicy2: "");
    for(int i = 0; i < (sizeof(two)/sizeof(two[0])); i++){
        printf(""%d "", two[i]);
    }

    getchar();;
    return 0;
}

void copyArrays(unsigned int n, int * array1, int * array2){
    int i = 0;
    for(i; i < n; i++){
        array2[i] = array1[n-1-i];
    }
};
",25,755,253
"void AddArraysPointer(int sourceArray[], int outputArray[], int size);

int main()
{
   int array1[8] = { 8, 32, -4, 43, 200, 4000, -6432, 7};

   int array2[8] = { 2, -32, -4, 653, -199, 4010, -6432, 14};
   int array3[8];

   int arraySize = sizeof(array1)/sizeof(*array1);

    addArraysPointer(array1, array2, array3, arraySize);

    printf(""array1: "");
    for(int i = 0; i < arraySize; i++){
            printf(""%d "", array1[i]);
    }

    printf(""\n\narray2: "");
    for(int i = 0; i < arraySize; i++){
            printf(""%d "", array2[i]);
    }

    printf(""\n\narray3: "");
    for(int i = 0; i < arraySize; i++){
            printf(""%d "", array3[i]);
    }

    printf(""\n"");
    return 0;
}

void addArraysPointer(int sourceArray1[], int sourceArray2[], int outputArray[], int size){
    int * pointerSource1 = sourceArray1;
    int * pointerSource2 = sourceArray2;
    int * pointerOutput = outputArray;
    for(int i = 0; i < size; i++){
        *pointerOutput = *pointerSource1 + *pointerSource2;
        pointerSource1++;
        pointerSource2++;
        pointerOutput++;
    }
};
",25,756,420
"#define MIESIACE 12
#define LATA 5

int main()
{
    const float deszcz[LATA][MIESIACE] = {
        {10.2, 8.1, 6.8, 4.2, 2.1, 1.8, 0.2, 0.3, 1.1, 2.3, 6.1, 7.4},
        {9.2, 9.8, 4.8, 3.2, 2.5, 4.8, 1.2, 0.5, 1.6, 1.3, 7.1, 7.4},
        {10.6, 5.6, 6.7, 4.4, 3.8, 1.8, 2.2, 7.3, 2.6, 4.3, 4.6, 4.6},
        {12.5, 3.7, 4.3, 0.2, 2.1, 1.7, 4.6, 0.5, 1.6, 0.3, 9.1, 2.4},
        {12.2, 9.1, 7.8, 1.2, 8.4, 1.5, 0.2, 3.5, 3.8, 1.3, 7.1, 4.4}
    };

    float * rok;        
    float * miesiac;    
    float podsuma, suma;
    int licznik = 0;

    for(rok = deszcz, suma = 0; rok <= &deszcz[4][11]; rok = rok + MIESIACE){
        for(miesiac = deszcz[licznik], podsuma = 0; miesiac <= &deszcz[licznik][11]; miesiac++){
            podsuma += *miesiac;

        }
        printf(""%5d %12.1f\n"", 1995 + licznik, podsuma);
        licznik++;
        suma += podsuma;
    }

    printf(""\nRoczna srednia wynosi %.1f cm.\n\n"", suma/LATA);
    printf(""SREDNIE MIESIECZNE:\n\n"");
    printf("" Sty  Lut  Mar  Kwi  Maj  Cze  Lip  Sie  Wrz  Paz "");
    printf("" Lis  Gru\n"");

    for (miesiac = deszcz; miesiac <= &deszcz[0][11]; miesiac++){
        for(rok = miesiac, podsuma = 0; rok <= &deszcz[4][11]; rok = rok + 12){ 
            podsuma += *rok;
        }
        printf(""%4.1f "", podsuma/LATA);
    }

    printf(""\n"");
    return 0;
}
",25,757,736
"#define FREE 17850
#define HEAD 23900
#define MARRIEDT 29750
#define MARRIEDS 14875
#define TAX1 0.15
#define TAX2 0.28

int main()
{
    int endProgram = 0;

    while(!endProgram) {

        int userCategory;
        float userIncome;
        float userTax;
        int userChoice;
        int valueOK = 0;

        while(!valueOK) {
            printf(""********************************************************************\n"");
            printf(""Wybierz odpowiednia opcje:\n"");
            printf(""1) Stan wolny\t\t\t2) Glowa rodziny\n"");
            printf(""3) Malzenstwo, wspolnie\t\t4) Malzenstwo, osobno\n"");
            printf(""5) wyjscie\n"");
            printf(""********************************************************************\n"");
            userChoice = getchar();

            switch (userChoice) {
                case '1' : {
                    userCategory = FREE;
                    printf(""Wybrano [Stan wolny]\n"");
                    valueOK = 1;
                    break;
                }
                case '2' : {
                    userCategory = HEAD;
                    printf(""Wybrano [Glowa rodziny]\n"");
                    valueOK = 1;
                    break;
                }
                case '3' : {
                    userCategory = MARRIEDT;
                    printf(""Wybrano [Malzenstwo, wspolnie]\n"");
                    valueOK = 1;
                    break;
                }
                case '4' : {
                    userCategory = MARRIEDS;
                    printf(""Wybrano [Malzenstwo, osobno]\n"");
                    valueOK = 1;
                    break;
                }
                case '5' : {
                    valueOK = 1;
                    endProgram = 1;
                    break;
                }
                default : fflush(stdin);
            }

        }

        if (!endProgram) {
            printf(""Podaj dochod podlegajacy opodatkowaniu: "");
            scanf(""%f"", &userIncome);
            if(userIncome <= userCategory){
                userTax = TAX1 * userIncome;
            } else {
                userTax = TAX1 * userCategory + (userIncome - userCategory) * TAX2;
            }
            printf(""Wysokosc naleznego podatku: %.2f$\n\n"", userTax);
            getchar();
        }
    }
    return 0;
}
",25,758,675
"void getNChars(int);

int main()
{
    int userNum;
    printf(""Podaj liczbe znakow.\n"");
    scanf(""%d"", &userNum);

    getNChars(userNum);

    printf(""\n------------------------------------------"");
    printf(""\nDziekuje. Dobranoc! To juz jest koniec!\n"");

    getchar();
    return 0;
}

void getNChars(int numOfChars) {
    char stringArray[numOfChars];
    fflush(stdin);
    printf(""Podaj znaki.\n"");
    for(int i = 0; i < numOfChars; i++) {
        stringArray[i] = getchar();
        if (strcmp(&stringArray[i], "" "") == 0 || strcmp(&stringArray[i], ""\t"") == 0 || strcmp(&stringArray[i], ""\n"") == 0) {
            printf(""\nNapotkano spacje, tabulator lub znak nowej linii!\n"");
            break;
        }
    }
    printf(""\nPodane znaki to: "");
    puts(stringArray);
};
",25,759,289
"int main()
{
    char userChar;
    char userNumberString[255];
    int userNumber;
    int counter = 0;

    printf(""Podaj liczbe calkowita: "");

    while((userChar = getchar()) != '\n') {
        userNumberString[counter] = userChar;
        counter++;
    }
    userNumber = atoi(userNumberString); 

    printf(""Liczby pierwsze podanej liczby: "");
    for(int i = 2; i <= userNumber; i++) {
        int primeCounter = 0;
        for(int j = 1; j <= i; j++){
            if(i % j == 0 ) {
                primeCounter++;
            }
        }
        if(primeCounter == 2){
            printf("" [%d]; "", i);
        }
    }

    getchar();
    return 0;
}
",25,760,223
"void wiersz_zn(char ch, int i, int j);

int main()
{
    char userChar;
    int charsInRow;
    int numberOfRows;

    printf(""Podaj znak: "");
    scanf(""%c"", &userChar);
    printf(""Podaj ilo\230\206 znak\242w w wierszu: "");
    scanf(""%d"", &charsInRow);
    printf(""Podaj liczb\251 wierszy: "");
    scanf(""%d"", &numberOfRows);

    wiersz_zn(userChar,charsInRow, numberOfRows);

    return 0;
}

void wiersz_zn(char ch, int i, int j) {
    putchar('\n');
    for(j; j > 0; j--){
        for(int k = i; k > 0; k--){
            putchar(ch);
        }
        putchar('\n');
    }
    return;
}
",25,761,250
"#include ""months.c""
#define MAXNAME 20
#define MAXABB 3

int numberOfDays(string);

int main()
{
    char userMonth[MAXNAME];

    printf(""Podaj nazwe miesiaca.\n"");
    printf(""Program wyswietli liczbe dni od poczatku roku do podanego miesiaca: "");
    scanf(""%s"", &userMonth);

    printf(""Liczba dni: %d"", numberOfDays(userMonth));

    getchar();
    return 0;
}

int numberOfDays(monthName){
    int error = 1; 
    int result = 0;
    for (int i = 0; i < 12; i++){
        result += months[i].days;
        if(strcmp(monthName, months[i].name) == 0){
            error = 0;
            break; 
        }
    }
    if(error == 1){
        result = 0;
    }
    return result;
};
",25,762,259
"int main()
{
    char ch;
    int oddSum = 0;
    int evenSum = 0;
    int oddCounter = 0;
    int evenCounter = 0;

    printf(""Podaj liczby ca\210kowite. '0' zako\344czy program!\n"");
    while((ch = getchar()) != '0') {
        if (isdigit(ch)){
            if ( ch % 2 == 0) {
                evenCounter++;
                evenSum += ch - '0'; 
            } else {
                oddCounter++;
                oddSum += ch - '0';
            }
        }
    }
    printf(""Liczb parzystych: %d\nSrednia warto\230\206: %d\n\n"", evenCounter, evenSum / evenCounter);
    printf(""Liczb nieparzystych: %d\nSrednia warto\230\206: %d\n"", oddCounter, oddSum / oddCounter);

    getchar();
    return 0;
}

",25,763,263
"int main()
{
    float num1, num2;
    int operation;
    float result;

    printf(""Podaj wartosc pierwszej liczby.\n"");
    scanf(""%f"", &num1);
    printf(""Podaj wartosc drugiej liczby.\n"");
    scanf(""%f"", &num2);

    printf(""Wybierz rodzaj operacji matematycznej.\n"");
    printf(""---------------------------------------\n"");
    printf(""1) Dodaj                   3) Pomnoz\n"");
    printf(""2) Odejmij                 4) Podziel\n"");
    scanf(""%d"", &operation);

    switch (operation) {
    case 1:
        result = num1 + num2;
        break;
    case 2:
        result = num1 - num2;
        break;
    case 3:
        result = num1 * num2;
        break;
    case 4:
        result = num1 / num2;
        break;
    }

    printf(""\nWynik: %.2f\n"", result);

    getchar();
    return 0;
}
",25,764,281
"int main()
{
    double userNumber;
    double numbersArray[3][5];
    char letterCollection;

    int licznik1 = 0;
    int licznik2 = 0;

    double sum, sumAll, biggestNumber;

    while(licznik1 < 3) {
        switch (licznik1){
            case 0:
                letterCollection = 'A';
            break;
            case 1:
                letterCollection = 'B';
            break;
            case 2:
                letterCollection = 'C';
            break;
        }
        printf(""Podaj liczbe nr %d dla zbioru %c: "", licznik2 + 1, letterCollection);
        scanf(""%lf"", &userNumber);
        numbersArray[licznik1][licznik2] = userNumber;
        licznik2++;
        if(licznik2 >= 5){
            licznik1++;
            licznik2 = 0;
        }
    }

    printf(""\n"");

    licznik1 = 0;
    licznik2 = 0;

    for(licznik1; licznik1 < 3; licznik1++){
            switch (licznik1){
            case 0:
                letterCollection = 'A';
            break;
            case 1:
                letterCollection = 'B';
            break;
            case 2:
                letterCollection = 'C';
            break;
        }
        for(licznik2; licznik2 < 5; licznik2++){
            printf(""%d liczba w zbiorze %c: %.2f\n"", licznik2 + 1, letterCollection, numbersArray[licznik1][licznik2]);
            sum += numbersArray[licznik1][licznik2];
            if(biggestNumber < numbersArray[licznik1][licznik2]){
               biggestNumber = numbersArray[licznik1][licznik2];
            }
        }
        licznik2 = 0;
        printf(""Srednia zbioru %c: %.2lf\n\n"", letterCollection, sum/5);
        sumAll += sum;
        sum = 0;
    }

    printf(""Srednia wszystkich zbior\242w: %.2lf\n"", sumAll/15);
    printf(""Najwi\251ksza liczba: %.2lf\n\n"", biggestNumber);
    return 0;
}
",25,765,586
"void sumElements(unsigned int, int * array1, int * array2, int * array3);

int main()
{
    int one[8] = {5, 6, 8, 8, 10, -2, 0, 121};
    int two[8] = {2, 1, 3, -4, 10, 21, 2, 233};
    int three[8];
    unsigned int naturalNumber = 8;

    printf(""Elementy tablicy1: "");
    for(int i = 0; i < (sizeof(one)/sizeof(one[0])); i++){
        printf(""%d "", one[i]);
    }
    printf(""\nElementy tablicy2: "");
    for(int i = 0; i < (sizeof(two)/sizeof(two[0])); i++){
        printf(""%d "", two[i]);
    }

    copyArrays(naturalNumber, one, two, three);

    printf(""\nElementy tablicy3: "");
    for(int i = 0; i < (sizeof(three)/sizeof(three[0])); i++){
        printf(""%d "", three[i]);
    }

    getchar();;
    return 0;
}

void copyArrays(unsigned int n, int * array1, int * array2, int * array3){
    int i = 0;
    for(i; i < n; i++){
        array3[i] = array1[i] + array2[i];
    }
};
",25,766,376
"float difference(float sourceArray[]);

int main()
{
   float array[10] = {8.2, 32, -4.56, 5.666, 6.32, 93, 345, -74.32, 424.23, -425.53, 89, 56};

    printf(""Roznica najwiekszej i najmniejszej wartosci, to: %.2f\n"", difference(array));

    return 0;
}

float difference(float sourceArray[]){
    int size = 12;
    float biggest;
    float smallest;
    float diff;
    for(int i = 0; i < size; i++){
        if(biggest < sourceArray[i]){
            biggest = sourceArray[i];
        }
        if(smallest > sourceArray[i]){
            smallest = sourceArray[i];
        }
    }

    diff = biggest - smallest;
    return diff;
};
",25,767,254
"#define BASICHOUR1 35
#define BASICHOUR2 37
#define BASICHOUR3 40
#define BASICHOUR4 45
#define OVERTIME 1.5
#define TAX1 0.15
#define TAX2 0.20
#define TAX3 0.25

int main()
{
    int userBasicHour;
    int workHours;
    float brutto;
    float podatek;
    int userChoice;
    int valueOK = 0;
    int endProgram = 0;

    while(!valueOK) {
        printf(""********************************************************************\n"");
        printf(""Podaj liczb\251 odpowiadaj\245c\245 zadanej stawce wynagrodzenia lub opcji:\n"");
        printf(""1) 35zl/godz.\t\t2) 37zl/godz.\n"");
        printf(""3) 40zl/godz.\t\t4) 45zl/godz.\n"");
        printf(""5) wyjscie\n"");
        printf(""********************************************************************\n"");
        userChoice = getchar();

        switch (userChoice) {
            case '1' : {
                userBasicHour = BASICHOUR1;
                printf(""Wybrano stawk\251 45zl/godz.\n"");
                valueOK = 1;
                break;
            }
            case '2' : {
                userBasicHour = BASICHOUR2;
                printf(""Wybrano stawk\251 45zl/godz.\n"");
                valueOK = 1;
                break;
            }
            case '3' : {
                userBasicHour = BASICHOUR3;
                printf(""Wybrano stawk\251 45zl/godz.\n"");
                valueOK = 1;
                break;
            }
            case '4' : {
                userBasicHour = BASICHOUR4;
                printf(""Wybrano stawk\251 45zl/godz.\n"");
                valueOK = 1;
                break;
            }
            case '5' : {
                valueOK = 1;
                endProgram = 1;
                break;
            }
            default : fflush(stdin);
        }

    }

    if (!endProgram) {
        printf(""Podaj liczb\251 przepracowanych godzin w tygodniu: "");
        scanf(""%d"", &workHours);

        if(workHours >= 40) {
            brutto = 40 * userBasicHour + (workHours - 40) * userBasicHour * OVERTIME;
        } else {
            brutto = workHours * userBasicHour;
        }

        if (brutto <= 1200) {
            podatek = brutto * TAX1;
        } else if (brutto > 1200 && brutto <= 1800) {
            podatek = 1200 * TAX1 + (brutto - 1200) * TAX2;
        } else {
            podatek = 1200 * TAX1 + (600) * TAX2 + (brutto - 1800) * TAX3;
        }

        printf(""\nWynagrodzenie brutto: %.2fz\210\n"", brutto);
        printf(""Podatek: %.2fz\210\n"", podatek);
        printf(""Wynagrodzenie netto: %.2fz\210\n"", brutto - podatek);

        getchar();
    }
    return 0;
}
",25,768,959
"int main()
{
    float a, b, c;
    float delta;
    float x1, x2;

    printf(""Podaj wartosc wspolczynnika a.\n"");
    scanf(""%f"", &a);
    printf(""Podaj wartosc wspolczynnika b.\n"");
    scanf(""%f"", &b);
    printf(""Podaj wartosc wspolczynnika c.\n"");
    scanf(""%f"", &c);

    if (a == 0) {
        x1 = -c/b;
        printf(""Rozwiazanie rownania: %.2f\n"", x1);
    } else {
        delta = b*b-4*a*c;
        if (delta < 0) {
           printf(""Rownanie nie ma rozwiazan w zbiorze liczb rzeczywistych.\n"");
        } else {
            x1 = (-b-delta)/(2*a);
            x2 = (-b+delta)/(2*a);
            printf(""x1 wynosi: %.2f\n"", x1);
            printf(""x2 wynosi: %.2f\n"", x2);
        }
    }

    getchar();
    return 0;
}
",25,769,306
"#define N_PARADAS 5

#define EN_RUTA 0

#define EN_PARADA 1

#define MAX_USUARIOS 40 
#define USUARIOS 4 


int estado= EN_RUTA;
int parada_actual = 0; 
int n_ocupantes= 0; 

int esperando_parada[N_PARADAS]; 

int esperando_bajar[N_PARADAS]; 



pthread_mutex_t esperaSubir[N_PARADAS];
pthread_mutex_t esperaBajar[N_PARADAS];

pthread_t hiloAutobus;

pthread_t usuarios[USUARIOS];

pthread_cond_t suben;
pthread_cond_t bajan;
pthread_cond_t hanSubido;
pthread_cond_t hanBajado;

int min(int num1, int num2){
    if(num1 < num2)
        return num1;
    else
        return num2;
}

void * thread_autobus(void * args) {
    while (1) {
    
        Autobus_En_Parada();
    
        Conducir_Hasta_Siguiente_Parada();
    }
}

void * thread_usuario(int i) {
    int id_usuario, a, b;
    id_usuario = i;

    while (1) {
        a=rand() % N_PARADAS;
        do{
            b=rand() % N_PARADAS;
        } while(a==b);

        printf(""Usuario %d se quiere subir en la parada %d y bajar en la %d \n"", id_usuario, a, b);
        Usuario(id_usuario,a,b);
    }
}

void Usuario(int id_usuario, int origen, int destino) {

    Subir_Autobus(id_usuario, origen);

    Bajar_Autobus(id_usuario, destino);
}

int main(int argc, char *argv[]) {
    int i;






    for(i=0; i < N_PARADAS; i++){
        pthread_mutex_init(&esperaSubir[i],NULL);
        pthread_mutex_init(&esperaBajar[i],NULL);
    }
    

    pthread_cond_init(&suben, NULL);
    pthread_cond_init(&bajan, NULL);
    pthread_cond_init(&hanSubido, NULL);
    pthread_cond_init(&hanBajado, NULL);
    

    pthread_create(&hiloAutobus, NULL, thread_autobus, NULL);
    

    for (i = 0; i < USUARIOS; i++)
        pthread_create(&usuarios[i], NULL, thread_usuario, (void *) i);



    pthread_join(hiloAutobus, NULL);

    for (i = 0; i < USUARIOS; i++)
        pthread_join(usuarios[i], NULL);

    for(i=0; i<N_PARADAS; i++){
        pthread_mutex_destroy(&esperaSubir[i]);
        pthread_mutex_destroy(&esperaBajar[i]);
    }

    
    pthread_cond_destroy(&suben);
    pthread_cond_destroy(&bajan);
    pthread_cond_destroy(&hanSubido);
    pthread_cond_destroy(&hanBajado);

    return 0;
}

void Autobus_En_Parada(){

    
    
    printf(""EL bus estÃ¡ en la parada %d \n"", parada_actual);
    estado = EN_PARADA;

    pthread_mutex_lock(&esperaSubir[parada_actual]);
    pthread_mutex_lock(&esperaBajar[parada_actual]);

    
    n_ocupantes -= esperando_bajar[parada_actual];
    
    
    int usuarios_suben = min(MAX_USUARIOS-n_ocupantes, esperando_parada[parada_actual]);
    n_ocupantes += usuarios_suben;
    
    
    pthread_cond_broadcast(&bajan);
    
    
    int j;
    for(j = 0; j < usuarios_suben; j++){
        
        
        
        pthread_cond_broadcast(&suben);
    }
    
    
    while(esperando_parada[parada_actual] > 0 || esperando_bajar[parada_actual] > 0){
        
        
        if(esperando_bajar[parada_actual] > 0 && esperando_parada[parada_actual] == 0)
            
            pthread_cond_wait(&hanBajado, &esperaBajar[parada_actual]);

        
        else if(esperando_bajar[parada_actual] == 0 && esperando_parada[parada_actual] > 0)
            
            pthread_cond_wait(&hanSubido, &esperaSubir[parada_actual]);
        
        
        else{
            
            pthread_mutex_unlock(&esperaSubir[parada_actual]);
            
            pthread_cond_wait(&hanBajado, &esperaBajar[parada_actual]);
            
            pthread_mutex_lock(&esperaSubir[parada_actual]);
        }

        
        
    }
    
    pthread_mutex_unlock(&esperaSubir[parada_actual]);
    pthread_mutex_unlock(&esperaBajar[parada_actual]);

    estado = EN_RUTA;
    printf(""El bus estÃ¡ en ruta \n"");
}

void Conducir_Hasta_Siguiente_Parada(){

    
    sleep((random() % 5)+1);
    parada_actual = (parada_actual + 1) % N_PARADAS;
}

void Subir_Autobus(int id_usuario, int origen){


    
    pthread_mutex_lock(&esperaSubir[origen]);
    esperando_parada[origen]++;

    
    while(parada_actual != origen || estado != EN_PARADA){
        pthread_cond_wait(&suben, &esperaSubir[origen]);
    }

    
    esperando_parada[origen]--;

    
    if(esperando_parada[origen] == 0)
        pthread_cond_signal(&hanSubido);

    printf(""Usuario %d se sube en la parada %d \n"", id_usuario, origen);
    
    
    pthread_mutex_unlock(&esperaSubir[origen]);
}

void Bajar_Autobus(int id_usuario, int destino){


    pthread_mutex_lock(&esperaBajar[destino]);
    esperando_bajar[destino]++;

    while(parada_actual != destino || estado != EN_PARADA){
        pthread_cond_wait(&bajan, &esperaBajar[destino]);
    }

    esperando_bajar[destino]--;

    if(esperando_bajar[destino] == 0)
        pthread_cond_signal(&hanBajado);
    
    printf(""Usuario %d se baja en la parada %d \n"", id_usuario, destino);
    pthread_mutex_unlock(&esperaBajar[destino]);
}",26,770,1968
"#include ""44b.h""
#include ""leds.h""
#include ""gpio.h""


#define LED1 0x01
#define LED2 0x02
#define BIT_LED1 9
#define BIT_LED2 10





static unsigned int status = 0;

void leds_init( void )
{
    
    

    portB_conf(BIT_LED1, OUTPUT);
    portB_conf(BIT_LED2, OUTPUT);

    leds_display( status );
}

void led1_on( void )
{
    status |=  LED1;
    leds_display( status );
}

void led1_off( void )
{
    status &=  ~LED1;
    leds_display( status );
}

void led2_on( void )
{
    status |=  LED2;
    leds_display( status );
}

void led2_off( void )
{
    status &=  ~LED2;
    leds_display( status );
}

void led1_switch( void )
{
    status ^= LED1;
    leds_display( status );
}

void led2_switch( void )
{
    status ^= LED2;
    leds_display( status );
}

void leds_switch( void ){
    status ^= (LED1 | LED2);
    leds_display( status );
}

void leds_display( unsigned int leds_status )
{
    status = leds_status;
    
    
    if( status & LED1 )
    {
        
        

        portB_write(BIT_LED1, LOW);
    }
    else
    {
        
        

        portB_write(BIT_LED1, HIGH);
    }

    
    if( status & LED2 )
    {
        
        

        portB_write(BIT_LED2, LOW);
    }
    else
    {
        
        

        portB_write(BIT_LED2, HIGH);
    }
}
",26,771,532
"#include ""myFS.h""







void copyNode(NodeStruct *dest, NodeStruct *src)
{
    int i;

    dest->numBlocks = src->numBlocks;
    dest->fileSize = src->fileSize;
    dest->modificationTime = src->modificationTime;
    dest->freeNode = src->freeNode;

    for(i = 0; i < MAX_BLOCKS_PER_FILE; i++)
        dest->blocks[i] = src->blocks[i];
}

int findFileByName(MyFileSystem *myFileSystem, char *fileName)
{
    int i;

    for(i = 0; i < MAX_FILES_PER_DIRECTORY; i++) {
        if(myFileSystem->directory.files[i].freeFile == false) {
            if(strcmp(fileName, myFileSystem->directory.files[i].fileName) == 0)
                return i;
        }
    }
    return -1;
}

int findFreeFile(MyFileSystem *myFileSystem)
{
    int i;
    for(i = 0; i < MAX_FILES_PER_DIRECTORY; i++) {
        if(myFileSystem->directory.files[i].freeFile == true)
            return i;
    }
    
    return -1;
}

int findFreeNode(MyFileSystem* myFileSystem)
{
    int i;
    for(i = 0; i < MAX_NODES; i++) {
        if(myFileSystem->nodes[i] == NULL)
            return i;
    }
    
    return -1;
}

int findNodeByPos(int nodeNum)
{
    int whichInodeBlock;
    int whichInodeInBlock;
    int inodeLocation;

    whichInodeBlock = nodeNum / NODES_PER_BLOCK;
    whichInodeInBlock = nodeNum % NODES_PER_BLOCK;

    inodeLocation = (NODES_IDX + whichInodeBlock) * BLOCK_SIZE_BYTES + whichInodeInBlock * sizeof(NodeStruct);
    return inodeLocation;
}

int initializeNodes(MyFileSystem *myFileSystem)
{
    int numNode;
    NodeStruct temp;

    
    for(numNode = 0; numNode < MAX_NODES; numNode++) {
        if(readNode(myFileSystem, numNode, &temp))
            return -1;
        
        if(temp.freeNode) {
            myFileSystem->nodes[numNode] = NULL;
        }
        
        else {
            if( (myFileSystem->nodes[numNode] = malloc(sizeof(NodeStruct)))==NULL) {
                perror(""Error in malloc"");
                return -2;
            }
            copyNode(myFileSystem->nodes[numNode], &temp);
            myFileSystem->numFreeNodes--;
        }
    }
    return 0;
}

void initializeSuperBlock(MyFileSystem *myFileSystem, int diskSize)
{
    myFileSystem->superBlock.diskSizeInBlocks = diskSize / BLOCK_SIZE_BYTES;
    myFileSystem->superBlock.numOfFreeBlocks = myQuota(myFileSystem);

    myFileSystem->superBlock.creationTime = time(NULL);

    myFileSystem->superBlock.blockSize = BLOCK_SIZE_BYTES;
    myFileSystem->superBlock.maxLenFileName = MAX_LEN_FILE_NAME;
    myFileSystem->superBlock.maxBlocksPerFile = MAX_BLOCKS_PER_FILE;
}

void myFree(MyFileSystem *myFileSystem)
{
    int i;
    close(myFileSystem->fdVirtualDisk);
    for(i = 0; i < MAX_NODES; i++) {
        free(myFileSystem->nodes[i]);
        myFileSystem->nodes[i] = NULL;
    }
}

int myMkfs(MyFileSystem *myFileSystem, int diskSize, char *backupFileName)
{
    
    myFileSystem->fdVirtualDisk = open(backupFileName, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);

    
    assert(sizeof(SuperBlockStruct) <= BLOCK_SIZE_BYTES);
    assert(sizeof(DirectoryStruct) <= BLOCK_SIZE_BYTES);
    int numBlocks = diskSize / BLOCK_SIZE_BYTES;
    int minNumBlocks = 3 + MAX_BLOCKS_WITH_NODES + 1;
    int maxNumBlocks = NUM_BITS;
    if(numBlocks < minNumBlocks) {
        return -1;
    }
    if(numBlocks >= maxNumBlocks) {
        return -2;
    }

    
    
    int i;
    for(i = 0; i < NUM_BITS; i++) {
        myFileSystem->bitMap[i] = 0;
    }

    
    myFileSystem->bitMap[BITMAP_IDX] = 1;
    myFileSystem->bitMap[SUPERBLOCK_IDX] = 1;
    myFileSystem->bitMap[DIRECTORY_IDX] = 1;
    
    for(i = 3; i < 3 + MAX_BLOCKS_WITH_NODES; i++) {
        myFileSystem->bitMap[i] = 1;
    }
    updateBitmap(myFileSystem);

    
    
    myFileSystem->directory.numFiles = 0;
    for(i = 0; i < MAX_FILES_PER_DIRECTORY; i++) {
        myFileSystem->directory.files[i].freeFile = 1;
    }
    updateDirectory(myFileSystem);

    
    NodeStruct currentNode;
    currentNode.freeNode = 1;
    for(i = 0; i < MAX_NODES; i++) {
        updateNode(myFileSystem, i, &currentNode);
    }

    
    initializeSuperBlock(myFileSystem, diskSize);
    updateSuperBlock(myFileSystem);
    sync();

    
    assert(myQuota(myFileSystem) >= 1);

    if(initializeNodes(myFileSystem)) {
        myFree(myFileSystem);
        return -3;
    }

    printf(""SF: %s, %d B (%d B/block), %d blocks\n"", backupFileName, diskSize, BLOCK_SIZE_BYTES, numBlocks);
    printf(""1 block for SUPERBLOCK (%u B)\n"", (unsigned int)sizeof(SuperBlockStruct));
    printf(""1 block for BITMAP, covering %u blocks, %u B\n"", (unsigned int)NUM_BITS, (unsigned int)(NUM_BITS * BLOCK_SIZE_BYTES));
    printf(""1 block for DIRECTORY (%u B)\n"", (unsigned int)sizeof(DirectoryStruct));
    printf(""%d blocks for inodes (%u B/inode, %u inodes)\n"", MAX_BLOCKS_WITH_NODES, (unsigned int)sizeof(NodeStruct), (unsigned int)MAX_NODES);
    printf(""%d blocks for data (%d B)\n"", myFileSystem->superBlock.numOfFreeBlocks, BLOCK_SIZE_BYTES * myFileSystem->superBlock.numOfFreeBlocks);
    printf(""Formatting completed!\n"");

    return 0;
}

int myQuota(MyFileSystem *myFileSystem)
{
    int freeCount = 0;
    int i;
    
    for(i = 0; i < myFileSystem->superBlock.diskSizeInBlocks; i++) {
        
        
        if(myFileSystem->bitMap[i] == 0) {
            freeCount++;
        }
    }
    return freeCount;
}

int readNode(MyFileSystem *myFileSystem, int nodeNum, NodeStruct* node)
{
    int posNode;
    assert(nodeNum < MAX_NODES);
    posNode = findNodeByPos(nodeNum);

    if( lseek(myFileSystem->fdVirtualDisk, posNode, SEEK_SET)==-1 ||
        read(myFileSystem->fdVirtualDisk, node, sizeof(NodeStruct)) != sizeof(NodeStruct) ) {
        perror(""Error when reading an inode"");
        return -1;
    }
    return 0;
}

int reserveBlocksForNodes(MyFileSystem *myFileSystem, DISK_LBA blocks[], int numBlocks)
{
    int i = 0;
    int currentBlock = 0;

    while((currentBlock < numBlocks) && (i < NUM_BITS)) {
        if(myFileSystem->bitMap[i] == 0) {
            myFileSystem->bitMap[i] = 1;
            blocks[currentBlock] = i;
            currentBlock++;
        }
        ++i;
    }

    return (i==NUM_BITS)?-1:0;
}

int updateBitmap(MyFileSystem *myFileSystem)
{
    if(lseek(myFileSystem->fdVirtualDisk, BLOCK_SIZE_BYTES * BITMAP_IDX, SEEK_SET) == (off_t) - 1) {
        perror(""Failed lseek in updateBitmap"");
        return -1;
    }
    if(write(myFileSystem->fdVirtualDisk,
             myFileSystem->bitMap, sizeof(BIT) * NUM_BITS) == -1) {
        perror(""Failed write in updateBitmap"");
        return -1;
    }
    sync();
    return 0;
}

int updateDirectory(MyFileSystem *myFileSystem)
{
    if(lseek(myFileSystem->fdVirtualDisk, BLOCK_SIZE_BYTES * DIRECTORY_IDX, SEEK_SET) == (off_t) - 1) {
        perror(""Failed lseek in updateDirectory"");
        return -1;
    }
    if(write(myFileSystem->fdVirtualDisk, &(myFileSystem->directory), sizeof(DirectoryStruct)) == -1) {
        perror(""Failed write in updateDirectory"");
        return -1;
    }
    sync();
    return 0;
}

int updateNode(MyFileSystem *myFileSystem, int numNode, NodeStruct *node)
{
    int posNodoI;
    assert(numNode < MAX_NODES);
    posNodoI = findNodeByPos(numNode);

    if(lseek(myFileSystem->fdVirtualDisk, posNodoI, SEEK_SET) == (off_t) - 1) {
        perror(""Failed lseek in updateNode"");
        return -1;
    }
    if(write(myFileSystem->fdVirtualDisk, node, sizeof(NodeStruct)) == -1) {
        perror(""Failed write in updateNode"");
    }
    sync();
    return 0;
}


int updateSuperBlock(MyFileSystem *myFileSystem)
{
    if(lseek(myFileSystem->fdVirtualDisk, BLOCK_SIZE_BYTES * SUPERBLOCK_IDX, SEEK_SET) == (off_t) - 1) {
        perror(""Failed lseek in updateSuperBlock"");
        return -1;
    }
    if(write(myFileSystem->fdVirtualDisk, &(myFileSystem->superBlock), sizeof(SuperBlockStruct)) == -1) {
        perror(""Failed write in updateSuperBlock"");
        return -1;
    }
    sync();
    return 0;
}



int readBitmap(MyFileSystem *myFileSystem)
{
    return -1;
}



int readDirectory(MyFileSystem* myFileSystem)
{
    return -1;
}


int readSuperblock(MyFileSystem* myFileSystem)
{
    return -1;
}

int readInodes(MyFileSystem* myFileSystem)
{
    return -1;
}

int myMount(MyFileSystem *myFileSystem, char *backupFileName)
{
    if ((myFileSystem->fdVirtualDisk = open(backupFileName, O_RDWR))==-1) {
        perror(backupFileName);
        return 1;
    }

    if (readBitmap(myFileSystem)!=0) {
        fprintf(stderr,""Can't read bitmap\n"");
        return 2;
    }

    if (readSuperblock(myFileSystem)!=0) {
        fprintf(stderr,""Can't read superblock\n"");
        return 3;
    }

    if (readInodes(myFileSystem)!=0) {
        fprintf(stderr,""Can't read inodes\n"");
        return 4;
    }

    if (readDirectory(myFileSystem)!=0) {
        fprintf(stderr,""Can't read directory\n"");
        return 5;
    }

    printf(""SF: %s, %d B (%d B/block), %d blocks\n"", backupFileName, myFileSystem->superBlock.diskSizeInBlocks*BLOCK_SIZE_BYTES, BLOCK_SIZE_BYTES, myFileSystem->superBlock.diskSizeInBlocks);
    printf(""1 block for SUPERBLOCK (%u B)\n"", (unsigned int)sizeof(SuperBlockStruct));
    printf(""1 block for BITMAP, covering %u blocks, %u B\n"", (unsigned int)NUM_BITS, (unsigned int)(NUM_BITS * BLOCK_SIZE_BYTES));
    printf(""1 block for DIRECTORY (%u B)\n"", (unsigned int)sizeof(DirectoryStruct));
    printf(""%d blocks for inodes (%u B/inode, %u inodes)\n"", MAX_BLOCKS_WITH_NODES, (unsigned int)sizeof(NodeStruct), (unsigned int)MAX_NODES);
    printf(""%d blocks for data (%d B)\n"", myFileSystem->superBlock.numOfFreeBlocks, BLOCK_SIZE_BYTES * myFileSystem->superBlock.numOfFreeBlocks);
    printf(""Volume mounted successfully!\n"");
    return 0;
}

int readBlock(MyFileSystem *myFileSystem, DISK_LBA blockNumber, void *buffer)
{

    if(blockNumber < 0 || blockNumber >= myFileSystem->superBlock.diskSizeInBlocks) {
        fprintf(stderr,""Firts bocks to be read must be between 0 and %d\n"", myFileSystem->superBlock.diskSizeInBlocks-1);
        return -1;
    }

    if( lseek(myFileSystem->fdVirtualDisk, blockNumber*BLOCK_SIZE_BYTES, SEEK_SET) == (off_t)-1 ) {
        perror(""Failed lseek in readBlock()"");
        return -1;
    }
    if( read(myFileSystem->fdVirtualDisk, buffer, BLOCK_SIZE_BYTES) != BLOCK_SIZE_BYTES ) {
        perror(""Failed read in readBlock()"");
    }
    return 0;
}

int writeBlock(MyFileSystem *myFileSystem, DISK_LBA blockNumber, void *buffer)
{

    if(blockNumber < 0 || blockNumber >= myFileSystem->superBlock.diskSizeInBlocks) {
        fprintf(stderr,""Firts bocks to be read must be between 0 and %d\n"", myFileSystem->superBlock.diskSizeInBlocks-1);
        return -1;
    }

    if( lseek(myFileSystem->fdVirtualDisk, blockNumber*BLOCK_SIZE_BYTES, SEEK_SET) == (off_t)-1 ) {
        perror(""Lseek failed in writeBlock()"");
        return -1;
    }
    if( write(myFileSystem->fdVirtualDisk, buffer, BLOCK_SIZE_BYTES) != BLOCK_SIZE_BYTES ) {
        perror(""Write failed in writeBlock()"");
    }
    return 0;
}",26,772,4007
"#include ""44b.h""
#include ""intcontroller.h""

void ic_init(void)
{
    
    rINTMOD = 0x0; 
    rINTCON = 0x7; 
    rINTMSK = ~(0x0); 
}

int ic_conf_irq(enum enable st, enum int_vec vec)
{
    int conf = rINTCON;

    if (st != ENABLE && st != DISABLE)
        return -1;

    if (vec == VEC)
        
        conf &= ~(1 <<2);

    else
        conf |= (1 << 2);
        

    if (st == ENABLE)
        conf &= ~(1 << 1);
        
    else
        conf |= (1 << 1);
        

    rINTCON = conf;
    return 0;
}

int ic_conf_fiq(enum enable st)
{
    int ret = 0;

    if (st == ENABLE)
        rINTCON &= ~1;
        
    else if (st == DISABLE)
        rINTCON |= 1;
        
    else
        ret = -1;

    return ret;
}

int ic_conf_line(enum int_line line, enum int_mode mode)
{
    unsigned int bit = INT_BIT(line);

    if (line < 0 || line > 26)
        return -1;

    if (mode != IRQ && mode != FIQ)
        return -1;

    if (mode == IRQ)
        
        rINTMOD &= ~bit;

    else
        
        rINTMOD |= bit;
    return 0;
}

int ic_enable(enum int_line line)
{
    if (line < 0 || line > 26)
        return -1;
    rINTMSK &= ~(1 << line);
    

    return 0;
}

int ic_disable(enum int_line line)
{
    if (line < 0 || line > 26)
        return -1;

    rINTMSK |= (1 << line);
    
    
    return 0;
}

int ic_cleanflag(enum int_line line)
{
    int bit;

    if (line < 0 || line > 26)
        return -1;

    bit = INT_BIT(line);

    if (rINTMOD & bit)
        
        
        rF_ISPC |= bit;
    else
        rI_ISPC |= bit;
        
        
    return 0;
}



",26,773,661
"int main(int argc, char* argv[])
{
    
    if (argc!=2){
        fprintf(stderr, ""Usage: %s <command>\n"", argv[0]);
        exit(1);
    }

    return system(argv[1]);
}


int system(const char * command){
    int ret = -1;

    
    int pid = fork();

    
    if(pid == -1)
        fprintf(stderr, ""Fallo fork\n"");

    
    else if(pid == 0)
        execlp(""/bin/bash"", ""bash"", ""-c"", command, (char*) NULL);
    
    
    
    else{
        wait(&ret);
        ret = WEXITSTATUS(ret);
    }
}",26,774,192
"#include ""44b.h""
#include ""timer.h""

int tmr_set_prescaler(int p, int  value)
{
    int offset = p*8;
    value &= 0xFF;

    if (p < 0 || p > 3)
        return -1;

    
    
    
    value <<= offset;
    
    rTCFG0 |= value;

    return 0;
}

int tmr_set_divider(int d, enum tmr_div div)
{
    int ret = 0;
    int pos = d*4;

    if ((d < 0 || d > 5) ||
            (div == D1_32 && d > 3) ||
            (div == EXTCLK && d != 5) ||
            (div == TCLK && d != 4))
        return -1;

    if (div == EXTCLK || div == TCLK)
        div = 4;

    
    
    
    unsigned int b = div;
    b <<= pos;

    rTCFG1 |= b;

    return 0;
}

int tmr_set_count(enum tmr_timer t, int count, int cmp)
{
    int err = 0;
    switch (t) {
        case TIMER0:
            
            
            
            
            rTCNTB0 = count;
            rTCMPB0 = cmp;
             break;
        case TIMER1:
            
            
            
            
            rTCNTB1 = count;
            rTCMPB1 = cmp;
             break;
        case TIMER2:
            
            
            
            
            rTCNTB2 = count;
            rTCMPB2 = cmp;
             break;
        case TIMER3:
            
            
            
            
            rTCNTB3 = count;
            rTCMPB3 = cmp;
             break;
        case TIMER4:
            
            
            
            
            rTCNTB4 = count;
            rTCMPB4 = cmp;
             break;
        case TIMER5:
            
            
            
            rTCNTB5 = count;
             break;
        default:
            err = -1;
    }

    return err;
}

int tmr_update(enum tmr_timer t)
{
    int pos = t*4;
    if (t > 0)
        pos += 4;

    if (t < 0 || t > 5)
        return -1;

    
    
    
    
    unsigned int b = 1;
    b <<= pos + 1; 
    
    rTCON |= b;
    rTCON &= ~b;

    return 0;
}

int tmr_set_mode(enum tmr_timer t, enum tmr_mode mode)
{
    int err = 0;
    int pos = t*4;
    if (t > 0)
        pos += 4;

    if (t < 0 || t > 5)
        return -1;

    if (mode == ONE_SHOT)
    {
        
        
        
        unsigned int b = 1;
        b <<= pos + 4;

        rTCON &= ~b;
    }
    else if (mode == RELOAD)
    {
        
        
        
        unsigned int b = 1;
        b <<= pos + 4;

        rTCON |= b;
    }
    else
        err = -1;

    return err;
}

int tmr_start(enum tmr_timer t)
{
    int pos = t*4;
    if (t > 0)
        pos += 4;

    if (t < 0 || t > 5)
        return -1;

    
    
    
    unsigned int b = 1;
    b <<= pos;

    rTCON |= b;
    return 0;
}

int tmr_stop(enum tmr_timer t)
{
    int pos = t*4;
    if (t > 0)
        pos += 4;

    if (t < 0 || t > 5)
        return -1;

    
    
    
    unsigned int b = 1;
    b <<= pos;

    rTCON &= ~b;
    return 0;
}

int tmr_isrunning(enum tmr_timer t)
{
    int ret = 0;
    int pos = t*4;
    if (t > 0)
        pos += 4;

    if ((t >= 0) && (t <= 5) 
            && (rTCON & (0x1 << pos)))
        ret = 1;

    return ret;
}

",26,775,1219
"#include ""44b.h""
#include ""button.h""
#include ""leds.h""
#include ""utils.h""
#include ""D8Led.h""
#include ""gpio.h""

struct RLstat {
    int moving;
    int speed;
    int iter;
    int direction;
    int position;
};

static struct RLstat RL = {
    .moving = 0,
    .speed = 5,
    .iter = 0,
    .direction = 0,
    .position = 0,
};

int setup(void)
{
    leds_init();
    D8Led_init();
    D8Led_segment(RL.position);

    

    
    
    
    
    

    Delay(0);
    return 0;
}

int loop(void)
{
    unsigned int buttons = read_button();

    if (buttons & BUT1) {
        
        
        
        
    }

    if (buttons & BUT2) {
        
        
        
        
        
        
    }

    if (RL.moving) {
        RL.iter--;
        if (RL.iter == 0) {
            
            
            
            
            
            
            
        }
    }

    Delay(2000); 
    return 0;
}


int main(void)
{
    setup();

    while (1) {
        loop();
    }
}
",26,776,384
"struct t_dummy {
    char cx;
    char cy;
    int lat;
    int longitud;
};
struct t_dummy st;

unsigned int tabla[8]= { 0x1, 0x3, 0x5, 0x7, 0x9, 0xB, 0xD, 0xF };


#define LED1 0x01
#define LED2 0x02
static unsigned int status = 0;


unsigned int * puntero;
char str_tecla[27] = ""\nTecla pulsada\0"";;
char * puntero2;

int main() {

    st.cx = 1;
    st.cy = 2;
    st.lat = 3;
    st.longitud = 4;

    status |=  LED1;
    status &=  ~LED1;
    status ^= (LED1 | LED2);
    status = (tabla[7]<< 4 ) | tabla [2] | (tabla[4]<<8);
    status  = (status & ~(0xf << 12)) | (0x7 << 12);

    puntero = tabla;
    puntero++;

    puntero2 = str_tecla;
    return 0;
}
",26,777,323
"#include ""44b.h""
#include ""button.h""
#include ""leds.h""
#include ""utils.h""
#include ""D8Led.h""
#include ""intcontroller.h""
#include ""timer.h""
#include ""gpio.h""
#include ""keyboard.h""

struct RLstat {
    int moving;
    int speed;
    int direction;
    int position;
};

static struct RLstat RL = {
    .moving = 0,
    .speed = 5,
    .direction = 0,
    .position = 0,
};

void timer_ISR(void) __attribute__ ((interrupt (""IRQ"")));
void button_ISR(void) __attribute__ ((interrupt (""IRQ"")));


void timer_ISR(void)
{
    
    if (RL.direction == 1) 
    {
        if (RL.position + 1 < 6)
        {
            RL.position += 1;
        }
        else
        {
            RL.position = 0;
        }
    }
    else
    {
        if (RL.position - 1 >= 0)
        {
            RL.position -= 1;
        }
        else
        {
            RL.position = 5;
        }
    }

    D8Led_segment(RL.position);
}

void button_ISR(void)
{
    unsigned int whicheint = rEXTINTPND;
    unsigned int buttons = (whicheint >> 2) & 0x3;

    
    

    if (buttons & ~BUT1) {
        
        
        
        

        led1_off();
        led2_off();

        if(RL.direction == 0)
        {
            RL.direction = 1;
        }
        else
        {
            RL.direction = 0;
        }
    }

    if (buttons & ~BUT2) {
        
        
        
        
        
        

        led1_switch();

        led2_switch();


        if (RL.moving == 0)
        {
            RL.moving= 1;
        }
        else
        {
            RL.moving= 0;
        }
    }

    
    Delay(2000);
    
    rEXTINTPND &= ~(0x03 << 2);
            
            
            
}













































int setup(void)
{
    ic_enable(INT_GLOBAL);

    leds_init();
    D8Led_init();
    D8Led_segment(RL.position);

    

    
    
    
    

    portG_conf(6, EINT);
    portG_conf(7, EINT);
    portG_conf(1, EINT);

    portG_conf_pup(6, ENABLE);
    portG_conf_pup(7, ENABLE);
    portG_conf_pup(1, ENABLE);
    

    
    tmr_set_prescaler(TIMER0, 255);
    tmr_set_divider(8, TIMER0);
    tmr_set_count(TIMER0, 62500, 1);

    if (RL.moving)
        tmr_start(TIMER0);
    

    
    pISR_TIMER0   = timer_ISR; 
    pISR_EINT4567 = button_ISR; 
    

    
    ic_conf_irq(ENABLE, VEC);
    ic_conf_fiq(DISABLE);
    ic_conf_line(INT_TIMER0, IRQ);
    ic_conf_line(INT_EINT4567, IRQ);
    ic_conf_line(INT_EINT1, IRQ);
    ic_enable(INT_TIMER0);
    ic_enable(INT_EINT4567);
    ic_enable(INT_EINT1);

    ic_init();
    
    
    
    
    
    
    
    
    
    ic_conf_irq(ENABLE, VEC);
    ic_conf_fiq(DISABLE);
    ic_conf_line(INT_TIMER0, IRQ);
    ic_conf_line(INT_EINT4567, IRQ);
    ic_conf_line(INT_EINT1, IRQ);
    ic_enable(INT_TIMER0);
    ic_enable(INT_EINT4567);
    ic_enable(INT_EINT1);
    

    Delay(0);
    return 0;
}

int loop(void)
{
    return 0;
}


int main(void)
{
    setup();

    while (1) {
        loop();
    }
}
",26,778,1289
"MODULE_LICENSE(""GPL"");


int init_module(void);
void cleanup_module(void);
static int device_open(struct inode *, struct file *);
static int device_release(struct inode *, struct file *);
static ssize_t device_read(struct file *, char *, size_t, loff_t *);
static ssize_t device_write(struct file *, const char *, size_t, loff_t *);


#define SUCCESS 0

#define DEVICE_NAME ""chardev_leds""  
#define BUF_LEN 80


dev_t start;


struct cdev* chardev=NULL;


static int Device_Open = 0;




static char *leidos_Ptr = NULL;


static struct file_operations fops = {
    .read = device_read,
    .write = device_write,
    .open = device_open,
    .release = device_release
};


struct tty_driver* kbd_driver= NULL;


struct tty_driver* get_kbd_driver_handler(void)
{
    printk(KERN_INFO ""modleds: loading\n"");
    printk(KERN_INFO ""modleds: fgconsole is %x\n"", fg_console);
#if ( LINUX_VERSION_CODE > KERNEL_VERSION(2,6,32) )
    return vc_cons[fg_console].d->port.tty->driver;
#else
    return vc_cons[fg_console].d->vc_tty->driver;
#endif
}


static inline int set_leds(struct tty_driver* handler, unsigned int mask)
{
#if ( LINUX_VERSION_CODE > KERNEL_VERSION(2,6,32) )
    return (handler->ops->ioctl) (vc_cons[fg_console].d->port.tty, KDSETLED,mask);
#else
    return (handler->ops->ioctl) (vc_cons[fg_console].d->vc_tty, NULL, KDSETLED, mask);
#endif
}


int init_module(void)
{
    int major;      
    int minor;      
    int ret;

    
    
    
    if ((ret=alloc_chrdev_region (&start, 0, 1,DEVICE_NAME))) {
        printk(KERN_INFO ""Can't allocate chrdev_region()"");
        return ret;
    }

    
    if ((chardev=cdev_alloc())==NULL) {
        printk(KERN_INFO ""cdev_alloc() failed "");
        unregister_chrdev_region(start, 1);
        return -ENOMEM;
    }

    
    cdev_init(chardev,&fops);

    
    if ((ret=cdev_add(chardev,start,1))) {
        printk(KERN_INFO ""cdev_add() failed "");
        kobject_put(&chardev->kobj);
        unregister_chrdev_region(start, 1);
        return ret;
    }

    
    kbd_driver= get_kbd_driver_handler();

    major=MAJOR(start);
    minor=MINOR(start);

    
    printk(KERN_INFO ""I was assigned major number %d. To talk to\n"", major);
    printk(KERN_INFO ""the driver, create a dev file with\n"");
    
    
    
    
    
    
    printk(KERN_INFO ""'sudo mknod -m 666 /dev/%s c %d %d'.\n"", DEVICE_NAME, major,minor);
    printk(KERN_INFO ""Try to cat and echo to the device file.\n"");
    printk(KERN_INFO ""Remove the device file and module when done.\n"");

    return SUCCESS;
}


void cleanup_module(void)
{
    
    if (chardev)
        cdev_del(chardev);

    
    set_leds(kbd_driver,0);
    
    unregister_chrdev_region(start, 1);
}


static int device_open(struct inode *inode, struct file *file)
{
    if (Device_Open){
        printk(KERN_ALERT ""El dispositivo ya esaba abierto"");
        return -EBUSY;
    }

    
    Device_Open++;
    printk(KERN_INFO ""Se acaba de abrir el dispositivo\n"");

    
    
    try_module_get(THIS_MODULE);

    return SUCCESS;
}


static int device_release(struct inode *inode, struct file *file)
{
    Device_Open--;      

    
    module_put(THIS_MODULE);
    printk(KERN_INFO ""El dispositivo se acaba de cerrar\n"");

    return 0;
}


static ssize_t device_read(struct file *filp,   
                           char *buffer,    
                           size_t length,   
                           loff_t * offset)
{
    printk(KERN_ALERT ""Sorry, this operation isn't supported.\n"");
    return -EPERM;
}






static ssize_t device_write(struct file *filp, const char *buff, size_t len, loff_t * off){
    int bytes_to_write = len;

    

    printk(KERN_INFO ""Longitud: %d\n"", len);

    printk(KERN_INFO ""Estamos en el write\n"");

    
    
    
    leidos_Ptr = (char *) vmalloc(len);

    
    if(copy_from_user(leidos_Ptr, buff, bytes_to_write))
        return -EFAULT;

    
    unsigned int mask = 0;

    
    int encender_numLock = 0;
    int encender_capsLock = 0;
    int encender_scrollLock = 0;

    
    
    int i = 0;
    while (i < len){
        if (*leidos_Ptr == '1'){
            encender_numLock = 2;
        }
        else if (*leidos_Ptr == '2'){
            encender_capsLock = 4;
        }
        else if (*leidos_Ptr == '3'){
            encender_scrollLock = 1;
        }
        else{
            
            
        }
        printk(KERN_INFO ""Leido: %c \n"", *leidos_Ptr);
        leidos_Ptr++;
        i++;
    }

    
    mask = encender_numLock+encender_capsLock+encender_scrollLock;
    printk(KERN_INFO ""Mascara: %d \n"", mask);

    
    set_leds(kbd_driver,mask);

    
    return bytes_to_write;
}",26,779,1781
"#include ""44b.h""
#include ""leds.h""
#include ""gpio.h""


#define LED1 0x01
#define LED2 0x02
#define BIT_LED1 9
#define BIT_LED2 10





static unsigned int status = 0;

void leds_init( void )
{
    
    

    leds_display( status );
}

void led1_on( void )
{
    status |=  LED1;
    leds_display( status );
}

void led1_off( void )
{
    status &=  ~LED1;
    leds_display( status );
}

void led2_on( void )
{
    status |=  LED2;
    leds_display( status );
}

void led2_off( void )
{
    status &=  ~LED2;
    leds_display( status );
}

void led1_switch( void )
{
    status ^= LED1;
    leds_display( status );
}

void led2_switch( void )
{
    status ^= LED2;
    leds_display( status );
}

void leds_switch( void ){
    status ^= (LED1 | LED2);
    leds_display( status );
}

void leds_display( unsigned int leds_status )
{
    status = leds_status;
    
    
    if( status & LED1 )
        
        
    else
        
        

    
    if( status & LED2 )
        
        
    else
        
        
}
",26,780,411
"#include ""fuseLib.h""
#include ""myFS.h""





MyFileSystem myFileSystem;

#define USAGE           ""Usage: %s -t diskSize -a backupFileName -f 'fuse options'\n""
#define EXAMPLE     ""Example:\n%s -t 2097152 -a virtual-disk -f '-d -s mount-point'\n""
#define EXAMPLE2    ""Example:\n%s -m -a <virtual-disk> -f '-d -s mount-point'\n""

int main(int argc, char **argv)
{
    myFileSystem.numFreeNodes = MAX_NODES;

    int ret; 

    int opt, diskSize = -1;
    char *backupFileName = NULL;
    char *argsFUSE = NULL;

    char *argvNew[MAX_FUSE_NARGS];
    char *pTmp;
    int mount=0;

    while((opt = getopt(argc, argv, ""t:a:f:m"")) != -1) {
        switch(opt) {
        case 't':
            diskSize = atoi(optarg);
            break;
        case 'a':
            backupFileName = optarg;
            break;
        case 'f':
            argsFUSE = optarg;
            break;
        case 'm':
            mount=1;
            break;
        default: 
            fprintf(stderr, USAGE, argv[0]);
            fprintf(stderr, EXAMPLE, argv[0]);
            exit(-1);
        }
    }

    if (!mount) {
        
        if(diskSize == -1 || backupFileName == NULL || argsFUSE == NULL) {
            fprintf(stderr, USAGE, argv[0]);
            fprintf(stderr, EXAMPLE, argv[0]);
            exit(-1);
        }

        
        ret = myMkfs(&myFileSystem, diskSize, backupFileName);
    } else {
        
        if(backupFileName == NULL || argsFUSE == NULL) {
            fprintf(stderr, USAGE, argv[0]);
            fprintf(stderr, EXAMPLE2, argv[0]);
            exit(-1);
        }
        
        ret = myMount(&myFileSystem, backupFileName);
    }

    if(ret) {
        fprintf(stderr, ""Unable to format or mount, error code: %d\n"", ret);
        exit(-1);
    }
    fprintf(stderr, ""File system available\n"");

    
    argc = 1;
    argvNew[0] = argv[0];

    pTmp = strtok(argsFUSE, "" "");
    while(pTmp && argc < MAX_FUSE_NARGS) {
        argvNew[argc++] = pTmp;
        pTmp = strtok(0, "" "");
    }

    
    if((ret = fuse_main(argc, argvNew, &myFS_operations, NULL))) {
        fprintf(stderr, ""Error when mounting the FUSE file system\n"");
        return(ret);
    }

    myFree(&myFileSystem);

    return(0);
}
",26,781,812
"#include ""mytar.h""

extern char *use;



int copynFile(FILE * origin, FILE * destination, int nBytes){
    
    
    char* c = (char*) malloc(nBytes * sizeof(char));

    
    int n = fread(c, sizeof(char), nBytes, origin);

    
    fwrite(c, sizeof(char), n, destination);

    
    free(c);

    
    return n;
}



char* loadstr(FILE * file){

    
    int counter = 0;

    
    while(getc(file) != '\0')
        counter++;

    
    fseek(file, -(counter + 1), SEEK_CUR);

    
    char* c = (char*) malloc(counter * sizeof(char));

    
    fread(c, sizeof(char), counter + 1, file);

    
    return c;
}



stHeaderEntry* readHeader(FILE * tarFile, int *nFiles){

    
    fread(nFiles, sizeof(int), 1, tarFile);

    
    stHeaderEntry* pair = (stHeaderEntry*) malloc(sizeof(stHeaderEntry) * (*nFiles));

    
    for(int i = 0; i < *nFiles; i++){
        
        pair[i].name = loadstr(tarFile);
        
        fread(&(pair[i].size), sizeof(int), 1, tarFile);
    }

    
    return pair;
}



int createTar(int nFiles, char *fileNames[], char tarName[]){

    
    FILE * f = fopen(tarName, ""w"");

    
    int headerSize = sizeof(int);
    for(int i = 0; i < nFiles; i++)
        headerSize += strlen(fileNames[i]) + 1 + sizeof(int);

    
    fseek(f, headerSize, SEEK_SET);

    
    int* fileSizes = (int*) malloc(nFiles * sizeof(int));
    
    
    for(int i = 0; i < nFiles; i++){
        
        FILE * a = fopen(fileNames[i], ""r"");
        
        int t = copynFile(a, f, 100);
        
        fileSizes[i] = 0;
        while(t != 0){
            
            fileSizes[i] += t;
            
            t = copynFile(a, f, 100);
        }
        
        fclose(a);
    }
    
    
    fseek(f, 0, SEEK_SET);

    
    fwrite(&nFiles, sizeof(int), 1, f);

    
    for(int i = 0; i < nFiles; i++){
        
        fwrite(fileNames[i], sizeof(char), strlen(fileNames[i]) + 1, f);
        
        fwrite(&fileSizes[i], sizeof(int), 1, f);
    }

    
    fclose(f);
    
    free(fileSizes);

    
    return EXIT_SUCCESS;
}



int extractTar(char tarName[]){

    
    FILE * f = fopen(tarName, ""r"");

    
    int nFiles;
    stHeaderEntry* s = readHeader(f, &nFiles);

    
    for(int i = 0; i < nFiles; i++){
        
        FILE * a = fopen(s[i].name, ""w"");
        
        copynFile(f, a, s[i].size);
        
        fclose(a);
    }

    
    fclose(f);
    
    return EXIT_SUCCESS;
}
",26,782,949
"#define PATH ""/dev/chardev_leds""

int main(int argc, char * argv[]){
    
    if (argc!=2){
        fprintf(stderr, ""Uso: %s cont_binario/rotativo (Elegir uno de los dos modos)\n"", argv[0]);
        exit(1);
    }

    
    FILE * file = fopen(PATH, ""r+"");
    if (file == NULL){
        printf(""No se puede abrir el archivo\n"");
        exit(1);
    }
    fclose(file);

    
    if(strcmp(argv[1], ""cont_binario"") == 0){
        cont_binario();
    }

    
    else if(strcmp(argv[1], ""rotativo"") == 0){
        rotativo();
    }
    
    else{
        fprintf(stderr, ""Modo: %s no valido\n"", argv[1]);
        exit(1);
    }

    return 0;
}


void rotativo(){

    
    char  leds[] = ""0"";

    
    FILE * file;

    
    int i = 1;
    while(1){
        file = fopen(PATH, ""r+"");

        
        sprintf(leds, ""%d"", i);

        fwrite(leds, sizeof(char), strlen(leds), file);

        printf(""He encendido el led %s\n"", leds);
        fclose(file);

        sleep(1);

        i = (i%3) + 1;
    }
}


void cont_binario(){

    
    char leds[] = ""000"";

    
    FILE * file;

    int i = 0;
    
    while(1){
        int num = i;
        file = fopen(PATH, ""r+"");

        
        if(num >= 4){
            leds[0] = '1';
            num = num -4;
        }

        
        if (num >= 2){
            leds[1] = '2';
            num = num -2;
        }

        
        if(num >= 1){
            leds[2] = '3';
        }

        
        fwrite(leds, sizeof(char), strlen(leds), file);

        printf(""He encendido los leds %s\n"", leds);

        fclose(file);

        
        sleep(1);

        i = (i+1)%8;

        leds[0] = '0';
        leds[1] = '0';
        leds[2] = '0';
    }
}",26,783,682
"#define ALL_LEDS_ON 0x7
#define ALL_LEDS_OFF 0


struct tty_driver* kbd_driver= NULL;



struct tty_driver* get_kbd_driver_handler(void)
{
    printk(KERN_INFO ""modleds: loading\n"");
    printk(KERN_INFO ""modleds: fgconsole is %x\n"", fg_console);
#if ( LINUX_VERSION_CODE > KERNEL_VERSION(2,6,32) )
    return vc_cons[fg_console].d->port.tty->driver;
#else
    return vc_cons[fg_console].d->vc_tty->driver;
#endif
}


static inline int set_leds(struct tty_driver* handler, unsigned int mask)
{
#if ( LINUX_VERSION_CODE > KERNEL_VERSION(2,6,32) )
    return (handler->ops->ioctl) (vc_cons[fg_console].d->port.tty, KDSETLED,mask);
#else
    return (handler->ops->ioctl) (vc_cons[fg_console].d->vc_tty, NULL, KDSETLED, mask);
#endif
}

static int __init modleds_init(void)
{
    kbd_driver= get_kbd_driver_handler();
    set_leds(kbd_driver,ALL_LEDS_ON);
    return 0;
}

static void __exit modleds_exit(void)
{
    set_leds(kbd_driver,ALL_LEDS_OFF);
}

module_init(modleds_init);
module_exit(modleds_exit);

MODULE_LICENSE(""GPL"");
MODULE_DESCRIPTION(""Modleds"");
",26,784,456
"#include ""44b.h""
#include ""keyboard.h""


#define KEY_VALUE_MASK  0x0f


volatile static unsigned char *keyboard_base = (unsigned char *)0x06000000;


int kb_scan(void)
{
    int value = -1;
    int i;
    char temp;
    int lines[4]  = {0xfd, 0xfb, 0xf7, 0xef};
    int map[4][4] = {{0, 1, 2, 3},
                    {4, 5, 6, 7},
                    {8, 9, 0xA, 0xB},
                    {0xC, 0xD, 0xE, 0xF}};

    for (i = 0; (i < 4) && (value == -1); i++) {
        temp = *(keyboard_base+lines[i]);

        if(( temp & KEY_VALUE_MASK) != KEY_VALUE_MASK) {
            
            
            
            
            
        }
    }

    return value;
}
",26,785,292
"#include ""44b.h""
#include ""timer.h""

int tmr_set_prescaler(int p, int  value)
{
    int offset = p*8;
    value &= 0xFF;

    if (p < 0 || p > 3)
        return -1;

    
    
    
    rTCFG0 &= ~(0xFF << offset);

    value <<= offset;
    rTCFG0 |= value;

    return 0;
}

int tmr_set_divider(int d, enum tmr_div div)
{
    int ret = 0;
    int pos = d*4;

    if ((d < 0 || d > 5) ||
            (div == D1_32 && d > 3) ||
            (div == EXTCLK && d != 5) ||
            (div == TCLK && d != 4))
        return -1;

    if (div == EXTCLK || div == TCLK)
        div = 4;

    
    
    
    rTCFG1 &= ~(0xF << pos);

    unsigned int b = div;
    b <<= pos;

    rTCFG1 |= b;

    return 0;
}

int tmr_set_count(enum tmr_timer t, int count, int cmp)
{
    int err = 0;
    switch (t) {
        case TIMER0:
            
            
            
            
            rTCNTB0 = count;
            rTCMPB0 = cmp;
             break;
        case TIMER1:
            
            
            
            
            rTCNTB1 = count;
            rTCMPB1 = cmp;
             break;
        case TIMER2:
            
            
            
            
            rTCNTB2 = count;
            rTCMPB2 = cmp;
             break;
        case TIMER3:
            
            
            
            
            rTCNTB3 = count;
            rTCMPB3 = cmp;
             break;
        case TIMER4:
            
            
            
            
            rTCNTB4 = count;
            rTCMPB4 = cmp;
             break;
        case TIMER5:
            
            
            
            rTCNTB5 = count;
             break;
        default:
            err = -1;
    }

    return err;
}

int tmr_update(enum tmr_timer t)
{
    int pos = t*4;
    if (t > 0)
        pos += 4;

    if (t < 0 || t > 5)
        return -1;

    
    
    
    
    unsigned int b = 1;
    b <<= pos + 1; 
    
    rTCON |= b;
    rTCON &= ~b;

    return 0;
}

int tmr_set_mode(enum tmr_timer t, enum tmr_mode mode)
{
    int err = 0;
    int pos = t*4;
    if (t > 0)
        pos += 4;

    if (t < 0 || t > 5)
        return -1;

    if (mode == ONE_SHOT)
    {
        
        
        
        unsigned int b = 1;
        b <<= pos + 3;

        rTCON &= ~b;
    }
    else if (mode == RELOAD)
    {
        
        
        
        unsigned int b = 1;
        b <<= pos + 3;

        rTCON |= b;
    }
    else
        err = -1;

    return err;
}

int tmr_start(enum tmr_timer t)
{
    int pos = t*4;
    if (t > 0)
        pos += 4;

    if (t < 0 || t > 5)
        return -1;

    
    
    
    unsigned int b = 1;
    b <<= pos;

    rTCON |= b;
    return 0;
}

int tmr_stop(enum tmr_timer t)
{
    int pos = t*4;
    if (t > 0)
        pos += 4;

    if (t < 0 || t > 5)
        return -1;

    
    
    
    unsigned int b = 1;
    b <<= pos;

    rTCON &= ~b;
    return 0;
}

int tmr_isrunning(enum tmr_timer t)
{
    int ret = 0;
    int pos = t*4;
    if (t > 0)
        pos += 4;

    if ((t >= 0) && (t <= 5) 
            && (rTCON & (0x1 << pos)))
        ret = 1;

    return ret;
}

",26,786,1251
"#include ""fuseLib.h""












int resizeNode(uint64_t idxNode, size_t newSize)
{
    NodeStruct *node = myFileSystem.nodes[idxNode];
    char block[BLOCK_SIZE_BYTES];
    int i, diff = newSize - node->fileSize;

    if(!diff)
        return 0;

    memset(block, 0, sizeof(char)*BLOCK_SIZE_BYTES);

    
    if(diff > 0) {

        
        if(node->numBlocks && node->fileSize % BLOCK_SIZE_BYTES) {
            int currentBlock = node->blocks[node->numBlocks - 1];

            if( readBlock(&myFileSystem, currentBlock, &block)==-1 ) {
                fprintf(stderr,""Error reading block in resizeNode\n"");
                return -EIO;
            }

            int offBlock = node->fileSize % BLOCK_SIZE_BYTES;
            int bytes2Write = (diff > (BLOCK_SIZE_BYTES - offBlock)) ? BLOCK_SIZE_BYTES - offBlock : diff;
            for(i = 0; i < bytes2Write; i++) {
                block[offBlock++] = 0;
            }

            if( writeBlock(&myFileSystem, currentBlock, &block)==-1 ) {
                fprintf(stderr,""Error writing block in resizeNode\n"");
                return -EIO;
            }
        }

        
        int newBlocks = (newSize + BLOCK_SIZE_BYTES - 1) / BLOCK_SIZE_BYTES - node->numBlocks;
        if(newBlocks) {
            memset(block, 0, sizeof(char)*BLOCK_SIZE_BYTES);

            
            if(newBlocks > myFileSystem.superBlock.numOfFreeBlocks)
                return -ENOSPC;

            myFileSystem.superBlock.numOfFreeBlocks -= newBlocks;
            int currentBlock = node->numBlocks;
            node->numBlocks += newBlocks;

            for(i = 0; currentBlock != node->numBlocks; i++) {
                if(myFileSystem.bitMap[i] == 0) {
                    myFileSystem.bitMap[i] = 1;
                    node->blocks[currentBlock] = i;
                    currentBlock++;
                    
                    if( writeBlock(&myFileSystem, i, &block)==-1 ) {
                        fprintf(stderr,""Error writing block in resizeNode\n"");
                        return -EIO;
                    }
                }
            }
        }
        node->fileSize += diff;

    }
    
    else {
        
        int numBlocks = (newSize + BLOCK_SIZE_BYTES - 1) / BLOCK_SIZE_BYTES;
        myFileSystem.superBlock.numOfFreeBlocks += (node->numBlocks - numBlocks);

        for(i = node->numBlocks; i > numBlocks; i--) {
            int nBloque = node->blocks[i - 1];
            myFileSystem.bitMap[nBloque] = 0;
            
            if( writeBlock(&myFileSystem, nBloque, &block)==-1 ) {
                fprintf(stderr,""Error writing block in resizeNode\n"");
                return -EIO;
            }
        }
        node->numBlocks = numBlocks;
        node->fileSize += diff;
    }
    node->modificationTime = time(NULL);

    sync();

    
    updateSuperBlock(&myFileSystem);
    updateBitmap(&myFileSystem);
    updateNode(&myFileSystem, idxNode, node);

    return 0;
}


void mode_string(mode_t mode, char *str)
{
    str[0] = mode & S_IRUSR ? 'r' : '-';
    str[1] = mode & S_IWUSR ? 'w' : '-';
    str[2] = mode & S_IXUSR ? 'x' : '-';
    str[3] = mode & S_IRGRP ? 'r' : '-';
    str[4] = mode & S_IWGRP ? 'w' : '-';
    str[5] = mode & S_IXGRP ? 'x' : '-';
    str[6] = mode & S_IROTH ? 'r' : '-';
    str[7] = mode & S_IWOTH ? 'w' : '-';
    str[8] = mode & S_IXOTH ? 'x' : '-';
    str[9] = '\0';
}


static int my_getattr(const char *path, struct stat *stbuf)
{
    NodeStruct *node;
    int idxDir;

    fprintf(stderr, ""--->>>my_getattr: path %s\n"", path);

    memset(stbuf, 0, sizeof(struct stat));

    
    if(strcmp(path, ""/"") == 0) {
        stbuf->st_mode = S_IFDIR | 0755;
        stbuf->st_nlink = 2;
        stbuf->st_uid = getuid();
        stbuf->st_gid = getgid();
        stbuf->st_mtime = stbuf->st_ctime = myFileSystem.superBlock.creationTime;
        return 0;
    }

    
    if((idxDir = findFileByName(&myFileSystem, (char *)path + 1)) != -1) {
        node = myFileSystem.nodes[myFileSystem.directory.files[idxDir].nodeIdx];
        stbuf->st_size = node->fileSize;
        stbuf->st_mode = S_IFREG | 0644;
        stbuf->st_nlink = 1;
        stbuf->st_uid = getuid();
        stbuf->st_gid = getgid();
        stbuf->st_mtime = stbuf->st_ctime = node->modificationTime;
        return 0;
    }

    return -ENOENT;
}


static int my_readdir(const char *path, void *buf, fuse_fill_dir_t filler,  off_t offset, struct fuse_file_info *fi)
{
    int i;

    fprintf(stderr, ""--->>>my_readdir: path %s, offset %jd\n"", path, (intmax_t)offset);

    if(strcmp(path, ""/"") != 0)
        return -ENOENT;

    filler(buf, ""."", NULL, 0);
    filler(buf, "".."", NULL, 0);

    for(i = 0; i < MAX_FILES_PER_DIRECTORY; i++) {
        if(!(myFileSystem.directory.files[i].freeFile)) {
            if(filler(buf, myFileSystem.directory.files[i].fileName, NULL, 0) == 1)
                return -ENOMEM;
        }
    }

    return 0;
}


static int my_open(const char *path, struct fuse_file_info *fi)
{
    int idxDir;

    fprintf(stderr, ""--->>>my_open: path %s, flags %d, %""PRIu64""\n"", path, fi->flags, fi->fh);

    
    if((idxDir = findFileByName(&myFileSystem, (char *)path + 1)) == -1) {
        return -ENOENT;
    }

    
    fi->fh = myFileSystem.directory.files[idxDir].nodeIdx;

    return 0;
}



static int my_write(const char *path, const char *buf, size_t size, off_t offset, struct fuse_file_info *fi)
{
    char buffer[BLOCK_SIZE_BYTES];
    int bytes2Write = size, totalWrite = 0;
    NodeStruct *node = myFileSystem.nodes[fi->fh];

    fprintf(stderr, ""--->>>my_write: path %s, size %zu, offset %jd, fh %""PRIu64""\n"", path, size, (intmax_t)offset, fi->fh);

    
    if(resizeNode(fi->fh, size + offset) < 0)
        return -EIO;

    
    while(bytes2Write) {
        int i;
        int currentBlock, offBlock;
        currentBlock = node->blocks[offset / BLOCK_SIZE_BYTES];
        offBlock = offset % BLOCK_SIZE_BYTES;

        if( readBlock(&myFileSystem, currentBlock, &buffer)==-1 ) {
            fprintf(stderr,""Error reading blocks in my_write\n"");
            return -EIO;
        }

        for(i = offBlock; (i < BLOCK_SIZE_BYTES) && (totalWrite < size); i++) {
            buffer[i] = buf[totalWrite++];
        }

        if( writeBlock(&myFileSystem, currentBlock, &buffer)==-1 ) {
            fprintf(stderr,""Error writing block in my_write\n"");
            return -EIO;
        }

        
        bytes2Write -= (i - offBlock);
        offset += (i - offBlock);
    }
    sync();

    node->modificationTime = time(NULL);
    updateSuperBlock(&myFileSystem);
    updateBitmap(&myFileSystem);
    updateNode(&myFileSystem, fi->fh, node);

    return size;
}


static int my_release(const char *path, struct fuse_file_info *fi)
{
    (void) path;
    (void) fi;

    fprintf(stderr, ""--->>>my_release: path %s\n"", path);

    return 0;
}


static int my_mknod(const char *path, mode_t mode, dev_t device)
{
    char modebuf[10];

    mode_string(mode, modebuf);
    fprintf(stderr, ""--->>>my_mknod: path %s, mode %s, major %d, minor %d\n"", path, modebuf, (int)MAJOR(device), (int)MINOR(device));

    
    if(strlen(path + 1) > myFileSystem.superBlock.maxLenFileName) {
        return -ENAMETOOLONG;
    }

    
    if(myFileSystem.numFreeNodes <= 0) {
        return -ENOSPC;
    }

    
    if(myFileSystem.directory.numFiles >= MAX_FILES_PER_DIRECTORY) {
        return -ENOSPC;
    }
    
    if(findFileByName(&myFileSystem, (char *)path + 1) != -1)
        return -EEXIST;

    
    int idxNodoI, idxDir;
    if((idxNodoI = findFreeNode(&myFileSystem)) == -1 || (idxDir = findFreeFile(&myFileSystem)) == -1) {
        return -ENOSPC;
    }

    
    myFileSystem.directory.files[idxDir].freeFile = false;
    myFileSystem.directory.numFiles++;
    strcpy(myFileSystem.directory.files[idxDir].fileName, path + 1);
    myFileSystem.directory.files[idxDir].nodeIdx = idxNodoI;
    myFileSystem.numFreeNodes--;

    
    if(myFileSystem.nodes[idxNodoI] == NULL)
        myFileSystem.nodes[idxNodoI] = malloc(sizeof(NodeStruct));

    myFileSystem.nodes[idxNodoI]->fileSize = 0;
    myFileSystem.nodes[idxNodoI]->numBlocks = 0;
    myFileSystem.nodes[idxNodoI]->modificationTime = time(NULL);
    myFileSystem.nodes[idxNodoI]->freeNode = false;

    reserveBlocksForNodes(&myFileSystem, myFileSystem.nodes[idxNodoI]->blocks, 0);

    updateDirectory(&myFileSystem);
    updateNode(&myFileSystem, idxNodoI, myFileSystem.nodes[idxNodoI]);

    return 0;
}


static int my_truncate(const char *path, off_t size)
{
    int idxDir;

    fprintf(stderr, ""--->>>my_truncate: path %s, size %jd\n"", path, size);

    if((idxDir = findFileByName(&myFileSystem, (char *)path + 1)) == -1) {
        return -ENOENT;
    }

    
    if(resizeNode(myFileSystem.directory.files[idxDir].nodeIdx, size) < 0)
        return -EIO;

    return 0;
}



static int my_unlink(const char *path){

    int idfich;

    
    
    if((idfich = findFileByName(&myFileSystem, (char *)path + 1)) == -1)
        return -EEXIST;

    
    myFileSystem.directory.files[idfich].freeFile = true;
    
    myFileSystem.directory.numFiles--;
    
    myFileSystem.numFreeNodes++;

    
    int idnodo = myFileSystem.directory.files[idfich].nodeIdx;

    
    myFileSystem.nodes[idnodo]->freeNode = true;

    int bloque;

    
    for(int i = 0; i < MAX_BLOCKS_PER_FILE; i++){
        
        if((bloque = myFileSystem.nodes[idnodo]->blocks[i]) != 0){
            
            myFileSystem.bitMap[bloque] = 0;
            
            myFileSystem.nodes[idnodo]->blocks[i] = 0;
            
            myFileSystem.superBlock.numOfFreeBlocks++;
        }
    }

    
    free (myFileSystem.nodes[idnodo]);

    
    updateBitmap(&myFileSystem);
    updateDirectory(&myFileSystem);
    updateNode(&myFileSystem, idnodo, myFileSystem.nodes[idnodo]);
    updateSuperBlock(&myFileSystem);

    return 0;
}






static int my_read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi){

    
    char buffer[BLOCK_SIZE_BYTES];
    
    int bytes2Read = size, totalRead = 0;
    
    NodeStruct *node = myFileSystem.nodes[fi->fh];

    
    fprintf(stderr, ""--->>>my_read: path %s, size %zu, offset %jd, fh %""PRIu64""\n"", path, size, (intmax_t)offset, fi->fh);

    
    while(bytes2Read) {
        int i;
        int currentBlock, offBlock;
        
        currentBlock = node->blocks[offset / BLOCK_SIZE_BYTES];
        
        offBlock = offset % BLOCK_SIZE_BYTES;

        
        if( readBlock(&myFileSystem, currentBlock, &buffer)==-1 ) {
            fprintf(stderr,""Error reading blocks in my_write\n"");
            return -EIO;
        }

        
        for(i = offBlock; (i < BLOCK_SIZE_BYTES) && (totalRead < size); i++) {
            
            buf[totalRead++] = buffer[i] ;
        }

        
        
        bytes2Read -= (i - offBlock);
        
        offset += (i - offBlock);
    }

    
    while (totalRead < size){
        buf[totalRead++] = '0';
    }

    
    sync();

    return size;
}


struct fuse_operations myFS_operations = {
    .getattr    = my_getattr,                   
    .readdir    = my_readdir,                   
    .truncate   = my_truncate,                  
    .open       = my_open,                      
    .write      = my_write,                     
    .release    = my_release,                   
    .mknod      = my_mknod,                     
    .unlink     = my_unlink,
    .read       = my_read,
};

",26,787,4144
"int main()
{
  int salary;
  float bonus;
  char gender;







  printf(""Enter the Gender"");
  scanf(""%c"",&gender);
  printf(""Enter Salary"");
  scanf(""%d"",&salary);

  if(gender == 'M' || gender == 'm')
  {
    if(salary > 10000)
    {
      bonus = (salary * .05);
    }
    else
    {
      bonus = (salary * .07);
    }
  }
  if(gender == 'F' || gender == 'f')
  {
    if(salary > 10000)
    {

      bonus = (float)(salary * .10);
    }
    else
    {
      bonus = (float)(salary * .12);
    }
  }
  salary = salary + bonus;
  printf(""Salary is %d"", salary);
}
",27,788,246
"int main()
{
  int i=0,j=0,k=0,array[100]={0}, no = 0,latest_no = 0, last = 0, sum = 0;
  printf(""Enter Length of Array"");
  scanf(""%d"",&no);





  for(i=0; i<no; i++)
  {
    scanf(""%d"",&array[i]);
  }
  
  for(i=0; i<no; i++)
  {
    latest_no = array[i];
    sum = 0;
    while(latest_no != 0)
    {
      last = latest_no%10;
      sum = (sum*10) + last;
      latest_no = latest_no/10;
    }
    printf(""value of Sum is %d\n"",sum);
    if( array[i] == sum)
    {
      printf(""%d is Palindrom\n\n"",sum);
    }
    else
    {
      printf(""No Number is Palindrom\n\n"");
    }
  }



}
",27,789,279
"int main()
{
  int i=0,j=0,k=0,array[100]={0},array2[100] = {0}, no=0,insert_no=0,insert_index=0,flag=0,pair_sum = 0;
  printf(""Enter Length of Array"");
  scanf(""%d"",&no);





  for(i=0; i<no; i++)
  {
    scanf(""%d"",&array[i]);
  }
  for(i=0; i<no; i++)
  {
    printf(""%d "",array[i]);
  }
  
  printf(""\nEnter Element, whose you want to find pair"");
  scanf(""%d"",&pair_sum);
  printf(""\nPair_sum is %d\n"",pair_sum);

  for(i=0; i<no; i++)
  {
    for(j=i+1; j<no; j++)
    {
     if(array[i] + array[j] == pair_sum)
     {
       printf(""Pair for %d are (%d,%d) found at (%d,%d) position\n"",pair_sum,array[i],array[j],i,j);
     }
    }
  }

}
",27,790,315
"void array_print(int arr[], int no)
{
  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
  printf(""\n"");
}

void union_array(int arr1[], int arr2[], int size_arr1, int size_arr2)
{
  int i = 0, j = 0;
  
  while(i<size_arr1 && j<size_arr2)
  {
    if(arr1[i] < arr2[j])
    { 
      printf(""%d "",arr1[i++]); 
    }
    if(arr1[i] > arr2[j])
    {
      printf(""%d "",arr2[j++]); 
    }
    if(arr1[i] == arr2[j])
    {
      printf(""%d "",arr2[j++]); 
      i++;
    }
  }
  while(i<size_arr1)
    printf(""%d "",arr1[i++]);
  while(j<size_arr2)
    printf(""%d "",arr2[j++]);
}

int main()
{
  int arr1[] = {1,2,3,7,8,9,10}, arr2[] = {2, 8, 10, 15, 16, 100} ,no,j=0,temp=0,mid=0,n=0;
  int size_arr1 = sizeof(arr1)/sizeof(int), size_arr2 = sizeof(arr2)/sizeof(int);
  array_print(arr1,size_arr1);
  array_print(arr2,size_arr2);
  union_array(arr1,arr2,size_arr1,size_arr2);
}
",27,791,439
"int main()
{
  int i,j,k,no,array1[100],array2[100],max1=0,max2=0,count=0;
  printf(""Enter Length of Array\n"");
  scanf(""%d"",&no);






  for(i=0; i<no; i++)
  {
    scanf(""%d"",&array1[i]);
  }
  max1 = array1[0];
  for(i=1; i<no; i++)
  {
    if(max1 < array1[i])
    {
      max1 = array1[i];
      count = i;
    }
  }

  for(j=0, i=0; i<no-1; i++,j++)
  {
    if(i < count)
    {       
      array2[i] = array1[j];
    }
    if(i >= count)
    {
    array2[i] = array1[j+1];
    }
  }

  for(i=0; i<no-1; i++)
  {
    printf(""%d "",array2[i]);
  }
}


",27,792,294
"int main()
{
  int i,j = 0,k, count = 0, count1 = 0;
  char str_arr[100], str_arr1[100], f;
  printf(""Enter String to find It's palindrom or Not\n"");
  scanf(""%[^\n]s"",str_arr);


  
  for(i=0; str_arr[i] != '\0'; i++)
  {
    count++;
  }
  for(i=count-1; i>=0; i--)
  {
    str_arr1[j] = str_arr[i];
    j++;
  }
  str_arr1[i] = '\0';
  printf(""String After Reverse is %s\n"",str_arr1);

  for(i=0; str_arr[i] != '\0'; i++)
  {
    if(str_arr[i] == str_arr1[i])
    {
    count1++;
    }
  }
  printf(""Value of Count1 is %d Count is %d\n"",count1,count);
  if(count1 == count)
  {
    printf(""String is Palindrom\n"");
  }
  else
  {
    printf(""Not a Palindrom String\n"");
  }
}
",27,793,324
"int main()
{
  int i,j,k,r1,c1,r2,c2,flag = 0;
  printf(""Enter Value of r1, c1, r2, c2\n"");
  scanf(""%d%d%d%d"",&r1,&c1,&r2,&c2);
  int m1[r1][c1], m2[r2][c2], add_array[r1][c1], mul[r1][c2];





  printf(""Enter value of Matrix1\n"");
  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      scanf(""%d"",&m1[i][j]);
    }
  }
 
  do
  {
    printf(""Enter value of Matrix2\n"");
    for(i=0; i<r2; i++)
    {
      for(j=0; j<c2; j++)
      {
        scanf(""%d"",&m2[i][j]);
      }
    }

    for(i=0; i<r1; i++)
    {
      for(j=0; j<c1; j++)
      {
        add_array[i][j] = m2[i][j] - m1[i][j];
      }
    }

    for(i=0; i<r2; i++)
    {
      for(j=0; j<c2; j++)
      {
        printf(""%.2d "",add_array[i][j]);
      }
      printf(""\n"");
    }

    for(i=0; i<r2; i++)
    {
      for(j=0; j<c2; j++)
      {
        m1[i][j] = add_array[i][j];
    add_array[i][j] = 0;
      }
    }
    printf(""Enter 1 To Add more Matrix\n"");
    scanf(""%d"",&flag);
  }while(flag);

}
",27,794,515
"int g = 0;
void* thread_fun(void *vargp)
{ 
  
  
  int myid = *(int *)vargp;

  
  static int s = 0;
  
  ++s;
  ++g;
   while(1)
   {
     int i = 1;
   }
  
  printf(""Thread Id u: %d, Thread Id d: %d, Static: %d, Global: %d\n"",myid,myid,++s,++g);
}


int main()
{
  int  i;
  pthread_t tid;

  
  for(i = 0; i<3; i++)
  {
    
    pthread_create(&tid, NULL, thread_fun, (void*)&i);
  }
    
    pthread_exit(NULL);
    return 0;
}
",27,795,220
"int g = 0; 


void *myThreadFun(void *vargp) 
{ 
    
    int *myid = (int *)vargp; 

    
    static int s = 0; 

    
    ++s; ++g; 

    
    printf(""Thread ID: %d, Static: %d, Global: %d\n"", *myid, ++s, ++g); 
} 

int main() 
{ 
    int i; 
    pthread_t tid; 

    
    for (i = 0; i < 3; i++) 
        pthread_create(&tid, NULL, myThreadFun, (void *)&tid); 

    pthread_exit(NULL); 
    return 0; 
} 

",27,796,197
"void calculate_the_maximum(int n, int k)
{
  int old_answer_or=0,new_answer_or=0,old_answer_xor=0,new_answer_xor=0,old_answer_and=0,new_answer_and=0,i,j;
  for(i=1;i<n;i++)
  {
    for(j=i+1;j<=n;j++)
    {
      if( (new_answer_and = (i & j)) < k)
      {
        if( new_answer_and > old_answer_and )
        {
          old_answer_and = new_answer_and;
        }
      }
      if( (new_answer_or = (i | j)) < k)
      {
        if( new_answer_or > old_answer_or )
        {
          old_answer_or = new_answer_or;
        }
      }
      if( (new_answer_xor = (i ^ j)) < k)
      {
        if( new_answer_xor > old_answer_xor )
        {
          old_answer_xor = new_answer_xor;
        }
      }
    }
  }
  printf(""%d\n"",old_answer_and);
  printf(""%d\n"",old_answer_or);
  printf(""%d"",old_answer_xor);

}

int main()
{
    int n, k;
    scanf(""%d %d"", &n, &k);
    calculate_the_maximum(n, k);
    return 0;
}
",27,797,398
"void array_print(int arr[], int no)  
{
  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
  printf(""\n"");
}





void cyclic_rotate(int arr1[], int size_arr1)
{
  int last_element,i=0;
  last_element = arr1[size_arr1-1];
  for(i = size_arr1-1; i > 0; i--)
    arr1[i] = arr1[i-1];
  arr1[0] = last_element;
}

int main()
{
  int arr1[] = {1,2,3,4, 5,}, no,j=0;
  int size_arr1 = sizeof(arr1)/sizeof(int);
  array_print(arr1,size_arr1); 
  cyclic_rotate(arr1,size_arr1);
  array_print(arr1,size_arr1); 
}
",27,798,255
"int main()
{
  int i,j,k,r1,c1,r2,c2,row_sum = 0, col_sum = 0, diagnoal1 = 0, diagnoal2 = 0;
  float expo= 0.0;
  printf(""Enter Value of r1, c1 and Exponential\n"");
  scanf(""%d%d%f"",&r1,&c1,&expo);
  int m1[r1][c1], m2[r1][c1], mul[r1][c1], sum = 0;



  printf(""Enter value of Matrix1\n"");
  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      scanf(""%d"",&m1[i][j]);
    }
  }

  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      printf(""%d "",m1[i][j]);
    }
    printf(""\n"");
  }

  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      m2[j][i] = m1[i][j];
    }
  }
  printf(""\n"");
  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      printf(""%d "",m2[i][j]);
    }
    printf(""\n"");
  }
  
  for(i=0; i<r1; i++)
  {
    for(j=0; j<r1; j++)
    {
      for(k=0; k<r1; k++)
      {
        sum = sum + m1[i][k]*m2[k][j];
      }
      mul[i][j] = sum;
      sum = 0;
    }
  }
  printf(""\n"");
  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      printf(""%d "",mul[i][j]);
    }
    printf(""\n"");
  }

}

",27,799,578
"int main()
{
  int i,j,k,r1,c1,r2,c2, flag = 0;
  printf(""Enter Value of r1, c1\n"");
  scanf(""%d%d"",&r1,&c1);
  int m1[r1][c1], sum = 0;




  if(r1 == c1)
  {
    printf(""Enter value of Matrix1\n"");
    for(i=0; i<r1; i++)
    {
      for(j=0; j<c1; j++)
      {
        scanf(""%d"",&m1[i][j]);
      }
    }
 
    for(i=0; i<r1; i++)
    {
      for(j=0; j<c1; j++)
      {
        printf(""%d "",m1[i][j]);
      }
      printf(""\n"");
    }

    for(i=0; i<r1; i++)
    {
      for(j=0; j<c1; j++)
      {
        if( i == j && m1[i][j] == 1)
    {
          flag++;
    }
    if( i != j && m1[i][j] == 0)
    {
      flag++;
    }
      }
    }  
 
  }
  else
  {
    printf(""Identical Matrix Should be a Square Matrix\n"");
  }
  if(flag == (r1*c1))
  {
    printf(""Matrix is Identical\n"");
  }
  else
  {
    printf(""Matrix is Not Identical"");
  }
  printf(""\nValue of flag is %d"",flag);
}

",27,800,427
"int main()
{
  int i,j,k,r1,c1,r2,c2,row_sum = 0, col_sum = 0, diagnoal1 = 0, diagnoal2 = 0;
  printf(""Enter Value of r1, c1\n"");
  scanf(""%d%d"",&r1,&c1);
  int m1[r1][c1], sum = 0;



  printf(""Enter value of Matrix1\n"");
  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      scanf(""%d"",&m1[i][j]);
    }
  }

  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      printf(""%d "",m1[i][j]);
    }
    printf(""\n"");
  }

  for(i=0; i<r1; i++)
  {
    diagnoal1 = diagnoal1 + m1[i][i];
    diagnoal2 = diagnoal2 + m1[i][c1];
    c1--;
  }
  printf(""\n\nValue of Diagnoal1 is %d & Diagnoal2 is %d"",diagnoal1,diagnoal2);

 }

",27,801,350
"struct pair
{
  int min;
  int max;
};




struct pair max_min_array(int arr[], int low, int high)
{
  struct pair minmax,mml,mmr;
  int mid;

  if( low == high)
  {
    minmax.max = arr[low];
    minmax.min = arr[low];
    return minmax;
  }

  if(high == low+1)
  {
    if(arr[low]>arr[high])
    {
      minmax.max = arr[low];
      minmax.min = arr[high];
    }
    else
    {
      minmax.min = arr[low];
      minmax.max = arr[high];
    }
    return minmax;
  }

  mid = (low+high)/2;
  mml = max_min_array(arr, low, mid);
  mmr = max_min_array(arr, mid+1, high);
  
  if(mml.min < mmr.min)
    minmax.min = mml.min;
  else
    minmax.min = mmr.min;

  if(mml.max > mmr.max)
    minmax.max = mml.max;
  else
    minmax.max = mmr.max;
  return minmax;
}

int main()
{
  int arr[100] = {1000, 11, 445, 1, 330, 3000};
  int no = 6;
  struct pair minmax = max_min_array(arr,0,no-1);
  printf(""Max value is %d \nMin value is %d"",minmax.min,minmax.max);
}
",27,802,443
"int main()
{
  int i,j,k,x,y,no,sum=0,a,b,dummy1=0, dummy2 = 0;
  printf(""Enter the Range to find the Perfect number between them"");
  scanf(""%d%d"",&a,&b);





  for(j=a; j<=b; j++)
  {
    sum = 0;
    dummy1 = j;
    for( i=1; i<j; i++)
    {
      if(dummy1 % i == 0)
      {
        sum = sum + i;
      }
    }
    if( dummy1 == sum)
    {
      printf(""%d "",dummy1);
    }
  }

}

",27,803,187
"void *myThreadFun(void *vargp) 
{ 
    sleep(1); 
    printf(""Printing GeeksQuiz from Thread \n"");
    return NULL; 
} 

int main() 
{ 
    pthread_t thread_id; 
    printf(""Before Thread\n""); 
        printf(""ThreadId is %ld\n"",thread_id);  
    pthread_create(&thread_id, NULL, &myThreadFun, NULL); 
    pthread_join(thread_id, NULL); 
    printf(""After Thread\n""); 
    exit(0); 
}

",27,804,150
"int factorial(int);
int main()
{
  float i,j,degree,radian,result, sine = 0;
  int count = 0, k = 1, accurate;
  printf(""Enter the degree to find it by sin value by it"");
  scanf(""%f"",&degree);



  radian = (float)degree * (3.1415/180);
  printf(""Minimum is 3.Enter the value of the accurate, upto which you want to find the result"");
  scanf(""%d"",&accurate);
  do
  {
    if(count % 2 == 0)
    {
      sine = (float)sine + (pow(radian,k)/factorial(k));
    }
    if(count % 2 == 1)
    {
      sine = (float)sine - (pow(radian,k)/factorial(k));
    }
    count++;
    k = k + 2;
  }
  while(count <= accurate);
  printf(""\nValue of sine %f"", sine);
  printf(""\nValue of sine %f"", sin(radian));

}

int factorial(int val)
{
  int  fact= 1, i;
  for(i=1; i<=val; i++)
  {
    fact = fact * i;
  }
  return fact;
}

",27,805,348
"int g = 0; 


void *myThreadFun(void *vargp) 
{ 
    
    int *myid = (int *)vargp; 

    
    static int s = 0; 

    
    ++s; ++g; 

    
    printf(""Thread ID: %u, Static: %d, Global: %d\n"", *myid, ++s, ++g); 
} 

int main() 
{ 
    int i; 
    pthread_t tid; 

    
    for (i = 0; i < 3; i++) 
        pthread_create(&tid, NULL, myThreadFun, (void *)&tid); 

    pthread_exit(NULL); 
    return 0; 
} 

",27,806,197
"void array_print(int arr[], int no)
{
  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
  printf(""\n"");
}

void union_array(int arr1[], int arr2[])
{
  int size_arr1 = (sizeof(arr1)/sizeof(int)), size_arr2 = (sizeof(arr2)/sizeof(int));
  int arr3[size_arr1+size_arr2], j = 0;
  for(int i = 0; i<size_arr1; i++)
  {
    arr3[j] = arr1[i];
    j++;
  }
  for(int i = 0; i<size_arr2; i++)
  {
    arr3[j] = arr1[i];
    j++;
  }
  array_print(arr3,size_arr1+size_arr2);
}

int main()
{
  int arr1[] = {1,2,3,5,6,7,8,9,10}, arr2[] = {10,2,3,6,4,9,8,7,2,3,1} ,no,j=0,temp=0,mid=0,n=0;
  array_print(arr1,sizeof(arr1)/sizeof(int));
  array_print(arr2,sizeof(arr2)/sizeof(int));
  union_array(arr1,arr2);
}
",27,807,363
"int main()
{
  int i=0,j=0,k=0,array1[100]={0},array2[100] = {0}, no=0,insert_no=0,insert_index=0,flag=0;
  printf(""Enter Length of Array"");
  scanf(""%d"",&no);





  for(i=0; i<no; i++)
  {
    scanf(""%d"",&array1[i]);
  }
  for(i=0; i<no; i++)
  {
    printf(""%d "",array1[i]);
  }

  printf(""Enter number to insert and position it from Array\n"");
  scanf(""%d%d"",&insert_no,&insert_index);
  insert_index = insert_index - 1;
  
  for(i=0; i<no+1; i++)
  {
    if( i < insert_index)
    {
      array2[i] = array1[i];
    }
    if( i == insert_index)
    {
      array2[i] = insert_no;
    }
    if( i > insert_index)
    {
      array2[i] = array1[i-1];
    }
  }

  printf(""\n"");

  for(i=0; i<no+1; i++)
  {
    printf(""%d "",array2[i]);
  }

}
",27,808,356
"int main()
{
  int arr[100],no,j=0,temp=0,mid=0;
  printf(""Enter length of array"");
  scanf(""%d"",&no);




  for(int i = 0; i<no; i++)
  {
    scanf(""%d"",&arr[i]);
  }

  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }

  printf(""\n"");

  for(int i = 0; i<no; i++)
  {
    if(arr[i]<0)
    {
      if(i != j)
      {
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }
      j++;
    }
  }

  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
}
",27,809,247
"int factorial(int);
int main()
{
  float i,j,degree,radian,result, cose = 0;
  int count = 0, k = 0, accurate;
  printf(""Enter the degree to find it by sin value by it"");
  scanf(""%f"",&degree);



  radian = (float)degree * (3.1415/180);
  printf(""Minimum is 3.Enter the value of the accurate, upto which you want to find the result"");
  scanf(""%d"",&accurate);
  do
  {
    if(count % 2 == 0)
    {
      cose = (float)cose + (pow(radian,k)/factorial(k));
    }
    if(count % 2 == 1)
    {
      cose = (float)cose - (pow(radian,k)/factorial(k));
    }
    count++;
    k = k + 2;
  }
  while(count <= accurate);
  printf(""\nValue of cos %f"", cose);
  printf(""\nValue of cos %f"", cos(radian));

}

int factorial(int val)
{
  int  fact= 1, i;
  for(i=1; i<=val; i++)
  {
    fact = fact * i;
  }
  return fact;
}

",27,810,346
"int g = 0; 


void *myThreadFun(void *vargp) 
{ 
    
    int *myid = (int *)vargp; 

    
    static int s = 0; 

    
    ++s; ++g; 

    
    printf(""Thread ID: %u, Static: %d, Global: %d\n"", *myid, ++s, ++g); 
} 

int main() 
{ 
    int i; 
    pthread_t tid; 

    
    for (i = 0; i < 3; i++) 
        pthread_create(&tid, NULL, myThreadFun, (void *)&tid); 

    pthread_exit(NULL); 
    return 0; 
} 

",27,811,197
"int main()
{
  int i,j,k,choice;
  printf(""Enter the choice to find the Area \n1. Triangle \n2. Circle \n3. Rectangle \n4. Square \n5. Parallelogram\n"");
  scanf(""%d"",&choice);
 
 
 
 
 
 
  switch(choice)
  {
    case 1:
      {
        int a, b, c;
    float Area;
    printf(""Enter the sides of the triangle"");
    scanf(""%d%d%d"",&a,&b,&c);
    Area = (a*b*c);
    printf(""Area of the triangle is %.2f"",Area);
    break;
      }
    case 2:
      {
        int r;
    float Area;
    printf(""Enter the radius of circle"");
    scanf(""%d"",&r);
    Area = (3.14 * r * r);
    printf(""Area of the circle is %.2f"",Area);
    break;
      }
    case 3:
      {
        int a, b;
    float Area;
    printf(""Enter the sides of the Rectangle"");
    scanf(""%d%d"",&a,&b);
    Area = (a*b);
    printf(""Area of the Rectangle is %.2f"",Area);
    break;
      }
    case 4:
      {
        int a;
    float Area;
    printf(""Enter the side of square"");
    scanf(""%d"",&a);
    Area = (a*a);
    printf(""Area of the square is %.2f"",Area);
    break;
      }
    case 5:
      {
        int breath, height;
    float Area;
    printf(""Enter the sides of the Parallelogram"");
    scanf(""%d%d"",&breath,&height);
    Area = (breath*height);
    printf(""Area of the  Parallelogram is %.2f"",Area);
    break;
      }
    default :
      {
        printf(""Invalid Result"");
    break;
      }
  }
}
",27,812,517
"int main()
{
  int i=0,j=0,k=0,len_array1=0,len_array2=0,temp=0;
  printf(""Enter Length of array1 and array2"");
  scanf(""%d%d"",&len_array1,&len_array2);
  int array1[len_array1],array2[len_array2],array3[len_array1+len_array2];



  printf(""Enter Element of Array1\n"");
  for(i=0; i<len_array1; i++)
  {
    scanf(""%d"",&array1[i]);
  }
  printf(""Enter Element of Array2\n"");
  for(i=0; i<len_array2; i++)
  {
    scanf(""%d"",&array2[i]);
  }

  for(i=0;i<len_array1;i++)
  {
    array3[j] = array1[i];
    j++;
  }
  for(i=0;i<len_array2;i++)
  {
    array3[j] = array2[i];
    j++;
  }

  for(i=0;i<len_array1+len_array2;i++)
  {
    printf(""%d "",array3[i]);
  }
  printf(""After Sorting\n"");
  
  for(i=0;i<len_array1+len_array2;i++)
  {
    for(j=i+1;j<len_array1+len_array2;j++)
    {
      if(array3[i] > array3[j])
      {
        temp = array3[i];
    array3[i] = array3[j];
    array3[j] = temp;
      }
    }  
  }

  for(i=0;i<len_array1+len_array2;i++)
  {
    printf(""%d "",array3[i]);
  }
}
",27,813,492
"void array_print(int arr[], int no)  
{
  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
  printf(""\n"");
}

int ispresent(int arr1[], int size_arr1, int arr2[], int index_val) 
{
  for(int i = 0; i<size_arr1; i++)
  {
    if(arr1[i] == arr2[index_val])
    {
      return 1;
    }
  }
  return 0;
}

int remove_repeat(int arr[], int size_arr) 
{
  for(int i = 0; i<size_arr; i++)
  {
    for(int j = i+1; j<size_arr;j++)
    { 
      if(arr[i] == arr[j])
      {
        for(int k = j; k<size_arr; k++)
    {
          arr[k] = arr[k+1];
    }
    size_arr--;
      }
    }
  }
  return size_arr;
}
void union_array(int arr1[], int arr2[], int size_arr1, int size_arr2)
{
  int total_size = size_arr1+size_arr2, arr3[total_size], index_val = 0, k = 0i, last_count = 0;

  for(int i = 0; i<size_arr1; i++)
  {
    arr3[k] = arr1[i];
    k++;
  }

  for(int i = 0; i<size_arr2; i++)
  {
    int val = ispresent(arr1,size_arr1,arr2,i); 
    if(val == 0)
    {
      arr3[k] = arr2[i];
      k++;
    }
  }

  printf(""Array after Union :-"");
  array_print(arr3,k);
}

int main()
{
  int arr1[] = {1,2,3,5,6,6,7,8,9,7,8,9,10}, arr2[] = {100,2,3,60,1,2,3,4,4,6,4,9,80,7,2,30,1} ,no,j=0,temp=0,mid=0,n=0;
  int size_arr1 = sizeof(arr1)/sizeof(int), size_arr2 = sizeof(arr2)/sizeof(int);
  array_print(arr1,size_arr1); 
  array_print(arr2,size_arr2); 
  size_arr1 = remove_repeat(arr1,size_arr1); 
  size_arr2 = remove_repeat(arr2,size_arr2); 
  array_print(arr1,size_arr1); 
  array_print(arr2,size_arr2); 
  union_array(arr1,arr2,size_arr1,size_arr2);
}
",27,814,768
"int main()
{
  int i,j,k,r1,c1,r2,c2, flag = 0;
  printf(""Enter Value of r1, c1\n"");
  scanf(""%d%d"",&r1,&c1);
  int m1[r1][c1], sum = 0;





  printf(""Enter value of Matrix1\n"");
  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      scanf(""%d"",&m1[i][j]);
    }
  }

  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      printf(""%d "",m1[i][j]);
    }
    printf(""\n"");
  }

  for(i=0; i<r1; i++)
  {
    sum = sum + m1[i][i];
  }

  printf(""Value of Trace is %d "",sum); 
}
",27,815,269
"void* myturn(void * arg)
{
  while(1)
  {
    sleep(1);
    printf(""myturn\n"");
  }
  return NULL;
}


void* yourturn(void * arg)
{
  while(1)
  {
    sleep(1);
    printf(""yourturn\n\n"");
  }
  return NULL;
}

int main()
{
  pthread_t thread_id, thread_id1;
  pthread_create(&thread_id,NULL,myturn,NULL);  
  pthread_create(&thread_id,NULL,yourturn,NULL);
  pthread_join(thread_id,NULL);
  pthread_join(thread_id,NULL);
  
}



















",27,816,204
"int main()
{
        
    char server_message[256] = ""You have been reached the Server"";


    
    int server_socket;
    server_socket = socket(AF_INET, SOCK_STREAM, 0);


    
    struct sockaddr_in server_address;
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(9000);
    server_address.sin_addr.s_addr = INADDR_ANY;


    
    bind(server_socket, (struct sockaddr*)&server_address, sizeof(server_address));


    
    listen(server_socket, 5); 


    
    int client_socket;
    client_socket = accept(server_socket, NULL, NULL);
        

    
    send(client_socket, server_message, sizeof(server_message),0);

    
    close(server_socket);
    return 0;
}





",27,817,253
"void array_print(int arr[], int no)
{
  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
  printf(""\n"");
}

void intersection_array(int arr1[], int arr2[], int size_arr1, int size_arr2)
{
  int total_size = size_arr1+size_arr2;
  int arr3[total_size], arr4[total_size], j = 0, k = 0;
  for(int i = 0; i<size_arr1; i++) 
  {
    arr3[j] = arr1[i];
    j++;
  }
  for(int i = 0; i<size_arr2; i++) 
  {
    arr3[j] = arr2[i];
    j++;
  }
  printf(""Array befor Union :-"");
  array_print(arr3,total_size); 
  for(int i = 0; i<size_arr1; i++) 
  {
    for(int j = 0; j<size_arr2;j++)
    {
      if(arr1[i] == arr2[j])
      {
        arr4[k] = arr1[i];
        k++;
      }
    }
  }
  printf(""Array after k is %d Intersection  :-"",k);
  array_print(arr4,k);
  int size_arr4 = k;
  printf(""Array is :-""); 
  for(int i = 0; i<size_arr4;i++) 
  {
    for(int j = i+1; j<size_arr4;j++)
    {
      if(arr4[i] == arr4[j])
      {
        for(int k = j; k<size_arr4;k++)
    {
          arr4[k] = arr4[k+1];
    }
    size_arr4--;
      }
    }
  }
  array_print(arr4,size_arr4); 
}

int main()
{
  int arr1[] = {1,2,3,5,6,7,8,9,10}, arr2[] = {10,2,3,6,4,9,8,7,2,3,1} ,no,j=0,temp=0,mid=0,n=0;
  int size_arr1 = sizeof(arr1)/sizeof(int), size_arr2 = sizeof(arr2)/sizeof(int);
  array_print(arr1,size_arr1);
  array_print(arr2,size_arr2);
  intersection_array(arr1,arr2,size_arr1,size_arr2);
}
",27,818,677
"int main()
{
  int i,j,k,x,y,no,count=0;
  printf(""Enter the number, upto which you want to find out prime or not"");
  scanf(""%d"",&no);
  







  for(j=1; j<=no; j++)
  {
      count = 0;
      for(i=1; i<=j; i++)
      {
        if( j%i == 0)
        {
          count++;
        }
      }
      if( count == 2)
      {
        printf(""%d \n"",j);
      }
  }
}


",27,819,161
"int main()
{
  int arr[100],no,j=0,temp=0,mid=0;
  printf(""Enter length of array"");
  scanf(""%d"",&no);




  for(int i = 0; i<no; i++)
  {
    scanf(""%d"",&arr[i]);
  }

  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
  printf(""\n"");
  if(no%2 == 0)
  {
   mid = no/2;
  }
  else
  {
    mid = (no-1)/2;
  }
  for(int i = no-1; i>=mid; i--)
  {
    temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
    j++;
  }

  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
}
",27,820,261
"int main()
{
  int a = 0, i=0,j=0,k=0,len_array1=0,len_array2=0,temp=0, total_count = 0;
  printf(""Enter Length of array1 and array2"");
  scanf(""%d%d"",&len_array1,&len_array2);
  int array1[len_array1],array2[len_array2],array3[len_array1+len_array2];



  int intersection_arr[100];
  printf(""Enter Element of Array1\n"");
  for(i=0; i<len_array1; i++)
  {
    scanf(""%d"",&array1[i]);
  }
  printf(""Enter Element of Array2\n"");
  for(i=0; i<len_array2; i++)
  {
    scanf(""%d"",&array2[i]);
  }
  for(i=0;i<len_array1;i++)
  {
    array3[j] = array1[i];
    j++;
  }
  for(i=0;i<len_array2;i++)
  {
    array3[j] = array2[i];
    j++;
  }
  for(i=0;i<total_count;i++)
  {
    for(j=i+1; j<len_array1+len_array2;j++)
    {
      if(array3[i] > array3[j])
      {
        temp = array3[i];
    array3[i] = array3[j];
    array3[j] = temp;
      }
    }
  }

  total_count = len_array1+len_array2;
  for(i=0; i<len_array1+len_array2; i++)
  {
    printf(""%d "",array3[i]);
  }

  for(i=0;i<len_array1;i++)
  {
    for(j=0; j<len_array2;j++)
    {
      if(array1[i] == array2[j])
      {
        intersection_arr[k] = array1[i];
    k++;
      }
    }
  }

  printf(""\nArray After Intersection\n"");
  for(i=0; i<k; i++)
  {
    printf(""%d "",intersection_arr[i]);
  }

}
",27,821,604
"int main()
{
  int i,j=0,k,O_no,D_no,a,b,arr[100];
  int new[10]={0};
  printf(""Enter the number to find the repeatation in it"");
  scanf(""%d"",&O_no);






            

  while( O_no > 0 )
  {
    i = O_no % 10;
    arr[j] = i;
    O_no = O_no / 10;
    j++;
  }
  
  for(i=0; i<j; i++)
  {
    new[arr[i]]++;
  }
    
  for(i=0; i<10; i++)
  {
    if(new[i]!=0)
      printf(""%d  frequency is %d \n"",i, new[i]);
  }

}
",27,822,225
"int main()
{
  int i,j,k, count = 0, frequency[26] = {0};
  char str_arr[100], str_arr1[100], f;
  printf(""Enter String to convert Upper to Lower & Lower to Upper"");
  scanf(""%[^\n]s"",str_arr);


  
  printf(""%s"",str_arr);
  for(i=0; str_arr[i] != '\0'; i++)
  {
    if(str_arr[i] > 'a' && str_arr[i] < 'z')
    {
      str_arr1[i] = (char)str_arr[i] - 32;
    }

    else if(str_arr[i] > 'A' && str_arr[i] < 'Z')
    {
      str_arr1[i] = (char)str_arr[i] + 32;
    }
    else
    {
      str_arr1[i] = str_arr[i];
    }
  }

  printf(""\nAfter Conversion String is %s\n"",str_arr1);
}
",27,823,282
"void* fun_call()
{
  sleep(1);
  printf(""First Thread is created\n"");
  
}


int main()
{
  pthread_t thread_id;
  printf(""Befor Execution of Thread\n"");
  pthread_create(&thread_id,NULL,fun_call,NULL);
  printf(""Thread_id is %lu\n"",thread_id);
  pthread_join(thread_id,NULL);
  printf(""after Execution of Thread\n"");
}

",27,824,126
"struct pair
{
  int min;
  int max;
};




struct pair max_min_array(int arr[], int no)
{
  struct pair minmax;
  if( no == 1)
  {
    minmax.max = arr[0];
    minmax.min = arr[0];
    return minmax;
  }
  if(arr[0] > arr[1])
  {
    minmax.max = arr[0];
    minmax.min = arr[1];
  }
  else
  {
    minmax.max = arr[1];
    minmax.min = arr[0];
  }
  
  for(int i = 0; i<no; i++)
  {
    if(arr[i] < minmax.min)
      minmax.min = arr[i];
    else if(arr[i] > minmax.max)
      minmax.max = arr[i];
  }
  return minmax;
}

int main()
{
  int arr[100] = {1000, 11, 445, 1, 330, 3000};
  int no = 6;
  struct pair minmax = max_min_array(arr,no);
  printf(""Max value is %d \nMin value is %d"",minmax.min,minmax.max);
}
",27,825,344
"int main()
{
  int i,j,k,r1,c1,r2,c2, flag = 0;
  printf(""Enter Value of r1, c1, r2, c2\n"");
  scanf(""%d%d%d%d"",&r1,&c1,&r2,&c2);
  int m1[r1][c1], m2[r2][c2], sum = 0, mul[r1][c2];





  printf(""Enter value of Matrix1\n"");
  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      scanf(""%d"",&m1[i][j]);
    }
  }

  printf(""Value Befor Transpose\n""); 
  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      printf(""%d"",m1[i][j]);
    }
    printf(""\n"");
  }

  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      m2[j][i] = m1[i][j];
    }
    printf(""\n"");
  }

  printf(""Value after Transpose\n""); 
  for(i=0; i<c1; i++)
  {
    for(j=0; j<r1; j++)
    {
      printf(""%d "",m2[i][j]);
    }
    printf(""\n"");
  }
}
",27,826,407
"void sighandler(int); 

int main ()
{
   signal(SIGINT, sighandler);

   while(1) 
   {
      printf(""Going to sleep for a second...\n"");
      sleep(1); 
   }
   return(0);
}
void sighandler(int signum) 
{
   printf(""Caught signal %d, coming out...\n"", signum);
   
}
",27,827,111
"void array_print(int arr[], int no)
{
  printf(""Array is :- "");
  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
}

int swap(int* a, int* b)
{
  int temp = *a;
  *a = *b;
  *b = temp;
}

void sort012(int arr[], int size)
{
  int low,mid,high;
  low = mid = 0;
  high = (size-1);
  while(mid<=high)
  {
    if(arr[mid]==0)
    {
      swap(&arr[low], &arr[mid]);
      low++;
      mid++;
      continue;
    }
    if(arr[mid]==1)
    {
      mid++;
      continue;
    }
    if(arr[mid]==2)
    {
      swap(&arr[mid], &arr[high]);
      high--;
      continue;
    }
  }
}

int main()
{
  int arr[] = {0,1,1,0,0,2,1,2,0,0,0,1};
  int no = 12;
  array_print(arr,no);
  sort012(arr,no);
  printf(""\n"");
  array_print(arr,no);
}
",27,828,349
"void array_print(int arr[], int no)
{
  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
}



void max_min_array(int arr[], int max, int min, int no)
{
  for(int i = 0; i<no; i++)
  {
    if(min>arr[i])
    {
      min = arr[i];
    }
    else
    {
      max = arr[i];
    }
  }
  printf(""Max is %d Min is %d"",max,min);
}

int main()
{
  int arr[100],no,j=0,temp=0,mid=0,max = 0, min = 0;
  printf(""Enter length of array"");
  scanf(""%d"",&no);
  for(int i = 0; i<no; i++)
  {
    scanf(""%d"",&arr[i]);
  }
  printf(""Array is :- "");
  array_print(arr,no);
  min = arr[0];
  max = arr[0];
  max_min_array(arr,max,min,no);  
}
",27,829,303
"void array_print(int arr[], int no)  
{
  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
  printf(""\n"");
}


int cyclic_rotate(int arr1[], int size_arr1)
{
  int meh = 0, msf = 0; 
  for(int i = 0; i<size_arr1;i++)
  {
    meh = meh + arr1[i]; 

    if(msf<meh) 
    {
      msf = meh;
    }
    if(meh<0) 
    { 
      meh = 0;
    }
  }
  return meh;  
}


int main()
{
  int arr1[] = {-2,-3,4,-1,-2,1,5,-3}, no,j=0;
  int size_arr1 = sizeof(arr1)/sizeof(int);
  array_print(arr1,size_arr1);
  int sum = cyclic_rotate(arr1,size_arr1);
  printf(""Sum is %d"",sum);
}
",27,830,293
"int main()
{
  int i,j,k, count = 0;
  char str_arr[100], f;
  printf(""Enter Character to find out Vowel/Consonant"");
  scanf(""%[^\n]s"",str_arr);



  printf(""Enter Vowel whose count you want to find\n"");
  scanf("" %c"",&f);
  for(i=0; str_arr[i] != '\0'; i++)
  {
    if(str_arr[i] == f)
    {
      count++;
    }
  }
  if(count ==  0)
  {
    printf(""Not even a Single Time Vowel is Found"");
  }
  else
  {
    printf(""Vowel is Found %d Times"",count);
  }


}
",27,831,199
"void *thread_fun(void *id)
{
  int *new_thread = (int *)id;
  printf(""new_thread id is %d\n"",*new_thread);

}



int main()
{
  pthread_t id;

  for(int i = 0; i<3; i++)
  {
    pthread_create(&id, NULL, thread_fun, (void *)&id);
  }
  pthread_join(id,NULL);

  pthread_exit(NULL);
}
",27,832,132
"int main()
{
  int a = 0, i=0,j=0,k=0,len_array1=0,len_array2=0,temp=0, total_count = 0;
  printf(""Enter Length of array1 and array2"");
  scanf(""%d%d"",&len_array1,&len_array2);
  int array1[len_array1],array2[len_array2],array3[len_array1+len_array2];



  total_count = len_array1+len_array2;
  printf(""Enter Element of Array1\n"");
  for(i=0; i<len_array1; i++)
  {
    scanf(""%d"",&array1[i]);
  }
  printf(""Enter Element of Array2\n"");
  for(i=0; i<len_array2; i++)
  {
    scanf(""%d"",&array2[i]);
  }
  for(i=0;i<len_array1;i++)
  {
    array3[j] = array1[i];
    j++;
  }
  for(i=0;i<len_array2;i++)
  {
    array3[j] = array2[i];
    j++;
  }
  for(i=0;i<total_count;i++)
  {
    for(j=i+1; j<len_array1+len_array2;j++)
    {
      if(array3[i] > array3[j])
      {
        temp = array3[i];
    array3[i] = array3[j];
    array3[j] = temp;
      }
    }
  }

  for(i=0;i<total_count;i++)
  {
    for(j=i+1; j<total_count;)
    {
      if(array3[i] == array3[j])
      {
        for(k=j;k<total_count;k++)
    {
          array3[k] = array3[k+1];
    }
        total_count--;
      }
      else
      {
        j++;
      }
    }
  }

  printf(""\nArray After Union, value of k is %d\n"",k);
  for(i=0; i<total_count; i++)
  {
    printf(""%d "",array3[i]);
  }
}
",27,833,598
"int main()
{
int i = 0, j = 0, k = 0;
char str1[100] = {0},str_sub[100][100] = {0},c;
printf(""Enter a string\n"");
scanf(""%[^\n]s"",str1);



printf(""Enter character From where you want to Split\n"");
scanf("" %c"",&c);

while(str1[k] != '\0')
{
  j = 0;
  while(str1[k] != c && str1[k] != '\0')
  {
    str_sub[i][j] = str1[k];
    j++;
    k++;
  }
  str_sub[i][j] = '\0';
  i++;
  if(str1 != '\0')
  {
    k++;
  }
}
int len = i;
printf(""Words after Splitting are:\n"");
for(i=0; i<len; i++)
{
  printf(""%s\n"",str_sub[i]);
}


}
",27,834,270
"int main()
{
  int i,j,k,r1,c1,r2,c2,flag = 0;
  printf(""Enter Value of r1, c1, r2, c2\n"");
  scanf(""%d%d%d%d"",&r1,&c1,&r2,&c2);
  int m1[r1][c1], m2[r2][c2], add_array[r1][c1], mul[r1][c2];





  printf(""Enter value of Matrix1\n"");
  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      scanf(""%d"",&m1[i][j]);
    }
  }
 
  do
  {
    printf(""Enter value of Matrix2\n"");
    for(i=0; i<r2; i++)
    {
      for(j=0; j<c2; j++)
      {
        scanf(""%d"",&m2[i][j]);
      }
    }

    for(i=0; i<r1; i++)
    {
      for(j=0; j<c1; j++)
      {
        add_array[i][j] = m1[i][j] + m2[i][j];
      }
    }

    for(i=0; i<r2; i++)
    {
      for(j=0; j<c2; j++)
      {
        printf(""%.2d "",add_array[i][j]);
      }
      printf(""\n"");
    }

    for(i=0; i<r2; i++)
    {
      for(j=0; j<c2; j++)
      {
        m1[i][j] = add_array[i][j];
    add_array[i][j] = 0;
      }
    }
    printf(""Enter 1 To Add more Matrix\n"");
    scanf(""%d"",&flag);
  }while(flag);

}
",27,835,515
"int main()
{
  int i,j,k,array1[100],array2[100],no=0, min = 0, max = 0;
  printf(""Enter number of Digit you want to use in Array\n"");
  scanf(""%d"",&no);  





  for(i=0; i<no; i++)
  {
    scanf(""%d"",&array1[i]);
  }
  
  for(i=0; i<no; i++)
  {
    printf(""%d "",array1[i]);
  }
 
  min = array1[0];
  max = array1[0];

  printf(""Min Value Befor is %d\n"",min);
  printf(""Max Value Befor is %d\n"",max);
  for(i=1; i<no; i++)
  {
    if(min > array1[i])
    {
      min = array1[i];    
    }
    
    if(max < array1[i])
    {
      max = array1[i];    
    }
  }
  printf(""Min Value After is %d\n"",min);
  printf(""Max Value After is %d\n"",max);
}
",27,836,304
"int main()
{
  int i=0,j=0,k=0,array[100]={0},lar_dif = 0, no = 0;
  printf(""Enter Length of Array"");
  scanf(""%d"",&no);





  for(i=0; i<no; i++)
  {
    scanf(""%d"",&array[i]);
  }
  
  
  for(i=0; i<no; i++)
  {
    for(j=i+1; j<no; j++)
    {
      if( (array[j] - array[i]) > lar_dif)
       {
         lar_dif = (array[j] - array[i]);
       }
    }
  }

  printf(""Value of Lar_dif is %d"",lar_dif);

}
",27,837,212
"struct node
{
  char c;
  short int s;
};


struct node
{
  short int s;
  char c;
  int i;
};


struct node
{
  char c;
  double d;
  int i;
};


struct node
{
  double d;
  int i;
  char c;
};




",27,838,95
"int main()
{
  int i,j,k,array[100],no=0, neg_sum = 0, pos_sum = 0;
  printf(""Enter How many numbers you want to Enter"");
  scanf(""%d"",&no);
  
  
  
  
  
  for(i=0; i<no; i++)
  {
    scanf(""%d"",&array[i]);
  }

  for(i=0; i<no; i++)
  {
    printf(""%d "",array[i]);
  }

  for(i=0; i<no; i++)
  {
    if( array[i] < 0)
    {
      neg_sum = neg_sum - (-array[i]);
    }
    if( array[i] > 0)
    {
     pos_sum = pos_sum + (array[i]);
    }
  }

  printf(""Neg_Sum is %d Pos_Sum is %d"",neg_sum,pos_sum);
}
",27,839,251
"int main()
{

  int a,b,i,j,flag=-1,small,large,mul=0,sum;
  printf(""Enter the value of the a and b"");
  scanf(""%d%d"",&a,&b);
  





  if( (a<0 && b<0) || (a>0 && b>0) )
  {
    flag = 0;
  }
  else if((a>0 && b<0) || (a<0 && b>0))
  {
    flag = 1;
  }
 

  if(a<0)
  { 
    a = -1 * a;
  }
  else if(b < 0)
  {
    b = -1 * b;
  }

  printf(""a is %d, b is %d"",a,b);
  if(a>b)
  {
    large = a;
    small = b;
  }
  else
  {
    large = b;
    small = a;
  }

  for(i=1;i<=small;i++)
  {
    mul = mul + large;
  }

  if(flag == 0)
  {
    printf(""multiplication is %d"",mul);
  }
  else if(flag == 1)
  {
    printf(""multiplication is -%d"",mul);
  }

}
",27,840,347
"int main()
{
  int i=0,j=0,k=0, no=0, min_sum = 0, sum = 0, min_i = 0, min_j = 0;
  printf(""Enter Length of Array"");
  scanf(""%d"",&no);
  int array1[no];





  for(i=0; i<no; i++)
  {
    scanf(""%d"",&array1[i]);
  }
  min_sum = array1[0] + array1[1];
  for(i=0; i<no; i++)
  {
    printf(""%d "",array1[i]);
  }
  
  for(i=0; i<no; i++)
  {
    for(j=i+1; j<no; j++)
    {
      sum = array1[i] + array1[j];
      if( abs(min_sum) > abs(sum) )
      {
        min_sum = sum;
    min_i = i;
    min_j = j;
      }  
    }
  }
 printf(""Sum of %d %d Gives Nearest\n"",array1[min_i],array1[min_j]); 
}
",27,841,304
"void array_print(int arr[], int no)
{
  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
  printf(""\n"");
}

void union_array(int arr1[], int arr2[], int size_arr1, int size_arr2)
{
  int total_size = size_arr1+size_arr2;
  int arr3[total_size], j = 0;
  for(int i = 0; i<size_arr1; i++)
  {
    arr3[j] = arr1[i];
    j++;
  }
  for(int i = 0; i<size_arr2; i++)
  {
    arr3[j] = arr2[i];
    j++;
  }
  printf(""Array befor Union :-"");
  array_print(arr3,total_size);
  for(int i = 0; i<total_size; i++)
  {
    for(int j = i+1; j<total_size;)
    {
      if(arr3[i] == arr3[j])
      {
        for(int k = j; k<total_size; k++)
    {
          arr3[k] = arr3[k+1];
    }
    total_size--;
      }
      else
      {
        j++;
      }
    }
  }
  printf(""Array after Union :-"");
  array_print(arr3,total_size);
}

int main()
{
  int arr1[] = {1,2,3,5,6,7,8,9,10}, arr2[] = {10,2,3,6,4,9,8,7,2,3,1} ,no,j=0,temp=0,mid=0,n=0;
  int size_arr1 = sizeof(arr1)/sizeof(int), size_arr2 = sizeof(arr2)/sizeof(int);
  array_print(arr1,size_arr1);
  array_print(arr2,size_arr2);
  union_array(arr1,arr2,size_arr1,size_arr2);
}
",27,842,540
"int main()
{
  int arr[100],arr1[100],no,j=0;
  printf(""Enter length of array"");
  scanf(""%d"",&no);




  for(int i = 0; i<no; i++)
  {
    scanf(""%d"",&arr[i]);
  }

  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
  printf(""\n"");
  for(int i = no-1; i>=0; i--)
  {
    arr1[j] = arr[i];
    j++;
  }

  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr1[i]);
  }
}
",27,843,200
"int main()
{
  int arr[100],no,j=0,temp=0,mid=0;
  printf(""Enter length of array"");
  scanf(""%d"",&no);




  for(int i = 0; i<no; i++)
  {
    scanf(""%d"",&arr[i]);
  }

  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }

  printf(""\n"");
  if(no%2 == 0)
  {
   mid = no/2;
  }
  else
  {
    mid = (no-1)/2;
  }

  for(int i = no-1; i>=mid; i--)
  
  {
    if(arr[i]<0)
    {
      temp = arr[i];
      arr[i] = arr[j];
      arr[j] = temp;
      j++;
    }
  }

  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
}
",27,844,282
"unsigned long addall()
{
  unsigned long sum = 0;
  int i = 0;
  while(i<=1000000000)
  {
    sum += i;
    i++;
  }
  return sum;

}

int main()
{
  clock_t start, end;
  double cpu_time_used;
  start = clock();
  unsigned long sum = 0, i =0;
  
  sum = addall();
  end = clock();
  cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;
  printf(""Sum of the numbers till 100 Crore is %lu and Time taken by Program without thread is %f"",sum,cpu_time_used);
}
",27,845,190
"int main()
{
  int i,j,k,r1,c1,r2,c2,row_sum = 0, col_sum = 0;
  printf(""Enter Value of r1, c1\n"");
  scanf(""%d%d"",&r1,&c1);
  int m1[r1][c1], sum = 0;



  printf(""Enter value of Matrix1\n"");
  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      scanf(""%d"",&m1[i][j]);
    }
  }

  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      printf(""%d "",m1[i][j]);
    }
    printf(""\n"");
  }

  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      row_sum = row_sum + m1[i][j];
    }
    printf(""Sum of Row[%d] is %d\n"",i,row_sum);
    row_sum = 0;
  }

  for(i=0; i<r1; i++)
  {
    for(j=0; j<c1; j++)
    {
      col_sum = col_sum + m1[j][i];
    }
    printf(""Sum of col[%d] is %d\n"",i,col_sum);
    col_sum = 0;
  }
 }

",27,846,411
"int g = 0;

void *fun_thread(void *vargs)
{
  int myid;
  myid = *(int *)vargs;
  static int s = 0;
  s++;
  g++;
  while(1)
  {
    int i = 1;
  }
  printf(""Thread Id u: %d, Thread Id d: %d, Static: %d, Global: %d\n"",myid,myid,++s,++g);

}


int main()
{
  int i = 0;
  pthread_t thread_id;
  for(i = 0; i<3; i++)
  {
    pthread_create(&thread_id,NULL,fun_thread,(void *)&i);
  }
  pthread_exit(NULL);
    return 0;

}
",27,847,210
"void array_print(int arr[], int no)  
{
  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
  printf(""\n"");
}

int ispresent(int arr1[], int size_arr1, int arr2[], int index_val) 
{
  for(int i = 0; i<size_arr1; i++)
  {
    if(arr1[i] == arr2[index_val])
    {
      return 1;
    }
  }
  return 0;
}

int remove_repeat(int arr[], int size_arr) 
{
  for(int i = 0; i<size_arr; i++)
  {
    for(int j = i+1; j<size_arr;j++)
    { 
      if(arr[i] == arr[j])
      {
        for(int k = j; k<size_arr; k++)
    {
          arr[k] = arr[k+1];
    }
    size_arr--;
      }
    }
  }
  return size_arr;
}
void intersection_array(int arr1[], int arr2[], int size_arr1, int size_arr2)
{
  int total_size = size_arr1+size_arr2, arr3[total_size], index_val = 0, k = 0i, last_count = 0;

  for(int i = 0; i<size_arr2; i++)
  {
    int val = ispresent(arr1,size_arr1,arr2,i); 
    if(val == 1)
    {
      arr3[k] = arr2[i];
      k++;
    }
  }

  printf(""Array after Union :-"");
  array_print(arr3,k);
}

int main()
{
  int arr1[] = {1,2,3,5,6,6,7,8,9,7,8,9,10}, arr2[] = {100,2,3,60,1,2,3,4,4,6,4,9,80,7,2,30,1} ,no,j=0,temp=0,mid=0,n=0;
  int size_arr1 = sizeof(arr1)/sizeof(int), size_arr2 = sizeof(arr2)/sizeof(int);
  array_print(arr1,size_arr1); 
  array_print(arr2,size_arr2); 
  size_arr1 = remove_repeat(arr1,size_arr1); 
  size_arr2 = remove_repeat(arr2,size_arr2); 
  array_print(arr1,size_arr1); 
  array_print(arr2,size_arr2); 
  intersection_array(arr1,arr2,size_arr1,size_arr2);
}
",27,848,725
"void array_print(int arr[], int no)
{
  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
}



int kmin(int arr[], int size, int k)
{
  int  temp = 0, count = 0, index = 0;

  while(count <= k)
  { 
    int min = arr[count], index = count;
    for(int i = count; i < size; i++)
    {
      if(min > arr[i])
      {
        min = arr[i];
    index = i;
      }
    }
    if(count != index)
    {
      temp = arr[index];
     
      arr[index] = arr[count];
      
      arr[count] = temp;
      
    }
    count++;
    
  }
  return (count-1);
}
int main()
{
  int arr[100] = {1000, 11, 445, 1, 330, 3000};
  int no = 6,k=0,rindex=0;
  printf(""Array is :- "");
  array_print(arr,no);
  printf(""Enter value of kth"");
  scanf(""%d"",&k);
  rindex = kmin(arr,(no-1),(k-1));
  printf(""rindex is %d\n"",rindex);
  printf(""kth Min value is %d"",arr[rindex]);
}
",27,849,384
"int main()
{
  int i,j = 0,k, count = 0, count1 = 0, len1 = 0, len2 = 0, flag = 0;
  char str[100], str_sub[100];
  printf(""Enter a Universal string to find Substring\n"");
  scanf(""%[^\n]s"",str);


  
  printf(""Enter a Substring\n"");
  scanf("" %[^\n]s"",str_sub);
  len1 = strlen(str);
  len2 = strlen(str_sub);
  for(i=0; i<=(len1 - len2); i++)
  {
    for(j=i; j<(i+len2); j++)
    {
      flag = 1;
      if( str[j] != str_sub[j-i])
      { 
        flag = 0;
    break;
      }
    }
    if(flag == 1)
    break;
  }
  
  if(flag == 1)
  {
    printf(""\nSub_String Found"");
  }
  else
  {
    printf(""Sub_String Not FOund"");
  }
}
",27,850,297
"void array_print(int arr[], int no)
{
  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
}

void reverse_array(int arr[], int START, int END)
{
  int temp = 0;
  while(START<END)
  {
    temp = arr[END];
    arr[END] = arr[START];
    arr[START] = temp;
    START++;
    END--;
  }
}
int main()
{
  int arr[100],no,j=0,temp=0,mid=0,n=0;
  printf(""Enter length of array"");
  scanf(""%d"",&no);




  for(int i = 0; i<no; i++)
  {
    scanf(""%d"",&arr[i]);
  }
  array_print(arr,no);
  reverse_array(arr,0,no-1);
  printf(""\n"");
  array_print(arr,no);
}
",27,851,263
"void myturn()
{
  while(1)
    {
      sleep(1);
      printf(""Myturn\n"");  
    }
}


void yourturn()
{
  while(1)
  {
    sleep(1);
    printf(""yourturn\n"");  
  }
}

int main()
{
  myturn(); 
  yourturn();   
}






















",27,852,119
"int main()
{
  int i,j,k,r1,c1,r2,c2;
  printf(""Enter Value of r1, c1, r2, c2\n"");
  scanf(""%d%d%d%d"",&r1,&c1,&r2,&c2);
  int m1[r1][c1], m2[r2][c2], sum = 0, mul[r1][c2];





  if( c1 == r2)
  {
    printf(""Enter value of Matrix1\n"");
    for(i=0; i<r1; i++)
    {
      for(j=0; j<c1; j++)
      {
        scanf(""%d"",&m1[i][j]);
      }
    }
  
    printf(""Enter value of Matrix2\n"");
    for(i=0; i<r2; i++)
    {
      for(j=0; j<c2; j++)
      {
        scanf(""%d"",&m2[i][j]);
      }
    }
  
    for(i=0; i<r1; i++)
    {
      for(j=0; j<c1; j++)
      {
        printf(""%d "",m1[i][j]);
      }
      printf(""\n"");
    }
  
    printf(""\n"") ;
    for(i=0; i<r1; i++)
    {
      for(j=0; j<c1; j++)
      {
        printf(""%d "",m2[i][j]);
      }
      printf(""\n"");
    }
   
  
    for(i=0; i<r1; i++)
    {
      for(j=0; j<c2; j++)
      {
        for(k=0; k<r2; k++)
        {
          sum = sum + m1[i][k] * m2[k][j];  
        }  
        mul[i][j] = sum;
        sum = 0;
      }
      printf(""\n"");
    } 
    printf(""Mutiplication of Matrix is -: \n"");
    for(i=0; i<r1; i++)
    {
      for(j=0; j<c1; j++)
      {
       printf(""%d "",mul[i][j]);
      }
      printf(""\n"");
    }
  }
  else
  {
    printf(""Multiplication is Not Possible"");
  } 

}
",27,853,620
"int main()
{
  int i,j,k,x,y,no,sum=0;
  printf(""Enter the number to find out happy or not"");
  scanf(""%d"",&no);







  while( sum != 1)
  {
    sum = 0;
    while(no>0)
    {
      i = no % 10;
      sum = sum + (i*i);
      no = no / 10;
    }
    no = sum ;
    printf(""sum is %d"", sum);
  }

  if( sum == 1)
  {
    printf(""Happy number"");
  }
  else
  {
    printf(""Not Happy number"");
  }
}
",27,854,183
"void array_print(int arr[], int no)
{
  for(int i = 0; i<no; i++)
  {
    printf(""%d "",arr[i]);
  }
}



int swap(int* a, int* b)
{
  int temp = *a;
  *a = *b;
  *b = temp;
}



int sort(int arr[], int size)
{
  int low,mid,high;
  low = mid = 0;
  high = (size-1);
  while(mid<=high)
  {
    switch (arr[mid]) 
    { 
      case 0: 
          swap(&arr[low++], &arr[mid++]); 
          break; 
      case 1: 
          mid++; 
          break; 
      case 2: 
          swap(&arr[mid], &arr[high--]); 
          break;
    }
  }
}




   
int main()
{
  int arr[] = {0,1,1,0,1,2,1,2,0,0,0,1};
  int no = 12;
  printf(""Array is :- "");
  array_print(arr,no);
  sort(arr,no);
  printf(""\n"");
  array_print(arr,no);
}
",27,855,333
"int main()
{
int i;
char str[100],c;
printf(""Enter a string\n"");
scanf(""%[^\n]s"",str);




printf(""%c\n"",str[0]);
printf(""%d"",str[0]-32);
for(i=0;i<strlen(str);i++)
{
    
    
  if(str[i]>='A'&&str[i]<='Z')
  {
      c=str[i];
      break;
  }
  else
  {
      continue;
  }
}

printf(""\nFirst capital letter of string %s is %c\n"",str,c);

}
",27,856,170
"void* myturn(void * arg)
{
  while(1)
  {
    sleep(1);
    printf(""myturn\n"");
  }
  return NULL;
}


void* yourturn(void * arg)
{
  while(1)
  {
    sleep(1);
    printf(""yourturn\n\n"");
  }
  return NULL;
}

int main()
{
  pthread_t thread_id, thread_id1;
  pthread_create(&thread_id,NULL,myturn,NULL);
  pthread_create(&thread_id1,NULL,yourturn,NULL);
  pthread_join(thread_id,NULL);
  pthread_join(thread_id1,NULL);
  
}



















",27,857,205
"int main()
{
  int i=0,j=0,k=0,array1[100]={0},array2[100]={0},no=0,delete_no=0,delete_index=0,flag=0;
  printf(""Enter Length of Array"");
  scanf(""%d"",&no);





  for(i=0; i<no; i++)
  {
    scanf(""%d"",&array1[i]);
  }
  for(i=0; i<no; i++)
  {
    printf(""%d "",array1[i]);
  }

  printf(""Enter number to delete it from Array\n"");
  scanf(""%d"",&delete_no);

  for(i=0; i<no; i++)
  {
    if(array1[i] == delete_no)
    {
      printf(""Number is %d Index is %d"",array1[i],i);
      delete_index = i;
      flag = 1;
    }
  }

  if(flag == 1)
  {
    for(i=0; i<no-1; i++)
    {
      if( i < delete_index)
      {
        array2[i] = array1[i];
      }
      if( i >= delete_index)
      {
        array2[i] = array1[i+1];
      }
    }
    printf(""\n"");
    for(i=0; i<no; i++)
    {
    for(i=0; i<no-1; i++)
    {
      printf(""%d "",array2[i]);
    }
  }
}
}
",27,858,411
"unsigned long sum[4];
void* addall(void * arg)
{
  long id = (long)arg;
  int start = id*250000000;
  int i = 1;
  while(i<=250000000)
  {
    sum[id] += (i + start);
    i++;
  }
  return NULL;
}

int main()
{
  clock_t start, end; 
  double cpu_time_used;
  start = clock();

  pthread_t id1, id2, id3, id4;

  pthread_create(&id1,NULL,addall,(void *)0);
  pthread_create(&id2,NULL,addall,(void *)1);
  pthread_create(&id3,NULL,addall,(void *)2);
  pthread_create(&id4,NULL,addall,(void *)3);
  pthread_join(id1,NULL);
  pthread_join(id2,NULL);
  pthread_join(id3,NULL);
  pthread_join(id4,NULL);
  end = clock();
  cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;
  printf(""Sum of the numbers till 100 Crore %lu and Time taken by Program with thread is %f\n"",sum[0]+sum[1]+sum[2]+sum[3],cpu_time_used);

}
",27,859,362
"int main()
{
  int i,j,k,x,y,no,sum=0,dummy1=0;
  printf(""Enter the number to find out happy or not"");
  







  for(j=1; j<=1000; j++)
  {
    sum = 0;
    dummy1 = j;
    while( sum != 1 && sum != 4 )
    {
      sum = 0;
      while(dummy1>0)
      {
        i = dummy1 % 10;
        sum = sum + (i*i);
        dummy1 = dummy1 / 10;
      }
      dummy1 = sum ;
    }
 
    if( sum == 1)
    {
      printf(""%d "",j);
    }
  }
}
",27,860,202
"int main()
{
  int i=0,j=0,k=0,array[100]={0}, no = 0,latest_no = 0, last = 0, sum = 0;
  printf(""Enter Length of Array"");
  scanf(""%d"",&no);





  for(i=0; i<no; i++)
  {
    scanf(""%d"",&array[i]);
  }
  
  for(i=0; i<no; i++)
  {
    latest_no = array[i];
    sum = 0;
    while(latest_no != 0)
    {
      last = latest_no%10;
      sum = sum + (last*last*last);
      latest_no = latest_no/10;
    }
    printf(""value of Sum is %d\n"",sum);
    if( array[i] == sum)
    {
      printf(""%d is Armstrong\n\n"",sum);
    }
    else
    {
      printf(""No Number is Armstrong\n\n"");
    }
  }



}
",27,861,277
"#define CAPACITY 100


int top = -1;
char stack[CAPACITY];

void push(char item)
{
    if(top>= CAPACITY-1)
    {
        printf(""Stack is Full\n"");
    }
    else
    {
        top++;
        stack[top] = item;
    }
}
char pop()
{
    char item;
    item = stack[top];
    top--;
    return(item);
}
int precedence(char symbol)
{
    if(symbol == '^')
        return 3;
    else if(symbol == '*' || symbol == '/')
        return 2;
    else if(symbol == '+' || symbol == '-')
        return 1;
    else
        return 0;
}
int is_operator(char symbol)
{
    if(symbol == '^' || symbol == '/' || symbol == '*' || symbol == '+' || symbol == '-')
        return 1;
    else
        return 0;
}


int main()
{
    char infix[CAPACITY], postfix[CAPACITY], item, temp;
    int i = 0, j = 0;
    printf(""Enter an Infix Expression to Convert into Postfix : "");
    gets(infix);

    while(infix[i]!='\0')
    {
        item = infix[i];
        if(item == '(')
        {
            push(item);
        }
        else if((item >= 'A' && item <= 'Z') || (item >= 'a' && item <= 'z'))
        {
            postfix[j] = item;
            j++;
        }
        else if(is_operator(item) == 1)
        {
            temp = pop();
            while(is_operator(temp) == 1 && precedence(temp) >= precedence(item))
            {
                postfix[j] = temp;
                j++;
                temp = pop();
            }
            push(temp);
            push(item);
        }
        else if(item == ')')
        {
            temp = pop();
            while(temp != '(')
            {
                postfix[j] = temp;
                j++;
                temp = pop();
            }
        }
        else
        {
            printf(""\nInvalid Expression"");
        }
        i++;
    }
    while(top > -1)
    {
        postfix[j] = pop();
        j++;
    }
    printf(""\nArithmetic Expression in Postfix form is : "");
    puts(postfix);
    return 0;
}
",28,862,652
"int main()
{
    
    int i, ele, loc, n;
    printf(""Enter the length of array\n"");
    scanf(""%d"", &n);
    printf(""Enter Array Elements\n"");
    int arr[50];
    for(i = 0; i<n; i++)
    {
        scanf(""%d"", &arr[i]);
    }
    for(i = 0; i<n; i++)
    {
        printf(""%d "", arr[i]);
    }

    
    printf(""\n Enter element to inset\n"");
    scanf(""%d"", &ele);
    printf(""Enter location to insert\n"");
    scanf(""%d"", &loc);
    for(i = n-1; i>=loc; i-- )
    {
        arr[i+1] = arr[i];
    }
    arr[loc] = ele;
    for(i = 0; i<=n; i++)
    {
        printf(""%d "", arr[i]);
    }

    
    int m;
    printf(""\nEnter the position of element to delete\n"");
    scanf(""%d"", &m);

    for(i = m; i<n; i++)
    {
        arr[i] = arr[i+1];
    }

    for(i = 0; i<n; i++)
    {
        printf(""%d "", arr[i]);
    }

    
    printf(""\nArray in Reverse Order: \n"");
    for(i = n-1; i>=0; i--)
    {
        printf(""%d "", arr[i]);
    }
    return 0;
}
",28,863,404
"#define CAPACITY 100


int top = -1;
char stack[CAPACITY];

void push(char item)
{
    if(top>= CAPACITY-1)
    {
        printf(""Stack is Full\n"");
    }
    else
    {
        top++;
        stack[top] = item;
    }
}
char pop()
{
    char item;
    item = stack[top];
    top--;
    return(item);
}
int precedence(char symbol)
{
    if(symbol == '^')
        return 3;
    else if(symbol == '*' || symbol == '/')
        return 2;
    else if(symbol == '+' || symbol == '-')
        return 1;
    else
        return 0;
}
int is_operator(char symbol)
{
    if(symbol == '^' || symbol == '/' || symbol == '*' || symbol == '+' || symbol == '-')
        return 1;
    else
        return 0;
}


int main()
{
    char infix[CAPACITY], postfix[CAPACITY], item, temp;
    int i = 0, j = 0;
    printf(""Enter an Infix Expression to Convert into Postfix : "");
    gets(infix);

    while(infix[i]!='\0')
    {
        item = infix[i];
        if(item == '(')
        {
            push(item);
        }
        else if((item >= 'A' && item <= 'Z') || (item >= 'a' && item <= 'z'))
        {
            postfix[j] = item;
            j++;
        }
        else if(is_operator(item) == 1)
        {
            temp = pop();
            while(is_operator(temp) == 1 && precedence(temp) >= precedence(item))
            {
                postfix[j] = temp;
                j++;
                temp = pop();
            }
            push(temp);
            push(item);
        }
        else if(item == ')')
        {
            temp = pop();
            while(temp != '(')
            {
                postfix[j] = temp;
                j++;
                temp = pop();
            }
        }
        else
        {
            printf(""\nInvalid Expression"");
        }
        i++;
    }
    while(top > -1)
    {
        postfix[j] = pop();
        j++;
    }
    printf(""\nArithmetic Expression in Postfix form is : "");
    puts(postfix);
    return 0;
}
",28,864,652
"struct node
{
    int data;
    struct node* link;
};
struct node* top = NULL;
void enqueue();
void dequeue();
void traverse();

int main()
{
    int choice;
    while(1)
    {
        printf(""Queue Operations : \n"");
        printf(""1. Enqueue\n"");
        printf(""2. Dequeue\n"");
        printf(""3. Traverse\n"");
        printf(""4. Exit\n"");
        printf(""Enter your choice : "");
        scanf(""%d"", &choice);
        switch(choice)
        {
        case 1:
            enqueue();
            break;
        case 2:
            dequeue();
            break;
        case 3:
            traverse();
            break;
        case 4:
            exit(0);
            break;
        default:
            printf(""Invalid Choice\n"");
        }
    }
    return 0;
}
void enqueue()
{
    struct node* temp;
    temp = (struct node*)malloc(sizeof(struct node));
    printf(""Enter an element to insert : "");
    scanf(""%d"", &temp->data);
    temp->link = NULL;

    if(top == NULL)
    {
        top = temp;
    }
    else
    {
        struct node* p;
        p = top;
        while(p->link != NULL)
        {
            p = p->link;
        }
        p->link = temp;
    }
}
void dequeue()
{
    struct node* temp;
    printf(""%d deleted.\n"", top->data);
    if(top == NULL)
    {
        printf(""Queue is Empty\n"");
    }
    else
    {
        temp = top;
        top = temp->link;
        temp->link = NULL;
        free(temp);
    }
}
void traverse()
{
    struct node* temp;
    if(top == NULL)
    {
        printf(""Queue is Empty\n"");
    }
    else
    {
        temp = top;
        while(temp != NULL)
        {
            printf(""%d-->"",temp->data);
            temp = temp->link;
        }
        printf(""\n"");
    }
}
",28,865,554
"#define CAPACITY 50

char stack[CAPACITY];
int i, len; count = 0;
int top = -1;

void push(char arg)
{
    top++;
    stack[top] = arg;
}
char pop()
{
    char c;
    c = stack[top];
    top--;
    return c;
}

int main()
{
    printf(""Enter a String to Check\n"");
    scanf(""%s"", stack);
    len = strlen(stack);
    
    for(i = 0; i<len; i++)
    {
        push(stack[i]);
    }
    for(i = 0; i<len; i++)
    {
        if(stack[i]==pop())
        {
            count++;
        }
    }
    if(count == len)
    {
        printf(""Given string is Palindrome\n"");
    }
    else
    {
        printf(""Given string is not Palindrome\n"");
    }
    return 0;
}
",28,866,264
"#define CAPACITY 50

char stack[CAPACITY];
int i, len; count = 0;
int top = -1;

void push(char arg)
{
    top++;
    stack[top] = arg;
}
char pop()
{
    char c;
    c = stack[top];
    top--;
    return c;
}

int main()
{
    printf(""Enter a String to Check\n"");
    scanf(""%s"", stack);
    len = strlen(stack);
    
    for(i = 0; i<len; i++)
    {
        push(stack[i]);
    }
    for(i = 0; i<len; i++)
    {
        if(stack[i]==pop())
        {
            count++;
        }
    }
    if(count == len)
    {
        printf(""Given string is Palindrome\n"");
    }
    else
    {
        printf(""Given string is not Palindrome\n"");
    }
    return 0;
}
",28,867,264
"struct node
{
    int data;
    struct node* left;
    struct node* right;
};
int len;
struct node * root = NULL;
void addend(void);
void addbegin(void);
void addafter(void);
void display(void);
void reverse(void);
void del(void);
void delvalue(int value);
void dellist(void);

int search(int value);
int length(void);

int main()
{
    int choice, value;
    while(1)
    {
        printf(""Double Linked List Operations : \n"");
        printf(""1. Append\n"");
        printf(""2. Add at Begin\n"");
        printf(""3. Add at After\n"");
        printf(""4. Display\n"");
        printf(""5. Reverse\n"");
        printf(""6. Delete\n"");
        printf(""7. Delete Value\n"");
        printf(""8. Delete List\n"");
        printf(""9. Exit\n"");
        printf(""Enter your choice : "");
        scanf(""%d"", &choice);
        switch(choice)
        {
        case 1:
            addend();
            break;
        case 2:
            addbegin();
            break;
        case 3:
            addafter();
            break;
        case 4:
            display();
            break;
        case 5:
            reverse();
            break;
        case 6:
            del();
            break;
        case 7:
            printf(""Enter the value to delete : "");
            scanf(""%d"", &value);
            delvalue(value);
            printf(""\n\n"");
            break;
        case 8:
            dellist();
            break;
        case 9:
            exit(0);
            break;
        default:
            printf(""Invalid Choice\n\n"");
        }
    }
    return 0;
}

void addend()
{
    struct node* temp;
    temp = (struct node*)malloc(sizeof(struct node));
    printf(""Enter an element to append : "");
    scanf(""%d"", &temp->data);
    printf(""%d inserted.\n\n"", temp->data);
    temp->left = NULL;
    temp->right = NULL;
    if(root == NULL)
    {
        root = temp;
    }
    else
    {
        struct node* p = root;
        while(p->right != NULL)
        {
            p = p->right;
        }
        p->right = temp;
        temp->left = p;
    }
}

void addbegin()
{
    struct node* temp;
    temp = (struct node*)malloc(sizeof(struct node));
    printf(""Enter an element to insert : "");
    scanf(""%d"", &temp->data);
    printf(""%d inserted.\n\n"", temp->data);
    temp->left = NULL;
    temp->right = NULL;
    if(root == NULL)
    {
        root = temp;
    }
    else
    {
        temp->right = root;
        root->left = temp;
        root = temp;
    }
}

void addafter()
{
    struct node* temp, *p = root, *q;
    int key, i = 1;
    printf(""Enter the location where you want to insert : "");
    scanf(""%d"", &key);
    if(key > len)
    {
        printf(""Unable to insert \n\n"");
    }
    else
    {
        while(i < key)
        {
            p = p->right;
            i++;
        }
        q = p->right;
        temp = (struct node*)malloc(sizeof(struct node));
        printf(""Enter an element to insert : "");
        scanf(""%d"", &temp->data);
        printf(""%d inserted\n\n"", temp->data);
        temp->left = NULL;
        temp->right = NULL;
        temp->right = q;
        q->left = temp;
        p->right = temp;
        temp->left = p;
    }
}


void display()
{
    struct node * temp = root;
    if(root == NULL)
    {
        printf(""List is Empty\n\n"");
    }
    else
    {
        while(temp != NULL)
        {
            printf(""%d --> "", temp->data);
            temp = temp->right;
        }
        printf(""\n\n"");
    }
}

void reverse()
{
    struct node* temp = root;
    if(root == NULL)
    {
        printf(""List is Empty\n\n"");
    }
    else
    {
        while(temp->right != NULL)
        {
            temp = temp->right;
        }
        while(temp != NULL)
        {
            printf(""%d --> "", temp->data);
            temp = temp->left;
        }
        printf(""\n\n"");
    }
}


void del()
{
    struct node* temp;
    int key, i = 1;
    printf(""Enter the location of element to delete : "");
    scanf(""%d"", &key);
    if(key > length())
    {
        printf(""Invalid Location to perform delete\n\n"");
    }
    else if(key == 1)
    {
        temp = root;
        root = temp->right;
        temp->left = NULL;
        free(temp);
    }
    else if(key == length())
    {
        struct node * temp, *p;
        p = root;
        while(p->right != NULL)
        {
            p = p->right;
        }
        temp = p->left;
        temp->right = NULL;
        free(p);
    }
    else
    {
        struct node *p, *q;
        temp = root;
        while(i < key)
        {
            temp = temp->right;
            i++;
        }
        q = temp->right;
        p = temp->left;
        p->right = q;
        q->left = p;
        free(temp);
    }
}

void delvalue(int value)
{
    struct node* temp = root, *p, *q;
    
    if(root->data == value)
    {
        root = temp->right;
        free(temp);
    }
    else if(search(value) == 1)
    {
        while(temp->data != value)
        {
            temp = temp->right;
        }
        q = temp->right;
        p = temp->left;
        if(temp->right != NULL)
        {
            p->right = q;
            q->left = p;
            free(temp);
        }
        else
        {
            p->right = NULL;
            free(temp);
        }
    }
    else
    {
        printf(""Value not found in the list.\n\n"");
    }
}

void dellist()
{
    struct node *temp = root, *p;
    while(temp != NULL)
    {
        p = temp->right;
        free(temp);
        temp = p;
    }
    printf(""All the elements in the list deleted successfully.\n\n"");
    root = NULL;
}


int length()
{
    struct node* temp = root;
    int count = 0;
    while(temp != NULL)
    {
        count++;
        temp = temp->right;
    }
    return count;
}

int search(int value)
{
    struct node *p = root;
    while(p != NULL)
    {
        if(p->data == value)
        {
            return 1;
        }
        else
        {
            p = p->right;
        }
    }
    return 0;
}


",28,868,1918
"struct node
{
    int data;
    struct node* left;
    struct node* right;
};
struct node * root = NULL;

void insert(int ele);
void traverse_inorder(struct node* root);
void traverse_preorder(struct node* root);
void traverse_postorder(struct node* root);
int count_leaves(struct node* root);
int height(struct node* root);
int main()
{
    while(1)
    {
        int choice, ele;
        printf(""<--- Operations on BST --->\n"");
        printf(""1. Insertion\n"");
        printf(""2. In order Traversal\n"");
        printf(""3. Pre-order Traversal\n"");
        printf(""4. Post order Traversal\n"");
        printf(""5. Count Leaves\n"");
        printf(""6. Height\n"");
        printf(""7. Exit\n"");
        printf(""Enter your choice : "");
        scanf(""%d"", &choice);
        switch(choice)
        {
        case 1:
            printf(""Enter an element to insert : "");
            scanf(""%d"", &ele);
            printf(""%d successfully inserted.\n\n"", ele);
            insert(ele);
            break;
        case 2:
            traverse_inorder(root);
            printf(""\n\n"");
            break;
        case 3:
            traverse_preorder(root);
            printf(""\n\n"");
            break;
        case 4:
            traverse_postorder(root);
            printf(""\n\n"");
            break;
        case 5:
            printf(""Total Leaf Count : %d\n\n"", count_leaves(root));
            break;
        case 6:
            printf(""Maximum Height : %d\n\n"", height(root));
            break;
        case 7:
            exit(0);
            break;
        default:
            printf(""Invalid Choice\n\n"");
        }
    }
    return 0;
}

void insert(int ele)
{
    struct node* temp, *p, *q;
    temp = (struct node*)malloc(sizeof(struct node));
    temp->data = ele;
    temp->left = NULL;
    temp->right = NULL;
    if(root == NULL)
    {
        root = temp;
    }
    else
    {
        q = root;
        while(1)
        {
            p = q;
            if(temp->data < p->data)
            {
                q = q->left;
                if(q == NULL)
                {
                    p->left = temp;
                    return;
                }
            }
            else
            {
                q = q->right;
                if(q == NULL)
                {
                    p->right = temp;
                    return;
                }
            }
        }
    }
}

void traverse_inorder(struct node* root)
{
    if(root != NULL)
    {
        traverse_inorder(root->left);
        printf(""%d\t"", root->data);
        traverse_inorder(root->right);
    }
}
void traverse_preorder(struct node* root)
{
    if(root != NULL)
    {
        printf(""%d\t"", root->data);
        traverse_preorder(root->left);
        traverse_preorder(root->right);
    }
}
void traverse_postorder(struct node* root)
{
    if(root != NULL)
    {
        traverse_postorder(root->left);
        traverse_postorder(root->right);
        printf(""%d\t"", root->data);
    }
}

int count_leaves(struct node* root)
{
    if (root == NULL)
    {
        return 0;
    }
    else if (root->left == NULL && root->right == NULL)
    {
        return 1;
    }
    else
    {
        return count_leaves(root->left)+count_leaves(root->right);
    }
}

int height(struct node* root)
{
    if(root == NULL)
    {
        return 0;
    }
    else
    {
        int c1 = height(root->left);
        int c2 = height(root->right);
        if(c1>c2)
        {
            return c1+1;
        }
        else
        {
            return c2+1;
        }
    }
}
",28,869,1102
"#define CAPACITY 5
int stack[CAPACITY], top=-1;

void push(int item);
int pop();
void traverse();

int isFull();
int isEmpty();
int main()
{
    while(1)
    {
        int ch, item;
        printf(""1. Push \n"");
        printf(""2. Pop\n"");
        printf(""3. Traverse \n"");
        printf(""4. Exit\n"");
        printf(""Enter your choice : "");
        scanf(""%d"", &ch);
        
        switch (ch)
        {
        case 1:
            printf(""Enter element to push\n"");
            scanf(""%d"", &item);
            push(item);
            break;
        case 2:
            item = pop();
            if(item == 0)
            {
                printf(""Stack is underflow\n"");
            }
            else
            {
                printf(""Popped item is %d \n"", item);
            }
            break;
        case 3:
            traverse();
            break;
        case 4:
            exit(0);
            break;
        default:
            printf(""Invalid Input\n"");
        }
    }
    return 0;
}

void push(int ele)
{
    if(isFull())
    {
        printf(""Stack is Full \n"");
    }
    else
    {
        top++;
        stack[top] = ele;
        printf(""%d pushed \n"", ele);
    }
}

int pop()
{
    if(isEmpty())
    {
        return 0;
    }
    else
    {
        return stack[top--];
    }
}

void traverse()
{
    if(isEmpty())
    {
        printf(""Stack is Empty\n"");
    }
    else
    {
        int i;
        for(i = 0; i<=top; i++)
        {
            printf(""%d \n"", stack[i]);
        }
    }
}


int isFull()
{
    if(top == CAPACITY -1)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

int isEmpty()
{
    if(top == -1)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
",28,870,591
"#define CAPACITY 50

int top = -1;
int stack[CAPACITY];
char postfix_expression[CAPACITY];
void push(int ch);
int pop();
int isEmpty();
int evaluation();

int main()
{
    int final_answer;
    printf(""Enter Expression to Evaluate : \n"");
    scanf(""%s"", postfix_expression);
    final_answer = evaluation();
    printf(""Evaluation of Postfix Expression : %d"", final_answer);
    return 0;
}
void push(int ch)
{
    if(top > CAPACITY)
    {
        printf(""Stack Overflow\n"");
    }
    else
    {
        top++;
        stack[top] = ch;
    }
}
int pop()
{
    if(isEmpty())
    {
        printf(""Stack is Empty\n"");
    }
    else
    {
        return stack[top--];
    }
}
int isEmpty()
{
    if(top == -1)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
int evaluation()
{
    int x, y, temp, value, i;
    for(i = 0; i<strlen(postfix_expression); i++)
    {
        if(postfix_expression[i] <= '9' && postfix_expression[i]>= '0')
        {
            push(postfix_expression[i]-'0');
        }
        else
        {
            x = pop();
            y = pop();
            switch(postfix_expression[i])
            {
            case '+':
                temp = y+x;
                break;
            case '-':
                temp = y-x;
                break;
            case '*':
                temp = y*x;
                break;
            case '/':
                temp = y/x;
                break;
            case '%':
                temp = y%x;
                break;
            case '^':
                temp = pow(y,x);
                break;
            default:
                printf(""Invalid\n"");
            }
            push(temp);
        }
    }
    value = pop();
    return value;
}
",28,871,556
"int main()
{
    int arr[10][10], i,j,k, arr2[10][10],arr3[10][10], sum=0;

    
    printf(""Read first 3x3 matrix\n"");
    for(i = 0; i<3; i++)
    {

        for(j = 0; j<3; j++)
        {
            printf(""Element - [%d],[%d] : "", i, j);
            scanf(""%d"", &arr[i][j]);
        }
    }
    printf(""The first matrix is : \n"");
    for(i = 0; i<3; i++)
    {
        printf(""\n"");
        for(j = 0; j<3; j++)
        {
            printf(""%d "", arr[i][j]);
        }
    }

    
    printf(""Read second 3x3 matrix\n"");
    for(i = 0; i<3; i++)
    {

        for(j = 0; j<3; j++)
        {
            printf(""Element - [%d],[%d] : "", i, j);
            scanf(""%d"", &arr2[i][j]);
        }
    }
    printf(""The second matrix is : \n"");
    for(i = 0; i<3; i++)
    {
        printf(""\n"");
        for(j = 0; j<3; j++)
        {
            printf(""%d "", arr2[i][j]);
        }
    }
    printf(""\n"");


    
    for(i = 0; i<=2; i++)
    {
        for(j=0; j<=2; j++)
        {

            for(k = 0; k<=2; k++)
            {
                sum = sum + arr[i][k] * arr2[k][j];
            }
            arr3[i][j] = sum;
            sum  = 0;
        }
    }

    
    printf(""The result is : \n"");
    for(i = 0; i<3; i++)
    {
        for(j=0; j<3; j++)
        {

            printf(""%d \t"", arr3[i][j]);
        }
        printf(""\n"");
    }
    return 0;
}
",28,872,575
"void addend(void);
void addbegin(void);
void addafter(void);
void display(void);
void del(void);
void delval(int value);
void dellist(void);

int len;
int length(void);
int search(int value);

struct node
{
    int data;
    struct node* link;
};
struct node* root = NULL;


int main()
{
    int choice, value;
    while(1)
    {
        printf(""Single Linked List Operations : \n"");
        printf(""1. Add at End\n"");
        printf(""2. Add at Begin\n"");
        printf(""3. Add at After\n"");
        printf(""4. Display\n"");
        printf(""5. Delete\n"");
        printf(""6. Delete Value\n"");
        printf(""7. Delete List\n"");
        printf(""8. Quit\n"");
        printf(""Enter your choice : "");
        scanf(""%d"", &choice);
        switch(choice)
        {
        case 1:
            addend();
            break;
        case 2:
            addbegin();
            break;
        case 3:
            addafter();
            break;
        case 4:
            display();
            break;
        case 5:
            del();
            break;
        case 6:
            printf(""Enter the value to delete : "");
            scanf(""%d"", &value);
            delval(value);
            break;
        case 7:
            dellist();
            break;
        case 8:
            exit(0);
            break;
        default:
            printf(""Invalid Entry\n"");
        }
    }
    return 0;
}

void addend()
{
    struct node* temp;
    temp = (struct node*)malloc(sizeof(struct node));
    printf(""Enter Node Data : "");
    scanf(""%d"", &temp->data);
    printf(""%d inserted.\n\n"", temp->data);
    temp->link = NULL;

    if(root == NULL)
    {
        root = temp;
    }
    else
    {
        struct node* p;
        p = root;
        while(p->link != NULL)
        {
            p = p->link;
        }
        p->link = temp;
    }
}

void addbegin()
{
    struct node* temp;
    temp = (struct node*)malloc(sizeof(struct node));
    printf(""Enter a node to insert : "");
    scanf(""%d"", &temp->data);
    printf(""%d inserted.\n"", temp->data);
    temp->link = root;
    root = temp;
}

void addafter()
{
    struct node* temp, * p;
    int key, i = 1;
    printf(""Enter location : "");
    scanf(""%d"", &key);
    len = length();
    if(key > len)
    {
        printf(""Unable to insert\n"");
        printf(""The list is having only %d nodes.\n"", len);
    }
    else
    {
        p = root;
        while(i < key)
        {
            p = p->link;
            i++;
        }
        temp = (struct node*)malloc(sizeof(struct node));
        printf(""Enter a node to insert : "");
        scanf(""%d"", &temp->data);
        printf(""%d inserted.\n"", temp->data);
        temp->link = p->link;
        p->link = temp;
    }
}

void display()
{
    struct node* temp;
    temp = root;
    if(temp == NULL)
    {
        printf(""List is Empty\n"");
    }
    else
    {
        while(temp != NULL)
        {
            printf(""%d-->"", temp->data);
            temp = temp->link;
        }
        printf(""\n\n"");
    }
}

void del()
{
    struct node* temp;
    int key;
    printf(""Enter the key : "");
    scanf(""%d"", &key);
    if(key > length())
    {
        printf(""Invalid Location\n"");
    }
    else if(key == 1)
    {
        temp = root;
        root = temp->link;
        temp->link = NULL;
        free(temp);
    }
    else
    {
        struct node* p = root, *q;
        int i = 1;
        while(i < key - 1)
        {
            p = p->link;
            i++;
        }
        q = p->link;
        p->link = q->link;
        q->link = NULL;
        free(q);
    }
}

void delval(int value)
{
    struct node* temp, *p = root, *q;
    q = root->link;
    if(root->data == value)
    {
        temp = root;
        root = temp->link;
        temp->link = NULL;
        free(temp);
    }
    else if(search(value) == 1)
    {
        while(q->data != value)
        {
            p = p->link;
            q = p->link;
        }
        p->link = q->link;
        q->link = NULL;
        free(q);
    }
    else
    {
        printf(""Value not found in the list.\n\n"");
    }
}

void dellist()
{
    struct node *temp = root, *p;
    while(temp != NULL)
    {
        p = temp->link;
        free(temp);
        temp = p;
    }
    printf(""All the elements in the list deleted successfully.\n\n"");
    root = NULL;
}


int length()
{
    int count = 0;
    struct node* temp;
    temp = root;
    while(temp != NULL)
    {
        count++;
        temp = temp->link;
    }
    printf(""The length of the linked list is : %d\n\n"", count);
    return count;
}

int search(int value)
{
    struct node *p = root;
    while(p != NULL)
    {
        if(p->data == value)
        {
            return 1;
        }
        else
        {
            p = p->link;
        }
    }
    return 0;
}
",28,873,1571
"int i, j, k, m = 1, n, a, b;
int min, mincost = 0, cost[9][9], parent[9];
int find(int i);
int uni(int i, int j);
int main()
{
    printf(""Implementation of Kruskal's Algorithm\n"");
    printf(""Enter the number of vertices: "");
    scanf(""%d"", &n);

    
    printf(""\nEnter the cost adjacency matrix: \n"");
    for (i = 1; i <= n; i++)
    {
        for (j = 1; j<= n; j++)
        {
            scanf(""%d"", &cost[i][j]);
            if (i == j)
            {
                cost[i][j] = 0;
            }
            else if(cost[i][j]==0)
            {
                cost[i][j] = 999;
            }
        }
    }
    
    printf(""The Adjacency Matrix is:\n"");
    for(i = 1; i <= n; i++)
    {
        for(j = 1; j <= n; j++)
        {
            printf(""%d\t"", cost[i][j]);
        }
        printf(""\n"");
    }
    printf(""The edges of Minimum Cost Spanning Tree are: "");
    while(m < n)
    {
        for(i = 1, min = 999; i <= n; i++)
        {
            for(j = 1; j <= n; j++)
            {
                if(cost[i][j] < min)
                {
                    min = cost[i][j];
                    a = i;
                    b = j;
                }
            }
        }
        if(uni(find(a), find(b)))
        {
            printf(""\n%d. edge (%d, %d) = %d\n"", m++, a, b, min);
            mincost += min;
        }
        cost[a][b] = cost[b][a] = 999;
    }
    printf(""\nMinimum Cost = %d\n"", mincost);
    return 0;
}
int find(int i)
{
    while(parent[i])
        i = parent[i];
    return i;
}
int uni(int i, int j)
{
    if(i != j)
    {
        parent[j] = i;
        return 1;
    }
    return 0;
}
",28,874,621
"#define CAPACITY 100

int top = -1;
char stack[CAPACITY];

void push(char item)
{
    if(top>= CAPACITY-1)
    {
        printf(""Stack is Full\n"");
    }
    else
    {
        top++;
        stack[top] = item;
    }
}
char pop()
{
    char item;
    item = stack[top];
    top--;
    return(item);
}
int precedence(char symbol)
{
    if(symbol == '^')
        return 3;
    else if(symbol == '*' || symbol == '/')
        return 2;
    else if(symbol == '+' || symbol == '-')
        return 1;
    else
        return 0;
}
int is_operator(char symbol)
{
    if(symbol == '^' || symbol == '/' || symbol == '*' || symbol == '+' || symbol == '-')
        return 1;
    else
        return 0;
}

int main()
{
    char infix[CAPACITY], prefix[CAPACITY], tempo[CAPACITY], item, temp;
    int i = 0, j = 0, k = 0, l = 0;
    printf(""Enter an Infix Expression to Convert into Prefix : "");
    gets(tempo);
    for(k = strlen(tempo)-1; k>=0; k--)
    {
        infix[l] = tempo[k];
        l++;
    }
    while(infix[i]!='\0')
    {
        item = infix[i];
        if(item == ')')
        {
            push(item);
        }
        else if((item >= 'A' && item <= 'Z') || (item >= 'a' && item <= 'z'))
        {
            prefix[j] = item;
            j++;
        }
        else if(is_operator(item) == 1)
        {
            temp = pop();
            while(is_operator(temp) == 1 && precedence(temp) >= precedence(item))
            {
                prefix[j] = temp;
                j++;
                temp = pop();
            }
            push(temp);
            push(item);
        }
        else if(item == '(')
        {
            temp = pop();
            while(temp != ')')
            {
                prefix[j] = temp;
                j++;
                temp = pop();
            }
        }
        else
        {
            printf(""Invalid Expression\n"");
        }
        i++;
    }
    while(top > -1)
    {
        prefix[j] = pop();
        j++;
    }
    printf(""Arithmetic Expression in Prefix form is : "");
    for(i = strlen(prefix)-1; i>= 0 ; i--)
    {
        printf(""%c"", prefix[i]);
    }
    return 0;
}
",28,875,733
"int main()
{
    char str[31];
    long int tam, soma = 0, pot;

    fgets(str, 31, stdin);

    for (int i=0; str[i] != '\0'; i++)
    {
        if (str[i] == '\n')
        {
            str[i] = '\0';
        }
    }

    tam = strlen(str);
    pot = tam-1;

    for (int i=0; i<tam; i++)
    {
        if (str[i] == '1')
        {
            soma += pow(2,(pot-i));
        }
    }

    printf(""%li\n"", soma);

    return 0;
}",29,876,189
"#define true 1
#define false 0

int main()
{
    char str[1001];
    int num[1001], aux, aux0, qtd = 1;

    fgets(str, 1001, stdin);

    for (int i = 0; str[i] != '\0'; i++)
    {
        if (str[i] == '\n')
        {
            str[i] = '\0';
        }
    }

    for (int i = 0; str[i] != '\0';)
    {
        aux = atoi(&str[i]);
        aux0 = aux;
        

        while (aux0 >= 10)
        {
            aux0 /= 10;
            qtd++;
        }

        if ((aux != 0) && (str[i + qtd] != '\0'))
        {
            for (int j = 0; j < (aux - 1); j++)
            {
                printf(""%c"", str[i + qtd]);
            }
        }

        else
        {
            printf(""%c"", str[i]);
        }

        i += qtd;
        qtd = 1;
    }

    putchar('\n');
    return 0;
}",29,877,320
"int main(int argc, char **argv)
{
    FILE *arq_1, *arq_2;
    char aux, *texto;

    if (argc < 3)
    {
        printf(""\nErro! NÃ£o foram informados aquivos o suficiente.\n\n"");
        return 0;
    }

    arq_1 = fopen(argv[1], ""r"");
    arq_2 = fopen(argv[2], ""w"");

    if (arq_1 == NULL || arq_2 == NULL)
    {
        printf(""\nErro ao abrir algum arquivo.\n\n"");
        return 0;
    }

    int i = 0;
    while (fscanf(arq_1, ""%c"", &aux) != EOF)
    {
        i++;
    }

    rewind(arq_1);

    texto = malloc(i+1 * sizeof(char));

    for (int j = 0; j < i; j++)
    {
        fscanf(arq_1, ""%c"", texto + j);
    }
    texto[i] = '\0';

    for (int j = 0; j < i; j++)
    {
        if (texto[j] == '/' && texto[j+1] == '/')
        {
            int k = j;
            while (texto[k] != '\n' && texto[k] != '\0')
            {
                texto[k] = ' ';
                k++;
            }
        }

    }

    fprintf(arq_2, ""%s"", texto);

    fclose(arq_1);
    fclose(arq_2);

    return 0;
}",29,878,443
"#define true 1
#define false 0

int main()
{
    int n, av[10000], bv[10000], cv[10000], xyz[100000], a, b, c, x, y, z, k = 0, solucao, solucao2, aux;

    scanf(""%i"", &n);

    for (int i = 0; i < n; i++)
    {
        scanf(""%i"", &av[i]);
        scanf(""%i"", &bv[i]);
        scanf(""%i"", &cv[i]);
    }

    for (int i = 0; i < n; i++)
    {
        a = av[i];
        b = bv[i];
        c = cv[i];

        solucao2 = false;

        for (y = (-c); y <= c; y++)
        {
            for (z = y; z <= c; z++)
            {
                x = a - y - z;
                if (((y * z * x) == b) && (((x * x) + (y * y) + (z * z)) == c))
                {
                    solucao = true;
                    if (k != 0)
                    {
                        for (int j=0; j<=(k-3); j++)
                        {
                            if ((x == xyz[j])||(y == xyz[j])||(z == xyz[j]))
                            {
                                solucao = false;
                                break;
                            }
                        }
                    }
                    if (solucao == true)
                    {
                        printf(""%i %i %i\n"", y, z, x);
                        solucao2 = true;
                        xyz[k] = x;
                        xyz[k+1] = y;
                        xyz[k+2] = z;
                        k += 3;
                    }
                }
            }
        }
        if (solucao2 == false)
            printf(""Sem solucao\n"");
    }
    return 0;
}",29,879,538
"typedef struct Complex
{
    float real;
    float imaginario;

} complex_t;

void le_complexs(complex_t *a, complex_t *b);
void imprime_complex(complex_t *c);

complex_t conjugado(complex_t a);
complex_t adicao(complex_t a, complex_t b);
complex_t subtracao(complex_t a, complex_t b);
complex_t multiplicacao(complex_t a, complex_t b);
complex_t divisao(complex_t a, complex_t b);

int main()
{
    complex_t a, b, c;
    int escolha;

    do
    {
        do
        {
            printf(""\nCalculadora de nÃºmeros complexs:\n"");
            printf(""\n\t(1) AdiÃ§Ã£o\n"");
            printf(""\t(2) SubtraÃ§Ã£o\n"");
            printf(""\t(3) MultiplicaÃ§Ã£o\n"");
            printf(""\t(4) DivisÃ£o\n"");
            printf(""\t(5) Sair\n"");
            printf(""\n\tDigite sua escolha: "");
            scanf(""%i"", &escolha);
            getchar();
            system(""clear"");

        } while (escolha != 1 && escolha != 2 && escolha != 3 && escolha != 4 && escolha != 5);


        switch (escolha)
        {
            case 1:
                le_complexs(&a, &b);
                c = adicao(a,b);
                imprime_complex(&c);
                break;
            
            case 2:
                le_complexs(&a, &b);
                c = subtracao(a,b);
                imprime_complex(&c);
                break;
            
            case 3:
                le_complexs(&a, &b);
                c = multiplicacao(a,b);
                imprime_complex(&c);
                break;
            
            case 4:
                le_complexs(&a, &b);
                c = divisao(a,b);
                imprime_complex(&c);
                break;
            
            case 5:
                return 0;
        }

        printf(""\nPressione ENTER para continuar: "");
        getchar();
        system(""clear"");

    } while (escolha != 5);

    return 0;
}


void le_complexs(complex_t *a, complex_t *b)
{
    printf(""\nDigite o 1Âº nÃºmero:\n"");
    
    printf(""\t-> Real: "");
    scanf(""%f"", &a->real);
    getchar();

    printf(""\t-> ImaginÃ¡rio: "");
    scanf(""%f"", &a->imaginario);
    getchar();

    printf(""\nDigite o 2Âº nÃºmero:\n"");
    
    printf(""\t-> Real: "");
    scanf(""%f"", &b->real);
    getchar();

    printf(""\t-> ImaginÃ¡rio: "");
    scanf(""%f"", &b->imaginario);
    getchar();
}

void imprime_complex(complex_t *c)
{

    if (c->imaginario < 0)
    {
        printf(""\nRes = %.2f %.2fi\n"", c->real, c->imaginario);
    }

    else
    {
        printf(""\nRes = %.2f +%.2fi\n"", c->real, c->imaginario);
    }
}

complex_t conjugado(complex_t a)
{
    a.imaginario *= -1;

    return a;
}

complex_t adicao(complex_t a, complex_t b)
{
    complex_t c;
    
    c.real = a.real + b.real;
    c.imaginario = a.imaginario + b.imaginario;

    return c;
}

complex_t subtracao(complex_t a, complex_t b)
{
    complex_t c;

    c.real = a.real - b.real;
    c.imaginario = a.imaginario - b.imaginario;

    return c;
}

complex_t multiplicacao(complex_t a, complex_t b)
{
    complex_t c;

    c.real = (a.real * b.real) - (a.imaginario * b.imaginario);
    c.imaginario = (a.real * b.imaginario) + (a.imaginario * b.real);

    return c;
}

complex_t divisao(complex_t a, complex_t b)
{
    complex_t c, d;

    complex_t b2 = conjugado(b);

    d = multiplicacao(b, b2);
    c = multiplicacao(a, b2);

    c.real /= d.real;
    c.imaginario /= d.real;

    return c;
}",29,880,1284
"int main()
{
    int matriz[4][4];

    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            scanf(""%i"", &matriz[i][j]);
        }
    }

    printf(""\n"");
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            if (j > i)
            {
                printf("" 0 "");
            }
            else
            {
                printf(""%2i "", matriz[i][j]);
            }
        }
        printf(""\n"");
    }
    printf(""\n\n"");
    return 0;
}",29,881,196
"int main(int argc, char **argv)
{
    FILE *arq;
    char aux, *texto;
    float res = 0;

    if (argc < 2)
    {
        printf(""\nErro! NÃ£o foi informado o nome do arquivo.\n\n"");
        return 0;
    }

    arq = fopen(argv[1], ""r"");

    if (arq == NULL)
    {
        printf(""\nErro ao abrir o arquivo.\n\n"");
        return 0;
    }

    int i = 0;

    while (fscanf(arq, ""%c"", &aux) != EOF)
    {
        i++;
    }

    rewind(arq);

    

    texto = malloc(i * sizeof(char));

    for (int j = 0; j < i; j++)
    {
        fscanf(arq, ""%c"", texto+j);
    }

    for (int j = 0; j < i; j++)
    {
        if (texto[j] == 'R' && texto[j+1] == '$')
        {
            res += atof(texto + j+2);
        }
    }
    printf(""\nLista de compras: R$%.2f\n\n"", res);

    return 0;
}",29,882,347
"#define tamanho 20
#define true 1
#define false 0

int main(void)
{
    int vetor[tamanho], aux, pivo, n, busca = false;

    printf(""\nInforme os nÃºmeros do vetor:\n"");
    for (int i = 0; i < tamanho; i++)
    {
        scanf(""%i"", &vetor[i]);
        for (int j = i; j > 0; j--)
        {
            if (vetor[j] < vetor[j - 1])
            {
                aux = vetor[j];
                vetor[j] = vetor[j - 1];
                vetor[j - 1] = aux;
            }
        }
    }

    printf(""\nVetor: "");
    for (int i = 0; i < tamanho; i++)
    {
        printf(""%i "", vetor[i]);
    }

    pivo = tamanho / 2;

    printf(""\nInforme qual nÃºmero deseja buscar no vetor: "");
    scanf(""%i"", &n);

    for (int i = 0; i < (tamanho / 2); i++)
    {
        if (n == vetor[pivo])
        {
            busca = true;
        }
        else if (n < vetor[pivo - 1])
        {
            if ((pivo % 2) == 0)
            {
                pivo = pivo / 2;
            }
            else
            {
                pivo = (pivo + 1) / 2;
            }
        }
        else if (n > vetor[pivo - 1])
        {
            if ((pivo % 2) == 0)
            {
                pivo = pivo + (pivo / 2);
            }
            else
            {
                pivo = pivo + ((pivo + 1) / 2);
            }
        }
        else if (n == vetor[pivo - 1])
        {
            busca = true;
        }
    }

    if (busca == true)
    {
        printf(""\nO nÃºmero estÃ¡ no vetor\n"");
    }
    else
    {
        printf(""\nO nÃºmero nÃ£o estÃ¡ no vetor\n"");
    }

    printf(""\n\n"");
    return 0;
}",29,883,635
"#define true 1
#define false 0

int main()
{
    int vet[10], num, busca = false, busca2;

    for (int i=0; i<10; i++)
    {
        scanf (""%i"", &vet[i]);
    }

    putchar ('\n');
    scanf (""%i"", &num);

    for (int i=0; i<10; i++)
    {
        for (int j=0; j<10; j++)
        {
            if (j != i)
            {
                if ((vet[i] * vet[j]) == num)
                {
                    printf (""\n%i * %i = %i"", vet[i], vet[j], num);
                    busca = true;
                }
            }
        }
    }

    if (busca == false)
    {
        printf (""\nNÃ£o existe nÃºmeros\n\n"");
    }

    if (busca == true)
    {
        printf (""\n\n"");
    }

    return 0;
}",29,884,283
"int main()
{
    char str[82];
    int num[100000], k, n, tam;
    long int tam_total = 0;

    scanf(""%i"", &n);
    scanf(""%i"", &k);
    getchar();

    for (int j = 0; j < n; j++)
    {
        fgets(str, 82, stdin);

        for (int i = 0; str[i] != '\0'; i++)
        {
            if (str[i] == '\n')
            {
                num[i + tam_total] = ((int)str[i]);
            }

            else
            {
                num[i + tam_total] = ((int)str[i]) - k;

                if (num[i + tam_total] < 32)
                {
                    num[i + tam_total] += 95;
                }
            }
        }

        tam = strlen(str);
        tam_total += tam;
    }

    for (long int i = 0; i < tam_total; i++)
    {
        printf(""%c"", num[i]);
    }

    return 0;
}",29,885,302
"void potencia(float x, int n, float xp[])
{
    float x0 = 1;
    xp[0] = 1;

    for (int i = 1; i <= n; i++)
    {
        x0 *= x;
        xp[i] = x0;
        
    }
}

int main()
{
    int n;
    long int q;
    float x[100000], av[6], soma = 0, xp[5];

    scanf(""%i"", &n);

    for (int i = 0; i <= n; i++)
    {
        scanf(""%f"", &av[i]);
    }

    scanf(""%li"", &q);

    for (int i = 0; i < q; i++)
    {
        scanf(""%f"", &x[i]);
    }

    for (int i = 0; i < q; i++)
    {
        potencia(x[i], n, xp);

        for (int j = 0; j <= n; j++)
        {
            soma += av[j] * xp[j];
            
        }

        printf(""%f\n"", soma);
        soma = 0;
    }

    return 0;
}",29,886,325
"#include ""lz77decode.h""

void decompress(char *compressed_str)
{
    

    int pos,             
        tam,             
        tam_d,           
        tam_total = 1;   

    char letra,          
        *decom = NULL;   

    decom = malloc(1 * sizeof(char)); 

    while (*compressed_str)           
    {
        if (*compressed_str == '(')   
        {
            compressed_str++;
            
            

            
            if (*compressed_str == '-')
            {
                pos = -1;
            }

            
            else
            {
                pos = atoi(compressed_str);
            }


            
            while (*compressed_str != ',')
            {
                compressed_str++;
            }
            compressed_str++;


            tam = atoi(compressed_str);                       
            tam_total += tam + 1;                             
            decom = realloc(decom, tam_total * sizeof(char)); 
            

            
            while (*compressed_str != ',')
            {
                compressed_str++;
            }
            compressed_str++;


            
            if (*compressed_str == '\\' && *(compressed_str + 1) == '0')
            {
                letra = '\0';
            }

            
            else
            {
                letra = *compressed_str; 
            }
            compressed_str++;
            


            

            tam_d = strlen(decom);

            
            if (pos == -1)
            {
                *decom = letra;
                *(decom + 1) = '\0';
            }
            
            else if (pos == 0) 
            {
                *(decom + tam_d) = letra;
                *(decom + tam_d + 1) = '\0';
            }
            
            else
            {
                int i, 
                    j; 

                for (i = tam_d - pos, j = 0; j < tam; i++, j++)
                {
                    
                    if (i == tam_d)
                    {
                        i = tam_d - pos;
                    }
                    *(decom + j + tam_d) = *(decom + i);
                }

                
                *(decom + tam_d + tam) = letra;

                
                *(decom + tam_d + tam + 1) = '\0';
            }
            
        }
        compressed_str++;
    }

    
    tam_d = strlen(decom);
    
    for (int i = 0; i < tam_d; i++)
    {
        printf(""%c"", *(decom + i));
    }
    putchar('\n');
    
    

    free(decom); 
}",29,887,731
"#include ""lz77encode.h"" 
#include ""lz77decode.h"" 
#define true 1
#define false 0

int main()
{
    char *str = NULL;
    int tam, k = 6, i0;

    str = malloc(10002 * sizeof(char)); 

    fgets(str, 10002, stdin);
    tam = strlen(str);

    if (*(str + tam - 1) == '\n') 
    {
        *(str + tam - 1) = '\0';
    }

    
    if (*str == '(')
    {
        decompress(str); 
    }
    


    
    else
    {
        
        
        
        
        
        
        

        
        
        
        
        
        

        
        
        
        
        

        compress(str, k); 
    }
    

    free(str); 

    return 0;
}",29,888,257
"int main(int argc, char *argv[])
{
    FILE *arq_1, *arq_2, *arq_3;
    char aux;

    if (argc < 4)
    {
        printf(""\nErro! NÃ£o foram informados arquivos o suficiente\n\n"");
        return 0;
    }

    arq_1 = fopen(argv[1], ""r"");
    arq_2 = fopen(argv[2], ""r"");
    arq_3 = fopen(argv[3], ""w"");

    if (arq_1 == NULL || arq_2 == NULL || arq_3 == NULL)
    {
        printf(""\nErro ao abrir algum arquivo\n\n"");
        return 0;
    }

    while ((fscanf(arq_1, ""%c"", &aux) != EOF))
    {        
        fprintf(arq_3, ""%c"", aux);   
    }
    
    while ((fscanf(arq_2, ""%c"", &aux) != EOF))
    {        
        fprintf(arq_3, ""%c"", aux);   
    }

    fclose(arq_1);
    fclose(arq_2);
    fclose(arq_3);

    return 0;
}",29,889,332
"int main()
{
    int n;
    scanf (""%i"", &n);

    n = (n/2)+1;

    for (int i=1; i<=n; i++)
    {
        for (int j=(n-1); j>=i; j--)
        {
            putchar (' ');
        }
        for (int k=1; k<=i; k++)
        {
            putchar ('*');
        }
        for (int l=1; l<i; l++)
        {
            putchar ('*');
        }
        putchar ('\n');
    }
    for (int i=(n-1); i>0; i--)
    {
        for (int j=i; j<n; j++)
        {
            putchar (' ');
        }
        for (int k=1; k<=i; k++)
        {
            putchar ('*');
        }
        for (int l=1; l<i; l++)
        {
            putchar ('*');
        }
        putchar ('\n');
    }
    putchar ('\n');

    return 0;
}",29,890,283
"int main()
{
    int qtd, n, qtd_total, qtd100 = 0, qtd50 = 0, qtd25 = 0, qtd10 = 0, qtd5 = 0, qtd2 = 0, qtd1 = 0;
    scanf (""%i"", &qtd);

    for (int i=0; i<qtd; i++)
    {
        scanf (""%i"", &n);
        while (n>=100)
        {
            n -= 100;
            qtd100++;
        }
        
        if ((50<=n)&&(n<=99))
        {
            n -= 50;
            qtd50++;
        } 

        if ((25<=n)&&(n<=49))
        {
            n -= 25;
            qtd25++;
        }

        while ((10<=n)&&(n<=24))
        {
            n -= 10;
            qtd10++;
        }

        if ((5<=n)&&(n<=9))
        {
            n -= 5;
            qtd5++;
        }

        while ((2<=n)&&(n<=4))
        {
            n -= 2;
            qtd2++;
        }

        if (n==1)
        {
            n--;
            qtd1++;
        }
        
        qtd_total = qtd100+qtd50+qtd25+qtd10+qtd5+qtd2+qtd1;
        printf (""%i notas\n%i notas de 100\n%i notas de 50\n%i notas de 25\n%i notas de 10\n%i notas de 5\n%i notas de 2\n%i notas de 1\n"", qtd_total, qtd100, qtd50, qtd25, qtd10, qtd5, qtd2, qtd1);
        qtd_total = 0;
        qtd100 = 0;
        qtd50 = 0;
        qtd25 = 0;
        qtd10 = 0;
        qtd5 = 0;
        qtd2 = 0;
        qtd1 = 0;
    }

    return 0;
}",29,891,607
"int main()
{
    int n, qtd = 2, idade, maior, menor;

    printf(""\nInforme a quantidade de idades: "");
    scanf(""%i"", &n);

    printf(""\nInforme a 1Âª idade: "");
    scanf(""%i"", &idade);

    maior = idade;
    menor = idade;

    for (int i = 0; i < (n - 1); i++)
    {
        printf(""\nInforme a %iÂª idade: "", qtd);
        scanf(""%i"", &idade);
        qtd++;

        if (idade > maior)
        {
            maior = idade;
        }

        else if (idade < menor)
        {
            menor = idade;
        }
    }

    printf(""\nMaior idade: %i"", maior);
    printf(""\nMenor idade: %i\n\n"", menor);

    return 0;
}",29,892,244
"int main()
{
    float A[100][100];
    int n, m;

    scanf(""%i %i"", &n, &m);

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            scanf(""%f"", &A[i][j]);
        }
    }

    for (int j = 0; j < m; j++)
    {
        for (int i = 0; i < n; i++)
        {
            if (i == (n-1)) printf(""%.2f"", A[i][j]);
            
            else printf(""%.2f "", A[i][j]);
        }
        putchar('\n');
    }

    return 0;
}",29,893,201
"int main()
{
    int n;
    float nota, notafinal = 0, denominador = 0, fator, notamedia;

    printf(""\nInforme a quantidade de notas do aluno: "");
    scanf(""%i"", &n);

    for (int qtd = 1; qtd <= n; qtd++)
    {
        printf(""\nInforme a %iÂª nota: "", qtd);
        scanf(""%f"", &nota);

        if ((qtd % 2) == 0)
        {
            fator = 3;
            nota = fator * nota;
        }

        else
        {
            fator = 2;
            nota = fator * nota;
        }

        notafinal = notafinal + nota;
        denominador = denominador + fator;
    }

    notamedia = notafinal / denominador;
    printf(""\nNota mÃ©dia = %.2f\n"", notamedia);

    if (notamedia < 5)
    {
        printf(""\nAluno reprovado!\n\n"");
    }

    else if ((notamedia >= 5) && (notamedia < 6))
    {
        printf(""\nAluno em recuperaÃ§Ã£o!\n\n"");
    }

    else
    {
        printf(""\nAluno aprovado!\n\n"");

        if ((notamedia >= 8) && (notamedia < 10))
        {
            printf(""ParabÃ©ns!\n\n"");
        }

        else if (notamedia == 10)
        {
            printf(""Sensacional!\n\n"");
        }
    }

    return 0;
}",29,894,442
"int main()
{
    int hora_inicio, minuto_inicio, hora_fim, minuto_fim, minuto_total_inicio, minuto_total_fim, res_minuto, duracao_hora, duracao_minuto;

    scanf(""%i"", &hora_inicio);
    scanf(""%i"", &minuto_inicio);
    scanf(""%i"", &hora_fim);
    scanf(""%i"", &minuto_fim);

    minuto_total_inicio = (hora_inicio * 60) + minuto_inicio;
    minuto_total_fim = (hora_fim * 60) + minuto_fim;

    res_minuto = minuto_total_fim - minuto_total_inicio;

    duracao_hora = res_minuto / 60;
    duracao_minuto = res_minuto % 60;

    printf(""\n\n"");
    if (duracao_hora < 10)
    {
        printf(""0%d"", duracao_hora);
    }
    else
    {
        printf(""%d"", duracao_hora);
    }
    if (duracao_minuto < 10)
    {
        printf("":0%d"", duracao_minuto);
    }
    else
    {
        printf("":%d"", duracao_minuto);
    }
    printf(""\n\n"");
    return 0;
}",29,895,378
"#include ""lz77encode.h""
#define true 1
#define false 0

void compress(char *str, int k)
{
    int pos,         
        tam_maior,   
        tam,         
        pos_aux,     
        indice = 0,  
        i_aux,       
        end = false; 

    
    printf(""(-1,0,%c)"", *str); 

    str++;
    indice++;
    

    
    while (*str) 
    {

        
        tam_maior = 0;

        
        pos = 0;

        
        for (int i = indice - 1; i >= (indice - k) && i >= 0; i--)
        {
            
            if (*(str - indice + i) == *(str))
            {
                tam = 0;
                i_aux = i;

                
                for (int j = 0; *(str - indice + i_aux + j) == *(str + j); j++)
                {
                    
                    if (j == 0) 
                    {
                        pos_aux = -(-indice + i_aux + j);
                    }

                    
                    if ((-indice + i_aux + j) >= 0)
                    {
                        i_aux = i - j;
                    }

                    tam++;
                }

                
                if (tam > tam_maior)
                {
                    tam_maior = tam;
                    pos = pos_aux;
                }
            }
        }
        
        str += tam_maior;
        
        indice += tam_maior;
        

        
        
        
        if (*str == '\0')
        {
            printf(""(%i,%i,\\0)"", pos, tam_maior);
            end = true;
        }
        else
        {
            printf(""(%i,%i,%c)"", pos, tam_maior, *str);
        }
        

        
        str++;
        indice++;
    }

    if (end == false) 
    {
        printf(""(0,0,\\0)"");
    }
    putchar('\n');
}",29,896,557
"#define tamanho 5

int main(void)
{
    int a[tamanho], b[tamanho], aux;

    printf(""\nInforme os nÃºmeros do vetor A:\n"");
    for (int i = 0; i < tamanho; i++)
    {
        scanf(""%i"", &a[i]);
    }

    printf(""\nInforme os nÃºmeros do vetor B:\n"");
    for (int i = 0; i < tamanho; i++)
    {
        scanf(""%i"", &b[i]);
    }

    for (int j = 0; j < tamanho; j++)
    {
        aux = a[j];
        a[j] = b[j];
        b[j] = aux;
    }

    printf(""\nVetor A: "");
    for (int k = 0; k < tamanho; k++)
    {
        printf(""%i "", a[k]);
    }

    printf(""\nVetor B: "");
    for (int k = 0; k < tamanho; k++)
    {
        printf(""%i "", b[k]);
    }

    printf(""\n\n"");
    return 0;
}
",29,897,314
"int main()
{
    float a, b, c, x1, x2, x, delta, real, im1, im2;

    printf(""\nDe acordo com o modelo de equaÃ§Ã£o: axÂ²+bx+c\n\n"");
    printf(""Informe 'a': "");
    scanf(""%f"", &a);
    printf(""Informe 'b': "");
    scanf(""%f"", &b);
    printf(""Informe 'c': "");
    scanf(""%f"", &c);

    delta = pow(b, 2) - 4 * a * c;

    if (delta == 0)
    {
        x = (-b) / (2 * a);

        printf(""\nA equaÃ§Ã£o tem raiz dupla\nx = %.2f\n\n"", x);
    }

    else if (delta < 0)
    {
        delta = -delta;
        real = (-b) / (2 * a);
        im1 = sqrt(delta) / (2 * a);
        im2 = (-sqrt(delta)) / (2 * a);

        printf(""\nA equaÃ§Ã£o tem raiz imaginÃ¡ria\nParte real = %.2f\nParte imaginÃ¡ria = %.2fi e %.2fi\n\n"", real, im1, im2);
    }

    else
    {
        x1 = (-b + sqrt(delta)) / (2 * a);
        x2 = (-b - sqrt(delta)) / (2 * a);

        printf(""\nA equaÃ§Ã£o tem raizes reais\nx1 = %.2f\nx2 = %.2f\n\n"", x1, x2);
    }

    return 0;
}",29,898,441
"#define true 1
#define false 0

int main()
{
    char str[10];
    int tam, valor, num = false;
    while (num == false)
    {
        puts(""\nInforme um nÃºmero:"");
        scanf(""%s"", str);
        getchar();

        tam = strlen(str);
        valor = atoi(str);
        

        if ((pow(10, (tam - 1))) <= valor)
        {
            num = true;
        }

        else if (num == false)
        {
            system(""clear"");
            puts(""\nNÃºmero invÃ¡lido, digite novamente!"");
        }
    }

    puts(""\nO nÃºmero Ã© de fato um nÃºmero\n"");
    return 0;
}",29,899,212
"int main()
{
    int restaurante[8][4];
    int cadeira = 1;

    for (int i = 0; i < 8; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            switch (j)
            {
            case 0:
                restaurante[i][j] = cadeira;
                break;
            case 1:
                restaurante[i][j] = cadeira + 1;
                break;
            case 2:
                restaurante[i][j] = cadeira + 4;
                break;
            case 3:
                restaurante[i][j] = cadeira + 5;
                break;
            }
        }
        if ((i % 2) == 0)
        {
            cadeira += 2;
        }
        else
        {
            cadeira += 6;
        }
    }

    system(""clear"");
    for (int i = 0; i < 8; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            printf(""%3i"", restaurante[i][j]);
        }
        printf(""\n"");
    }

    printf(""\n"");
    return 0;
}",29,900,323
"#include ""funcoes.h"" 

int main()
{
    int n, q;
    double a[7], x[100], xf;

    scanf(""%i"", &n); 
    getchar();

    for (int i = 0; i <= n; i++)
    {
        scanf(""%lf"", &a[i]); 
        getchar();
    }

    scanf(""%i"", &q); 

    for (int i = 0; i < q; i++)
    {
        scanf(""%lf"", &x[i]); 
        getchar();
    }

    putchar('\n');
    for (int i = 0; i < q; i++)
    {
        xf = f_de_x(n, a, x[i]); 

        vetor_taylor(n, a, x[i], xf); 
        
        putchar('\n');
    }

    return 0;
}",29,901,243
"typedef enum Bool
{
    false, true
    
} bool;

typedef struct Aluno
{
    char nome[82];
    int idade;
    int semestre;
    float renda_mensal;

} aluno_t;

void le_turma(aluno_t *turma, int n);
void imprime_aluno(aluno_t aluno);
bool imprime_renda(aluno_t *turma, int semestre, int n);
bool imprime_semestre(aluno_t *turma, int semestre, int n);
bool imprime_idade(aluno_t *turma, int idade, int n);

int main()
{
    int n, escolha;
    float renda_media;

    printf(""\nDigite o nÃºmero de alunos: "");
    scanf(""%i"", &n);
    getchar();

    aluno_t *turma = malloc(n * sizeof(aluno_t));

    le_turma(turma, n);

    do
    {
        do
        {
            printf(""Deseja imprimir:\n"");
            printf(""\t(1) Alunos que possuam renda mensal superior Ã  media de seu semestre.\n"");
            printf(""\t(2) Alunos que estÃ£o no mesmo semestre.\n"");
            printf(""\t(3) Alunos que a idade escolhida.\n"");
            printf(""\t(4) Sair."");
            printf(""\n\tDigite sua escolha: "");

            scanf(""%i"", &escolha);
            getchar();
            system(""clear"");

        } while (escolha != 1 && escolha != 2 && escolha != 3 && escolha != 4);

        switch (escolha)
        {
            int escolha_sem_1;
            int escolha_sem_2;
            int escolha_id;

            case 1:
                printf(""Digite o semestre: "");
                scanf(""%i"", &escolha_sem_1);
                getchar();
                imprime_renda(turma, escolha_sem_1, n);
                break;

            case 2:
                printf(""Digite o semestre: "");
                scanf(""%i"", &escolha_sem_2);
                getchar();
                imprime_semestre(turma, escolha_sem_2, n);
                break;

            case 3:
                printf(""Digite a Idade: "");
                scanf(""%i"", &escolha_id);
                getchar();
                imprime_idade(turma, escolha_id, n);
                break;

            case 4:
                return 0;   
        }
        printf(""\nPressione ENTER para continuar: "");
        getchar();
        system(""clear"");

    } while (escolha != 4);

    free(turma);
    
    return 0;
}


void le_turma(aluno_t *turma, int n)
{
    for(int i = 0; i < n; i++)
    {
        printf(""\nDigite os dados do %iÂº aluno:\n"", i+1);

        printf(""\t-> Nome: "");
        fgets(turma[i].nome, 82, stdin);

        int tam = strlen(turma[i].nome);
        if (turma[i].nome[tam - 1] == '\n')
        {
            turma[i].nome[tam - 1] = '\0';
        }

        printf(""\t-> Idade: "");
        scanf(""%i"", &turma[i].idade);
        getchar();

        printf(""\t-> Semestre: "");
        scanf(""%i"", &turma[i].semestre);
        getchar();

        printf(""\t-> Renda mensal: "");
        scanf(""%f"", &turma[i].renda_mensal);
        getchar();
    }
    system(""clear"");
}

bool imprime_renda(aluno_t *turma, int semestre, int n)
{
    bool sem = false;
    int k = 0;
    float media = 0.0;

    for (int i = 0; i < n; i++)
    {
        if (turma[i].semestre == semestre)
        {
            if (sem == false) sem = true;

            media += turma[i].renda_mensal;
            k++;
        }
    }

    if (sem == false)
    {
        printf(""\nNenhum aluno foi encontrado no semestre escolhido.\n"");
        return false;
    }

    media /= k;
    printf(""\nMedia = %f\n"", media);

    for (int i = 0; i < n; i++)
    {
        if (turma[i].renda_mensal >= media && turma[i].semestre == semestre)
        {
            imprime_aluno(turma[i]);
        }
    }

    return true;
}

bool imprime_semestre(aluno_t *turma, int semestre, int n)
{
    bool sem = false;

    for (int i = 0; i < n; i++)
    {
        if (turma[i].semestre == semestre)
        {
            if (sem == false) sem = true;

            imprime_aluno(turma[i]);
        }
    }

    if (sem == false)
    {
        printf(""\nNenhum aluno foi encontrado no semestre escolhido.\n"");
        return false;
    }

    return true;
}

bool imprime_idade(aluno_t *turma, int idade, int n)
{
    bool id = false;

    for (int i = 0; i < n; i++)
    {
        if (turma[i].idade == idade)
        {
            if (id == false) id = true;

            imprime_aluno(turma[i]);
        }
    }

    if (id == false)
    {
        printf(""\nNenhum aluno com a idade escolhida foi encontrado.\n"");
        return false;
    }

    return true;
}

void imprime_aluno(aluno_t aluno)
{
    printf(""\nNome: %s\n"", aluno.nome);
    printf(""Idade: %i\n"", aluno.idade);
    printf(""Semestre: %i\n"", aluno.semestre);
    printf(""Renda mensal: %f\n"", aluno.renda_mensal);
}",29,902,1706
"void le_mdc(int *a, int *b)
{
    do
    {
        printf(""\nDigite dois inteiros 'a' e 'b', onde 'b' > 0:\n"");
        printf(""\t-> a: "");
        scanf(""%i"", a);
        getchar();
        printf(""\t-> b: "");
        scanf(""%i"", b);
        getchar();
        system(""clear"");

    } while (b <= 0);
}

void le_mmc(int *a, int *b)
{
    do
    {
        printf(""\nDigite dois inteiros nÃ£o-negativos 'a' e 'b':\n"");
        printf(""\t-> a: "");
        scanf(""%i"", a);
        getchar();
        printf(""\t-> b: "");
        scanf(""%i"", b);
        getchar();
        system(""clear"");
    
    } while (a < 0 || b < 0);
}

int mdc(int a, int b)
{
    return (a % b > 0) ? mdc(b, a % b) : b;
}

int mmc(int a, int b)
{
    return (a == 0 || b == 0) ? 0 : (a*b) / mdc(a,b);
}

int main()
{
    int a, b, escolha;

    do
    {
        do
        {
            printf(""\n\t(1) MDC\n"");
            printf(""\t(2) MMC\n"");
            printf(""\t(3) Sair\n"");
            printf(""\tDigite sua escolha: "");
            scanf(""%i"", &escolha);
            getchar();
            system(""clear"");
        
        } while (escolha != 1 && escolha != 2 && escolha != 3);

        if (escolha == 3) return 0;

        if (escolha == 1)
        {
            le_mdc(&a, &b);
            printf(""\nMDC(%i,%i) = %i\n\n"", a, b, mdc(a,b));
        }

        else if (escolha == 2)
        {
            le_mmc(&a, &b);
            printf(""\nMMC(%i,%i) = %i\n\n"", a, b, mmc(a,b));
        }

        printf(""\nPressione ENTER para continuar: "");
        getchar();
        system(""clear"");
    
    } while (escolha != 3);

    return 0;
}",29,903,644
"#define true 1
#define false 0

int main()
{
    char string[81], stringinv[81], aux;
    int tam, tam1, busca;

    fgets(string, 81, stdin);

    for (int i=0; string[i] != '\0'; i++)
    {
        if (string[i] == '\n')
        {
            string[i] = '\0';
        }
    }

    for (int i = 0; string[i] != '\0'; i++)
    {
        if (string[i] == ' ')
        {
            for (int j = i; string[j] != '\0'; j++)
            {
                string[j] = string[j + 1];
            }
        }
    }

    tam = strlen(string);

    for (int i = 0; string[i] != '\0'; i++)
    {
        stringinv[i] = string[(tam - 1) - i];
    }

    busca = true;
    
    for (int i = 0; string[i] != '\0'; i++)
    {
        if (string[i] != stringinv[i])
        {
            busca = false;
            break;
        }
    }

    if (busca == true)
    {
        printf(""S\n"");
    }
    else if (busca == false)
    {
        printf(""N\n"");
    }

    return 0;
}",29,904,377
"int main(int argc, char *argv[])
{
    FILE *arq;
    char aux, *texto;

    if (argc < 2)
    {
        printf(""\nErro! NÃ£o foi informado o nome do arquivo.\n\n"");
        return 0;
    }

    arq = fopen(argv[1], ""r+"");

    if (arq == NULL)
    {
        printf(""\nErro ao abrir o arquivo.\n\n"");
        return 0;
    }

    int i = 0;

    while (fscanf(arq, ""%c"", &aux) != EOF)
    {
        i++;
    }

    texto = malloc((i+1) * sizeof(char));

    rewind(arq);

    i = 0;

    while (fscanf(arq, ""%c"", &aux) != EOF)
    {
        texto[i] = aux;
        i++;
    }
    texto[i] = '\0';


    for (int j = 0; j < i; j++)
    {
        switch (texto[j])
        {
            case 'a':
                texto[j] = 'A';
                break;
                
            case 'e':
                texto[j] = 'E';
                break;

            case 'i':
                texto[j] = 'I';
                break;

            case 'o':
                texto[j] = 'O';
                break;

            case 'u':
                texto[j] = 'U';
                break;
            
            default:
                break;
        }
    }

    rewind(arq);
    fprintf(arq, ""%s"", texto);
    fclose(arq);

    return 0;
}",29,905,461
"#define true 1
#define false 0

void sequencia(int seq[], int print)
{
    int tam[10000], seq_aux[10000], qtd, k = 0, tam_s;
    for (int i = 0; seq[i] != 0; i++)
    {
        qtd = 0;
        for (int j = i; seq[j] == seq[i]; j++)
        {
            qtd++;
        }

        i += qtd - 1;
        tam[k] = qtd;
        seq_aux[k] = seq[i];
        k++;
    }

    for (int i = 0, j = 0, a = 0; j < k; a++)
    {
        if (a % 2 == 0)
        {
            seq[a] = tam[i];
            i++;
        }

        else if (a % 2 != 0)
        {
            seq[a] = seq_aux[j];
            j++;
        }

        if (print == true)
        {
            printf(""%i"", seq[a]);
        }
    }
}

int main()
{
    int seq[10000], n, tam_s; 

    seq[0] = 1;

    scanf(""%i"", &n);

    if (n == 1)
    {
        printf(""%i\n"", seq[0]);
    }

    else
    {
        for (int i = 1; i < n; i++)
        {
            if (i == (n - 1))
            {
                sequencia(seq, true);
                putchar('\n');
            }
            else
            {
                sequencia(seq, false);
            }
        }
    }

    return 0;
}",29,906,460
"int main()
{
    char frase[50], esarf[50];
    int tam_frase, i = 0, i1, j = 0, k = 0;

    printf(""\nInforme uma frase quanlquer:\n"");
    scanf(""%[^\n]s"", frase);

    tam_frase = strlen(frase);
    i1 = tam_frase - 1;

    strcpy(esarf, frase);
    for (int i = 0; i < tam_frase; i++)
    {
        esarf[i] = frase[(tam_frase - 1) - i];
    }

    while (j != (tam_frase + 1))
    {
        while ((j <= tam_frase) && (frase[j] != ' '))
        {
            j++;
        }

        for (int j1 = j; j1 < tam_frase; j1++)
        {
            frase[j1] = frase[j1 + 1];
        }
    }

    while (k != (tam_frase + 1))
    {
        while ((k <= tam_frase) && (esarf[k] != ' '))
        {
            k++;
        }

        for (int k1 = k; k1 < tam_frase; k1++)
        {
            esarf[k1] = esarf[k1 + 1];
        }
    }

    for (int m = 0; frase[m]; m++)
    {
        frase[m] = tolower(frase[m]);
    }
    for (int n = 0; esarf[n]; n++)
    {
        esarf[n] = tolower(esarf[n]);
    }

    if (strcmp(frase, esarf) == 0)
    {
        printf(""\nA Frase Ã© um palÃ­ndromo.\n\n"");
    }
    else
    {
        printf(""\nA Frase nÃ£o Ã© um palÃ­ndromo.\n\n"");
    }

    return 0;
}",29,907,538
"#define n 5
#define m 5
#define true 1
#define false 0

int main()
{
    char entrada[100];
    int string;
    int matriz_final[n][m];
    char matriz_entrada[n][m];
    int linha, coluna, random_bomb, menu, menu2, menu3, menu12, menu13;
    int mapa = false, instrucoes = false, creditos = false, sair = false;
    int qtd_bombas, random;
    random = (n + m) / 3;

    while (sair == false)
    {
        system(""clear"");
        printf(""\tBem vindo ao gerador de mapa de campo minado.\n\n\t(1) Iniciar\n\t(2) InstruÃ§Ãµes\n\t(3) CrÃ©ditos\n\t(4) Sair\n\t "");
        scanf(""%d"", &menu);
        getchar();
        system(""clear"");

        switch (menu)
        {
        case 1:
            mapa = true;
            while (mapa == true)
            {
                printf(""\t(1) Gerador de mapa manual\n\t(2) Gerador de mapa randÃ´mico\n\t "");
                scanf(""%d"", &menu12);
                getchar();
                switch (menu12)
                {
                case 1:
                    system(""clear"");
                    for (int i = 0; i < n; i++)
                    {
                        do
                        {
                            printf(""Informe as %d linhas da matriz com %d elementos vÃ¡lidos,\nou seja 'X' para bomba e 'L' para nÃ£o bomba,\nos elementos deverÃ£o ser inseridos sem espaÃ§os entre eles.\nAo fim de uma linha, pressione 'enter' para escrever a prÃ³xima linha.\n\n"", n, m);
                            for (int j = 0; j < i; j++)
                            {
                                for (int k = 0; k < m; k++)
                                {
                                    printf(""%c"", matriz_entrada[j][k]);
                                }
                                printf(""\n"");
                            }
                            setbuf(stdin, NULL);
                            scanf(""%s"", entrada);
                            getchar();

                            string = true;
                            if (strlen(entrada) != m)
                            {
                                string = false;
                            }
                            for (int j = 0; j < m; j++)
                            {
                                if ((toupper(entrada[j]) != 'X') && (toupper(entrada[j]) != 'L'))
                                {
                                    string = false;
                                }
                            }
                            if (string == false)
                            {
                                printf(""\nstring invÃ¡lida\n"");
                                sleep(1);
                                system(""clear"");
                            }
                        } while (string == false);

                        for (int j = 0; j < m; j++)
                        {
                            matriz_entrada[i][j] = entrada[j];
                        }

                        for (int j = 0; j < m; j++)
                        {
                            if (toupper(entrada[j]) == 'X')
                            {
                                matriz_final[i][j] = 88;
                            }
                            else
                            {
                                matriz_final[i][j] = 0;
                            }
                        }
                        system(""clear"");
                    }

                    for (int i = 0; i < n; i++)
                    {
                        for (int j = 0; j < m; j++)
                        {
                            qtd_bombas = 0;
                            if (matriz_final[i][j] != 88)
                            {
                                if (j != 0)
                                {
                                    if (matriz_final[i][j - 1] == 88)
                                    {
                                        qtd_bombas++;
                                    }
                                }
                                if (j != (m - 1))
                                {
                                    if (matriz_final[i][j + 1] == 88)
                                    {
                                        qtd_bombas++;
                                    }
                                }
                                if (i != 0)
                                {
                                    if (matriz_final[i - 1][j] == 88)
                                    {
                                        qtd_bombas++;
                                    }
                                }
                                if (i != (n - 1))
                                {
                                    if (matriz_final[i + 1][j] == 88)
                                    {
                                        qtd_bombas++;
                                    }
                                }
                                if ((j != (m - 1)) && (i != (n - 1)))
                                {
                                    if (matriz_final[i + 1][j + 1] == 88)
                                    {
                                        qtd_bombas++;
                                    }
                                }
                                if ((j != 0) && (i != (n - 1)))
                                {
                                    if (matriz_final[i + 1][j - 1] == 88)
                                    {
                                        qtd_bombas++;
                                    }
                                }
                                if ((j != 0) && (i != 0))
                                {
                                    if (matriz_final[i - 1][j - 1] == 88)
                                    {
                                        qtd_bombas++;
                                    }
                                }
                                if ((j != (m - 1)) && (i != 0))
                                {
                                    if (matriz_final[i - 1][j + 1] == 88)
                                    {
                                        qtd_bombas++;
                                    }
                                }
                                matriz_final[i][j] = qtd_bombas;
                            }
                        }
                    }

                    while (mapa == true)
                    {
                        linha = 0;
                        coluna = 0;
                        printf(""colunas:      "");
                        for (int j = 0; j < m; j++)
                        {
                            printf(""%-2i"", coluna);
                            coluna++;
                            printf(""  "");
                        }
                        printf(""\n\t      "");
                        for (int j = 0; j < m; j++)
                        {
                            printf(""|   "");
                        }
                        printf(""\n\n"");
                        for (int i = 0; i < n; i++)
                        {
                            for (int j = 0; j < m; j++)
                            {
                                if (j == 0)
                                {
                                    printf(""linha: %2i --  "", linha);
                                    linha++;
                                }
                                if (matriz_final[i][j] == 88)
                                {
                                    printf(""%c   "", matriz_final[i][j]);
                                }
                                else
                                {
                                    printf(""%d   "", matriz_final[i][j]);
                                }
                            }
                            printf(""\n\n"");
                        }

                        printf(""\tQuando estiver pronto digite '0' para voltar: "");
                        scanf(""%d"", &menu13);
                        getchar();
                        if (menu13 == 0)
                        {
                            mapa = false;
                        }
                        else
                        {
                            system(""clear"");
                        }
                    }
                    break;

                case 2:
                    system(""clear"");
                    srand(time(NULL));
                    for (int i = 0; i < n; i++)
                    {
                        for (int j = 0; j < m; j++)
                        {
                            random_bomb = rand() % random;
                            if (random_bomb == 0)
                            {
                                matriz_final[i][j] = 88;
                            }
                            else
                            {
                                matriz_final[i][j] = 0;
                            }
                        }
                    }

                    for (int i = 0; i < n; i++)
                    {
                        for (int j = 0; j < m; j++)
                        {
                            qtd_bombas = 0;
                            if (matriz_final[i][j] != 88)
                            {
                                if (j != 0)
                                {
                                    if (matriz_final[i][j - 1] == 88)
                                    {
                                        qtd_bombas++;
                                    }
                                }
                                if (j != (m - 1))
                                {
                                    if (matriz_final[i][j + 1] == 88)
                                    {
                                        qtd_bombas++;
                                    }
                                }
                                if (i != 0)
                                {
                                    if (matriz_final[i - 1][j] == 88)
                                    {
                                        qtd_bombas++;
                                    }
                                }
                                if (i != (n - 1))
                                {
                                    if (matriz_final[i + 1][j] == 88)
                                    {
                                        qtd_bombas++;
                                    }
                                }
                                if ((j != (m - 1)) && (i != (n - 1)))
                                {
                                    if (matriz_final[i + 1][j + 1] == 88)
                                    {
                                        qtd_bombas++;
                                    }
                                }
                                if ((j != 0) && (i != (n - 1)))
                                {
                                    if (matriz_final[i + 1][j - 1] == 88)
                                    {
                                        qtd_bombas++;
                                    }
                                }
                                if ((j != 0) && (i != 0))
                                {
                                    if (matriz_final[i - 1][j - 1] == 88)
                                    {
                                        qtd_bombas++;
                                    }
                                }
                                if ((j != (m - 1)) && (i != 0))
                                {
                                    if (matriz_final[i - 1][j + 1] == 88)
                                    {
                                        qtd_bombas++;
                                    }
                                }
                                matriz_final[i][j] = qtd_bombas;
                            }
                        }
                    }

                    while (mapa == true)
                    {
                        linha = 0;
                        coluna = 0;
                        printf(""colunas:      "");
                        for (int j = 0; j < m; j++)
                        {
                            printf(""%-2i"", coluna);
                            coluna++;
                            printf(""  "");
                        }
                        printf(""\n\t      "");
                        for (int j = 0; j < m; j++)
                        {
                            printf(""|   "");
                        }
                        printf(""\n\n"");
                        for (int i = 0; i < n; i++)
                        {
                            for (int j = 0; j < m; j++)
                            {
                                if (j == 0)
                                {
                                    printf(""linha: %2i --  "", linha);
                                    linha++;
                                }
                                if (matriz_final[i][j] == 88)
                                {
                                    printf(""%c   "", matriz_final[i][j]);
                                }
                                else
                                {
                                    printf(""%d   "", matriz_final[i][j]);
                                }
                            }
                            printf(""\n\n"");
                        }

                        printf(""\tQuando estiver pronto digite '0' para voltar: "");
                        scanf(""%d"", &menu13);
                        getchar();
                        if (menu13 == 0)
                        {
                            mapa = false;
                        }
                        else
                        {
                            system(""clear"");
                        }
                    }
                    break;

                default:
                    system(""clear"");
                    break;
                }
            }
            break;

        case 2:
            instrucoes = true;
            while (instrucoes == true)
            {
                printf(""\tA matriz por padrÃ£o tem tamanho 5x5, porÃ©m Ã© possÃ­vel mudar o tamanho da matriz,\n"");
                printf(""\talterando no inicio cÃ³digo os valores de n (linhas) e m (colunas) no #define. Ex: '#define n 7'\n\n"");
                printf(""\tGeraÃ§Ã£o manual:\n\n"");
                printf(""\tPara cada linha da matriz deverÃ¡ ser digitado uma string (sem espaÃ§os) do tamanho do nÃºmero de colunas,\n"");
                printf(""\tEssa string deverÃ¡ conter apenas 'X' para indicar uma bomba e 'L' para indicar nÃ£o-bomba.\n"");
                printf(""\tApÃ³s digitada a linha, deverÃ¡ pressionar 'enter', para poder escrever a prÃ³xima linha.\n\n"");
                printf(""\tGeraÃ§Ã£o randÃ´mica:\n\n"");
                printf(""\tCaso deseja alterar a chance de que ocorra uma bomba, basta alterar a variÃ¡vel: 'random',\n"");
                printf(""\tComo a ocorrÃªncia de bomba Ã© determinada pela escolha aleatÃ³ria de um nÃºmero de 0 atÃ© o random,\n"");
                printf(""\tQuanto maior for o random menor a chance de aparecer uma bomba.\n\n"");
                printf(""\tQuando estiver pronto digite '0' para voltar: "");
                scanf(""%d"", &menu2);
                getchar();
                if (menu2 == 0)
                {
                    instrucoes = false;
                }
                else
                {
                    system(""clear"");
                }
            }
            break;

        case 3:
            creditos = true;
            while (creditos == true)
            {
                printf(""\tEste trabalho, o gerador de mapa de campo minado, foi feito por:\n\n"");
                printf(""\tDarla Ellen Santos Garcez\n\tGustavo Cunha Lacerda\n\tHenrique Tavares Aguiar\n\n"");
                printf(""\tQuando estiver pronto, digite '0' para voltar: "");
                scanf(""%d"", &menu3);
                getchar();
                if (menu3 == 0)
                {
                    creditos = false;
                }
                else
                {
                    system(""clear"");
                }
            }
            break;

        case 4:
            sair = true;
            break;
        }
    }
    return 0;
}",29,908,3982
"int main()
{
    char str[90];
    int num[100000], k, n, tam, tam_total = 0;

    scanf(""%i"", &n);
    scanf(""%i"", &k);
    getchar();

    for (int j = 0; j < n; j++)
    {
        fgets(str, 90, stdin);

        for (int i = 0; str[i] != '\0'; i++)
        {
            if (str[i] == '\n')
            {
                num[i + tam_total] = ((int)str[i]);
            }
            else
            {
                num[i + tam_total] = ((int)str[i]) + k;
            }

            if (num[i + tam_total] > 126)
            {
                num[i + tam_total] -= 95;
            }

            
        }

        tam = strlen(str);
        tam_total += tam;
    }

    for (int i = 0; i < tam_total; i++)
    {
        printf(""%c"", num[i]);
    }

    return 0;
}",29,909,299
"int main(int argc, char **argv)
{
    FILE *arq_1, *arq_2;
    char aux, *str_1, *str_2;
    int n, m;
    float **matriz, aux_2, *texto;

    if (argc < 3)
    {
        printf(""\nErro! NÃ£o foram informados arquivos o suficiente\n\n"");
        return 0;
    }

    arq_1 = fopen(argv[1], ""r"");
    arq_2 = fopen(argv[2], ""w"");

    if (arq_1 == NULL || arq_2 == NULL)
    {
        printf(""\nErro ao abrir o arquivo.\n\n"");
        return 0;
    }

    int i = 0;
    
    while (fscanf(arq_1, ""%f"", &aux_2) != EOF)
    {
        i++;
    }

    printf(""\ni = %i\n"", i);

    texto = malloc(i * sizeof(float));

    rewind(arq_1);

    for (int j = 0; j < i; j++)
    {
        fscanf(arq_1, ""%f"", texto+j);
        
    }

    n = texto[0];
    m = texto[1];

    

    matriz = malloc(n * sizeof(float*));
    for (int i = 0; i < n; i++)
    {
        matriz[i] = malloc(m * sizeof(float));
    }


    for (int i = 0, k = 0; i < n; i++)
    {
        for (int  j = 0; j < m; j++)
        {
            matriz[i][j] = texto[k+2];
            k++;
            
        }
        
    }
    

    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            fprintf(arq_2, ""%f "", matriz[j][i]);
            
        }
        fprintf(arq_2, ""%c"", '\n');
        
    }


    return 0;
}",29,910,576
"#include ""funcoes.h""

double fatorial(int n)
{
    double x = 1;

    for (int i = 2; i <= n; i++)
    {
        x *= i; 
    }

    return x; 
}

double f_de_x(int n, double a[], double x) 
{
    double soma = 0;

    for (int i = 0; i <= n; i++)
    {
        soma += a[i] * pow(x, i); 
    }

    return soma; 
}

int f_de_x_taylor(int n, double at[], double x, double xf)
{
    double soma = 0;

    for (int i = 0; i <= n; i++)
    {
        soma += (at[i] * pow(x, i)) / fatorial(i); 

        printf(""%i %lf %lf\n"", i + 1, soma, xf); 

        if (fabs(soma - xf) <= 0.001) 
            return 0;
    }

    return 0;
}

void vetor_taylor(int n, double a[], double x, double xf)
{
    double at[7];

    for (int i = 0; i <= n; i++)
    {
        at[i] = a[i]; 
    }

    for (int i = 1; i <= n; i++)
    {
        for (int j = i; j > 0; j--)
        {
            at[i] *= j; 
        }
    }

    f_de_x_taylor(n, at, x, xf); 
}",29,911,447
"int main()
{
    int matriz[1000][1000], n, soma, maior = INT_MIN, k0;

    scanf(""%i"", &n);

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            scanf(""%i"", &matriz[i][j]);
        }
    }

    for (int k = (-n + 1); k < n; k++)
    {
        soma = 0;
        for (int i = 0, j; i < n; i++)
        {
            j = i + k;
            if (j >= 0 && j < n)
            {
                soma += matriz[i][j];
            }
        }

        if (soma > maior)
        {
            maior = soma;
            k0 = k;
        }
    }

    printf(""%i %i\n"", k0, maior);

    return 0;
}",29,912,258
"int main()
{
    int matriz[4][4];
    int soma = 0;
    system(""clear"");
    printf(""Informe os elementos(int) de uma matriz 4x4:\n"");

    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            scanf(""%i"", &matriz[i][j]);
            if (i == j)
            {
                soma += matriz[i][j];
            }
        }
    }

    system(""clear"");
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            if (j == 0)
            {
                printf(""|"");
            }
            printf(""%3i"", matriz[i][j]);
            if (j == 3)
            {
                printf("" |"");
            }
        }
        printf(""\n"");
    }
    printf(""\nA soma dos elementos da diagonal principal Ã©: %d\n\n"", soma);
    return 0;
}",29,913,291
"#define true 1
#define false 0

int primos(long int maior, long int vet[])
{
    long int primo = 3;
    int busca, i0;
    vet[0] = 2;
    for (int i = i; (vet[i] * vet[i]) <= maior;)
    {
        busca = true;
        for (int j = i; (j >= 0) && (busca == true); j--)
        {
            if (primo % vet[j] == 0)
                busca = false;
        }

        if (busca == true)
        {
            vet[i + 1] = primo;
            i++;
            i0 = i;
        }

        else if (busca == false)
            primo++;
    }

    return i0;
}

int primo(long int num, long int vet[], int tam)
{    
    if (num == 1) return false;

    else if (num == 2) return true;
        
    else
    {
        for (int j = 0; j <= tam; j++)
        {
            if ((num % vet[j] == 0) && (num != vet[j]))
                return false;
        }
    }

    return true;
}

int main(int argc, char **argv)
{
    int t, tam, primovf;
    long int n[200000], maior = 0, n0, vet[10000];

    scanf(""%i"", &t);

    for (int i = 0; i < t; i++)
    {
        scanf(""%li"", &n[i]);

        if (n[i] > maior)
            maior = n[i];
    }

    tam = primos(maior, vet);

    for  (int i = 0; i < t; i++)
    {
        primovf = primo(n[i], vet, tam);

        n0 = n[i];

        while (primovf == true && n[i] >= 10)
        {
            n[i] /= 10;
            
            primovf = primo(n[i], vet, tam);
        }

        if (primovf == true)
            printf(""S\n"");
        
        else if (primovf == false)
            printf(""N\n"");
    }    

    return 0;
}",29,914,623
"double exponencial(double a, int n)
{
    if (n == 0) return 1;

    else if (n == 1) return a;

    else if (n < 0) return exponencial(1/a, (-1)*n);

    else if (n % 2 == 0) return exponencial(a, n/2) * exponencial(a, n/2);

    else return exponencial(a, n-1) * exponencial(a, 1);
}

int main()
{
    double a;
    int n;

    printf(""\nFunÃ§Ã£o exponencial (a^n):\n"");
    printf(""\t -> (real) a: "");
    scanf(""%lf"", &a);
    getchar();
    printf(""\t -> (int) n: "");
    scanf(""%i"", &n);

    printf(""\n%lf^%i = %lf\n\n"", a, n, exponencial(a,n));

    return 0;
}",29,915,260
"typedef struct Aluno
{
    char nome[32];
    int semestre;
    float ra;

} aluno_t;

void imprime_sem(aluno_t *alunos, int x, int n)
{
    for (int i = 0; i < n; i++)
    {
        if (alunos[i].semestre == x)
        {
            printf(""\nNome: %s\n"", alunos[i].nome);
            printf(""Semestre: %i\n"", alunos[i].semestre);
            printf(""Rendimento acadÃªmico: %f\n"", alunos[i].ra);
        }
    }
}

int main(int argc, char **argv)
{
    FILE *arq;
    aluno_t *alunos;
    char aux;
    int x;

    if (argc < 2)
    {
        printf(""\nErro! NÃ£o foi informado o nome do arquivo.\n\n"");
        return 0;
    }

    arq  = fopen(argv[1], ""r"");

    if (arq == NULL)
    {
        printf(""\nErro ao abrir o arquivo.\n\n"");
        return 0;
    }

    int i = 1;
    while (fscanf(arq, ""%c"", &aux) != EOF)
    {
        if (aux == '\n')
        {
            i++;
        }
    }

    rewind(arq);

    if (i % 3 == 0)
    {
        i /= 3;
    }
    
    else
    {
        printf(""\nInformaÃ§Ãµes insuficientes.\n\n"");
        return 0;
    }

    alunos = malloc(i * sizeof(aluno_t));

    for (int j = 0; j < i; j++)
    {
        fscanf(arq, ""%s"", alunos[j].nome);
        fscanf(arq, ""%i"", &alunos[j].semestre);
        fscanf(arq, ""%f"", &alunos[j].ra);
    }

    printf(""\nDigite um semestre: "");
    scanf(""%i"", &x);
    getchar();

    imprime_sem(alunos, x, i);

    fclose(arq);

    return 0;
}",29,916,605
"#define true 1
#define false 0

int main(void)
{
    long int n;
    int vf = false, qtd = 0, primo = 2;

    do
    {
        printf(""\nDigite um numero natural para calcular seus fatores primos: "");
        scanf(""%li"", &n);
        if (n < 0)
        {
            printf(""ERRO! Favor digitar um numero natural\n"");
        }
    } while (n < 0);

    if (n == 0)
    {
        printf(""\nNao ha fatores primos de 0\n"");
    }
    else if (n == 1)
    {
        printf(""\n1 = 1\n"");
    }
    else
    {
        printf(""\n%.0li = "", n);
        while (n > 1)
        {
            while (vf = false)
            {
                for (int i = 2; i < primo; i++)
                {
                    if ((primo % i) == 0)
                    {
                        vf = true;
                    }
                }
                if (vf = false)
                {
                    primo++;
                }
            }
            while ((n % primo) == 0)
            {
                n = n / primo;
                qtd++;
            }
            if (qtd != 0)
            {
                printf(""%i(%i) "", primo, qtd);
            }

            primo++;
            vf = false;
            qtd = 0;
        }
        printf(""\n\n"");
    }
}",29,917,402
"int main()
{
    double x[1000], y[1000], d, menor;
    int n, p1, p2;

    scanf (""%i"", &n);

    for (int i=0; i<n; i++)
    {
        scanf (""%lf"", &x[i]);
    }
    
    for (int i=0; i<n; i++)
    {
        scanf (""%lf"", &y[i]);
    }

    for (int i=0; i<n; i++)
    {
        for (int j=(i+1); j<n; j++)
        {
            d = pow((x[i]-x[j]),2) + pow((y[i]-y[j]),2);
            d = sqrt(d);
            
            if ((i==0)&&(j==1))
            {
                menor = d;
                p1 = i;
                p2 = j;
            }
            else
            {
                if (d < menor)
                {
                    menor = d;
                    p1 = i;
                    p2 = j;
                }
            }
            
        }
    }

    printf (""Pontos: %i e %i\nDistancia: %lf\n"", p1, p2, menor);

    return 0;
}",29,918,340
"#define true 1
#define false 0

int main()
{
    char frase[200], termo[200];
    int i = 0, tam_frase, tam_termo, busca = false, indice;
    puts(""\nInforme uma frase:"");
    scanf(""%[^\n]s"", frase);
    getchar();
    puts(""\nInforme um termo:"");
    scanf(""%[^\n]s"", termo);

    tam_frase = strlen(frase);
    tam_termo = strlen(termo);

    if (tam_frase >= tam_termo)
    {
        for (int i = 0; i < tam_frase; i++)
        {
            if ((frase[i] == termo[0]) && (busca == false))
            {
                busca = true;
                indice = i;
                for (int j = 0; j < tam_termo; j++)
                {
                    if ((frase[i + j] != termo[j]) && (busca == true))
                    {
                        busca = false;
                    }
                }
            }
        }
    }
    if (busca == true)
    {
        printf(""\nTermo encontrado, iniciando-se na posiÃ§Ã£o %i\n\n"", indice + 1);
    }
    else if (busca == false)
    {
        puts(""\nTermo nÃ£o encontrado na frase\n"");
    }
    return 0;
}",29,919,395
"int main()
{
    int qtd, n, qtd_total = 0;
    scanf (""%i"", &qtd);

    for (int i=0; i<qtd; i++)
    {
        scanf (""%i"", &n);

        while (n>=100)
        {
            n -= 100;
            qtd_total++;
        }
        
        if ((50<=n)&&(n<=99))
        {
            n -= 50;
            qtd_total++;
        } 

        if ((25<=n)&&(n<=49))
        {
            n -= 25;
            qtd_total++;
        }

        while ((10<=n)&&(n<=24))
        {
            n -= 10;
            qtd_total++;
        }

        if ((5<=n)&&(n<=9))
        {
            n -= 5;
            qtd_total++;
        }

        while ((2<=n)&&(n<=4))
        {
            n -= 2;
            qtd_total++;
        }

        if (n==1)
        {
            n--;
            qtd_total++;
        }
    
        printf (""%i notas\n"", qtd_total);
        qtd_total = 0;

    }

    return 0;
}",29,920,351
"int main()
{
    double A[100][100], B[100][100], soma = 0;
    int n, m, k, l;

    scanf(""%i %i %i %i"", &n, &m, &k, &l);

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            scanf(""%lf"", &A[i][j]);
        }
    }

    for (int i = 0; i < k; i++)
    {
        for (int j = 0; j < l; j++)
        {
            scanf(""%lf"", &B[i][j]);
        }
    }

    if (m != k)
    {
        printf(""impossivel\n"");
        return 0;
    }

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < l; j++)
        {
            for (int a = 0; a < m; a++)
            {
                soma += A[i][a] * B[a][j];
            }
            printf(""%.2lf "", soma);
            soma = 0;
        }
        putchar('\n');
    }

    return 0;
}",29,921,343
"#define true 1
#define false 0

int main()
{
    int n,num,aux,condicao = true, maior, smaior, smenor, menor, maior0, smaior0, menor0, smenor0;

    scanf (""%i"", &n);

    for (int i=0; i<n; i++)
    {
        scanf (""%i"", &num);
        if (i==0)
        {
            maior = num;
            menor = num;
            smaior = num;
            smenor = num;
        }
        else
        {
            if (num > maior)
            {
                aux = maior;
                maior = num;
                smaior = aux;
            }
            else if (num < menor)
            {
                aux = menor;
                menor = num;
                smenor = aux;
            }
            if ((maior == smaior)&&(num < smaior)&&(num > smenor)&&(num > menor))
            {
                smaior = num;
            }
            else if ((menor == smenor)&&(num > smenor)&&(num < smaior)&&(num < maior))
            {
                smenor = num;
            }
            else if ((maior == smaior)&&(num < smaior))
            {
                smaior = num;
            }
            else if ((menor == smenor)&&(num > smenor))
            {
                smenor = num;
            }
            if ((maior == smaior)&&(maior == smenor)&&(num < smenor)&&(num > menor))
            {
                smaior = num;
                smenor = num;
            }
            else if ((menor == smenor)&&(menor == smaior)&&(num > smaior)&&(num < maior))
            {
                smenor = num;
                smaior = num;
            }
            if ((num < maior)&&(num > smaior))
            {
                smaior = num;
            }
            else if ((num > menor)&&(num < smenor))
            {
                smenor = num;
            }
        }
        
    }
    
        if ((maior == smaior)&&(smaior == smenor)&&(smenor == menor))
            printf (""%i\n%i\nnao definido\nnao deifnido\n"", maior, menor);

        else
            printf (""%i\n%i\n%i\n%i\n"", maior, menor, smaior, smenor);
    
    return 0;
}",29,922,674
"int main()
{
    char matriz[3][5];

    system(""clear"");

    printf(""informe os elementos(char) de uma matriz 3x5:\n"");
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 5; j++)
        {
            scanf(""%c"", &matriz[i][j]);
            getchar();
        }
    }

    system(""clear"");

    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 5; j++)
        {
            if (j == 0)
            {
                printf(""|"");
            }
            printf(""%2c"", matriz[i][j]);
            if (j == 4)
            {
                printf("" |"");
            }
        }
        printf(""\n"");
    }
    printf(""\n"");

    for (int i = 0; i < 5; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            if (j == 0)
            {
                printf(""|"");
            }
            printf(""%2c"", matriz[j][i]);
            if (j == 2)
            {
                printf("" |"");
            }
        }
        printf(""\n"");
    }
    printf(""\n"");
    return 0;
}",29,923,357
"#include ""funcoes.h"" 
#define iteracoes 10000

int main()
{
    int n;
    double a[7], l, r, m;

    scanf(""%i"", &n); 
    getchar();

    for (int i = 0; i <= n; i++)
    {
        scanf(""%lf"", &a[i]); 
        getchar();
    }

    scanf(""%lf"", &l); 
    getchar();
    scanf(""%lf"", &r); 
    getchar();

    for (long int i = 0; i <= iteracoes; i++)
    {

        m = l + ((r-l)/2);

        if (fabs(f_de_x(n, a, m)) <= 0.0001) 
        {
            printf(""\n%lf\n\n"", m); 
            return 0;
        }

        if ((f_de_x(n, a, m) * f_de_x(n, a, l)) < 0) 
        {
            r = m; 
        }
        
        else 
        {
            l = m; 
        }

        if (i == iteracoes)
        {
            printf(""raiz nao encontrada\n""); 
        }

    }

    return 0;
}",29,924,347
"#define true 1
#define false 0

int main()
{
    int n, primos[10000], aux = 3, k = 0, primo;
    primos[0] = 2;

    scanf(""%i"", &n);

    for (int i=0; i< n; i++)
    {
        primo = true;
        for (int j=k; j>=0; j--)
        {
            if ((aux % primos[j]) == 0)
            {
                primo = false;
            }
        }

        if (primo == false)
        {
            aux+=2;
        }

        if (primo == true)
        {
            primos[k+1] = aux;
            k++;
        }
    }

    for (int i=0; i<=k; i++)
    {
        printf(""%i "", primos[i]);
    }

    return 0;
}",29,925,239
"typedef enum
{
    fib = 1, pad, cat, quit

} func_t;

void le_numero(int *n)
{
    do
    {
        printf(""\nDigite um inteiro positivo: "");
        scanf(""%i"", n);
        getchar();
        system(""clear"");

    } while (n < 0);
}

long int fibonacci(int n)
{
    return (n > 1) ? fibonacci(n-1) + fibonacci(n-2) : 1;
}

long int padovan(int n)
{
    return (n > 2) ? padovan(n-2) + padovan(n-3) : 1;
}

long int catalan(float n)
{
    return (n > 0) ? ((4*n - 2) / (n+1)) * catalan(n-1) : 1;
}

int main()
{
    int n;
    func_t escolha;
    
    do
    {
        do
        {
            printf(""\t(1) Fibonacci\n"");
            printf(""\t(2) Padovan\n"");
            printf(""\t(3) Catalan\n"");
            printf(""\t(4) Sair\n"");
            printf(""\n\tDigite sua escolha: "");
            scanf(""%i"", &escolha);
            getchar();
            system(""clear"");

        } while (escolha != fib && escolha != pad && escolha != cat && escolha != quit);

        if (escolha == quit) return 0;

        le_numero(&n);

        switch (escolha)
        {
            case fib:
                printf(""\nFibonacci de %i = %li\n\n"", n, fibonacci(n));
                break;
            
            case pad:
                printf(""\nPadovan de %i = %li\n\n"", n, padovan(n));
                break;
            
            case cat:
                printf(""\nCatalan de %i = %li\n\n"", n, catalan(n));
                break;
        }

        printf(""\nPressione ENTER para continuar: "");
        getchar();
        system(""clear"");

    } while (escolha != quit);

    return 0;
}",29,926,579
"#define true 1
#define false 0

void fill_letters(char str[], char letters[])
{
    int busca, tam;

    letters[0] = str[0];
    for (int i = 0; str[i] != '\0'; i++)
    {
        busca = false;
        for (int j = 0; (letters[j] != '\0') && (busca == false); j++)
        {
            if (letters[j] == str[i])
            {
                busca = true;
            }
        }
        if (busca == false)
        {
            tam = strlen(letters);
            letters[tam] = str[i];
            letters[tam + 1] = '\0';
        }
    }
}

int main()
{
    char str[100002], letters[100002];
    int qtd, tam_s, impar = false, pali = true;

    fgets(str, 100002, stdin);

    if (str[strlen(str) - 1] == '\n')
    {
        str[strlen(str) - 1] = '\0';
    }

    fill_letters(str, letters);
    tam_s = strlen(str);

    for (int i = 0; (letters[i] != '\0') && (pali == true); i++)
    {
        qtd = 0;
        for (int j = 0; str[j] != '\0'; j++)
        {
            if (letters[i] == str[j])
            {
                qtd++;
            }
        }

        if (tam_s % 2 == 0)
        {
            if (qtd % 2 != 0)
            {
                pali = false;
            }
        }
        else
        {
            if (qtd % 2 != 0)
            {
                if (impar == false)
                {
                    impar = true;
                }
                else if (impar == true)
                {
                    pali = false;
                }
            }
        }    
    }

    if (pali == true)
    {
        printf(""Sim\n"");
    }

    else
    {
        printf(""Nao\n"");
    }

    return 0;
}",29,927,600
"typedef enum Bool
{
    false, true

} bool;

typedef struct Quantidade
{
    int chars;
    int linhas;
    int palavras;

} qtd_t;

int main(int argc, char **argv)
{
    FILE *arq;
    char aux;
    qtd_t qtd;
    bool espaco = false, pontuacao = false, enter = false;
    
    qtd.chars = 0;
    qtd.linhas = 1;
    qtd.palavras = 0;

    if (argc < 2)
    {
        printf(""\nErro! NÃ£o foram informados arquivos o suficiente\n\n"");
        return 0;
    }

    arq = fopen(argv[1], ""r"");

    if (arq == NULL)
    {
        printf(""\nErro ao abrir o arquivo.\n\n"");
        return 0;
    }

    for (int i = 0; fscanf(arq, ""%c"", &aux) != EOF; i++)
    {
        if (aux == '\n')
        {
            qtd.linhas++;
        }

        if (i == 0)
        {
            if (aux != ' ' && aux != '\n' && aux != ',' && aux != '.' && aux != ';' && aux != ':' && aux != '?' && aux != '!')
            {
                qtd.chars++;
                qtd.palavras++;
            }
        }

        else
        {
            if (aux == ' ')
            {
                espaco = true;
            }

            else if (aux == ',' || aux == '.' || aux == ';' || aux == ':' || aux == '?' || aux == '!')
            {
                pontuacao = true;
            }

            else if (aux == '\n')
            {
                enter = true;
            }

            else
            {
                qtd.chars++;
            }

            if ((espaco == true || pontuacao == true || enter == true) &&\
                (aux != ' ' && aux != '\n' && aux != ',' && aux != '.' && aux != ';' && aux != ':' && aux != '?' && aux != '!'))
                {
                    qtd.palavras++;

                    espaco = false;
                    pontuacao = false;
                    enter = false;
                }
        }
    }

    printf(""\n%s:\n"", argv[1]);
    printf(""\t-> chars: %i\n"", qtd.chars);
    printf(""\t-> palavras: %i\n"", qtd.palavras);
    printf(""\t-> linhas: %i\n"", qtd.linhas);

    return 0;
}",29,928,708
"#define true 1
#define false 0

int main()
{
    char t[1002], p[102];
    int tamt, tamp, busca;

    fgets(t, 1002, stdin);
    fgets(p, 102, stdin);

    for (int i = 0; t[i] != '\0'; i++)
    {
        if (t[i] == '\n')
        {
            t[i] = '\0';
        }
    }

    for (int i = 0; p[i] != '\0'; i++)
    {
        if (p[i] == '\n')
        {
            p[i] = '\0';
        }
    }

    tamt = strlen(t);
    tamp = strlen(p);

    

    for (int i = 0; i <= (tamt - tamp); i++)
    {
        if (t[i] == p[0])
        {
            busca = true;
            for (int k = 0; k < tamp; k++)
            {
                if (t[i+k] != p[k])
                {
                    busca = false;
                    break;
                }
            }

            if (busca == true)
            {
                printf (""%i "", i);
            }
        }
    }

    printf(""\n\n"");
    return 0;
}",29,929,365
"typedef enum Bool
{
    false, true

} bool;

typedef struct Ponto
{
    double x;
    double y;

} ponto_t;

typedef struct Retangulo
{
    ponto_t sup_esq;
    ponto_t inf_dir;

} rect_t;

void le_retangulo(rect_t *retangulo)
{
    printf(""\nDigite as coordenadas do retÃ¢ngulo:\n"");
    
    printf(""\n\tPonto superior esquerdo:\n"");
    printf(""\t-> Coordenada x: "");
    scanf(""%lf"", &retangulo->sup_esq.x);
    getchar();
    printf(""\t-> Coordenada y: "");
    scanf(""%lf"", &retangulo->sup_esq.y);
    getchar();

    printf(""\n\tPonto inferior direito:\n"");
    printf(""\t-> Coordenada x: "");
    scanf(""%lf"", &retangulo->inf_dir.x);
    getchar();
    printf(""\t-> Coordenada y: "");
    scanf(""%lf"", &retangulo->inf_dir.y);
    getchar();
}

void le_retangulos(rect_t *retangulo_1, rect_t *retangulo_2)
{
    printf(""\nDigite as coordenadas do 1Âº retÃ¢ngulo:\n"");
    
    printf(""\n\tPonto superior esquerdo:\n"");
    printf(""\t-> Coordenada x: "");
    scanf(""%lf"", &retangulo_1->sup_esq.x);
    getchar();
    printf(""\t-> Coordenada y: "");
    scanf(""%lf"", &retangulo_1->sup_esq.y);
    getchar();

    printf(""\n\tPonto inferior direito:\n"");
    printf(""\t-> Coordenada x: "");
    scanf(""%lf"", &retangulo_1->inf_dir.x);
    getchar();
    printf(""\t-> Coordenada y: "");
    scanf(""%lf"", &retangulo_1->inf_dir.y);
    getchar();

    printf(""\nDigite as coordenadas do 2Âº retÃ¢ngulo:\n"");
    
    printf(""\n\tPonto superior esquerdo:\n"");
    printf(""\t-> Coordenada x: "");
    scanf(""%lf"", &retangulo_2->sup_esq.x);
    getchar();
    printf(""\t-> Coordenada y: "");
    scanf(""%lf"", &retangulo_2->sup_esq.y);
    getchar();

    printf(""\n\tPonto inferior direito:\n"");
    printf(""\t-> Coordenada x: "");
    scanf(""%lf"", &retangulo_2->inf_dir.x);
    getchar();
    printf(""\t-> Coordenada y: "");
    scanf(""%lf"", &retangulo_2->inf_dir.y);
    getchar();
}

double area(rect_t retangulo)
{
    double area = (retangulo.sup_esq.x - retangulo.inf_dir.x) * (retangulo.sup_esq.y - retangulo.inf_dir.y);

    return (area < 0) ? area*(-1) : area;
}

bool intersecao(rect_t retangulo_1, rect_t retangulo_2)
{
    bool sup_esq = false, inf_dir = false;

    if ((((retangulo_2.sup_esq.x > retangulo_1.sup_esq.x) && (retangulo_2.sup_esq.x < retangulo_1.inf_dir.x)) || ((retangulo_2.sup_esq.y < retangulo_1.sup_esq.y) && (retangulo_2.sup_esq.y > retangulo_1.inf_dir.y))) == true)
    {
        sup_esq = true;
    }

    if ((((retangulo_2.inf_dir.x < retangulo_1.inf_dir.x) && (retangulo_2.inf_dir.x > retangulo_1.sup_esq.x)) || ((retangulo_2.inf_dir.y > retangulo_1.inf_dir.y) && (retangulo_2.inf_dir.y < retangulo_1.sup_esq.y))) == true)
    {
        inf_dir = true;
    }

    if ((sup_esq || inf_dir) == true)
    {
        return true;
    }

    else return false;
}

int contido(rect_t retangulo_1, rect_t retangulo_2)
{
    if (((retangulo_2.sup_esq.x > retangulo_1.sup_esq.x && retangulo_2.sup_esq.x < retangulo_1.inf_dir.x) && (retangulo_2.sup_esq.y < retangulo_1.sup_esq.y && retangulo_2.sup_esq.y > retangulo_1.inf_dir.y)) &&\
        ((retangulo_2.inf_dir.x < retangulo_1.inf_dir.x && retangulo_2.inf_dir.x > retangulo_1.sup_esq.x) && (retangulo_2.inf_dir.y > retangulo_1.inf_dir.y && retangulo_2.inf_dir.y < retangulo_1.sup_esq.y)) == true)
    {
        return 2;
    }

    else if (((retangulo_1.sup_esq.x > retangulo_2.sup_esq.x && retangulo_1.sup_esq.x < retangulo_2.inf_dir.x) && (retangulo_1.sup_esq.y < retangulo_2.sup_esq.y && retangulo_1.sup_esq.y > retangulo_2.inf_dir.y)) &&\
             ((retangulo_1.inf_dir.x < retangulo_2.inf_dir.x && retangulo_1.inf_dir.x > retangulo_2.sup_esq.x) && (retangulo_1.inf_dir.y > retangulo_2.inf_dir.y && retangulo_1.inf_dir.y < retangulo_2.sup_esq.y)) == true)
    {
        return 1;
    }

    else if (((retangulo_1.sup_esq.x == retangulo_2.sup_esq.x && retangulo_1.sup_esq.y == retangulo_2.sup_esq.y) && (retangulo_1.inf_dir.x == retangulo_2.inf_dir.x && retangulo_1.inf_dir.y == retangulo_2.inf_dir.y)) == true)
    {
        return 3;
    }

    else return 0;
}

double intersecao_area(rect_t retangulo_1, rect_t retangulo_2)
{
    rect_t retangulo;

    if (retangulo_2.sup_esq.x >= retangulo_1.sup_esq.x && retangulo_2.sup_esq.x <= retangulo_1.inf_dir.x)
    {
        retangulo.sup_esq.x = retangulo_2.sup_esq.x;
    }

    else retangulo.sup_esq.x = retangulo_1.sup_esq.x;

    if (retangulo_2.sup_esq.y <= retangulo_1.sup_esq.y && retangulo_2.sup_esq.y >= retangulo_1.inf_dir.y)
    {
        retangulo.sup_esq.y = retangulo_2.sup_esq.y;
    }

    else retangulo.sup_esq.y = retangulo_1.sup_esq.y;

    if (retangulo_2.inf_dir.x <= retangulo_1.inf_dir.x && retangulo_2.inf_dir.x >= retangulo_1.sup_esq.x)
    {
        retangulo.inf_dir.x = retangulo_2.inf_dir.x;
    }

    else retangulo.inf_dir.x = retangulo_1.inf_dir.x;

    if (retangulo_2.inf_dir.y >= retangulo_1.inf_dir.y && retangulo_2.inf_dir.y <= retangulo_1.sup_esq.y)
    {
        retangulo.inf_dir.y = retangulo_2.inf_dir.y;
    }

    else retangulo.inf_dir.y = retangulo_1.inf_dir.y;

    printf(""\nsup_esq (%lf,%lf)\ninf_dir(%lf,%lf)\n"", retangulo.sup_esq.x, retangulo.sup_esq.y, retangulo.inf_dir.x, retangulo.inf_dir.y);
    
    return area(retangulo);
}


int main()
{
    rect_t retangulo_1, retangulo_2;
    int escolha;

    do
    {
        do
        {
            printf(""\n\t(1) Calcular a Ã¡rea de um retÃ¢ngulo\n"");
            printf(""\t(2) Verificar interseÃ§Ã£o de retangulos\n"");
            printf(""\t(3) Verificar se um retÃ¢ngulo estÃ¡ contido em um outro\n"");
            printf(""\t(4) Calcular a Ã¡rea da interseÃ§Ã£o entre dois retangulos\n"");
            printf(""\t(5) Sair\n"");
            printf(""\n\tDigite sua escolha: "");
            scanf(""%i"", &escolha);
            getchar();

            if (escolha < 1 || escolha > 5) system(""clear"");

        } while (escolha < 1 || escolha > 5);

        switch (escolha)
        {
            case 1:
                le_retangulo(&retangulo_1);
                printf(""\nÃrea = %lf\n"", area(retangulo_1));
                break;
            
            case 2:
                le_retangulos(&retangulo_1, &retangulo_2);

                if ((intersecao(retangulo_1, retangulo_2) || intersecao(retangulo_2, retangulo_1)) == true)
                {
                    printf(""\nOs retÃ¢ngulos dados se intersectam!\n"");
                }

                else printf(""\nOs retÃ¢ngulos dados nÃ£o se intersectam!\n"");

                break;

            case 3:
                le_retangulos(&retangulo_1, &retangulo_2);

                switch (contido(retangulo_1, retangulo_2))
                {
                    case 1:
                        printf(""\nO retÃ¢ngulo 1 estÃ¡ contido no retÃ¢ngulo 2\n"");
                        break;

                    case 2:
                        printf(""\nO retÃ¢ngulo 2 estÃ¡ contido no retÃ¢ngulo 1\n"");
                        break;
                    
                    case 3:
                        printf(""\nOs retÃ¢ngulos sÃ£o identicos\n"");
                        break;
                    
                    case 0:
                        printf(""\nNenhum retÃ¢ngulo estÃ¡ contido no outro\n"");
                        break;
                }

                break;

            case 4:
                le_retangulos(&retangulo_1, &retangulo_2);

                if ((intersecao(retangulo_1, retangulo_2) || intersecao(retangulo_2, retangulo_1)) == false)
                {
                    printf(""\nOs retÃ¢ngulos dados nÃ£o se intersectam!\n"");
                }

                else
                {
                    printf(""\nÃrea da interseÃ§Ã£o = %lf\n"", intersecao_area(retangulo_1, retangulo_2));
                }

                break;
            
            case 5:
                return 0;
        }

        printf(""\nPressione ENTER para continuar: "");
        getchar();
        system(""clear"");
    
    } while (escolha != 5);

    return 0;

}",29,930,3261
"#define true 1
#define false 0

long int primos[500];

int primov(long int n)
{
    primos[0] = 2;
    int k = 0, primo;

    for (long int i = 3; (primos[k] * primos[k]) <= n; i += 2)
    {
        primo = true;
        for (int j = 0; (j <= k) && (primo == true); j++)
        {
            if ((i % primos[j]) == 0)
            {
                primo = false;
            }
        }

        if (primo == true)
        {
            primos[k + 1] = i;
            k++;
        }
        
    }

    return k;
}

int busca(long int n, int k)
{
    for (int j = 0; (j <= k) && ((primos[j] * primos[j]) <= n); j++)
    {
        if ((n % primos[j]) == 0)
        {
            printf(""composto\n"");
            return 0;
        }
    }

    printf(""primo\n"");
    return 0;
}

int main()
{
    long int num[100000], maior;
    int n, k;

    scanf(""%i"", &n);

    for (int i = 0; i < n; i++)
    {
        scanf(""%li"", &num[i]);

        if (i == 0)
        {
            maior = num[i];
        }

        else if (num[i] > maior)
        {
            maior = num[i];
        }
    }

    k = primov(maior);

    for (int i = 0; i < n; i++)
    {

        if (num[i] == 1)
        {
            printf(""composto\n"");
        }

        else if (num[i] == 2)
        {
            printf(""primo\n"");
        }

        else
        {
            busca(num[i], k);
        }
    }

    

    return 0;
}",29,931,557
"void palavra_fibonacci(int n)
{
    if (n == 0) putchar('b');

    else if (n == 1) putchar('a');

    else
    {
        palavra_fibonacci(n-1);
        palavra_fibonacci(n-2);
    }
}

int main()
{
    int n;

    do
    {
        printf(""\nDigite um inteiro nÃ£o-negativo: "");
        scanf(""%i"", &n);
        getchar();
        system(""clear"");

    } while (n < 0);

    printf(""\nA %iÂª palavra de Fibonacci:\n\n"", n);
    palavra_fibonacci(n);
    printf(""\n\n"");

    return 0;
}",29,932,213
"int main(void)
{
    float temp, frio, normal, quente;

    printf(""\nInforme a temperatura ambiente em graus celsius: "");
    scanf(""%f"", &temp);

    
    
    
    if (temp < 20)
    {
        frio = 1;
        normal = 0;
        quente = 0;
    }

    
    
    
    else if ((temp >= 20) && (temp <= 26))
    {
        frio = 0;
        normal = 1;
        quente = 0;
    }

    
    
    
    else
    {
        frio = 0;
        normal = 0;
        quente = 1;
    }

    if (frio == 1)
    {
        printf(""\nO aparelho estÃ¡ aquecendo\n\n"");
    }
    else if (normal == 1)
    {
        printf(""\nO aparelho estÃ¡ desligado\n\n"");
    }
    else if (quente == 1)
    {
        printf(""\nO aparelho estÃ¡ resfriando\n\n"");
    }
}",29,933,304
"int main()
{
    char nome1[100], sobrenome1[100], nome2[100], sobrenome2[100], sobrenome2_2[100];
    int i1, j1, i2, j2, i1_2, tam_sobrenome1, tam_sobrenome2;

    printf(""\nInforme o 1Âº nome: "");
    scanf(""%[^\n]s"", nome1);
    getchar();
    printf(""\nInforme o 1Âº sorenomenome: "");
    scanf(""%[^\n]s"", sobrenome1);
    getchar();
    printf(""\nInforme o 2Âº nome: "");
    scanf(""%[^\n]s"", nome2);
    getchar();
    printf(""\nInforme o 2Âº sobrenome: "");
    scanf(""%[^\n]s"", sobrenome2);
    getchar();

    strcpy(sobrenome2_2, sobrenome2);

    tam_sobrenome1 = strlen(sobrenome1);
    i1 = tam_sobrenome1;
    while (sobrenome1[i1] != ' ')
    {
        i1--;
    }
    i1_2 = i1 + 1;

    tam_sobrenome2 = strlen(sobrenome2);
    j1 = 0;
    while (sobrenome2[j1] != ' ')
    {
        j1++;
    }

    for (int k = (j1 + 1); k <= (j1 + i1); k++)
    {
        sobrenome2[k] = sobrenome1[i1_2];
        i1_2++;
    }

    printf(""\n%s %s e %s %s.\nApÃ³s casados se chamarÃ£o:\n%s %s e %s %s\n\n"",
           nome1, sobrenome1, nome2, sobrenome2_2, nome1, sobrenome2, nome2, sobrenome2);
    return 0;
}",29,934,546
"int main()
{
    char nomes1[4][10], nomes2[4][10], quadrilha[4][2][10];

    system(""clear"");
    printf(""Informe os primeiros 4 nomes (sem acentuaÃ§Ã£o):\n"");
    for (int i = 0; i < 4; i++)
    {
        scanf(""%10[^\n]s"", nomes1[i]);
        getchar();
    }
    printf(""\nInforme os Ãºltimos 4 nomes (sem acentuaÃ§Ã£o):\n"");
    for (int i = 0; i < 4; i++)
    {
        scanf(""%10[^\n]s"", nomes2[i]);
        getchar();
    }

    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 2; j++)
        {
            if (j == 0)
            {
                strcpy(quadrilha[i][j], nomes1[i]);
            }
            else if (j == 1)
            {
                strcpy(quadrilha[i][j], nomes2[i]);
            }
        }
    }

    system(""clear"");
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 2; j++)
        {
            if (j == 0)
            {
                printf(""|"");
            }
            printf("" %-10s "", quadrilha[i][j]);
            if (j == 1)
            {
                printf(""|"");
            }
        }
        printf(""\n"");
    }
    printf(""\n\n"");
    return 0;
}",29,935,449
"int main(int argc, char **argv)
{
    FILE *arq_1, *arq_2, *arq_3;
    int *vet_1, *vet_2, aux;
    int aux_1 = {1, 3, 5, 7, 10, 11}, aux_2 = {0, 2, 4, 6, 8, 10};

    if (argc < 4)
    {
        printf(""\nErro! NÃ£o foram informados arquivos o suficiente\n\n"");
        return 0;
    }

    arq_1 = fopen(argv[1], ""w+b"");
    arq_2 = fopen(argv[2], ""w+b"");
    arq_3 = fopen(argv[3], ""wb"");

    if (arq_1 == NULL || arq_2 == NULL || arq_3 == NULL)
    {
        printf(""\nErro ao abrir algum arquivo\n\n"");
        return 0;
    }

    fwrite(&aux_1, sizeof(int), 6, arq_1);
    fwrite(&aux_2, sizeof(int), 6, arq_2);

    fseek(arq_1, 0, SEEK_SET);
    fseek(arq_2, 0, SEEK_SET);

    int i = 0, j = 0;
    
    while (fread(&aux, sizeof(int), 1, arq_1) != 0)
    {
        i++;
    }

    while (fread(&aux, sizeof(int), 1, arq_2) != 0)
    {
        j++;
    }

    vet_1 = malloc(i * sizeof(int));
    vet_2 = malloc(j * sizeof(int));

    fseek(arq_1, 0, SEEK_SET);
    fseek(arq_2, 0, SEEK_SET);

    fread(vet_1, sizeof(int), i, arq_1);
    fread(vet_2, sizeof(int), j, arq_2);

    for (int i2 = 0, j2 = 0; i2 < i, j2 < j;)
    {
        if (vet_1[i2] < vet_2[j2])
        {
            fwrite(vet_1 + i2, sizeof(int), 1, arq_3);
            i2++;
        }

        else if (vet_2[j2] < vet_1[i2])
        {
            fwrite(vet_2 + j2, sizeof(int), 1, arq_3);
            j2++;
        }

        else if (vet_1[i2] == vet_2[j2])
        {
            fwrite(vet_1 + i2, sizeof(int), 1, arq_3);
            fwrite(vet_2 + j2, sizeof(int), 1, arq_3);
            i2++;
            j2++;
        }
    }

    fclose(arq_1);
    fclose(arq_2);
    fclose(arq_3);

    return 0;
}",29,936,819
"int main ()
{
    int n, qtd;
    scanf (""%i"", &qtd);

    for (int i=0; i<qtd; i++)
    {
        scanf (""%i"", &n);

        while (n>=1000)
        {
            putchar ('M');
            n -= 1000;
        }

        if ((900<=n)&&(n<=999))
        {
            printf (""CM"");
            n -= 900;
        }
        else if ((800<=n)&&(n<=899))
        {
            printf (""DCCC"");
            n -= 800;
        }
        else if ((700<=n)&&(n<=799))
        {
            printf (""DCC"");
            n -= 700;
        }
        else if ((600<=n)&&(n<=699))
        {
            printf (""DC"");
            n -= 600;
        }
        else if ((500<=n)&&(n<=599))
        {
            printf (""D"");
            n -= 500;
        }
        else if ((400<=n)&&(n<=499))
        {
            printf (""CD"");
            n -= 400;
        }
        else if ((300<=n)&&(n<=399))
        {
            printf (""CCC"");
            n -= 300;
        }
        else if ((200<=n)&&(n<=299))
        {
            printf (""CC"");
            n -= 200;
        }
        else if ((100<=n)&&(n<=199))
        {
            printf (""C"");
            n -= 100;
        }

        if ((90<=n)&&(n<=99))
        {
            printf (""XC"");
            n -= 90;
        }
        else if ((80<=n)&&(n<=89))
        {
            printf (""LXXX"");
            n -= 80;
        }
        else if ((70<=n)&&(n<=79))
        {
            printf (""LXX"");
            n -= 70;
        }
        else if ((60<=n)&&(n<=69))
        {
            printf (""LX"");
            n -= 60;
        }
        else if ((50<=n)&&(n<=59))
        {
            printf (""L"");
            n -= 50;
        }
        else if ((40<=n)&&(n<=49))
        {
            printf (""XL"");
            n -= 40;
        }
        else if ((30<=n)&&(n<=39))
        {
            printf (""XXX"");
            n -= 30;
        }
        else if ((20<=n)&&(n<=29))
        {
            printf (""XX"");
            n -= 20;
        }
        else if ((10<=n)&&(n<=19))
        {
            printf (""X"");
            n -= 10;
        }

        switch (n)
        {
            case 9:
                printf (""IX"");
                n -= 9;
                break;
            case 8:
                printf (""VIII"");
                n -= 8;
                break;
            case 7:
                printf (""VII"");
                n -= 7;
                break;
            case 6:
                printf (""VI"");
                n -= 6;
                break;
            case 5:
                printf (""V"");
                n -= 5;
                break;
            case 4:
                printf (""IV"");
                n -= 4;
                break;
            case 3:
                printf (""III"");
                n -= 3;
                break;
            case 2:
                printf (""II"");
                n -= 2;
                break;
            case 1:
                printf (""I"");
                n -= 1;
                break;

        }
        printf (""\n"");
    }

    return 0;

}",29,937,1036
"int main(void)
{
    float temp;
    float frio, quente, normal;

    printf(""\nInforme a temperatura do ambiente em graus celsius: "");
    scanf(""%f"", &temp);

    if (temp <= 10)
    {
        frio = 1;
        normal = 0;
        quente = 0;
        
    }
    else if ((10 < temp) && (temp <= 11))
    {
        frio = 0.9;
        normal = 0.1;
        quente = 0;
        
    }
    else if ((11 < temp) && (temp <= 12))
    {
        frio = 0.8;
        normal = 0.2;
        quente = 0;
        
    }
    else if ((12 < temp) && (temp <= 13))
    {
        frio = 0.7;
        normal = 0.3;
        quente = 0;
        
    }
    else if ((13 < temp) && (temp <= 14))
    {
        frio = 0.6;
        normal = 0.4;
        quente = 0;
        
    }
    else if ((14 < temp) && (temp <= 15))
    {
        frio = 0.5;
        normal = 0.5;
        quente = 0;
        
    }
    else if ((15 < temp) && (temp <= 16))
    {
        frio = 0.5;
        normal = 0.5;
        quente = 0;
        
    }
    else if ((16 < temp) && (temp <= 17))
    {
        frio = 0.4;
        normal = 0.6;
        quente = 0;
        
    }
    else if ((17 < temp) && (temp <= 18))
    {
        frio = 0.3;
        normal = 0.7;
        quente = 0;
        
    }
    else if ((18 < temp) && (temp <= 19))
    {
        frio = 0.2;
        normal = 0.8;
        quente = 0;
        
    }
    else if ((19 < temp) && (temp <= 20))
    {
        frio = 0.1;
        normal = 0.9;
        quente = 0;
        
    }
    else if ((20 < temp) && (temp <= 25))
    {
        frio = 0;
        normal = 1;
        quente = 0;
        
    }
    else if ((25 < temp) && (temp <= 26))
    {
        frio = 0;
        normal = 0.9;
        quente = 0.1;
        
    }
    else if ((26 < temp) && (temp <= 27))
    {
        frio = 0;
        normal = 0.8;
        quente = 0.2;
        
    }
    else if ((27 < temp) && (temp <= 28))
    {
        frio = 0;
        normal = 0.7;
        quente = 0.3;
        
    }
    else if ((28 < temp) && (temp <= 29))
    {
        frio = 0;
        normal = 0.6;
        quente = 0.4;
        
    }
    else if ((29 < temp) && (temp <= 30))
    {
        frio = 0;
        normal = 0.5;
        quente = 0.5;
        
    }
    else if ((30 < temp) && (temp <= 31))
    {
        frio = 0;
        normal = 0.5;
        quente = 0.5;
        
    }
    else if ((31 < temp) && (temp <= 32))
    {
        frio = 0;
        normal = 0.4;
        quente = 0.6;
        
    }
    else if ((32 < temp) && (temp <= 33))
    {
        frio = 0;
        normal = 0.3;
        quente = 0.7;
        
    }
    else if ((33 < temp) && (temp <= 34))
    {
        frio = 0;
        normal = 0.2;
        quente = 0.8;
        
    }
    else if ((34 < temp) && (temp <= 35))
    {
        frio = 0;
        normal = 0.1;
        quente = 0.9;
        
    }
    else if (temp > 35)
    {
        frio = 0;
        normal = 0;
        quente = 1;
        
    }

    if ((frio > quente) && (normal != 1))
    {
        printf(""\nO aparelho estÃ¡ aquecendo com %.0f%% de potÃªncia\n\n"", frio * 100);
    }
    else if ((quente > frio) && (normal != 1))
    {
        printf(""\nO aparelho estÃ¡ resfriando com %.0f%% de potÃªncia\n\n"", quente * 100);
    }
    else if (normal == 1)
    {
        printf(""\nO aparelho estÃ¡ desligado\n\n"");
    }

    return 0;
}",29,938,1420
"int main()
{
    char hex[9];
    long int soma = 0;
    int tam, pot;

    fgets(hex, 9, stdin);

    for (int i = 0; hex[i] != '\0'; i++)
    {
        if (hex[i] == '\n')
        {
            hex[i] = '\0';
        }
    }

    tam = strlen(hex);
    pot = tam - 1;

    for (int i = 0; hex[i] != '\0'; i++)
    {
        switch (hex[i])
        {
        case '1':
            soma += 1 * pow(16, (pot - i));
            break;

        case '2':
            soma += 2 * pow(16, (pot - i));
            break;

        case '3':
            soma += 3 * pow(16, (pot - i));
            break;

        case '4':
            soma += 4 * pow(16, (pot - i));
            break;

        case '5':
            soma += 5 * pow(16, (pot - i));
            break;

        case '6':
            soma += 6 * pow(16, (pot - i));
            break;

        case '7':
            soma += 7 * pow(16, (pot - i));
            break;

        case '8':
            soma += 8 * pow(16, (pot - i));
            break;

        case '9':
            soma += 9 * pow(16, (pot - i));
            break;

        case 'a':
            soma += 10 * pow(16, (pot - i));
            break;

        case 'b':
            soma += 11 * pow(16, (pot - i));
            break;

        case 'c':
            soma += 12 * pow(16, (pot - i));
            break;

        case 'd':
            soma += 13 * pow(16, (pot - i));
            break;

        case 'e':
            soma += 14 * pow(16, (pot - i));
            break;

        case 'f':
            soma += 15 * pow(16, (pot - i));
            break;

        }
    }

    printf(""%li\n"", soma);

    return 0;
}",29,939,620
"#define tamanho 32

int main()
{
    int vetor[tamanho];
    int qtd1 = 0, qtd0, i, j;

    printf(""\nInforme os nÃºmeros do vetor:\n"");
    for (i = 0; i < tamanho; i++)
    {
        scanf(""%i"", &vetor[i]);
    }

    for (i = 0; i < tamanho; i++)
    {
        if (vetor[i] != 0)
        {
            vetor[i] = 1;
            qtd1++;
        }
    }

    qtd0 = tamanho - qtd1;

    printf(""\nVetor: "");
    for (j = 0; j < tamanho; j++)
    {
        printf(""%i "", vetor[j]);
    }

    printf(""\nQuantidade de zeros: %i\nQuantidade de uns: %i\n\n"", qtd0, qtd1);
    return 0;
}",29,940,267
"double exponencial(int a, long long int n)
{
    if (n == 0) return 1;

    else if (n == 1) return a;

    else if (n % 2 == 0) return exponencial(a, n/2) * exponencial(a, n/2);

    else return exponencial(a, n-1) * exponencial(a, 1);
}

long long int fatorial(int n)
{
    return (n > 1) ? n * fatorial(n-1) : 1;
}

double super_fatorial(int n)
{
    return (n > 1) ? exponencial(n, fatorial(n-1)) : 1;
}

int main()
{
    int n;

    do
    {
        printf(""\nDigite um inteiro positivo: "");
        scanf(""%i"", &n);
        getchar();
        system(""clear"");

    } while(n <= 0);

    if (n >= 5) printf(""\nFatorial exponencial de %i = %e\n\n"", n, super_fatorial(n));

    else printf(""\nFatorial exponencial de %i = %.0lf\n\n"", n, super_fatorial(n));

    return 0;
}",29,941,331
"#define true 1
#define false 0

int main()
{
    char palavra[50], tema[50], palavra_rev[50], tentativa_acerto_palavra[50], letra, voltar;
    int menu, jogo, tam_palavra, partida, letra_certa, letra_usada;

    jogo = 2;
    while ((jogo != true) && (jogo != false))
    {
        system(""clear"");
        printf(""\tBem vindo ao jogo da forca!\n\n"");
        printf(""\t(1) JOGAR\n"");
        printf(""\t(2) SAIR DO JOGO\n\t "");
        scanf(""%d"", &menu);

        switch (menu)
        {
        case 1:
            jogo = true;
            break;
        case 2:
            jogo = false;
        default:
            break;
        }
    }

    while (jogo == true)
    {
        char letras_erradas[12 + 1] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '\0'}; 

        
        int erros = 0, i_lerradas = 0, vitoria = 0, palavra_certa = true;

        system(""clear"");

        setbuf(stdin, NULL); 
        printf(""\tInforme a palavra ou frase desejada:\n\t"");
        scanf(""%50[^\n]s"", palavra);

        setbuf(stdin, NULL); 
        printf(""\n\tInforme o tema da palavra ou frase:\n\t"");
        scanf(""%50[^\n]s"", tema);
        tam_palavra = strlen(palavra);
        palavra[tam_palavra] = '\0';
        for (int i = 0; palavra[i] != '\0'; i++)
        {
            if (palavra[i] != ' ')
            {
                palavra_rev[i] = '-';
            }
            else
            {
                palavra_rev[i] = ' ';
                vitoria++;
            }
        }
        palavra_rev[tam_palavra] = '\0';

        partida = true;

        while (partida == true)
        {
            system(""clear"");
            printf(""\tLetras erradas: %s\n\n"", letras_erradas);
            printf(""\tTema: %s\n\n"", tema);

            
            switch (erros)
            {
            case 0:
                printf(""\t ------------------\n"");
                printf(""\t/|\\               |\n"");
                printf(""\t |                | \n"");
                printf(""\t |               \n"");
                printf(""\t |               \n"");
                printf(""\t |               \n"");
                printf(""\t |               \n"");
                printf(""\t |                                   %s  \n"", palavra_rev);
                printf(""\t |               \n"");
                printf(""\t |               \n"");
                printf(""\t |               \n"");
                printf(""\t |               \n"");
                printf(""\t |\n"");
                printf(""\t |\n"");
                printf(""\t |\n"");
                printf(""\t/ \\ \n\n\n"");
                break;
            case 1:
                printf(""\t ------------------\n"");
                printf(""\t/|\\               |\n"");
                printf(""\t |                | \n"");
                printf(""\t |               OO\n"");
                printf(""\t |              O  O\n"");
                printf(""\t |               OO\n"");
                printf(""\t |               \n"");
                printf(""\t |                                   %s  \n"", palavra_rev);
                printf(""\t |               \n"");
                printf(""\t |               \n"");
                printf(""\t |               \n"");
                printf(""\t |               \n"");
                printf(""\t |\n"");
                printf(""\t |\n"");
                printf(""\t |\n"");
                printf(""\t/ \\ \n\n\n"");
                break;
            case 2:
                printf(""\t ------------------\n"");
                printf(""\t/|\\               |\n"");
                printf(""\t |                | \n"");
                printf(""\t |               OO\n"");
                printf(""\t |              O  O\n"");
                printf(""\t |               OO\n"");
                printf(""\t |                |\n"");
                printf(""\t |                |                  %s  \n"", palavra_rev);
                printf(""\t |                |\n"");
                printf(""\t |                |\n"");
                printf(""\t |                \n"");
                printf(""\t |                \n"");
                printf(""\t |\n"");
                printf(""\t |\n"");
                printf(""\t |\n"");
                printf(""\t/ \\ \n\n\n"");
                break;
            case 3:
                printf(""\t ------------------\n"");
                printf(""\t/|\\               |\n"");
                printf(""\t |                | \n"");
                printf(""\t |               OO\n"");
                printf(""\t |              O  O\n"");
                printf(""\t |               OO\n"");
                printf(""\t |                |\n"");
                printf(""\t |               /|                  %s  \n"", palavra_rev);
                printf(""\t |              / |\n"");
                printf(""\t |                |\n"");
                printf(""\t |                \n"");
                printf(""\t |                \n"");
                printf(""\t |\n"");
                printf(""\t |\n"");
                printf(""\t |\n"");
                printf(""\t/ \\ \n\n\n"");
                break;
            case 4:
                printf(""\t ------------------\n"");
                printf(""\t/|\\               |\n"");
                printf(""\t |                | \n"");
                printf(""\t |               OO\n"");
                printf(""\t |              O  O\n"");
                printf(""\t |               OO\n"");
                printf(""\t |                |\n"");
                printf(""\t |               /|\\                 %s  \n"", palavra_rev);
                printf(""\t |              / | \\ \n"");
                printf(""\t |                |\n"");
                printf(""\t |                \n"");
                printf(""\t |                \n"");
                printf(""\t |\n"");
                printf(""\t |\n"");
                printf(""\t |\n"");
                printf(""\t/ \\ \n\n\n"");
                break;
            case 5:
                printf(""\t ------------------\n"");
                printf(""\t/|\\               |\n"");
                printf(""\t |                | \n"");
                printf(""\t |               OO\n"");
                printf(""\t |              O  O\n"");
                printf(""\t |               OO\n"");
                printf(""\t |                |\n"");
                printf(""\t |               /|\\                 %s  \n"", palavra_rev);
                printf(""\t |              / | \\ \n"");
                printf(""\t |                |\n"");
                printf(""\t |               /\n"");
                printf(""\t |              / \n"");
                printf(""\t |\n"");
                printf(""\t |\n"");
                printf(""\t |\n"");
                printf(""\t/ \\ \n\n\n"");
                break;
            default:
                break;
            }

            
            setbuf(stdin, NULL); 
            printf(""\t(1) Acertar a palavra/frase (se errar Ã© fim de jogo)\n"");
            printf(""\t(2) Escolher uma letra\n\t"");
            scanf(""%d"", &menu);

            switch (menu)
            {
            
            case 1:

                setbuf(stdin, NULL); 
                printf(""\n\tInforme a palavra/frase:\n\t"");
                scanf(""%50[^\n]s"", tentativa_acerto_palavra);
                palavra_certa = true;
                for (int i = 0; tentativa_acerto_palavra[i] != '\0'; i++)
                {
                    if (tolower(tentativa_acerto_palavra[i]) != tolower(palavra[i]))
                    {
                        palavra_certa = false;
                        erros = 6;
                    }
                }
                if (palavra_certa == true)
                {
                    vitoria = tam_palavra;
                }
                break;

            
            case 2:
                
                setbuf(stdin, NULL); 
                printf(""\n\tEscolha uma letra: \n\t"");
                letra = getchar();

                
                letra_usada = false;
                for (int i = 0; i < tam_palavra; i++)
                {
                    if (tolower(letra) == tolower(palavra_rev[i]))
                    {
                        letra_usada = true;
                    }
                }
                for (int i = 0; i < 12; i++)
                {
                    if (tolower(letra) == tolower(letras_erradas[i]))
                    {
                        letra_usada = true;
                    }
                }
                
                if (letra_usada == true)
                {
                    printf(""Letra ja usada..."");
                }
                
                else
                {
                    letra_certa = false;
                    for (int i = 0; palavra[i] != '\0'; i++)
                    {
                        if (tolower(letra) == tolower(palavra[i]))
                        {
                            palavra_rev[i] = palavra[i];
                            letra_certa = true;
                            vitoria++;
                        }
                    }
                    if (letra_certa == false)
                    {
                        letras_erradas[i_lerradas] = letra;
                        letras_erradas[i_lerradas + 1] = ' ';
                        i_lerradas += 2;
                        erros++;
                    }
                }
            default:
                break;
            }

            
            if (vitoria == tam_palavra)
            {
                system(""clear"");
                printf(""\tLetras erradas: %s\n\n"", letras_erradas);
                printf(""\tTema: %s\n\n"", tema);
                printf(""\t ------------------          PARABÃNS VOCÃ ADVINHOU A PALAVRA OU FRASE\n"");
                printf(""\t/|\\                \n"");
                printf(""\t |                  \n"");
                printf(""\t |               OO\n"");
                printf(""\t |              O**O\n"");
                printf(""\t |               OO\n"");
                printf(""\t |              \\ | /\n"");
                printf(""\t |               \\|/                 %s\n"", palavra);
                printf(""\t |                | \n"");
                printf(""\t |                |\n"");
                printf(""\t |               / \\\n"");
                printf(""\t |              /   \\\n"");
                printf(""\t |\n"");
                printf(""\t |\n"");
                printf(""\t |\n"");
                printf(""\t/ \\ \n\n\n"");
                printf(""Aperte qualque tecla para voltar: "");
                scanf(""%c"", &voltar);
                getchar();
                partida = false;
            }
            
            else if (erros == 6)
            {
                system(""clear"");
                printf(""\tLetras erradas: %s\n\n"", letras_erradas);
                printf(""\tTema: %s\n\n"", tema);
                printf(""\t ------------------        QUE PENA, VOCÃ NÃO ADVINHOU A PALAVRA OU FRASE\n"");
                printf(""\t/|\\               |\n"");
                printf(""\t |                | \n"");
                printf(""\t |               OO\n"");
                printf(""\t |              OxxO\n"");
                printf(""\t |               OO\n"");
                printf(""\t |                |  \n"");
                printf(""\t |               /|\\                %s\n"", palavra);
                printf(""\t |              / | \\\n"");
                printf(""\t |                |\n"");
                printf(""\t |               / \\\n"");
                printf(""\t |              /   \\\n"");
                printf(""\t |\n"");
                printf(""\t |\n"");
                printf(""\t |\n"");
                printf(""\t/ \\ \n\n\n"");
                printf(""Aperte qualque tecla para voltar: "");
                scanf(""%c"", &voltar);
                getchar();
                partida = false;
            }
        }
        jogo = 2;
        while ((jogo != true) && (jogo != false))
        {
            system(""clear"");
            printf(""\tBem vindo ao jogo da forca!\n\n"");
            printf(""\t(1) JOGAR\n"");
            printf(""\t(2) SAIR DO JOGO\n\t "");
            scanf(""%d"", &menu);

            switch (menu)
            {
            case 1:
                jogo = true;
                break;
            case 2:
                jogo = false;
            default:
                break;
            }
        }
    }
}",29,942,3360
"int main()
{
    int n, qtd = 0;
    long int vet[1000], aux, aux2;

    scanf(""%i"", &n);

    for (int i = 0; i < n; i++)
    {
        scanf(""%li"", &vet[i]);
        for (int j = i; j > 0; j--)
        {
            if (vet[j] < vet[j - 1])
            {
                aux = vet[j];
                vet[j] = vet[j - 1];
                vet[j - 1] = aux;
            }
        }
    }

    for (int i = 0; i < n; i++)
    {
        if (i == 0)
        {
            aux2 = vet[i];
            qtd++;
        }

        else if (vet[i] == aux2)
        {
            qtd++;
        }

        else if (vet[i] != aux2)
        {
            printf(""%li %i\n"", vet[i - 1], qtd);
            qtd = 0;
            aux2 = vet[i];
            qtd++;
        }

        if (i == (n - 1))
        {
            printf(""%li %i\n"", vet[i], qtd);
        }
    }
    

    return 0;
}",29,943,353
"#define tamanho 10

int main(void)
{
    int vetor[tamanho], aux, i = 0, k = 0, maior, menor, indice_maior[tamanho], indice_menor[tamanho];
    printf(""\nInforme os nÃºmeros do vetor:\n"");
    for (int a = 0; a < tamanho; a++)
    {
        scanf(""%i"", &vetor[a]);
        if (a == 0)
        {
            maior = vetor[a];
            indice_maior[i] = a;
            menor = vetor[a];
            indice_menor[k] = a;
        }
        else
        {
            if (vetor[a] > maior)
            {
                maior = vetor[a];
                for (int j = 0; j < tamanho; j++)
                {
                    indice_maior[j] = 0;
                }
                i = 0;
                indice_maior[i] = a;
            }
            else if (vetor[a] == maior)
            {
                i++;
                indice_maior[i] = a;
            }
            else if (vetor[a] < menor)
            {
                menor = vetor[a];
                for (int l = 0; l < tamanho; l++)
                {
                    indice_menor[l] = 0;
                }
                k = 0;
                indice_menor[k] = a;
            }
            else if (vetor[a] == menor)
            {
                k++;
                indice_menor[k] = a;
            }
        }
    }

    if (k != 0)
    {
        printf(""\nMenor = indices "");
        for (int c = 0; c <= k; c++)
        {
            if (c == k)
            {
                printf(""%i. "", indice_menor[c]);
            }
            else
            {
                printf(""%i, "", indice_menor[c]);
            }
        }
        printf(""com valor %i"", menor);
    }
    else if (k == 0)
    {
        printf(""\nMenor = indice %i com valor %i"", indice_menor[k], menor);
    }

    if (i != 0)
    {
        printf(""\nMaior = indices "");
        for (int b = 0; b <= i; b++)
        {
            if (b == i)
            {
                printf(""%i. "", indice_maior[b]);
            }
            else
            {
                printf(""%i, "", indice_maior[b]);
            }
        }
        printf(""com valor %i"", maior);
    }
    else if (i == 0)
    {
        printf(""\nMaior = indice %i com valor %i"", indice_maior[i], maior);
    }

    printf(""\n\n"");
    return 0;
}",29,944,766
"#define true 1
#define false 0

int sistema(int a, int b, int c)
{
    int x, y, z;
    for (y = (-c); y <= c; y++)
    {
        for (z = (y+1); z <= c; z++)
        {
            x = a - y - z;
            if (((y * z * x) == b) && (((x * x) + (y * y) + (z * z)) == c) && (z != x) && (y != x))
            {
                printf(""%i %i %i\n"", y, z, x);
                return 0;
            }
        }
    }
    printf(""Sem solucao\n"");
    
    return 0;
}

int main()
{
    int n, av[10000], bv[10000], cv[10000], xv[100000], yv[100000], zv[100000], a, b, c, x, y, z, k = 0, solucao, solucao2, aux;

    scanf(""%i"", &n);

    for (int i = 0; i < n; i++)
    {
        scanf(""%i"", &av[i]);
        scanf(""%i"", &bv[i]);
        scanf(""%i"", &cv[i]);
    }

    for (int i = 0; i < n; i++)
    {
        sistema (av[i], bv[i], cv[i]);
    }
    return 0;
}",29,945,402
"int main()
{
    int n;
    float nota, notafinal = 0, denominador = 0, fator, notamedia;

    printf(""\nInforme a quantidade de notas do aluno: "");
    scanf(""%i"", &n);

    for (int qtd = 1; qtd <= n; qtd++)
    {
        printf(""\nInforme a %iÂª nota: "", qtd);
        scanf(""%f"", &nota);

        if ((qtd % 2) == 0)
        {
            fator = 3;
            nota = fator * nota;
        }

        else
        {
            fator = 2;
            nota = fator * nota;
        }

        notafinal = notafinal + nota;
        denominador = denominador + fator;
    }

    notamedia = notafinal / denominador;
    printf(""\nNota mÃ©dia = %.2f\n\n"", notamedia);

    return 0;
}",29,946,264
"#define true 1
#define false 0

int main ()
{
    long int num, primo = true, i = 3;
    scanf (""%li"", &num);

    if (num == 1)
    {
        printf (""Composto!\n"");
    }

    else if (num == 2)
    {
        printf (""Primo!\n"");
    }

    else if ((num % 2) == 0)
    {
        printf (""Composto!\n"");
    }

    else
    { 
        while (((i*i) <= num)&&(primo == true))
        {
            if ((num % i) == 0)
            {
                primo = false;
            }
            i += 2;
        }

        if (primo == true)
        {
            printf (""Primo!\n"");
        }
        else
        {
            printf (""Composto!\n"");
        }
    }

    return 0;
}",29,947,247
"#define mlinhas 9
#define ncolunas 9

int main()
{
    int linha = 1, coluna = 1;
    char a = 'a';
    printf(""\n"");

    for (int m = 0; m < mlinhas; m++)
    {
        for (int n = 0; n < ncolunas; n++)
        {
            if (coluna == 1)
            {
                printf(""| "");
            }
            printf(""%c%i%i  "", a, linha, coluna);
            if (coluna == ncolunas)
            {
                printf(""|"");
            }
            coluna++;
        }
        printf(""\n"");
        linha++, coluna = 1;
    }
    printf(""\n"");
}
",29,948,195
"int main()
{
    system(""clear"");

    int n;
    float saldo = 1000, x, y;

    printf(""########################\n"");
    printf(""# 1 - Saque            #\n"");
    printf(""# 2 - DepÃ³sito         #\n"");
    printf(""# 3 - Sair do programa #\n"");
    printf(""########################\n"");
    printf(""Saldo: R$%.2f\n"", saldo);
    printf(""FaÃ§a sua escolha: "");

    scanf(""%i"", &n);

    system(""clear"");

    while (n != 3)
    {
        system(""clear"");

        switch (n)
        {
        case 1:
            printf(""SAQUE:\n"");
            printf(""\nDigite quantos reais deseja sacar: "");
            scanf(""%f"", &x);

            saldo = saldo - x;

            break;

        case 2:
            system(""clear"");

            printf(""DEPÃSITO:\n"");
            printf(""\nDigite quantos reais deseja depositar: "");
            scanf(""%f"", &y);

            saldo = saldo + y;

            break;
        }

        system(""clear"");

        printf(""########################\n"");
        printf(""# 1 - Saque            #\n"");
        printf(""# 2 - DepÃ³sito         #\n"");
        printf(""# 3 - Sair do programa #\n"");
        printf(""########################\n"");
        printf(""Saldo: R$%.2f\n"", saldo);
        printf(""FaÃ§a sua escolha: "");

        scanf(""%i"", &n);
    }

    printf(""\n"");
    return 0;
}",29,949,442
"#define true 1
#define false 0

int popstar(int N[][1000], int j, int n)
{
    for (int i = 0; i < n; i++)
    {
        if (N[i][j] != 1) return false;
    }

    return true;
}

int main()
{
    int N[1000][1000], n, maybe[1000], busca, busca_p, k = 0;

    scanf(""%i"", &n);

    for (int i = 0; i < n; i++)
    {
        busca = true;

        for (int j = 0; j < n; j++)
        {
            scanf(""%i"", &N[i][j]);
            
            if ((j != i) && (N[i][j] != 0)) busca = false;
            else if ((j == i) && (N[i][j] != 1)) busca = false;
            
        }

        if (busca == true)
        {
            maybe[k] = i;
            k++;
        }
    }

    if (k == 0)
    {
        printf(""Nao ha popstar.\n"");
        return 0;
    }

    for (int i = 0; i < k; i++)
    {
        busca_p = popstar(N, maybe[i], n);

        if (busca_p == true) printf(""Popstar: aluno #%i\n"", maybe[i] + 1);
    }

    return 0;
}",29,950,404
"#define tamanho 10

int main(void)
{
    float vetor[tamanho], aux;
    int j = tamanho - 1;

    printf(""Informe os nÃºmeros do vetor:\n"");
    for (int i = 0; i < tamanho; i++)
    {
        scanf(""%f"", &vetor[i]);
    }

    for (int i = 0; i < (tamanho / 2); i++)
    {
        aux = vetor[i];
        vetor[i] = vetor[j];
        vetor[j] = aux;
        j--;
    }

    printf(""\nVetor: "");
    for (int i = 0; i < tamanho; i++)
    {
        printf(""%.2f "", vetor[i]);
    }

    printf(""\n\n"");
    return 0;
}",29,951,236
"long int fib[47];

void fibonacci(int maior)
{
    fib[0] = 1;
    fib[1] = 1;
    
    for (int a = 2; a <= maior; a++)
    {
        fib[a] = fib[a - 1] + fib[a - 2];
    }
}

long int supersigma(int i, int j)
{
    long int soma = 0;

    for (int a = i; a <= j; a++)
    {
        soma += fib[a];
    }

    return soma;
}

int main()
{
    int n, iv[100000], jv[100000], maior = 0;

    scanf(""%i"", &n);

    for (int a = 0; a < n; a++)
    {
        scanf(""%i"", &iv[a]);
        scanf(""%i"", &jv[a]);

        if (jv[a] > maior)
            maior = jv[a];
    }

    fibonacci(maior);

    for (int a=0; a<n; a++)
    {
        printf(""%li\n"", supersigma(iv[a], jv[a]));
    }

    return 0;
}",29,952,333
"int main()
{
    int a;
    int b;
    int c;
    int d = 0;
    int cont = 0;

    printf(""digite o tamanho da sequencia: "");
    scanf(""%d"",&a);


    for(b = 0;b < a; b++)
    {
        printf(""digite um numero: "");
        scanf(""%d"",&c);

        if(c < d)
        {
            cont++;

            d = 0 + c;

        }

    }

        if(cont <= 0)
        {
            printf(""esta ordenado."");

        }else
        {
            printf(""nao esta ordenada."");
        }

}
",30,953,182
"int main()

{

    float maior_tam_aluno = 0;
    int num_maior_aluno = 0;

    float menor_tam_aluno = 100000;
    int num_menor_aluno = 0;

    int num_aluno[3];
    float altura_aluno[3];
    int i;
    int j = 0;

    for(i = 0; i <3; i++){



            printf(""Digite o numero do aluno %d: "",i);
            scanf(""%d"",&num_aluno[i]);

            printf(""Digite a altura do aluno %d: "",j);
            scanf(""%f"",&altura_aluno[i]);



        }
            for(j = 0; j <3; j++){

            if(altura_aluno[j] > maior_tam_aluno){

                maior_tam_aluno = altura_aluno[j];
                num_maior_aluno = num_aluno[j];
            }

            if(altura_aluno[j] < menor_tam_aluno){
                menor_tam_aluno = altura_aluno[j];
                num_menor_aluno = num_aluno[j];
            }



    }

    printf(""\n O maior aluno eh: %d %.2f \n"",num_maior_aluno, maior_tam_aluno);
    printf(""\n O menor aluno eh: %d %.2f \n"",num_menor_aluno, menor_tam_aluno);



    system(""PAUSE"");
    return 0;
}
",30,954,430
"int main()
{
    int c; 
    int l; 
    int a;
    int b = 1;

    printf(""Digite um numero: "");
    scanf(""%d"",&a);

  for (l=0; l<a; l++)
    {
        for (c=0; c<a;c++)
        {
           if (l == c )
           {

               printf(""%d "",b);
               b++;
           }else
            {
                printf(""  "");
            }

        }
        printf(""\n"");
    }
        printf(""\n\n\n"");








}
",30,955,160
"int vet1[10];
int vet2[10];
int intersecao[10];

void criarVetorIntersecao() {

    for (int i = 0; i < 10; i++) {

        for (int j = 0; j < 10; j++) {

            if (vet1[i] == vet2[j]) {
                intersecao[i] = vet1[i];
            }
        }
    }
}

int verificarValorRepetido(int vet1[10], int valorComparar) {

    for (int i = 0; i < 10; i++) {

        if (vet1[i] == valorComparar) {
            return valorComparar;
        }

    }

    return 0;
}

void imprimirVetorIntersecao() {

    for (int i = 0; i < 10; i++) {

        if (intersecao[i] > 0) {

            printf(""%d\n"", intersecao[i]);
        }
    }
}

int main() {
    setlocale(LC_ALL, """");

    for (int i = 0; i < 10; i++) {

        int valorAlocar = 0;

        printf(""Preencha o valor do vetor1 numero %d\n"", i);
        scanf(""%d"", &valorAlocar);

        int retorno = verificarValorRepetido(vet1, valorAlocar);

        if (retorno != 0) {

            printf(""O valor %d nao pode ser inserido pois esta repetido, por favor informe outro numero.\n"", retorno);
            i--;
            continue;
        } else {

            vet1[i] = valorAlocar;
        }
    }

    for (int i = 0; i < 10; i++) {

        int valorAlocar = 0;

        printf(""Preencha o valor do vetor2 numero %d\n"", i);
        scanf(""%d"", &valorAlocar);

        int retorno = verificarValorRepetido(vet2, valorAlocar);

        if (retorno != 0) {

            printf(""O valor %d nao pode ser inserido pois esta repetido, por favor informe outro numero.\n"", retorno);
            i--;
            continue;
        } else {

            vet2[i] = valorAlocar;
        }
    }

    system(""cls"");

    printf(""\n ------------------------------ \n"");

    criarVetorIntersecao();
    imprimirVetorIntersecao();

    return 0;
}

",30,956,712
"int quantidadeTotalPar = 0;
int quantidadeTotalImpar = 0;
int pares[6];
int impares[6];

void calcularTotal(int numero[6]) {

    for (int i = 0; i < 6; i++) {

        if (numero[i] % 2 == 0) {

            quantidadeTotalPar = quantidadeTotalPar + numero[i];
            pares[i] = numero[i];

        } else {

            quantidadeTotalImpar = quantidadeTotalImpar + numero[i];
            impares[i] = numero[i];

        }
    }
}

void imprimirResultados() {

    printf(""Soma total numeros pares digitados: %d\n\n"", quantidadeTotalPar);
    printf(""Valores pares digitados: \n"");

    for (int i = 0; i < 6; i++) {

        if (pares[i] > 0) {

            printf(""%d\n"", pares[i]);
        }
    }

    printf(""Soma total numeros impares digitados: %d\n\n"", quantidadeTotalImpar);
    printf(""Valores impares digitados: \n"");

    for (int i = 0; i < 6; i++) {

        if (impares[i] > 0) {

            printf(""%d\n"", impares[i]);
        }
    }

}

int main() {
    setlocale(LC_ALL, """");
    int numero[6];

    for (int i = 0; i < 6; i++) {

        printf(""Preencha o valor numero %d\n"", i);
        scanf(""%d"", &numero[i]);
    }

    system(""cls"");

    calcularTotal(numero);
    imprimirResultados();

    return 0;
}
",30,957,481
"int main()

{

    int i,j,z;
    int conjunto1[5];
    int conjunto2[5];


    for(i = 0; i < 5; i++){

        printf(""Digite um valor para a: "", i);
        scanf(""%d"",&conjunto1[i]);

    }

        printf(""\n \n"");

    for(j = 0; j < 5; j++){

        printf(""Digite um valor para b: "", j);
        scanf(""%d"",&conjunto2[j]);

    }



        int produto = 0;

       for (int i = 0; i < 5; i++){

       produto = produto + conjunto1[i] * conjunto2[i];


        }

        printf("" \n produto escalar dos dois conjuntos eh: %d \n"", produto);

    system(""PAUSE"");
    return 0;
}
",30,958,244
"int main()
{
    int m;
    int n;

    printf(""digite o primeiro numero: "");
    scanf(""%d"",&m);

    printf(""digite o segundo numero: "");
    scanf(""%d"",&n);

while ( m!=n)

{

if (m > n){

    m = m - n;

}else

    n = n - m;

}
    printf(""o maximo divisor comum eh:%d"", m);
}




",30,959,128
"int main()
{
    int vetor[6];

    for(int i=0; i<6; i++){

        printf(""digite os valores do vetor: \n"");
        scanf(""%d"",&vetor[i]);

    }
       printf(""\nRESULTADO\n"");
        for(int i=5; i>=0; i--){

        printf(""%d "",vetor[i]);



        }






    return 0;
}
",30,960,126
"int main()
{
    int a;
    int b;
    int c = 2;
    int d;

    printf(""Digite um numero: "");
    scanf(""%d"",&a);

    for(b = 0; b <= a; b++)
    {
        if(a>=0)
        {
            d = a / c;
            c++;
        }if(a % c == 0)
        {
            printf(""%d / %d = %d\n"",a,c,d);
        }

    }




}
",30,961,140
"int main()
{
    int d1,d2,d3,d4,d5,d6;
    unsigned long int contadora = 0;

    for (d1 = 1; d1<=60;d1++)

        if(d1 %2 != 1)

    for (d2 = d1+1; d2<=60;d2++)

        if(d2 %2 != 0)

    for (d3 = d2+1; d3<=60;d3++)

        if(d3 %2 != 1)

    for (d4 = d3+1; d4<=60;d4++)

        if(d4 % 2 != 0)

    for (d5 = d4+1; d5<=60;d5++)

        if(d5 % 2 !=1)

    for (d6 = d5+1; d6<=60;d6++)

        if(d6 % 2 != 0)


    printf(""[%d] [%d] [%d] [%d] [%d] [%d] \n"",d1,d2,d3,d4,d5,d6);
    contadora++;


    printf(""%u"",contadora);






}
",30,962,323
"int vetor[11];
int posicaoReporNumero;

void ordenarVetorCrescente() {

    for (int i = 0; i <= 5; i++) {

        int menorValorPosicao = buscarMenorValor(i);

        int valorPosicaoAnterior = vetor[i];
        vetor[i] = menorValorPosicao;
        vetor[posicaoReporNumero] = valorPosicaoAnterior;
    }
}

void ordenarVetorDecrescente() {

    for (int i = 6; i <= 11; i++) {

        int maiorValorPosicao = buscarMaiorValor(i);

        int valorPosicaoAnterior = vetor[i];
        vetor[i] = maiorValorPosicao;
        vetor[posicaoReporNumero] = valorPosicaoAnterior;
    }
}

int buscarMenorValor(int j) {

    int valorAAssumirPosicao = vetor[j];
    posicaoReporNumero = NULL;

    for (int i = j; i < 11; i++) {

        if (valorAAssumirPosicao > vetor[i]) {

            valorAAssumirPosicao = vetor[i];
            posicaoReporNumero = i;
        }
    }

    return valorAAssumirPosicao;
}

int buscarMaiorValor(int j) {

    int valorAAssumirPosicao = vetor[j];
    posicaoReporNumero = NULL;

    for (int i = j; i < 11; i++) {

        if (valorAAssumirPosicao < vetor[i]) {

            valorAAssumirPosicao = vetor[i];
            posicaoReporNumero = i;
        }
    }

    return valorAAssumirPosicao;
}

void imprimirVetor() {

    for (int i = 0; i < 11; i++) {

        printf(""Posicao %d valor do vetor: %d\n"", i, vetor[i]);
    }
}

int main()
{
    for (int i = 0; i < 11; i++){
        printf(""Preencha o valor do vetor numero %d\n"", i);
        scanf(""%d"", &vetor[i]);
    }

    ordenarVetorCrescente();
    ordenarVetorDecrescente();
    imprimirVetor();

    return 0;
}

",30,963,687
"int fatorial(int x);
int comb(int lin, int col);

int main()
{
    int lin, col, n, num;

    printf(""Digite a quantidade de linhas: "");
    scanf(""%d"", &n);
    printf(""\n"");

    for(lin=0;lin<=n;lin++){
        for(col=n-lin;col!=0;col--){
            printf(""   "");
        }
        for(col=0;col<=lin;col++){
            num = comb(lin, col);
            printf("" %4d "", num);
        }
        printf(""\n"");
    }
    return 0;
}

int fatorial(int x){
  int i, fatorial=1;

  for(i=x;i>0;i--){
    fatorial = fatorial*i;
  }
  return fatorial;
}

int comb(int lin, int col){

 return fatorial(lin) / (fatorial(col) * fatorial(lin-col));
}
",30,964,254
"int vetor[15];

void compactarVetor() {
    for (int i = 0; i < 15; i++) {

        if (vetor[i] == 0) {

            for (int j = i; j < 15; j++) {

                vetor[j] = vetor[j + 1];
            }
        }
    }
}

void imprimirVetor() {

    for (int i = 0; i < 15; i++) {

        if (vetor[i] != 0) {
            printf(""Posicao %d valor do vetor: %d\n"", i, vetor[i]);
        }
    }
}

int main() {
    setlocale(LC_ALL, """");

    for (int i = 0; i < 15; i++) {

        printf(""Preencha o valor do vetor1 numero %d\n"", i);
        scanf(""%d"", &vetor[i]);
    }

    system(""cls"");

    compactarVetor();
    imprimirVetor();

    return 0;
}




",30,965,298
"int main()
{

int c; 
int l; 
int a;
int b;

    printf(""Digite um numero: "");
    scanf(""%d"",&a);

    for (l=1; l<a; l++)
    {
        for (c=1; c<=a; c++)
        {
            if(c<=l){

                    b = c;
                printf(""%d "",b);

            }
        }

        printf(""\n"");
    }
        printf(""\n\n\n"");





}
",30,966,139
"int main()

{
    int i,j,z;
    int a[3];
    int b[3];
    int c[3];



    for(i = 0; i < 3; i++){

        printf(""Digite um valor para a: "", i);
        scanf(""%d"",&a[i]);

    }

        printf(""\n \n"");

    for(j = 0; j < 3; j++){

        printf(""Digite um valor para b: "", j);
        scanf(""%d"",&b[j]);

    }


    for(i = 0; i < 3; i++){
    printf(""\n vetor a:  %d \n "", a[i]);
    }

    for(j = 0; j < 3; j++){
    printf(""\n vetor b: %d \n "", b[j]);
    }


    for(z = 0; z < 3; z++){

        if( z %2 ==0){

            c[z] = a[z];
        }

        else if( z %2 != 0){
            c[z] = b[z];

        }

        printf(""\n vetor c: %d \n"",c[z]);
    }




    system(""PAUSE"");
    return 0;
}
",30,967,338
"int main()

{
        int i,j,z;
    int a[5];
    int b[5];
    int c[5];



    for(i = 0; i < 5; i++){

        printf(""Digite um valor para a: "", i);
        scanf(""%d"",&a[i]);

    }

        printf(""\n \n"");




    for(z = 0; z < 5; z++){

        if( z %2 ==0){

            c[z] = a[z];
        printf(""\n vetor c(impar): %d \n"",c[z]);
        }

         if( z %2 != 0){
            b[z] = a[z];

        printf(""\n vetor b (par): %d \n"",b[z]);
        }

    }




    system(""PAUSE"");
    return 0;
}
",30,968,235
"int main() {

    int primo;
    int a;
    int b;
    int c;


    printf(""Digite um numero: "");
    scanf(""%d"", &a);



    for (b=a; ; b++) {


        primo = 1;
        for (c=2; c<b; c++) {

            if (b % c == 0)
                primo = 0;
}

                if (primo == 1) {
            printf(""\n\nO numero a direita primo mais proximo: %d\n"", b);
            break;
        }
    }




    for (b=a;b > 0; b--) {


        primo = 1;
        for (c=2; c<b; c++) {

            if (b % c == 0)
                primo = 0;
}

                if (primo == 1) {
            printf(""O numero a esquerda primo mais proximo: %d\n"", b);
            break;
        }
    }


}
",30,969,268
"int main()
{
    float a[10],b[10];
    int i;

    for(i=0; i<10; i++)
    {
        printf("" digite o %d valor: "",i);
        scanf(""%f"",&a[i]);
    }
    for(i=0; i<10; i++)
        b[i] = a[i] * a[i];
    printf(""\n\nConjunto 1: \n"");

    for(i=0; i<10; i++)
    printf(""\n%2.f "",a[i]);
    printf(""\n\nConjunto 2: \n"");

    for(i=0; i<10; i++)

        printf("" \n%2.f "",b[i]);




return 0;
}
",30,970,208
"float calculaDesvioPadrao(float vet[]);

int main()
{
        int i;

        float vet[10];


        for (i = 0; i < 10; ++i){

            printf(""Digite um numero: "");
            scanf(""%f"", &vet[i]);
        }
            printf(""\n Desvio Padrao = %.6f"", calculaDesvioPadrao(vet));

            system(""PAUSE"");
            return 0;
}

    float calculaDesvioPadrao(float vet[]) {

        float soma = 0.0, mean, desvio = 0.0;
        int i;

        for (i = 0; i < 10; i++) {
            soma += vet[i];
        }

        mean = soma / 10;
        for (i = 0; i < 10; i++)
            desvio += pow(vet[i] - mean, 2);
        return sqrt(desvio / 10);
}
",30,971,268
"int main()
{
    int c; 
    int l; 


for (l=1; l<6; l++)
    {
        for (c=1; c<6; c++)
        {
            if(c<l){
                printf(""# "");

            }else if (c == l)
                {
                    printf(""+ "");

                }else if(c > 1)
                {
                    printf(""# "");
                }

        }



        printf(""\n"");
    }
        printf(""\n\n\n"");




}
",30,972,143
"int main()
{
    int a[10];
    int b[10];
    int c[10];

    int i;
                printf(""--------------------------------------\n"");
                printf(""digite um numero para o primeiro vetor\n"");
                printf(""--------------------------------------\n\n"");

    for(i=0;i<10;i++) 
    {
        printf(""digite um numero: "");
        scanf(""%d"",&a[i]);
    }

                printf(""--------------------------------------\n"");
                printf(""digite um numero para o segundo vetor\n"");
                printf(""--------------------------------------\n\n"");

    for(i=0;i<10;i++) 
    {
        printf(""digite um numero: "");
        scanf(""%d"",&b[i]);
    }

                printf(""\n------------------------------------------\n"");
    for(i=0;i<10;i++) 
    {
        c[i] = a[i] - b[i];
        printf(""[%d] - [%d] = [%d]\n"",a[i],b[i],c[i]);
    }
                printf(""\n------------------------------------------\n"");






}
",30,973,306
"int main()
{
    int a;
    int b;

    printf(""Escolha um prato:\n\n"");
    printf(""---------------------------\n"");
    printf(""1 - Lazanha\n"");
    printf(""2 - Macarronada\n"");
    printf(""3 - Strogonff\n"");
    printf(""4 - Churrasco\n"");
    printf(""5 - Sair\n"");
    printf(""---------------------------\n\n"");

    printf(""Digite o prato: "");
    scanf(""%d"",&a);

    while(a<=4)
    {
        printf(""Escolha um prato:\n\n"");
    printf(""---------------------------\n"");
    printf(""1 - Lazanha\n"");
    printf(""2 - Macarronada\n"");
    printf(""3 - Strogonff\n"");
    printf(""4 - Churrasco\n"");
    printf(""5 - Sair\n"");
    printf(""---------------------------\n\n"");

    printf(""Digite o prato: "");
    scanf(""%d"",&a);
    }
}
",30,974,270
"int main()

{

    int vetor[50];
    int i;


    for(i= 0; i < 50; i++){

        if(i %7 != 0 && i % 10 != 7 ){
            printf(""\n %d \n"", i);

        }


        else{
            continue;
        }
    }



    system(""PAUSE"");
    return 0;
}
",30,975,113
"int vet1[10];
int vet2[10];
int uniao[20];

void populaVetorUniao() {

    for (int c = 0; c < 10; c++) {
        uniao[c] = vet1[c];
    }

    for (int i = 0; i <= 10; i++) {
        int valorJaInseridoUniao = 0;

        for (int j = 0; j < 10; j++) {

            if (vet2[i] == uniao[j]) {
                valorJaInseridoUniao = 1;
            }
        }

        if (valorJaInseridoUniao == 0) {
            uniao[i + 10] = vet2[i];
        }
    }
}

int verificarValorRepetido(int valorComparar) {

    for (int i = 0; i < 10; i++) {

        if (vet1[i] == valorComparar) {
            return valorComparar;
        }

        if (vet2[i] == valorComparar) {
            return valorComparar;
        }

    }

    return 0;
}

void imprimirVetores() {

    for (int i = 0; i < 20; i++) {

        printf(""%d\n"", uniao[i]);
    }
}

int main() {
    setlocale(LC_ALL, """");

    for (int i = 0; i < 10; i++) {

        int valorAlocar = 0;

        printf(""Preencha o valor do vetor1 numero %d\n"", i);
        scanf(""%d"", &valorAlocar);

        int retorno = verificarValorRepetido(valorAlocar);

        if (retorno != 0) {

            printf(""O valor %d nao pode ser inserido pois esta repetido, por favor informe outro numero."", retorno);
            i--;
            continue;
        } else {

            vet1[i] = valorAlocar;
        }
    }

    for (int i = 0; i < 10; i++) {

        int valorAlocar = 0;

        printf(""Preencha o valor do vetor2 numero %d\n"", i);
        scanf(""%d"", &valorAlocar);

        int retorno = verificarValorRepetido(valorAlocar);

        if (retorno != 0) {

            printf(""O valor %d nao pode ser inserido pois esta repetido, por favor informe outro numero.\n"", retorno);
            i--;
            continue;
        } else {

            vet2[i] = valorAlocar;
        }
    }

    system(""cls"");

    printf(""\n ------------------------------ \n"");

    populaVetorUniao();

    printf(""--- Uniao entre vetores ---\n"");

    imprimirVetores(uniao, 10);

    printf(""--------------------------------\n"");

    return 0;
}


",30,976,812
"#include ""util.h""
#include ""parser-util.h""
#include ""parser-expressions.h""

    const char* keywordsarr[] = { ""true"", ""false"", ""null"", ""this"" };
    const char* opsarr[] = { ""+"", ""-"", ""*"", ""/"", ""&"", ""|"", ""<"", "">"", ""="" };
    mkstrlist(keywordconstants, keywordsarr);
mkstrlist(operators, opsarr);




bool isop(TOKEN* t);


TERM* parsetermnullified(PARSER* p);
TERM* parseterm(PARSER* p);
TERM* mkterm(TERMTYPE type);
TERM* parseint(PARSER* p);
TERM* parsestr(PARSER* p);
TERM* parsekeyword(PARSER* p);
TERM* parseunaryopterm(PARSER* p);
TERM* parseinnerexpression(PARSER* p);
TERM* parsecalltermnullified(PARSER* p);
TERM* parsearrayterm(PARSER* p);
TERM* parsevarterm(PARSER* p);
TERM* parseidentifierterm(PARSER* p);
SUBROUTCALL* nullsubroutcall(PARSER* p, SUBROUTCALL* c);
SUBROUTCALL* parsesubroutcallnullified(PARSER* p);




bool isop(TOKEN* t) {
    for(int i = 0; i < operators.size; i++)
        if(!strcmp(t->token, operators.items[i]))
            return true;
    return false;
}


TERM* parsetermnullified(PARSER* p) {
    TOKENTYPE type = p->current->type;
    if(type == integer) return parseint(p);
    if(type == string) return parsestr(p);
    if(type == keyword) return parsekeyword(p);
    if(type == identifier) return parseidentifierterm(p);
    if(equals(p, ""-"") || equals(p, ""~"")) return parseunaryopterm(p);
    if(equals(p, ""("")) return parseinnerexpression(p);
    return NULL;
}

TERM* parseterm(PARSER* p) {
    TERM* t = parsetermnullified(p);
    if(t == NULL)
        unexpected(p);
    return t;
}

TERM* mkterm(TERMTYPE type) {
    TERM* t = (TERM*)malloc(sizeof(TERM));
    t->type = type;
    return t;
}

TERM* parseint(PARSER* p) {
    TERM* t = mkterm(intconstant);
    t->integer = atoi(p->current->token);
    next(p);
    return t;
}

TERM* parsestr(PARSER* p) {
    TERM* t = mkterm(stringconstant);
    t->string = p->current->token;
    next(p);
    return t;
}

TERM* parsekeyword(PARSER* p) {
    TERM* t = mkterm(keywordconstant);
    if(!existsinarray(&keywordconstants, p->current->token))
        unexpected(p);
    t->string = p->current->token;
    next(p);
    return t;
}

TERM* parseunaryopterm(PARSER* p) {
    TERM* t = mkterm(unaryopterm);
    t->unaryop = p->current->token[0];
    next(p);
    t->expression = parseterm(p);
    t->expression->next = NULL;
    return t;
}

TERM* parseinnerexpression(PARSER* p) {
    TERM* t = mkterm(innerexpression);
    next(p);
    t->expression = parseexpression(p);
    checkcontent(p, "")"");
    return t;
}

TERM* parsecalltermnullified(PARSER* p) {
    SUBROUTCALL* call = parsesubroutcallnullified(p);
    if(call == NULL)
        return NULL;
    TERM* t = mkterm(subroutcall);
    t->call = call;
    return t;
}

TERM* parsearrayterm(PARSER* p) {
    TERM* t = mkterm(arrayitem);
    t->array = (ARRAY*)malloc(sizeof(ARRAY));
    t->array->name = p->current->token;
    next(p);
    checkcontent(p, ""["");
    t->array->exp = parseexpression(p);
    checkcontent(p, ""]"");
    return t;
}

TERM* parsevarterm(PARSER* p) {
    TERM* t = mkterm(varname);
    t->string = p->current->token;
    next(p);
    return t;
}

TERM* parseidentifierterm(PARSER* p) {
    TERM* t = parsecalltermnullified(p);
    if(t == NULL)
        if(nextequals(p, ""[""))
            return parsearrayterm(p);
        else
            return parsevarterm(p);
    else
        return t;
}

TERM* parseexpressionnullified(PARSER* p) {
    TERM* head = parsetermnullified(p);
    TERM* current = head;
    TERM* nextt;
    while(isop(p->current)) {
        current->op = p->current->token[0]; 
        next(p);
        nextt = parseterm(p);
        current->next = nextt;
        current = nextt;
    }
    if(current != NULL)
        current->next = NULL;
    return head;
}

TERM* parseexpression(PARSER* p) {
    TERM* t = parseexpressionnullified(p);
    if(t == NULL)
        unexpected(p);
    return t;
}

SUBROUTCALL* nullsubroutcall(PARSER* p, SUBROUTCALL* c) {
    free(c->debug);
    free(c);
    rewindparser(p);
    return NULL;
}

SUBROUTCALL* parsesubroutcallnullified(PARSER* p) {
    if(p->current->type != identifier)
        return NULL;

    anchorparser(p);
    SUBROUTCALL* c = (SUBROUTCALL*)malloc(sizeof(SUBROUTCALL));

    c->debug = getdebug(p);

    if(nextequals(p, ""."")) {
        c->parentname = p->current->token;
        next(p);
        next(p);
    }
    else
        c->parentname = NULL;

    if(p->current->type != identifier)
        return nullsubroutcall(p, c);
    c->name = p->current->token;
    next(p);

    if(differs(p, ""(""))
        return nullsubroutcall(p, c);
    next(p);

    c->parameters = parseexpressionlist(p);

    if(differs(p, "")""))
        return nullsubroutcall(p, c);
    next(p);
    return c;
}

SUBROUTCALL* parsesubroutcall(PARSER* p) {
    SUBROUTCALL* c = (SUBROUTCALL*)malloc(sizeof(SUBROUTCALL));
    c->debug = getdebug(p);

    if(nextequals(p, ""."")) {
        c->parentname = parseidentifier(p);
        next(p);
    }
    else
        c->parentname = NULL;

    c->name = parseidentifier(p);

    checkcontent(p, ""("");

    c->parameters = parseexpressionlist(p);

    checkcontent(p, "")"");
    return c;
}

EXPRESSIONLIST* parseexpressionlist(PARSER* p) {
    if(!strcmp(p->current->token, "")""))
        return NULL;
    EXPRESSIONLIST* head = (EXPRESSIONLIST*)malloc(sizeof(EXPRESSIONLIST));
    head->expression = parseexpressionnullified(p);
    EXPRESSIONLIST* current = head;
    EXPRESSIONLIST* nextls;
    while(!strcmp(p->current->token, "","")) {
        next(p);
        nextls = (EXPRESSIONLIST*)malloc(sizeof(EXPRESSIONLIST));
        nextls->expression = parseexpression(p);
        current->next = nextls;
        current = nextls;
    }
    if(current != NULL)
        current->next = NULL;
    return head;
}
",31,977,2155
"#include ""threads.h""
#include ""parser.h""
#include ""compiler.h""
#include ""io.h""
#include ""os.h""

int main(int argc, char* argv[]) {
    if(argc < 2) {
        eprintf(""Usage: %s {input file(s)}\n"", argv[0]);
        return 1;
    }

    FILELIST* files = getfiles(argv[1]);
    FILELIST* curr = files->next;

    COMPILEUNIT* head = (COMPILEUNIT*)malloc(sizeof(COMPILEUNIT));

    head->file = files;
    head->parser = mkparser(tokenize(files->fullname), files->name);

    COMPILEUNIT* currunit = head;
    while(curr != NULL) {
        COMPILEUNIT* newunit = (COMPILEUNIT*)malloc(sizeof(COMPILEUNIT));
        newunit->file = curr;
        newunit->parser = mkparser(tokenize(curr->fullname), curr->name);
        currunit->next = newunit;
        currunit = newunit;
        curr = curr->next;
    }
    currunit->next = NULL;

    actonunits(head, parseunit);

    CLASS* headclass = head->parsed;
    CLASS* currclass = headclass;
    currunit = head->next;
    while(currunit != NULL) {
        currclass->next = currunit->parsed;
        currclass = currunit->parsed;
        currunit = currunit->next;
    }
    currclass->next = NULL;
    COMPILER* compiler = mkcompiler(headclass);

    currunit = head;
    while(currunit != NULL) {
        currunit->compiler = compiler;
        currunit = currunit->next;
    }

    actonunits(head, compileunit);

    currunit = head;
    while(currunit != NULL) {
        FILE* output = fopen(currunit->file->outname, ""w"");
        if(output == NULL) {
            eprintf(""%s"", strerror(errno));
            exit(1);
        }

        if(currunit->compiled == NULL) {
            eprintf(""Class '%s' is empty; file '%s'\n"", currunit->parsed->name, currunit->file->name);
            exit(1);
        }

        printlns(currunit->compiled->head, output);
        fclose(output);
        COMPILEUNIT* next = currunit->next;
        freeunit(currunit);
        currunit = next;
    }

    freecompiler(compiler);
    freetree(headclass);
    freefilelist(files);
    return 0;
}
",31,978,689
"#include ""parser-expressions.h""
#include ""parser-util.h""
#include ""parser-statements.h""




STATEMENT* mkstatement(PARSER* p, STATEMENTTYPE t);

STATEMENT* parsestatementnullified(PARSER* p);
STATEMENT* parselet(PARSER* p);
CONDSTATEMENT* parsecond(PARSER* p);
STATEMENT* parseif(PARSER* p);
STATEMENT* parsewhile(PARSER* p);
STATEMENT* parsedo(PARSER* p);
STATEMENT* parsereturn(PARSER* p);




STATEMENT* mkstatement(PARSER* p, STATEMENTTYPE t) {
    STATEMENT* s = (STATEMENT*)malloc(sizeof(STATEMENT));
    s->type = t;
    s->debug = getdebug(p);
    return s;
}




STATEMENT* parsestatementnullified(PARSER* p) {
    if(equals(p, ""let"")) return parselet(p);
    if(equals(p, ""if"")) return parseif(p);
    if(equals(p, ""while"")) return parsewhile(p);
    if(equals(p, ""do"")) return parsedo(p);
    if(equals(p, ""return"")) return parsereturn(p);
    return NULL;
}

STATEMENT* parsestatements(PARSER* p) {
    STATEMENT* head = parsestatementnullified(p);
    STATEMENT* curr = head;
    STATEMENT* next;
    while(next = parsestatementnullified(p), next != NULL) {
        curr->next = next;
        curr = next;
    }
    if(curr != NULL)
        curr->next = NULL;
    return head;
}

STATEMENT* parselet(PARSER* p) {
    next(p);
    STATEMENT* s = mkstatement(p, letstatement);
    LETSTATEMENT* letst = (LETSTATEMENT*)malloc(sizeof(LETSTATEMENT));

    letst->varname = parseidentifier(p);
    
    if(equals(p, ""["")) {
        next(p);
        letst->arrayind = parseexpression(p);
        checkcontent(p, ""]"");
    }
    else
        letst->arrayind = NULL;

    checkcontent(p, ""="");

    letst->expression = parseexpression(p);

    checkcontent(p, "";"");

    s->type = letstatement;
    s->letstatement = letst;
    return s;
}

CONDSTATEMENT* parsecond(PARSER* p) {
    checkcontent(p, ""("");

    CONDSTATEMENT* st = (CONDSTATEMENT*)malloc(sizeof(CONDSTATEMENT));

    st->expression = parseexpression(p);

    checkcontent(p, "")"");
    checkcontent(p, ""{"");

    st->statements = parsestatements(p);

    checkcontent(p, ""}"");
    return st;
}

STATEMENT* parseif(PARSER* p) {
    next(p);
    STATEMENT* s = mkstatement(p, ifstatement);
    IFSTATEMENT* ifst = (IFSTATEMENT*)malloc(sizeof(IFSTATEMENT));

    ifst->base = parsecond(p);

    if(equals(p, ""else"")) {
        next(p);
        checkcontent(p, ""{"");
        ifst->elsestatements = parsestatements(p);
        checkcontent(p, ""}"");
    }
    else
        ifst->elsestatements = NULL;

    s->type = ifstatement;
    s->ifstatement = ifst;
    return s;
}

STATEMENT* parsewhile(PARSER* p) {
    next(p);
    STATEMENT* s = mkstatement(p, whilestatement);

    s->whilestatement = parsecond(p);
    return s;
}

STATEMENT* parsedo(PARSER* p) {
    next(p);
    STATEMENT* s = mkstatement(p, dostatement);

    s->dostatement = parsesubroutcall(p);

    checkcontent(p, "";"");
    return s;
}

STATEMENT* parsereturn(PARSER* p) {
    next(p);
    STATEMENT* s = mkstatement(p, returnstatement);

    s->retstatement = parseexpressionnullified(p);

    checkcontent(p, "";"");
    return s;
}
",31,979,1130
"#include ""util.h""
#include ""io.h""


#ifndef PATH_MAX
#ifdef __linux__

#else
#define PATH_MAX 512
#endif
#endif

char* strtail(char* str, int len, int count) {
    int index = len - count;
    if (index <= 0) return str;
    return str + (sizeof(char) * (index));
}

char* strhead(char* str, int count) {
    return str + (sizeof(char) * count);
}

char* trimstr(char* str, int len, int end) {
    int count = len - end;
    char oldchar = str[count];
    str[count] = '\0';
    char* newstr = (char*)malloc(sizeof(char) * (1 + count));
    strcpy(newstr, str);
    str[count] = oldchar;
    return newstr;
}

char* getname(char* f, int len) {
    int startind = 0;
    int endind = len - 1;
    bool readsmt = false;
 
    for(int i = endind; i >= 0; i--) {
        if(f[i] == '/') {
            if(!readsmt) {
                endind = i-1;
                f[i] = '\0';
                continue;
            }
            startind = i+1;
            break;
        }
        readsmt = true;
    }

    int sz = sizeof(char)*(endind - startind + 2);
    char* startstr = strhead(f, startind);
    char* retstr = (char*)malloc(sz);
    snprintf(retstr, sz, ""%s"", startstr);
    return retstr;
}

char* getfullname(char* fname, int fnamelen, char* dirname, int dirlen) {
    int sz = sizeof(char)*(fnamelen+dirlen+2);
    char* fullname = (char*)malloc(sz);
    sprintf(fullname, ""%s/%s"", dirname, fname);
    return fullname;
}

bool isdotjack(char* f, int len) {
    const char* ext = "".jack"";
    return strcmp(strtail(f, len, strlen(ext)), ext) == 0;
}

bool isdir(char* f, int len) {
    bool readsmt = false;
    for(int i = len-1; i >= 0; i--) {
        if(f[i] == '.') {
            if(readsmt)
                return false;
            else
                continue;
        }
        if(f[i] == '/')
            return 1;
        readsmt = true;
    }
    return true;
}

char* getoutname(char* fullname, int len) {
    char* trimmed = trimstr(fullname, len, 4);
    int sz = sizeof(char) * (len-1);
    char* outname = (char*)malloc(sz);
    sprintf(outname, ""%svm"", trimmed);
    free(trimmed);
    return outname;
}

FILELIST* addfile(FILELIST* l, char* fullname, char* name) {
    FILELIST* new = (FILELIST*)malloc(sizeof(FILELIST));
    new->name = name;
    new->fullname = fullname;
    new->next = l;
    new->outname = getoutname(fullname, strlen(fullname));
    return new;
}

FILELIST* getfilesfromdir(char* dir) {
    FILELIST* filelist = NULL;
    DIR* d = opendir(dir);

    if(d == NULL) {
        eprintf(""Error while opening directory '%s': %s\n"", dir, strerror(errno));
        exit(errno);
    }

    int len = strlen(dir);
    struct dirent* thisfile;
    while(thisfile = readdir(d), thisfile != NULL) {
        int thislen = strlen(thisfile->d_name);
        if(isdotjack(thisfile->d_name, thislen)) {
            char* fullname = getfullname(thisfile->d_name, thislen, dir, len);
            char* name = ezheapstr(thisfile->d_name);
            filelist = addfile(filelist, fullname, name);
        }
    }
    
    closedir(d);

    if(filelist == NULL) {
        eprintf(""Directory '%s' doesn't have any .jack file\n"", dir);
        exit(1);
    }
    return filelist;
}

FILELIST* getsinglefile(char* file) {
    int len = strlen(file);
    if(isdotjack(file, len)){
        char* name = getname(file, len);
        char* fullname = heapstr(file, len);

        FILE* input = fopen(fullname, ""r"");
        if(input == NULL) {
            eprintf(""Error while reading file '%s': %s\n"", file, strerror(errno));
            exit(errno);
        }
        fclose(input);

        return addfile(NULL, fullname, name);
    }
    else {
        eprintf(""Input file must be named like 'Xxx.vm'\n"");
        exit(1);
    }
}

FILELIST* getfiles(char* input) {
    int inplen = strlen(input);
    bool isitdir = isdir(input, inplen);

    if(isitdir)
        return getfilesfromdir(input);
    else
        return getsinglefile(input);
}

void freefilelist(FILELIST* fs) {
    free(fs->name);
    free(fs->fullname);
    free(fs->outname);
    FILELIST* next = fs->next;
    free(fs);
    if(next != NULL)
        freefilelist(next);
}
",31,980,1497
"#include ""threads.h""
#include ""parser.h""
#include ""compiler.h""
#include ""io.h""
#include ""assembler.h""

int main(int argc, char* argv[]) {
    if(argc < 2) {
        eprintf(""Usage: %s {input file(s)}\n"", argv[0]);
        return 1;
    }

    FILELIST* files = getfiles(argv[1]);
    FILELIST* curr = files->next;

    COMPILEUNIT* head = (COMPILEUNIT*)malloc(sizeof(COMPILEUNIT));

    head->file = files;
    head->parser = mkparser(tokenize(files->fullname), files->name);

    COMPILEUNIT* currunit = head;
    while(curr != NULL) {
        COMPILEUNIT* newunit = (COMPILEUNIT*)malloc(sizeof(COMPILEUNIT));
        newunit->file = curr;
        newunit->parser = mkparser(tokenize(curr->fullname), curr->name);
        currunit->next = newunit;
        currunit = newunit;
        curr = curr->next;
    }
    currunit->next = NULL;

    actonunits(head, parseunit);

    CLASS* headclass = head->parsed;
    CLASS* currclass = headclass;
    currunit = head->next;
    while(currunit != NULL) {
        currclass->next = currunit->parsed;
        currclass = currunit->parsed;
        currunit = currunit->next;
    }
    currclass->next = NULL;
    COMPILER* compiler = mkcompiler(headclass);

    currunit = head;
    while(currunit != NULL) {
        currunit->compiler = compiler;
        currunit = currunit->next;
    }

    actonunits(head, compileunit);
    actonunits(head, vmtranslateunit);

    ASMBLK* asmlns = head->asmlns;
    currunit = head->next;
    while(currunit != NULL) {
        mergeasmblks(asmlns, currunit->asmlns);
        currunit = currunit->next;
    }

    ASSEMBLER* assembler = mkassembler(asmlns->head);
    preprocess(assembler);
    assemble(assembler);


    char* outname = getouthack(argv[1]);
    FILE* output = fopen(outname, ""w"");
    if(output == NULL) {
        eprintf(""%s"", strerror(errno));
        exit(1);
    }

    printstrlist(asmlns->head, output);
    free(asmlns);

    fclose(output);
    free(outname);

    currunit = head;
    while(currunit != NULL) {
        COMPILEUNIT* next = currunit->next;
        freeunit(currunit);
        currunit = next;
    }

    freecompiler(compiler);
    freeassembler(assembler);
    freetree(headclass);
    freefilelist(files);
    return 0;
}
",31,981,793
"#include ""compiler-util.h""

LINE* opvarraw(SCOPE* s, char* op, VAR* v) {
    char* tokens[] = { op, v->memsegment, itoa(v->index) };
    LINE* ln = mksimpleln(tokens, strcount(tokens));
    free(tokens[2]);
    return ln;
}

LINE* pushvarraw(SCOPE* s, VAR* v) {
    return opvarraw(s, ""push"", v);
}

LINE* pushvar(SCOPE* s, DEBUGINFO* d, const char* name) {
    return opvarraw(s, ""push"", getvarmustexist(s, d, name));
}

LINE* popvar(SCOPE* s, DEBUGINFO* d, const char* name) {
    return opvarraw(s, ""pop"", getvarmustexist(s, d, name));
}

LINE* poptemp() {
    char* poptemp[] = { ""pop"", ""temp"", ""0"" };
    return mksimpleln(poptemp, strcount(poptemp));
}

LINE* popthatadd() {
    char* popthatadd[] = { ""pop"", ""pointer"", ""1"" };
    return mksimpleln(popthatadd, strcount(popthatadd));
}

LINE* onetoken(char* str) {
    LINE* ln = mkline(1);
    addtoken(ln, ezheapstr(str));
    ln->next = NULL;
    return ln;
}

LINE* mksimpleln(char** tokens, int count) {
    LINE* ln = mkline(count);
    for(int i = 0; i < count; i++)
        addtoken(ln, ezheapstr(tokens[i]));
    ln->next = NULL;
    return ln;
}
",31,982,472
"#include ""compiler.h""
#include ""compiler-scopes.h""

typedef enum { local, staticseg, arg, fieldseg } MEMSEGMENT;
char* memsegnames[] = { ""local"", ""static"", ""argument"", ""this"" };


void doubledeclaration(const char* name, DEBUGINFO* d1, DEBUGINFO* d2);
void ensurenoduplicate(SCOPE* s, DEBUGINFO* d, char* name);


VAR* getvarinvars(VAR* vars, const char* name);
CLASS* getclass(SCOPE* s, const char* name);
SUBROUTDEC* getsubroutdecfromlist(SUBROUTDEC* start, char* name);
SUBROUTDEC* getmethod(SCOPE* s, VAR* parent, SUBROUTCALL* call);
SUBROUTDEC* getfunction(SCOPE* s, SUBROUTCALL* call);
SUBROUTDEC* getsubroutdecwithparent(SCOPE* s, SUBROUTCALL* call, VAR** varret);
SUBROUTDEC* getsubroutdecwithoutparent(SCOPE* s, SUBROUTCALL* call);
SUBROUTDEC* getsubroutdec(SCOPE* s, const char* name);


VAR* mkvar(char* type, char* name, bool primitive, DEBUGINFO* debug, MEMSEGMENT seg, int i);
void addvar(SCOPE* s, VAR** dest, VAR* v);
void addlocalvar(SCOPE* s, VARDEC* v, int* i);
void addstaticvar(SCOPE* s, CLASSVARDEC* v);
void addfield(SCOPE* s, CLASSVARDEC* v, int* i);
void addclassvardec(SCOPE* s, CLASSVARDEC* v, int* i);
void addparameter(SCOPE* s, PARAMETER* p, int* i);


void doubledeclaration(const char* name, DEBUGINFO* d1, DEBUGINFO* d2) {
    eprintf(""Double declaration of '%s' at '%s', line %i; previously defined at '%s', line %i\n"",
                name, d1->file, d1->definedat, d2->file, d2->definedat);
    exit(1);
}

void notdeclared(const char* name, DEBUGINFO* debug) {
    eprintf(""'%s' not declared; file '%s', line %i\n"", name, debug->file, debug->definedat);
    exit(1);
}

void invalidparent(SUBROUTCALL* call) {
    eprintf(""Invalid subroutine parent '%s'; file '%s', line %i\n"", call->parentname, call->debug->file, call->debug->definedat);
    exit(1);
}

void ensurenoduplicate(SCOPE* s, DEBUGINFO* d, char* name) {
    VAR* v = getvar(s, name);
    if(v != NULL)
        doubledeclaration(name, d, v->debug);

    CLASS* c = getclass(s, name);
    if(c != NULL)
        doubledeclaration(name, d, c->debug);

    SUBROUTDEC* sr = getsubroutdec(s, name);
    if(sr != NULL)
        doubledeclaration(name, d, sr->debug);
}


SCOPE* mkscope(SCOPE* prev) {
    SCOPE* s = (SCOPE*)malloc(sizeof(SCOPE));
    s->previous = prev;
    if(prev != NULL)
        s->compiler = prev->compiler;
    s->localvars = NULL;
    s->fields = NULL;
    s->staticvars = NULL;
    s->parameters = NULL;
    s->classes = NULL;
    s->subroutines = NULL;
    return s;
}


VAR* getvarinvars(VAR* vars, const char* name) {
    while(vars != NULL) {
        if(!strcmp(vars->name, name))
            return vars;
        vars = vars->next;
    }
    return NULL;
}

VAR* getvar(SCOPE* s, const char* name) {
    VAR* var = getvarinvars(s->localvars, name);
    if(var != NULL)
        return var;
    var = getvarinvars(s->parameters, name);
    if(var != NULL)
        return var;
    var = getvarinvars(s->fields, name);
    if(var != NULL)
        return var;
    var = getvarinvars(s->staticvars, name);
    if(var != NULL)
        return var;
    if(s->previous != NULL)
        return getvar(s->previous, name);
    return NULL;
}

VAR* getvarmustexist(SCOPE* s, DEBUGINFO* d, const char* name) {
    VAR* v = getvar(s, name);
    if(v == NULL)
        notdeclared(name, d);
    return v;
}

CLASS* getclass(SCOPE* s, const char* name) {
    CLASS* curr = s->classes;
    while(curr != NULL) {
        if(!strcmp(curr->name, name))
            return curr;
        curr = curr->next;
    }
    if(s->previous != NULL)
        return getclass(s->previous, name);
    return NULL;
}

SUBROUTDEC* getsubroutdecfromlist(SUBROUTDEC* start, char* name) {
    while(start != NULL) {
        if(!strcmp(start->name, name))
            return start;
        start = start->next;
    }
    return NULL;
}

SUBROUTDEC* getmethod(SCOPE* s, VAR* parent, SUBROUTCALL* call) {
    CLASS* c = getclass(s, parent->type);
    SUBROUTDEC* d = getsubroutdecfromlist(c->subroutdecs, call->name);
    if(d == NULL)
        return NULL;
    if(d->subroutclass != method) {
        eprintf(""Calling a function/constructor as if it were a method; file '%s', line %i\n"", call->debug->file, call->debug->definedat);
        exit(1);
    }
    return d;
}

SUBROUTDEC* getfunction(SCOPE* s, SUBROUTCALL* call) {
    CLASS* c = getclass(s, call->parentname);
    if(c == NULL)
        notdeclared(call->parentname, call->debug);
    SUBROUTDEC* d = getsubroutdecfromlist(c->subroutdecs, call->name);
    if(d == NULL)
        return NULL;
    if(d->subroutclass == method) {
        eprintf(""Calling a method as if it were a function; file '%s', line %i\n"", call->debug->file, call->debug->definedat);
        exit(1);
    }
    return d;
}

SUBROUTDEC* getsubroutdecwithparent(SCOPE* s, SUBROUTCALL* call, VAR** varret) {
    VAR* parent = getvar(s, call->parentname);
    if(parent != NULL) {
        if(parent->primitive) {
            eprintf(""Primitive type does not have subroutines; file '%s', line %i\n"", call->debug->file, call->debug->definedat);
            exit(1);
        }
        *varret = parent;
        return getmethod(s, parent, call);
    }
    else
        return getfunction(s, call);
}

SUBROUTDEC* getsubroutdecwithoutparent(SCOPE* s, SUBROUTCALL* call) {
    SUBROUTDEC* d = getsubroutdecfromlist(s->currclass->subroutdecs, call->name);
    return d;
}

SUBROUTDEC* getsubroutdecfromcall(SCOPE* s, SUBROUTCALL* call, VAR** varret) {
    SUBROUTDEC* d;
    *varret = NULL;
    if(call->parentname != NULL)
        d = getsubroutdecwithparent(s, call, varret);
    else
        d = getsubroutdecwithoutparent(s, call);
    if(d == NULL)
        notdeclared(call->name, call->debug);
    return d;
}

SUBROUTDEC* getsubroutdec(SCOPE* s, const char* name) {
    SUBROUTDEC* curr = s->subroutines;
    while(curr != NULL) {
        if(!strcmp(curr->name, name))
            return curr;
        curr = curr->next;
    }
    if(s->previous != NULL)
        return getsubroutdec(s->previous, name);
    return NULL;
}


VAR* mkvar(char* type, char* name, bool primitive, DEBUGINFO* debug, MEMSEGMENT seg, int i) {
    VAR* v = (VAR*)malloc(sizeof(VAR));
    v->name = name;
    v->type = type;
    v->debug = debug;
    v->memsegment = memsegnames[seg];
    v->primitive = primitive;
    v->index = i;
    return v;
}

void addvar(SCOPE* s, VAR** dest, VAR* v) {
    ensurenoduplicate(s, v->debug, v->name);

    if(!v->primitive) {
        CLASS* type = getclass(s, v->type);
        if(type == NULL)
            notdeclared(v->type, v->debug);
    }

    v->next = *dest;
    *dest = v;
}

void addlocalvar(SCOPE* s, VARDEC* v, int* i) {
    STRINGLIST* currname = v->names;
    while(currname != NULL) {
        addvar(s, &(s->localvars), mkvar(v->type, currname->content, v->primitive, v->debug, local, *i));
        currname = currname->next;
        (*i)++;
    }
}

void addstaticvar(SCOPE* s, CLASSVARDEC* v) {
    STRINGLIST* currname = v->base->names;
    pthread_mutex_lock(&(s->compiler->staticmutex));
    static int i = 0;
    while(currname != NULL) {
        addvar(s, &(s->staticvars), mkvar(v->base->type, currname->content, v->base->primitive, v->base->debug, staticseg, i));
        currname = currname->next;
        i++;
    }
    pthread_mutex_unlock(&(s->compiler->staticmutex));
}

void addfield(SCOPE* s, CLASSVARDEC* v, int* i) {
    STRINGLIST* currname = v->base->names;
    while(currname != NULL) {
        addvar(s, &(s->fields), mkvar(v->base->type, currname->content, v->base->primitive, v->base->debug, fieldseg, *i));
        currname = currname->next;
        (*i)++;
    }
}

void addclassvardec(SCOPE* s, CLASSVARDEC* v, int* i) {
    if(v->type == stat)
        addstaticvar(s, v);
    else {
        addfield(s, v, i);
    }
}

void addparameter(SCOPE* s, PARAMETER* p, int* i) {
    addvar(s, &(s->parameters), mkvar(p->type, p->name, p->primitive, p->debug, arg, *i));
    (*i)++;
}


void addclassvardecs(SCOPE* s, CLASSVARDEC* classvardecs) {
    int i = 0;
    while(classvardecs != NULL) {
        addclassvardec(s, classvardecs, &i);
        classvardecs = classvardecs->next;
    }
}

void addlocalvars(SCOPE* s, VARDEC* localvars) {
    int i = 0;
    while(localvars != NULL) {
        addlocalvar(s, localvars, &i);
        localvars = localvars->next;
    }
}

void addparameters(SCOPE* s, bool isformethod, PARAMETER* params) {
    int i = isformethod ? 1 : 0;
    while(params != NULL) {
        addparameter(s, params, &i);
        params = params->next;
    }
}

void freevars(VAR* v) {
    if(v != NULL) {
        VAR* next = v->next;
        free(v);
        freevars(next);
    }
}

void freescope(SCOPE* s) {
    freevars(s->fields);
    freevars(s->staticvars);
    freevars(s->localvars);
    freevars(s->parameters);
    free(s);
};
",31,983,3322
"#include ""compiler-statements.h""
#include ""compiler-structure.h""
#include ""compiler-util.h""




int countlocalvars(VARDEC* decs);
int countstrs(STRINGLIST* ls);
int getobjsize(CLASS* c);
LINE* mksubdeclabel(CLASS* c, SUBROUTDEC* sd);


LINEBLOCK* compilefunbody(SCOPE* s, CLASS* cl, SUBROUTDEC* d);
LINEBLOCK* compilefundec(SCOPE* s, CLASS* cl, SUBROUTDEC* f);
LINEBLOCK* compileconstructor(SCOPE* s, CLASS* cl, SUBROUTDEC* con);
LINEBLOCK* compilemethod(SCOPE* s, CLASS* cl, SUBROUTDEC* m);





int countlocalvars(VARDEC* decs) {
    int i = 0;
    while(decs != NULL) {
        STRINGLIST* curr = decs->names;
        while(curr != NULL) {
            i++;
            curr = curr->next;
        }
        decs = decs->next;
    }
    return i;
}

int countstrs(STRINGLIST* ls) {
    int count = 0;
    while(ls != NULL) {
        count++;
        ls = ls->next;
    }
    return count;
}

int getobjsize(CLASS* c) {
    CLASSVARDEC* curr = c->vardecs;
    int count = 0;
    while(curr != NULL) {
        if(curr->type == field)
            count += countstrs(curr->base->names);
        curr = curr->next;
    }
    return count;
}

LINE* mksubdeclabel(CLASS* c, SUBROUTDEC* sd) {
    char* labelstrs[] = { ""function"", dotlabel(c->name, sd->name), itoa(countlocalvars(sd->body->vardecs)) };
    LINE* label = mkln(labelstrs);
    free(labelstrs[1]);
    free(labelstrs[2]);
    label->next = NULL;
    return label;
}


LINEBLOCK* compilefunbody(SCOPE* s, CLASS* cl, SUBROUTDEC* d) {
    SUBROUTBODY* b = d->body;
    SCOPE* myscope = mkscope(s);
    myscope->currclass = cl;
    if(b->vardecs != NULL)
        addlocalvars(myscope, b->vardecs);

    if(b->statements == NULL) {
        eprintf(""Subroutine body has no statements; file '%s', line %i\n"",
                d->debug->file, d->debug->definedat);
        exit(1);
    }

    STATEMENT* last;
    LINEBLOCK* head = compilestatementsretlast(myscope, b->statements, &last);
    if(last->type != returnstatement) {
        eprintf(""Subroutine must end with a return statement; file '%s', line %i\n"",
                last->debug->file, last->debug->definedat);
        exit(1);
    }

    freescope(myscope);
    return head;
}

LINEBLOCK* compilefundec(SCOPE* s, CLASS* cl, SUBROUTDEC* f) {
    LINE* label = mksubdeclabel(cl, f);

    LINEBLOCK* body = compilefunbody(s, cl, f);
    appendlnbefore(body, label);
    return body;
}

LINEBLOCK* compileconstructor(SCOPE* s, CLASS* cl, SUBROUTDEC* con) {
    LINE* label = mksubdeclabel(cl, con);
    LINEBLOCK* blk = mklnblk(label);

    char* size[] = { ""push"", ""constant"", itoa(getobjsize(cl)) };
    char* memalloc[] = { ""call"", ""Memory.alloc"", ""1"" };
    char* poppointer[] = { ""pop"", ""pointer"", ""0"" };
    appendln(blk, mkln(size));
    appendln(blk, mkln(memalloc));
    appendln(blk, mkln(poppointer));
    free(size[2]);

    if(con->body != NULL)
        return mergelnblks(blk, compilefunbody(s, cl, con));
    else
        return blk;
}

LINEBLOCK* compilemethod(SCOPE* s, CLASS* cl, SUBROUTDEC* m) {
    LINE* label = mksubdeclabel(cl, m);
    LINEBLOCK* blk = mklnblk(label);

    char* pusharg0[] = { ""push"", ""argument"", ""0"" };
    char* poppointer[] = { ""pop"", ""pointer"", ""0"" };
    appendln(blk, mkln(pusharg0));
    appendln(blk, mkln(poppointer));

    if(m->body != NULL) 
        return mergelnblks(blk, compilefunbody(s, cl, m));
    else
        return blk;
}

LINEBLOCK* compilesubroutdec(SCOPE* s, CLASS* cl, SUBROUTDEC* sd) {
    SCOPE* myscope = mkscope(s);
    LINEBLOCK* blk;
    if(sd->parameters != NULL)
        addparameters(myscope, sd->subroutclass == method, sd->parameters);
    if(sd->subroutclass == function)
        blk = compilefundec(myscope, cl, sd);
    else if(sd->subroutclass == constructor)
        blk = compileconstructor(myscope, cl, sd);
    else
        blk = compilemethod(myscope, cl, sd);
    freescope(myscope);
    return blk;
}
",31,984,1496
"#include ""parser-tree.h""

void freeexpression(TERM* e);
void freeexpressionlist(EXPRESSIONLIST* el);
void freestatements(STATEMENT* s);

void freevardec(VARDEC* v) {
    freestrlist(v->names);
    free(v->debug);
    free(v);
}

void freevardecs(VARDEC* v) {
    VARDEC* next = v->next;
    freevardec(v);
    if(next != NULL)
        freevardecs(next);
}

void freeparameters(PARAMETER* p) {
    free(p->debug);
    PARAMETER* next = p->next;
    free(p);
    if(next != NULL)
        freeparameters(next);
}

void freearray(ARRAY* a) {
    freeexpression(a->exp);
    free(a);
}

void freesubroutcall(SUBROUTCALL* call) {
    if(call->parameters != NULL)
        freeexpressionlist(call->parameters);
    free(call->debug);
    free(call);
}

void freeexpression(TERM* e) {
    if(e->type == arrayitem)
        freearray(e->array);
    else if(e->type == innerexpression || e->type == unaryopterm)
        freeexpression(e->expression);
    else if(e->type == subroutcall)
        freesubroutcall(e->call);
    TERM* next = e->next;
    free(e);
    if(next != NULL)
        freeexpression(next);
}

void freeexpressionlist(EXPRESSIONLIST* el) {
    freeexpression(el->expression);
    EXPRESSIONLIST* next = el->next;
    free(el);
    if(next != NULL)
        freeexpressionlist(next);
}

void freelet(LETSTATEMENT* l) {
    if(l->arrayind != NULL)
        freeexpression(l->arrayind);
    freeexpression(l->expression);
    free(l);
}

void freecond(CONDSTATEMENT* cond) {
    freeexpression(cond->expression);
    if(cond->statements != NULL)
        freestatements(cond->statements);
    free(cond);
}

void freeif(IFSTATEMENT* st) {
    freecond(st->base);
    if(st->elsestatements != NULL)
        freestatements(st->elsestatements);
    free(st);
}

void freestatements(STATEMENT* s) {
    if(s->type == letstatement)
        freelet(s->letstatement);
    else if(s->type == ifstatement)
        freeif(s->ifstatement);
    else if(s->type == whilestatement)
        freecond(s->whilestatement);
    else if(s->type == dostatement)
        freesubroutcall(s->dostatement);
    else if(s->retstatement != NULL)
        freeexpression(s->retstatement);

    free(s->debug);
    STATEMENT* next = s->next;
    free(s);
    if(next != NULL)
        freestatements(next);
}

void freesubroutbody(SUBROUTBODY* b) {
    if(b->vardecs != NULL)
        freevardecs(b->vardecs);
    if(b->statements != NULL)
        freestatements(b->statements);
    free(b);
}

void freesubroutdecs(SUBROUTDEC* sr) {
    free(sr->debug);
    if(sr->parameters != NULL)
        freeparameters(sr->parameters);
    freesubroutbody(sr->body);
    SUBROUTDEC* next = sr->next;
    free(sr);
    if(next != NULL)
        freesubroutdecs(next);
}

void freeclassvardecs(CLASSVARDEC* cvd) {
    freevardec(cvd->base);
    CLASSVARDEC* next = cvd->next;
    free(cvd);
    if(next != NULL)
        freeclassvardecs(next);
}

void freetree(CLASS* c) {
    free(c->debug);

    if(c->vardecs != NULL)
        freeclassvardecs(c->vardecs);
    if(c->subroutdecs != NULL)
        freesubroutdecs(c->subroutdecs);

    CLASS* next = c->next;
    free(c);
    if(next != NULL)
        freetree(next);
}
",31,985,1174
"#include ""threads.h""

void* parseunit(void* input) {
    COMPILEUNIT* unit = (COMPILEUNIT*)input;

    unit->parsed = parse(unit->parser);

    pthread_exit(NULL);
}

void* compileunit(void* input) {
    COMPILEUNIT* unit = (COMPILEUNIT*)input;

    unit->compiled = compileclass(unit->compiler, unit->parsed);

    pthread_exit(NULL);
}

void waitthreads(pthread_t* threads, int amount) {
    void* status;
    int code;
    for(int i = 0; i < amount; i++) {
        code = pthread_join(threads[i], &status);
        if(code) {
            eprintf(""Error while joining thread %i: %s\n"", i, strerror(code));
            exit(code);
        }
    }
}

void actonunits(COMPILEUNIT* units, void*(*fun)(void*)) {
    pthread_t mythreads[_SC_THREAD_THREADS_MAX];
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

    COMPILEUNIT* curr = units;

    int i;
    int code;
    do {
        i = 0;
        while(curr != NULL && i < _SC_THREAD_THREADS_MAX) {
            code = pthread_create(&mythreads[i], &attr, fun, curr);

            if(code) {
                eprintf(""Error while creating thread %i: %s\n"", i, strerror(code));
                exit(code);
            }

            curr = curr->next;
            i++;
        }
        waitthreads(mythreads, i);
    } while(i == _SC_THREAD_THREADS_MAX);

    pthread_attr_destroy(&attr);
}

void freeunit(COMPILEUNIT* u) {
    freeparser(u->parser);
    freelnblk(u->compiled);
    free(u);
}
",31,986,547
"#include ""vm-lines.h""

LINE* mkline(int size) {
    LINE* ln = (LINE*)malloc(sizeof(LINE));
    ln->tokens = (char**)malloc(sizeof(char*)*size);
    ln->count = 0;
    return ln;
}

void addtoken(LINE* ln, char* token) {
    ln->tokens[ln->count] = token;
    ln->count++;
}

void println(LINE* ln, FILE* stream) {
    for(int i = 0; i < ln->count; i++) {
        fprintf(stream, ""%s"", ln->tokens[i]);
        if(i + 1 < ln->count)
            fprintf(stream, "" "");
    }
    fprintf(stream, ""\n"");
}

void printlns(LINE* lns, FILE* stream) {
    while(lns != NULL) {
        println(lns, stream);
        lns = lns->next;
    }
}

void freeln(LINE* ln) {
    for(int i = 0; i < ln->count; i++)
        free(ln->tokens[i]);
    free(ln->tokens);
    free(ln);
}

void freelns(LINE* lns) {
    LINE* next = lns->next;
    freeln(lns);
    if(next != NULL)
        freelns(next);
}

void freelnblk(LINEBLOCK* blk) {
    freelns(blk->head);
    free(blk);
}

LINEBLOCK* mklnblk(LINE* start) {
    LINEBLOCK* blk = (LINEBLOCK*)malloc(sizeof(LINEBLOCK));
    blk->head = start;
    blk->tail = start;
    return blk;
}

LINEBLOCK* mergelnblks(LINEBLOCK* head, LINEBLOCK* tail) {
    if(head == NULL)
        return tail;
    head->tail->next = tail->head;
    head->tail = tail->tail;
    free(tail);
    return head;
}

void appendln(LINEBLOCK* lnblk, LINE* ln) {
    lnblk->tail->next = ln;
    lnblk->tail = ln;
}

void appendlnbefore(LINEBLOCK* lnblk, LINE* ln) {
    ln->next = lnblk->head;
    lnblk->head = ln;
}
",31,987,645
"#include ""tokenizer.h""
#include ""tokenizer-tables.h""


typedef enum {
    common, charsymbol, space
} CHARTYPE;

typedef struct {
    char* str;
    int size;
    int count;
} STRING;


STRING* mkstring(int size);
void append(STRING* s, char c);
void freestr(STRING* str);


TOKEN* appendtokenraw(TOKEN* curitem, STRING* token, int definedat, TOKENTYPE type);
TOKEN* appendtoken(TOKEN* curitem, STRING* token, char* file, int definedat);
#define mktoken() (TOKEN*)malloc(sizeof(TOKEN))


CHARTYPE getchartype(unsigned char c);
bool iskeyword(STRING* tk);
bool issymbol(STRING* tk);
bool isint(char* str);
bool isintcons(STRING* tk);
bool isidentifier(STRING* tk);
TOKENTYPE gettokentype(STRING* tk, char* file, int definedat);


void skipln(FILE* input);
void skipmultiln(FILE* input, int* lnscount);
bool handlecomment(FILE* input, int* lnscount);
void readstr(FILE* input, STRING* tmp, int definedat);


STRING* mkstring(int size) {
    STRING* str = (STRING*)malloc(sizeof(STRING));
    str->size = sizeof(char) * size; 
    str->str = (char*)malloc(str->size);
    str->count = 0;
    return str;
}

void append(STRING* s, char c) {
    int targsize = sizeof(char) * (s->count + 1);
    if(s->size <= targsize) {
        s->size = targsize * 2;
        s->str = (char*)realloc(s->str, s->size);
    }

    s->str[s->count] = c;
    s->count++;
}

void freestr(STRING* str) {
    free(str->str);
    free(str);
}


TOKEN* appendtokenraw(TOKEN* curitem, STRING* token, int definedat, TOKENTYPE type) {
    curitem->token = (char*)malloc(sizeof(char)*token->count);
    strcpy(curitem->token, token->str);
    curitem->definedat = definedat;
    curitem->type = type;
    TOKEN* nextitem = mktoken();
    curitem->next = nextitem;
    token->count = 0;
    return nextitem;
}

void freetokens(TOKEN* t) {
    free(t->token);
    TOKEN* next = t->next;
    free(t);
    if(next != NULL)
        freetokens(next);
}

TOKEN* appendtoken(TOKEN* curitem, STRING* token, char* file, int definedat) {
    append(token, '\0');
    return appendtokenraw(curitem, token, definedat, gettokentype(token, file, definedat));
}


CHARTYPE getchartype(unsigned char c) {
    if(isspace(c)) return space;
    if(isalnum(c) || c == '_' || c == '""') return common;
    return charsymbol;
}

bool iskeyword(STRING* tk) {
    return existsinarray(&keywords, tk->str);
}

bool issymbol(STRING* tk) {
    if(tk->count != 2)
        return false;
    return existsinarray(&symbols, tk->str);
}

bool isint(char* str) {
    int i = 0;
    while(str[i] != '\0') {
        if(!isdigit(str[i]))
            return false;
        i++;
    }
    return true;
}

bool isintcons(STRING* tk) {
    if(!isint(tk->str))
        return false;
    int val = atoi(tk->str);
    return val <= 65535;
}

bool isidentifier(STRING* tk) {
    if(isdigit(tk->str[0]))
        return false;

    int count = tk->count - 1;
    for(int i = 0; i < count; i++)
        if(!isalnum(tk->str[i]) && tk->str[i] != '_')
            return false;
    return true;
}

TOKENTYPE gettokentype(STRING* tk, char* file, int definedat) {
    if(iskeyword(tk)) return keyword;
    if(issymbol(tk)) return symbol;
    if(isintcons(tk)) return integer;
    if(isidentifier(tk)) return identifier;
    eprintf(""Unexpected token '%s'; file '%s', line %i\n"", tk->str, file, definedat);
    exit(1);
}


void skipln(FILE* input) {
    unsigned char c;
    while(c = fgetc(input), c != '\0')
        if(c == '\n')
            break;
}

void skipmultiln(FILE* input, int* lnscount) {
    unsigned char c;
    while(c = fgetc(input), c != '\0')
        if(c == '\n')
            (*lnscount)++;
        else if(c == '*')
            if(fgetc(input) == '/')
                break;
}

bool handlecomment(FILE* input, int* lnscount) {
    unsigned char nextc = fgetc(input);
    if(nextc == '/') {
        skipln(input);
        (*lnscount)++;
        return true;
    }
    else if(nextc == '*') {
        unsigned char furtherc = fgetc(input);
        if(furtherc == '*') {
            skipmultiln(input, lnscount);
            return true;
        }
        ungetc(furtherc, input);
    }
    ungetc(nextc, input);
    return false;
}

void readstr(FILE* input, STRING* tmp, int definedat) {
    unsigned char c;
    while(c = fgetc(input), c != '\0') {
        if(c == '\n') {
            eprintf(""Unexpected end of line; line %i"", definedat);
            exit(1);
        }
        if(c == '""')
            break;
        append(tmp, c);
    }
    append(tmp, '\0');
}

TOKEN* tokenize(char* file) {
    TOKEN* head = mktoken();
    TOKEN* lastitem = head;
    TOKEN* curitem = head;

    STRING* tmptoken = mkstring(200);
    CHARTYPE lasttype = space;
    CHARTYPE curtype;

    int lnscount = 1;
    FILE* input = fopen(file, ""r"");
    
    unsigned char c;
    while(!feof(input)) {
        c = fgetc(input);
        if(c == '\n')
            lnscount++;
        else if(c == '/' && handlecomment(input, &lnscount)) 
            continue;
        else if(c == '""') {
            if(lasttype != space)
                curitem = appendtoken(curitem, tmptoken, file, lnscount);
            readstr(input, tmptoken, lnscount);
            lastitem = curitem;
            curitem = appendtokenraw(curitem, tmptoken, lnscount, string);
            lasttype = space;
            continue;
        }

        curtype = getchartype(c);

        if(curtype == common) {
            if(lasttype == charsymbol) {
                lastitem = curitem;
                curitem = appendtoken(curitem, tmptoken, file, lnscount);
            }
            append(tmptoken, c);
        } else {
            if(lasttype != space){
                lastitem = curitem;
                curitem = appendtoken(curitem, tmptoken, file, lnscount);
            }
            if(curtype == charsymbol)
                append(tmptoken, c);
        }
        lasttype = curtype;
    }

    if(curitem == head) {
        eprintf(""File '%s' is empty\n"", file);
        exit(1);
    }

    lastitem->next = NULL;
    free(curitem);
    freestr(tmptoken);
    fclose(input);
    return head;
}
",31,988,2162
"#include ""threads.h""

void* parseunit(void* input) {
    COMPILEUNIT* unit = (COMPILEUNIT*)input;

    unit->parsed = parse(unit->parser);

    pthread_exit(NULL);
}

void* compileunit(void* input) {
    COMPILEUNIT* unit = (COMPILEUNIT*)input;

    unit->compiled = compileclass(unit->compiler, unit->parsed);

    pthread_exit(NULL);
}

char* getclassname(char* filename) {
    int len = strlen(filename) - 1;

    for(len = len; len >= 0; len--)
        if(filename[len] == '.')
            break;

    int sz = sizeof(char) * (len + 1);
    char* classname = (char*)malloc(sz);
    snprintf(classname, sz, ""%s"", filename); 
    return classname;
}

void* vmtranslateunit(void* input) {
    COMPILEUNIT* unit = (COMPILEUNIT*)input;

    if(unit->compiled == NULL) {
        eprintf(""Class '%s' is empty; file '%s'\n"", unit->parsed->name, unit->file->name);
        exit(1);
    }

    char* classname = getclassname(unit->file->name);
    unit->vmtranslator = mkvmtranslator(classname, unit->compiled);
    unit->asmlns = translatevm(unit->vmtranslator);
    free(classname);

    pthread_exit(NULL);
}

void waitthreads(pthread_t* threads, int amount) {
    void* status;
    int code;
    for(int i = 0; i < amount; i++) {
        code = pthread_join(threads[i], &status);
        if(code) {
            eprintf(""Error while joining thread %i: %s\n"", i, strerror(code));
            exit(code);
        }
    }
}

void actonunits(COMPILEUNIT* units, void*(*fun)(void*)) {
    pthread_t mythreads[_SC_THREAD_THREADS_MAX];
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

    COMPILEUNIT* curr = units;

    int i;
    int code;
    do {
        i = 0;
        while(curr != NULL && i < _SC_THREAD_THREADS_MAX) {
            code = pthread_create(&mythreads[i], &attr, fun, curr);

            if(code) {
                eprintf(""Error while creating thread %i: %s\n"", i, strerror(code));
                exit(code);
            }

            curr = curr->next;
            i++;
        }
        waitthreads(mythreads, i);
    } while(i == _SC_THREAD_THREADS_MAX);

    pthread_attr_destroy(&attr);
}

void freeunit(COMPILEUNIT* u) {
    freeparser(u->parser);
    freelnblk(u->compiled);
    freevmtranslator(u->vmtranslator);
    free(u);
}
",31,989,839
"#include ""assembler-tables.h""
#include ""assembler.h""
#include ""util.h""

void expandsymbols(SYMBOLARRAY* a, int toaddn);
void pushsymbol(SYMBOLARRAY* a, SYMBOL* s);
void freesymbol(SYMBOL* s);
SYMBOL* mksymbol(char* name, int namesize, int val);
int getsymbol(ASSEMBLER* a, char* name);
void skipln(ASSEMBLER* a);
void readrest(ASSEMBLER* a, int trueln);
int isvar(char* var);
void initsymbols(SYMBOLARRAY* s);
void populatevars(ASSEMBLER* a);
SYMBOL* readlabel(ASSEMBLER* a, STRINGLIST* ln, int count);
void replacevar(ASSEMBLER* a, STRINGLIST* ln, int val);
void preprocess(ASSEMBLER* a);
void transa(STRINGLIST* ln);
char* lookctable(TABLE* t, bool cond, char* token, const char* fieldname);
void transb(STRINGLIST* ln);
void assemble(ASSEMBLER* a);
void freeassembler(ASSEMBLER* a);
void strtogarbage(ASSEMBLER* a, char* str);

void strtogarbage(ASSEMBLER* a, char* str) {
    STRINGLIST* newstr = (STRINGLIST*)malloc(sizeof(STRINGLIST));
    newstr->content = str;
    newstr->next = a->garbage;
    a->garbage = newstr;
}

void expandsymbols(SYMBOLARRAY* a, int toaddn) {
    int sum = a->count + toaddn;
    if(sizeof(SYMBOL*) * sum > a->size) {
        a->size = sizeof(SYMBOL*) * sum * 3;
        a->items = (SYMBOL**)realloc(a->items, a->size);
    }
}

void pushsymbol(SYMBOLARRAY* a, SYMBOL* s) {
    expandsymbols(a, 1);
    a->items[a->count] = s;
    a->count++;
}

void freesymbol(SYMBOL* s) {
    free(s->name);
    free(s);
}

void freesymbols(SYMBOLARRAY* a) {
    for(int i = 0; i < a->count; i++)
        freesymbol(a->items[i]);
    free(a->items);
    free(a);
}

SYMBOL* mksymbol(char* name, int namesize, int val) {
    SYMBOL* s = (SYMBOL*)malloc(sizeof(SYMBOL));
    char* heapname = (char*)malloc(namesize);
    strcpy(heapname, name);
    s->name = heapname;
    s->value = val;
    return s;
}

int getsymbol(ASSEMBLER* a, char* name) {
    for(int i = 0; i < a->vars->count; i++)
        if(strcmp(a->vars->items[i]->name, name)  == 0)
            return a->vars->items[i]->value;

    for(int i = 0; i < a->labels->count; i++)
        if(strcmp(a->labels->items[i]->name, name)  == 0)
            return a->labels->items[i]->value;
    
    return -1;
}

int isvar(char* var) {
    int i = 0;
    while(1) {
        if(var[i] == '\0')
            break;
        if(!isdigit(var[i]))
            return 1;
        i++;
    }
    return 0;
}

void initsymbols(SYMBOLARRAY* s) {
    s->size = 150 * sizeof(SYMBOL*);
    s->items = (SYMBOL**)malloc(s->size);
    s->count = 0;
}

ASSEMBLER* mkassembler(STRINGLIST* input) {
    ASSEMBLER* a = (ASSEMBLER*)malloc(sizeof(ASSEMBLER));
    a->labels = (SYMBOLARRAY*)malloc(sizeof(SYMBOLARRAY));
    a->vars = (SYMBOLARRAY*)malloc(sizeof(SYMBOLARRAY));
    a->garbage = NULL;
    a->lns = input;

    initsymbols(a->labels);
    initsymbols(a->vars);

    populatevars(a);
    a->varsramind = BOTTOM_VAR;

    return a;
}

void populatevars(ASSEMBLER* a) {
    const int firstamnt = 5;
    const int ramvamnt = 16; 
    const int specialamt = 2;
    const int sum = firstamnt + ramvamnt + specialamt;

    
    expandsymbols(a->vars, sum);
    
    
    a->vars->count = sum;

    
    char* labels[] = { ""SP"", ""LCL"", ""ARG"", ""THIS"", ""THAT"" };
    for(int i = 0; i < firstamnt; i++) {
        a->vars->items[i] = mksymbol(labels[i], strlen(labels[i])+1, i);
    }

    
    const int asciioff = 48;
    char ramvname[4];
    ramvname[0] = 'R';
    ramvname[2] = '\0';
    int tmptarg = (ramvamnt/10)*10;
    for(int i = 0; i < tmptarg; i++) {
        ramvname[1] = (char)(i+asciioff);
        a->vars->items[firstamnt+i] = mksymbol(ramvname, 3, i);
    }
    ramvname[1] = '1';
    ramvname[3] = '\0';
    for(int i = 10; i < ramvamnt; i++) {
        ramvname[2] = (char)((i%10)+asciioff);
        a->vars->items[firstamnt+i] = mksymbol(ramvname, 4, i);
    }

    
    a->vars->items[firstamnt+ramvamnt] = mksymbol(""SCREEN"", 7, 16384);
    
    a->vars->items[firstamnt+ramvamnt+1] = mksymbol(""KBD"", 4, 24576);
}

SYMBOL* readlabel(ASSEMBLER* a, STRINGLIST* ln, int count) {
    int i = 1;
    char c;
    while(true) {
        c = ln->content[i];
        if(c == ')') 
            break;
        i++;
    }

    int size = i * sizeof(char);
    char* name = (char*)malloc(size);
    snprintf(name, size, ""%s"", ln->content+sizeof(char));
    SYMBOL* l = (SYMBOL*)malloc(sizeof(SYMBOL));
    l->name = name;
    l->value = count;
    return l;
}

void replacevar(ASSEMBLER* a, STRINGLIST* ln, int val) {
    int size = sizeof(char)*(countplaces(val) + 2);
    char* newln = (char *)malloc(size);
    snprintf(newln, size, ""@%i"", val);
    ln->content = newln;
    strtogarbage(a, newln);
}

void handlevarsymbol(ASSEMBLER* a, STRINGLIST* ln) {
    char* afterat = ln->content+sizeof(char);
    if(isvar(afterat)) {
        int val = getsymbol(a, afterat);
        if(val == -1) {
            if(a->varsramind == RAM_LIMIT) {
                eprintf(""Variable amount reached RAM limit (%i)\n"", RAM_LIMIT);
                exit(1);
            }
            SYMBOL* var = mksymbol(afterat, strlen(afterat)+1, a->varsramind);
            a->varsramind++;
            pushsymbol(a->vars, var);
            val = var->value;
        }
        replacevar(a, ln, val);
    }
}

void handlelabelsymbol(ASSEMBLER* a, STRINGLIST* ln, int count) {
    SYMBOL* l = readlabel(a, ln, count);

    pushsymbol(a->labels, l);
}

void stripvars(ASSEMBLER* a) {
    STRINGLIST* curln = a->lns;
    while(curln != NULL) {
        if(curln->content[0] == '@')
                handlevarsymbol(a, curln);
        curln = curln->next;
    }
}

void striplabels(ASSEMBLER* a) {
    STRINGLIST* curln = a->lns;
    STRINGLIST* lastln;
    int count = 0;
    while(curln != NULL) {
        if(curln->content[0] == '(') {
            handlelabelsymbol(a, curln, count);
            if(count > 0)
                lastln->next = curln->next;
            else
                a->lns = curln->next;
            STRINGLIST* tmp = curln;
            curln = curln->next;
            free(tmp);
        }
        else {
            lastln = curln;
            curln = curln->next;
            count++;
        }
    }
}

void preprocess(ASSEMBLER* a) {
    striplabels(a);
    stripvars(a);
}

void transa(STRINGLIST* ln) {
    int add = atoi(ln->content+sizeof(char));

    char* out = (char*)malloc(sizeof(char) * INST_SIZE);

    int lastbit = 1 << 15;
    for(int i = INST_SIZE-2; i > 0; i--) {
        if(add & (lastbit >> i))
            out[i] = '1';
        else
            out[i] = '0';
    }

    out[INST_SIZE-1] = '\0';
    out[0] = '0';

    ln->content = out;
}

char* lookctable(TABLE* t, bool cond, char* token, const char* fieldname) {
    char* out = (char*)malloc(t->instsize);

    if(!cond) {
        int targsize = t->instsize - 1;
        for(int i = 0; i < targsize; i++)
            out[i] = '0';
        out[t->instsize-1] = '\0';
        return out;
    }
    for(int i = 0; i < t->size; i++)
        if(strcmp(t->table[2*i], token) == 0) {
            strcpy(out, t->table[(2*i)+1]);
            return out;
        }
    return NULL;
}

void transb(STRINGLIST* ln) {
    bool hasjmp = false;
    bool hasdest = false;
    bool hascmp = false;
    int i = 0;
    int tmpi = 0;
    char tmp[C_TOKEN_SIZE], dest[C_TOKEN_SIZE], cmp[C_TOKEN_SIZE], jmp[C_TOKEN_SIZE];

    while(true) {
        if(ln->content[i] == '\0') {
            tmp[tmpi] = '\0';
            if(hasjmp)
                strcpy(jmp, tmp);
            else
                strcpy(cmp, tmp);
            break;
        }

        if(ln->content[i] == '=' && !hasdest && hascmp) {
            hascmp = false;
            hasdest = true;
            tmp[tmpi] = '\0';
            strcpy(dest, tmp);
            tmpi = 0;
            i++;
            continue;
        }
        if(ln->content[i] == ';' && !hasjmp && hascmp) {
            hascmp = false;
            hasjmp = true;
            tmp[tmpi] = '\0';
            strcpy(cmp, tmp);
            tmpi = 0;
            i++;
            continue;
        }
        
        hascmp = 1;
        tmp[tmpi] = ln->content[i];
        tmpi++;
        i++;
    }
    
    char* rawdest = lookctable(&desttable, hasdest, dest, ""dest"");
    char* rawjmp = lookctable(&jmptable, hasjmp, jmp, ""jump"");
    char* rawcmp = lookctable(&cmptable, 1, cmp, ""comp"");

    int sz = sizeof(char) * INST_SIZE;
    char* out = (char*)malloc(sz);
    snprintf(out, sz, ""111%s%s%s"", rawcmp, rawdest, rawjmp);

    ln->content = out;
    free(rawdest);
    free(rawjmp);
    free(rawcmp);
}

void assemble(ASSEMBLER* a) {
    STRINGLIST* currln = a->lns;
    while(currln != NULL) {
        if(currln->content[0] == '@')
            transa(currln);
        else
            transb(currln);
        currln = currln->next;
    }
}

void freeasmlns(STRINGLIST* lns) {
    if(lns != NULL) {
        free(lns->content);
        STRINGLIST* next = lns->next;
        free(lns);
        freeasmlns(next);
    }
}

void freeassembler(ASSEMBLER* a) {
    freesymbols(a->vars);
    freesymbols(a->labels);
    freeasmlns(a->lns);
    freeasmlns(a->garbage);
    free(a);
}
",31,990,3629
"#include ""vm-lines.h""

LINE* mkline(int size) {
    LINE* ln = (LINE*)malloc(sizeof(LINE));
    ln->tokens = (char**)malloc(sizeof(char*)*size);
    ln->count = 0;
    return ln;
}

void addtoken(LINE* ln, char* token) {
    ln->tokens[ln->count] = token;
    ln->count++;
}

void println(LINE* ln, FILE* stream) {
    for(int i = 0; i < ln->count; i++) {
        fprintf(stream, ""%s"", ln->tokens[i]);
        if(i + 1 < ln->count)
            fprintf(stream, "" "");
    }
    fprintf(stream, ""\n"");
}

void printlns(LINE* lns, FILE* stream) {
    while(lns != NULL) {
        println(lns, stream);
        lns = lns->next;
    }
}

void freeln(LINE* ln) {
    for(int i = 0; i < ln->count; i++)
        free(ln->tokens[i]);
    free(ln->tokens);
    free(ln);
}

void freelns(LINE* lns) {
    LINE* next = lns->next;
    freeln(lns);
    if(next != NULL)
        freelns(next);
}

void freelnblk(LINEBLOCK* blk) {
    freelns(blk->head);
    free(blk);
}

LINEBLOCK* mklnblk(LINE* start) {
    LINEBLOCK* blk = (LINEBLOCK*)malloc(sizeof(LINEBLOCK));
    blk->head = start;
    blk->tail = start;
    return blk;
}

LINEBLOCK* mergelnblks(LINEBLOCK* head, LINEBLOCK* tail) {
    if(head == NULL)
        return tail;
    head->tail->next = tail->head;
    head->tail = tail->tail;
    free(tail);
    return head;
}

void appendln(LINEBLOCK* lnblk, LINE* ln) {
    lnblk->tail->next = ln;
    lnblk->tail = ln;
}

void appendlnbefore(LINEBLOCK* lnblk, LINE* ln) {
    ln->next = lnblk->head;
    lnblk->head = ln;
}
",31,991,645
"#include ""util.h""

char* heapstr(const char* str, int len) {
    int size = sizeof(char) * (len + 1);
    char* outstr = (char*)malloc(size);
    strcpy(outstr, str);
    return outstr;
}

char* ezheapstr(const char* str) {
    return heapstr(str, strlen(str));
}

void* copy(void* v, int size) {
    void* copy = malloc(size);
    memcpy(copy, v, size);
    return copy;
}

int countplaces(int n) {
    int places = 1;
    int divisor = 1;
    if(n < 0) {
        n = -n;
        places++;
    }
    while(n / divisor >= 10) {
        places++;
        divisor *= 10;
    }
    return places;
}

char* itoa(int i) {
    int size = sizeof(char)*(countplaces(i)+1);
    char* a = (char*)malloc(size);
    sprintf(a, ""%i"", i);
    return a;
}

char* dotlabel(char* n1, char* n2) {
    int sz = (strlen(n1) + strlen(n2) + 2) * sizeof(char);
    char* result = (char*)malloc(sz);
    sprintf(result, ""%s.%s"", n1, n2);
    return result;
}

STRINGLIST* onestr(const char* str) {
    STRINGLIST* strlist = (STRINGLIST*)malloc(sizeof(STRINGLIST));
    strlist->content = ezheapstr(str);
    strlist->next = NULL;
    return strlist;
}

STRINGLIST* initstrlist(const char** strs, int count) {
    STRINGLIST* strlist = (STRINGLIST*)malloc(sizeof(STRINGLIST));
    STRINGLIST* curr = strlist;
    for(int i = 0; i < count-1; i++) {
        curr->content = ezheapstr(strs[i]);
        curr->next = (STRINGLIST*)malloc(sizeof(STRINGLIST));
        curr = curr->next;
    }
    curr->content = ezheapstr(strs[count-1]);
    curr->next = NULL;
    return strlist;
}

void printstrlist(STRINGLIST* strlist, FILE* stream) {
    while(strlist != NULL) {
        fprintf(stream, ""%s\n"", strlist->content);
        strlist = strlist->next;
    }
}

void freestrlist(STRINGLIST* strlist) {
    STRINGLIST* next = strlist->next;
    free(strlist);
    if(next != NULL)
        freestrlist(next);
}

bool existsinarray(STRINGARRAY* arr, const char* item) {
    for(int i = 0; i < arr->size; i++)
        if(!strcmp(arr->items[i], item))
            return true;
    return false;
}
",31,992,768
"#include ""util.h""
#include ""parser-util.h""
#include ""parser-expressions.h""

    const char* keywordsarr[] = { ""true"", ""false"", ""null"", ""this"" };
    const char* opsarr[] = { ""+"", ""-"", ""*"", ""/"", ""&"", ""|"", ""<"", "">"", ""="" };
    mkstrlist(keywordconstants, keywordsarr);
mkstrlist(operators, opsarr);




bool isop(TOKEN* t);


TERM* parsetermnullified(PARSER* p);
TERM* parseterm(PARSER* p);
TERM* mkterm(TERMTYPE type);
TERM* parseint(PARSER* p);
TERM* parsestr(PARSER* p);
TERM* parsekeyword(PARSER* p);
TERM* parseunaryopterm(PARSER* p);
TERM* parseinnerexpression(PARSER* p);
TERM* parsecalltermnullified(PARSER* p);
TERM* parsearrayterm(PARSER* p);
TERM* parsevarterm(PARSER* p);
TERM* parseidentifierterm(PARSER* p);
SUBROUTCALL* nullsubroutcall(PARSER* p, SUBROUTCALL* c);
SUBROUTCALL* parsesubroutcallnullified(PARSER* p);




bool isop(TOKEN* t) {
    for(int i = 0; i < operators.size; i++)
        if(!strcmp(t->token, operators.items[i]))
            return true;
    return false;
}


TERM* parsetermnullified(PARSER* p) {
    TOKENTYPE type = p->current->type;
    if(type == integer) return parseint(p);
    if(type == string) return parsestr(p);
    if(type == keyword) return parsekeyword(p);
    if(type == identifier) return parseidentifierterm(p);
    if(equals(p, ""-"") || equals(p, ""~"")) return parseunaryopterm(p);
    if(equals(p, ""("")) return parseinnerexpression(p);
    return NULL;
}

TERM* parseterm(PARSER* p) {
    TERM* t = parsetermnullified(p);
    if(t == NULL)
        unexpected(p);
    return t;
}

TERM* mkterm(TERMTYPE type) {
    TERM* t = (TERM*)malloc(sizeof(TERM));
    t->type = type;
    return t;
}

TERM* parseint(PARSER* p) {
    TERM* t = mkterm(intconstant);
    t->integer = atoi(p->current->token);
    next(p);
    return t;
}

TERM* parsestr(PARSER* p) {
    TERM* t = mkterm(stringconstant);
    t->string = p->current->token;
    next(p);
    return t;
}

TERM* parsekeyword(PARSER* p) {
    TERM* t = mkterm(keywordconstant);
    if(!existsinarray(&keywordconstants, p->current->token))
        unexpected(p);
    t->string = p->current->token;
    next(p);
    return t;
}

TERM* parseunaryopterm(PARSER* p) {
    TERM* t = mkterm(unaryopterm);
    t->unaryop = p->current->token[0];
    next(p);
    t->expression = parseterm(p);
    t->expression->next = NULL;
    return t;
}

TERM* parseinnerexpression(PARSER* p) {
    TERM* t = mkterm(innerexpression);
    next(p);
    t->expression = parseexpression(p);
    checkcontent(p, "")"");
    return t;
}

TERM* parsecalltermnullified(PARSER* p) {
    SUBROUTCALL* call = parsesubroutcallnullified(p);
    if(call == NULL)
        return NULL;
    TERM* t = mkterm(subroutcall);
    t->call = call;
    return t;
}

TERM* parsearrayterm(PARSER* p) {
    TERM* t = mkterm(arrayitem);
    t->array = (ARRAY*)malloc(sizeof(ARRAY));
    t->array->name = p->current->token;
    next(p);
    checkcontent(p, ""["");
    t->array->exp = parseexpression(p);
    checkcontent(p, ""]"");
    return t;
}

TERM* parsevarterm(PARSER* p) {
    TERM* t = mkterm(varname);
    t->string = p->current->token;
    next(p);
    return t;
}

TERM* parseidentifierterm(PARSER* p) {
    TERM* t = parsecalltermnullified(p);
    if(t == NULL)
        if(nextequals(p, ""[""))
            return parsearrayterm(p);
        else
            return parsevarterm(p);
    else
        return t;
}

TERM* parseexpressionnullified(PARSER* p) {
    TERM* head = parsetermnullified(p);
    TERM* current = head;
    TERM* nextt;
    while(isop(p->current)) {
        current->op = p->current->token[0]; 
        next(p);
        nextt = parseterm(p);
        current->next = nextt;
        current = nextt;
    }
    if(current != NULL)
        current->next = NULL;
    return head;
}

TERM* parseexpression(PARSER* p) {
    TERM* t = parseexpressionnullified(p);
    if(t == NULL)
        unexpected(p);
    return t;
}

SUBROUTCALL* nullsubroutcall(PARSER* p, SUBROUTCALL* c) {
    free(c->debug);
    free(c);
    rewindparser(p);
    return NULL;
}

SUBROUTCALL* parsesubroutcallnullified(PARSER* p) {
    if(p->current->type != identifier)
        return NULL;

    anchorparser(p);
    SUBROUTCALL* c = (SUBROUTCALL*)malloc(sizeof(SUBROUTCALL));

    c->debug = getdebug(p);

    if(nextequals(p, ""."")) {
        c->parentname = p->current->token;
        next(p);
        next(p);
    }
    else
        c->parentname = NULL;

    if(p->current->type != identifier)
        return nullsubroutcall(p, c);
    c->name = p->current->token;
    next(p);

    if(differs(p, ""(""))
        return nullsubroutcall(p, c);
    next(p);

    c->parameters = parseexpressionlist(p);

    if(differs(p, "")""))
        return nullsubroutcall(p, c);
    next(p);
    return c;
}

SUBROUTCALL* parsesubroutcall(PARSER* p) {
    SUBROUTCALL* c = (SUBROUTCALL*)malloc(sizeof(SUBROUTCALL));
    c->debug = getdebug(p);

    if(nextequals(p, ""."")) {
        c->parentname = parseidentifier(p);
        next(p);
    }
    else
        c->parentname = NULL;

    c->name = parseidentifier(p);

    checkcontent(p, ""("");

    c->parameters = parseexpressionlist(p);

    checkcontent(p, "")"");
    return c;
}

EXPRESSIONLIST* parseexpressionlist(PARSER* p) {
    if(!strcmp(p->current->token, "")""))
        return NULL;
    EXPRESSIONLIST* head = (EXPRESSIONLIST*)malloc(sizeof(EXPRESSIONLIST));
    head->expression = parseexpressionnullified(p);
    EXPRESSIONLIST* current = head;
    EXPRESSIONLIST* nextls;
    while(!strcmp(p->current->token, "","")) {
        next(p);
        nextls = (EXPRESSIONLIST*)malloc(sizeof(EXPRESSIONLIST));
        nextls->expression = parseexpression(p);
        current->next = nextls;
        current = nextls;
    }
    if(current != NULL)
        current->next = NULL;
    return head;
}
",31,993,2155
"#include ""tokenizer.h""
#include ""tokenizer-tables.h""


typedef enum {
    common, charsymbol, space
} CHARTYPE;

typedef struct {
    char* str;
    int size;
    int count;
} STRING;


STRING* mkstring(int size);
void append(STRING* s, char c);
void freestr(STRING* str);


TOKEN* appendtokenraw(TOKEN* curitem, STRING* token, int definedat, TOKENTYPE type);
TOKEN* appendtoken(TOKEN* curitem, STRING* token, char* file, int definedat);
#define mktoken() (TOKEN*)malloc(sizeof(TOKEN))


CHARTYPE getchartype(unsigned char c);
bool iskeyword(STRING* tk);
bool issymbol(STRING* tk);
bool isint(char* str);
bool isintcons(STRING* tk);
bool isidentifier(STRING* tk);
TOKENTYPE gettokentype(STRING* tk, char* file, int definedat);


void skipln(FILE* input);
void skipmultiln(FILE* input, int* lnscount);
bool handlecomment(FILE* input, int* lnscount);
void readstr(FILE* input, STRING* tmp, int definedat);


STRING* mkstring(int size) {
    STRING* str = (STRING*)malloc(sizeof(STRING));
    str->size = sizeof(char) * size; 
    str->str = (char*)malloc(str->size);
    str->count = 0;
    return str;
}

void append(STRING* s, char c) {
    int targsize = sizeof(char) * (s->count + 1);
    if(s->size <= targsize) {
        s->size = targsize * 2;
        s->str = (char*)realloc(s->str, s->size);
    }

    s->str[s->count] = c;
    s->count++;
}

void freestr(STRING* str) {
    free(str->str);
    free(str);
}


TOKEN* appendtokenraw(TOKEN* curitem, STRING* token, int definedat, TOKENTYPE type) {
    curitem->token = (char*)malloc(sizeof(char)*token->count);
    strcpy(curitem->token, token->str);
    curitem->definedat = definedat;
    curitem->type = type;
    TOKEN* nextitem = mktoken();
    curitem->next = nextitem;
    token->count = 0;
    return nextitem;
}

void freetokens(TOKEN* t) {
    free(t->token);
    TOKEN* next = t->next;
    free(t);
    if(next != NULL)
        freetokens(next);
}

TOKEN* appendtoken(TOKEN* curitem, STRING* token, char* file, int definedat) {
    append(token, '\0');
    return appendtokenraw(curitem, token, definedat, gettokentype(token, file, definedat));
}


CHARTYPE getchartype(unsigned char c) {
    if(isspace(c)) return space;
    if(isalnum(c) || c == '_' || c == '""') return common;
    return charsymbol;
}

bool iskeyword(STRING* tk) {
    return existsinarray(&keywords, tk->str);
}

bool issymbol(STRING* tk) {
    if(tk->count != 2)
        return false;
    return existsinarray(&symbols, tk->str);
}

bool isint(char* str) {
    int i = 0;
    while(str[i] != '\0') {
        if(!isdigit(str[i]))
            return false;
        i++;
    }
    return true;
}

bool isintcons(STRING* tk) {
    if(!isint(tk->str))
        return false;
    int val = atoi(tk->str);
    return val <= 65535;
}

bool isidentifier(STRING* tk) {
    if(isdigit(tk->str[0]))
        return false;

    int count = tk->count - 1;
    for(int i = 0; i < count; i++)
        if(!isalnum(tk->str[i]) && tk->str[i] != '_')
            return false;
    return true;
}

TOKENTYPE gettokentype(STRING* tk, char* file, int definedat) {
    if(iskeyword(tk)) return keyword;
    if(issymbol(tk)) return symbol;
    if(isintcons(tk)) return integer;
    if(isidentifier(tk)) return identifier;
    eprintf(""Unexpected token '%s'; file '%s', line %i\n"", tk->str, file, definedat);
    exit(1);
}


void skipln(FILE* input) {
    unsigned char c;
    while(c = fgetc(input), c != '\0')
        if(c == '\n')
            break;
}

void skipmultiln(FILE* input, int* lnscount) {
    unsigned char c;
    while(c = fgetc(input), c != '\0')
        if(c == '\n')
            (*lnscount)++;
        else if(c == '*')
            if(fgetc(input) == '/')
                break;
}

bool handlecomment(FILE* input, int* lnscount) {
    unsigned char nextc = fgetc(input);
    if(nextc == '/') {
        skipln(input);
        (*lnscount)++;
        return true;
    }
    else if(nextc == '*') {
        unsigned char furtherc = fgetc(input);
        if(furtherc == '*') {
            skipmultiln(input, lnscount);
            return true;
        }
        ungetc(furtherc, input);
    }
    ungetc(nextc, input);
    return false;
}

void readstr(FILE* input, STRING* tmp, int definedat) {
    unsigned char c;
    while(c = fgetc(input), c != '\0') {
        if(c == '\n') {
            eprintf(""Unexpected end of line; line %i"", definedat);
            exit(1);
        }
        if(c == '""')
            break;
        append(tmp, c);
    }
    append(tmp, '\0');
}

TOKEN* tokenize(char* file) {
    TOKEN* head = mktoken();
    TOKEN* lastitem = head;
    TOKEN* curitem = head;

    STRING* tmptoken = mkstring(200);
    CHARTYPE lasttype = space;
    CHARTYPE curtype;

    int lnscount = 1;
    FILE* input = fopen(file, ""r"");
    
    unsigned char c;
    while(!feof(input)) {
        c = fgetc(input);
        if(c == '\n')
            lnscount++;
        else if(c == '/' && handlecomment(input, &lnscount)) 
            continue;
        else if(c == '""') {
            if(lasttype != space)
                curitem = appendtoken(curitem, tmptoken, file, lnscount);
            readstr(input, tmptoken, lnscount);
            lastitem = curitem;
            curitem = appendtokenraw(curitem, tmptoken, lnscount, string);
            lasttype = space;
            continue;
        }

        curtype = getchartype(c);

        if(curtype == common) {
            if(lasttype == charsymbol) {
                lastitem = curitem;
                curitem = appendtoken(curitem, tmptoken, file, lnscount);
            }
            append(tmptoken, c);
        } else {
            if(lasttype != space){
                lastitem = curitem;
                curitem = appendtoken(curitem, tmptoken, file, lnscount);
            }
            if(curtype == charsymbol)
                append(tmptoken, c);
        }
        lasttype = curtype;
    }

    if(curitem == head) {
        eprintf(""File '%s' is empty\n"", file);
        exit(1);
    }

    lastitem->next = NULL;
    free(curitem);
    freestr(tmptoken);
    fclose(input);
    return head;
}
",31,994,2162
"#include ""util.h""
#include ""io.h""


#ifndef PATH_MAX
#ifdef __linux__

#else
#define PATH_MAX 512
#endif
#endif

char* strtail(char* str, int len, int count) {
    int index = len - count;
    if (index <= 0) return str;
    return str + (sizeof(char) * (index));
}

char* strhead(char* str, int count) {
    return str + (sizeof(char) * count);
}

char* trimstr(char* str, int len, int end) {
    int count = len - end;
    char oldchar = str[count];
    str[count] = '\0';
    char* newstr = (char*)malloc(sizeof(char) * (1 + count));
    strcpy(newstr, str);
    str[count] = oldchar;
    return newstr;
}

char* getname(char* f, int len) {
    int startind = 0;
    int endind = len - 1;
    bool readsmt = false;
 
    for(int i = endind; i >= 0; i--) {
        if(f[i] == '/') {
            if(!readsmt) {
                endind = i-1;
                f[i] = '\0';
                continue;
            }
            startind = i+1;
            break;
        }
        readsmt = true;
    }

    int sz = sizeof(char)*(endind - startind + 2);
    char* startstr = strhead(f, startind);
    char* retstr = (char*)malloc(sz);
    snprintf(retstr, sz, ""%s"", startstr);
    return retstr;
}

char* getfullname(char* fname, int fnamelen, char* dirname, int dirlen) {
    int sz = sizeof(char)*(fnamelen+dirlen+2);
    char* fullname = (char*)malloc(sz);
    sprintf(fullname, ""%s/%s"", dirname, fname);
    return fullname;
}

bool isdotjack(char* f, int len) {
    const char* ext = "".jack"";
    return strcmp(strtail(f, len, strlen(ext)), ext) == 0;
}

bool isdir(char* f) {
    bool readsmt = false;
    for(int i = strlen(f)-1; i >= 0; i--) {
        if(f[i] == '.') {
            if(readsmt)
                return false;
            else
                continue;
        }
        if(f[i] == '/')
            return 1;
        readsmt = true;
    }
    return true;
}

char* getoutname(char* fullname, int len) {
    char* trimmed = trimstr(fullname, len, 4);
    int sz = sizeof(char) * (len-1);
    char* outname = (char*)malloc(sz);
    snprintf(outname, sz, ""%svm"", trimmed);
    free(trimmed);
    return outname;
}

FILELIST* addfile(FILELIST* l, char* fullname, char* name) {
    FILELIST* new = (FILELIST*)malloc(sizeof(FILELIST));
    new->name = name;
    new->fullname = fullname;
    new->next = l;
    new->outname = getoutname(fullname, strlen(fullname));
    return new;
}

FILELIST* getfilesfromdir(char* dir) {
    FILELIST* filelist = NULL;
    DIR* d = opendir(dir);

    if(d == NULL) {
        eprintf(""Error while opening directory '%s': %s\n"", dir, strerror(errno));
        exit(errno);
    }

    int len = strlen(dir);
    struct dirent* thisfile;
    while(thisfile = readdir(d), thisfile != NULL) {
        int thislen = strlen(thisfile->d_name);
        if(isdotjack(thisfile->d_name, thislen)) {
            char* fullname = getfullname(thisfile->d_name, thislen, dir, len);
            char* name = ezheapstr(thisfile->d_name);
            filelist = addfile(filelist, fullname, name);
        }
    }
    
    closedir(d);

    if(filelist == NULL) {
        eprintf(""Directory '%s' doesn't have any .jack file\n"", dir);
        exit(1);
    }
    return filelist;
}

FILELIST* getsinglefile(char* file) {
    int len = strlen(file);
    if(isdotjack(file, len)){
        char* name = getname(file, len);
        char* fullname = heapstr(file, len);

        FILE* input = fopen(fullname, ""r"");
        if(input == NULL) {
            eprintf(""Error while reading file '%s': %s\n"", file, strerror(errno));
            exit(errno);
        }
        fclose(input);

        return addfile(NULL, fullname, name);
    }
    else {
        eprintf(""Input file must be named like 'Xxx.vm'\n"");
        exit(1);
    }
}

FILELIST* getfiles(char* input) {
    if(isdir(input))
        return getfilesfromdir(input);
    else
        return getsinglefile(input);
}

void freefilelist(FILELIST* fs) {
    free(fs->name);
    free(fs->fullname);
    free(fs->outname);
    FILELIST* next = fs->next;
    free(fs);
    if(next != NULL)
        freefilelist(next);
}

char* getouthack(char* input) {
    char* out;
    int inplen = strlen(input);
    if(isdir(input)) {
        char* name = getname(input, inplen);
        int sz = (inplen + strlen(name) + 7) * sizeof(char);
        out = (char*)malloc(sz);
        sprintf(out, ""%s/%s.hack"", input, name);
        free(name);
    }
    else {
        out = heapstr(input, inplen);
        out[inplen-4] = 'h';
    }
    return out;
}
",31,995,1631
"#include ""util.h""

char* heapstr(const char* str, int len) {
    int size = sizeof(char) * (len + 1);
    char* outstr = (char*)malloc(size);
    strcpy(outstr, str);
    return outstr;
}

char* ezheapstr(const char* str) {
    return heapstr(str, strlen(str));
}

void* copy(void* v, int size) {
    void* copy = malloc(size);
    memcpy(copy, v, size);
    return copy;
}

int countplaces(int n) {
    int places = 1;
    int divisor = 1;
    if(n < 0) {
        n = -n;
        places++;
    }
    while(n / divisor >= 10) {
        places++;
        divisor *= 10;
    }
    return places;
}

char* itoa(int i) {
    int size = sizeof(char)*(countplaces(i)+1);
    char* a = (char*)malloc(size);
    snprintf(a, size, ""%i"", i);
    return a;
}

char* dotlabel(char* n1, char* n2) {
    int sz = (strlen(n1) + strlen(n2) + 2) * sizeof(char);
    char* result = (char*)malloc(sz);
    sprintf(result, ""%s.%s"", n1, n2);
    return result;
}

STRINGLIST* onestr(const char* str) {
    STRINGLIST* strlist = (STRINGLIST*)malloc(sizeof(STRINGLIST));
    strlist->content = ezheapstr(str);
    strlist->next = NULL;
    return strlist;
}

STRINGLIST* initstrlist(const char** strs, int count) {
    STRINGLIST* strlist = (STRINGLIST*)malloc(sizeof(STRINGLIST));
    STRINGLIST* curr = strlist;
    for(int i = 0; i < count-1; i++) {
        curr->content = ezheapstr(strs[i]);
        curr->next = (STRINGLIST*)malloc(sizeof(STRINGLIST));
        curr = curr->next;
    }
    curr->content = ezheapstr(strs[count-1]);
    curr->next = NULL;
    return strlist;
}

void printstrlist(STRINGLIST* strlist, FILE* stream) {
    while(strlist != NULL) {
        fprintf(stream, ""%s\n"", strlist->content);
        strlist = strlist->next;
    }
}

void freestrlist(STRINGLIST* strlist) {
    STRINGLIST* next = strlist->next;
    free(strlist);
    if(next != NULL)
        freestrlist(next);
}

bool existsinarray(STRINGARRAY* arr, const char* item) {
    for(int i = 0; i < arr->size; i++)
        if(!strcmp(arr->items[i], item))
            return true;
    return false;
}
",31,996,770
"#include ""compiler-structure.h""
#include ""compiler.h""


LINEBLOCK* compileclass(COMPILER* c, CLASS* class) {
    SCOPE* topscope = mkscope(c->globalscope);
    if(class->vardecs != NULL)
        addclassvardecs(topscope, class->vardecs);
    if(class->subroutdecs != NULL)
        topscope->subroutines = class->subroutdecs;

    LINEBLOCK* output = NULL;
    SUBROUTDEC* curr = class->subroutdecs;
    while(curr != NULL) {
        output = mergelnblks(output, compilesubroutdec(topscope, class, curr));
        curr = curr->next;
    }
    freescope(topscope);
    return output;
}

COMPILER* mkcompiler(CLASS* classes) {
    COMPILER* c = (COMPILER*)malloc(sizeof(COMPILER));
    c->globalscope = mkscope(NULL);
    c->globalscope->compiler = c;
    c->globalscope->classes = classes;
    c->classes = classes;
    pthread_mutex_init(&(c->ifmutex), NULL);
    pthread_mutex_init(&(c->whilemutex), NULL);
    pthread_mutex_init(&(c->staticmutex), NULL);
    return c;
}

void freecompiler(COMPILER* c) {
    pthread_mutex_destroy(&(c->ifmutex));
    pthread_mutex_destroy(&(c->whilemutex));
    pthread_mutex_destroy(&(c->staticmutex));
    freescope(c->globalscope);
    free(c);
}
",31,997,446
"#include ""parser-expressions.h""
#include ""parser-util.h""
#include ""parser-statements.h""




STATEMENT* mkstatement(PARSER* p, STATEMENTTYPE t);

STATEMENT* parsestatementnullified(PARSER* p);
STATEMENT* parselet(PARSER* p);
CONDSTATEMENT* parsecond(PARSER* p);
STATEMENT* parseif(PARSER* p);
STATEMENT* parsewhile(PARSER* p);
STATEMENT* parsedo(PARSER* p);
STATEMENT* parsereturn(PARSER* p);




STATEMENT* mkstatement(PARSER* p, STATEMENTTYPE t) {
    STATEMENT* s = (STATEMENT*)malloc(sizeof(STATEMENT));
    s->type = t;
    s->debug = getdebug(p);
    return s;
}




STATEMENT* parsestatementnullified(PARSER* p) {
    if(equals(p, ""let"")) return parselet(p);
    if(equals(p, ""if"")) return parseif(p);
    if(equals(p, ""while"")) return parsewhile(p);
    if(equals(p, ""do"")) return parsedo(p);
    if(equals(p, ""return"")) return parsereturn(p);
    return NULL;
}

STATEMENT* parsestatements(PARSER* p) {
    STATEMENT* head = parsestatementnullified(p);
    STATEMENT* curr = head;
    STATEMENT* next;
    while(next = parsestatementnullified(p), next != NULL) {
        curr->next = next;
        curr = next;
    }
    if(curr != NULL)
        curr->next = NULL;
    return head;
}

STATEMENT* parselet(PARSER* p) {
    next(p);
    STATEMENT* s = mkstatement(p, letstatement);
    LETSTATEMENT* letst = (LETSTATEMENT*)malloc(sizeof(LETSTATEMENT));

    letst->varname = parseidentifier(p);
    
    if(equals(p, ""["")) {
        next(p);
        letst->arrayind = parseexpression(p);
        checkcontent(p, ""]"");
    }
    else
        letst->arrayind = NULL;

    checkcontent(p, ""="");

    letst->expression = parseexpression(p);

    checkcontent(p, "";"");

    s->type = letstatement;
    s->letstatement = letst;
    return s;
}

CONDSTATEMENT* parsecond(PARSER* p) {
    checkcontent(p, ""("");

    CONDSTATEMENT* st = (CONDSTATEMENT*)malloc(sizeof(CONDSTATEMENT));

    st->expression = parseexpression(p);

    checkcontent(p, "")"");
    checkcontent(p, ""{"");

    st->statements = parsestatements(p);

    checkcontent(p, ""}"");
    return st;
}

STATEMENT* parseif(PARSER* p) {
    next(p);
    STATEMENT* s = mkstatement(p, ifstatement);
    IFSTATEMENT* ifst = (IFSTATEMENT*)malloc(sizeof(IFSTATEMENT));

    ifst->base = parsecond(p);

    if(equals(p, ""else"")) {
        next(p);
        checkcontent(p, ""{"");
        ifst->elsestatements = parsestatements(p);
        checkcontent(p, ""}"");
    }
    else
        ifst->elsestatements = NULL;

    s->type = ifstatement;
    s->ifstatement = ifst;
    return s;
}

STATEMENT* parsewhile(PARSER* p) {
    next(p);
    STATEMENT* s = mkstatement(p, whilestatement);

    s->whilestatement = parsecond(p);
    return s;
}

STATEMENT* parsedo(PARSER* p) {
    next(p);
    STATEMENT* s = mkstatement(p, dostatement);

    s->dostatement = parsesubroutcall(p);

    checkcontent(p, "";"");
    return s;
}

STATEMENT* parsereturn(PARSER* p) {
    next(p);
    STATEMENT* s = mkstatement(p, returnstatement);

    s->retstatement = parseexpressionnullified(p);

    checkcontent(p, "";"");
    return s;
}
",31,998,1130
"#include ""vm-templates.h""
#include ""vm-translator.h""
#include ""util.h""
#define eq(translator, index, str) !strcmp(translator->currln->tokens[index], str)

STRINGLIST* asmln(char* content) {
    STRINGLIST* ln = (STRINGLIST*)malloc(sizeof(STRINGLIST));
    ln->content = content;
    return ln;
}

void togarbage(VMTRANSLATOR* t, char* str) {
    STRINGLIST* garb = asmln(str);
    garb->next = t->garbage;
    t->garbage = garb;
}

char* atraw(VMTRANSLATOR* t, char* n, int len) {
    int sz = sizeof(char) * (len + 2);
    char* atstr = (char*)malloc(sz);
    sprintf(atstr, ""@%s"", n);
    togarbage(t, atstr);
    return atstr;
}

char* at(VMTRANSLATOR* t, char* n) {
    return atraw(t, n, strlen(n));
}

char* atn(VMTRANSLATOR* t, int n) {
    char* str = itoa(n);
    togarbage(t, str);
    return at(t, str);
}

char* mkstr(VMTRANSLATOR* t, char* str) {
    char* heapstr = ezheapstr(str);
    togarbage(t, heapstr);
    return heapstr;
}

char* mkpointerind(VMTRANSLATOR* t) {
    if(t->currln->tokens[2][0] == 0)
        return mkstr(t, ""@THIS"");
    else
        return mkstr(t, ""@THAT"");
}

char* mktempind(VMTRANSLATOR* t) {
    int index = atoi(t->currln->tokens[2]);
    char* actualind = itoa(index+5);    
    togarbage(t, actualind);
    return at(t, actualind);
}

char* dotat(VMTRANSLATOR* t, char* name, char* n) {
    int sz = sizeof(char) * (strlen(name) + strlen(n) + 3);
    char* atstr = (char*)malloc(sz);
    sprintf(atstr, ""@%s.%s"", name, n);
    togarbage(t, atstr);
    return atstr;
}

char* switchsegment(VMTRANSLATOR* t) {
    if(eq(t, 1, ""local""))
        return mkstr(t, ""@LCL"");
    if(eq(t, 1, ""argument""))
        return mkstr(t, ""@ARG"");
    if(eq(t, 1, ""this""))
        return mkstr(t, ""@THIS"");
    return mkstr(t, ""@THAT"");
}

char* mkspeciallab(VMTRANSLATOR* t, char* suffix, int* ind, int* len) {
    (*ind)++;
    *len = t->classnamelen + countplaces(*ind) + strlen(suffix) + 2;
    int sz = ((*len)+1) * sizeof(char);
    char* lab = (char*)malloc(sz);
    sprintf(lab, ""%s$%s.%i"", t->classname, suffix, (*ind));
    togarbage(t, lab);
    return lab;
}

char* mkcmplab(VMTRANSLATOR* t, int* len) {
    return mkspeciallab(t, ""cmp"", &(t->cmpind), len);
}

char* mkretlab(VMTRANSLATOR* t, int* len) {
    return mkspeciallab(t, ""ret"", &(t->retind), len);
}

char* enclosingparenthesis(VMTRANSLATOR* t, char* content, int len) {
    int sz = sizeof(char) * (len + 3);
    char* str = (char*)malloc(sz);
    sprintf(str, ""(%s)"", content);
    togarbage(t, str);
    return str;
}

char* mklab(VMTRANSLATOR* t) {
    int sz = (t->classnamelen + strlen(t->currln->tokens[1]) + 4) * sizeof(char);
    char* lab = (char*)malloc(sz);
    sprintf(lab, ""(%s$%s)"", t->classname, t->currln->tokens[1]);
    togarbage(t, lab);
    return lab;
}

char* mkgotolab(VMTRANSLATOR* t) {
    int sz = sizeof(char) * (t->classnamelen + strlen(t->currln->tokens[1]) + 3);
    char* lab = (char*)malloc(sz);
    sprintf(lab, ""@%s$%s"", t->classname, t->currln->tokens[1]);
    togarbage(t, lab);
    return lab;
}

ASMBLK* copytemplate(TEMPLATE* t) {
    ASMBLK* blk = (ASMBLK*)malloc(sizeof(ASMBLK));
    blk->head = asmln(t->items[0]);
    STRINGLIST* curr = blk->head;
    for(int i = 1; i < t->count; i++) {
        STRINGLIST* newln = asmln(t->items[i]);
        curr->next = newln;
        curr = newln;
    }
    curr->next = NULL;
    blk->tail = curr;
    return blk;
}

void mergeasmblks(ASMBLK* a, ASMBLK* b) {
    a->tail->next = b->head;
    a->tail = b->tail;
    free(b);
}





ASMBLK* translatepushconst(VMTRANSLATOR* t) {
    
    tpushcons.items[0] = at(t, t->currln->tokens[2]);

    return copytemplate(&tpushcons);
}

ASMBLK* translatepushstatic(VMTRANSLATOR* t) {
    
    tpushstat.items[0] = dotat(t, t->classname, t->currln->tokens[2]);

    return copytemplate(&tpushstat);
}

ASMBLK* translatepushpointer(VMTRANSLATOR* t) {
    
    tpushpointer.items[0] = mkpointerind(t);

    return copytemplate(&tpushpointer);
}

ASMBLK* translatepushtemp(VMTRANSLATOR* t) {
    
    tpushtemp.items[0] = mktempind(t);

    return copytemplate(&tpushtemp);
}

void pushpopcommon(VMTRANSLATOR* t, TEMPLATE* tp) {
    
    tp->items[0] = switchsegment(t);
    
    
    tp->items[1] = mkstr(t, ""D=M"");

    
    tp->items[2] = at(t, t->currln->tokens[2]);
}

ASMBLK* translatepushgeneric(VMTRANSLATOR* t) {
    pushpopcommon(t, &tpush);

    return copytemplate(&tpush);
}

ASMBLK* translatepush(VMTRANSLATOR* t) {
    if(eq(t, 1, ""constant""))
        return translatepushconst(t);
    if(eq(t, 1, ""static""))
        return translatepushstatic(t);
    if(eq(t, 1, ""pointer""))
        return translatepushpointer(t);
    if(eq(t, 1, ""temp""))
        return translatepushtemp(t);
    return translatepushgeneric(t);
}

ASMBLK* translatepopstatic(VMTRANSLATOR* t) {
    
    tpopstat.items[tpopstat.count-2] = dotat(t, t->classname, t->currln->tokens[2]);

    
    tpopstat.items[tpopstat.count-1] = mkstr(t, ""M=D"");

    return copytemplate(&tpopstat);
}

ASMBLK* translatepoppointer(VMTRANSLATOR* t) {
    
    tpoppointer.items[tpoppointer.count-2] = mkpointerind(t);

    
    tpoppointer.items[tpoppointer.count-1] = mkstr(t, ""M=D"");

    return copytemplate(&tpoppointer);
}

ASMBLK* translatepoptemp(VMTRANSLATOR* t) {
    
    tpoptemp.items[tpoptemp.count-2] = mktempind(t);

    tpoptemp.items[tpoptemp.count-1] = mkstr(t, ""M=D"");

    return copytemplate(&tpoptemp);
}

ASMBLK* translatepopgeneric(VMTRANSLATOR* t) {
    pushpopcommon(t, &tpop);
    
    return copytemplate(&tpop);
}

ASMBLK* translatepop(VMTRANSLATOR* t) {
    if(eq(t, 1, ""static""))
        return translatepopstatic(t);
    if(eq(t, 1, ""pointer""))
        return translatepoppointer(t);
    if(eq(t, 1, ""temp""))
        return translatepoptemp(t);
    return translatepopgeneric(t);
}






ASMBLK* translatearith(VMTRANSLATOR* t, char* op) {
    tarith.items[tarith.count-1] = mkstr(t, op);

    return copytemplate(&tarith);
}

ASMBLK* translatecomp(VMTRANSLATOR* t, char* op) {
    int labellen;
    char* label = mkcmplab(t, &labellen);

    
    tcomp.items[tcomp.count-6] = atraw(t, label, labellen);
    
    
    int sz = sizeof(char) * 6;
    char* trueop = (char*)malloc(sz);
    sprintf(trueop, ""D;J%s"", op);
    tcomp.items[tcomp.count-5] = trueop;
    togarbage(t, trueop);

    
    tcomp.items[tcomp.count-1] = enclosingparenthesis(t, label, labellen);

    return copytemplate(&tcomp);
}



ASMBLK* translatelabel(VMTRANSLATOR* t) {
    
    tlabel.items[tlabel.count-1] = mklab(t);

    return copytemplate(&tlabel);
}

ASMBLK* translategoto(VMTRANSLATOR* t) {
    
    tgoto.items[tgoto.count-2] = mkgotolab(t);

    return copytemplate(&tgoto);
}

ASMBLK* translateifgoto(VMTRANSLATOR* t) {
    
    tifgoto.items[tifgoto.count-2] = mkgotolab(t);

    return copytemplate(&tifgoto);
}

ASMBLK* translatereturn(VMTRANSLATOR* t) {
    ASMBLK* blk = copytemplate(&tstartreturn);
    
    for(int i = tframevars.count-1; i >= 0; i--) {
        tretpop.items[tretpop.count-2] = tframevars.items[i];
        mergeasmblks(blk, copytemplate(&tretpop));
    }

    mergeasmblks(blk, copytemplate(&tendreturn));
    return blk;
}

ASMBLK* translatefunction(VMTRANSLATOR* t) {
    t->retind = 0;
    t->cmpind = 0;

    
    tfunction.items[0] = mklab(t);
    ASMBLK* blk = copytemplate(&tfunction);

    
    int nlocals = atoi(t->currln->tokens[2]);

    for(int i = 0; i < nlocals; i++)
        mergeasmblks(blk, copytemplate(&tfunctionpush));

    return blk;
}

ASMBLK* pushframe(VMTRANSLATOR* t, char* retlab, int retlablen, int* framesize) {
    tcallstart.items[1] = atraw(t, retlab, retlablen);

    ASMBLK* blk = copytemplate(&tcallstart);

    for(int i = 0; i < tframevars.count; i++) {
        tcallpush.items[0] = tframevars.items[i];
        mergeasmblks(blk, copytemplate((&tcallpush)));
    }

    *framesize = tframevars.count + 1;
    return blk;
}

ASMBLK* translatecall(VMTRANSLATOR* t) {
    
    int retlablen;
    char* retlab = mkretlab(t, &retlablen);

    
    int framesize;
    ASMBLK* blk = pushframe(t, retlab, retlablen, &framesize);

    
    int nargs = atoi(t->currln->tokens[2]);
    tcallsetarg.items[tcallsetarg.count-4] = atn(t, nargs + framesize);
    mergeasmblks(blk, copytemplate(&tcallsetarg));
    
    
    tcalljmp.items[tcalljmp.count-3] = at(t, t->currln->tokens[1]);
    tcalljmp.items[tcalljmp.count-1] = enclosingparenthesis(t, retlab, retlablen);
    mergeasmblks(blk, copytemplate(&tcalljmp));

    return blk;
}

ASMBLK* translateln(VMTRANSLATOR* t) {
    if(eq(t, 0, ""push""))
        return translatepush(t);
    if(eq(t, 0, ""pop""))
        return translatepop(t);

    if(eq(t, 0, ""add""))
        return translatearith(t, ""M=D+M"");
    if(eq(t, 0, ""sub""))
        return translatearith(t, ""M=M-D"");
    if(eq(t, 0, ""and""))
        return translatearith(t, ""M=D&M"");
    if(eq(t, 0, ""or""))
        return translatearith(t, ""M=D|M"");

    if(eq(t, 0, ""neg""))
        return copytemplate(&tneg);
    if(eq(t, 0, ""not""))
        return copytemplate(&tnot);

    if(eq(t, 0, ""eq""))
        return translatecomp(t, ""EQ"");
    if(eq(t, 0, ""gt""))
        return translatecomp(t, ""LT"");
    if(eq(t, 0, ""lt""))
        return translatecomp(t, ""GT"");

    if(eq(t, 0, ""label""))
        return translatelabel(t);
    if(eq(t, 0, ""goto""))
        return translategoto(t);
    if(eq(t, 0, ""if-goto""))
        return translateifgoto(t);

    if(eq(t, 0, ""return""))
        return translatereturn(t);
    if(eq(t, 0, ""function""))
        return translatefunction(t);
    return translatecall(t);
}

ASMBLK* translatevm(VMTRANSLATOR* t) {
    ASMBLK* blk = copytemplate(&tbootstrap);
    while(t->currln != NULL) {
        mergeasmblks(blk, translateln(t));
        t->currln = t->currln->next;
    }
    return blk;
}

VMTRANSLATOR* mkvmtranslator(char* classname, LINEBLOCK* vmlines) {
    VMTRANSLATOR* transl = (VMTRANSLATOR*)malloc(sizeof(VMTRANSLATOR));
    transl->currln = vmlines->head;
    transl->start = vmlines->head;
    transl->garbage = NULL;
    transl->retind = 0;
    transl->cmpind = 0;
    transl->classname = classname;
    transl->classnamelen = strlen(classname);
    return transl;
}

void freegarbage(STRINGLIST* garbage) {
    if(garbage != NULL) {
        free(garbage->content);
        STRINGLIST* next = garbage->next;
        free(garbage);
        freegarbage(next);
    }
}

void freevmtranslator(VMTRANSLATOR* t) {
    freegarbage(t->garbage);
    free(t);
}
",31,999,4315
"#include ""os.h""
#include ""util.h""

CLASS* mkosclass(CLASS* os, const char* name) {
    CLASS* c = (CLASS*)malloc(sizeof(CLASS));
    c->name = ezheapstr(name);
    c->subroutdecs = NULL;
    c->next = os;
    return c;
}

void adddec(CLASS* c, SUBROUTCLASS subroutclass, char* type, const char* name) {
    SUBROUTDEC* dec = (SUBROUTDEC*)malloc(sizeof(SUBROUTDEC));
    dec->class = c;
    dec->subroutclass = subroutclass;
    dec->name = ezheapstr(name);
    dec->type = ezheapstr(type);
    dec->next = c->subroutdecs;
    c->subroutdecs = dec;
}

CLASS* mkmath(CLASS* os) {
    CLASS* mathclass = mkosclass(os, ""Math"");
    adddec(mathclass, function, ""int"", ""multiply"");
    adddec(mathclass, function, ""int"", ""divide"");
    adddec(mathclass, function, ""int"", ""abs"");
    adddec(mathclass, function, ""int"", ""min"");
    adddec(mathclass, function, ""int"", ""max"");
    adddec(mathclass, function, ""int"", ""sqrt"");
    return mathclass;
}

CLASS* mkstringclass(CLASS* os) {
    CLASS* strclass = mkosclass(os, ""String"");
    adddec(strclass, constructor, ""String"", ""new"");
    adddec(strclass, method, ""int"", ""dispose"");
    adddec(strclass, method, ""int"", ""length"");
    adddec(strclass, method, ""char"", ""charAt"");
    adddec(strclass, method, ""void"", ""setCharAt"");
    adddec(strclass, method, ""String"", ""appendChar"");
    adddec(strclass, method, ""void"", ""eraseLastChar"");
    adddec(strclass, method, ""int"", ""intValue"");
    adddec(strclass, method, ""void"", ""setInt"");
    adddec(strclass, function, ""char"", ""backSpace"");
    adddec(strclass, function, ""char"", ""doubleQuote"");
    adddec(strclass, function, ""char"", ""newLine"");
    return strclass;
}

CLASS* mkarray(CLASS* os) {
    CLASS* arrclass = mkosclass(os, ""Array"");
    adddec(arrclass, function, ""Array"", ""new"");
    adddec(arrclass, method, ""void"", ""dispose"");
    return arrclass;
}

CLASS* mkoutput(CLASS* os) {
    CLASS* outclass = mkosclass(os, ""Output"");
    adddec(outclass, function, ""void"", ""moveCursor"");
    adddec(outclass, function, ""void"", ""printChar"");
    adddec(outclass, function, ""void"", ""printString"");
    adddec(outclass, function, ""void"", ""printInt"");
    adddec(outclass, function, ""void"", ""println"");
    adddec(outclass, function, ""void"", ""backSpace"");
    return outclass;
}

CLASS* mkscreen(CLASS* os) {
    CLASS* scrclass = mkosclass(os, ""Screen"");
    adddec(scrclass, function, ""void"", ""clearScreen"");
    adddec(scrclass, function, ""void"", ""setColor"");
    adddec(scrclass, function, ""void"", ""drawPixel"");
    adddec(scrclass, function, ""void"", ""drawLine"");
    adddec(scrclass, function, ""void"", ""drawRectangle"");
    adddec(scrclass, function, ""void"", ""drawCircle"");
    return scrclass;
}

CLASS* mkkeyboard(CLASS* os) {
    CLASS* kbdclass = mkosclass(os, ""Keyboard"");
    adddec(kbdclass, function, ""char"", ""keyPressed"");
    adddec(kbdclass, function, ""char"", ""readChar"");
    adddec(kbdclass, function, ""String"", ""readLine"");
    adddec(kbdclass, function, ""int"", ""readInt"");
    return kbdclass;
}

CLASS* mkmemory(CLASS* os) {
    CLASS* memclass = mkosclass(os, ""Memory"");
    adddec(memclass, function, ""int"", ""peek"");
    adddec(memclass, function, ""void"", ""poke"");
    adddec(memclass, function, ""Array"", ""alloc"");
    adddec(memclass, function, ""void"", ""deAlloc"");
    return memclass;
}

CLASS* mksys(CLASS* os) {
    CLASS* sysclass = mkosclass(os, ""Sys"");
    adddec(sysclass, function, ""void"", ""halt"");
    adddec(sysclass, function, ""void"", ""error"");
    adddec(sysclass, function, ""void"", ""wait"");
    return sysclass;
}

CLASS* mkos() {
    CLASS* os = mkmath(NULL);
    os = mkstringclass(os);
    os = mkarray(os);
    os = mkoutput(os);
    os = mkscreen(os);
    os = mkkeyboard(os);
    os = mkmemory(os);
    os = mksys(os);
    return os;
}

void freeossubroutdecs(SUBROUTDEC* d) {
    free(d->name);
    free(d->type);
    SUBROUTDEC* next = d->next;
    free(d);
    if(next != NULL)
        freeossubroutdecs(next);
}

void freeosclasses(CLASS* c) {
    freeossubroutdecs(c->subroutdecs);
    free(c->name);
    CLASS* next = c->next;
    free(c);
    if(next != NULL)
        freeosclasses(next);
}

void freeos(CLASS* os) {
    freeosclasses(os);
}

SUBROUTDEC* getsubroutdecinclass(CLASS* c, const char* name) {
    SUBROUTDEC* curr = c->subroutdecs;
    while(curr != NULL) {
        if(!strcmp(curr->name, name))
            return curr;
        curr = curr->next;
    }
    return NULL;
}

CLASS* getosclass(CLASS* os, const char* name) {
    CLASS* curr = os;
    while(curr != NULL) {
        if(!strcmp(curr->name, name))
            return curr;
        curr = curr->next;
    }
    return NULL;
}

SUBROUTDEC* getossubroutdec(CLASS* os, SUBROUTCALL* call) {
    CLASS* c = getosclass(os, call->parentname);
    if(c == NULL)
        return NULL;
    return getsubroutdecinclass(c, call->name);
}
",31,1000,1784
"#include ""compiler-expressions.h""
#include ""compiler-statements.h""
#include ""compiler-util.h""




LINE* popthat();
LINE* pushtemp();
char* mkcondlabel(char* name, int count);


LINEBLOCK* compileret(SCOPE* s, STATEMENT* st);
LINEBLOCK* compileif(SCOPE* s, STATEMENT* st);
LINEBLOCK* compilewhile(SCOPE* s, STATEMENT* st);
LINEBLOCK* compilelet(SCOPE* s, STATEMENT* st);
LINEBLOCK* compilestatement(SCOPE* s, STATEMENT* st);






LINE* popthat() {
    char* popthat[] = { ""pop"", ""that"", ""0"" };
    return mkln(popthat);
}

LINE* pushtemp() {
    char* pushtemp[] = { ""push"", ""temp"", ""0"" };
    return mkln(pushtemp);
}

char* mkcondlabel(char* name, int count) {
    int sz = (strlen(name) + countplaces(count) + 1) * sizeof(char);
    char* result = (char*)malloc(sz);
    sprintf(result, ""%s%i"", name, count);
    return result;
}


LINEBLOCK* compileret(SCOPE* s, STATEMENT* st) {
    TERM* e = st->retstatement;
    LINE* ret = onetoken(""return"");
    LINEBLOCK* blk = mklnblk(ret);

    
    if(e == NULL) {
        char* tokens[] = { ""push"", ""constant"", ""0"" };
        appendlnbefore(blk, mkln(tokens));
    } else
        blk = mergelnblks(compileexpression(s, st->debug, e), blk);

    return blk;
}

LINEBLOCK* compileif(SCOPE* s, STATEMENT* st) {
    IFSTATEMENT* ifst = st->ifstatement;
    LINEBLOCK* blk = compileexpression(s, st->debug, ifst->base->expression);

    pthread_mutex_lock(&(s->compiler->ifmutex));
    static int ifcount = 0;
    int mycount = ifcount;
    ifcount++;
    pthread_mutex_unlock(&(s->compiler->ifmutex));
    
    char* truelabel = mkcondlabel(""IF_TRUE"", mycount);
    char* ifgoto[] = { ""if-goto"", truelabel };
    appendln(blk, mkln(ifgoto));
    
    char* falselabel = mkcondlabel(""IF_FALSE"", mycount);
    char* gotofalse[] = { ""goto"", falselabel };
    appendln(blk, mkln(gotofalse));

    char* truelabelln[] = { ""label"", truelabel };
    appendln(blk, mkln(truelabelln));

    blk = mergelnblks(blk, compilestatements(s, ifst->base->statements));

    char* endlabel;
    bool haselse = ifst->elsestatements != NULL;
    if(haselse) {
        endlabel = mkcondlabel(""IF_END"", mycount);
        char* endgoto[] = { ""goto"", endlabel };
        appendln(blk, mkln(endgoto));
    }

    char* falselabelln[] = { ""label"", falselabel};
    appendln(blk, mkln(falselabelln));

    if(haselse) {
        blk = mergelnblks(blk, compilestatements(s, ifst->elsestatements));
        char* endlabelln[] = { ""label"", endlabel };
        appendln(blk, mkln(endlabelln));
        free(endlabel);
    }

    free(falselabel);
    free(truelabel);

    return blk;
}

LINEBLOCK* compilewhile(SCOPE* s, STATEMENT* st) {
    CONDSTATEMENT* w = st->whilestatement;
    LINEBLOCK* blk = compileexpression(s, st->debug, w->expression);

    pthread_mutex_lock(&(s->compiler->whilemutex));
    static int whilecount = 0;
    int mycount = whilecount;
    whilecount++;
    pthread_mutex_unlock(&(s->compiler->whilemutex));

    char* explabel = mkcondlabel(""WHILE_EXP"", mycount);
    char* explabelln[] = { ""label"", explabel };
    appendlnbefore(blk, mkln(explabelln));

    appendln(blk, onetoken(""not""));

    char* endlabel = mkcondlabel(""WHILE_END"", mycount);
    char* ifgoto[] = { ""if-goto"", endlabel };
    appendln(blk, mkln(ifgoto));

    blk = mergelnblks(blk, compilestatements(s, w->statements));

    char* gotoln[] = { ""goto"", explabel };
    appendln(blk, mkln(gotoln));

    char* endlabelln[] = { ""label"", endlabel };
    appendln(blk, mkln(endlabelln));

    free(explabel);
    free(endlabel);

    return blk;
}

LINEBLOCK* compilelet(SCOPE* s, STATEMENT* st) {
    LETSTATEMENT* l = st->letstatement;
    LINEBLOCK* blk = compileexpression(s, st->debug, l->expression);

    if(l->arrayind != NULL) {
        appendlnbefore(blk, onetoken(""add""));
        appendlnbefore(blk, pushvar(s, st->debug, l->varname));
        blk = mergelnblks(compileexpression(s, st->debug, l->arrayind), blk);

        appendln(blk, poptemp());
        appendln(blk, popthatadd());
        appendln(blk, pushtemp());
        appendln(blk, popthat());
    }
    else
        appendln(blk, popvar(s, st->debug, l->varname));
    return blk;
}

LINEBLOCK* compilestatement(SCOPE* s, STATEMENT* st) {
    if(st->type == dostatement) return compilesubroutcall(s, st->dostatement);
    if(st->type == returnstatement) return compileret(s, st);
    if(st->type == ifstatement) return compileif(s, st);
    if(st->type == whilestatement) return compilewhile(s, st);
    return compilelet(s, st);
}

LINEBLOCK* compilestatements(SCOPE* s, STATEMENT* sts) {
    LINEBLOCK* head = NULL;
    while(sts != NULL) {
        head = mergelnblks(head, compilestatement(s, sts));
        sts = sts->next;
    }
    return head;
}

LINEBLOCK* compilestatementsretlast(SCOPE* s, STATEMENT* sts, STATEMENT** retlast) {
    LINEBLOCK* head = NULL;
    STATEMENT* last = NULL;
    while(sts != NULL) {
        head = mergelnblks(head, compilestatement(s, sts));
        last = sts;
        sts = sts->next;
    }
    *retlast = last;
    return head;
}
",31,1001,1942
"#include ""parser-util.h""
#include ""util.h""

const char* tokentypesarr[] = { ""keyword"", ""identifier"", ""symbol"",
                    ""integerConstant"", ""stringConstant"" };
mkstrlist(tokentypes, tokentypesarr);

void unexpected(PARSER* p) {
    eprintf(""Unexpected token '%s' (of type %s); line %i, file '%s'\n"",
                p->current->token, tokentypes.items[p->current->type],
                p->current->definedat, p->file);
    exit(1);
}

void checktype(PARSER* p, TOKENTYPE type) {
    if(p->current->type != type) {
        eprintf(""Unexpected %s; file '%s', line %i\n"", 
                tokentypes.items[p->current->type], p->file,
                    p->current->definedat);
        exit(1);
    }
}

void checkcontent(PARSER* p, const char* content) {
    if(differs(p, content))
        unexpected(p);
    next(p);
}

char* parseidentifier(PARSER* p) {
    checktype(p, identifier);
    char* result = p->current->token;
    next(p);
    return result;
}

DEBUGINFO* getdebug(PARSER* p) {
    DEBUGINFO* d = (DEBUGINFO*)malloc(sizeof(DEBUGINFO));
    d->file = p->file;
    d->definedat = p->current->definedat;
    return d;
}
",31,1002,395
"#include ""parser-util.h""
#include ""parser-structure.h""
#include ""parser-statements.h""

const char* classvartypesarr[] = { ""static"", ""field"" };
const char* vartypesarr[] = { ""int"", ""char"", ""boolean"" };
const char* subroutclassesarr[] = { ""constructor"", ""function"", ""method"" };
mkstrlist(classvartypes, classvartypesarr);
mkstrlist(vartypes, vartypesarr);
mkstrlist(subroutclasses, subroutclassesarr);




bool isprimitive(TOKEN* tk);
char* parsetype(PARSER* p);
int parsepossibilities(PARSER* p, STRINGARRAY* poss);


CLASS* parseclass(PARSER* p);
CLASSVARTYPE parseclassvartype(PARSER* p);
CLASSVARDEC* parseclassvardec(PARSER* p);
CLASSVARDEC* parseclassvardecs(PARSER* p);
SUBROUTCLASS parsesubroutclass(PARSER* p);
SUBROUTDEC* parsesubroutdec(PARSER* p, CLASS* c);
SUBROUTDEC* parsesubroutdecs(PARSER* p, CLASS* c);
PARAMETER* parseparameter(PARSER* p);
PARAMETER* parseparameters(PARSER* p);
SUBROUTBODY* parsesubroutbody(PARSER* p);
void parsevardeccommon(PARSER* p, VARDEC* v);
VARDEC* parsevardec(PARSER* p);
VARDEC* parsevardecs(PARSER* p);





bool isprimitive(TOKEN* tk) {
    if(tk->type == keyword)
        if(existsinarray(&vartypes, tk->token))
            return true;
    return false;
}

char* parsetype(PARSER* p) {
    if(p->current->type != identifier && p->current->type != keyword)
        unexpected(p);

    char* result = p->current->token;
    next(p);
    return result;
}

int parsepossibilities(PARSER* p, STRINGARRAY* poss) {
    for(int i = 0; i < poss->size; i++)
        if(equals(p, poss->items[i]))
            return i;
    return -1;
}


CLASS* parseclass(PARSER* p) {
    checkcontent(p, ""class"");

    CLASS* class = (CLASS*)malloc(sizeof(CLASS));

    class->debug = getdebug(p);

    class->name = parseidentifier(p);

    checkcontent(p, ""{"");

    class->vardecs = parseclassvardecs(p);

    class->subroutdecs = parsesubroutdecs(p, class);

    checkcontent(p, ""}"");

    if(p->current != NULL)
        unexpected(p);

    return class;
}

CLASSVARTYPE parseclassvartype(PARSER* p) {
    return parsepossibilities(p, &classvartypes);
}

CLASSVARDEC* parseclassvardec(PARSER* p) {
    CLASSVARTYPE classvartype = parseclassvartype(p);
    if(classvartype == -1)
        return NULL;
    next(p);

    CLASSVARDEC* classvardec = (CLASSVARDEC*)malloc(sizeof(CLASSVARDEC));
    classvardec->type = classvartype;

    classvardec->base = (VARDEC*)malloc(sizeof(VARDEC));

    parsevardeccommon(p, classvardec->base);

    return classvardec;
}

CLASSVARDEC* parseclassvardecs(PARSER* p) {
    CLASSVARDEC* head = parseclassvardec(p);
    CLASSVARDEC* curr = head;
    CLASSVARDEC* nextc;
    while(nextc = parseclassvardec(p), nextc != NULL) {
        curr->next = nextc;
        curr = nextc;
    }
    if(curr != NULL)
        curr->next = NULL;
    return head;
}

SUBROUTCLASS parsesubroutclass(PARSER* p) {
    return parsepossibilities(p, &subroutclasses);
}

SUBROUTDEC* parsesubroutdec(PARSER* p, CLASS* c) {
    SUBROUTCLASS subroutclass = parsesubroutclass(p);
    if(subroutclass == -1)
        return NULL;

    next(p);
    SUBROUTDEC* subroutdec = (SUBROUTDEC*)malloc(sizeof(SUBROUTDEC));
    subroutdec->subroutclass = subroutclass;

    if(differs(p, ""void""))
        subroutdec->type = parsetype(p);
    else {
        subroutdec->type = p->current->token;
        next(p);
    }

    subroutdec->debug = getdebug(p);

    subroutdec->name = parseidentifier(p);

    checkcontent(p, ""("");
    subroutdec->parameters = parseparameters(p);
    checkcontent(p, "")"");

    checkcontent(p, ""{"");
    subroutdec->body = parsesubroutbody(p);
    checkcontent(p, ""}"");

    subroutdec->class = c;

    return subroutdec;
}

SUBROUTDEC* parsesubroutdecs(PARSER* p, CLASS* c) {
    SUBROUTDEC* head = parsesubroutdec(p, c);
    SUBROUTDEC* curr = head;
    SUBROUTDEC* nexts;
    while(nexts = parsesubroutdec(p, c), nexts != NULL) {
        curr->next = nexts;
        curr = nexts;
    }
    if(curr != NULL)
        curr->next = NULL;
    return head;
}

PARAMETER* parseparameter(PARSER* p) {
    if(equals(p, "")""))
        return NULL;
    PARAMETER* param = (PARAMETER*)malloc(sizeof(PARAMETER));
    param->debug = getdebug(p);
    param->primitive = isprimitive(p->current);
    param->type = parsetype(p);
    param->name = parseidentifier(p);
    return param;
}

PARAMETER* parseparameters(PARSER* p) {
    PARAMETER* head = parseparameter(p);
    PARAMETER* curr = head;
    PARAMETER* nextp;
    while(equals(p, "","")) {
        next(p);
        nextp = parseparameter(p);
        if(nextp == NULL)
            unexpected(p);
        curr->next = nextp;
        curr = curr->next;
    }
    if(curr != NULL)
        curr->next = NULL;
    return head;
}

SUBROUTBODY* parsesubroutbody(PARSER* p) {
    SUBROUTBODY* subroutbody = (SUBROUTBODY*)malloc(sizeof(SUBROUTBODY));
    subroutbody->vardecs = parsevardecs(p);
    subroutbody->statements = parsestatements(p);

    return subroutbody;
}

void parsevardeccommon(PARSER* p, VARDEC* v) {
    v->typeclass = p->current->type;
    v->primitive = isprimitive(p->current);
    v->type = parsetype(p);

    STRINGLIST* currstr = (STRINGLIST*)malloc(sizeof(STRINGLIST));
    v->names = currstr;

    v->debug = getdebug(p);

    v->names->content = parseidentifier(p);

    while(!strcmp(p->current->token, "","")) {
        next(p);
        STRINGLIST* nextstr = (STRINGLIST*)malloc(sizeof(STRINGLIST));
        nextstr->content = parseidentifier(p);
        currstr->next = nextstr;
        currstr = nextstr;
    }
    currstr->next = NULL;

    checkcontent(p, "";"");
}


VARDEC* parsevardec(PARSER* p) {
    if(strcmp(p->current->token, ""var""))
        return NULL;
    next(p);

    VARDEC* vardec = (VARDEC*)malloc(sizeof(VARDEC));

    parsevardeccommon(p, vardec);

    return vardec;
}

VARDEC* parsevardecs(PARSER* p) {
    VARDEC* head = parsevardec(p);
    VARDEC* curr = head;
    VARDEC* nextv;
    while(nextv = parsevardec(p), nextv != NULL) {
            curr->next = nextv;
        curr = nextv;
    }
    if(curr != NULL)
        curr->next = NULL;
    return head;
}
",31,1003,2293
"#define MAXSIZE 100
struct Stack {
    int top;
    int array[MAXSIZE];
} string;

int isFull() {
    if(string.top >= MAXSIZE)
        return 1;
    else
        return 0;
}
int isEmpty() {
 if(string.top == -1)
     return 1;
 else
     return 0;
}
void push(int num) {
    if (isFull())
        printf(""Stack is Full...\n"");
    else {
        string.array[string.top + 1] = num;
        string.top++;
    }
}
int pop() {
    if (isEmpty())
        printf(""Stack is Empty...\n"");
    else {
     string.top = string.top - 1;
        return string.array[string.top+1];
    }
}

int main() {
    char inputString[100], c;
    int i, length;
    
    printf(""Enter a string\n"");
    gets(inputString);
    length = strlen(inputString);
    for(i = 0; i < length; i++){
        push(inputString[i]);
    }
    for(i = 0; i < length; i++){
        if(pop() != inputString[i]) {
            printf(""Not a Palindrome String\n"");
            return 0;
        }
    }

    printf(""Palindrome String\n"");
    return 0;
}
",32,1004,366
"struct node{
    int data;
    struct node*next;
};
struct node*head;

void print(){
struct node*temp;
temp=head;
while(temp!=NULL)
{
    printf(""%d\n"", temp->data);
    temp=temp->next;
}
}
void create(int value){
struct node*temp=(struct node*)malloc(sizeof(struct node));
temp->data=value;
temp->next=NULL;
if(head==NULL){
    head=temp;
}
else{
    struct node*newnode;
    newnode=head;
    while(newnode->next!=NULL)
    {
        newnode=newnode->next;
    }
    newnode->next=temp;
}
}
void deletenode(int position)
{
    int i;
    if(position==1)
    {
        struct node*temp;
        temp=head;
        head=head->next;
        free(temp);
    }
    else
    {
        struct node*temp1;
        temp1=head;
        for(i=1;i<=position-2;i++)
        {
            temp1=temp1->next;
        }
        struct node*temp2;
        temp2=temp1->next;
        temp1->next=temp2->next;
        free(temp2);
    }
}

int main()
{
    head=NULL;
    create(10);
    create(20);
    create(30);
    create(4);
    printf(""display:\n"");
    print();
    deletenode(2);
    printf(""display:\n"");
    print();
    return 0;


}
",32,1005,422
"#define MAX_SIZE 100

int main()
{
    int arr[MAX_SIZE];
    int i, size, pos;

    
    printf(""Enter size of the array : "");
    scanf(""%d"", &size);
    printf(""Enter elements in array : "");
    for(i=0; i<size; i++)
    {
        scanf(""%d"", &arr[i]);
    }

    
    printf(""Enter the element position to delete : "");
    scanf(""%d"", &pos);

    
    if(pos==size+1 || pos<0)
    {
        printf(""Invalid position! Please enter position between 1 to %d"", size);
    }
    else
    {
        
        for(i=pos-1; i<size-1; i++)
        {
            arr[i] = arr[i + 1];
        }

        
        size--;
    }

    
    printf(""\nElements of array after delete are : "");
    for(i=0; i<size; i++)
    {
        printf(""%d\t"", arr[i]);
    }

    return 0;
}
",32,1006,282
"struct node {
    int data;
    struct node * next;
}*head;
void createList(int n);
void displayList();
void insertAtBeginning(int data);
void insertAtN(int data, int position);


int main()
{
    int n, data, choice=1;

    head = NULL;
                printf(""Enter the total number of nodes in list: "");
                scanf(""%d"", &n);
                createList(n);
                displayList();
                printf(""Enter node position: "");
                scanf(""%d"", &n);
                printf(""Enter data you want to insert at %d position: "", n);
                scanf(""%d"", &data);
                insertAtN(data, n);
                displayList();


    return 0;
}
 
 
void createList(int n)
{
    int i, data;
    struct node *prevNode, *newNode;
        head = (struct node *)malloc(sizeof(struct node));

        printf(""Enter data of 1 node: "");
        scanf(""%d"", &data);

        head->data = data;
        head->next = NULL;

        prevNode = head;
        for(i=2; i<=n; i++)
        {
            newNode = (struct node *)malloc(sizeof(struct node));

            printf(""Enter data of %d node: "", i);
            scanf(""%d"", &data);

            newNode->data = data;
            newNode->next = NULL;

            
            prevNode->next = newNode;
            
            prevNode = newNode;
        }

        
        prevNode->next = head;
}
void displayList()
{
    struct node *current;
    int n = 1;

    if(head == NULL)
    {
        printf(""List is empty.\n"");
    }
    else
    {
        current = head;
        printf(""DATA IN THE LIST:\n"");

        do {
            printf(""Data %d = %d\n"", n, current->data);

            current = current->next;
            n++;
        }while(current != head);
    }
}
void insertAtBeginning(int data)
{
    struct node *newNode, *current;

    if(head == NULL)
    {
        printf(""List is empty.\n"");
    }
    else
    {
         
        newNode = (struct node *)malloc(sizeof(struct node));
        newNode->data = data;
        newNode->next = head;
         
        
        current = head;
        while(current->next != head)
        {
            current = current->next;
        }
        current->next = newNode;

        
        head = newNode;

        printf(""NODE INSERTED SUCCESSFULLY\n"");
    }
}
void insertAtN(int data, int position)
{
    struct node *newNode, *current;
    int i;

    if(head == NULL)
    {
        printf(""List is empty.\n"");
    }
    else if(position == 1)
    {
    
    struct node *newNode, *current;
        
        newNode = (struct node *)malloc(sizeof(struct node));
        newNode->data = data;
        newNode->next = head;
         
        current = head;
        while(current->next != head)
        {
            current = current->next;
        }
        current->next = newNode;

        
        head = newNode;
}
    else
    {
        
        newNode = (struct node *)malloc(sizeof(struct node));
        newNode->data = data;
        
        current = head;
        for(i=2; i<=position-1; i++)
        {
            current = current->next;
        }
        
        newNode->next = current->next;
        current->next = newNode;

    }
}
",32,1007,959
"struct node{
    int data;
    struct node*next;
};
struct node*head;

void createList(int n)
{
    struct node*mehedi;
    struct node*temp;
    int data, i;
    head=(struct node*)malloc(sizeof(struct node));
    printf(""Enter node data:"");
    scanf(""%d"", &data);
    head->data=data;
    head->next=NULL;
    temp=head;
    for(i=2;i<=n; i++)
    {
        mehedi=(struct node*)malloc(sizeof(struct node));
        printf(""Enter node data:"");
        scanf(""%d"", &data);
        mehedi->data=data;
        mehedi->next=NULL;
        temp->next=mehedi;
        temp=temp->next;
    }
}
void deletenode(int position)
{
        int i;

        struct node*temp1;
        temp1=head;
        for(i=1;i<=position-2;i++)
        {
            temp1=temp1->next;
        }
        struct node*temp2;
        temp2=temp1->next;
        temp1->next=temp2->next;
        free(temp2);
    }
void print(){
struct node*temp;
temp=head;
while(temp!=NULL)
{
    printf(""%d\n"", temp->data);
    temp=temp->next;
}
}
int main()
{
    int n;
    printf(""Enter the total number of nodes: "");
    scanf(""%d"", &n);
    createList(n);
    printf(""display:\n"");
    print();
    return 0;


}


",32,1008,425
"int main()
{
    int i,n;
    printf(""Enter the element of array:"");
    scanf(""%d"", &n);
    int a[n];
    for(i=0; i<=n-1; i++)
    {
        scanf(""%d"", &a[i]);
    }
    printf(""\nEven numbers:"");
    for(i=0; i<=n-1; i++)
    {
        if(a[i]%2==0)
        {
            printf(""%d "", a[i]);
        }
    }
    printf(""\n\nOdd numbers:"");
    for(i=0; i<=n-1; i++)
    {
        if(a[i]%2==1)
        {
            printf(""%d "", a[i]);

        }
    }
    return 0;
}
",32,1009,208
"struct node {
    int data;
    struct node * prev;
    struct node * next;
}*head,*last;

void createList(int n);
void displayListFromFirst();

void insertAtBeginning(int data);
void insertAtN(int data, int position);


int main()
{
    int n, data;

    head = NULL;
    last = NULL;

    printf(""Enter the number of nodes you want to create: "");
    scanf(""%d"", &n);
    createList(n);
    displayListFromFirst();
    

    printf(""Enter node position: "");
    scanf(""%d"", &n);
    printf(""Enter data you want to insert at %d position: "", n);
    scanf(""%d"", &data);
    insertAtN(data, n);
    displayListFromFirst();
    

    return 0;
}
void createList(int n)
{
    int i, data;
    struct node *newNode;
            head = (struct node *)malloc(sizeof(struct node));
            printf(""Enter data of 1 node: "");
            scanf(""%d"", &data);

            head->data = data;
            head->prev = NULL;
            head->next = NULL;

            last = head;
            for(i=2; i<=n; i++)
            {
                newNode = (struct node *)malloc(sizeof(struct node));
                    printf(""Enter data of %d node: "", i);
                    scanf(""%d"", &data);

                    newNode->data = data;
                    newNode->prev = last;
                    newNode->next = NULL;

                    last->next = newNode;
                    last = newNode;
            }
        printf(""\nDOUBLY LINKED LIST CREATED SUCCESSFULLY\n"");
    }

void displayListFromFirst()
{
    struct node * temp;
        temp = head;
        printf(""\n\nDATA IN THE LIST From First:\n"");

        while(temp != NULL)
        {
            printf(""DATA = %d\n"", temp->data);
            temp = temp->next;
        }
    }



void insertAtN(int data, int position)
{
    int i;
    struct node * newNode, *temp;
        temp = head;
        i=1;

        while(i<position-1 && temp!=NULL)
        {
            temp = temp->next;
            i++;
        }

        
            newNode = (struct node *)malloc(sizeof(struct node));

            newNode->data = data;
            newNode->next = temp->next;
            newNode->prev = temp;
            
            
                temp->next->prev = newNode;
            
            temp->next = newNode;
        
    }






",32,1010,693
"struct Node {
    int data;
    struct Node* next;
};

struct Node* front = NULL;
struct Node* rear = NULL;


void Enqueue(int x) {
    struct Node* temp =
        (struct Node*)malloc(sizeof(struct Node));
    temp->data =x;
    temp->next = NULL;
    if(front == NULL && rear == NULL){
        front = rear = temp;
        return;
    }
    rear->next = temp;
    rear = temp;
}

void Dequeue() {
    struct Node* temp = front;
    if(front == NULL) {
        printf(""Queue is Empty\n"");
        return;
    }
    if(front == rear) {
        front = rear = NULL;
    }
    else {
        front = front->next;
    }
    free(temp);
}

int Front() {
    if(front == NULL) {
        printf(""Queue is empty\n"");
        return;
    }
    return front->data;
}

void Print() {
    struct Node* temp = front;
    while(temp != NULL) {
        printf(""%d  \n"",temp->data);
        temp = temp->next;
    }
    printf(""\n"");
}

int main()
{
    int i,n,p,m;
    printf(""How many number do you want to enqueue ? "");
    scanf(""%d"",&n);
    for(i=0;i<n;i++)
    {
        printf(""Enter the value :"");
        scanf(""%d"",&p);
        Enqueue(p);
        printf(""List is :\n"");
        Print();
    }
    printf(""How many number do you want to dequeue ? "");
    scanf(""%d"",&m);
    for(i=0;i<m;i++)
    {
        Dequeue();
        printf(""List is :\n"");
        Print();
    }

}
",32,1011,478
"int main()
{
    int a[2][2];
    int r1,c1;
    for(r1=0; r1<=1; r1++)
    {
        for(c1=0; c1<=1; c1++)
        {
            scanf(""%d"", &a[r1][c1]);
        }
    }
    printf(""The first matrix is:\n"");
    for(r1=0; r1<=1; r1++)
    {
        for(c1=0; c1<=1; c1++)
        {
            printf(""%d "", a[r1][c1]);
        }
        printf(""\n"");
    }
    
    int r2,c2;
    for(r2=0; r2<=1; r2++)
    {
        for(c2=0; c2<=1; c2++)
        {
            scanf(""%d"", &a[r2][c2]);
        }
    }
    printf(""The Secound matrix is:\n"");
    for(r2=0; r2<=1; r2++)
    {
        for(c2=0; c2<=1; c2++)
        {
            printf(""%d "", a[r2][c2]);
        }
        printf(""\n"");
    }
    for(r1=0; r1<=1; r1++)
    {
        for(c1=0; c1<=1; c1++)
        {
            for(r2=0; r2<=1; r2++)
            {
                for(c2=0; c2<=1; c2++)
                {
                    if(r1==r2&&c1==c2)
                        {
                            printf(""Two matrices are equal"");
                        }
                    else
                        {
                            printf(""Not equal"");
                        }


                }
            }
        }
    }


    return 0;
}
",32,1012,473
"struct node{
    int data;
    struct node*next;
};
struct node*head;

void createList(int n)
{
    struct node*mehedi;
    struct node*temp;
    int data, i;
    head=(struct node*)malloc(sizeof(struct node));
    printf(""Enter node data:"");
    scanf(""%d"", &data);
    head->data=data;
    head->next=NULL;
    temp=head;
    for(i=2;i<=n; i++)
    {
        mehedi=(struct node*)malloc(sizeof(struct node));
        printf(""Enter node data:"");
        scanf(""%d"", &data);
        mehedi->data=data;
        mehedi->next=NULL;
        temp->next=mehedi;
        temp=temp->next;
    }
}
void reverse()
{
    struct node* current, *prev, *temp;
    current=head;
    prev =NULL;
    while(temp!=NULL)
    {
        temp=current->next;
        current->next=prev;
        prev=current;
        current=temp;
    }
    head=prev;
}
void print(){
struct node*temp;
temp=head;
while(temp!=NULL)
{
    printf(""%d\n"", temp->data);
    temp=temp->next;
}
}
int main()
{
    int n;
    printf(""Enter the total number of nodes: "");
    scanf(""%d"", &n);
    createList(n);
    printf(""display:\n"");
    print();
    printf(""reverse:\n"");
    reverse();
    print();
    return 0;


}


",32,1013,417
"int main()
{
    int array[10][10];

    int i, j, m, n, sum = 0;
    printf(""Enter the order of the matrix\n"");

    scanf(""%d %d"", &m, &n);

    printf(""Enter the co-efficients of the matrix\n"");

    for (i = 0; i < m; ++i)

    {

        for (j = 0; j < n; ++j)

        {
            scanf(""%d"", &array[i][j]);
        }
    }
    for (i = 0; i < m; ++i)
    {
        for (j = 0; j < n; ++j)
        {
            sum = sum + array[i][j] ;
        }
        printf(""Sum of the %d row is = %d\n"", i, sum);
        sum = 0;
    }
    sum = 0;
    for (j = 0; j < n; ++j)
    {
        for (i = 0; i < m; ++i)
        {
            sum = sum + array[i][j];
        }
        printf(""Sum of the %d column is = %d\n"", j, sum);
        sum = 0;
    }
    return 0;

}


",32,1014,329
"struct node {
    int data;
    struct node * next;
}*head;

void createList(int n);
void displayList();


int main()
{
    int n, data, choice=1;

    head = NULL;

    printf(""Enter the total number of nodes in list: "");
    scanf(""%d"", &n);
    createList(n);
    displayList();

    return 0;
}
void createList(int n)
{
    int i, data;
    struct node *temp, *newNode;
        head = (struct node *)malloc(sizeof(struct node));

        printf(""Enter data of 1 node: "");
        scanf(""%d"", &data);

        head->data = data;
        head->next = NULL;

        temp = head;

        
        for(i=2; i<=n; i++)
        {
            newNode = (struct node *)malloc(sizeof(struct node));

            printf(""Enter data of %d node: "", i);
            scanf(""%d"", &data);

            newNode->data = data;
            newNode->next = NULL;

            
            temp->next = newNode;

            
            temp = newNode;
        }

        
        temp->next = head;

        printf(""\nCIRCULAR LINKED LIST CREATED SUCCESSFULLY\n"");

}



void displayList()
{
    struct node *current;
    int n = 1;

    if(head == NULL)
    {
        printf(""List is empty.\n"");
    }
    else
    {
        current = head;
        printf(""DATA IN THE LIST:\n"");

        do {
            printf(""Data %d = %d\n"", n, current->data);

            current = current->next;
            n++;
        }while(current != head);
    }
}
",32,1015,467
"struct node{
int data;
struct node*next;
};
struct node*head;
void createList(int n);
void inab(int data);
void displayList();
int main()
{
    int n, data;
    printf(""Enter the total number of nodes: "");
    scanf(""%d"", &n);
    createList(n);

    printf(""\nData in the list \n"");
    displayList();
    printf(""\nEnter data to insert at beginning of the list: "");
    scanf(""%d"", &data);
    inab(data);

    printf(""\nData in the list \n"");
    displayList();

    return 0;
}
void createList(int n)
{
    struct node*mehedi;
    struct node*temp;
    int data, i;
    head=(struct node*)malloc(sizeof(struct node));
    printf(""Enter node data:"");
    scanf(""%d"", &data);
    head->data=data;
    head->next=NULL;
    temp=head;
    for(i=2;i<=n; i++)
    {
        mehedi=(struct node*)malloc(sizeof(struct node));
        printf(""Enter node data:"");
        scanf(""%d"", &data);
        mehedi->data=data;
        mehedi->next=NULL;
        temp->next=mehedi;
        temp=temp->next;
    }
}
void inab(int data)
{
    struct node*peloon;
    peloon=(struct node*)malloc(sizeof(struct node));
    peloon->data=data;
    peloon->next=head;
    head=peloon;
}
void displayList()
{
    struct node*temp;
    temp=head;
    while(temp!=NULL)
    {
        printf(""%d\n"", temp->data);
        temp=temp->next;
    }
}
",32,1016,462
"int main()
{

   int a[2][2];
   int r1, c1;
   for(r1=0; r1<=1; r1++)
   {
       for(c1=0; c1<=1; c1++)
       {
           scanf(""%d"", &a[r1][c1]);
       }
   }
   for(r1=0; r1<=1; r1++)
   {
       for(c1=0; c1<=1; c1++)
       {
           printf(""%d "", a[r1][c1]);
       }
       printf(""\n"");
   }
   int b[2][2];
   int r2, c2;
   for(r2=0; r2<=1; r2++)
   {
       for(c2=0; c2<=1; c2++)
       {
           scanf(""%d"", &b[r2][c2]);
       }
   }
   for(r2=0; r2<=1; r2++)
   {
       for(c2=0; c2<=1; c2++)
       {
           printf(""%d "", b[r2][c2]);
       }
       printf(""\n"");
   }
   for(r1=0; r2)


    return 0;
}
",32,1017,321
"int main()
{
    int a[5][5];
    int r, c;
    for(r=0; r<=1; r++)
    {
        for(c=0; c<=1; c++)
        {
            scanf(""%d"", &a[r][c]);
        }
        printf(""\n"");
    }
    for(r=0; r<=1; r++)
    {
        for(c=0; c<=1; c++)
        {
            printf(""%d "", a[r][c]);
        }
        printf(""\n"");
    }
    int sum=0;
    for(r=0; r<=1; r++)
    {
        sum=0;
        for(c=0; c<=1; c++)
        {
            sum=sum+a[r][c];
        }
        printf(""\nsum of element of row%d=%d "",r+1, sum);
    }
    for(c=0; c<=1; c++)
    {
        sum=0;
        for(r=0; r<=1; r++)
        {
            sum=sum+a[r][c];
        }
        printf(""\nsum of element of coloumn %d=%d "",c+1, sum);
    }
    return 0;
}
",32,1018,315
"struct node{
int data;
struct node*next;
};
struct node*head;
void createlist(int n);
void displaylist();

int main()
    {
        int n,data;
        printf(""Enter the number of list:"");
        scanf(""%d"", &n);
        createlist(n);
        printf(""\nDisplay\n"");
        displaylist();
        return 0;
    }

void createlist(int n)
{
    struct node*mehedi;
    struct node*temp;
    int i, data;
    head=(struct node*)malloc(sizeof(struct node));
    printf(""Enter data:"");
    scanf(""%d"", &data);
    head->data=data;
    head->next=NULL;
    temp=head;
    for(i=2;i<=n;i++)
    {
        mehedi=(struct node*)malloc(sizeof(struct node));
        printf(""Enter data:"");
        scanf(""%d"", &data);
        mehedi->data=data;
        mehedi->next=NULL;
        temp->next=mehedi;
        temp=mehedi;
    }

}

    void displaylist()
    {
        struct node*temp;
        temp=head;
        while(temp!=NULL)
        {
            printf(""%d\n"", temp->data);
            temp=temp->next;
        }
    }



",32,1019,350
"struct node {
    struct node * left;
    char data;
    struct node * right;
};

struct node *constructTree( int );
void inorder(struct node *);

char array[ ] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', '\0', '\0', 'H' };
int leftcount[ ] = {  1,   3,   5,   -1,   9,  -1,  -1,   -1,   -1,  -1 };
int rightcount[ ] = {  2,   4,   6,   -1,  -1,  -1,  -1,   -1,   -1,  -1 };

void main() {
    struct node *root;
    root = constructTree( 0 );
    printf(""In-order Traversal: \n"");
    inorder(root);
}

struct node * constructTree( int index ) {
    struct node *temp = NULL;
    if (index != -1) {
        temp = (struct node *)malloc( sizeof ( struct node ) );
        temp->left = constructTree( leftcount[index] );
        temp->data = array[index];
        temp->right = constructTree( rightcount[index] );
    }
    return temp;
}

void inorder( struct node *root ) {
    if (root != NULL) {
        inorder(root->left);
        printf(""%c\t"", root->data);
        inorder(root->right);
    }
}
",32,1020,371
"struct node{
int data;
struct node*next;
};
struct node*head;
void createlist(int n);
void displaylist();

int main()
    {
        int n,data;
        printf(""Enter the number of list:"");
        scanf(""%d"", &n);
        createlist(n);
        printf(""\nDisplay\n"");
        displaylist();
        return 0;
    }

void createlist(int n)
{
    struct node*mehedi;
    struct node*temp;
    int i, data;
    head=(struct node*)malloc(sizeof(struct node));
    printf(""Enter data:"");
    scanf(""%d"", &data);
    head->data=data;
    head->next=NULL;
    temp=head;
    for(i=2;i<=n;i++)
    {
        mehedi=(struct node*)malloc(sizeof(struct node));
        printf(""Enter data:"");
        scanf(""%d"", &data);
        mehedi->data=data;
        mehedi->next=NULL;
        temp->next=mehedi;
        temp=temp->next;
    }

}

    void displaylist()
    {
        struct node*temp;
        temp=head;
        while(temp!=NULL)
        {
            printf(""%d\n"", temp->data);
            temp=temp->next;
        }
    }



",32,1021,350
"int MAXSIZE = 8;
int stack[8];
int top = -1;

int isempty() {

   if(top == -1)
      return 1;
   else
      return 0;
}

int isfull() {

   if(top == MAXSIZE)
      return 1;
   else
      return 0;
}

int peek() {
   return stack[top];
}

int pop() {
   int data;

   if(!isempty()) {
      data = stack[top];
      top = top - 1;
      return data;
   } else {
      printf(""Could not retrieve data, Stack is empty.\n"");
   }
}

int push(int data) {

   if(!isfull()) {
      top = top + 1;
      stack[top] = data;
   } else {
      printf(""Could not insert data, Stack is full.\n"");
   }
}

int main() {
   
   push(3);
   push(5);
   push(9);
   push(1);
   push(12);
   push(15);

   printf(""Element at top of the stack: %d\n"" ,peek());
   printf(""Elements: \n"");

   
   while(!isempty()) {
      int data = pop();
      printf(""%d\n"",data);
   }

   printf(""Stack full: %s\n"" , isfull()?""true"":""false"");
   printf(""Stack empty: %s\n"" , isempty()?""true"":""false"");

   return 0;
}
",32,1022,392
"int main()
{
    int i,n;
    printf(""Enter the element of array:"");
    scanf(""%d"", &n);
    int a[n];
    for(i=0; i<=n-1; i++)
    {
        scanf(""%d"", &a[i]);
    }
    printf(""\nEven numbers:"");
    for(i=0; i<=n-1; i++)
    {
        if(a[i]%2==0)
        {
            printf(""%d "", a[i]);
        }
    }
    printf(""\n\nOdd numbers:"");
    for(i=0; i<=n-1; i++)
    {
        if(a[i]%2==1)
        {
            printf(""%d "", a[i]);

        }
    }
    return 0;
}
",32,1023,208
"struct node {
    int data;
    struct node * prev;
    struct node * next;
}*head, *last;

void createList(int n);
void displayList();


void deleteFromN(int position);


int main()
{
    int n, data, choice=1;

    head = NULL;
    last = NULL;
    printf(""Enter the total number of nodes in list: "");
    scanf(""%d"", &n);
    createList(n);
    
    
    printf(""Enter the node position which you want to delete: "");
    scanf(""%d"", &n);
    deleteFromN(n);
    displayList();
    return 0;
}

void createList(int n)
{
    int i, data;
        struct node *newNode;
        head = (struct node *)malloc(sizeof(struct node));

        printf(""Enter data of 1 node: "");
        scanf(""%d"", &data);

        head->data = data;
        head->prev = NULL;
        head->next = NULL;

        last = head;
        for(i=2; i<=n; i++)
        {
            newNode = (struct node *)malloc(sizeof(struct node));

            printf(""Enter data of %d node: "", i);
            scanf(""%d"", &data);

            newNode->data = data;
            newNode->prev = last; 
            newNode->next = NULL;

            last->next = newNode; 
            last = newNode; 
        }
}

void displayList()
{
    struct node * temp;
    int n = 1;

    if(head == NULL)
    {
        printf(""List is empty.\n"");
    }
    else
    {
        temp = head;
        printf(""DATA IN THE LIST:\n"");

        while(temp != NULL)
        {
            printf(""DATA of %d node = %d\n"", n, temp->data);

            n++;

            
            temp = temp->next;
        }
    }
}

void deleteFromN(int position)
{
    struct node *current;
    int i;
    current = head;

    for(i=1; i<position && current!=NULL; i++)
    {
        current = current->next;
    }

    if(position == 1)
    {
        
        struct node * toDelete;
        toDelete = head;

        head = head->next; 
        head->prev = NULL; 

        free(toDelete); 
    }
    else if(current == last)
    {
        
        struct node * toDelete;
        toDelete = last;

        last = last->prev; 
        last->next = NULL; 

        free(toDelete);       
    }
    else if(current != NULL)
    {
        current->prev->next = current->next;
        current->next->prev = current->prev;

        free(current); 

        printf(""SUCCESSFULLY DELETED NODE FROM %d POSITION.\n"", position);
    }
}
    


",32,1024,769
"struct node{
int data;

struct node*next;
};
struct node*head;
void createList(int n);
void displayList();
int main()
{
    int n, key;
    printf(""Enter the total number of nodes: "");
    scanf(""%d"", &n);
    createList(n);

    printf(""\nData in the list \n"");
    displayList();
    printf(""\nEnter data which u wnt to srch: "");
    scanf(""%d"", &key);
    search(key);

    return 0;
}
void createList(int n)
{
    struct node*mehedi;
    struct node*temp;
    int data, i;
    head=(struct node*)malloc(sizeof(struct node));
    printf(""Enter node data:"");
    scanf(""%d"", &data);
    head->data=data;
    head->next=NULL;
    temp=head;
    for(i=2;i<=n; i++)
    {
        mehedi=(struct node*)malloc(sizeof(struct node));
        printf(""Enter node data:"");
        scanf(""%d"", &data);
        mehedi->data=data;
        mehedi->next=NULL;
        temp->next=mehedi;
        temp=temp->next;
    }
}
void search(int key)
{
    struct node*temp;
    temp=head;
    while(temp!=NULL)
    {
        if(temp->data==key){
        printf(""Key found :)"");
        temp=temp->next;
        break;
    }
    else{
        printf(""Key not found :("");
        break;
    }
}
}
void displayList()
{
    struct node*temp;
    temp=head;
    while(temp!=NULL)
    {
        printf(""%d\n"", temp->data);
        temp=temp->next;
    }
}
",32,1025,467
"int main()
{
    int array[10][10];

    int i, j, m, n, sum = 0;
    printf(""Enter the order of the matrix\n"");

    scanf(""%d %d"", &m, &n);

    printf(""Enter the co-efficients of the matrix\n"");

    for (i = 0; i < m; ++i)

    {

        for (j = 0; j < n; ++j)

        {
            scanf(""%d"", &array[i][j]);
        }
    }
    for (i = 0; i < m; ++i)
    {
        for (j = 0; j < n; ++j)
        {
            sum = sum + array[i][j] ;
        }
        printf(""Sum of the %d row is = %d\n"", i, sum);
        sum = 0;
    }
    sum = 0;
    for (j = 0; j < n; ++j)
    {
        for (i = 0; i < m; ++i)
        {
            sum = sum + array[i][j];
        }
        printf(""Sum of the %d column is = %d\n"", j, sum);
        sum = 0;
    }
    return 0;

}


",32,1026,329
"#define MAXSIZE 100
struct Stack {
    int top;
    int array[MAXSIZE];
} string;

int isFull() {
    if(string.top >= MAXSIZE)
        return 1;
    else
        return 0;
}
int isEmpty() {
 if(string.top == -1)
     return 1;
 else
     return 0;
}
void push(int num) {
    if (isFull())
        printf(""Stack is Full...\n"");
    else {
        string.array[string.top + 1] = num;
        string.top++;
    }
}


int main() {
    char inputString[100], c;
    int i, length;
    
    printf(""Enter a string\n"");
    gets(inputString);
    printf(""\n\n"");
    puts(inputString);
    length = strlen(inputString);
    
            return 0;


    printf("""");
    return 0;
}

",32,1027,248
"struct node {
    int data;
    struct node * next;
}*head;
void createList(int n);
void displayList();

void insertAtN(int data, int position);


int main()
{
    int n, data;

    head = NULL;
    printf(""Enter the total number of nodes in list: "");
    scanf(""%d"", &n);
    createList(n);
    displayList();
    printf(""Enter node position: "");
    scanf(""%d"", &n);
    printf(""Enter data you want to insert at %d position: "", n);
    insertAtN(data, n);
    displayList();

    return 0;
}
void createList(int n)
{
    int i, data;
    struct node *prevNode, *newNode;

    if(n >= 1)
    {
        head = (struct node *)malloc(sizeof(struct node));
        printf(""Enter data of 1 node: "");
        scanf(""%d"", &data);

        head->data = data;
        head->next = NULL;

        prevNode = head;
        for(i=2; i<=n; i++)
        {
            newNode = (struct node *)malloc(sizeof(struct node));

            printf(""Enter data of %d node: "", i);
            scanf(""%d"", &data);

            newNode->data = data;
            newNode->next = NULL;
            prevNode->next = newNode;
            prevNode = newNode;
        }
        prevNode->next = head;

        printf(""\nCIRCULAR LINKED LIST CREATED SUCCESSFULLY\n"");
    }
}
void displayList()
{
    struct node *current;
    int n = 1;

    if(head == NULL)
    {
        printf(""List is empty.\n"");
    }
    else
    {
        current = head;
        printf(""DATA IN THE LIST:\n"");

        do {
            printf(""Data %d = %d\n"", n, current->data);

            current = current->next;
            n++;
        }while(current != head);
    }
}
void insertAtN(int data, int position)
{
    struct node *newNode, *current;
    int i;
    if(position == 1)
    {
    struct node *newNode, *current;
    newNode = (struct node *)malloc(sizeof(struct node));
    scanf(""%d"", &data);
    newNode->data = data;
    newNode->next = head;
    current = head;
    while(current->next != head)
        {
            current = current->next;
        }
        current->next = newNode;
        head = newNode;
    }
    else
    {
        newNode = (struct node *)malloc(sizeof(struct node));
        scanf(""%d"", &data);
        newNode->data = data;
        current = head;
        for(i=2; i<=position-1; i++)
        {
            current = current->next;
        }
        newNode->next = current->next;
        current->next = newNode;

        printf(""NODE INSERTED SUCCESSFULLY.\n"");
    }
}
",32,1028,795
"struct node {
    int data;
    struct node * prev;
    struct node * next;
}*head,*last;

void createList(int n);
void displayListFromFirst();

void insertAtBeginning(int data);
void insertAtN(int data, int position);


int main()
{
    int n, data;

    head = NULL;
    last = NULL;

    printf(""Enter the number of nodes you want to create: "");
    scanf(""%d"", &n);
    createList(n);
    displayListFromFirst();
    

    printf(""Enter node position: "");
    scanf(""%d"", &n);
    printf(""Enter data you want to insert at %d position: "", n);
    scanf(""%d"", &data);
    insertAtN(data, n);
    displayListFromFirst();
    

    return 0;
}
void createList(int n)
{
    int i, data;
    struct node *newNode;
            head = (struct node *)malloc(sizeof(struct node));
            printf(""Enter data of 1 node: "");
            scanf(""%d"", &data);

            head->data = data;
            head->prev = NULL;
            head->next = NULL;

            last = head;
            for(i=2; i<=n; i++)
            {
                newNode = (struct node *)malloc(sizeof(struct node));
                    printf(""Enter data of %d node: "", i);
                    scanf(""%d"", &data);

                    newNode->data = data;
                    newNode->prev = last;
                    newNode->next = NULL;

                    last->next = newNode;
                    last = newNode;
            }
        printf(""\nDOUBLY LINKED LIST CREATED SUCCESSFULLY\n"");
    }

void displayListFromFirst()
{
    struct node * temp;
        temp = head;
        printf(""\n\nDATA IN THE LIST From First:\n"");

        while(temp != NULL)
        {
            printf(""DATA = %d\n"", temp->data);
            temp = temp->next;
        }
    }
void insertAtBeginning(int data)
{
    struct node * newNode;

    if(head == NULL)
    {
        printf(""Error, List is Empty!\n"");
    }
    else
    {
        newNode = (struct node *)malloc(sizeof(struct node));

        newNode->data = data;
        newNode->next = head; 
        newNode->prev = NULL; 

        
        head->prev = newNode;

        
        head = newNode;

        printf(""NODE INSERTED SUCCESSFULLY AT THE BEGINNING OF THE LIST\n"");
    }
}
void insertAtEnd(int data)
{
    struct node * newNode;

    if(last == NULL)
    {
        printf(""Error, List is empty!\n"");
    }
    else
    {
        newNode = (struct node *)malloc(sizeof(struct node));

        newNode->data = data;
        newNode->next = NULL;
        newNode->prev = last;

        last->next = newNode;
        last = newNode;

        printf(""NODE INSERTED SUCCESSFULLY AT THE END OF LIST\n"");
    }
}
    void insertAtN(int data, int position)
{
    int i;
    struct node * newNode, *temp;

        if(position == 1)
        {
            insertAtBeginning(data);
        
}
        else if(temp!=NULL)
        {
             insertAtEnd(data);
            
        }
        else
        {
            printf(""Error, Invalid position\n"");
        }
    }





",32,1029,933
"int main()
{
    int
    a[5][5], b[5][5], sum=0;
    int r, c;
    for(r=0; r<=2; r++)
        {
            for(c=0; c<=2; c++)
            {
                scanf(""%d"", &a[r][c]);
            }
        }
        printf(""\n"");
        for(r=0; r<=2; r++)
        {
            for(c=0; c<=2; c++)
            {
                scanf(""%d"", &b[100][100]);
            }
        }
        printf(""\n"");
        for(r=0; r<=2; r++)
        {
            for(c=0; c<=2; c++)
            {
                sum=a[r][c];
            }
            printf(""%d"", sum);
        }
        return 0;
}
",32,1030,224
"#define MAX 6

int queue[MAX];
int front = 0;
int rear = 0;
int itemCount = 0;

int peek() {
   return queue[front];
}

bool isEmpty() {
   return itemCount == 0;
}

bool isFull() {
   return itemCount == MAX;
}



int enqueue(int data) {

   if(!isFull()) {
        rear=rear+1;
        queue[rear]=data;

   itemCount++;}
}

int dequeue() {
   int data;
   if(!isEmpty()){
   data = queue[front];
   front=front+1;
   itemCount--;}
   return data;
}

int main() {
   int num, n;
   enqueue(3);
   enqueue(5);
   enqueue(9);
   enqueue(1);
   enqueue(12);
   enqueue(15);

   if(isFull()){
      printf(""Queue is full!\n"");
   }

   num = dequeue();
   

   printf(""Element removed: %d\n"",num);
   enqueue(16);
   enqueue(17);
   enqueue(18);
   printf(""Element at front: %d\n"",peek());

   
   
   
   printf(""Queue:  "");

   while(!isEmpty()) {
      n = dequeue();
      printf(""%d "",n);
   }
}
",32,1031,369
"struct node
{
    int data;
    struct node *next;
}*head;
void createList(int n)
{
    struct node *newNode, *temp;
    int data, i;

    head = (struct node *)malloc(sizeof(struct node));
        printf(""Enter the data of node 1: "");
        scanf(""%d"", &data);

        head->data = data;
        head->next = NULL;

        temp = head;
        for(i=2; i<=n; i++)
        {
            newNode = (struct node *)malloc(sizeof(struct node));
                printf(""Enter the data of node %d: "", i);
                scanf(""%d"", &data);

                newNode->data = data;
                newNode->next = NULL;

                temp->next = newNode;

                temp = temp->next;
            }
}



void search(int key)
{
    while (head != NULL)
    {    if(head->data==key)
        {
            printf(""key Data found\n"");
            return;
       }
        head = head->next;
    }
    printf(""Key Data not found\n"");
}
void displayList()
{
    struct node *temp;
        temp = head;
        while(temp != NULL)
        {
            printf(""Data = %d\n"", temp->data);
            temp = temp->next;
        }
}
int main()
{
    int n, data,key;
    printf(""Enter the total number of nodes: "");
    scanf(""%d"", &n);
    createList(n);
    printf(""\nData in the list :\n"");
    displayList();

     printf(""\nEnter key to search: "");
    scanf(""%d"", &key);
    search(key);

    return 0;
}
",32,1032,448
"struct node{
int data;
struct node*next;
};
struct node*head;
void createList(int n);
void inab(int data);
void displayList();
int main()
{
    int n, data;
    printf(""Enter the total number of nodes: "");
    scanf(""%d"", &n);
    createList(n);

    printf(""\nData in the list \n"");
    displayList();
    printf(""\nEnter data to insert at beginning of the list: "");
    scanf(""%d"", &data);
    inab(data);

    printf(""\nData in the list \n"");
    displayList();

    return 0;
}
void createList(int n)
{
    struct node*mehedi;
    struct node*temp;
    int data, i;
    head=(struct node*)malloc(sizeof(struct node));
    printf(""Enter node data:"");
    scanf(""%d"", &data);
    head->data=data;
    head->next=NULL;
    temp=head;
    for(i=2;i<=n; i++)
    {
        mehedi=(struct node*)malloc(sizeof(struct node));
        printf(""Enter node data:"");
        scanf(""%d"", &data);
        mehedi->data=data;
        mehedi->next=NULL;
        temp->next=mehedi;
        temp=temp->next;
    }
}
void inab(int data)
{
    struct node*peloon;
    peloon=(struct node*)malloc(sizeof(struct node));
    peloon->data=data;
    peloon->next=head;
    head=peloon;
}
void displayList()
{
    struct node*temp;
    temp=head;
    while(temp!=NULL)
    {
        printf(""%d\n"", temp->data);
        temp=temp->next;
    }
}
",32,1033,462
"struct node {
    int data;
    struct node * prev;
    struct node * next;
}*head,*last;

void createList(int n);
void displayListFromFirst();
void displayListFromEnd();

int main()
{
    int n, data;

    head = NULL;
    last = NULL;

    printf(""Enter the number of nodes you want to create: "");
    scanf(""%d"", &n);
    createList(n);
    displayListFromFirst();
    displayListFromEnd();
    return 0;
}
void createList(int n)
{
    int i, data;
    struct node *newNode;
            head = (struct node *)malloc(sizeof(struct node));
            printf(""Enter data of 1 node: "");
            scanf(""%d"", &data);

            head->data = data;
            head->prev = NULL;
            head->next = NULL;

            last = head;
            for(i=2; i<=n; i++)
            {
                newNode = (struct node *)malloc(sizeof(struct node));
                    printf(""Enter data of %d node: "", i);
                    scanf(""%d"", &data);

                    newNode->data = data;
                    newNode->prev = last;
                    newNode->next = NULL;

                    last->next = newNode;
                    last = newNode;
            }
        printf(""\nDOUBLY LINKED LIST CREATED SUCCESSFULLY\n"");
    }

void displayListFromFirst()
{
    struct node * temp;
        temp = head;
        printf(""\n\nDATA IN THE LIST From First:\n"");

        while(temp != NULL)
        {
            printf(""DATA = %d\n"", temp->data);
            temp = temp->next;
        }
    }
void displayListFromEnd()
{
    struct node * temp;
        temp = last;
        printf(""\n\nDATA IN THE LIST From End:\n"");

        while(temp != NULL)
        {
            printf(""DATA = %d\n"", temp->data);
            temp = temp->prev;
        }
}

",32,1034,529
"void * aleatorio();

int main(){

    int n = 2;
    float total = 0, * subtotal;
    pthread_t hilos[n];

    for (int i = 0; i < n; i++){ pthread_create(&hilos[i], NULL, (void *) aleatorio, NULL); } 
    

    for (int i = 0; i < n; i++){
        
       pthread_join(hilos[i], (void **) &subtotal); 
       
       printf(""Valor recibido: %f\n"", *subtotal); 
       total = total + *subtotal; 
    }
    printf(""la suma del total es: %f\n"", total);

    exit(EXIT_SUCCESS);
     
}    

void * aleatorio(){

    float f1 = drand48()*10, f2 = drand48()*10;
    float * f3 = calloc(1, sizeof(float));
    *f3 = f1+f2;
    printf(""%f + %f = %f\n"", f1, f2, *f3);

    pthread_exit((void *) f3); 
    
    
}",33,1035,303
"#define n 3                                     

int v[n];                                       
int indiceConsumicion = 0;                      
int indiceProduccion = 0;                       
int hebraProductor = 0;                         
int hebraConsumidor = 0;                        

sem_t mutex;                                    
sem_t full;                                     
sem_t empty;                                    

void producirDato(int numero){                  
    v[indiceProduccion] = numero;               
    indiceProduccion = (indiceProduccion +1)%n; 
    for(int i=0; i<n; i++){                     
            printf(""|%d"", v[i]);
    }
    printf(""|"");
}

int consumirDato(){                                 
    int numConsumido= v[indiceConsumicion];         
    v[indiceConsumicion] = '\0';                    
    indiceConsumicion = (indiceConsumicion +1)%n;   
        for(int i=0; i<n; i++){                     
            printf(""|%d"", v[i]);
        }
    printf(""|"");
    return numConsumido;                            
}

void * productor(){                                         
    sem_wait(&empty);                                       
    sem_wait(&mutex);                                       
    hebraProductor++;                                       
    int numero = rand()%101;                                
    producirDato(numero);                                   
    printf(""---->Productor %d, Dato %d\n"",hebraProductor, numero);
    sem_post(&mutex);                                       
    sem_post(&full);                                        
    
    pthread_exit(NULL);                                     
}

void * consumidor(){                                        
    sem_wait(&full);                                        
    sem_wait(&mutex);                                       
    hebraConsumidor++;                                      
    int numero = consumirDato();                            
    printf(""---->Consumidor %d, Dato: %d\n"", hebraConsumidor, numero);
    sem_post(&mutex);                                       
    sem_post(&empty);                                       
    
    pthread_exit(NULL);                                     
}

int main(){
    srand(time(NULL));                  

    sem_init(&mutex, 0, 1);             
    sem_init(&full, 0, 0);              
    sem_init(&empty, 0, n);             


    pthread_t threadProductor[3];       
    pthread_t threadConsumidor[3];      

    for (int i=0; i<3; i++){
        if(pthread_create(&threadProductor[i], NULL, productor, NULL)){                         
            printf(""Error, no se ha podido crear la hebra. Codigo de error %d\n"", errno);
            exit(EXIT_FAILURE);
        }
    }

    for (int i=0; i<3; i++){                                                                    
        if(pthread_create(&threadConsumidor[i], NULL, consumidor, NULL)){
            printf(""Error, no se ha podido crear la hebra. Codigo de error %d\n"", errno);
            exit(EXIT_FAILURE);
        }
    }
    
    for (int i=0; i<3; i++){
        if (pthread_join(threadProductor[i], NULL)){                                            
            printf(""Error, no se ha podido recoger la hebra. Codigo de error %d\n"", errno);
            exit(EXIT_FAILURE);
        }
    }

    for (int i=0; i<3; i++){
        if (pthread_join(threadConsumidor[i], NULL)){                                           
            printf(""Error, no se ha podido recoger la hebra. Codigo de error %d\n"", errno);
            exit(EXIT_FAILURE);
        }
    }
    
    for(int i=0; i<n; i++){                                     
        printf(""Valor %d del buffer: %d\n"", i+1, v[i]);
    }
    exit(EXIT_SUCCESS);                                         
}",33,1036,1055
"void * cuentaLineas( void * argv ){

    int * numeroLineas = malloc(sizeof(int));

    * numeroLineas = 0;
    
    char const * fichero;

    char aux[256];

    fichero = (char*) argv;

    FILE* f = fopen(fichero, ""r""); 

    if (f==NULL){

        printf(""Error al abrir el archivo\n""); 
        EXIT_FAILURE;
    }

    while(fgets(aux, 256, f)!=NULL){ ++*numeroLineas; } 
    
    fclose(f);
 
    pthread_exit( (void**) numeroLineas);
}


int main(int argc, char const * argv[] ){

    int totalLineas = 0;

    int * retorno;

    pthread_t hilos[argc-1];

    for (int i = 0; i < argc-1; i++){
    
        if ( pthread_create( &(hilos[i]), NULL, (void *) cuentaLineas, (void *) argv[i+1] ) != 0){
        
            fprintf(stderr, ""Error en la creacion de la hebra \n"");

            exit(EXIT_FAILURE);
        }
        
    }

    for (int i = 0; i < argc-1; i++){
    
        if ( pthread_join( hilos[i], (void **) &retorno ) != 0){
        
            fprintf(stderr, ""Error al hacer join \n"");

            exit(EXIT_FAILURE);
        }

        printf(""El numero de lineas del fichero %i es %d \n"", i + 1, *retorno);


        totalLineas = totalLineas + *retorno;
    }
    
    printf(""El numero de lineas totales son %i \n"", totalLineas);

    return 0;
}",33,1037,505
"int main(int argc, char * argv[]){

    switch (fork()){

        case -1:

                printf(""ERROR"");
                exit(EXIT_FAILURE);
                break;

        case 0: 

                printf(""soy el hijo numero %d; mi padre es %d\n"", getpid(), getppid); 
                execlp(argv[1], argv[1], NULL);
                exit(EXIT_SUCCESS);
                
                break;
    }

    
    switch (fork()){

        case -1:

                printf(""ERROR"");
                exit(EXIT_FAILURE);
                break;

        case 0: 

                printf(""soy el hijo numero %d; mi padre es %d\n"", getpid(), getppid); 
                execvp(argv[2], argv+2);
                exit(EXIT_SUCCESS);
                break;
    }


    return 0;
}",33,1038,242
"void tratarSignal() { printf(""SeÃ±al recibida\n""); }

int main(){

    pid_t pid;

    printf(""Soy %d el padre de todos\n"", getpid()); 

    pid = fork();

    switch(pid){


        case -1: 

            printf(""Error al crear el proceso hijo\n""); 
            exit(EXIT_FAILURE);

        case 0:

            signal(SIGUSR1, tratarSignal);      

            printf(""Soy %d el hijo del proceso: %d\n"", getpid(), getppid()); 

            for (int i = 0; i < 5; i++){      
        
                pause();
            }

            sleep(10);


        default: 

            printf(""Esperando a que acabe mi hijo\n"");

            for (int i = 0; i < 5; i++){ 
      
                sleep(3);
                kill(pid, SIGUSR1);
            }

            sleep(3);
            kill(pid, SIGKILL);
    }
   
  exit(EXIT_SUCCESS); 
}",33,1039,294
"int main(){

    int n=5, status;

    printf(""Padre con ID %d \n"", getpid());
    printf(""\n"");

    for (int i=0; i<n; i++){
        
        switch (fork()){ 
        
        case -1:
            printf(""Error en la creaciÃ³n \n"");
            exit(EXIT_FAILURE);
        
        case 0:
            printf(""Hijo %d con ID %d, padre: %d \n"", i+1, getpid(), getppid());
            exit(EXIT_SUCCESS); 

        default:
            printf(""Esperando hijo numero %d \n"", i+1);
            wait(&status); 
            printf(""Hijo %d termindo con ID %d, codigo de salida: %d \n"", i+1, getpid(), WEXITSTATUS(status)); 
            printf(""\n"");

        }

        
    } 

    return 0;
}",33,1040,244
"int indiceGlobal = 0;                                   
int par = 0;                                      
int impar = 0;                                  
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;    


int main( int argc, const char * argv[]){
    
    if (argc != 2){      
        
        printf(""Error\n"");
        exit(EXIT_FAILURE);
    }

    srand(time(NULL));      
    
    int n = atoi(argv[1]);     
    
    int *resultado;          
    
    pthread_t thread[n];        

    for(int i=0; i<n; i++){

        if (pthread_create(&thread[i], NULL, suma, (void *) &indiceGlobal)){  
           
            printf(""Error %d\n"", errno);
            exit(EXIT_FAILURE);
        }
    }
    
    for(int i=0; i<n; i++){
        
        if (pthread_join(thread[i], (void **) &resultado )){

            printf(""Error %d\n"", errno);
            exit(EXIT_FAILURE);
        }
    }

    printf(""Valor del par %d\n"", par);      
    printf(""Valor del impar %d\n"", impar);

    exit(EXIT_SUCCESS);     
}

void * suma(void * n){               
        
    int *indiceLocal= (int *)n;            
    int *suma = malloc(sizeof(int *));    

    for (int i = 0; i < 5 ; i++){                               
                        
        int x = rand()%11;      
        *suma = *suma + x; 
    }

    if (pthread_mutex_lock(&mutex)){                  

        printf(""Error %d"", errno);
        exit(EXIT_FAILURE);
    }

    indiceGlobal++; 
       
    printf(""Hebra %ld con indice %d\n"", pthread_self(), *indiceLocal);
    printf(""La suma en %d es %d\n"", *indiceLocal, *suma); 

    if(*indiceLocal%2==0){ par = par + *suma; }                                              
   

    else{ impar = impar + *suma; }                                                               

    if (pthread_mutex_unlock(&mutex)){      

        printf(""Error %d"", errno);
        exit(EXIT_FAILURE);
    }

    pthread_exit((void *)suma);                                           
}
",33,1041,667
"int main(){

        switch ( fork() ){

        case -1: 
            perror(""fork error:\n"");
            fprintf(stderr, ""errno:  %i\n"", errno); 
            exit(EXIT_FAILURE);
            break;

        case 0: 
            printf(""soy un proceso hijo con PID: %i; el PID de mi proceso padre es: %i\n"", getpid(), getppid());
            break;

        default:
            sleep(10);
            exit(EXIT_FAILURE);
        }

}",33,1042,147
"void * generarNumeros(){

    int * z = malloc(sizeof(int)); 

    int x = rand() % 10;
    printf(""x = %i \n"", x);

    int y = rand() % 10;
    printf(""y = %i \n"", y);

    *z = x + y;

    printf(""x + y = %i \n"", *z);

    pthread_exit(z);
}


int main(int argc, char const *argv[]){

    srand (time(NULL));

    int nHebras = atoi(argv[1]);

    pthread_t thread[nHebras]; 

    int *numero, suma=0; 

    for (int i = 0; i < nHebras; i++){
   
        if( pthread_create( &(thread[i]), NULL, (void*) generarNumeros, NULL ) != 0 ){ 

            fprintf(stderr, ""Error al crear la hebra"");         
            exit(EXIT_FAILURE);                                 
        }
    }


    for (int i = 0; i < nHebras; i++){
   
        if( pthread_join( thread[i], (void **) &numero ) != 0 ){ 

            fprintf(stderr, ""Error al usar join"");         
            exit(EXIT_FAILURE);                  
        }

        suma = suma + *numero;
    }
    
    printf(""%i"", suma);

    return 0;
}

",33,1043,397
"int main(){

    int nHijos=5, hijo, status;

    printf(""Padre con ID %d \n"", getpid());
    printf(""\n"");

    for (int i=0; i<nHijos; i++){
        
        hijo=fork(); 
            
        switch (hijo){
        
        case -1:

            printf(""Error en la creaciÃ³n \n"");
            exit(EXIT_FAILURE);
        
        case 0:

            printf(""Hijo %d con ID %d del proceso %d \n"", i+1, getpid(), getppid());
            printf(""\n"");
            break;

        default:

            printf(""Esperando hijo numero %d \n"", i+1);
            wait(&status);
            printf(""Hijo %d termindo con ID %d, codigo de salida: %d \n"", i+1, getpid(), WEXITSTATUS(status));
            printf(""\n"");
            exit(EXIT_SUCCESS);

        }

        
    } 

    return 0;
}",33,1044,270
"int main(int argc, char * argv[]){

    int status;

    printf(""Soy el proceso %d\n"", getpid());

    for (int i = 0; i < argc - 1; i++){


        switch (fork()){

            case -1:

                    printf(""ERROR"");
                    exit(EXIT_FAILURE);
                    break;

            case 0: 

                    printf(""soy el hijo numero %d; mi padre es el proceso: %d\n"", getpid(), getppid); 

                        printf("" %i \n"", factorial( atoi(argv[i+1]) ) );
                    exit(EXIT_SUCCESS);
                
                    break;

            default:

                    wait(&status); 
        }

    }

    return 0;
}


int factorial(int n){ 

  int resultado = 1;

  for (int i = n; i > 0; i--) {

    resultado *=i;
  }
  
  return resultado;
}",33,1045,274
"void tratarSennal (int signo) { printf(""recibida seÃ±al tratada por hijo""); }

int main(void){

    pid_t pid, pidHijo;
    int status, o=0;

    switch (pid) {

    case -1:

        exit(EXIT_FAILURE);
        break;

    case 0:

        signal(SIGUSR1, tratarSennal);

        for (int i = 0; i < 5; i++) pause();
        
        exit(EXIT_SUCCESS);
        break;    
    
    default:

        for (int i = 0; i < 5; i++){

            sleep(1);
            kill(pid,SIGUSR1);
        }

        pidHijo=wait(&status);
        break;
    }
}",33,1046,213
"int main(int argc, char * argv[]){

    int status;
    pid_t pid[2]; 

    switch ( fork() ){

            case -1: 
                perror(""fork error:\n"");
                fprintf(stderr, ""errno:  %i\n"", errno); 
                exit(EXIT_FAILURE);
                break;

            case 0: 
                printf(""soy un proceso hijo con PID: %i; el PID de mi proceso padre es: %i\n"", getpid(), getppid());
                
                
                
                exit(EXIT_SUCCESS); 
            }

    switch ( fork() ){

            case -1: 
                perror(""fork error:\n"");
                fprintf(stderr, ""errno:  %i\n"", errno); 
                exit(EXIT_FAILURE);
                break;

            case 0: 
                printf(""soy un proceso hijo con PID: %i; el PID de mi proceso padre es: %i\n"", getpid(), getppid());
                execlp(""open"", ""open"", ""-t"", argv[1], argv[2], NULL); 
                exit(EXIT_SUCCESS); 
            }

    pid[0]=wait(&status);
    pid[1]=wait(&status);


        
}


",33,1047,341
"int main(){

    int n, status;
    pid_t pid; 

    printf(""introduce el numero de procesos:\n"");
    scanf(""%i"", &n);

    for (int i = 0; i < n; i++){

        switch ( fork() ){

        
        
        

        case -1: 
            perror(""fork error:\n"");
            fprintf(stderr, ""errno:  %i\n"", errno); 
            exit(EXIT_FAILURE);
            break;

        case 0: 
            printf(""soy un proceso hijo con PID: [%i]; el PID de mi proceso padre es: [%i]\n"", getpid(), getppid());
            break;

        default:

            pid = wait(&status); 
            
            

            if (pid > 0){ 
        
                if      (WIFEXITED(status))   printf(""1 el hijo %i ha sido finalizado con la seÃ±al %i\n"", pid, WEXITSTATUS(status));
                else if (WIFSIGNALED(status)) printf(""2 el hijo %i ha sido finalizado con la seÃ±al %i\n"", pid, WTERMSIG(status));
                else if (WIFSTOPPED(status))  printf(""3 el hijo %i ha sido finalizado con la seÃ±al %i\n"", pid, WSTOPSIG(status));
                exit(EXIT_SUCCESS);
            }
            else{ 
                printf(""fallo en la invocacion\n"");
                exit(EXIT_FAILURE);
            }
            

        }

    }
    
    exit(EXIT_SUCCESS);

}",33,1048,426
"int variableGlobal = 0;

int main(){

    int n=5, status;

    printf(""Padre con ID %d \n"", getpid());
    printf(""\n"");

    for (int i=0; i<n; i++){
        
        switch (fork()){ 
        
        case -1:

            printf(""Error en la creaciÃ³n \n"");
            exit(EXIT_FAILURE);
        
        case 0:

            printf(""Hijo %d con ID %d, padre: %d \n"", i+1, getpid(), getppid());

            variableGlobal++;
            printf(""%i\n"", variableGlobal);

            exit(EXIT_SUCCESS); 

        default:

            printf(""Esperando hijo numero %d \n"", i+1);
            wait(&status); 
            printf(""Hijo %d termindo con ID %d, codigo de salida: %d \n"", i+1, getpid(), WEXITSTATUS(status)); 
            printf(""\n"");

        }

        
    } 

    printf(""%i\n"", variableGlobal);

    return 0;
}",33,1049,286
"int factorial(int n);

int main(int argc, char * argv[]){

    int status;
    pid_t pid; 

    int n=0;

    for (int i = 0; i < argc-1; i++){

        switch ( fork() ){

            case -1: 
                perror(""fork error:\n"");
                fprintf(stderr, ""errno:  %i\n"", errno); 
                exit(EXIT_FAILURE);

            case 0: 
                printf(""soy un proceso hijo con PID: %i; el PID de mi proceso padre es: %i\n"", getpid(), getppid());
                sleep(1);
                n = atoi(argv[i+1]);
                printf(""el factorial de %i es %i\n"", n, factorial(n));
                sleep(1);
                exit(EXIT_SUCCESS); 
        }

        pid=wait(&status);
    }

    
}

int factorial(int n){

   int fact=1;

   if( n<0 ) return 0;

   if(n==0) return 1;

   for (int i = 1; i <= n; ++i) {fact = fact*i;} 
      
   return fact;
   
}",33,1050,330
"void * aumentaVariableGlobal();

int variableGlobal = 0;

int main(int argc, char * argv[]){


    int nHilos = 2; 

    pthread_t hilos[nHilos];

    for (int i = 0; i < nHilos; i++){ pthread_create(&hilos[i], NULL, aumentaVariableGlobal, NULL );
                                      pthread_join(hilos[i], NULL); }

    

    printf(""la variable global suma %i \n"", variableGlobal);
    
}

void * aumentaVariableGlobal(){

    for (int i = 0; i < 1000; i++)
    {
        variableGlobal++;
        printf(""%i\n"", variableGlobal);
    }

    printf(""la hebra ha aumentado %i veces\n"", variableGlobal);
    
    pthread_exit(NULL); 

}
",33,1051,232
"typedef struct{

  int * vector;
  int numeroElementos;

} vInfo;

int comprobacionArgumento(int argumento){

  if (argumento==2 || argumento==5){ return 1; }

  return 0;
}

int * reservarMemoria(int numeroElementos){

    int *vector;

    vector = (int *) malloc( numeroElementos * sizeof(int) );

    return vector;
}

void rellenaVector(int *vector, int numeroElementos){

    srand( time(NULL) );

    for (int i = 0; i < numeroElementos; ++i){ vector[i] = (rand() % 9) + 1; }
}

void imprimeVector (int *vector, int numeroElementos){

    printf(""["");
    printf("" %d "", vector[0]);

    for (int i = 1; i < numeroElementos; ++i){ printf("", %d "", vector[i]); }

    printf(""]\n"");
    printf(""\n"");
}

vInfo * creaHijos(int * vPadre, int numeroHilos){

    int numeroElementos = 10 / numeroHilos;

    vInfo * vHijos = (vInfo *) malloc (numeroHilos * sizeof(vInfo));

    for (int i=0;i<numeroHilos;i++){

        vHijos[i].vector = reservarMemoria(numeroElementos);

        vHijos[i].numeroElementos = numeroElementos;

        int k = 0;

        for (int j = (i * numeroElementos); j < ( (i * numeroElementos) + numeroElementos ); j++){

            vHijos[i].vector[k] =vPadre[j];

            k++;
        }

        printf(""El vector hijo es: \n"");
    
        imprimeVector(vHijos[i].vector, vHijos->numeroElementos);
    }

    return vHijos;
}

void * sumaHilos (void* d){

    int * suma = malloc( sizeof(int) );

    *suma = 0;

    vInfo *v;

    v = (vInfo*) d;

    for (int i = 0; i < v->numeroElementos; i++){

        *suma = *suma + v->vector[i];
    }
         
    printf(""La suma de los elementos de este vector es: %d \n"", *suma);

    pthread_exit((void**) suma);
}

int main(int argc, char const *argv[]){

    if( argc < 2 || comprobacionArgumento( atoi(argv[1]) ) == 0 ){

        printf(""Error llame al programa de la siguiente forma:\n"");
        printf(""./E3 2. o /E3 5\n"");

        exit(EXIT_FAILURE);
    }

    int numeroHilos = atoi(argv[1]);

    vInfo *vPadre = malloc( sizeof(vInfo) ); 

    vPadre->numeroElementos = 10;
  
    vPadre->vector = reservarMemoria( vPadre->numeroElementos );

    rellenaVector( vPadre->vector, vPadre->numeroElementos );

    printf(""El vector padre es: \n"");

    imprimeVector( vPadre->vector, vPadre->numeroElementos );

    vInfo * vHijos = creaHijos(vPadre->vector, numeroHilos); 

    pthread_t hilos[numeroHilos];

    int * retorno, suma = 0;

    for (int i = 0; i < numeroHilos; i++){

        if( pthread_create( &hilos[i], NULL, (void *) sumaHilos, (void *) vHijos+( sizeof(vInfo)*i ) ) != 0 ){

            fprintf(stderr, ""Error creating thread\n"");
            exit(EXIT_FAILURE); 
        }
    }

    for (int i = 0; i < numeroHilos; i++){
    
        if(pthread_join( hilos[i], (void**) &retorno) ){
        
            fprintf(stderr, ""Error joining thread\n"");
            exit(EXIT_FAILURE);
        }

        suma += *retorno;
    }    

    printf(""\nLa suma de los numeros de todos los vectores es: %d\n"", suma);
    exit(EXIT_SUCCESS);
}",33,1052,1180
"int main(){

    int n, status;
    pid_t pid; 

    printf(""introduce el numero de procesos:\n"");
    scanf(""%i"", &n);

    for (int i = 0; i < n; i++){

        switch ( fork() ){

        
        
        

        case -1: 
            perror(""fork error:\n"");
            fprintf(stderr, ""errno:  %i\n"", errno); 
            exit(EXIT_FAILURE);
            break;

        case 0: 
            printf(""soy un proceso hijo con PID: %i; el PID de mi proceso padre es: %i\n"", getpid(), getppid());
            exit(EXIT_SUCCESS); 
        }
    }

    for (int i = 0; i < n; i++){

        pid = wait(&status); 
        
        

        if (pid > 0){ 
        
            if      (WIFEXITED(status))   printf(""1 el hijo %i ha sido finalizado con la seÃ±al %i\n"", pid, WEXITSTATUS(status));
            else if (WIFSIGNALED(status)) printf(""2 el hijo %i ha sido finalizado con la seÃ±al %i\n"", pid, WTERMSIG(status));
            else if (WIFSTOPPED(status))  printf(""3 el hijo %i ha sido finalizado con la seÃ±al %i\n"", pid, WSTOPSIG(status));
        
        }
        else{ 
            printf(""fallo en la invocacion\n"");
            exit(EXIT_FAILURE);
        }
         
    }
    
    exit(EXIT_SUCCESS);

}",33,1053,436
"int main(){

    int status;
    pid_t hijo;

    printf(""Soy el padre \n"");
    printf(""\n"");

    hijo = fork();

    if (hijo == -1){

        printf(""Error \n"");
        exit(EXIT_FAILURE);
    }

    if (hijo == 0){

        printf(""HIJO ID: %d \n"", getpid());
        exit(EXIT_SUCCESS);
    }

    else{

        printf(""sleep 20s \n"");
        sleep(20);

        wait(&status);

        printf(""Proceso hijo termindo con el codigo %d \n"", WEXITSTATUS(status));

        sleep(20);
        exit(EXIT_SUCCESS);
    }

    return 0;
}",33,1054,206
"#define n 5 

int v[n];      

int indiceConsumicion = 0;                    
int indiceProduccion = 0;

sem_t mutex;                                   
sem_t full;                                    
sem_t empty;                                    


int main(){

    srand(time(NULL));                  

    sem_init(&mutex, 0, 1);             
    sem_init(&full, 0, 0);              
    sem_init(&empty, 0, n);           

    pthread_t threadProductor;        
    pthread_t threadConsumidor;        

    if(pthread_create(&threadProductor, NULL, productor, NULL)){ printf(""Error %d\n"", errno); exit(EXIT_FAILURE); }

    if(pthread_create(&threadConsumidor, NULL, consumidor, NULL )){ printf(""Error %d\n"", errno); exit(EXIT_FAILURE); }
    
    if (pthread_join(threadProductor, NULL)){ printf(""Error %d\n"", errno); exit(EXIT_FAILURE); }
    
    if (pthread_join(threadConsumidor, NULL)){ printf(""Error %d\n"", errno); exit(EXIT_FAILURE); }
   
    for(int i=0; i<n; i++){ printf(""Valor %d del buffer: %d\n"", i+1, v[i]); }
    
    exit(EXIT_SUCCESS);                                        
}


void * productor(){ 

    for (int i=0; i<10; i++){   
        
        sem_wait(&empty);                                                          
        sem_wait(&mutex);  
        
        int numero = rand()%101;    
        
        producirDato(numero);
        
        printf(""Productor:\n"");
        printf(""Dato %d: %d\n"", i+1, numero);
        
        sem_post(&mutex);                                  
        sem_post(&full);                                   
    }
    
    pthread_exit(NULL);                                   
}

void * consumidor(){  
    
    for (int i=0; i<10; i++){ 
        
        sem_wait(&full);                                    
        sem_wait(&mutex);    
        
        int numero = consumirDato();
        
        printf(""Consumidor:\n"");
        printf(""---->Consumidor, Dato %d: %d\n"", i+1, numero);
        
        sem_post(&mutex);                             
        sem_post(&empty);                                                
    }
    
    pthread_exit(NULL);                 
}


void producirDato(int numero){    

    v[indiceProduccion] = numero;    
    
    indiceProduccion = (indiceProduccion +1)%n; 
    
    for(int i=0; i<n; i++){ printf(""%d "", v[i]); }
}

int consumirDato(){                      

    int numConsumido= v[indiceConsumicion];   
    
    v[indiceConsumicion] = '\0';  
    
    indiceConsumicion = (indiceConsumicion +1)%n;   
    
    for(int i=0; i<n; i++){ printf(""%d "", v[i]); }

    return numConsumido;   
}



",33,1055,856
"int i=0;

void RING(){    

    printf(""RING\n"");

    i++;    

    if (i==4){  
  
        kill(getpid(), SIGKILL);    
    }
  
}

int main(int argc, char const *argv[]){

    signal(SIGALRM, RING);  

    alarm(5);     
    pause();      

    alarm(3);     
    pause();      

    while (1){    

        alarm(1);   
        pause();    
    } 

    exit(EXIT_SUCCESS);     
}",33,1056,155
"void Display(int *a,int n)
    {
        int i;
        for(i=0;i<n;i++)
            printf(""%d "",*(a+i));
    }
int* Reverse(int *a,int n)
    {
        int i,j=0,*b;
        b=(int *)malloc(n*sizeof(int *));
        for(i=n-1;i>=0;i--)
        {
            *(b+j)=*(a+i);
            j++;
        }       
        return b;
    }
int main()
    {
        int *a,m,i;
        
        printf(""\n Enter size of array1:: "");
        scanf(""%d"",&m);
        
        a=(int *)malloc(m*sizeof(int *));
        
        printf(""\n Enter %d elements of array::"",m);
        for(i=0;i<m;i++)
            scanf(""%d"",&a[i]);
            
        printf(""\n Before reverse"");
        printf(""\n Array:"");
        Display(a,m);
    
        Reverse(a,m);  
        
        printf(""\n After reverse"");
        printf(""\n Array:"");
        Display(Reverse(a,m),m);
        
        return 0;
    }
",34,1057,320
"int Mystrlen(char *str)
    {
        int i;
        for(i=0;i<str[i]!=0;i++);
        
        return i;
        
    }

char* RemoreExSpace(char *str)
    {
        int i, j;
    char * newString;
    i=Mystrlen(str);
    newString = (char *)malloc(i);

    i = 0;
    j = 0;

    while(str[i] != '\0')
    {
        
        if(str[i] == ' ')
        {
            newString[j] = ' ';
            j++;

            
            while(str[i] == ' ')
                i++;
        }

        newString[j] = str[i];

        i++;
        j++;
    }
    
    newString[j] = '\0';

    return newString;
    }

int main()
    {
        int i,n;
        char str[50];
        printf(""\n Enter the string:"");
        gets(str);
        
        printf(""\n Before removal of extra space:"");
        printf(""%s"",str);
        
        printf(""\n After removal of extra space:"");
        printf(""%s"",RemoreExSpace(str));
        printf(""Good bye"");
        return 0;
    }
",34,1058,337
"int Mystrlength(char *str)
    {
        int i;
        for(i=0;i<str[i]!='\0';i++);
        return i;   
    }
char * ReverseWord(char str[])
    {
        int d,s,k=0,t,j;
        char *temp= malloc(Mystrlength(str));
        s=Mystrlength(str)-1;
        d=Mystrlength(str)-1;
        while(s>0)
            {
            if(str[s]== ' ')    
                {
                    for(j=s+1;j<=d;j++)
                        {
                            temp[k]=str[j];     
                            k++;
                        }
                    temp[k++]=' ';
                    d=s-1;
                }
            s--;
            }
        for(j=0;j<=d;j++)
            {
                temp[k]=str[j]; 
                k++;    
            }
        temp[k]= '\0';
        return temp;
    }
int main()
    {
        char str[20],*temp;
        int n,s,d,k=0;
        printf(""\n Enter the string:: "");
        gets(str);
        
        temp=ReverseWord(str);
        printf(""Reverse Ordered words is::%s"",temp);
    
        return 0;
    }
    
    
",34,1059,356
"void displayMat(float **mat,int r,int c);
float deterMat(float **mat,int r,int c);
int main()
    {
    int i,j,r,c;
    float **mat,temp;
    printf(""Enter the row & col. of the matrix "");
    scanf(""%d%d"",&r,&c);
    
    if(r!=c)
        printf(""For determinant matrix should be square"");
    else
        {
        mat=(float **)malloc(r*sizeof(float *));        
                                                
        for(i=0;i<r;i++)
            mat[i]=(float *)malloc(c*sizeof(float));    
    
        printf(""\n Enter the matrix \n"");
        for(i=0;i<r;i++)
        for(j=0;j<c;j++)
        scanf(""%f"",&mat[i][j]);
            
        printf(""The matrix is:\n"");
        displayMat(mat,r,c);
    
        temp=deterMat(mat,r,c);
        
        printf(""Determinant of the matrix is:= %f\n"", temp);
        }
    return 0;
    }   
void displayMat(float **mat,int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
        {
        for(j=0;j<c;j++)
        printf(""%f "",mat[i][j]);
        printf(""\n"");
        }
    }
float deterMat(float **mat,int r,int c)
    {
    int i,j,k;
    float det,ratio;
    for(i = 0; i < r; i++)
        {
            for(j = 0; j < c; j++)
                {
                    if(j>i)
                        {
                        ratio = mat[j][i]/mat[i][i];
                        for(k = 0; k < r; k++)
                                mat[j][k] -= ratio * mat[i][k];
                        }
                }
            }
        det = 1; 
        for(i = 0; i < r; i++)
            det *= mat[i][i];
        return det;
        }
    

",34,1060,567
"void displayarr(int arr[],int len);
int removeDuplicates(int arr[],int n);
int main()
    {
    int *arr,i,n,sum=0;
    printf(""Enter how many numbers you want to store into array"");
    scanf(""%d"",&n);
    
    arr=(int *)malloc((n)*sizeof(int *));   
    
    printf(""\nEnter %d elements"",n);
    for(i=0;i<n;i++)
    scanf(""%d"",&arr[i]);
    
    n=removeDuplicates(arr,n);
    
    printf(""\nAfter removing duplicates: "");
    displayarr(arr,n);
    return 0;
    }
int removeDuplicates(int arr[],int n)
    {
    int i,j=0,*temp,k;
    if(n==0||n==1)
        return n;
    
    temp=(int *)malloc((n)*sizeof(int *));
    
    for(i=0;i<n;i++)
        {
        for(j=i+1;j<n;)
            {
            if(arr[i]==arr[j])
                {
                for(k=j;k<n;k++)
                    arr[k]=arr[k+1];
                n--;
                }
            else
                j++;    
            }
        }
    return n;
    }
void displayarr(int arr[],int len)
    {
    int i;
    for(i=0;i<len;i++)
        printf(""%d "",arr[i]);
    }
",34,1061,397
"int main()
    {
    int n,i,j,k;
    
    printf(""Enter how many row"");
    scanf(""%d"",&n);
    
    for(i=1;i<=n;i++)
        {
        for(j=1;j<=n-i;j++)
            printf("" "");
        for(k=1;k<=2*i-1;k++)
            {
                if(k==1||i==n||k==2*i-1)
                    printf(""*"");
                else
                    printf("" "");
            }
        printf(""\n"");
        }
    printf(""\n\n"");
        return 0;
    }   







",34,1062,173
"int main()
    {
    int n,i,j;
    
    printf(""Enter how many row"");
    scanf(""%d"",&n);
    
    for(i=1; i<=n; i++)
            {
            for(j=1; j<=n-i; j++)
                    printf("" "");
    
            for(j=1;j<=n;j++)
                {
                if(i==1||i==n||j==1||j==n)
                    printf(""*"");
                else    
                    printf("" "");
                }
            printf(""\n"");
            }

    printf(""\n\n"");
        return 0;
    }   







",34,1063,172
"int Mystrcompare(char *str1,char *str2)
    {
    int m=Mystrlen(str1),flag=0,i;
    int n=Mystrlen(str2);
    
    if(m>n)
        return m-n;
    else if(m<n)
        return m-n;
    else 
        {
        for(i=0;i<m;i++)
            {
                if(str1[i]!=str2[i])
                    {
                        flag=1;
                        break;
                    }
            }
            if(flag==0)
                return 0;
            else 
                return 1;
        }
    
    }
int Mystrlen(char *str)
    {
        int i;
        for(i=0;i<str[i]!='\0';i++);
        
        return i;
    }
int main()
    {
        char str1[20],str2[20];
        int i=0,len1,j=0,k;
        printf(""\n Enter the first string"");
        gets(str1);
        printf(""\n Enter the second string"");
        gets(str2);
        
        
        printf(""\n Mystrcompare(%s,%s)=%d"",str1,str2,Mystrcompare(str1,str2));
        return 0;
    }
    
    
",34,1064,347
"void displayarr(int arr[],int len);
int main()
    {
    int *arr,temp,n,i,j;
    printf(""Enter how many numbers you want to store into array"");
    scanf(""%d"",&n);
    
    arr=(int *)malloc(n*sizeof(int *)); 
    
    printf(""Enter %d elements"",n);
    for(i=0;i<n;i++)
    scanf(""%d"",&arr[i]);        
    
    printf(""Original array: "");
    displaymatrix(arr,n);
    
    for(i=n-1,j=0;i>j;i--,j++)      
        {
        temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
        }
    
    printf(""\nReversed array: "");
    displaymatrix(arr,n);           
    return 0;
    }

void displayarr(int arr[],int len)
    {
    int i;
    for(i=0;i<len;i++)
        printf(""%d "",arr[i]);
    }
    
    
",34,1065,277
"int r,c,m,n;
void Display(int **mat3)
    {
    int i,j;
    for(i=0;i<r;i++)
        {
        for(j=0;j<n;j++)
            printf(""%-3d "",mat3[i][j]);
        printf(""\n"");
        }
    }
int **Product(int **mat1,int **mat2,int **mat3)
    {
    int i,j,k;
    for(i=0;i<r;i++)
        {
        for(j=0;j<n;j++)
                {
                mat3[i][j]=0;
                for(k=0;k<c;k++)
                    mat3[i][j]+=mat1[i][k]*mat2[k][j];
                }
        }
    return mat3;
    }
int main()
    {
        int i,j;
        int **mat1,**mat2,**mat3;
        printf(""Enter the row & col. of the first matrix "");
        scanf(""%d%d"",&r,&c);
        printf(""Enter the row & col. of the second matrix "");
        scanf(""%d%d"",&m,&n);
        if(c==m)
            {
                mat1=(int **)malloc(r*sizeof(int *));       
                                                
                mat2=(int **)malloc(m*sizeof(int *));
            
                mat3=(int **)malloc(r*sizeof(int *));       
        
                for(i=0;i<r;i++)
                mat1[i]=(int *)malloc(c*sizeof(int));   
            
                for(j=0;j<m;j++)
                mat2[j]=(int *)malloc(n*sizeof(int));
        
                for(j=0;j<r;j++)
                mat3[j]=(int *)malloc(n*sizeof(int));
        
                printf(""\n Enter the first matrix "");
                for(i=0;i<r;i++)
                    {
                    for(j=0;j<c;j++)
                    scanf(""%d"",&mat1[i][j]);
                    }
                printf(""\n Enter the second matrix"");
                for(i=0;i<m;i++)
                    {
                    for(j=0;j<n;j++)
                    scanf(""%d"",&mat2[i][j]);
                    }
        
                Product(mat1,mat2,mat3);
                
                printf(""\n The Resultant matrix is \n"");
                Display(mat3);
                
                free(mat1);
                free(mat2);
                free(mat3);
                }
        else
        printf(""OOPS!!Multiplication not possible.."");
    return 0;
    }   

",34,1066,700
"int main()
    {
    int n,i,j;
    
    printf(""Enter how many row"");
    scanf(""%d"",&n);
    
    for(i=1;i<=n;i++)
        {
        for(j=1;j<=n;j++)   
            {
            if(i==1||i==n||j==1||j==n||i==j||i+j==n+1)
                {
                printf(""*"");
                }
            else 
                printf("" "");
            }   
        printf(""\n"");
        }

    printf(""\n\n"");
        return 0;
    }   







",34,1067,166
"int Mystrlen(char *str)
    {
        int i;
        for(i=0;i<str[i]!=0;i++);
        
        return i;
        
    }

char* Trimleading(char *str)
    {
        int i=0,j,c=0,n;
        char *temp;
        n=Mystrlen(str);
        
        while(str[c]==' '||str[c]=='\t'||str[c]=='\n')
            {
                c++;
            }
    
        for(j=c;j<=n-1;j++)
            {
                str[i]=str[j];  
                
                i++;
            }
        str[i]='\0';
        
        return str;
    }

int main()
    {
        int i,n;
        char str[50];
        printf(""\n Enter the string"");
        gets(str);
        
        printf(""\n Before trimming::"");
        printf(""%s"",str);
        
        printf(""\n After trimming::"");
        printf(""%s"",Trimleading(str));
        
        return 0;
    }
",34,1068,291
"FILE *openfile(char *,char *);
int mergefile(char *,char *,char *);
void main()
    {
    int cf  ;

    cf=mergefile(""File71.txt"",""File72.txt"",""File7.txt"");
    if(cf==1)
        printf(""Merge done"");
    else
        printf(""Merge not done"");
    getch();
    }
int mergefile(char *fp1,char *fp2,char *fp3)
    {
    FILE *one,*two,*three;
    int ch;
    
    one=openfile(fp1,""r"");
    two=openfile(fp2,""r"");
    three=openfile(fp3,""w"");
    
    if(one==NULL||two==NULL||three==NULL)
        return 0;
        
    while((ch=fgetc(one))!=EOF)
        fputc(ch,three);
        
    while((ch=fgetc(two))!=EOF)
        fputc(ch,three);
    return 1;
    }
FILE *openfile(char *path,char *mode)
    {
    FILE *fp;
    fp=fopen(path,mode);
    if(fp==NULL)
        {
        perror(""File opening error (:"");
        getch();
        exit(0);
        }
    return fp;
    }
",34,1069,348
"int main()
    {
    int n,i,j;
    
    printf(""Enter how many row"");
    scanf(""%d"",&n);
    
    for(i=1;i<=n;i++)
        {
        for(j=1;j<=i;j++)
            {
                if(j==1||j==i||i==n)
                    printf(""*"");
                else
                    printf("" "");
            }
        printf(""\n"");
        }
    printf(""\n\n"");
        return 0;
    }   







",34,1070,142
"int Mystrlen(char *str)
    {
        char *s=str;
        while(*str)
            str++;
        return str-s;
    }
char *Mystrrev(char *str)
    {
        char *begin,*end,temp;
        char *rev;
        int n=Mystrlen(str),i;
        
        begin=str;
        end=str;
        for(i=0;i<n-1;i++)
            end++;
        
        for(i=0;i<n/2;i++)
            {
                temp=*end;
                printf(""%c "",*end);
                *end=*begin;
                *begin=temp;
                begin++;
                end--;
            }
        return str;
    }
int main()
    {
        char str[30],*t;
        printf(""\n Enter the string"");
        scanf(""%s"",str);
        
        printf(""\n Reverse of the string is:: "");
        t=Mystrrev(str);
        puts(t);
    }

",34,1071,262
"#define size 255
int MyMax(int a[],int n)
    {
        int i,max=0;
        for(i=0;i<n;i++)
            {
                if(a[i]>a[max])
                    {
                        max=i;
                    }   
            }
        printf(""%d"",max);
        return max;
    }

int main()
    {
        int freq[size],i,c=0,t;
        char str[size],ch;
        printf(""\n Enter the string"");
        gets(str);
        
        for(i=0;i<size;i++)
                freq[i]=0;
                
        for(i=0;i<str[i]!='\0';i++)
            {
                t=(int)str[i];
                freq[t]=freq[t]+1;
            }
                
        
        for(i=0;i<size;i++)
            printf(""%d "",freq[i]);
            
        i=MyMax(freq,size);
        printf(""\n No of occurrence of '%c' is =%d"",i,freq[i]);
        return 0;
    }
",34,1072,299
"int main()
    {
    int n,i,j;
    
    printf(""Enter how many row"");
    scanf(""%d"",&n);
    
    for(i=1;i<=n;i++)
        {
        for(j=1;j<=2*n-1;j++)   
            {
            if(i+j>=n+1&&i+j<2*n+1)
                {
                printf(""*"");
                }
            else 
                printf("" "");
            }   
        printf(""\n"");
        }

    printf(""\n\n"");
        return 0;
    }   







",34,1073,160
"#define size 255
int MyMin(int a[],int n)
    {
        int i,min=0;
        for(i=0;i<n;i++)
            {
                if(a[i]!=0)
                    {
                    if(a[i]<a[min]||a[min]==0)
                        min=i;
                    }
                    
            }
        return min;
    }

int main()
    {
        int freq[size],i,c=0,t;
        char str[size],ch;
        printf(""\n Enter the string"");
        gets(str);
        
        for(i=0;i<size;i++)
                freq[i]=0;
                
        for(i=0;i<str[i]!='\0';i++)
            {
                t=(int)str[i];
                freq[t]=freq[t]+1;
            }
                
        
        for(i=0;i<size;i++)
            printf(""%d "",freq[i]);
            
        i=MyMin(freq,size);
        printf(""\n No of occurrence of '%c' is =%d"",i,freq[i]);
        return 0;
    }
",34,1074,313
"int IsIdentity(int **mat,int r,int c);
int **Transpose(int **mat1,int **mat2,int r,int c);
int **MultiMat(int **mat1,int **mat2,int **temp,int r,int c,int n);
int main()
    {
    int i,j,r,c,**mat1,**mat2,**temp;
    printf(""Enter the row & col. for the matrix"");
    scanf(""%d%d"",&r,&c);
    mat1=(int **)malloc(r*sizeof(int *));   
    mat2=(int **)malloc(r*sizeof(int *));   
    temp=(int **)malloc(r*sizeof(int *));                                       
    
    for(i=0;i<r;i++)
        mat1[i]=(int *)malloc(c*sizeof(int ));
        
    for(i=0;i<r;i++)
        mat2[i]=(int *)malloc(c*sizeof(int ));
    
    for(i=0;i<r;i++)
        temp[i]=(int *)malloc(c*sizeof(int ));
            

    printf(""\n Enter the matrix \n"");
    for(i=0;i<r;i++)
    for(j=0;j<c;j++)                
    scanf(""%d"",&mat1[i][j]);
    
    Transpose(mat1,mat2,r,c);
    MultiMat(mat1,mat2,temp,r,c,c);
    
    if(IsIdentity(temp,r,c))
        printf(""\nOrthogonal matrix"");
    else
        printf(""Matrix is not orthogonal matrix"");
        
    return 0;
    }
int ** Transpose(int **mat1,int **mat2,int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
    for(j=0;j<c;j++)
        mat2[i][j]=mat1[j][i];
    return mat2;
    }
int ** MultiMat(int **mat1,int **mat2,int **temp,int r,int c,int n)
    {
    int i,j,k;
        
        for(i=0;i<r;i++)
            {
            for(j=0;j<n;j++)
                {
                temp[i][j]=0;
                for(k=0;k<c;k++)
                    temp[i][j]+=mat1[i][k]*mat2[k][j];
                }
            }
        return temp;
        }
int IsIdentity(int **mat,int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
        {
        for(j=0;j<c;j++)
            {
            if((i!=j)&&(mat[i][j]!=0))
                return 0;
            else if((i==j)&&(mat[i][j])!=1)
                return 0;
            }
        }
    return 1;
    }   
",34,1075,776
"int main()
    {
        int i,j,k=0,n,m;
        char name[20];
        printf(""Enter Name"");
        gets(name);
        printf(""Enter value of n"");
        scanf(""%d"",&n);
        m=strlen(name);
        
        for(i=n/2;i<n;i=i+2)
            {
                for(j=1;j<n-i;j=j+2)
                    printf("" "");
                for(j=1;j<=i;j++)
                    printf(""*"");
                for(j=1;j<=i-4*k;j++)
                    printf("" "");
                for(j=1;j<=i;j++)
                    printf(""*"");
            k++;
                printf(""\n"");
            }
        for(i=n;i>=1;i--)
            {
                for(j=1;j<=n-i;j++)
                    printf("" ""); 
                if(i==n)
                    {
                    for(j=1;j<=(n*2-m)/2;j++)   
                        printf(""*"");
                    printf(""%s"",name);
                    for(j=1;j<(n*2-m)/2;j++)    
                        printf(""*"");
                    }
                else
                    {
                    for(j=1;j<=2*i-1;j++)
                        printf(""*"");    
                    }
                printf(""\n"");
            }
        printf(""\n"");
        return 0;
        
    }
",34,1076,391
"int SumUpperTri(int mat[][20],int r)
    {
    int i,j,sum=0;
    for(i=0;i<r;i++) 
        {
        for(j=0;j<r;j++) 
            {
            if(i<=j)
                sum=sum+mat[i][j];
            }
        }
    return sum;
    }

int main()
    {
    int i,j,r,c,mat1[20][20];
    printf(""Enter the row & col. for the matrix"");
    scanf(""%d%d"",&r,&c);
    
    if(r!=c)
        printf(""Upper triangualr matrix or not matrix should be square"");
    else
        {
        printf(""\n Enter the matrix \n"");
        for(i=0;i<r;i++)
        for(j=0;j<c;j++)                
        scanf(""%d"",&mat1[i][j]);
        
        printf(""The sum of the Upper triangular matrix=%d"",SumUpperTri(mat1,r));    
        }
    return 0;
    }   


",34,1077,287
"void displayMat(int mat[][20],int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
        {
        for(j=0;j<c;j++)
        printf(""%d "",mat[i][j]);
        printf(""\n"");
        }
    }
void AddMat(int mat1[][20],int mat2[][20],int r,int c)
    {
    int i,j,temp[20][20];
            
    for(i=0;i<r;i++)
        {
        for(j=0;j<c;j++)
            temp[i][j]=mat1[i][j]+mat2[i][j];
        }
    displayMat(temp,r,c);
    }
int main()
    {
    int i,j,r,c,mat1[20][20],mat2[20][20];
    printf(""\n Enter the row & col. for two matrix(Both should be same)"");
    scanf(""%d%d"",&r,&c);
    
    if(r!=c)
        printf(""\n For Addition matrix should be square"");
    else
        {       
        printf(""\n Enter the first matrix \n"");
        for(i=0;i<r;i++)
        for(j=0;j<c;j++)                
        scanf(""%d"",&mat1[i][j]);
        
        printf(""\n Enter the second matrix \n"");
        for(i=0;i<r;i++)
        for(j=0;j<c;j++)                
        scanf(""%d"",&mat2[i][j]);
        
        printf(""\n The addtion of two matrix is:\n"");
        AddMat(mat1,mat2,r,c);
        }
    return 0;
    }
",34,1078,461
"int IsSymmetric(int mat1[][20],int mat2[][20],int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
        {
        for(j=0;j<c;j++)
            {
            if(mat1[i][j]!=mat2[i][j])
                return 0;
            }
        }
    return 1;
    }
int ** Transpose(int mat1[][20],int mat2[][20],int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
    for(j=0;j<c;j++)
        mat2[i][j]=mat1[j][i];
    return mat2;
    }

int main()
    {
    int i,j,r,c,mat1[20][20],mat2[20][20];
    printf(""Enter the row & col. for the matrix"");
    scanf(""%d%d"",&r,&c);
    
    printf(""\n Enter the matrix \n"");
    for(i=0;i<r;i++)
    for(j=0;j<c;j++)                
    scanf(""%d"",&mat1[i][j]);
    
    if(IsSymmetric(mat1,Transpose(mat1,mat2,r,c),r,c))
        printf(""\nSymmetric matrix"");
    else
        printf(""\nMatrix is not Symmetric matrix"");
        
    return 0;
    }

",34,1079,392
"int main()
    {
        int mat1[20][20],mat2[20][20],i,j,n,flag=0;
        printf(""\nEnter the order of matrix"");
        scanf(""%d"",&n);
        
        printf(""\n Enter first matrix"");
        for(i=0;i<n;i++)
        for(j=0;j<n;j++)
        scanf(""%d"",&mat1[i][j]);
        
        printf(""\n Enter second matrix"");
        for(i=0;i<n;i++)
        for(j=0;j<n;j++)
        scanf(""%d"",&mat2[i][j]);
        
        for(i=0;i<n;i++)
            {
                for(j=0;j<n;j++)
                    {
                        if(mat1[i][j]!=mat2[i][j])
                        {
                        flag=1;
                        break;  
                        }       
                    }
            }
        if(flag==0)
            printf(""\n Two matrix are equal"");
        else
            printf(""\n Two matrix are different"");
        return 0;
    }
",34,1080,293
"int main()
    {
    int n,i,j,k;
    
    printf(""Enter how many row"");
    scanf(""%d"",&n);
    
    for(i=n;i>=1;i--)
        {
        for(j=n;j>i;j--)
            printf("" "");
        for(j=1;j<=2*i-1;j++)
            {
                if(j==2*i-1||j==1||i==n)
                    printf(""*"");
                else
                    printf("" "");
            }
        printf(""\n"");
        }
    printf(""\n\n"");
        return 0;
    }   







",34,1081,173
"int isEven(int n)
    {
        if(n%2==0)
            return 1;
        else 
            return 0;
    }
int isPrime(int n)
    {
        int i,flag=0;
        for(i=2;i<n/2;i++)
            {
                if(n%i==0)
                    {
                        return 0;
                    }
            }
        return 1;
    }
int main()
    {
        FILE *fptr,*eptr,*optr,*pptr;
        int n;
        
        fptr=fopen(""File3.txt"",""r"");
        eptr=fopen(""FIle3Even.txt"",""w"");
        optr=fopen(""FIle3Odd.txt"",""w"");
        pptr=fopen(""FIle3Prime.txt"",""w"");
        if(fptr==NULL||eptr==NULL||optr==NULL||pptr==NULL)
            {
                perror(""File openning error(:"");
                getch();
                exit(0);
            }
            
        while(fscanf(fptr,""%d"",&n)!=EOF)
            {
                if(isPrime(n))
                    fprintf(pptr,""%d "",n);
                if(isEven(n))
                    fprintf(eptr,""%d "",n);
                else
                    fprintf(optr,""%d "",n);  
            }
            
        printf(""\n Successfully written into file..."");
        
        fclose(fptr);
        fclose(eptr);
        fclose(optr);
        fclose(pptr);
        
        return 0;
    }

",34,1082,427
"int main()
    {
    int n,i,j,k,f;
    
    printf(""Enter how many columns"");
    scanf(""%d"",&n);
    f=1;
    
    for(i=1;i<=2*n-1;i++)
        {
            for(j=1;j<=f;j++)   
                printf(""*"");
            if(i<n)
                f++;
            else
                f--;
        printf(""\n"");
        }
        
    printf(""\n\n"");
        return 0;
    }   







",34,1083,147
"int checkIdentity(int mat[][20],int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
        {
        for(j=0;j<c;j++)
            {
            if((i!=j)&&(mat[i][j]!=0))
                return 0;
            else if((i==j)&&(mat[i][j])!=1)
                return 0;
            }
        }
    return 1;
    }   
int main()
    {
    int i,j,r,c,mat1[20][20],mat2[20][20];
    printf(""Enter the row & col. for the matrix"");
    scanf(""%d%d"",&r,&c);

    printf(""\n Enter the matrix \n"");
    for(i=0;i<r;i++)
    for(j=0;j<c;j++)                
    scanf(""%d"",&mat1[i][j]);
        
    if(checkIdentity(mat1,r,c)==1)
        printf(""Matrix is identity matrix of order %d"",r);
    else
        printf(""Matrix is not identity matrix"");
        
    return 0;
    }


",34,1084,310
"int **Transpose(int **mat1,int **mat2,int r,int c);
int IsSymmetric(int **mat1,int **mat2,int r,int c);
int main()
    {
    int i,j,r,c,**mat1,**mat2;
    printf(""Enter the row & col. for the matrix"");
    scanf(""%d%d"",&r,&c);
    mat1=(int **)malloc(r*sizeof(int *));   
    mat2=(int **)malloc(r*sizeof(int *));   
                                    
    
    for(i=0;i<r;i++)
        mat1[i]=(int *)malloc(c*sizeof(int ));
        
    for(i=0;i<r;i++)
        mat2[i]=(int *)malloc(c*sizeof(int ));

            

    printf(""\n Enter the matrix \n"");
    for(i=0;i<r;i++)
    for(j=0;j<c;j++)                
    scanf(""%d"",&mat1[i][j]);
    
    if(IsSymmetric(mat1,Transpose(mat1,mat2,r,c),r,c))
        printf(""\nSymmetric matrix"");
    else
        printf(""\nMatrix is not Symmetric matrix"");
        
    return 0;
    }
int IsSymmetric(int **mat1,int **mat2,int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
        {
        for(j=0;j<c;j++)
            {
            if(mat1[i][j]!=mat2[i][j])
                return 0;
            }
        }
    return 1;
    }
int ** Transpose(int **mat1,int **mat2,int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
    for(j=0;j<c;j++)
        mat2[i][j]=mat1[j][i];
    return mat2;
    }
",34,1085,524
"void Display(int *a,int n)
    {
        int i;
        for(i=0;i<n;i++)
            printf(""%d "",*(a+i));
    }
int Search(int *a,int n,int item)
    {
        int i,j=0,pos=0;
        for(i=0;i<n;i++)
            {
            if(*(a+i)==item)
                {
                    pos=i+1;
                    break;
                }
            }       
        return pos;
    }
int main()
    {
        int *a,m,i,item;
        
        printf(""\n Enter size of array1:: "");
        scanf(""%d"",&m);
        
        a=(int *)malloc(m*sizeof(int *));
        
        printf(""\n Enter %d elements of array::"",m);
        for(i=0;i<m;i++)
            scanf(""%d"",&a[i]);
        
        printf(""\n Enter the item to found"");
        scanf(""%d"",&item);
        
        i=Search(a,m,item);
        
        if(i==0)
            printf(""\n %d is not found"",item);
        else
            printf(""\n %d is found at position %d"",item,i);
    
        return 0;
    }
",34,1086,333
"int main()
    {
    int n,i,j;
    
    printf(""Enter how many row"");
    scanf(""%d"",&n);
    
    for(i=1;i<=n;i++)
        {
        for(j=1;j<i;j++)
            printf("" "");
        
        for(j=1;j<=n;j++)
            printf(""*"");
            
        printf(""\n"");
        
        }

    printf(""\n\n"");
        return 0;
    }   







",34,1087,136
"void baseconversion(char s[20],int,int);
int main()
{   
    char s[20];
    int base1,base2;
    printf(""Enter the number and base:"");
    scanf(""%s%d"",s,&base1);
    printf(""Enter the base to be converted:"");
    scanf(""%d"",&base2);
    baseconversion(s,base1,base2);
    return 0;
}

void baseconversion(char s[20],int b1,int b2)
{
    int count=0,r,digit,i,n=0,b=1;
    for(i=strlen(s)-1;i>=0;i--)
        {
         if(s[i]>='A'&&s[i]<='Z')
            {
             digit=s[i]-'0'-7;
            }
         else
            {
             digit=s[i]-'0';
            }
        n=digit*b+n;
        b=b*b1;
        }
    while(n!=0)
    {
        r=n%b2;
        digit='0'+r;
        if(digit>'9')
        {
            digit+=7;
        }
         s[count]=digit;
         count++;
         n=n/b2;
    }
    for(i=count-1;i>=0;i--)
        {
        printf(""%c"",s[i]);
        }
    printf(""\n"");
    }
    
",34,1088,378
"void displayMat(int mat[][20],int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
        {
        for(j=0;j<c;j++)
        printf(""%-3d "",mat[i][j]);
        printf(""\n"");
        }
    }
void Product(int mat1[][20],int mat2[][20],int r,int c)
    {
    int i,j,temp[20][20],k;
    
    for(i=0;i<r;i++)
            {
            for(j=0;j<c;j++)
                {
                temp[i][j]=0;
                for(k=0;k<c;k++)
                    temp[i][j]+=mat1[i][k]*mat2[k][j];
                }
            }
    displayMat(temp,r,c);
    }
int main()
    {
    int i,j,r,c,mat1[20][20],mat2[20][20];
    printf(""\n Enter the row & col. for two matrix(Both should be same): "");
    scanf(""%d%d"",&r,&c);
    
    if(r!=c)
        printf(""\n For Addition matrix should be square"");
    else
        {       
        printf(""\n Enter the first matrix \n"");
        for(i=0;i<r;i++)
        for(j=0;j<c;j++)                
        scanf(""%d"",&mat1[i][j]);
        
        printf(""\n Enter the second matrix \n"");
        for(i=0;i<r;i++)
        for(j=0;j<c;j++)                
        scanf(""%d"",&mat2[i][j]);
    
        
        printf(""\n The addtion of two matrix is:\n"");
        Product(mat1,mat2,r,c);
        }
    return 0;
    }
",34,1089,497
"int main()
    {
    int n,i,j;
    
    printf(""Enter how many row"");
    scanf(""%d"",&n);
    
    for(i=1;i<=n;i++)
        {
        for(j=1;j<i;j++)
            printf("" "");
        
        for(j=1;j<=n;j++)
            {
                if(i==1||i==n||j==1||j==n)
                    printf(""*"");
                else
                    printf("" "");
            }
        printf(""\n"");
        }

    printf(""\n\n"");
        return 0;
    }   







",34,1090,168
"int main()
    {
    int n,i,j;
    
    printf(""Enter how many row"");
    scanf(""%d"",&n);
    
    for(i=1;i<=n;i++)
        {
        for(j=1;j<i;j++)
            printf("" "");
        for(j=1;j<=n-i+1;j++)
            {
            if(i==1||j==n-i+1||j==1)    
                printf(""*"");
            else 
                printf("" "");
            }
        printf(""\n"");
        }
    printf(""\n\n"");
        return 0;
    }   







",34,1091,169
"int* Myreturn(int *a,int n)
    {
    int i;
    for(i=0;i<n;i++)
        *(a+i)=2*(*(a+i));

    return a;
    }
int main()
    {
        int *a,m,i;
        
        printf(""\n Enter size of array1:: "");
        scanf(""%d"",&m);
        
        a=(int *)malloc(m*sizeof(int *));
        
        printf(""\n Enter %d elements of array::"",m);
        for(i=0;i<m;i++)
            scanf(""%d"",&*(a+i));
        
        Myreturn(a,m);
        
        printf(""\n Result:: "");
        for(i=0;i<m;i++)
            printf(""%d "",*(a+i));
        return 0;
    }
",34,1092,217
"int main()
    {
    float a,b,c,t,t1,t2,real,ima;
    printf(""Enter the co-efficients of the quadratic equation"");
    scanf(""%f%f%f"",&a,&b,&c);
    
    t=sqrt(b*b-4*a*c);
    printf(""%f"",t);
    
    if(t>0)
        {
        t1=(-b+t)/(2*a);
        t2=(-b-t)/(2*a);
        printf(""\nRoots are unequal and roots are %.2f %.2f\n"",t1,t2);
        }
    else if(t==0)   
        {
        printf(""\nTwo roots are equal and roots are %.2f %.2f\n"",-b/(2*a),-b/(2*a));
        }
    else
        {
        real=-b/(2*a);
        ima=sqrt(4*a*c-b*b)/(2*a);
        printf(""\nTwo distinct complex Roots are %.2f+i%.2f and %.2f-i%.2f \n"",real,ima,real,ima);
        }
    return 0;
    }   
        
    
    

    
        
",34,1093,315
"int main()
    {
    int unit;
    float pay,Surpay;
    printf(""\nEnter the unit consumed\n"");
    scanf(""%d"",&unit);
        
    if(unit<=50)
        {
        pay=unit * 0.50;
        unit=unit-50;
        }

    if(unit<=150)
        {       
        pay=pay+unit*0.75;
        unit=unit-100;
        }
    if(unit<=250)
        {
        pay=pay+unit*1.20;
        unit=unit-100;
        }
    else
        {
        pay=pay+unit*1.50;
        }

    Surpay=pay*0.2;
    pay=pay+Surpay;

    printf(""\nPay of %f\n"",pay);    

    printf(""\n"");   
    return 0;
    }   
        
    
    

    
        
",34,1094,249
"void Mysort(int *a,int n)
    {
    int i,j,temp;
    for(i=0;i<n-1;i++)
        {
        for(j=0;j<n-i-1;j++)
            {
            if(*(a+j)>*(a+j+1)) 
                {
                    temp=*(a+j);
                    *(a+j)=*(a+j+1);
                    *(a+j+1)=temp;
                }
            }
        }
    }
int main()
    {
        int *a,m,i;
        
        printf(""\n Enter size of array1:: "");
        scanf(""%d"",&m);
        
        a=(int *)malloc(m*sizeof(int *));
        
        printf(""\n Enter %d elements of array::"",m);
        for(i=0;i<m;i++)
            scanf(""%d"",&*(a+i));
        
        Mysort(a,m);
        
        printf(""\n After sorting:: "");
        for(i=0;i<m;i++)
            printf(""%d "",*(a+i));
        return 0;
    }
",34,1095,293
"void prefixSuffixArray(char* pat, int M, int* pps) {
   int length = 0;
   pps[0] = 0;
   int i = 1;
   while (i < M) {
      if (pat[i] == pat[length]) {
         length++;
         pps[i] = length;
         i++;
      } else {
         if (length != 0)
         length = pps[length - 1];
         else {
            pps[i] = 0;
            i++;
         }
      }
   }
}
void KMPAlgorithm(char* text, char* pattern) {
   int M = strlen(pattern),c=0;
   int N = strlen(text);
   int pps[M];
   prefixSuffixArray(pattern, M, pps);
   int i = 0;
   int j = 0;
   while (i < N) {
      if (pattern[j] == text[i]) {
         j++;
         i++;
      }
      if (j == M) {
         c++;
         j = pps[j - 1];
      }
      else if (i < N && pattern[j] != text[i]) {
         if (j != 0)
         j = pps[j - 1];
         else
         i = i + 1;
      }
   }
printf(""\n No of matching occurence is:=%d"",c);
}
int main() {
   char text[100];
   char pattern[100];
   printf(""\n Enter the string "");
   gets(text);
   printf(""\n Enter the string "");
   gets(pattern);
  
   KMPAlgorithm(text, pattern);
   return 0;
}
",34,1096,436
"int main()
    {
    int amount,tt=0,ot=0,fh=0,h=0,f=0,tw=0,te=0,five=0,to=0,one=0;
    printf(""Enter amount"");
    scanf(""%d"",&amount);
    
    if(amount>=2000)
        {
        tt=amount/2000;
        amount=amount-2000*tt;
        }
    if(amount>=1000)
        {
        ot=amount/1000;
        amount=amount-1000*ot;
        }
    if(amount>=500)
        {
        fh=amount/500;
        amount=amount-500*fh;
        }
    if(amount>=100)
        {
        h=amount/100;
        amount=amount-100*h;
        }
    if(amount>=50)
        {
        f=amount/50;
        amount=amount-50*f;
        }
    if(amount>=20)
        {
        tw=amount/20;
        amount=amount-20*tw;
        }
    if(amount>=10)
        {
        te=amount/10;
        amount=amount-10*te;
        }
    if(amount>=5)
        {
        five=amount/5;
        amount=amount-5*five;
        }
    if(amount>=2)
        {
        to=amount/2;
        amount=amount-10*to;
        }
    else
        {
        one=amount;
        }
    printf(""\n Total number of notes"");
    printf(""\n2000: %d"",tt);
    printf(""\n1000: %d"",ot);
    printf(""\n500: %d"",fh);
    printf(""\n100: %d"",h);
    printf(""\n50: %d"",f);
    printf(""\n20: %d"",tw);
    printf(""\n10: %d"",te);
    printf(""\n5: %d"",five);
    printf(""\n2: %d"",to);
    printf(""\n1: %d\n"",one);

    return 0;
    }
",34,1097,574
"int main()
    {
    int n,i,j;
    
    printf(""Enter how many row"");
    scanf(""%d"",&n);
    
    for(i=1;i<=n;i++)
        {
        for(j=1;j<=n;j++)   
            {
            if(i==1||i==n||j==1||j==n)
                printf(""*"");
            else
                printf("" "");
            }
        printf(""\n"");
        }

    printf(""\n\n"");
        return 0;
    }

    







",34,1098,148
"int main()
    {
        FILE *fptr;
        char str[100];
        int n;
        
        fptr=fopen(""File4.txt"",""a"");
    
        if(fptr==NULL)
            {
                perror(""File openning error(:"");
                getch();
                exit(0);
            }
            
        
        printf(""\n Enter contents to append in file4::"");
        fflush(stdin);
        fgets(str,100,stdin);   
        
        
        fputs(str,fptr);
        
        printf(""\n Successfully append into file..."");
        
        fclose(fptr);
        
        return 0;
    }

",34,1099,176
"void Display(int **a,int m,int n)
    {
        int i,j;
        for(i=0;i<m;i++)
            {
                for(j=0;j<n;j++)
                    printf(""%d "",*(*(a+i)+j));
                printf(""\n"");
            }
    }

int main()
    {
        int **a,m,n,i,j,item;
        
        printf(""\n Enter row and column of 2D array:: "");
        scanf(""%d%d"",&m,&n);
        
        a=(int **)malloc(m*sizeof(int **));
        for(i=0;i<m;i++)
            a[i]=(int *)malloc(n*sizeof(int));  
        
        printf(""\n Enter %d elements of array::"",m*n);
        for(i=0;i<m;i++)
        for(j=0;j<n;j++)
            scanf(""%d"",(*(a+i)+j));
        
        printf(""\n The entered 2D-array is::\n"");
        Display(a,m,n);
        
        return 0;
    }
",34,1100,292
"int main()
    {
        int n,i,j,k,c=1;
        printf(""Enter no of rows"");
        scanf(""%d"",&n);
        
        for(i=1;i<=2*n-1;i++)
            {
                if(i<=n)
                    {
                        for(j=1;j<=n-i;j++)
                            printf("" "");
                            
                        for(j=1;j<=2*i-1;j++)
                            printf(""*"");
                    }
                else
                    {
                    for(j=i-n;j>=1;j--) 
                        printf("" "");
                        
                    for(j=1;j<=2*(i-2*c)-1;j++)
                        printf(""*"");
                    c++;
                    }
            printf(""\n"");
            }
    printf(""\n\n"");
    return 0;
    }




























",34,1101,260
"int main()
    {
    float p,c,b,m,ca,t;
    printf(""Enter makrs of Physics"");
    scanf(""%f"",&p);

    printf(""Enter makrs of Chemistry"");
    scanf(""%f"",&c);
    
    printf(""Enter makrs of Bialogy"");
    scanf(""%f"",&b);
        
    printf(""Enter makrs of Mathematics"");
    scanf(""%f"",&m);
    
    printf(""Enter makrs of Computer"");
    scanf(""%f"",&ca);
    
    t=((p+c+b+m+ca)/500)*100;
        
    if(t>=90)
        printf(""\nGRADE A\n"");
    
    else if(t>=90)
        printf(""\nGRADE A\n"");
    
    else if(t>=80)
        printf(""\nGRADE B\n"");
    
    else if(t>=70)
        printf(""\nGRADE C\n"");
    
    else if(t>=60)
        printf(""\nGRADE D\n"");

    else if(t>=40)
        printf(""\nGRADE E\n"");

    else
        printf(""\nGRADE F\n"");

    printf(""\n"");   
    return 0;
    }   
        
    
    

    
        
",34,1102,345
"void removeWord(char *buffer,char *str)
    {
        int m,n,f,i,j;
        m=strlen(buffer);
        n=strlen(str);
        
        
        
        
    }
int main()
    {
        FILE *fptr1,*fptr2;
        int ;
        char str[1000],buffer[1000];
        
        printf(""\n Enter word to remove"");
        scanf(""%s"",str);
        
        fptr1=fopen(""File8.txt"",""r"");
        fptr2=fopen(""File8Final.tmp"",""w"");
        
        if(ptr1==NULL||ptr2==NULL)
            {
                printf(""\n File not exit"");
                exit(1);
            }
        
        while((fgets(buffer,1000,fptr1))!=NULL)
            {
            removeWord(buffer,str);
            fputs(buffer,fptr2);
            }
        
        
        fclose(fptr1);
        fclose(fptr2);
        
        remove(""File8.txt"");
        
        rename(""File8.tmp"",""File8.txt"");
        
        printf(""\n Successfully removed"");
        
        return 0;
    }
",34,1103,313
"int main()
    {
    int mno;
    printf(""Enter the month number"");
    scanf(""%d"",&mno);

    if(mno==1)
        printf(""\n January months 31 days\n"");
    else if(mno==2) 
        printf(""\n February month 28 or 29 days\n"");
    else if(mno==3) 
        printf(""\n March month 31 days\n"");     
    else if(mno==4) 
        printf(""\n April month 30 days\n"");
    else if(mno==5) 
        printf(""\n May month 31 days\n"");   
    else if(mno==6) 
        printf(""\n June month 30 days\n"");
    else if(mno==7) 
        printf(""\n July month 31 days\n"");  
    else if(mno==8) 
        printf(""\n August month 31 days\n"");
    else if(mno==9) 
        printf(""\n September month 30 days\n"");     
    else if(mno==10) 
        printf(""\n October month 31 days\n"");
    else if(mno==11) 
        printf(""\n November month 30 days\n"");      
    else if(mno==12) 
        printf(""\n December month 31 days\n"");
    else
        printf(""\n OOPS!! Enter corrent month number\n"");
    return 0;
    }




",34,1104,377
"FILE *openfile(char *,char *);
int copyfile(char *,char *);
void main()
    {
    int cf  ;
    
    cf=copyfile(""File6To.txt"",""File6From.txt"");
    if(cf==1)
        printf(""Copy done"");
    else
        printf(""Copy not done"");
    getch();
    }
int copyfile(char *to,char *from)
    {
    FILE *t,*f;
    int ch;
    t=openfile(to,""w"");
    f=openfile(from,""r"");
    if(f==NULL||t==NULL)
        return 0;
    while((ch=fgetc(f))!=EOF)
        fputc(ch,t);
    return 1;
    }
FILE *openfile(char *path,char *mode)
    {
    FILE *fp;
    fp=fopen(path,mode);
    if(fp==NULL)
        {
        perror(""File opening error (:"");
        getch();
        exit(0);
        }
    return fp;
    }





",34,1105,282
"int main()
    {
        int n,i,j,k;
        printf(""Enter no of rows"");
        scanf(""%d"",&n);
        
        for(i=1;i<=n;i++)
            {
                for(j=n;j>=i;j--)
                    printf(""*"");
                for(j=2;j<2*i;j++)
                    printf("" "");
                for(j=1;j<=n-i+1;j++)
                    printf(""*"");
                printf(""\n"");
            }
        for(i=1;i<=n;i++)
        {
            for(j=1;j<=i;j++)
                printf(""*"");
            for(j=1;j<=2*n-2*i;j++)
                printf("" "");
            for(j=1;j<=i;j++)
                printf(""*"");
        printf(""\n"");
        }
    printf(""\n\n"");
    return 0;
    }
",34,1106,242
"int count=0;
void displayMat(int mat[][20],int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
        {
        for(j=0;j<c;j++)
        printf(""%d "",mat[i][j]);
        printf(""\n"");
        }
    }
int CheckSparse(int mat[][20],int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
        {
            for(j=0;j<c;j++)
                {
                    if(mat[i][j]==0)
                        count++;
                }
        }
    if(count>=(r*c)/2)
        return 1;
    else
        return 0;   
    }

int main()
    {
    int i,j,r,c,mat[20][20];
    printf(""Enter the row & col. of the matrix "");
    scanf(""%d%d"",&r,&c);    
                    
    printf(""\n Enter the matrix \n"");
    for(i=0;i<r;i++)
    for(j=0;j<c;j++)
    scanf(""%d"",&mat[i][j]);
        
    printf(""The matrix is:\n"");
    displayMat(mat,r,c);
    
    if(CheckSparse(mat,r,c)==1)
        printf(""The matrix is sparse matrix\n"");
    else
        printf(""The matrix is not sparse matrix\n"");
    return 0;
    }   



",34,1107,405
"int main()
    {
    int weekd;
    printf(""Enter week day number"");
    scanf(""%d"",&weekd);

    if(weekd==1)
        printf(""MONDAY\n"");

    else if(weekd==2)
        printf(""TUESDAY\n"");
    
    else if(weekd==3)
        printf(""WEDNESDAY\n"");

    else if(weekd==4)
        printf(""THURSDAY\n"");
    
    else if(weekd==5)
        printf(""FRIDAY\n"");
    
    else if(weekd==6)
        printf(""SATURDAY\n"");

    else if(weekd==7)
        printf(""SUNDAY\n"");
    
    else 
        printf(""OOPS!!Enter valid week day number\n"");

    return 0;
    }

",34,1108,221
"int main()
    {
        int i,j,k=0,n;
        printf(""Enter value of n"");
        scanf(""%d"",&n);
        
        for(i=n/2;i<n;i=i+2)
            {
                for(j=1;j<n-i;j=j+2)
                    printf("" "");
                for(j=1;j<=i;j++)
                    printf(""*"");
                for(j=1;j<=i-4*k;j++)
                    printf("" "");
                for(j=1;j<=i;j++)
                    printf(""*"");
            k++;
                printf(""\n"");
            }
        for(i=n;i>=1;i--)
            {
                for(j=1;j<=n-i;j++)
                    printf("" ""); 
                for(j=1;j<=2*i-1;j++)
                    printf(""*"");
                printf(""\n"");
            }

        printf(""\n"");
        return 0;
        
    }
",34,1109,262
"int main()
    {
        int i,pos;
        char str[30],ch,rech;
        printf(""\n Enter the string"");
        gets(str);
        
        printf(""\n Enter character to replace"");
        ch=getchar();
        
        getchar();
        
        printf(""\n Enter character to replace with"");
        rech=getchar();
        
        for(i=0;i<str[i]!='\0';i++)
            {
                if(str[i]==ch)
                    {
                        pos=i;
                        str[pos]=rech;
                        break;
                    }
            }
        
        printf(""\n After replace %s"",str);
        return 0;
    }
",34,1110,182
"int Mystrlen(char *str)
    {
        int i;
        for(i=0;i<str[i]!=0;i++);
        
        return i;
        
    }

char* Trim(char *str)
    {
        int i=0,j,c=0,n,d;
        char *temp;
        n=Mystrlen(str);
        while(str[c]==' '||str[c]=='\t'||str[c]=='\n')
            {
                c++;
            }
        for(j=c;j<=n-1;j++)
            {
                str[i]=str[j];  
                
                i++;
            }
        str[i]='\0';
        c=Mystrlen(str)-1;
        
        while(str[c]==' '||str[c]=='\t'||str[c]=='\n')
            {
                c--;
            }
        str[c+1]='\0';
        
        return str;
        return str;
    }

int main()
    {
        int i,n;
        char str[50];
        printf(""\n Enter the string:"");
        gets(str);
        
        printf(""\n Before trimming:"");
        printf(""%s"",str);
        
        printf(""\n After  trimming:"");
        printf(""%s"",Trim(str));
        printf(""Good bye"");
        return 0;
    }
",34,1111,366
"void Transpose(int **mat1,int **mat2,int r,int c);
void displayMat(int **mat,int r,int c);
int main()
    {
    int i,j,r,c,**mat1,**mat2;
    printf(""Enter the row & col. for the matrix"");
    scanf(""%d%d"",&r,&c);
    mat1=(int **)malloc(r*sizeof(int *));   
    mat2=(int **)malloc(r*sizeof(int *));                                   
    
    for(i=0;i<r;i++)
        mat1[i]=(int *)malloc(c*sizeof(int ));
        
    for(i=0;i<r;i++)
        mat2[i]=(int *)malloc(c*sizeof(int ));
            

    printf(""\n Enter the matrix \n"");
    for(i=0;i<r;i++)
    for(j=0;j<c;j++)                
    scanf(""%d"",&mat1[i][j]);
        
    Transpose(mat1,mat2,r,c);
        
    printf(""Transpose of the matrix is:\n"");
    displayMat(mat2,r,c);
    return 0;
    }
void displayMat(int **mat,int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
        {
        for(j=0;j<c;j++)
        printf(""%d "",mat[i][j]);
        printf(""\n"");
        }
    }   
void Transpose(int **mat1,int **mat2,int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
    for(j=0;j<c;j++)
        mat2[i][j]=mat1[j][i];
    }
",34,1112,469
"void Transpose(int mat1[][20],int mat2[][20],int r,int c);
void displayMat(int mat[][20],int r,int c);
int main()
    {
    int i,j,r,c,mat1[20][20],mat2[20][20];
    printf(""Enter the row & col. for the matrix"");
    scanf(""%d%d"",&r,&c);

    printf(""\n Enter the matrix \n"");
    for(i=0;i<r;i++)
    for(j=0;j<c;j++)                
    scanf(""%d"",&mat1[i][j]);
        
    Transpose(mat1,mat2,r,c);
        
    printf(""Transpose of the matrix is:\n"");
    displayMat(mat2,r,c);
    return 0;
    }
void displayMat(int mat[][20],int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
        {
        for(j=0;j<c;j++)
        printf(""%d "",mat[i][j]);
        printf(""\n"");
        }
    }   
void Transpose(int mat1[][20],int mat2[][20],int r,int c)
    {
    int i,j;
    for(i=0;i<r;i++)
    for(j=0;j<c;j++)
        mat2[i][j]=mat1[j][i];
    }

",34,1113,388
"int SumLowerTri(int mat[][20],int r)
    {
    int i,j,sum=0;
    for(i=0;i<r;i++) 
        {
        for(j=0;j<r;j++) 
            {
            if(i>=j)
                sum=sum+mat[i][j];
            }
        }
    return sum;
    }

int main()
    {
    int i,j,r,c,mat1[20][20];
    printf(""Enter the row & col. for the matrix"");
    scanf(""%d%d"",&r,&c);
    
    if(r!=c)
        printf(""Lower triangualr matrix or not matrix should be square"");
    else
        {
        printf(""\n Enter the matrix \n"");
        for(i=0;i<r;i++)
        for(j=0;j<c;j++)                
        scanf(""%d"",&mat1[i][j]);
        
        printf(""The sum of the lower triangular matrix=%d"",SumLowerTri(mat1,r));    
        }
    return 0;
    }   


",34,1114,287
"int main()
    {
        FILE *fptr;
        int c=0,word=0,line=0;
        char ch;
        
        if((fptr=fopen(""File8.txt"",""r""))==NULL)
            {
                printf(""\n File not exit"");
                exit(1);
            }
        while((ch=fgetc(fptr))!=EOF)
            {
                c++;
                if(ch=='\n'||ch=='\0')
                    line++;
                if(ch==' '||ch=='\n'||ch=='\t'||ch==','||ch=='.'||ch==':'||ch==';'||ch=='-')
                    word++;         
            }
        if(c>0)
            {
                line++;
                word++;
            }
        printf(""\n Total character:: %d"",c);
        printf(""\n Total word:: %d"",word);
        printf(""\n Total line:: %d"",line);
        
        fclose(fptr);
        return 0;
    }
",34,1115,253
"int pos=0,line=1,error=0;
int CompareFile(FILE *fptr1,FILE *fptr2)
    {
    char ch1,ch2;
    int n=1;
    ch1=getc(fptr1);
    ch2=getc(fptr2);
    while(ch1!=EOF&&ch2!=EOF)
        {
        pos++;
        if(ch1 =='\n'&&ch2=='\n') 
            { 
            line++; 
            pos = 0; 
            }    
        
        if(ch1!=ch2)
            {
            n=0;
            error++;
            }
            
        ch1=getc(fptr1);
        ch2=getc(fptr2);
        }
    return n;
    }
int main()
    {
        FILE *fptr1,*fptr2;
        char str[100];
        int n,line,col;
        
        fptr1=fopen(""File51.txt"",""r"");
        fptr2=fopen(""File52.txt"",""r"");
    
        if(fptr1==NULL||fptr2==NULL)
            {
                perror(""File openning error (: "");
                getch();
                exit(0);
            }           
        
        if(CompareFile(fptr1,fptr2))
            printf(""\n Two file is same"");
        else
            printf(""\n Two file is not same error:%d pos:%d line:%d"",error,pos,line);
    
        
        fclose(fptr1);
        fclose(fptr2);
        
        return 0;
    }

",34,1116,414
"int checkUpperTri(int mat[][20],int r)
    {
    int i,j,flag=1;
    for(i=1;i<r;i++) 
        for(j=0;j<i;j++) 
            if(mat[i][j]!= 0) 
                return 0;
        return 1;
    }

int main()
    {
    int i,j,r,c,mat1[20][20];
    printf(""Enter the row & col. for the matrix"");
    scanf(""%d%d"",&r,&c);
    
    if(r!=c)
        printf(""For checking upper triangualr matrix or not matrix should be square"");
    else
        {
        printf(""\n Enter the matrix \n"");
        for(i=0;i<r;i++)
        for(j=0;j<c;j++)                
        scanf(""%d"",&mat1[i][j]);
        
        if(checkUpperTri(mat1,r)==1)
            printf(""Matrix is Upper triangualr matrix"");
        else
            printf(""Matrix is not Upper triangualr matrix"");
        }
    return 0;
    }   


",34,1117,300
"int isFileExists(const char *path);
int isFileExistsAccess(const char *path);
int isFileExistsStats(const char *path);


int main()
{
    char path[100];

    printf(""Enter source file path: "");
    scanf(""%s"", path);


    
    if (isFileExistsAccess(path))
    {
        printf(""File exists at path '%s'\n"", path);
    }
    else
    {
        printf(""File does not exists at path '%s'\n"", path);
    }

    return 0;
}




int isFileExists(const char *path)
{
    
    FILE *fptr = fopen(path, ""r"");

    
    if (fptr == NULL)
        return 0;

    
    fclose(fptr);

    return 1;
}




int isFileExistsAccess(const char *path)
{
    
    if (access(path, F_OK) == -1)
        return 0;

    return 1;
}




int isFileExistsStats(const char *path)
{
    struct stat stats;

    stat(path, &stats);

    
    if (stats.st_mode & F_OK)
        return 1;

    return 0;
}
",34,1118,332
"int main()
    {
    float basicsal,HRA,DA;
    printf(""Enter the basic salary"");
    scanf(""%f"",&basicsal);
    
    if(basicsal>20000)
        {
        HRA=basicsal*30/100;
        DA=basicsal*95/100;
        }
    else if(basicsal<=20000)
        {
        HRA=basicsal*25/100;
        DA=basicsal*90/100;
        }
    else if(basicsal<=10000)
        {
        HRA=basicsal*20/100;
        DA=basicsal*80/100;
        }
    printf(""\n Gross salary=%f\n"",basicsal+HRA+DA);

    printf(""\n"");   
    return 0;
    }   
        
    
    

    
        
",34,1119,250
"int main()
    {
        int i,pos,j;
        char str[30],temp[30],ch;
        printf(""\n Enter the string"");
        gets(str);
        
        printf(""\n Enter the character"");
        scanf(""%c"",&ch);
        
        for(i=0;i<str[i]!='\0';i++)
            {
                if(str[i]==ch)
                    {
                        pos=i;
                        break;
                    }
            }
        for(j=0;i<str[j]!='\0';j++);
        
        for(i=pos;i<=j-1;i++)
            str[i]=str[i+1];
            
        str[i]='\0';
        
        printf(""%s"",str);
        return 0;
    }
",34,1120,210
"int Noofword(char *str)
    {
    int i=0,word=0;
    char prevchar='\0';
    while(1)
        {
        if(str[i]==' '||str[i]=='\n'||str[i]=='\t'||str[i]=='\0')   
            {
                if(prevchar!=' ' && prevchar!='\n'&&prevchar!='\t'&&prevchar!='\0')
                word++;
            }
        prevchar=str[i];
        if(str[i]=='\0')
            break;
        else 
            i++;
        }
    return word;
    }
int main()
    {
        char str[20];
        int i=0,v=0,c=0;
        printf(""\n Enter the string:: "");
        gets(str);
        
        printf(""\n No of word in the string is =%d"",Noofword(str));
    
        return 0;
    }
    
    
",34,1121,253
"int main()
    {
    int n,i,j,k,f;
    
    printf(""Enter how many columns"");
    scanf(""%d"",&n);
    f=1;
    
    for(i=1;i<=2*n-1;i++)
        {
            
            if(i<=n)
                {
                f++;
                for(j=1;j<=n-i;j++) 
                    printf("" "");
                }
            else
                {
                f--;
                for(j=1;j<=i-n;j++) 
                    printf("" "");
                }
            for(j=1;j<f;j++)    
                printf(""*"");
        printf(""\n"");
        }
        
    printf(""\n\n"");
        return 0;
    }   







",34,1122,207
"int checkLowerTri(int mat[][20],int r)
    {
    int i,j;
    for(i=0;i<r-1;i++) 
        {
        for(j=1;j<r;j++) 
            {
            if(i<j && mat[i][j]!=0)
                {
                return 0;
                break;  
                }           
            }
        }
    return 1;
    }

int main()
    {
    int i,j,r,c,mat1[20][20];
    printf(""Enter the row & col. for the matrix"");
    scanf(""%d%d"",&r,&c);
    
    if(r!=c)
        printf(""For checking Lower triangualr matrix or not matrix should be square"");
    else
        {
        printf(""\n Enter the matrix \n"");
        for(i=0;i<r;i++)
        for(j=0;j<c;j++)                
        scanf(""%d"",&mat1[i][j]);
        
        if(checkLowerTri(mat1,r)==1)
            printf(""Matrix is Lower triangualr matrix"");
        else
            printf(""Matrix is not Lower triangualr matrix"");
        }
    return 0;
    }   


",34,1123,324
"void creat();
void display();
int count();
void insert_at_after_pos();
struct node
{
int data;
struct node *next;
struct node *pre;
};
struct node *head=0;
int main()
{
    printf(""function of double linked list \n"");
    printf(""1.implementation of linked list\n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of element in the linked list\n"");
    printf(""4.insert an element after the position\n"");
    printf(""5.exit\n"");
    int choice;
    printf(""enter the choice ="");
    scanf(""%d"",&choice);
    while(choice!=5)
    {
        switch(choice)
        {
            case 1: printf(""implementation\n"");
            creat();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of element in the linked list\n"");
            count();
            break;
            case 4:printf(""inserting the element after the  position\n"");
            insert_at_after_pos();
            break;
            case 5:printf(""exit \n"");
            exit(0);
            break;
            default:printf(""invalied choice \n"");
            break;
        }
         printf(""enter the choice ="");
        scanf(""%d"",&choice);
    }
}
void creat()
{
struct node *newnode,*temp;
int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
            printf(""enter the data ="");
            scanf(""%d"",&newnode->data);
            newnode->pre=0;
            newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            temp=newnode;
        }
        printf(""do you need to continue(0,1)?\n enter 0 to stop  enter 1 to continue = "");
        scanf(""%d"",&choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    while(temp!=0)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""\n"");
}
int count()
{
    struct node *temp;
    temp=head;
    int c=0;
    while(temp!=0)
    {
        c++;
        temp=temp->next;
    }
    printf(""the number of elements in the linked list is %d \n"",c);
    return c;
}
void insert_at_after_pos()
{
    struct node *newnode,*temp;
    int pos;
    int i=1;
    printf(""enter the position ="");
    scanf(""%d"",&pos);
    int leg=count();
    if(pos>leg)
    {
        printf(""Invalid position \n"");
    }
    else
    {
        temp=head;
        while(i<pos)
        {
            temp=temp->next;
            i++;
        }
        newnode=(struct node*)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->pre=temp;
        newnode->next=temp->next;
        temp->next=newnode;
        newnode->next->pre=newnode;
    }

}
",35,1124,896
"int main(void) {
    printf(""insertion \n""); 
    printf(""insert an element in the array \n"");
    int a[100]={0};
    int n=10;
    int i;
    printf(""the elements in the array are : \n"");
    for(i=0;i<n;i++)
    {
        a[i]=i+4;
        printf(""%d\t"",a[i]);
    }
    int b=25,pos=3;
    printf(""\n the element is going to insert is : %d \n"",b);
    printf("" the element is going to insert at position is : %d \n"",pos);
    n++;
    for(i=n-1;i>=pos;i--)
    {
        a[i]=a[i-1];
    }
    a[pos-1]=b;
    printf(""\n after the insertion the elements in the array are \n"");
    for(i=0;i<n;i++)
    {
        printf(""%d\t"",a[i]);
    }
    return EXIT_SUCCESS;
}
",35,1125,274
"int stack[50],N;
int top=-1;
void push();
void pop();
void peek();
void display();
void isfull();
void isempty();
int main()
{
    printf(""THE STACK USING THE ARRAY\n"");
    printf(""enter the size of the array(max size of the array is 50)= \n"");
    scanf(""%d"",&N);
    printf(""1.push\n2.pop\n3.peek\n4.display\n5.is full\n6.is empty\n7.exit\n"");
    int choice;
    do
    {
        printf(""enter the choice= "");
        scanf(""%d"",&choice);
        switch(choice)
        {
            case 1:printf(""insert the element to the stack\n"");
            push();
            break;
            case 2:printf(""delete the element from the stack\n"");
            pop();
            break;
            case 3:printf(""display the top element in the stack\n"");
            peek();
            break;
            case 4:printf(""display all the element in the stack\n"");
            display();
            break;
            case 5:printf(""checking the stack is full or not\n"");
            isfull();
            break;
            case 6:printf(""checking the stack is empty or not\n"");
            isempty();
            break;
            case 7:printf(""exit \n"");
            break;
            default:printf(""wrong choice\n"");
            break;
        }
    }while(choice!=7);
    return 0;
}
void push()
{
    int x;
    printf(""enter the data ="");
    scanf(""%d"",&x);
    if(top==N-1)
    {
        printf(""stack overflow\n"");
    }
    else
    {
        top++;
        stack[top]=x;
    }
}
void pop()
{
    if(top==-1)
    {
        printf(""stack under flow\n"");
    }
    else
    {
        top--;
    }
}
void peek()
{
    if(top==-1)
    {
        printf(""there is no element in the stack\n"");
    }
    else
    {
        printf(""the top most element in the stack is %d\n"",stack[top]);
    }
}
void display()
{
    int i;
    if(top>-1)
    {
        for(i=top;i>=0;i--)
        {
            printf(""%d\t"",stack[i]);
        }
        printf(""\n"");
    }
    else
    {
        printf(""the stack is empty\n"");
    }
}
void isfull()
{
    if(top==N-1)
    {
        printf(""the stack is full\n"");
    }
    else
    {
        printf(""the stack is not full\n"");
    }
}
void isempty()
{
    if(top==-1)
    {
        printf(""the stack is empty\n"");
    }
    else
    {
        printf(""the stack is not empty\n"");
    }
}
",35,1126,783
"int main(void) {
    printf(""swapping the elements in the array to another array \n""); 
    int n=5,i;
    printf(""elements in the array  1 are \n"");
    int a[5]={15,24,36,14,22};
    for(i=0;i<n;i++)
        printf(""%d \t"",a[i]);
    printf(""\n"");
    int temp[5];
    for(i=0;i<n;i++)
    {
        temp[i]=a[i];
    }
    printf(""\n elements in the array  2 are \n"");
    int b[5]={20,16,95,38,45};
    for(i=0;i<n;i++)
        printf(""%d \t"",b[i]);
    printf(""\n after swapping the array \n"");
    printf(""\n elements in the array  1 are \n"");
    for(i=0;i<n;i++)
    {
        a[i]=b[i];
        printf(""%d \t"",a[i]);
    }
    printf(""\n elements in the array  2 are \n"");
    for(i=0;i<n;i++)
    {
        b[i]=temp[i];
        printf(""%d \t"",b[i]);
    }
    return EXIT_SUCCESS;
}
",35,1127,342
"void elemswap(int *x,int *y)
{
    int temp;
    temp=*x;
    *x=*y;
    *y=temp;
}
int sort(int a[],int l,int r)
{
    int key,start,end;
    key=a[l];
    start=l;
    end=r;
    if(start<end)
    {
        if(a[start]<=key)
        {
            start++;
        }
        if(a[end]>key)
        {
            end--;
        }
        if(start<end)
        {
            elemswap(&a[start],&a[end]);
        }
    }
    elemswap(&a[end],&a[l]);
    return end;
}
void quicksort(int a[],int l,int r)
{
    int loc;
    if(l<r)
    {
        loc=sort(a,l,r);
        quicksort(a,l,loc);
        quicksort(a,loc+1,r);
    }
}
void printarray(int a[],int n)
{
    int i;
    for(i=0;i<n;i++)
        printf(""%d\t"",a[i]);
}
int main(void) {
    printf(""sorting the elements in the array \n""); 
    printf(""quick sort \n"");
    int a[]={70,89,2,14,56,33,90};
    int n=sizeof(a)/sizeof(a[0]);
    printf(""the elements in the array are :\n "");
    printarray(a,n);
    printf(""\n after sorting elements in the array are :\n"");
    quicksort(a,0,n-1);
    printarray(a,n);
    return EXIT_SUCCESS;
}
",35,1128,466
"void insertion(int a[],int n)
{
    int i,j,temp;
    for(i=1;i<n;i++)
    {
        temp=a[i];
        j=i-1;
        while(j>=0 && a[j]>temp)
        {
            a[j+1]=a[j];
            j--;
        }
        a[j+1]=temp;
    }
}
void printarray(int a[],int n)
{
    int i;
    for(i=0;i<n;i++)
        printf(""%d\t"",a[i]);
}
int main(void) {
    printf(""sorting the elements in the array \n""); 
    printf(""insertion sort \n "");
    int a[5]={90,64,11,24,5};
    int n=5;
    printf(""the elements in the array are :\n "");
    printarray(a,n);
    printf(""\n after sorting elements in the array are :\n"");
    insertion(a,n);
    printarray(a,n);
    return EXIT_SUCCESS;
}
",35,1129,285
"void selection(int a[],int n)
{
    int p,j,min,temp;
    for(p=0;p<n-1;p++)
    {
        min=p;
        for(j=p+1;j<n;j++)
        {
            if(a[j]<a[min])
            {
                min=j;
            }
        }
        if(min!=p)
        {
            temp=a[p];
            a[p]=a[min];
            a[min]=temp;
        }
    }
}
void printarray(int a[],int n)
{
    int i;
    for(i=0;i<n;i++)
        printf(""%d\t"",a[i]);
}
int main(void) {
    printf(""sorting the elements in the array \n""); 
    printf(""selection sort \n "");
    int a[5]={65,47,4,80,12};
    int n=5;
    printf(""the elements in the array are :\n "");
    printarray(a,n);
    printf(""\n after sorting elements in the array are :\n"");
    selection(a,n);
    printarray(a,n);
    return EXIT_SUCCESS;
}
",35,1130,315
"void elemsw(int *x,int *y)
{
    int temp;
    temp=*x;
    *x=*y;
    *y=temp;
}
void sort(int a[],int n,int i)
{
    int large,l,r;
    large=i;
    l=2*i+1;
    r=2*i+2;
    while(l<n && a[l]>a[large])
    {
        large=l;
    }
    while(r<n && a[r]>a[large])
    {
        large=r;
    }
    if(large!=i)
    {
        elemsw(&a[large],&a[i]);
        sort(a,n,large);
    }
}
void heapsort(int a[],int n)
{
    int i;
    for(i=(n/2)-1;i>=0;i--)
    {
        sort(a,n,i);
    }
    for(i=n-1;i>=0;i--)
    {
        elemsw(&a[0],&a[i]);
        sort(a,i,0);
    }
}
void printarray(int a[],int n)
{
    int i;
    for(i=0;i<n;i++)
        printf(""%d\t"",a[i]);
}
int main(void) {
    printf(""sorting the elements in the array \n""); 
    printf(""heap sort \n"");
    int a[]={15,12,9,54,60,45};
    int n=sizeof(a)/sizeof(a[0]);
    printf(""the elements in the array are :\n "");
    printarray(a,n);
    printf(""\n after sorting elements in the array are :\n"");
    heapsort(a,n);
    printarray(a,n);
}
",35,1131,477
"void create();
struct node
{
    int data;
    struct node *next;
};
struct node *head=0;
int main()
{
    printf(""the function of circular linked list\n"");
    printf(""1.implementation of linked list\n"");
    create();
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            temp=newnode;
        }
        temp->next=head;
        printf(""do you need to continue(0,1)?\n enter 0 to stop and 1 to continue ="");
        scanf(""%d"",&choice);
    }
}
",35,1132,250
"void creat();
void display();
struct node
{
    int data;
    struct node *next;
    struct node *pre;
};
struct node *head=0;
int main()
{
    printf(""function of double linked list \n"");
    printf(""1.implementation\n"");
    creat();
    printf(""2.display the linked list\n"");
    display();
}
void creat()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
            printf(""enter the data ="");
            scanf(""%d"",&newnode->data);
            newnode->pre=0;
            newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            temp=newnode;
        }
        printf(""do you need to continue(0,1)?\n enter 0 to stop  enter 1 to continue = "");
        scanf(""%d"",&choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    while(temp!=0)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
}

",35,1133,342
"void create();
void display();
void count();
void delete_beg();
struct node
{
    int data;
    struct node *next;
    struct node *pre;
};
struct node *head=0;
int main()
{
    int choice;
    printf(""function of doubly circular linked list \n"");
    printf(""1.implementation \n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of elements in the linked list\n"");
    printf(""4.delete the element at the beginning position in the linked list\n"");
    printf(""5.exit\n"");
    printf(""enter the choice ="");
    scanf(""%d"",&choice);
    while(choice!=6)
    {
        switch(choice)
        {
            case 1:printf(""implementation \n"");
            create();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of elements in the linked list\n"");
            count();
            break;
            case 4: printf(""delete the element at the beginning position in the linked list\n"");
            delete_beg();
            break;
            case 5:printf(""exit\n"");
            exit(0);
            break;
            default:printf(""wrong choice\n"");
            break;
        }
        printf(""enter the choice ="");
        scanf(""%d"",&choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->pre=0;
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
            newnode->next=newnode;
            newnode->pre=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            newnode->next=head;
            temp=newnode;
            head->pre=temp;
        }
    printf(""do you need to continue(0,1)?\nenter 0 to stop and 1 to continue ="");
    scanf(""%d"",&choice);
    }

}
void display()
{
    struct node *temp;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    temp=head;
    while(temp->next!=head)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""%d "",temp->data);
    printf(""\n"");
}
void count()
{
    struct node *temp;
    int c=0;
    temp=head;
    do
    {
        c++;
        temp=temp->next;
    }while(temp!=head);
    printf(""the number of elements in the linked list is %d\n"",c);
}
void delete_beg()
{
    struct node *temp,*firstnode;
    firstnode=head;
    temp=head;
    while(temp->next!=head)
    {
        temp=temp->next;
    }
    head->next->pre=head->pre;
    temp->next=firstnode->next;
    head=firstnode->next;
    free(firstnode);
}
",35,1134,854
"void create();
struct node
{
    int data;
    struct node *next;
    struct node *pre;
};
struct node *head=0;
int main()
{
    printf(""function of doubly circular linked list \n"");
    printf(""1.implementation \n"");
    create();
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->pre=0;
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
            newnode->next=newnode;
            newnode->pre=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            newnode->next=head;
            temp=newnode;
            head->pre=temp;
        }
    printf(""do you need to continue(0,1)?\nenter 0 to stop and 1 to continue ="");
    scanf(""%d"",&choice);
    }

}
",35,1135,305
"void create();
void display();
int count();
void delete_at_pos();
struct node
{
    int data;
    struct node *next;
    struct node *pre;
};
struct node *head=0;
int main()
{
    int choice;
    printf(""function of doubly circular linked list \n"");
    printf(""1.implementation \n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of elements in the linked list\n"");
    printf(""4.delete the element at any position in the linked list\n"");
    printf(""5.exit\n"");
    printf(""enter the choice ="");
    scanf(""%d"",&choice);
    while(choice!=6)
    {
        switch(choice)
        {
            case 1:printf(""implementation \n"");
            create();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of elements in the linked list\n"");
            count();
            break;
            case 4: printf(""delete the element at any position in the linked list\n"");
            delete_at_pos();
            break;
            case 5:printf(""exit\n"");
            exit(0);
            break;
            default:printf(""wrong choice\n"");
            break;
        }
        printf(""enter the choice ="");
        scanf(""%d"",&choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->pre=0;
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
            newnode->next=newnode;
            newnode->pre=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            newnode->next=head;
            temp=newnode;
            head->pre=temp;
        }
    printf(""do you need to continue(0,1)?\nenter 0 to stop and 1 to continue ="");
    scanf(""%d"",&choice);
    }

}
void display()
{
    struct node *temp;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    temp=head;
    while(temp->next!=head)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""%d "",temp->data);
    printf(""\n"");
}
int count()
{
    struct node *temp;
    int c=0;
    temp=head;
    do
    {
        c++;
        temp=temp->next;
    }while(temp!=head);
    printf(""the number of elements in the linked list is %d\n"",c);
    return c;
}
void delete_at_pos()
{
    struct node *temp;
    temp=head;
    int i=1;
    int pos;
    int leg=count();
    printf(""enter the position in between the 1 to %d\n"",leg);
    printf(""enter the position ="");
    scanf(""%d"",&pos);
    while(i<pos)
    {
        temp=temp->next;
        i++;
    }
    temp->pre->next=temp->next;
    temp->next->pre=temp->pre;
    free(temp);
}
",35,1136,903
"#define n 5
int queue[n];
int front=-1;
int rear=-1;
void enqueue(int x)
{
    if(rear==n-1)
    {
        printf(""overflow\n"");
    }
    else if(front==-1 && rear==-1)
    {
        front=rear=0;
        printf(""the inserted element is %d\n"",x);
        queue[rear]=x;
    }
    else
    {
        rear++;
        printf(""the inserted element is %d\n"",x);
        queue[rear]=x;
    }
}
void dequeue()
{
    if(front==-1 && rear==-1)
    {
        printf(""underflow\n"");
    }
    else if(front==rear)
    {
        printf(""the delete element is %d\n"",queue[front]);
        front=rear=-1;
    }
    else
    {
        printf(""the delete element is %d\n"",queue[front]);
        front++;
    }
}
void peek()
{
    if(front==-1 && rear==-1)
    {
        printf(""queue is empty\n"");
    }
    else
    {
        printf(""the peek element is %d\n"",queue[front]);
    }
}
void display()
{
    int i;
    if(front==-1 && rear==-1)
    {
        printf(""queue is empty\n"");
    }
    else
    {
        printf(""the elements in the queue are\n"");
        for(i=front;i<=rear;i++)
        {
            printf(""%d "",queue[i]);
        }
        printf(""\n"");
    }
}
int main()
{
    printf(""the queue using array\n"");
    enqueue(4);
    enqueue(10);
    enqueue(41);
    display();
    dequeue();
    peek();
    enqueue(25);
    dequeue();
    peek();
    display();
}
",35,1137,508
"void create();
void display();
int count();
void insert_at_pos();
struct node
{
    int data;
    struct node *next;
};
struct node *head=0;
int main()
{
    int choice;
    printf(""the function of circular linked list\n"");
    printf(""1.implementation of linked list\n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of elements in the linked list\n"");
    printf(""4.insert the element at any position \n"");
    printf(""5.exit\n"");
    printf(""enter your choice ="");
    scanf(""%d"",&choice);
    while(choice!=6)
    {
        switch(choice)
        {
            case 1:printf(""implementation of linked list\n"");
            create();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of elements in the linked list\n"");
            count();
            break;
            case 4:printf(""insert the element at any position \n"");
            insert_at_pos();
            break;
            case 5:printf(""exit\n"");
            exit(0);
            break;
            default:printf(""wrong choice \n"");
            break;
        }
        printf(""enter your choice ="");
        scanf(""%d"",&choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            temp=newnode;
        }
        temp->next=head;
        printf(""do you need to continue(0,1)?\n enter 0 to stop and 1 to continue ="");
        scanf(""%d"",&choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    while(temp->next!=head)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""%d"",temp->data);
    printf(""\n"");
}
int  count()
{
    struct node *temp;
    temp=head;
    int c=0;
    do
    {
        c++;
        temp=temp->next;
    }while(temp!=head);
    printf(""the number of elements in the list is %d\n"",c);
    return c;
}
void insert_at_pos()
{
    struct node *newnode,*temp;
    int i=1;
    int pos;
    printf(""enter the position ="");
    scanf(""%d"",&pos);
    int leg=count();
    if(pos>leg)
    {
        printf(""Invalid position\n"");
    }
    else
    {
        temp=head;
        while(i<pos-1)
        {
            temp=temp->next;
            i++;
        }
        newnode=(struct node *)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->next=temp->next;
        temp->next=newnode;
    }
}
",35,1138,891
"void creat();
void display();
void count();
void insert_at_last();
struct node
{
int data;
struct node *next;
struct node *pre;
};
struct node *head=0;
int main()
{
    printf(""function of double linked list \n"");
    printf(""1.implementation of linked list\n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of element in the linked list\n"");
    printf(""4.insert an element at the last position\n"");
    printf(""5.exit\n"");
    int choice;
    printf(""enter the choice ="");
    scanf(""%d"",&choice);
    while(choice!=5)
    {
        switch(choice)
        {
            case 1: printf(""implementation\n"");
            creat();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of element in the linked list\n"");
            count();
            break;
            case 4:printf(""inserting the element at the last\n"");
            insert_at_last();
            break;
            case 5:printf(""exit \n"");
            exit(0);
            break;
            default:printf(""invalied choice \n"");
            break;
        }
         printf(""enter the choice ="");
        scanf(""%d"",&choice);
    }
}
void creat()
{
struct node *newnode,*temp;
int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
            printf(""enter the data ="");
            scanf(""%d"",&newnode->data);
            newnode->pre=0;
            newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            temp=newnode;
        }
        printf(""do you need to continue(0,1)?\n enter 0 to stop  enter 1 to continue = "");
        scanf(""%d"",&choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    while(temp!=0)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""\n"");
}
void count()
{
    struct node *temp;
    temp=head;
    int c=0;
    while(temp!=0)
    {
        c++;
        temp=temp->next;
    }
    printf(""the number of elements in the linked list is %d \n"",c);
}
void insert_at_last()
{
    struct node *newnode,*temp;
    newnode=(struct node*)malloc(sizeof(struct node));
    printf(""enter the data ="");
    scanf(""%d"",&newnode->data);
    newnode->next=0;
    temp=head;
    while(temp->next!=0)
    {
        temp=temp->next;
    }
    temp->next=newnode;
    newnode->pre=temp;
}
",35,1139,797
"void creat();
void display();
void count();
void reverse();
struct node
{
int data;
struct node *next;
struct node *pre;
};
struct node *head=0;
int main()
{
    printf(""function of double linked list \n"");
    printf(""1.implementation of linked list\n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of element in the linked list\n"");
    printf(""4.revers the linked list\n"");
    printf(""5.exit\n"");
    int choice;
    printf(""enter the choice ="");
    scanf(""%d"",&choice);
    while(choice!=6)
    {
        switch(choice)
        {
            case 1: printf(""implementation\n"");
            creat();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of element in the linked list\n"");
            count();
            break;
            case 4:printf(""revers the linked list\n"");
            reverse();
            break;
            case 5:printf(""exit \n"");
            exit(0);
            break;
            default:printf(""invalied choice \n"");
            break;
        }
         printf(""enter the choice ="");
        scanf(""%d"",&choice);
    }
}
void creat()
{
struct node *newnode,*temp;
int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
            printf(""enter the data ="");
            scanf(""%d"",&newnode->data);
            newnode->pre=0;
            newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            temp=newnode;
        }
        printf(""do you need to continue(0,1)?\n enter 0 to stop  enter 1 to continue = "");
        scanf(""%d"",&choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    if(head==0)
    {
        printf(""the list is empty"");
    }
    while(temp!=0)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""\n"");
}
void count()
{
    struct node *temp;
    temp=head;
    int c=0;
    while(temp!=0)
    {
        c++;
        temp=temp->next;
    }
    printf(""the number of elements in the linked list is %d \n"",c);
}
void reverse()
{
    struct node *currentnode,*nextnode,*prenode;
    prenode=0;
    currentnode=nextnode=head;
    while(nextnode!=0)
    {
        nextnode=nextnode->next;
        currentnode->next=prenode;
        currentnode->pre=nextnode;
        prenode=currentnode;
        currentnode=nextnode;
    }
    head=prenode;
}
",35,1140,801
"void creat();
void display();
void count();
struct node
{
int data;
struct node *next;
struct node *pre;
};
struct node *head=0;
int main()
{
    printf(""function of double linked list \n"");
    printf(""1.implementation of linked list\n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of element in the linked list\n"");
    printf(""4.exit\n"");
    int choice;
    printf(""enter the choice ="");
    scanf(""%d"",&choice);
    while(choice!=5)
    {
        switch(choice)
        {
            case 1: printf(""implementation\n"");
            creat();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of element in the linked list\n"");
            count();
            break;
            case 4:printf(""exit \n"");
            exit(0);
            break;
            default:printf(""invalied choice \n"");
            break;
        }
         printf(""enter the choice ="");
        scanf(""%d"",&choice);
    }
}
void creat()
{
struct node *newnode,*temp;
int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
            printf(""enter the data ="");
            scanf(""%d"",&newnode->data);
            newnode->pre=0;
            newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            temp=newnode;
        }
        printf(""do you need to continue(0,1)?\n enter 0 to stop  enter 1 to continue = "");
        scanf(""%d"",&choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    while(temp!=0)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""\n"");
}
void count()
{
    struct node *temp;
    temp=head;
    int c=0;
    while(temp!=0)
    {
        c++;
        temp=temp->next;
    }
    printf(""the number of elements in the linked list is %d \n"",c);
}

",35,1141,623
"void printarray(int a[],int n)
{
    for(n=0;n<5;n++)
        printf(""%d \t"",a[n]);
}
int main(void) {
    printf(""printing the array in the descending odder \n ""); 
    printf(""elements in the array are \n"");
    int a[5]={15,24,36,14,22};
    int n=5,temp;
    printarray(a,n);
    printf(""\n array in the descending odder is \n "");
    int i,j;
    for(i=0;i<5;i++)
    {
        for(j=i+1;j<5;j++)
        {
            if(a[j]>a[i])
            {
                temp=a[i];
                a[i]=a[j];
                a[j]=temp;
            }
        }
    }
    printarray(a,n);
    return EXIT_SUCCESS;
}
",35,1142,250
"void create();
void display();
void count();
void insert_end();
struct node
{
    int data;
    struct node *next;
    struct node *pre;
};
struct node *head=0;
int main()
{
    int choice;
    printf(""function of doubly circular linked list \n"");
    printf(""1.implementation \n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of elements in the linked list\n"");
    printf(""4.insert the element at the last position in the linked list\n"");
    printf(""5.exit\n"");
    printf(""enter the choice ="");
    scanf(""%d"",&choice);
    while(choice!=6)
    {
        switch(choice)
        {
            case 1:printf(""implementation \n"");
            create();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of elements in the linked list\n"");
            count();
            break;
            case 4: printf(""insert the element at the last position in the linked list\n"");
            insert_end();
            break;
            case 5:printf(""exit\n"");
            exit(0);
            break;
            default:printf(""wrong choice\n"");
            break;
        }
        printf(""enter the choice ="");
        scanf(""%d"",&choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->pre=0;
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
            newnode->next=newnode;
            newnode->pre=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            newnode->next=head;
            temp=newnode;
            head->pre=temp;
        }
    printf(""do you need to continue(0,1)?\nenter 0 to stop and 1 to continue ="");
    scanf(""%d"",&choice);
    }

}
void display()
{
    struct node *temp;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    temp=head;
    while(temp->next!=head)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""%d "",temp->data);
    printf(""\n"");
}
void count()
{
    struct node *temp;
    int c=0;
    temp=head;
    do
    {
        c++;
        temp=temp->next;
    }while(temp!=head);
    printf(""the number of elements in the linked list is %d\n"",c);
}
void insert_end()
{
    struct node *newnode,*temp;
    newnode=(struct node*)malloc(sizeof(struct node));
    printf(""enter the data ="");
    scanf(""%d"",&newnode->data);
    temp=head;
    while(temp->next!=head)
    {
        temp=temp->next;
    }
    temp->next=newnode;
    newnode->pre=temp;
    newnode->next=head;
    head->pre=newnode;
}
",35,1143,885
"void creat();
struct node
{
    int data;
    struct node *next;
    struct node *pre;
};
struct node *head=0;
int main()
{
    printf(""function of double linked list \n"");
    printf(""implementation\n"");
    creat();
}
void creat()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
            printf(""enter the data ="");
            scanf(""%d"",&newnode->data);
            newnode->pre=0;
            newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            temp=newnode;
        }
        printf(""do you need to continue(0,1)?\n enter 0 to stop  enter 1 to continue = "");
        scanf(""%d"",&choice);
    }
}
",35,1144,265
"void create();
void display();
struct node
    {
        int data;
        struct node *next;
    };
    struct node *head=0;
int main()
{
    printf(""Linked list functions\n"");
    printf(""implementation\n"");
    create();
    printf(""display the linked list \n"");
    display();
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
            printf(""enter the data = "");
            scanf(""%d"",& newnode->data);
            newnode->next=0;
       if(head==0)
       {
            head=temp=newnode;
       }
       else
       {
            temp->next=newnode;
            temp=newnode;
       }
       printf(""do you need to continue (0,1)?\n0 to stop 1 to continue the element in the linked list ="");
           scanf(""%d"",& choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    while(temp!=0)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""\n"");
}
",35,1145,318
"void create();
void display();
void count();
struct node
{
    int data;
    struct node *next;
};
struct node *head=0;
int main()
{
    int choice;
    printf(""the function of circular linked list\n"");
    printf(""1.implementation of linked list\n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of elements in the linked list\n"");
    printf(""4.exit\n"");
    printf(""enter your choice ="");
    scanf(""%d"",&choice);
    while(choice!=5)
    {
        switch(choice)
        {
            case 1:printf(""implementation of linked list\n"");
            create();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of elements in the linked list\n"");
            count();
            break;
            case 4:printf(""exit\n"");
            exit(0);
            break;
            default:printf(""wrong choice \n"");
            break;
        }
        printf(""enter your choice ="");
        scanf(""%d"",&choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            temp=newnode;
        }
        temp->next=head;
        printf(""do you need to continue(0,1)?\n enter 0 to stop and 1 to continue ="");
        scanf(""%d"",&choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    while(temp->next!=head)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""%d"",temp->data);
    printf(""\n"");
}
void count()
{
    struct node *temp;
    temp=head;
    int c=0;
    do
    {
        c++;
        temp=temp->next;
    }while(temp!=head);
    printf(""the number of elements in the list is %d\n"",c);
}
",35,1146,621
"void create();
void display();
void count();
void insert_end();
struct node
{
    int data;
    struct node *next;
};
struct node *head=0;
int main()
{
    int choice;
    printf(""the function of circular linked list\n"");
    printf(""1.implementation of linked list\n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of elements in the linked list\n"");
    printf(""4.insert the element at the last position \n"");
    printf(""5.exit\n"");
    printf(""enter your choice ="");
    scanf(""%d"",&choice);
    while(choice!=6)
    {
        switch(choice)
        {
            case 1:printf(""implementation of linked list\n"");
            create();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of elements in the linked list\n"");
            count();
            break;
            case 4:printf(""insert the element at the last position \n"");
            insert_end();
            break;
            case 5:printf(""exit\n"");
            exit(0);
            break;
            default:printf(""wrong choice \n"");
            break;
        }
        printf(""enter your choice ="");
        scanf(""%d"",&choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            temp=newnode;
        }
        temp->next=head;
        printf(""do you need to continue(0,1)?\n enter 0 to stop and 1 to continue ="");
        scanf(""%d"",&choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    while(temp->next!=head)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""%d"",temp->data);
    printf(""\n"");
}
void count()
{
    struct node *temp;
    temp=head;
    int c=0;
    do
    {
        c++;
        temp=temp->next;
    }while(temp!=head);
    printf(""the number of elements in the list is %d\n"",c);
}
void insert_end()
{
    struct node *newnode,*temp;
    newnode=(struct node *)malloc(sizeof(struct node));
    printf(""enter the data ="");
    scanf(""%d"",&newnode->data);
    if(head==0)
    {
        head=newnode;
        newnode->next=newnode;
    }
    else
    {
        temp=head;
        while(temp->next!=head)
        {
            temp=temp->next;
        }
        newnode->next=head;
        temp->next=newnode;
    }
}
",35,1147,847
"void creat();
void display();
int count();
void insert_at_pos();
struct node
{
int data;
struct node *next;
struct node *pre;
};
struct node *head=0;
int main()
{
    printf(""function of double linked list \n"");
    printf(""1.implementation of linked list\n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of element in the linked list\n"");
    printf(""4.insert an element at any position\n"");
    printf(""5.exit\n"");
    int choice;
    printf(""enter the choice ="");
    scanf(""%d"",&choice);
    while(choice!=5)
    {
        switch(choice)
        {
            case 1: printf(""implementation\n"");
            creat();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of element in the linked list\n"");
            count();
            break;
            case 4:printf(""inserting the element at any position\n"");
            insert_at_pos();
            break;
            case 5:printf(""exit \n"");
            exit(0);
            break;
            default:printf(""invalied choice \n"");
            break;
        }
         printf(""enter the choice ="");
        scanf(""%d"",&choice);
    }
}
void creat()
{
struct node *newnode,*temp;
int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
            printf(""enter the data ="");
            scanf(""%d"",&newnode->data);
            newnode->pre=0;
            newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            temp=newnode;
        }
        printf(""do you need to continue(0,1)?\n enter 0 to stop  enter 1 to continue = "");
        scanf(""%d"",&choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    while(temp!=0)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""\n"");
}
int count()
{
    struct node *temp;
    temp=head;
    int c=0;
    while(temp!=0)
    {
        c++;
        temp=temp->next;
    }
    printf(""the number of elements in the linked list is %d \n"",c);
    return c;
}
void insert_at_pos()
{
    struct node *newnode,*temp;
    int pos;
    int i=1;
    printf(""enter the position ="");
    scanf(""%d"",&pos);
    int leg=count();
    if(pos>leg)
    {
        printf(""Invalid position \n"");
    }
    else
    {
        temp=head;
        while(i<pos-1)
        {
            temp=temp->next;
            i++;
        }
        newnode=(struct node*)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->pre=temp;
        newnode->next=temp->next;
        temp->next=newnode;
        newnode->next->pre=newnode;
    }

}
",35,1148,891
"void create();
void display();
int count();
void insert_pos();
struct node
    {
        int data;
        struct node *next;
    };
    struct node *head=0;
int main()
{
    printf(""Linked list functions\n"");
    int choice;
    printf(""1.implementation\n"");
    printf(""2.display\n"");
    printf(""3.count\n"");
    printf(""4.inserst the element at any position\n"");
    printf(""5.exit\n"");
    printf(""enter the choice ="");
    scanf(""%d"",& choice);
    while(choice!=6)
    {
    switch(choice)
    {
    case 1:printf(""implementation \n"");
    create();
    break;
    case 2:printf(""display\n"");
    display();
    break;
    case 3:printf(""count the element in linked list\n"");
    count();
    break;
    case 4:printf(""inserting the element at any position \n"");
    insert_pos();
    break;
    case 5:exit(0);
    break;
    default: printf(""wrong choice \n"");
    break;
    }
    printf(""enter the choice ="");
    scanf(""%d"",& choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
            printf(""enter the data = "");
            scanf(""%d"",& newnode->data);
            newnode->next=0;
       if(head==0)
       {
            head=temp=newnode;
       }
       else
       {
            temp->next=newnode;
            temp=newnode;
       }
       printf(""do you need to continue (0,1)?\n0 to stop 1 to continue the element in the linked list ="");
           scanf(""%d"",& choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    while(temp!=0)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""\n"");
}
int count()
{
    struct node *temp;
    int count=0;
    temp=head;
    while(temp!=0)
    {
        count++;
        temp=temp->next;
    }
    printf(""the number of element in linked list is %d"", count);
    printf(""\n"");
    return count;
}
void insert_pos()
{
    struct node *newnode,*temp;
    int pos,i=1;
    printf(""enter the positon ="");
    scanf(""%d"",&pos);
    int leg=count();
    if(pos>leg)
    {
        printf(""Invalid positon \n"");
    }
    else
    {
        temp=head;
        while(i<pos-1)
        {
            temp=temp->next;
            i++;
        }
        newnode=(struct node*)malloc(sizeof(struct node));
        printf(""enter the data = "");
        scanf(""%d"",& newnode->data);
        newnode->next=temp->next;
        temp->next=newnode;
    }
}

",35,1149,817
"void creat();
void display();
void count();
void delete_at_pos();
struct node
{
int data;
struct node *next;
struct node *pre;
};
struct node *head=0;
int main()
{
    printf(""function of double linked list \n"");
    printf(""1.implementation of linked list\n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of element in the linked list\n"");
    printf(""4.delete the element from any position from the linked list\n"");
    printf(""5.exit\n"");
    int choice;
    printf(""enter the choice ="");
    scanf(""%d"",&choice);
    while(choice!=6)
    {
        switch(choice)
        {
            case 1: printf(""implementation\n"");
            creat();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of element in the linked list\n"");
            count();
            break;
            case 4:printf(""delete the element from any position from the linked list\n"");
            delete_at_pos();
            break;
            case 5:printf(""exit \n"");
            exit(0);
            break;
            default:printf(""invalied choice \n"");
            break;
        }
         printf(""enter the choice ="");
        scanf(""%d"",&choice);
    }
}
void creat()
{
struct node *newnode,*temp;
int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
            printf(""enter the data ="");
            scanf(""%d"",&newnode->data);
            newnode->pre=0;
            newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            temp=newnode;
        }
        printf(""do you need to continue(0,1)?\n enter 0 to stop  enter 1 to continue = "");
        scanf(""%d"",&choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    if(head==0)
    {
        printf(""the list is empty"");
    }
    while(temp!=0)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""\n"");
}
void count()
{
    struct node *temp;
    temp=head;
    int c=0;
    while(temp!=0)
    {
        c++;
        temp=temp->next;
    }
    printf(""the number of elements in the linked list is %d \n"",c);
}
void delete_at_pos()
{
    struct node *temp;
    int pos;
    int i=1;
    printf(""enter the position ="");
    scanf(""%d"",&pos);
    temp=head;
    while(i<pos)
    {
        temp=temp->next;
        i++;
    }
    if(temp->next==0)
    {
        temp->pre->next=0;
        free(temp);
    }
    else
    {
        temp->next->pre=temp->pre;
        temp->pre->next=temp->next;
        free(temp);
    }
}
",35,1150,858
"void linear(int a[],int n,int data)
{
    int i,result=0;
    for(i=0;i<n;i++)
    {
        if(a[i]==data)
        {
            result=1;
            break;
        }
    }
    if(result==0)
    {
        printf(""the element is not found in the array \n"");
    }
    else
    {
        printf(""the element is  found in the array at index %d \n"",i);
        printf(""the element is  found in the array at position  %d \n"",i+1);
    }
}
void printarray(int a[],int n)
{
    int i;
    for(i=0;i<n;i++)
        printf(""%d \t"",a[i]);
}
int main(void) {
    printf(""linear search \n"");
    printf(""searching for an  element in the array \n""); 
    printf(""elements in the array are \n"");
    int a[5]={15,24,36,14,22};
    int n=5;
    printarray(a,n);
    int data=36;
    printf(""\n the searching element in the array is %d \n"",data);
    linear(a,n,data);

    return EXIT_SUCCESS;
}
",35,1151,337
"void create();
void display();
int count();
void insert_beg();
void insert_end();
void insert_at_pos();
void delete_beg();
void delete_end();
void delete_at_pos();
struct node
{
    int data;
    struct node *next;
};
struct node *head=0;
int main()
{
    int choice;
    printf(""the function of circular linked list\n"");
    printf(""1.implementation of linked list\n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of elements in the linked list\n"");
    printf(""4.insert the element at the beginning position \n"");
    printf(""5.insert the element at the last position \n"");
    printf(""6.insert the element at any position \n"");
    printf(""7.delete the element from the beginning position\n"");
    printf(""8.delete the element from the last position\n"");
    printf(""9.delete the element from any position\n"");
    printf(""10.exit\n"");
    printf(""enter your choice ="");
    scanf(""%d"",&choice);
    while(choice!=11)
    {
        switch(choice)
        {
            case 1:printf(""implementation of linked list\n"");
            create();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of elements in the linked list\n"");
            count();
            break;
            case 4:printf(""insert the element at the beginning position \n"");
            insert_beg();
            break;
            case 5:printf(""insert the element at the last position \n"");
            insert_end();
            break;
            case 6:printf(""insert the element at any position \n"");
            insert_at_pos();
            break;
            case 7:printf(""delete the element from the beginning position\n"");
            delete_beg();
            break;
            case 8:printf(""delete the element from the last position\n"");
            delete_end();
            break;
            case 9:printf(""delete the element from any position\n"");
            delete_at_pos();
            break;
            case 10:printf(""exit\n"");
            exit(0);
            break;
            default:printf(""wrong choice \n"");
            break;
        }
        printf(""enter your choice ="");
        scanf(""%d"",&choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            temp=newnode;
        }
        temp->next=head;
        printf(""do you need to continue(0,1)?\n enter 0 to stop and 1 to continue ="");
        scanf(""%d"",&choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    while(temp->next!=head)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""%d"",temp->data);
    printf(""\n"");
}
int count()
{
    struct node *temp;
    temp=head;
    int c=0;
    do
    {
        c++;
        temp=temp->next;
    }while(temp!=head);
    printf(""the number of elements in the list is %d\n"",c);
    return c;
}
void insert_beg()
{
    struct node *newnode,*temp;
    newnode=(struct node *)malloc(sizeof(struct node));
    printf(""enter the data ="");
    scanf(""%d"",&newnode->data);
    if(head==0)
    {
        head=newnode;
        newnode->next=newnode;
    }
    else
    {
        temp=head;
        while(temp->next!=head)
        {
            temp=temp->next;
        }
        temp->next=newnode;
        newnode->next=head;
        head=newnode;
    }
}
void insert_end()
{
    struct node *newnode,*temp;
    newnode=(struct node *)malloc(sizeof(struct node));
    printf(""enter the data ="");
    scanf(""%d"",&newnode->data);
    if(head==0)
    {
        head=newnode;
        newnode->next=newnode;
    }
    else
    {
        temp=head;
        while(temp->next!=head)
        {
            temp=temp->next;
        }
        newnode->next=head;
        temp->next=newnode;
    }
}
void insert_at_pos()
{
    struct node *newnode,*temp;
    int i=1;
    int pos;
    int leg=count();
    printf(""enter the position in between 1 to %d\n"",leg);
    printf(""enter the position ="");
    scanf(""%d"",&pos);
    if(pos>leg)
    {
        printf(""Invalid position\n"");
    }
    else
    {
        temp=head;
        while(i<pos-1)
        {
            temp=temp->next;
            i++;
        }
        newnode=(struct node *)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->next=temp->next;
        temp->next=newnode;
    }
}
void delete_beg()
{
    struct node *temp,*firstnode;
    temp =head;
    while(temp->next!=head)
    {
        temp=temp->next;
    }
    firstnode=head;
    head=head->next;
    temp->next=firstnode->next;
    free(firstnode);
}
void delete_end()
{
    struct node *temp,*endnode;
    temp =head;
    while(temp->next!=head)
    {
        endnode=temp;
        temp=temp->next;
    }
    endnode->next=head;
    free(temp);
}
void delete_at_pos()
{
    struct node *temp,*nextnode;
    int i=1;
    int pos;
    int leg=count();
    printf(""enter the position in between 1 to %d\n"",leg);
    printf(""enter the position ="");
    scanf(""%d"",&pos);
    temp=head;
    while(i<pos-1)
    {
        temp=temp->next;
        i++;
    }
    nextnode=temp->next;
    temp->next=nextnode->next;
    free(nextnode);
}
",35,1152,1772
"struct node
{
    int data;
    struct node *next;
};
struct node *front=0;
struct node *rear=0;
void enqueue(int x)
{
    struct node *newnode;
    newnode=(struct node*)malloc(sizeof(struct node));
    newnode->data=x;
    newnode->next=0;
    printf(""the data inserted is %d\n"",x);
    if(front==0 && rear==0)
    {
        front=rear=newnode;
    }
    else
    {
       rear->next=newnode;
       rear=newnode;
    }
}
void peek()
{
    if(front==0 && rear==0)
    {
        printf(""the queue is empty\n"");
    }
    else
    {
        printf(""the peek element is %d \n"",front->data);
    }
}
void dequeue()
{
    struct node *temp;
    temp=front;
    if(front==0 && rear==0)
    {
        printf(""the queue is empty\n"");
    }
    else if(front==rear)
    {
        printf(""the delete element is %d \n"",temp->data);
        front=rear=0;
        free(temp);
    }
    else
    {
        printf(""the delete element is %d \n"",temp->data);
        front=front->next;
        free(temp);
    }
}
void display()
{
    struct node *temp;
    temp=front;
    if(front==0 && rear==0)
    {
        printf(""the queue is empty\n"");
    }
    else
    {
        printf(""the element in the array are\n"");
       while(temp!=0)
       {
           printf(""%d "",temp->data);
           temp=temp->next;
       }printf(""\n"");
    }
}
int main()
{
    printf(""queue using the linked list\n"");
    enqueue(17);
    enqueue(34);
    enqueue(55);
    dequeue();
    enqueue(20);
    display();
    peek();
    dequeue();
    enqueue(45);
    peek();
    display();
}
",35,1153,561
"struct node
{
    int data;
    struct node *next;
};
struct node *top=0;
void push(int x)
{
    struct node *newnode;
    newnode=(struct node*)malloc(sizeof(struct node));
    newnode->data=x;
    newnode->next=top;
    top=newnode;
    printf(""the element pushed into the stack is %d\n"",x);
}
void display()
{
    struct node *temp;
    temp=top;
    if(top==0)
    {
        printf(""the stack is empty\n"");
    }
    else
    {
        printf(""the elements in the stack are\n"");
        while(temp!=0)
        {
            printf(""%d "",temp->data);
            temp=temp->next;
        }
        printf(""\n"");
    }
}
void peek()
{
    if(top==0)
    {
        printf(""the stack is empty\n"");
    }
    else
    {
        printf(""the peek element is %d\n"",top->data);
    }
}
void pop()
{
    struct node *temp;
    if(top==0)
    {
        printf(""the stack is under flow\n"");
    }
    else
    {
        temp=top;
        printf(""the poped element is %d\n"",top->data);
        top=top->next;
        free(temp);
    }
}
int main()
{
    printf(""the stack using linked list\n"");
    push(2);
    push(3);
    push(10);
    display();
    peek();
    pop();
    peek();
    display();
}
",35,1154,422
"void creat();
void display();
int count();
void insert_beg();
void insert_end();
void insert_at_pos();
void delete_beg();
void delete_end();
void delete_at_pos();
void reverse();
struct node
{
int data;
struct node *next;
struct node *pre;
};
struct node *head=0;
int main()
{
    printf(""function of double linked list \n"");
    printf(""1.implementation of linked list\n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of element in the linked list\n"");
    printf(""4.insert the element at the beginning position of linked list\n"");
    printf(""5.insert the element at the last position of linked list\n"");
    printf(""6.insert the element at any position of linked list\n"");
    printf(""7.delete the element from beginning position from the linked list\n"");
    printf(""8.delete the element from last position from the linked list\n"");
    printf(""9.delete the element from any position from the linked list\n"");
    printf(""10.revers the linked list\n"");
    printf(""11.exit\n"");
    int choice;
    printf(""enter the choice ="");
    scanf(""%d"",&choice);
    while(choice!=12)
    {
        switch(choice)
        {
            case 1: printf(""implementation\n"");
            creat();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of element in the linked list\n"");
            count();
            break;
            case 4:printf(""insert the element at the beginning position of linked list\n"");
            insert_beg();
            break;
            case 5: printf(""insert the element at the last position of linked list\n"");
            insert_end();
            break;
            case 6:printf(""insert the element at any position of linked list\n"");
            insert_at_pos();
            break;
            case 7:printf(""delete the element from beginning position from the linked list\n"");
            delete_beg();
            break;
            case 8:printf(""delete the element from last position from the linked list\n"");
            delete_end();
            break;
            case 9:printf(""delete the element from any position from the linked list\n"");
            delete_at_pos();
            break;
            case 10:printf(""revers the linked list\n"");
            reverse();
            break;
            case 11:printf(""exit \n"");
            exit(0);
            break;
            default:printf(""invalied choice \n"");
            break;
        }
         printf(""enter the choice ="");
        scanf(""%d"",&choice);
    }
}
void creat()
{
struct node *newnode,*temp;
int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
            printf(""enter the data ="");
            scanf(""%d"",&newnode->data);
            newnode->pre=0;
            newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            temp=newnode;
        }
        printf(""do you need to continue(0,1)?\n enter 0 to stop  enter 1 to continue = "");
        scanf(""%d"",&choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    if(head==0)
    {
        printf(""the list is empty"");
    }
    while(temp!=0)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""\n"");
}
int count()
{
    struct node *temp;
    temp=head;
    int c=0;
    while(temp!=0)
    {
        c++;
        temp=temp->next;
    }
    printf(""the number of elements in the linked list is %d \n"",c);
    return c;
}
void insert_beg()
{
    struct node *newnode;
    newnode=(struct node *)malloc(sizeof(struct node));
    printf(""enter the data ="");
    scanf(""%d"",&newnode->data);
    newnode->pre=0;
    newnode->next=head;
    head=newnode;
}
void insert_end()
{
    struct node *newnode,*temp;
    newnode=(struct node *)malloc(sizeof(struct node));
    printf(""enter the data ="");
    scanf(""%d"",&newnode->data);
    newnode->next=0;
    temp=head;
    while(temp->next!=0)
    {
        temp=temp->next;
    }
    temp->next=newnode;
    newnode->pre=temp;
}
void insert_at_pos()
{
    struct node *newnode,*temp;
    int i=1,pos;
    printf(""enter the position ="");
    scanf(""%d"",&pos);
    int leg=count();
    if(pos>leg)
    {
        printf(""invalied position\n"");
    }
    else
    {
        newnode=(struct node *)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        temp=head;
        while(i<pos-1)
        {
            temp=temp->next;
            i++;
        }
        newnode->pre=temp;
        newnode->next=temp->next;
        temp->next=newnode;
        newnode->next->pre=newnode;
    }
}
void delete_beg()
{
    struct node *temp;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    else if(head->next==0)
    {
        head=0;
        free(head);
    }
    else
    {
        temp=head;
        head->next->pre=0;
        head=head->next;
        free(temp);
    }
}
void delete_end()
{
    struct node *temp;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    else if(head->next==0)
    {
        head=0;
        free(head);
    }
    else
    {
        temp=head;
        while(temp->next!=0)
        {
            temp=temp->next;
        }
        temp->pre->next=0;
        free(temp);
    }
}
void delete_at_pos()
{
    struct node *temp;
    int pos;
    int i=1;
    printf(""enter the position ="");
    scanf(""%d"",&pos);
    temp=head;
    while(i<pos)
    {
        temp=temp->next;
        i++;
    }
    if(temp->next==0)
    {
        temp->pre->next=0;
        free(temp);
    }
    else
    {
        temp->next->pre=temp->pre;
        temp->pre->next=temp->next;
        free(temp);
    }
}
void reverse()
{
    struct node *currentnode,*nextnode,*prenode;
    prenode=0;
    currentnode=nextnode=head;
    while(nextnode!=0)
    {
        nextnode=nextnode->next;
        currentnode->next=prenode;
        currentnode->pre=nextnode;
        prenode=currentnode;
        currentnode=nextnode;
    }
    head=prenode;
}
",35,1155,1951
"void create();
void display();
int count();
void insert_beg();
void insert_end();
void insert_at_pos();
void delete_beg();
void delete_end();
void delete_at_pos();
void reverse();
struct node
    {
        int data;
        struct node *next;
    };
    struct node *head=0;
int main()
{
    printf(""Linked list functions\n"");
    int choice;
    printf(""1.implementation\n"");
    printf(""2.display\n"");
    printf(""3.count\n"");
    printf(""4.insert the element at the beginning position of linked list\n"");
    printf(""5.insert the element at the last position of linked list\n"");
    printf(""6.insert the element at any position of linked list\n"");
    printf(""7.delete the element at the beginning position of linked list\n"");
    printf(""8.delete the element at the last position of linked list \n"");
    printf(""9.delete the element at any position of linked list\n"");
    printf(""10.reverse the linked list\n"");
    printf(""11.exit\n"");
    printf(""enter the choice ="");
    scanf(""%d"",& choice);
    while(choice!=12)
    {
    switch(choice)
    {
    case 1:printf(""implementation \n"");
    create();
    break;
    case 2:printf(""display\n"");
    display();
    break;
    case 3:printf(""count the element in linked list\n"");
    count();
    break;
    case 4:printf(""insert the element at the beginning position of linked list\n"");
    insert_beg();
    break;
    case 5:printf(""insert the element at the last position of linked list\n"");
    insert_end();
    break;
    case 6:printf(""insert the element at any position of linked list\n"");
    insert_at_pos();
    break;
    case 7:printf(""delete the element at the beginning position of linked list\n"");
    delete_beg();
    break;
    case 8:printf(""delete the element at the last position of linked list\n"");
    delete_end();
    break;
    case 9:printf(""delete the element at any position of linked list\n"");
    delete_at_pos();
    break;
    case 10:printf(""reverse the linked list\n"");
    reverse();
    break;
    case 11:printf(""exit\n"");
    exit(0);
    break;
    default: printf(""wrong choice \n"");
    break;
    }
    printf(""enter the choice ="");
    scanf(""%d"",& choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
            printf(""enter the data = "");
            scanf(""%d"",& newnode->data);
            newnode->next=0;
       if(head==0)
       {
            head=temp=newnode;
       }
       else
       {
            temp->next=newnode;
            temp=newnode;
       }
       printf(""do you need to continue (0,1)?\n0 to stop 1 to continue the element in the linked list ="");
           scanf(""%d"",& choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    while(temp!=0)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""\n"");
}
int count()
{
    struct node *temp;
    int count=0;
    temp=head;
    while(temp!=0)
    {
        count++;
        temp=temp->next;
    }
    printf(""the number of element in linked list is %d"", count);
    printf(""\n"");
    return count;
}
void insert_beg()
{
    struct node *newnode;
    newnode=(struct node*)malloc(sizeof(struct node));
    printf(""enter the data ="");
    scanf(""%d"",&newnode->data);
    newnode->next=head;
    head=newnode;
}
void insert_end()
{
    struct node *newnode,*temp;
    newnode=(struct node*)malloc(sizeof(struct node));
    printf(""enter the data ="");
    scanf(""%d"",&newnode->data);
    newnode->next=0;
    temp=head;
    while(temp->next!=0)
    {
        temp=temp->next;
    }
    temp->next=newnode;
}
void insert_at_pos()
{
    struct node *newnode,*temp;
    int pos;
    printf(""enter the position to insert the element ="");
    scanf(""%d"",&pos);
    int i=1;
    int leg=count();
    if(pos>leg)
    {
        printf(""invalid position\n"");
    }
    else
    {
        newnode=(struct node*)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        temp=head;
        while(i<pos-1)
        {
            temp=temp->next;
            i++;
        }
        newnode->next=temp->next;
        temp->next=newnode;
    }
}
void delete_beg()
{
    struct node *temp;
    temp=head;
    head=head->next;
    free(temp);
}
void delete_end()
{
    struct node *temp,*nextnode;
    temp=head;
    while(temp->next!=0)
    {
        nextnode=temp;
        temp=temp->next;
    }
    if(temp==head)
    {
        head=0;
        free(temp);
    }
    else
    {
        nextnode->next=0;
        free(temp);
    }
}
void delete_at_pos()
{
    struct node *temp,*nextnode;
    int pos;
    printf(""enter the position to delete the element ="");
    scanf(""%d"",&pos);
    int i=1;
    int leg=count();
    if(pos>leg)
    {
        printf(""invalid position\n"");
    }
    else
    {
        temp=head;
        while(i<pos-1)
        {
            temp=temp->next;
            i++;
        }
        nextnode=temp->next;
        temp->next=nextnode->next;
        free(nextnode);
    }
}
void reverse()
{
    struct node *nextnode,*prenode,*currentnode;
    prenode=0;
    currentnode=nextnode=head;
    while(nextnode!=0)
    {
        nextnode=nextnode->next;
        currentnode->next=prenode;
        prenode=currentnode;
        currentnode=nextnode;
    }
    head=prenode;
}
",35,1156,1755
"void create();
void display();
void count();
void insert_beg();
struct node
{
    int data;
    struct node *next;
};
struct node *head=0;
int main()
{
    int choice;
    printf(""the function of circular linked list\n"");
    printf(""1.implementation of linked list\n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of elements in the linked list\n"");
    printf(""4.insert the element at the beginning position \n"");
    printf(""5.exit\n"");
    printf(""enter your choice ="");
    scanf(""%d"",&choice);
    while(choice!=6)
    {
        switch(choice)
        {
            case 1:printf(""implementation of linked list\n"");
            create();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of elements in the linked list\n"");
            count();
            break;
            case 4:printf(""insert the element at the beginning position \n"");
            insert_beg();
            break;
            case 5:printf(""exit\n"");
            exit(0);
            break;
            default:printf(""wrong choice \n"");
            break;
        }
        printf(""enter your choice ="");
        scanf(""%d"",&choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            temp=newnode;
        }
        temp->next=head;
        printf(""do you need to continue(0,1)?\n enter 0 to stop and 1 to continue ="");
        scanf(""%d"",&choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    while(temp->next!=head)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""%d"",temp->data);
    printf(""\n"");
}
void count()
{
    struct node *temp;
    temp=head;
    int c=0;
    do
    {
        c++;
        temp=temp->next;
    }while(temp!=head);
    printf(""the number of elements in the list is %d\n"",c);
}
void insert_beg()
{
    struct node *newnode,*temp;
    newnode=(struct node *)malloc(sizeof(struct node));
    printf(""enter the data ="");
    scanf(""%d"",&newnode->data);
    if(head==0)
    {
        head=newnode;
        newnode->next=newnode;
    }
    else
    {
        temp=head;
        while(temp->next!=head)
        {
            temp=temp->next;
        }
        temp->next=newnode;
        newnode->next=head;
        head=newnode;
    }
}
",35,1157,855
"void create();
void display();
int count();
void delete_at_pos();
struct node
{
    int data;
    struct node *next;
};
struct node *head=0;
int main()
{
    int choice;
    printf(""the function of circular linked list\n"");
    printf(""1.implementation of linked list\n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of elements in the linked list\n"");
    printf(""4.delete the element from any position\n"");
    printf(""5.exit\n"");
    printf(""enter your choice ="");
    scanf(""%d"",&choice);
    while(choice!=6)
    {
        switch(choice)
        {
            case 1:printf(""implementation of linked list\n"");
            create();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of elements in the linked list\n"");
            count();
            break;
            case 4:printf(""delete the element from any position\n"");
            delete_at_pos();
            break;
            case 5:printf(""exit\n"");
            exit(0);
            break;
            default:printf(""wrong choice \n"");
            break;
        }
        printf(""enter your choice ="");
        scanf(""%d"",&choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            temp=newnode;
        }
        temp->next=head;
        printf(""do you need to continue(0,1)?\n enter 0 to stop and 1 to continue ="");
        scanf(""%d"",&choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    while(temp->next!=head)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""%d"",temp->data);
    printf(""\n"");
}
int count()
{
    struct node *temp;
    temp=head;
    int c=0;
    do
    {
        c++;
        temp=temp->next;
    }while(temp!=head);
    printf(""the number of elements in the list is %d\n"",c);
    return c;
}
void delete_at_pos()
{
    struct node *temp,*nextnode;
    int i=1;
    int pos;
    int leg=count();
    printf(""enter the position in between 1 to %d\n"",leg);
    printf(""enter the position ="");
    scanf(""%d"",&pos);
    temp=head;
    while(i<pos-1)
    {
        temp=temp->next;
        i++;
    }
    nextnode=temp->next;
    temp->next=nextnode->next;
    free(nextnode);
}
",35,1158,844
"void create();
void display();
void count();
void insert_beg();
struct node
    {
        int data;
        struct node *next;
    };
    struct node *head=0;
int main()
{
    printf(""Linked list functions\n"");
    int choice;
    printf(""1.implementation\n"");
    printf(""2.display\n"");
    printf(""3.count\n"");
    printf(""4.inserst at the begining \n"");
    printf(""5.exit\n"");
    printf(""enter the choice ="");
    scanf(""%d"",& choice);
    while(choice!=6)
    {
    switch(choice)
    {
    case 1:printf(""implementation \n"");
    create();
    break;
    case 2:printf(""display\n"");
    display();
    break;
    case 3:printf(""count the element in linked list\n"");
    count();
    break;
    case 4:printf(""inserting the element at the begining \n"");
    insert_beg();
    break;
    case 5:exit(0);
    break;
    default: printf(""wrong choice \n"");
    break;
    }
    printf(""enter the choice ="");
    scanf(""%d"",& choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
            printf(""enter the data = "");
            scanf(""%d"",& newnode->data);
            newnode->next=0;
       if(head==0)
       {
            head=temp=newnode;
       }
       else
       {
            temp->next=newnode;
            temp=newnode;
       }
       printf(""do you need to continue (0,1)?\n0 to stop 1 to continue the element in the linked list ="");
           scanf(""%d"",& choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    while(temp!=0)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""\n"");
}
void count()
{
    struct node *temp;
    int count=0;
    temp=head;
    while(temp!=0)
    {
        count++;
        temp=temp->next;
    }
    printf(""the number of element in linked list is %d"", count);
    printf(""\n"");
}
void insert_beg()
{
    struct node *newnode;
    newnode=(struct node*)malloc(sizeof(struct node));
    printf(""enter the data ="");
    scanf(""%d"",&newnode->data);
    newnode->next=head;
    head=newnode;
}
",35,1159,702
"void create();
void display();
void count();
void delete_beg();
struct node
    {
        int data;
        struct node *next;
        struct node *pre;
    };
    struct node *head=0;
int main()
{
    printf(""Linked list functions\n"");
    int choice;
    printf(""1.implementation\n"");
    printf(""2.display\n"");
    printf(""3.count\n"");
    printf(""4.delete the element from the beginning position \n"");
    printf(""5.exit\n"");
    printf(""enter the choice ="");
    scanf(""%d"",& choice);
    while(choice!=6)
    {
    switch(choice)
    {
    case 1:printf(""implementation \n"");
    create();
    break;
    case 2:printf(""display\n"");
    display();
    break;
    case 3:printf(""count the element in linked list\n"");
    count();
    break;
    case 4:printf(""delete the element from the beginning position \n"");
    delete_beg();
    break;
    case 5:printf(""exit\n"");
    exit(0);
    break;
    default: printf(""wrong choice \n"");
    break;
    }
    printf(""enter the choice ="");
    scanf(""%d"",& choice);
    }
}
void create()
{
    struct node *newnode,*tail;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
            printf(""enter the data = "");
            scanf(""%d"",& newnode->data);
            newnode->next=0;
            newnode->pre=0;
       if(head==0)
       {
            head=tail=newnode;
       }
       else
       {
            tail->next=newnode;
            newnode->pre=tail;
            tail=newnode;
       }
       printf(""do you need to continue (0,1)?\n0 to stop 1 to continue the element in the linked list ="");
           scanf(""%d"",& choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    while(temp!=0)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""\n"");
}
void count()
{
    struct node *temp;
    int count=0;
    temp=head;
    while(temp!=0)
    {
        count++;
        temp=temp->next;
    }
    printf(""the number of element in linked list is %d"", count);
    printf(""\n"");
}
void delete_beg()
{
    struct node *temp;
    temp=head;
    head=head->next;
    head->pre=0;
    free(temp);
}
",35,1160,704
"void create();
void display();
void count();
void delete_at_beg();
struct node
    {
        int data;
        struct node *next;
    };
    struct node *head=0;
int main()
{
    printf(""Linked list functions\n"");
    int choice;
    printf(""1.implementation\n"");
    printf(""2.display\n"");
    printf(""3.count\n"");
    printf(""4.delete the element at the beginning position\n"");
    printf(""5.exit\n"");
    printf(""enter the choice ="");
    scanf(""%d"",& choice);
    while(choice!=6)
    {
        switch(choice)
        {
            case 1:printf(""implementation \n"");
            create();
            break;
            case 2:printf(""display\n"");
            display();
            break;
            case 3:printf(""count the element in linked list\n"");
            count();
            break;
            case 4:printf(""delete the element from the beginning\n"");
            delete_at_beg();
            break;
            case 5:exit(0);
            break;
            default: printf(""wrong choice \n"");
            break;
        }
        printf(""enter the choice ="");
        scanf(""%d"",& choice);
        }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
            printf(""enter the data = "");
            scanf(""%d"",& newnode->data);
            newnode->next=0;
       if(head==0)
       {
            head=temp=newnode;
       }
       else
       {
            temp->next=newnode;
            temp=newnode;
       }
       printf(""do you need to continue (0,1)?\n0 to stop 1 to continue the element in the linked list ="");
           scanf(""%d"",& choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    while(temp!=0)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""\n"");
}
void count()
{
    struct node *temp;
    int count=0;
    temp=head;
    while(temp!=0)
    {
        count++;
        temp=temp->next;
    }
    printf(""the number of element in linked list is %d"", count);
    printf(""\n"");
}
void delete_at_beg()
{
    struct node *temp;
    temp=head;
    head=head->next;
    free(temp);
}
",35,1161,668
"void merge(int a[],int lb,int mid,int ub)
{
    int i,j,k,b[10];
    i=lb;
    j=mid+1;
    k=lb;
    while(i<=mid && j<=ub)
    {
        if(a[i]<a[j])
        {
            b[k]=a[i];
            i++;
            k++;
        }
        else
        {
            b[k]=a[j];
            j++;
            k++;
        }
    }
    if(i>mid)
    {
        while(j<=ub)
        {
            b[k]=a[j];
            j++;
            k++;
        }
    }
    else
    {
        while(i<=mid)
        {
            b[k]=a[i];
            i++;
            k++;
        }
    }
    for(k=lb;k<=ub;k++)
    {
        a[k]=b[k];
    }
}
void mergesort(int a[],int l,int r)
{
    int mid;
    if(l<r)
    {
        mid=(l+r)/2;
        mergesort(a,l,mid);
        mergesort(a,mid+1,r);
        merge(a,l,mid,r);
    }
}
void printarray(int a[],int n)
{
    int i;
    for(i=0;i<n;i++)
        printf(""%d\t"",a[i]);
}
int main(void) {
    printf(""sorting the elements in the array \n""); 
    printf(""merge sort \n"");
    int a[10]={45,78,96,12,63,80,69,71,85,11};
    int n=10;
    printf(""the elements in the array are :\n "");
    printarray(a,n);
    printf(""\n after sorting elements in the array are :\n"");
    mergesort(a,0,n-1);
    printarray(a,n);
    return EXIT_SUCCESS;
}
",35,1162,539
"void create();
void display();
int count();
void insert_at_pos();
struct node
{
    int data;
    struct node *next;
    struct node *pre;
};
struct node *head=0;
int main()
{
    int choice;
    printf(""function of doubly circular linked list \n"");
    printf(""1.implementation \n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of elements in the linked list\n"");
    printf(""4.insert the element at any position in the linked list\n"");
    printf(""5.exit\n"");
    printf(""enter the choice ="");
    scanf(""%d"",&choice);
    while(choice!=6)
    {
        switch(choice)
        {
            case 1:printf(""implementation \n"");
            create();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of elements in the linked list\n"");
            count();
            break;
            case 4: printf(""insert the element at any position in the linked list\n"");
            insert_at_pos();
            break;
            case 5:printf(""exit\n"");
            exit(0);
            break;
            default:printf(""wrong choice\n"");
            break;
        }
        printf(""enter the choice ="");
        scanf(""%d"",&choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->pre=0;
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
            newnode->next=newnode;
            newnode->pre=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            newnode->next=head;
            temp=newnode;
            head->pre=temp;
        }
    printf(""do you need to continue(0,1)?\nenter 0 to stop and 1 to continue ="");
    scanf(""%d"",&choice);
    }

}
void display()
{
    struct node *temp;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    temp=head;
    while(temp->next!=head)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""%d "",temp->data);
    printf(""\n"");
}
int count()
{
    struct node *temp;
    int c=0;
    temp=head;
    do
    {
        c++;
        temp=temp->next;
    }while(temp!=head);
    printf(""the number of elements in the linked list is %d\n"",c);
    return c;
}
void insert_at_pos()
{
    struct node *newnode,*temp;
    int i=1;
    int pos;
    int leg=count();
    printf(""enter the position in between the 1 to %d\n"",leg);
    printf(""enter the position ="");
    scanf(""%d"",&pos);
    if(pos>leg)
    {
        printf(""invalied position\n"");
    }
    else
    {
        temp=head;
        while(i<pos-1)
        {
            temp=temp->next;
            i++;
        }
        newnode=(struct node*)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->next=temp->next;
        newnode->pre=temp;
        temp->next->pre=newnode;
        temp->next=newnode;
    }
}
",35,1163,994
"void creat();
void display();
void count();
void delete_end();
struct node
{
int data;
struct node *next;
struct node *pre;
};
struct node *head=0;
int main()
{
    printf(""function of double linked list \n"");
    printf(""1.implementation of linked list\n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of element in the linked list\n"");
    printf(""4.delete the element from the last position \n"");
    printf(""5.exit\n"");
    int choice;
    printf(""enter the choice ="");
    scanf(""%d"",&choice);
    while(choice!=6)
    {
        switch(choice)
        {
            case 1: printf(""implementation\n"");
            creat();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of element in the linked list\n"");
            count();
            break;
            case 4:printf(""delete the element from the last position \n"");
            delete_end();
            break;
            case 5:printf(""exit \n"");
            exit(0);
            break;
            default:printf(""invalied choice \n"");
            break;
        }
         printf(""enter the choice ="");
        scanf(""%d"",&choice);
    }
}
void creat()
{
struct node *newnode,*temp;
int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->pre=0;
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            temp=newnode;
        }
        printf(""do you need to continue(0,1)?\n enter 0 to stop  enter 1 to continue = "");
        scanf(""%d"",&choice);
    }
}
void display()
{
    struct node *temp;
    if(head==0)
    {
        printf(""the list is empty"");
    }
    temp=head;
    while(temp!=0)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""\n"");
}
void count()
{
    struct node *temp;
    temp=head;
    int c=0;
    while(temp!=0)
    {
        c++;
        temp=temp->next;
    }
    printf(""the number of elements in the linked list is %d \n"",c);
}
void delete_end()
{
    struct node *temp;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    else if(head->next==0)
    {
        head=0;
        free(head);
    }
    else
    {
        temp=head;
        while(temp->next!=0)
        {
            temp=temp->next;
        }
        temp->pre->next=0;
        free(temp);
    }
}
",35,1164,821
"void create();
void display();
void count();
void delete_at_end();
struct node
    {
        int data;
        struct node *next;
    };
    struct node *head=0;
int main()
{
    printf(""Linked list functions\n"");
    int choice;
    printf(""1.implementation\n"");
    printf(""2.display\n"");
    printf(""3.count\n"");
    printf(""4.delete the element at the end  positon\n"");
    printf(""5.exit\n"");
    printf(""enter the choice ="");
    scanf(""%d"",& choice);
    while(choice!=6)
    {
    switch(choice)
    {
    case 1:printf(""implementation \n"");
    create();
    break;
    case 2:printf(""display\n"");
    display();
    break;
    case 3:printf(""count the element in linked list\n"");
    count();
    break;
    case 4:printf(""delete the element from the end\n"");
    delete_at_end();
    break;
    case 5:exit(0);
    break;
    default: printf(""wrong choice \n"");
    break;
    }
    printf(""enter the choice ="");
    scanf(""%d"",& choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
            printf(""enter the data = "");
            scanf(""%d"",& newnode->data);
            newnode->next=0;
       if(head==0)
       {
            head=temp=newnode;
       }
       else
       {
            temp->next=newnode;
            temp=newnode;
       }
       printf(""do you need to continue (0,1)?\n0 to stop 1 to continue the element in the linked list ="");
           scanf(""%d"",& choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    while(temp!=0)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""\n"");
}
void count()
{
    struct node *temp;
    int count=0;
    temp=head;
    while(temp!=0)
    {
        count++;
        temp=temp->next;
    }
    printf(""the number of element in linked list is %d"", count);
    printf(""\n"");
}
void delete_at_end()
{
    struct node *temp,*prenode;
    temp=head;
    while(temp->next!=0)
    {
        prenode=temp;
        temp=temp->next;
    }
    if(temp==head)
    {
        head=0;
        free(temp);
    }
    else
    {
        prenode->next=0;
        free(temp);
    }
}
",35,1165,744
"void create();
struct node
    {
        int data;
        struct node *next;
    };
    struct node *head=0;
    int main()
{
    printf(""Linked list functions\n"");
    printf(""implementation\n"");
    create();
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
            printf(""enter the data = "");
            scanf(""%d"",& newnode->data);
            newnode->next=0;
       if(head==0)
       {
            head=temp=newnode;
       }
       else
       {
            temp->next=newnode;
            temp=newnode;
       }
       printf(""do you need to continue (0,1)?\n0 to stop 1 to continue the element in the linked list ="");
       scanf(""%d"",& choice);
    }
}
",35,1166,241
"void create();
void display();
void count();
void delete_beg();
struct node
{
    int data;
    struct node *next;
};
struct node *head=0;
int main()
{
    int choice;
    printf(""the function of circular linked list\n"");
    printf(""1.implementation of linked list\n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of elements in the linked list\n"");
    printf(""4.delete the element from the beginning position\n"");
    printf(""5.exit\n"");
    printf(""enter your choice ="");
    scanf(""%d"",&choice);
    while(choice!=6)
    {
        switch(choice)
        {
            case 1:printf(""implementation of linked list\n"");
            create();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of elements in the linked list\n"");
            count();
            break;
            case 4:printf(""delete the element from the beginning position\n"");
            delete_beg();
            break;
            case 5:printf(""exit\n"");
            exit(0);
            break;
            default:printf(""wrong choice \n"");
            break;
        }
        printf(""enter your choice ="");
        scanf(""%d"",&choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            temp=newnode;
        }
        temp->next=head;
        printf(""do you need to continue(0,1)?\n enter 0 to stop and 1 to continue ="");
        scanf(""%d"",&choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    while(temp->next!=head)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""%d"",temp->data);
    printf(""\n"");
}
void count()
{
    struct node *temp;
    temp=head;
    int c=0;
    do
    {
        c++;
        temp=temp->next;
    }while(temp!=head);
    printf(""the number of elements in the list is %d\n"",c);
}
void delete_beg()
{
    struct node *temp,*firstnode;
    temp =head;
    while(temp->next!=head)
    {
        temp=temp->next;
    }
    firstnode=head;
    head=head->next;
    temp->next=firstnode->next;
    free(firstnode);
}
",35,1167,780
"void create();
void display();
void count();
void delete_end();
struct node
{
    int data;
    struct node *next;
    struct node *pre;
};
struct node *head=0;
int main()
{
    int choice;
    printf(""function of doubly circular linked list \n"");
    printf(""1.implementation \n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of elements in the linked list\n"");
    printf(""4.delete the element at the last position in the linked list\n"");
    printf(""5.exit\n"");
    printf(""enter the choice ="");
    scanf(""%d"",&choice);
    while(choice!=6)
    {
        switch(choice)
        {
            case 1:printf(""implementation \n"");
            create();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of elements in the linked list\n"");
            count();
            break;
            case 4: printf(""delete the element at the last position in the linked list\n"");
            delete_end();
            break;
            case 5:printf(""exit\n"");
            exit(0);
            break;
            default:printf(""wrong choice\n"");
            break;
        }
        printf(""enter the choice ="");
        scanf(""%d"",&choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node*)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->pre=0;
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
            newnode->next=newnode;
            newnode->pre=newnode;
        }
        else
        {
            temp->next=newnode;
            newnode->pre=temp;
            newnode->next=head;
            temp=newnode;
            head->pre=temp;
        }
    printf(""do you need to continue(0,1)?\nenter 0 to stop and 1 to continue ="");
    scanf(""%d"",&choice);
    }

}
void display()
{
    struct node *temp;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    temp=head;
    while(temp->next!=head)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""%d "",temp->data);
    printf(""\n"");
}
void count()
{
    struct node *temp;
    int c=0;
    temp=head;
    do
    {
        c++;
        temp=temp->next;
    }while(temp!=head);
    printf(""the number of elements in the linked list is %d\n"",c);
}
void delete_end()
{
    struct node *temp,*endnode;
    temp=head;
    while(temp->next!=head)
    {
        temp=temp->next;
    }
    endnode=temp;
    temp->pre->next=head;
    head->pre=endnode->pre;
    free(endnode);
}
",35,1168,843
"void create();
void display();
void count();
void delete_end();
struct node
{
    int data;
    struct node *next;
};
struct node *head=0;
int main()
{
    int choice;
    printf(""the function of circular linked list\n"");
    printf(""1.implementation of linked list\n"");
    printf(""2.display the linked list\n"");
    printf(""3.count the number of elements in the linked list\n"");
    printf(""4.delete the element from the last position\n"");
    printf(""5.exit\n"");
    printf(""enter your choice ="");
    scanf(""%d"",&choice);
    while(choice!=6)
    {
        switch(choice)
        {
            case 1:printf(""implementation of linked list\n"");
            create();
            break;
            case 2:printf(""display the linked list\n"");
            display();
            break;
            case 3:printf(""count the number of elements in the linked list\n"");
            count();
            break;
            case 4:printf(""delete the element from the last position\n"");
            delete_end();
            break;
            case 5:printf(""exit\n"");
            exit(0);
            break;
            default:printf(""wrong choice \n"");
            break;
        }
        printf(""enter your choice ="");
        scanf(""%d"",&choice);
    }
}
void create()
{
    struct node *newnode,*temp;
    int choice;
    while(choice)
    {
        newnode=(struct node *)malloc(sizeof(struct node));
        printf(""enter the data ="");
        scanf(""%d"",&newnode->data);
        newnode->next=0;
        if(head==0)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            temp=newnode;
        }
        temp->next=head;
        printf(""do you need to continue(0,1)?\n enter 0 to stop and 1 to continue ="");
        scanf(""%d"",&choice);
    }
}
void display()
{
    struct node *temp;
    temp=head;
    if(head==0)
    {
        printf(""the list is empty\n"");
    }
    while(temp->next!=head)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
    printf(""%d"",temp->data);
    printf(""\n"");
}
void count()
{
    struct node *temp;
    temp=head;
    int c=0;
    do
    {
        c++;
        temp=temp->next;
    }while(temp!=head);
    printf(""the number of elements in the list is %d\n"",c);
}
void delete_end()
{
    struct node *temp,*endnode;
    temp =head;
    while(temp->next!=head)
    {
        endnode=temp;
        temp=temp->next;
    }
    endnode->next=head;
    free(temp);
}
",35,1169,769
"char **strtow(char *str, char *delims);
int is_delim(char ch, char *delims);
int get_word_length(char *str, char *delims);
int get_word_count(char *str, char *delims);
char *get_next_word(char *str, char *delims);



char **strtow(char *str, char *delims)
{
    char **words = NULL;
    int wc, wordLen, n, i = 0;

    if (str == NULL || !*str)
        return (NULL);
    wc = get_word_count(str, delims);


    if (wc == 0)
        return (NULL);
    words = malloc((wc + 1) * sizeof(char *));
    if (words == NULL)
        return (NULL);
    while (i < wc)
    {
        wordLen = get_word_length(str, delims);
        if (is_delim(*str, delims))
        {
            str = get_next_word(str, delims);
        }
        words[i] = malloc((wordLen + 1) * sizeof(char));
        if (words[i] == NULL)
        {
            while (i >= 0)
            {
                i--;
                free(words[i]);
            }
            free(words);
            return (NULL);
        }
        n = 0;
        while (n < wordLen)
        {
            words[i][n] = *(str + n);
            n++;
        }
        words[i][n] = '\0'; 
        str = get_next_word(str, delims);
        i++;
    }
    words[i] = NULL; 
    return (words);
}



int is_delim(char ch, char *delims)
{
    int i = 0;

    while (delims[i])
    {
        if (delims[i] == ch)
            return (1);
        i++;
    }
    return (0);
}



int get_word_length(char *str, char *delims)
{
    int wLen = 0, pending = 1, i = 0;

    while (*(str + i))
    {
        if (is_delim(str[i], delims))
            pending = 1;
        else if (pending)
        {
            wLen++;
        }
        if (wLen > 0 && is_delim(str[i], delims))
            break;
        i++;
    }
    return (wLen);
}



int get_word_count(char *str, char *delims)
{
    int wc = 0, pending = 1, i = 0;

    while (*(str + i))
    {
        if (is_delim(str[i], delims))
            pending = 1;
        else if (pending)
        {
            pending = 0;
            wc++;
        }
        i++;
    }
    return (wc);
}



char *get_next_word(char *str, char *delims)
{
    int pending = 0;
    int i = 0;

    while (*(str + i))
    {
        if (is_delim(str[i], delims))
            pending = 1;
        else if (pending)
            break;
        i++;
    }
    return (str + i);
}
",36,1170,877
"#include ""monty.h""


void free_tokens(void);
unsigned int token_arr_len(void);
int is_empty_line(char *line, char *delims);
void (*get_op_func(char *opcode))(stack_t**, unsigned int);
int run_monty(FILE *script_fd);


void free_tokens(void)
{
    size_t i = 0;

    if (op_toks == NULL)
        return;

    for (i = 0; op_toks[i]; i++)
        free(op_toks[i]);

    free(op_toks);
}


unsigned int token_arr_len(void)
{
    unsigned int toks_len = 0;

    while (op_toks[toks_len])
        toks_len++;
    return (toks_len);
}


int is_empty_line(char *line, char *delims)
{
    int i, j;

    for (i = 0; line[i]; i++)
    {
        for (j = 0; delims[j]; j++)
        {
            if (line[i] == delims[j])
                break;
        }
        if (delims[j] == '\0')
            return (0);
    }

    return (1);
}


void (*get_op_func(char *opcode))(stack_t**, unsigned int)
{
    instruction_t op_funcs[] = {
        {""push"", monty_push},
        {""pall"", monty_pall},
        {""pint"", monty_pint},
        {""pop"", monty_pop},
        {""swap"", monty_swap},
        {""add"", monty_add},
        {""nop"", monty_nop},
        {""sub"", monty_sub},
        {""div"", monty_div},
        {""mul"", monty_mul},
        {""mod"", monty_mod},
        {""pchar"", monty_pchar},
        {""pstr"", monty_pstr},
        {""rotl"", monty_rotl},
        {""rotr"", monty_rotr},
        {""stack"", monty_stack},
        {""queue"", monty_queue},
        {NULL, NULL}
    };
    int i;

    for (i = 0; op_funcs[i].opcode; i++)
    {
        if (strcmp(opcode, op_funcs[i].opcode) == 0)
            return (op_funcs[i].f);
    }

    return (NULL);
}


int run_monty(FILE *script_fd)
{
    stack_t *stack = NULL;
    char *line = NULL;
    size_t len = 0, exit_status = EXIT_SUCCESS;
    unsigned int line_number = 0, prev_tok_len = 0;
    void (*op_func)(stack_t**, unsigned int);

    if (init_stack(&stack) == EXIT_FAILURE)
        return (EXIT_FAILURE);

    while (getline(&line, &len, script_fd) != -1)
    {
        line_number++;
        op_toks = strtow(line, DELIMS);
        if (op_toks == NULL)
        {
            if (is_empty_line(line, DELIMS))
                continue;
            free_stack(&stack);
            return (malloc_error());
        }
        else if (op_toks[0][0] == '#') 
        {
            free_tokens();
            continue;
        }
        op_func = get_op_func(op_toks[0]);
        if (op_func == NULL)
        {
            free_stack(&stack);
            exit_status = unknown_op_error(op_toks[0], line_number);
            free_tokens();
            break;
        }
        prev_tok_len = token_arr_len();
        op_func(&stack, line_number);
        if (token_arr_len() != prev_tok_len)
        {
            if (op_toks && op_toks[prev_tok_len])
                exit_status = atoi(op_toks[prev_tok_len]);
            else
                exit_status = EXIT_FAILURE;
            free_tokens();
            break;
        }
        free_tokens();
    }
    free_stack(&stack);

    if (line && *line == 0)
    {
        free(line);
        return (malloc_error());
    }

    free(line);
    return (exit_status);
}
",36,1171,1172
"#include ""monty.h""

int short_stack_error(unsigned int line_number, char *op);
int div_error(unsigned int line_number);
int pop_error(unsigned int line_number);
int div_error(unsigned int line_number);
int pchar_error(unsigned int line_number, char *message);


int pop_error(unsigned int line_number)
{
    fprintf(stderr, ""L%u: can't pop an empty stack\n"", line_number);
    return (EXIT_FAILURE);
}


int pint_error(unsigned int line_number)
{
    fprintf(stderr, ""L%d: can't pint, stack empty\n"", line_number);
    return (EXIT_FAILURE);
}


int short_stack_error(unsigned int line_number, char *op)
{
    fprintf(stderr, ""L%u: can't %s, stack too short\n"", line_number, op);
    return (EXIT_FAILURE);
}


int div_error(unsigned int line_number)
{
    fprintf(stderr, ""L%u: division by zero\n"", line_number);
    return (EXIT_FAILURE);
}


int pchar_error(unsigned int line_number, char *message)
{
    fprintf(stderr, ""L%u: can't pchar, %s\n"", line_number, message);
    return (EXIT_FAILURE);
}
",36,1172,375
"#include ""binary_trees.h""

unsigned char is_leaf(const binary_tree_t *node);
size_t depth(const binary_tree_t *tree);
const binary_tree_t *get_leaf(const binary_tree_t *tree);
int is_perfect_recursive(const binary_tree_t *tree,
        size_t leaf_depth, size_t level);
int binary_tree_is_perfect(const binary_tree_t *tree);


unsigned char is_leaf(const binary_tree_t *node)
{
    return ((node->left == NULL && node->right == NULL) ? 1 : 0);
}


size_t depth(const binary_tree_t *tree)
{
    return (tree->parent != NULL ? 1 + depth(tree->parent) : 0);
}


const binary_tree_t *get_leaf(const binary_tree_t *tree)
{
    if (is_leaf(tree) == 1)
        return (tree);
    return (tree->left ? get_leaf(tree->left) : get_leaf(tree->right));
}


int is_perfect_recursive(const binary_tree_t *tree,
        size_t leaf_depth, size_t level)
{
    if (is_leaf(tree))
        return (level == leaf_depth ? 1 : 0);
    if (tree->left == NULL || tree->right == NULL)
        return (0);
    return (is_perfect_recursive(tree->left, leaf_depth, level + 1) &&
            is_perfect_recursive(tree->right, leaf_depth, level + 1));
}


int binary_tree_is_perfect(const binary_tree_t *tree)
{
    if (tree == NULL)
        return (0);
    return (is_perfect_recursive(tree, depth(get_leaf(tree)), 0));
}
",36,1173,478
"#include ""monty.h""

void monty_nop(stack_t **stack, unsigned int line_number);
void monty_pchar(stack_t **stack, unsigned int line_number);
void monty_pstr(stack_t **stack, unsigned int line_number);


void monty_nop(stack_t **stack, unsigned int line_number)
{
    (void)stack;
    (void)line_number;
}


void monty_pchar(stack_t **stack, unsigned int line_number)
{
    if ((*stack)->next == NULL)
    {
        set_op_tok_error(pchar_error(line_number, ""stack empty""));
        return;
    }
    if ((*stack)->next->n < 0 || (*stack)->next->n > 127)
    {
        set_op_tok_error(pchar_error(line_number,
                    ""value out of range""));
        return;
    }

    printf(""%c\n"", (*stack)->next->n);
}


void monty_pstr(stack_t **stack, unsigned int line_number)
{
    stack_t *tmp = (*stack)->next;

    while (tmp && tmp->n != 0 && (tmp->n > 0 && tmp->n <= 127))
    {
        printf(""%c"", tmp->n);
        tmp = tmp->next;
    }

    printf(""\n"");

    (void)line_number;
}
",36,1174,373
"char *get_int(int num);
unsigned int _abs(int);
int get_numbase_len(unsigned int num, unsigned int base);
void fill_numbase_buff(unsigned int num, unsigned int base,
        char *buff, int buff_size);


char *get_int(int num)
{
    unsigned int temp;
    int length = 0;
    long num_l = 0;
    char *ret;

    temp = _abs(num);
    length = get_numbase_len(temp, 10);

    if (num < 0 || num_l < 0)
        length++; 
    ret = malloc(length + 1); 
    if (!ret)
        return (NULL);

    fill_numbase_buff(temp, 10, ret, length);
    if (num < 0 || num_l < 0)
        ret[0] = '-';

    return (ret);
}


unsigned int _abs(int i)
{
    if (i < 0)
        return (-(unsigned int)i);
    return ((unsigned int)i);
}


int get_numbase_len(unsigned int num, unsigned int base)
{
    int len = 1; 

    while (num > base - 1)
    {
        len++;
        num /= base;
    }
    return (len);
}


void fill_numbase_buff(unsigned int num, unsigned int base,
        char *buff, int buff_size)
{
    int rem, i = buff_size - 1;

    buff[buff_size] = '\0';
    while (i >= 0)
    {
        rem = num % base;
        if (rem > 9) 
            buff[i] = rem + 87; 
        else
            buff[i] = rem + '0';
        num /= base;
        i--;
    }
}
",36,1175,479
"#include ""sort.h""

void _swap(int *a, int *b)
{
    int tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;
}


void selection_sort(int *array, size_t size)
{
    unsigned int i, j, min;

    if (array == NULL || size < 2)
        return;

    for (i = 0; i < size; i++)
    {
        min = i;
        for (j = i + 1; j < size; j++)
        {
            if (array[min] > array[j])
                min = j;
        }
        if (min != i)
        {
            _swap(&array[i], &array[min]);
            print_array(array, size);
        }
    }

}
",36,1176,212
"#include ""monty.h""


void free_stack(stack_t **stack);
int init_stack(stack_t **stack);
int check_mode(stack_t *stack);


void free_stack(stack_t **stack)
{
    stack_t *tmp = *stack;

    while (*stack)
    {
        tmp = (*stack)->next;
        free(*stack);
        *stack = tmp;
    }
}


int init_stack(stack_t **stack)
{
    stack_t *s;

    s = malloc(sizeof(stack_t));
    if (s == NULL)
        return (malloc_error());

    s->n = STACK;
    s->prev = NULL;
    s->next = NULL;

    *stack = s;

    return (EXIT_SUCCESS);
}

",36,1177,212
"#include ""binary_trees.h""

bst_t *inorder_successor(bst_t *root);
bst_t *bst_delete(bst_t *root, bst_t *node);
bst_t *bst_remove_recursive(bst_t *root, bst_t *node, int value);
bst_t *bst_remove(bst_t *root, int value);


bst_t *inorder_successor(bst_t *root)
{
    while (root->left != NULL)
        root = root->left;
    return (root);
}


bst_t *bst_delete(bst_t *root, bst_t *node)
{
    bst_t *parent = node->parent, *successor = NULL;

    
    if (node->left == NULL)
    {
        if (parent != NULL && parent->left == node)
            parent->left = node->right;
        else if (parent != NULL)
            parent->right = node->right;
        if (node->right != NULL)
            node->right->parent = parent;
        free(node);
        return (parent == NULL ? node->right : root);
    }

    
    if (node->right == NULL)
    {
        if (parent != NULL && parent->left == node)
            parent->left = node->left;
        else if (parent != NULL)
            parent->right = node->left;
        if (node->left != NULL)
            node->left->parent = parent;
        free(node);
        return (parent == NULL ? node->left : root);
    }

    
    successor = inorder_successor(node->right);
    node->n = successor->n;

    return (bst_delete(root, successor));
}


bst_t *bst_remove_recursive(bst_t *root, bst_t *node, int value)
{
    if (node != NULL)
    {
        if (node->n == value)
            return (bst_delete(root, node));
        if (node->n > value)
            return (bst_remove_recursive(root, node->left, value));
        return (bst_remove_recursive(root, node->right, value));
    }
    return (NULL);
}


bst_t *bst_remove(bst_t *root, int value)
{
    return (bst_remove_recursive(root, root, value));
}
",36,1178,599
"#include ""monty.h""

void monty_add(stack_t **stack, unsigned int line_number);
void monty_sub(stack_t **stack, unsigned int line_number);
void monty_div(stack_t **stack, unsigned int line_number);
void monty_mul(stack_t **stack, unsigned int line_number);
void monty_mod(stack_t **stack, unsigned int line_number);


void monty_add(stack_t **stack, unsigned int line_number)
{
    if ((*stack)->next == NULL || (*stack)->next->next == NULL)
    {
        set_op_tok_error(short_stack_error(line_number, ""add""));
        return;
    }

    (*stack)->next->next->n += (*stack)->next->n;
    monty_pop(stack, line_number);
}


void monty_sub(stack_t **stack, unsigned int line_number)
{
    if ((*stack)->next == NULL || (*stack)->next->next == NULL)
    {
        set_op_tok_error(short_stack_error(line_number, ""sub""));
        return;
    }

    (*stack)->next->next->n -= (*stack)->next->n;
    monty_pop(stack, line_number);
}


void monty_div(stack_t **stack, unsigned int line_number)
{
    if ((*stack)->next == NULL || (*stack)->next->next == NULL)
    {
        set_op_tok_error(short_stack_error(line_number, ""div""));
        return;
    }

    if ((*stack)->next->n == 0)
    {
        set_op_tok_error(div_error(line_number));
        return;
    }

    (*stack)->next->next->n /= (*stack)->next->n;
    monty_pop(stack, line_number);
}


void monty_mul(stack_t **stack, unsigned int line_number)
{
    if ((*stack)->next == NULL || (*stack)->next->next == NULL)
    {
        set_op_tok_error(short_stack_error(line_number, ""mul""));
        return;
    }

    (*stack)->next->next->n *= (*stack)->next->n;
    monty_pop(stack, line_number);
}


void monty_mod(stack_t **stack, unsigned int line_number)
{
    if ((*stack)->next == NULL || (*stack)->next->next == NULL)
    {
        set_op_tok_error(short_stack_error(line_number, ""mod""));
        return;
    }

    if ((*stack)->next->n == 0)
    {
        set_op_tok_error(div_error(line_number));
        return;
    }

    (*stack)->next->next->n %= (*stack)->next->n;
    monty_pop(stack, line_number);
}
",36,1179,744
"#include ""binary_trees.h""


bst_t *bst_insert(bst_t **tree, int value)
{
    bst_t *curr, *new;

    if (tree != NULL)
    {
        curr = *tree;

        if (curr == NULL)
        {
            new = binary_tree_node(curr, value);
            if (new == NULL)
                return (NULL);
            return (*tree = new);
        }

        if (value < curr->n) 
        {
            if (curr->left != NULL)
                return (bst_insert(&curr->left, value));

            new = binary_tree_node(curr, value);
            if (new == NULL)
                return (NULL);
            return (curr->left = new);
        }
        if (value > curr->n) 
        {
            if (curr->right != NULL)
                return (bst_insert(&curr->right, value));

            new = binary_tree_node(curr, value);
            if (new == NULL)
                return (NULL);
            return (curr->right = new);
        }
    }
    return (NULL);
}
",36,1180,286
"#include ""sort.h""

void swap_backward(listint_t *c)
{
    listint_t *tmp, *head;

    while (c->prev != NULL)
    {
        if (c->n < c->prev->n)
        {
            tmp = c->prev->prev;
            c->prev->next = c->next;
            c->next = c->prev;
            c->prev->prev = c;
            c->prev = tmp;
            c->next->next->prev = c->next;
            if (tmp != NULL)
                tmp->next = c;
            head = c;
            while (head->prev != NULL)
                head = head->prev;
            print_list(head);
        }
        else
            c = c->prev;
    }
}

void swap_forward(listint_t *c)
{
    listint_t *tmp, *head;

    tmp = c->prev;

    if (tmp != NULL)
    {
        tmp->next = c->next;
        c->next->prev = tmp;
    }
    else
        c->next->prev = NULL;
    c->prev = c->next;
    if (c->next->next != NULL)
    {
        c->next = c->next->next;
        c->prev->next = c;
        c->next->prev = c;
    }
    else
    {
        c->next->next = c;
        c->next = NULL;
    }
    head = c;
    while (head->prev != NULL)
        head = head->prev;
    print_list(head);
    swap_backward(c->prev);
}

void insertion_sort_list(listint_t **list)
{
    listint_t *c;

    if ((list == NULL) || (*list == NULL) || ((*list)->next == NULL))
        return;
    c = *list;

    while (c->next != NULL)
    {
        if (c->n > c->next->n)
        {
            swap_forward(c);
        }
        else
            c = c->next;
    }
    while ((*list)->prev != NULL)
        *list = (*list)->prev;
}
",36,1181,558
"#include ""monty.h""


void set_op_tok_error(int error_code)
{
    int toks_len = 0, i = 0;
    char *exit_str = NULL;
    char **new_toks = NULL;

    toks_len = token_arr_len();
    new_toks = malloc(sizeof(char *) * (toks_len + 2));
    if (!op_toks)
    {
        malloc_error();
        return;
    }
    while (i < toks_len)
    {
        new_toks[i] = op_toks[i];
        i++;
    }
    exit_str = get_int(error_code);
    if (!exit_str)
    {
        free(new_toks);
        malloc_error();
        return;
    }
    new_toks[i++] = exit_str;
    new_toks[i] = NULL;
    free(op_toks);
    op_toks = new_toks;
}
",36,1182,262
"#include ""binary_trees.h""

size_t height(const binary_tree_t *tree);
int balance(const binary_tree_t *tree);
avl_t *avl_insert_recursive(avl_t **tree, avl_t *parent,
        avl_t **new, int value);
avl_t *avl_insert(avl_t **tree, int value);


size_t height(const binary_tree_t *tree)
{
    if (tree != NULL)
    {
        size_t l = 0, r = 0;

        l = tree->left ? 1 + binary_tree_height(tree->left) : 1;
        r = tree->right ? 1 + binary_tree_height(tree->right) : 1;
        return ((l > r) ? l : r);
    }
    return (0);
}


int balance(const binary_tree_t *tree)
{
    return (tree != NULL ? height(tree->left) - height(tree->right) : 0);
}


avl_t *avl_insert_recursive(avl_t **tree, avl_t *parent,
        avl_t **new, int value)
{
    int bfactor;

    if (*tree == NULL)
        return (*new = binary_tree_node(parent, value));

    if ((*tree)->n > value)
    {
        (*tree)->left = avl_insert_recursive(&(*tree)->left, *tree, new, value);
        if ((*tree)->left == NULL)
            return (NULL);
    }
    else if ((*tree)->n < value)
    {
        (*tree)->right = avl_insert_recursive(&(*tree)->right, *tree, new, value);
        if ((*tree)->right == NULL)
            return (NULL);
    }
    else
        return (*tree);

    bfactor = balance(*tree);
    if (bfactor > 1 && (*tree)->left->n > value)
        *tree = binary_tree_rotate_right(*tree);
    else if (bfactor < -1 && (*tree)->right->n < value)
        *tree = binary_tree_rotate_left(*tree);
    else if (bfactor > 1 && (*tree)->left->n < value)
    {
        (*tree)->left = binary_tree_rotate_left((*tree)->left);
        *tree = binary_tree_rotate_right(*tree);
    }
    else if (bfactor < -1 && (*tree)->right->n > value)
    {
        (*tree)->right = binary_tree_rotate_right((*tree)->right);
        *tree = binary_tree_rotate_left(*tree);
    }

    return (*tree);
}


avl_t *avl_insert(avl_t **tree, int value)
{
    avl_t *new = NULL;

    if (tree == NULL)
        return (NULL);
    if (*tree == NULL)
    {
        *tree = binary_tree_node(NULL, value);
        return (*tree);
    }
    avl_insert_recursive(tree, *tree, &new, value);
    return (new);
}
",36,1183,796
"#include ""monty.h""

void monty_push(stack_t **stack, unsigned int line_number);
void monty_pall(stack_t **stack, unsigned int line_number);
void monty_pint(stack_t **stack, unsigned int line_number);
void monty_pop(stack_t **stack, unsigned int line_number);
void monty_swap(stack_t **stack, unsigned int line_number);


void monty_push(stack_t **stack, unsigned int line_number)
{
    stack_t *tmp, *new;
    int i;

    new = malloc(sizeof(stack_t));
    if (new == NULL)
    {
        set_op_tok_error(malloc_error());
        return;
    }

    if (op_toks[1] == NULL)
    {
        set_op_tok_error(no_int_error(line_number));
        return;
    }

    for (i = 0; op_toks[1][i]; i++)
    {
        if (op_toks[1][i] == '-' && i == 0)
            continue;
        if (op_toks[1][i] < '0' || op_toks[1][i] > '9')
        {
            set_op_tok_error(no_int_error(line_number));
            return;
        }
    }
    new->n = atoi(op_toks[1]);

    if (check_mode(*stack) == STACK) 
    {
        tmp = (*stack)->next;
        new->prev = *stack;
        new->next = tmp;
        if (tmp)
            tmp->prev = new;
        (*stack)->next = new;
    }
    else 
    {
        tmp = *stack;
        while (tmp->next)
            tmp = tmp->next;
        new->prev = tmp;
        new->next = NULL;
        tmp->next = new;
    }
}


void monty_pall(stack_t **stack, unsigned int line_number)
{
    stack_t *tmp = (*stack)->next;

    while (tmp)
    {
        printf(""%d\n"", tmp->n);
        tmp = tmp->next;
    }
    (void)line_number;
}


void monty_pint(stack_t **stack, unsigned int line_number)
{
    if ((*stack)->next == NULL)
    {
        set_op_tok_error(pint_error(line_number));
        return;
    }

    printf(""%d\n"", (*stack)->next->n);
}



void monty_pop(stack_t **stack, unsigned int line_number)
{
    stack_t *next = NULL;

    if ((*stack)->next == NULL)
    {
        set_op_tok_error(pop_error(line_number));
        return;
    }

    next = (*stack)->next->next;
    free((*stack)->next);
    if (next)
        next->prev = *stack;
    (*stack)->next = next;
}


void monty_swap(stack_t **stack, unsigned int line_number)
{
    stack_t *tmp;

    if ((*stack)->next == NULL || (*stack)->next->next == NULL)
    {
        set_op_tok_error(short_stack_error(line_number, ""swap""));
        return;
    }

    tmp = (*stack)->next->next;
    (*stack)->next->next = tmp->next;
    (*stack)->next->prev = tmp;
    if (tmp->next)
        tmp->next->prev = (*stack)->next;
    tmp->next = (*stack)->next;
    tmp->prev = *stack;
    (*stack)->next = tmp;
}
",36,1184,953
"int main() 
{
    int vetorA[5], vetorB[5], matrizC[2][5], i , j;

    for (i = 0; i < 5; i++)
    {
        printf(""Informe os valores do vetor A:  "");
        scanf_s(""%i"", &vetorA[i]);
    }
        
    for (i = 0; i < 5; i++) 
    {
        printf(""Informe os valores do vetor B:  "");
        scanf_s(""%i"", &vetorB[i]);
    }
    
    for (j = 0; j < 5; j++)
    {
        matrizC[0][j] = vetorA[j];
        matrizC[1][j] = vetorB[j];
    }
    
    for (i = 0; i < 2; i++)
        for (j = 0; j < 5; j++)
            printf(""A matriz com os vetores A e B e: %d linha,  %d coluna  %i\n"", i, j, matrizC[i][j]);
        
        
    

    system(""pause"");
}",37,1185,306
"int main()
{
    int escolha;
    float saque, deposito, saldo = 0;
    
    setlocale(LC_ALL, ""Portuguese"");
    system(""color 17"");

    printf(""Digite o que quer fazer: (1)Consulta saldo, (2)saque, (3)depÃ³sito, (4)sair:  "");
    scanf_s(""%i"", &escolha);

    while (escolha != 4)
    {
        
        if (escolha == 1)
        {

            printf(""\nSeu saldo Ã©:  %.2f"", saldo);

        }
    
        if (escolha == 2)
        {
            printf(""\nDigite o valor do saque:  "");
            scanf_s(""%f"", &saque);
            if ((saldo - saque) <= 0)
            {
                printf(""VocÃª nÃ£o possui saldo"");
            }
            else
            {
                saldo = saldo - saque;
                printf(""\nSeu saldo Ã©:  %.2f"", saldo);
            }
            
        }
        
        if (escolha == 3)
        {
            printf(""\nDigite o valor a ser depositado:  "");
            scanf_s(""%f"", &deposito);

            saldo = saldo + deposito;
            printf(""Seu saldo Ã© %.2f reais"", saldo);
        }
        printf(""\n==============================================================================================="");
        printf(""\n\nDigite o que quer fazer: (1)Consulta saldo, (2)saque, (3)depÃ³sito, (4)sair:  "");
        scanf_s(""%i"", &escolha);
    } 
    system(""pause"");
}
",37,1186,466
"int main() 
{
    int  numeroDivisivel = 0, inicioIntervalo = 0, fimIntervalo = 0, qtdDivisoesExatas = 0,soma = 0;

    setlocale(LC_ALL, ""Portuguese"");
    system(""color 17"");

    printf(""Digite o nÃºmero que queira dividir:  "");
    scanf_s(""%i"", &numeroDivisivel);

    printf(""Digite o primeiro intervalo:  "");
    scanf_s(""%i"", &inicioIntervalo);

    printf(""Digite o segundo intervalo:  "");
    scanf_s(""%i"", &fimIntervalo);

    while (inicioIntervalo <= fimIntervalo)
    {
        if (inicioIntervalo % numeroDivisivel == 0)
        {
            qtdDivisoesExatas++;
            soma += inicioIntervalo;
        }
        inicioIntervalo++;
    }

    printf(""\n\nO nÃºmero pode ser dividido por %i nÃºmeros inteiros\n\n"", qtdDivisoesExatas);
    printf(""A soma dos nÃºmeros inteiros divididos por %i Ã©:  %i\n\n"",numeroDivisivel, soma);

    system(""pause"");
}
",37,1187,337
"int main() 
{
    int matrizA[5][3], matrizB[5][3], matrizC[5][3], i, j;

    for(i = 0; i < 5; i++)
        for (j = 0; j < 3; j++) 
        {
            printf(""Digite os valores da primeira matriz: %d linha, %d coluna:  "", i, j);
            scanf_s(""%i"", &matrizA[i][j]);
        }
    for (i = 0; i < 5; i++)
        for (j = 0; j < 3; j++)
        {
            printf(""Digite os valores da segunda matriz: %d linha, %d coluna:  "", i, j);
            scanf_s(""%i"", &matrizB[i][j]);
        }
    for (i = 0; i < 5; i++)
        for (j = 0; j < 3; j++) 
        {
            matrizC[i][j] = matrizA[i][j] + matrizB[i][j];

            printf(""A soma dos elementos e:  %i\n"", matrizC[i][j]);
        }
    system(""pause"");
}",37,1188,313
"int main() 
{
    float altura = 0,maioralt = 0,menoralt = 999,mediamulher = 0,mediaalt = 0,maiorhomem = 0,menorhomem = 999,quantF = 0;
    char sexo;
    int i;

    system(""color 17"");

    for (i = 0; i < 4; i++) 
    {
        
        printf(""Digite sua altura separado por ponto:Ex: 1.00  "");
        scanf_s(""%f"", &altura);
        (void)getchar();
        

        printf(""Digite seu sexo: M ou F:  "");
        scanf_s(""%c"", &sexo,1);
        sexo = toupper(sexo);
        
        if (altura < menoralt) 
        {
            menoralt = altura;
        }
        if (altura > maioralt) 
        {
            maioralt = altura;
        }

        if (sexo == 'F') 
        {
            quantF++;
            mediamulher += altura;
        }

        if (sexo == 'M' && altura < menorhomem) 
        {
            menorhomem = altura;
        }
        if (sexo == 'M' && altura > maiorhomem)
        {
            maiorhomem = altura;
        }

        mediaalt += altura;
    }
    
    if (mediamulher != 0)
    {
        mediamulher = mediamulher / quantF;
    }
    
    mediaalt = mediaalt / i;
    
    printf(""\n\n"");
    printf(""A maior altura da turma e:  %.2f\n"", maioralt);
    printf(""A maior altura da turma e:  %.2f\n"", menoralt);
    printf(""A media de altura das mulheres e:  %.2f\n"", mediamulher);
    printf(""A maior altura dos homens e:  %.2f\n"", maiorhomem);
    printf(""A menor altura dos homens e:  %.2f\n"", menorhomem);
    printf(""A media de altura da turma e:  %.2f\n"", mediaalt);




}",37,1189,576
"void metade();

float A[30], B[30];

int main() 
{
    int i;

    for (i = 0; i < 30; i++) 
    {
        printf(""Digite os valores de A:  "");
        scanf_s(""%f"", &A[i]);

        metade();
    }
    
    for (i = 0; i < 30; i++)
        printf(""Os valores de A pela metade sao:  %.2f\n"", B[i]);
}

void metade() 
{
    int i;
    
    for (i = 0; i < 30; i++) 
    {
        B[i] = A[i] / 2;
    }
}

",37,1190,195
"int main()
{
    int N1, N2, impar = 0, n3,i,r;

    setlocale(LC_ALL, ""Portuguese"");
    
    system(""color 17"");

    printf(""Digite o valor de N1:  "");
    scanf_s(""%i"", &N1);

    printf(""\nDigite o valor de N2:  "");
    scanf_s(""%i"", &N2);

    for (i =N1++ ; i < N2; i++)
    {
        if (i % 2 == 1) 
        {
            impar++;
        }
        
    }
    printf(""\nExistem %i numeros Ã­mpares entre N1 e N2 mano, ÃOBIXO\n"", impar);

    system(""pause"");
}
",37,1191,210
"int main() 
{
    char nomesProdutos[5][100], nomeCaro[100], loja[4][20] = {""Adidas"",""Nike"",""Cervejaria"",""Cachoeiras""};
    float lojaProduto[4][5], matrizImpostos[4][5], maisCaro = 0;
    int i, j;

    for (i = 0; i < 5; i++)
    {
        printf(""Digite os nomes dos produtos [%d]:  "", i);
        scanf_s(""%[^\n]s"", &nomesProdutos[i], 100);
        getchar();
    }
    
    for (i = 0; i < 4; i++)
        for (j = 0; j < 5; j++) 
        {
            printf(""Digite o preco dos produtos [%s] loja [%s] produto:  "", loja[i], nomesProdutos[j]);
            scanf_s(""%f"", &lojaProduto[i][j]);
        }

    for (i = 0; i < 4; i++)
        for (j = 0; j < 5; j++)
        {
            if (lojaProduto[i][j] <= 50) 
                matrizImpostos[i][j] = lojaProduto[i][j] * 5 / 100 + lojaProduto[i][j];
            if(lojaProduto[i][j] > 50 && lojaProduto[i][j] <= 100)
                matrizImpostos[i][j] = lojaProduto[i][j] * 10 / 100 + lojaProduto[i][j];
            if (lojaProduto[i][j] > 100)
                matrizImpostos[i][j] = lojaProduto[i][j] * 20 / 100 + lojaProduto[i][j];
        }

    for (i = 3; i < 4; i++)
        for (j = 0; j < 5; j++) 
        {
            if (matrizImpostos[i][j] > maisCaro) 
            {
                maisCaro = matrizImpostos[i][j];
                nomeCaro[99] = strcpy_s(nomeCaro, 99, nomesProdutos[i]);
            }
        }

    for (i = 0; i < 4; i++)
        for (j = 0; j < 5; j++)
        {
            printf(""A matriz com os impostos [%d][%d]:  %.2f\n"", i, j, matrizImpostos[i][j]);
        }

    printf(""O produto mais caro da 3 linha e %s com o valor de %.0f\n"", nomeCaro, maisCaro);

    system(""pause"");
}
",37,1192,751
"float cubo(float N);

int main() 
{
    float volumeEsfera, equacao, PI, y, N;
    
    printf(""Digite o numero para o cubo:  "");
    scanf_s(""%f"", &N);
    
    printf(""Digite o valor de PI:  "");
    scanf_s(""%f"", &PI);

    volumeEsfera = 4 * PI * cubo(N) / 3;

    printf(""O volume da esfera e:  %.2f\n\n"", volumeEsfera);

    N = 0;

    printf(""Digite o valor de X para a equacao:  "");
    scanf_s(""%f"", &N);

    printf(""Digite o valor de Y para a equacao:  "");
    scanf_s(""%f"", &y);

    equacao = cubo(N) + cubo(y) + 2;

    printf(""O resultado da equacao e: %.2f\n"", equacao);
}

float cubo(float N)
{
    float resultado;
    resultado = pow(N,3);
    return(resultado);
}
",37,1193,294
"int main()
{
    float matriz[3][3] = { {10,20,30}, {40,50,60}, {70,80,90} }, media, acimaMedia = 0, somaMedia = 0, repeticao = 0;
    int i, j;
    
    
    for (i = 0; i < 1; i++)
        for (j = 0; j < 1; j++)
            printf(""Os elementos da diagonal sao :  %.0f, %.0f, %.0f\n"", matriz[0][0], matriz[1][1], matriz[2][2]);
        
    for (i = 0; i < 3; i++)
        for (j = 0; j < 3; j++) 
        {
            somaMedia += matriz[i][j];
            repeticao++;
        }
    
    media = somaMedia / repeticao;
    
    printf(""\nA media dos elementos e:  %.2f"", media);

    for (i = 0; i < 3; i++)
        for (j = 0; j < 3; j++) 
        {
            if (matriz[i][j] > media)
                acimaMedia++;
        }
    
    printf(""\nExistem %.0f valores acima da media\n"",acimaMedia);
    
    system(""pause"");
}
",37,1194,353
"int main() 
{
    float matriz[5][4], somaMes[100], somaSemana = 0, totalVendas = 0;
    int i, j;
    
    for(i = 0; i < 5; i++)
        for (j = 0; j < 4; j++)
        {
            printf(""Digite as vendas da %d loja e %d semana:  "", i + 1, j+1);
            scanf_s(""%f"", &matriz[i][j]);
        }
    for (i = 0; i < 5; i++) 
    {
        somaMes[i] = 0;
        for (j = 0; j < 4; j++)
        {
            somaMes[i] += matriz[i][j];
        }
        somaSemana += somaMes[i];
        totalVendas += somaSemana;
    }
    for (i = 0; i < 5; i++)
        for (j = 0; j < 1; j++)
            printf(""O total de vendas do mes do %d vendedor e %.2f:  \n"", i+1, somaMes[i]);
            
    printf(""O total de vendas de cada semana de todos os vendedores e %.2f:  \n"", somaSemana);
    printf(""O total de vendas do mes e %.2f:  \n"", totalVendas);

    system(""pause"");
}
",37,1195,377
"float cubo(float N);
int diasVividos(int idade);

float N = 0;
int idade = 0, dia = 0, mes = 0, ano = 0;

int main() 
{
    float res1;
    int res2;
    
    res1 = cubo(N);
    printf(""O cubo e:  %.2f\n\n"",res1);
    
    res2 = diasVividos(idade);
    printf(""A quantidade de dias vividos e:  %i"", res2);
}

float cubo(float N)
{
    float resultado;
    
    printf(""Digite o numero para saber seu cubo:  "");
    scanf_s(""%f"", &N);
    
    resultado = N * N * N;
    return(resultado);
}

int diasVividos(int idade)
{
    int anos, meses = 0, ano1 = 0;

    printf(""Digite sua idade em anos:  "");
    scanf_s(""%i"", &idade);

    printf(""Digite sua data de nascimento separado por barra 00/00/0000:  "");
    scanf_s(""%i/%i/%i"", &dia, &mes, &ano);

    ano1 = (2020 - ano) * 365;
    meses = (11 - mes) * 30;

    anos = dia + meses + ano1;
    return(anos);
}
",37,1196,377
"int main() 
{

    int i;
    int num = 0;
    int inter1=0, inter2=0, inter3=0, inter4=0;
    

    system(""color 17"");

    for (i = 1; i <= 10; i++) {

        printf(""\n%d - Digite os numeros:  "", i);
        scanf_s(""%i"", &num);

        if (num < 0) 
        {
            printf(""Numero invalido\n"");
            break;
        }
        
        if ((num > 0) && (num <= 25))
        {
            
            inter1++;
        }

        if ((num > 25) && (num <= 50))
        {

            inter2++;
        }

        if ((num > 50) && (num <= 75))
        {

            inter3++;
        }

        if ((num > 75) && (num <= 100))
        {

            inter4++;
        }

    }

    printf(""Os numeros no 1 intervalo sao:  %i\n"", inter1);
    printf(""Os numeros no 2 intervalo sao:  %i\n"", inter2);
    printf(""Os numeros no 3 intervalo sao:  %i\n"", inter3);
    printf(""Os numeros no 4 intervalo sao:  %i\n"", inter4);
    

    system(""pause"");



}",37,1197,380
"int main() 
{
    int temperaturasOutubro[31], i,somaTemperatura = 0, diaInferior = 0;
    float media;

    for (i = 0; i < 31; i++) 
    {
        printf(""Digite as temperaturas:  "");
        scanf_s(""%i"", &temperaturasOutubro[i]);
        somaTemperatura += temperaturasOutubro[i];
    }

    media = somaTemperatura / i;
    printf(""A temperatura media e:  %.2f\n"", media);
    
    for (i = 0; i < 31; i++)
    {
        if (temperaturasOutubro[i] < media)
        {
            diaInferior++;
        }
    }
    for (i = 0; i < 31; i++)
    {
        if (temperaturasOutubro[i] > media)
        {
            printf(""Temperatura maior que a media no dia %i = %i Graus Celsius\n\n"",i, temperaturasOutubro[i]);
        }
    }
    printf(""Quantidade de dias com a temperatura inferior a media:  %i\n"", diaInferior);
    
    system(""pause"");
}
",37,1198,327
"int main(void)
{
    int n, i = 0, primo = 0;

    setlocale(LC_ALL, ""Portuguese"");
    system(""color 17"");

    printf(""Digite o valor de N:  "");
    scanf_s(""%i"", &n);

    while (i <= n)
    {
        i++;
        if (n % i == 0)
        {
            primo ++;
        }                       
    }

    if (primo == 2)
    {
        printf(""%i Ã© um nÃºmero primo\n"", n);
    }
    else
    {
        printf(""%i nÃ£o Ã© um nÃºmero primo\n\n"", n);
    }

    system(""pause"");
}
",37,1199,198
"#include ""deck.h""




void swap_func(deck_node_t **deck, deck_node_t *node1, deck_node_t *node2)
{
    deck_node_t *tmp;

    if (node1->next == node2)
    {
        if (node2->next)
            node2->next->prev = node1;
        node2->prev = node1->prev;
        node1->next = node2->next;
        node2->next = node1;
        if (node1->prev)
            node1->prev->next = node2;
        node1->prev = node2;
        if (*deck == node1)
            *deck = node2;
    }
    else
    {
        node1->next->prev = node2;
        if (node1->prev)
            node1->prev->next = node2;
        node2->prev->next = node1;
        if (node2->next)
            node2->next->prev = node1;
        tmp = node1->next;
        node1->next = node2->next;
        node2->next = tmp;
        tmp = node2->prev;
        node2->prev = node1->prev;
        node1->prev = tmp;
        if (*deck == node1)
            *deck = node2;
    }
}

int partition(deck_node_t **deck, int lo, int hi)
{
    deck_node_t *pivot = *deck, *pi = *deck, *pj = *deck, *tmp = *deck;
    int i, j, k, v;
    kind_t p;
    char *s = ""A234567891JQK"";

    for (i = 0; i < lo; i++)
    {
        pivot = pivot->next;
        pi = pi->next;
        pj = pj->next;
    }
    while (i < hi)
    {
        pivot = pivot->next;
        i++;
    }
    p = pivot->card->kind;
    i = lo;
    for (j = lo; j < hi; j++)
    {
        for (k = 0; s[k] != pj->card->value[0]; k++)
            ;
        for (v = 0; s[v] != pivot->card->value[0]; v++)
            ;
        if ((pj->card->kind < p) || (pj->card->kind == p && k <= v))
        {
            if (pi != pj)
            {
                swap_func(deck, pi, pj);
                tmp = pi;
                pi = pj;
                pj = tmp;
            }
            pi = pi->next, i++;
        }
        pj = pj->next;
    }
    if (pi != pivot)
        swap_func(deck, pi, pivot);
    return (i);
}

void quicksort(deck_node_t **deck, int lo, int hi)
{
    int p;

    if (lo < hi)
    {
        p = partition(deck, lo, hi);
        quicksort(deck, lo, p - 1);
        quicksort(deck, p + 1, hi);
    }

}

void sort_deck(deck_node_t **deck)
{
    if (deck == NULL || *deck == NULL || (*deck)->next == NULL)
        return;
    quicksort(deck, 0, 51);
}
",38,1200,862
"#include ""sort.h""

void swap_func(listint_t **list, listint_t *node)
{
    listint_t *tmp;

    tmp = node->next;
    if (tmp->next)
        tmp->next->prev = node;
    tmp->prev = node->prev;
    node->next = tmp->next;
    tmp->next = node;
    if (node->prev)
        node->prev->next = tmp;
    node->prev = tmp;
    if (*list == node)
        *list = tmp;
}


void cocktail_sort_list(listint_t **list)
{
    listint_t *current;
    int flag = 1;

    if (list == NULL || *list == NULL || (*list)->next == NULL)
        return;
    current = *list;
    while (flag > 0)
    {
        flag = 0;
        while (current->next != NULL)
        {
            if (current->n > current->next->n)
            {
                swap_func(list, current);
                print_list(*list);
                flag = 1;
            }
            else
                current = current->next;
        }
        if (flag == 0)
            break;
        flag = 0;
        while (current->prev != NULL)
        {
            if (current->n < current->prev->n)
            {
                swap_func(list, current->prev);
                print_list(*list);
                flag = 1;
            }
            else
                current = current->prev;
        }
    }
}
",38,1201,398
"#include ""binary_trees.h""

size_t binary_tree_height(const binary_tree_t *tree)
{
    size_t height_left = 0;
    size_t height_right = 0;

    if (tree == NULL)
        return (-1);
    if (tree->left == NULL && tree->right == NULL)
        return (0);
    height_left = binary_tree_height(tree->left) + 1;
    height_right = binary_tree_height(tree->right) + 1;
    if (height_left > height_right)
        return (height_left);
    return (height_right);
}


int binary_tree_balance(const binary_tree_t *tree)
{
    size_t height_left = 0;
    size_t height_right = 0;

    if (tree == NULL)
        return (0);
    height_left = binary_tree_height(tree->left);
    height_right = binary_tree_height(tree->right);
    return (height_left - height_right);
}


int binary_tree_is_perfect(const binary_tree_t *tree)
{
    if (tree == NULL || (binary_tree_balance(tree) != 0))
        return (0);
    if (tree->left == NULL && tree->right == NULL)
        return (1);
    return (binary_tree_is_perfect(tree->left)
        * binary_tree_is_perfect(tree->right));
}
",38,1202,379
"#include ""sort.h""

int partition(int *array, int lo, int hi, size_t size)
{
    int i, j, pivot, tmp;

    pivot = array[hi];
    i = lo - 1;
    j = hi + 1;
    while (1)
    {
        while (array[++i] < pivot)
        {
            ;
        }
        while (array[--j] > pivot)
        {
            ;
        }
        if (i > j)
            return (j);
        if (i != j)
        {
            tmp = array[i];
            array[i] = array[j];
            array[j] = tmp;
            print_array(array, size);
        }

    }
}

void quicksort_hoare(int *array, int lo, int hi, size_t size)
{
    int p;

    if (lo < hi)
    {
        p = partition(array, lo, hi, size);
        quicksort_hoare(array, lo, p, size);
        quicksort_hoare(array, p + 1, hi, size);
    }

}


void quick_sort_hoare(int *array, size_t size)
{
    if (array == NULL || size < 2)
        return;
    quicksort_hoare(array, 0, size - 1, size);
}
",38,1203,350
"#include ""sort.h""



void TopDownMerge(int *copy, int begin, int middle, int end, int *array)
{
    int i, j, k;

    i = begin;
    j = middle;
    k = begin;
    printf(""Merging...\n"");
    printf(""[left]: "");
    print_array(&copy[begin], middle - begin);
    printf(""[right]: "");
    print_array(&copy[middle], end - middle);
    while (k < end)
    {
        if (i < middle && (j >= end || copy[i] <= copy[j]))
        {
            array[k] = copy[i];
            i++;
        }
        else
        {
            array[k] = copy[j];
            j++;
        }
        k++;
    }
    printf(""[Done]: "");
    print_array(&array[begin], end - begin);
}

void TopDownSplitMerge(int *copy, int begin, int end, int *array)
{
    int middle;

    if (end - begin <= 1)
        return;
    middle = (end + begin) / 2;
    TopDownSplitMerge(array, begin, middle, copy);
    TopDownSplitMerge(array, middle, end, copy);
    TopDownMerge(copy, begin, middle, end, array);
}


void merge_sort(int *array, size_t size)
{
    int *copy;
    size_t i;

    if (array == NULL || size < 2)
        return;
    copy = malloc(sizeof(int) * size);
    if (!copy)
        return;
    i = 0;
    while (i < size)
    {
        copy[i] = array[i];
        i++;
    }
    TopDownSplitMerge(copy, 0, (int)size, array);
    free(copy);
}
",38,1204,475
"#include ""sort.h""


void counting_sort(int *array, size_t size)
{
    int *count = NULL, *out = NULL, max = 0, total = 0;
    size_t i, j;

    if (array == NULL || size < 2)
        return;
    for (i = 0; i < size; i++)
    {
        if (array[i] > max)
            max = array[i];
    }
    count = malloc(sizeof(int) * (max + 1));
    if (!count)
        return;
    j = max;
    for (i = 0; i <= j; i++)
        count[i] = 0;
    for (i = 0; i < size; i++)
        count[array[i]]++;
    for (i = 0; i <= j; i++)
    {
        total += count[i];
        count[i] = total;
    }
    print_array(count, max + 1);
    out = malloc(sizeof(int) * size);
    if (!out)
    {
        free(count);
        return;
    }
    for (i = 0; i < size; i++)
    {
        out[--count[array[i]]] = array[i];
    }
    for (i = 0; i < size; i++)
        array[i] = out[i];
    free(out);
    free(count);
}
",38,1205,363
"#include ""sort.h""

void shell_sort(int *array, size_t size)
{

    int value;
    size_t i, j, gap;

    if (array == NULL || size < 2)
        return;
    gap = 1;
    while (gap < size / 3)
    {
        gap = (gap * 3) + 1;
    }
    while (gap > 0)
    {
        i = gap;
        while (i < size)
        {
            value = array[i];
            j = i;
            while (j > gap - 1 && array[j - gap] >= value)
            {
                array[j] = array[j - gap];
                j -= gap;
            }
            array[j] = value;
            i++;
        }
        gap = (gap - 1) / 3;
        print_array(array, size);
    }
}
",38,1206,236
"#include ""sort.h""


void countingSort(int *array, int radix, int exp, size_t size)
{
    int bucketIdx, *bucket = NULL, *out = NULL, i;
    size_t j;

    bucket = malloc(sizeof(int) * radix);
    if (!bucket)
        return;
    i = 0;
    while (i < radix)
    {
        bucket[i] = 0;
        i++;
    }
    for (j = 0; j < size; j++)
    {
        bucketIdx = (array[j] / exp) % radix;
        bucket[bucketIdx]++;
    }
    i = 1;
    while (i < radix)
    {
        bucket[i] += bucket[i - 1];
        i++;
    }
    out = malloc(sizeof(int) * size);
    if (!out)
    {
        free(bucket);
        return;
    }
    i = size - 1;
    while (i >= 0)
    {
        bucketIdx = (array[i] / exp) % radix;
        out[--bucket[bucketIdx]] = array[i];
        i--;
    }
    for (j = 0; j < size; j++)
        array[j] = out[j];
    free(bucket);
    free(out);
}


void radix_sort(int *array, size_t size)
{
    int max, exp;
    size_t i = 0;

    if (array == NULL || size < 2)
        return;
    max = array[0];
    while (i < size)
    {
        if (array[i] > max)
            max = array[i];
        i++;
    }
    exp = 1;
    while (max / exp >= 1)
    {
        countingSort(array, 10, exp, size);
        exp *= 10;
        print_array(array, size);
    }
}
",38,1207,506
"#include ""sort.h""


void insertion_sort_list(listint_t **list)
{

    listint_t *p, *c, *aux;

    if (list == NULL || *list == NULL || (*list)->next == NULL)
        return;
    c = (*list)->next;
    aux = (*list)->next;
    while (aux != NULL)
    {
        aux = aux->next;
        while (c->prev != NULL)
        {
            if (c->prev->n > c->n)
            {
                p = c->prev;
                p->next = c->next;
                if (c->next)
                    c->next->prev = p;
                c->next = p;
                c->prev = p->prev;
                if (p->prev)
                    p->prev->next = c;
                p->prev = c;
                if (p == *list)
                    *list = c;
                print_list(*list);
            }
            else
                break;
        }
        c = aux;
    }
}
",38,1208,267
"#include ""sort.h""

int partition(int *array, int lo, int hi, size_t size)
{
    int i, j, pivot, tmp;

    pivot = array[hi];
    i = lo;
    j = lo;
    while (j < hi)
    {
        if (array[j] <= pivot)
        {
            if (i != j)
            {
                tmp = array[i];
                array[i] = array[j];
                array[j] = tmp;
                print_array(array, size);
            }
            i++;

        }
        j++;
    }
    if (i != hi)
    {
        tmp = array[i];
        array[i] = array[hi];
        array[hi] = tmp;
        print_array(array, size);
    }
    return (i);
}

void quicksort(int *array, int lo, int hi, size_t size)
{
    int q;

    if (lo < hi)
    {
        q = partition(array, lo, hi, size);
        quicksort(array, lo, q - 1, size);
        quicksort(array, q + 1, hi, size);
    }

}


void quick_sort(int *array, size_t size)
{
    if (array == NULL || size < 2)
        return;
    quicksort(array, 0, size - 1, size);
}
",38,1209,361
"typedef struct elemento{
    char nome;
    int agilidade;
    struct elemento* prox;
    struct elemento* ant;
}TipoElemento;

typedef struct listaCircular{
    TipoElemento* primeiro;
    int tamanho;
}TipoLista;

void iniciarLista(TipoLista* l){
    l->primeiro = NULL;
    l->tamanho = 0;
}

void inserirFim(TipoLista* l, char nome, int agilidade){
    TipoElemento* novoElemento = (TipoElemento*)malloc(sizeof(TipoElemento));
    novoElemento->nome = nome;
    novoElemento->agilidade = agilidade;

    if(l->tamanho == 0){
        novoElemento->prox = novoElemento;
        novoElemento->ant = novoElemento;
        l->primeiro = novoElemento;
        l->tamanho++;
    }else{
        novoElemento->prox = l->primeiro;
        novoElemento->ant = l->primeiro->ant;
        l->primeiro->ant->prox = novoElemento;
        l->primeiro->ant = novoElemento;
        l->tamanho++;
    }
}

int existeNaLista(TipoLista *l, char nome){
  int contador = l->tamanho;

  if(contador == 0)
    return 1;

  TipoElemento *p = l->primeiro;

  while(contador != 0)
  {
    if(p->nome == nome)
      return 2;

    p = p->prox;
    contador--;
  }
  return 1;
}

int existeNaListaII(TipoLista *l, char nome)
{
  int contador = l->tamanho;

  if(contador == 0)
    return 2;

  TipoElemento *p = l->primeiro;

  while(contador != 0)
  {
    if(p->nome == nome)
      return 1;

    p = p->prox;
    contador--;
  }
  return 3;
}

void imprimeLista(TipoLista* l){
  TipoElemento *aux = l->primeiro;
  int cont = 0;

  while(cont != l->tamanho){
    if(cont == 0)
      printf(""| "");
    
    printf(""soldado: %c "", aux->nome);
    aux = aux->prox;
    cont++;
    
    if(cont != l->tamanho)
      printf(""-> "");
    
    else
      printf(""|"");
  }
}


void sortear(TipoLista *l, char nome){
  int rodada = 1;
  char nomeAux = nome;

  while(l->tamanho != 1){

    int contador = rand() % 10;
    int contadorAux = contador;

    TipoElemento *p = l->primeiro;

    printf(""-> rodada %d: soldado %c, contagem %d\n"", rodada, nomeAux, contador);

    while(p->nome != nomeAux){
      p = p->prox;
    }
    while(contadorAux != 0){
      p = p->prox;
      contadorAux--;
      nomeAux = p->nome;
    }

    imprimeLista(l);
    printf(""\nremovido: soldado %c\n"", nomeAux);

    if(p == l->primeiro){
      l->primeiro = p->prox;
    }
    nomeAux = p->prox->nome;
    p->ant->prox = p->prox;
    p->prox->ant = p->ant;
    p = NULL;
    free(p);
    l->tamanho--;
    rodada++;

  }
  TipoElemento *n = l->primeiro;
  if(n->agilidade < 7)
    printf(""soldado %c escolhido - ele nao tem agilidade suficiente -> vamos morrer!!"", n->nome);
  else
    printf(""soldado %c escolhido e vai nos salvar!"",n->nome);

}

int main(){

    int op;
    int agilidade;
    int existe;
    char nome;

    TipoLista lista;
    iniciarLista(&lista);

    scanf(""%d"", &op);

    while(op==1){
        scanf("" %c %d"", &nome, &agilidade);
        existe = existeNaLista(&lista, nome);
        
        if(existe == 1)
           inserirFim(&lista, nome, agilidade);
        
        else
            printf(""soldado nao pode ser inserido duas vezes\n"");
        
        scanf(""%d"", &op);
    }

    if(op == 2){
        scanf("" %c"", &nome);
        existe = existeNaListaII(&lista, nome); 
        
        if(existe == 1){
            printf(""|| sorteio iniciado ||\n"");
            sortear(&lista, nome);
        }
        else{
            if(existe == 2)
                printf(""grupo vazio"");
            
            else
                printf(""soldado nao pertence ao grupo"");
        }
    }
    return 0;
}",39,1210,1402
"void bresenham1(int x1, int y1, int x2, int y2){        
        int slope;
        int dx, dy, incE, incNE, d, x, y; 
        if (x1 > x2 && y1 > y2){
            bresenham1(x2, y2, x1, y1);
             return;
        }        
        dx = x2 - x1;
        dy = y2 - y1;
    
        if (dy < 0){            
            slope = -1;
            dy = -dy;
        }
        else{            
           slope = 1;
        }
  
        incE = 2 * dy;
        incNE = 2 * dy - 2 * dx;
        d = 2 * dy - dx;
        y = y1;
        
    printf(""dx = %d\n"", dx);
    printf(""dy = %d\n"",dy);
    printf(""2dy = %d\n"",incE);
    printf(""2dy-2dx %d\n"",incNE);

    int tam;
    if (x2 - x1 > 0){
        tam = x2 - x1;
    }
    else if(x2-x1==0){
        tam = y2-y1;
    }
    else{
        tam = -(x2 - x1);
    }

    int vecX[tam];
    int vecY[tam];
    int vecPk[tam];
    
    int i =0;
        
        
        if(x2-x1 == 0){
            while(y1 < y2){
                if (d < 0){
                  d = d + incE;
                }
                else{
                  d = d + incNE;
                  x = x + slope;
                }
                
                vecPk[i] = d;
                vecX[i] = x1;
                vecY[i] = y1;
                i++;
                y1++;
            }
            
        }else{
            while(x1 < x2){
                if (d < 0){
                  d = d + incE;
                }
                else{
                  d = d + incNE;
                  y = y + slope;
                }
                
            vecPk[i] = d;
            vecX[i] = x1;
            vecY[i] = y;
            i++;
            x1++;
            }
        }
        
    printf(""X  | "");
    for (int i = 0; i < tam; i++)
    {
        printf(""%d "", vecX[i]);
    }
    printf(""\n"");

    printf(""Y  | "");
    for (int i = 0; i < tam; i++)
    {
        printf(""%d "", vecY[i]);
    }
    printf(""\n"");

    printf(""Pk | "");
    for (int i = 0; i < tam; i++)
    {
        printf(""%d "", vecPk[i]);
    }
    printf(""\n"");
 }

void imprime(int *vec, int tam)
{
    for (int i = 0; i < tam; i++)
    {
        printf(""%d"", vec[i]);
    }
}

int main(void)
{
    bresenham1(30,5,30,15);
    return 0;
}
",39,1211,846
"float tx = 0.0;
float ty = 0.0;
float theta = 5.0;

void circulo()
{
  int i;
  float angulo = 0.0;
  glBegin(GL_POLYGON);
  for (i = 0; i <= 8; i++)
  {
    angulo = 2 * M_PI * i / 8;
    glVertex2f(0.125 * cos(angulo), 0.125 * sin(angulo));
  }
  glEnd();

}

void quadrado(float x, float y)
{
  glBegin(GL_POLYGON);
  glVertex2f(-0.2 + x, 0.2 + y);
  glVertex2f(0.2 + x, 0.2 + y);
  glVertex2f(0.2 + x, -0.2 + y);
  glVertex2f(-0.2 + x, -0.2 + y);
  glEnd();
}

void retangulo()
{
  glBegin(GL_POLYGON);
  glVertex2f(-0.4, -0.4);
  glEnd();
}

void display_function()
{
  glClearColor(0, 0, 0, 0);
  glClear(GL_COLOR_BUFFER_BIT);
  glLoadIdentity();

  glPushMatrix();
    glTranslatef(-0.35+tx, 0+ty, 0.0);
    glRotatef(theta, 0.0, 0.0, 1.0);
    glColor3f(1.0, 1.0, 1.0);
    circulo();
  glPopMatrix();

  glPushMatrix();
    glTranslatef(0.35+tx, 0+ty, 0.0);
    glRotatef(theta, 0.0, 0.0, 1.0);
    glColor3f(1.0, 1.0, 0);
    circulo();
  glPopMatrix();

  glPushMatrix();
    glTranslatef(0.0+tx, 0.32+ty, 0);
    glColor3f(0.0, 1.0, 0.0);
    glRectf(-0.4, 0.2, 0.4, -0.2);
  glPopMatrix();

  glFlush();
}

void tecladoEspecial(int tecla, int x, int y)
{
  switch (tecla)
  {
  case GLUT_KEY_RIGHT:
    tx += 0.05;
    theta -= 8.0;
    break;
  case GLUT_KEY_LEFT:
    tx -= 0.05;
    theta += 8.0;
    break;
  case GLUT_KEY_UP:
    ty += 0.05;
    break;
  case GLUT_KEY_DOWN:
    ty -= 0.05;
    break;
  default:
    break;
  }
  glutPostRedisplay();
}

void init()
{
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glColor3f(1.0, 1.0, 1.0);
  glMatrixMode(GL_MODELVIEW);
  
}

int main(int argc, char **argv)
{
  glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
  glutInitWindowPosition(50, 100);
  glutInitWindowSize(400, 400);
  glutInit(&argc, argv);
  glutCreateWindow(""TransformaÃ§Ãµes GeomÃ©tricas - TranslaÃ§Ã£o"");
  init();
  glutDisplayFunc(display_function);
  glutSpecialFunc(tecladoEspecial);
  glutMainLoop();
  return 0;
}",39,1212,1005
"float tx = 0.0;
float ty = 0.0;
float theta = 5.0;
float thetaBraco = 1.0;
float thetaPerna = 1.0;

void circulo()
{
  int i;
  float angulo = 0.0;
  glBegin(GL_POLYGON);
  for (i = 0; i <= 6; i++)
  {
    angulo = 2 * M_PI * i / 6;
    glVertex2f(0.04 * cos(angulo), 0.04 * sin(angulo));
  }
  glEnd();
}

void quadrado(float x, float y)
{
  glBegin(GL_POLYGON);
  glVertex2f(-0.2 + x, 0.8 + y);
  glVertex2f(-0.4 + x, 0.6 + y);
  glVertex2f(0.2 + x, 0.8 + y);
  glVertex2f(0.4+ x, 0.6 + y);
  glEnd();
}

void triangulo(float x1, float y1, float x2, float y2, float x3, float y3)
{
  glBegin(GL_TRIANGLES);
    glVertex2f(x1,y1);
    glVertex2f(x2,y2);
    glVertex2f(x3,y3);
  glEnd();
}

void retangulo()
{
  glBegin(GL_POLYGON);
  glVertex2f(-0.4, -0.4);
  glEnd();
}

void display_function()
{
  glClearColor(0, 0, 0, 0);
  glClear(GL_COLOR_BUFFER_BIT);
  glLoadIdentity();

  
  glPushMatrix();
    
    glColor3f(1.0, 1.0, 1.0);
    glRectf(-0.1, 0.8, 0.1, 0.6);
  glPopMatrix();

  
  glPushMatrix();
    glTranslatef(-0.06 , 0.75 , 0.0);
    
    glColor3f(1.0, 0, 0);
    circulo();
  glPopMatrix();

  
  glPushMatrix();
    glTranslatef(0.06, 0.75, 0.0);
    
    glColor3f(1.0, 0, 0);
    circulo();
  glPopMatrix();

  
  glPushMatrix();
    
    
    glColor3f(0, 0, 1);
    triangulo(0.0,0.73, -0.05,0.68, 0.05,0.68);
  glPopMatrix();

  
  glPushMatrix();
    
    
    glColor3f(1, 0.5, 0.5);
    glRectf(-0.05, 0.64, 0.05, 0.62);
  glPopMatrix();

  
  glPushMatrix();
  glTranslatef(-0.2, 0.45, 0);
  glRotatef(thetaBraco, 0.0, 0.0, 1.0);
  glColor3f(1, 0.1, 1);
  glRectf(-0.4, 0.05, 0.2, -0.05);
  glPopMatrix();

  
  glPushMatrix();
  glTranslatef(0.20, 0.45, 0);
  glRotatef(-thetaBraco, 0.0, 0.0, 1.0);
  glColor3f(1, 0.1, 1);
  glRectf(-0.2, 0.05, 0.4, -0.05);
  glPopMatrix();

  
  glPushMatrix();
    glTranslatef(0.0, 0.2, 0);
    glColor3f(0.0, 1.0, 0.0);
    glRectf(-0.2, 0.4, 0.2, -0.4);
  glPopMatrix();

  
  glPushMatrix();
    glTranslatef(0.1, -0.2, 0);
    glColor3f(0.0, 1.0, 0.0);
    glRotatef(thetaPerna, 0.0, 0.0, 1.0);
    glRectf(-0.05, 0.3, 0.05, -0.3);
  glPopMatrix();

  
  glPushMatrix();
    glTranslatef(-0.1, -0.2, 0);
    glColor3f(0.0, 1.0, 0.0);
    glRotatef(-thetaPerna, 0.0, 0.0, 1.0);
    glRectf(-0.05, 0.3, 0.05, -0.3);
  glPopMatrix();

  glFlush();
}

void tecladoEspecial(int tecla, int x, int y)
{
  switch (tecla)
  {
  case GLUT_KEY_RIGHT:
    printf(""%f\n"", thetaPerna);
    if (thetaPerna > -6.000000)
    {
      thetaPerna -= 7.0;
    }
    break;

  case GLUT_KEY_LEFT:
    printf(""%f\n"", thetaPerna);
    if (thetaPerna <= +84.0000)
    {
      thetaPerna += 7.0;
    }
    break;
  
  case GLUT_KEY_UP:
    printf(""%f\n"", thetaBraco);
    if (thetaBraco >= -84.0000)
    {
      thetaBraco -= 7.0;
    }
    break;
  
  case GLUT_KEY_DOWN:
    printf(""%f\n"", thetaBraco);
    if (thetaBraco < 22.000000)
    {
      thetaBraco += 7.0;
    }
    break;
  
  default:
    break;
  }
  glutPostRedisplay();
}

void init()
{
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glColor3f(1.0, 1.0, 1.0);
  glMatrixMode(GL_MODELVIEW);
  
}

int main(int argc, char **argv)
{
  glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
  glutInitWindowPosition(50, 100);
  glutInitWindowSize(400, 400);
  glutInit(&argc, argv);
  glutCreateWindow(""TransformaÃ§Ãµes GeomÃ©tricas - TranslaÃ§Ã£o"");
  init();
  glutDisplayFunc(display_function);
  glutSpecialFunc(tecladoEspecial);
  glutMainLoop();
  return 0;
}",39,1213,1845
"typedef struct elemento{
    int id;
    struct elemento* prox;
}TipoElemento;

typedef struct fila{
    TipoElemento* primeiro;
    TipoElemento* ultimo;
    int tamanho;
    int tamMod;
}TipoLista;

void iniciarLista(TipoLista* l){
    l->primeiro = NULL;
    l->ultimo = NULL;
    l->tamanho = 0;
    l->tamMod = 0;
}

void remover(TipoLista* l){
    if(l->tamanho == 0){
        printf(""lista vazia\n"");
    }else{
        TipoElemento* aux = l->primeiro;
        l->primeiro = l->primeiro->prox;
        free(aux);
        l->tamanho--;
    }
}

int existeNalista(TipoLista* l, int id){
    TipoElemento* aux = l->primeiro;
    while(aux!=NULL){
        if(aux->id == id){
            return 1;
        }
        aux = aux->prox;
    }
    return 0;
}

void inserir(TipoLista* l, int id){
    TipoElemento* novoElemento = (TipoElemento*)malloc(sizeof(TipoElemento));
    novoElemento->id = id;

    if(existeNalista(l, id) == 1){
        printf(""processo ja esta na fila\n""); 
    }
    else{
        if(l->tamanho == 0){
            l->primeiro = novoElemento;
            l->ultimo = novoElemento;
            novoElemento->prox = NULL;
            l->tamanho++;
            l->tamMod++;
        }else{
            l->ultimo->prox = novoElemento;
            l->ultimo = novoElemento;
            novoElemento->prox = NULL;
            l->tamanho++;
            l->tamMod++;
        }
        
        if(l->tamMod == 3){
            printf(""removendo processo %d em espera a muito tempo...\n"", l->primeiro->id); 
            remover(l);
            l->tamMod = 0;
        }
    }
        
}

void imprimir(TipoLista* l){

    
    if(l->tamanho == 0){
        printf(""lista vazia\n"");
    }

    else{
        TipoElemento* aux = l->primeiro;
        TipoElemento* auxProx = l->primeiro->prox;
        printf(""| "");
        
        while(auxProx){
            printf(""%d -> "", aux->id);
            aux = auxProx;
            if(auxProx==NULL){
                break;
            }
            auxProx = auxProx->prox;
        }
        printf(""%d |\n"", aux->id);
    }
}

int main(){
    int op;
    int IDprocesso;
    TipoLista lista;

    iniciarLista(&lista);
    
    while(op != -1){
        scanf(""%d"", &op);

        if(op == -1){
            break;
        }
        
        if(op == 1){
            scanf(""%d"", &IDprocesso); 
            inserir(&lista, IDprocesso);
        }

        else if(op == 2){
            remover(&lista);
        }

        else if(op == 3){
            imprimir(&lista);
        }

        else{
            printf(""opcao invalida\n"");
            break;
        }
    }
    
    return 0;
}",39,1214,951
"float angulo = 0.5;
float velocidade = 0.0000000;
int opcao = 0;

void init(){
     glClearColor(0.0,0.0,0.0,0.0);
     glEnable(GL_DEPTH_TEST); 
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
     glOrtho(-7.0,7.0,-7.0,7.0,-7.0,7.0);
     glPushMatrix();
}

void desenhaCentro(){
    glPushMatrix();
        glColor3f(1.0,1.0,1.0);
        glutWireSphere(2.0, 20, 20);
    glPopMatrix();
}

void desenhaFolhas(){
    glPushMatrix();
        glColor3f(1.0,0.2,0.2);
        glRotatef(1, 0.0, 0.0, 1.0);
        glRotatef(-90.0, 1.0, 0.0, 0.0);
        glRotatef(angulo,0.0,1.0,0.0);
        glTranslatef(0.0, 0.0, 2.0);
        glutWireCone(1.0, 2.0, 10.0, 10.0);
    glPopMatrix();

    glPushMatrix();
        glColor3f(1.0,0.2,0.2);
        glRotatef(90.0, 0.0, 0.0, 1.0);
        glRotatef(-90.0, 1.0, 0.0, 0.0);
        glRotatef(angulo,0.0,1.0,0.0);
        glTranslatef(0.0, 0.0, 2.0);
        glutWireCone(1.0, 2.0, 10.0, 10.0);
    glPopMatrix();

    glPushMatrix();
        glColor3f(1.0,0.2,0.2);
        glRotatef(-90.0, 0.0, 0.0, 1.0);
        glRotatef(-90.0, 1.0, 0.0, 0.0);
        glRotatef(angulo,0.0,1.0,0.0);
        glTranslatef(0.0, 0.0, 2.0);
        glutWireCone(1.0, 2.0, 10.0, 10.0);
    glPopMatrix();

    glPushMatrix();
        glColor3f(1.0,0.2,0.2);
        glRotatef(-180.0, 0.0, 0.0, 1.0);
        glRotatef(-90.0, 1.0, 0.0, 0.0);
        glRotatef(angulo,0.0,1.0,0.0);
        glTranslatef(0.0, 0.0, 2.0);
        glutWireCone(1.0, 2.0, 10.0, 10.0);
    glPopMatrix();
    
}

void display()
{
    glMatrixMode(GL_MODELVIEW);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();
    glTranslatef(0.0, 0.0, -9.0);

    glPopMatrix();
    glPushMatrix();

    desenhaCentro();
    desenhaFolhas();

    glutSwapBuffers();
}

void anima()
{
    switch (opcao) {
        case 1:
            if(velocidade<0.075013){
                velocidade = velocidade + 0.000001;
                angulo= angulo + velocidade;
                printf(""\n%f\n"", velocidade);
            }else{
                angulo = angulo + velocidade;
            }
            break;
        case 2:
            if(velocidade>0.000000){
                velocidade = velocidade - 0.000001;
                angulo = angulo + velocidade;
            }
            break;

        case 3:
            angulo= angulo + velocidade;
            printf(""\n%f\n"", velocidade);
            break;

        case 4:
            if(velocidade>0.000000){
                angulo = angulo + velocidade;
                printf(""\n%f\n"", velocidade);
            }
            break;
        default:
            break;
    }
    glutPostRedisplay();
}

void rotacoes(int key, int x, int y){
     switch (key){
        case GLUT_KEY_RIGHT :
            opcao = 3;
            velocidade = velocidade + 0.0001;
            break ;
        case GLUT_KEY_LEFT :
            opcao = 4;
            velocidade = velocidade - 0.0001;
            break ;
        default:
           break;
     }
    glutPostRedisplay();
}

void mouse(int botao, int estado, int x, int y)
{
    glutIdleFunc(anima);
    switch (botao)
    {
    case GLUT_LEFT_BUTTON:
        if (estado == GLUT_DOWN){
            opcao = 1;
        }
        break;

    case GLUT_RIGHT_BUTTON:
        if (estado == GLUT_DOWN){
            opcao = 2;
        }
        break;
    default:
        break;
    }
    glutPostRedisplay();
}

int main(int argc, char *argv[])
{
     glutInit(&argc,argv);
     glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);
     glutInitWindowPosition(50,50);
     glutInitWindowSize(600,600);
     glutCreateWindow(""Catavento Animado - OpenGL"");
     glutDisplayFunc(display);
     glutSpecialFunc(rotacoes);
     glutIdleFunc(anima);
     glutMouseFunc(mouse);
     init();
     glutMainLoop();
}",39,1215,1659
"float tx = 0.0;
float ty = 0.0;

void circulo()
{
  int i;
  float angulo = 0.0;
  glBegin(GL_POLYGON);
  for (i = 0; i <= 50; i++)
  {
    angulo = 2 * M_PI * i / 50.0;
    glVertex2f(0.15 * cos(angulo), 0.15 * sin(angulo));
  }
  glEnd();
}

void quadrado(float x, float y){
  glBegin(GL_POLYGON);
    glVertex2f(-0.2+x, 0.2+y);
    glVertex2f(0.2+x, 0.2+y);
    glVertex2f(0.2+x, -0.2+y);
    glVertex2f(-0.2+x, -0.2+y);
  glEnd();
}

void retangulo(){
  glBegin(GL_POLYGON);
  glVertex2f(-0.05, -0.05);
  glVertex2f(0.05, -0.05);
  glVertex2f(0.05, -0.95);
  glVertex2f(-0.05, -0.95);
  glEnd();
}

void display_function()
{
  
  
  
  
  

  
  
  
  glClearColor(0, 0, 0, 0);
  glClear(GL_COLOR_BUFFER_BIT);
  glLoadIdentity();

  glColor3f(1.0, 1.0, 1.0);
  circulo();

  glColor3f(1.0, 1.0, 1.0);
  retangulo();

  glTranslatef(tx, ty, 0.0);
  
  glColor3f(0.5, 1.0, 0.5);
  quadrado(0.3, 0.3);

  glColor3f(1.0, 1.0, 0.0);
  quadrado(-0.3, 0.3);

  glColor3f(1.0, 0.0, 1.0);
  quadrado(0.3, -0.3);

  glColor3f(1.0, 0.0, 0.0);
  quadrado(-0.3, -0.3);

  glFlush();
}

void tecladoEspecial(int tecla, int x, int y)
{
  switch (tecla)
  {
  case GLUT_KEY_RIGHT:
    tx += 0.05;
    break;
  case GLUT_KEY_LEFT:
    tx -= 0.05;
    break;
  case GLUT_KEY_UP:
    ty += 0.05;
    break;
  case GLUT_KEY_DOWN:
    ty -= 0.05;
    break;
  default:
    break;
  }
  glutPostRedisplay();
}

void init()
{
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glColor3f(1.0, 1.0, 1.0);
  glMatrixMode(GL_MODELVIEW);
  
}

int main(int argc, char **argv)
{
  glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
  glutInitWindowPosition(50, 100);
  glutInitWindowSize(400, 400);
  glutInit(&argc, argv);
  glutCreateWindow(""TransformaÃ§Ãµes GeomÃ©tricas - TranslaÃ§Ã£o"");
  init();
  glutDisplayFunc(display_function);
  glutSpecialFunc(tecladoEspecial);
  glutMainLoop();
  return 0;
}",39,1216,1007
"typedef struct struct_node{
    struct struct_node *left;
    struct struct_node *right;
    int key;
}node;

node* createNode(int key){
    node* newElement = (node*)malloc(sizeof(node));
    newElement->key = key;
    newElement->right = NULL;
    newElement->left = NULL;
    return (newElement);
}

node* insert(node* root, int key){
    if(root == NULL){
        return createNode(key);
    }

    if(key < root->key){
        root->left = insert(root->left, key);
    }else if(key > root->key){
        root->right = insert(root->right, key); 
    }

    return root;
}

node* search(node* root, int key){
    if(root == NULL){
        return NULL;
    }

    if (root->key == key)
       return root;
    if (root->key > key)
       return search (root->left, key);
    else
       return search (root->right, key);
}

node* findParent(node *aux, int key_parent){
    if(aux != NULL){
        node *NovoPai = findParent(aux->left, key_parent);
        if(NovoPai == NULL) {
            NovoPai = findParent(aux->right, key_parent);
        }
        return NovoPai;
    }else{
        return NULL;
    }
}

node* searchMinValue(node* root) {
   while (root->left != NULL) {
      root = root->left;
   }
   return root;
}

node* deleteNode(node* root, int key){
    if(root == NULL){
        return root;
    }

    else if(key < root->key){
        root->left = deleteNode(root->left, key);
    }

    else if(key > root->key){
        root->right = deleteNode(root->right, key);
    }

    else{
        
        if(root->left == NULL && root->right == NULL){
            free(root);
            root = NULL;
            return root;
        }

        
        else if(root->left == NULL){
            node* temp = root;
            root = root->right;
            free(temp);
            return root;
        }
        else if(root->right == NULL){
            node* temp = root;
            root = root->left;
            free(temp);
            return root;
        }

        
        else{
            node* temp = searchMinValue(root->right);
            root->key = temp->key;
            root->right = deleteNode(root->right, temp->key);
        }
    }
    return root;
}

void printTree(node* root){
    if(root == NULL){
        return;
    }
    else{
        printTree(root->left);
            printf(""%d "",root->key);
            
            
        printTree(root->right);
    }
}


int main(){

    node *root;
    node *aux;

    int key;
    int cont = 0; 
    int operacoes = 0;
    char opcao;

    scanf(""%d"", &operacoes);

    while(cont < operacoes){
        scanf("" %c"", &opcao);
        
        if(opcao == 'I'){
            scanf(""%d"", &key);
            if(cont == 0){
                root = createNode(key);
            }else{
                insert(root, key);
            }
            cont++;
        }

        else if(opcao == 'B'){
            scanf(""%d"", &key);
            aux = search(root, key);
            if(aux == NULL){
                printf(""N"");
                printf(""\n"");
            }else{
                printf(""S"");
                printf(""\n"");
            }
            cont++;
        }

        else if(opcao == 'M'){
            
            printTree(root);
            printf(""\n"");
            cont++;
        }

        else if(opcao == 'R'){
            
            scanf(""%d"", &key);
            root = deleteNode(root, key);
            cont++;
        }
    }
    return 0;
}
",39,1217,1085
"typedef struct elemento{
    int IDcidade;
    int distancia;
    struct elemento* ant;
    struct elemento* prox;
}TipoElemento;

typedef struct lista_dinamica{
    TipoElemento* primeiro;
    TipoElemento* ultimo;
    int tamanho;
}TipoLista;

void iniciarLista(TipoLista* l){
    l->primeiro = NULL;
    l->ultimo = NULL;
    l->tamanho = 0;
}

int existeNaLista(TipoLista*l, int IDcidade){
    TipoElemento* aux = l->primeiro;
    while(aux!=NULL){
        if(aux->IDcidade == IDcidade){
            return 1;
        }
        aux = aux->prox;
    }

    return 0;
}

void inserir(TipoLista*l , int IDcidade, int distancia){
    TipoElemento* novoElemento = (TipoElemento*)malloc(sizeof(TipoElemento));
    novoElemento->IDcidade = IDcidade;
    novoElemento->distancia = distancia;

    if(l->tamanho == 0){
        l->primeiro = novoElemento;
        l->ultimo = novoElemento;
        novoElemento->prox = NULL;
        novoElemento->ant = NULL;               
    }else{
        l->ultimo->prox = novoElemento;
        novoElemento->ant = l->ultimo;
        l->ultimo = novoElemento;
        novoElemento->prox = NULL;
    }
    l->tamanho++;
}

int jaPercorri(TipoLista*l ,int IDcidade){
    int existe = existeNaLista(l, IDcidade);
    if(existe){
        int somaDistancia = 0;
        int contCidades = 0;
        
        TipoElemento* aux = l->primeiro;
        
        while(aux->IDcidade != IDcidade){
            somaDistancia = somaDistancia + aux->distancia;
            contCidades++;
            aux = aux->prox;
        }

        printf(""estou na cidade %d:\n"", IDcidade);
        printf(""ja percorri %d km, passando por %d cidades"", somaDistancia, contCidades);
        return 1;
    }else{
        printf(""cidade nao existe no percurso"");
        return 0;
    }
}

int faltamPercorrer(TipoLista*l, int IDcidade){
    int existe = existeNaLista(l, IDcidade);
    int Distancia = 0;
    int contCidades=1;
    
    if(existe){
        TipoElemento* aux = l->ultimo;
        
        while(aux->IDcidade != IDcidade){
            Distancia = Distancia + aux->distancia;
            contCidades++;
            aux = aux->ant;
        }
        Distancia = Distancia + aux->distancia;
        aux = aux->ant;

        printf(""estou na cidade %d:\n"", IDcidade);
        printf(""faltam percorrer %d km, passando por %d cidades"", Distancia, contCidades-1);
        return 1;
    }else{
        printf(""cidade nao existe no percurso"");
        return 0;
    }
}

void calculaTrajetoTotal(TipoLista* l){
    int distanciaTotal = 0;
    int contCidades=0;
    TipoElemento* aux = l->primeiro;

    while(aux!=NULL){
        distanciaTotal = distanciaTotal + aux->distancia;
        contCidades++;
        aux = aux->prox;
    }
    printf(""o trajeto total tem %d kms, passando\n"", distanciaTotal);
    printf(""por %d cidades\n"", contCidades);
}

int main(){
    int flag;
    int op = 1;
    int IDcidade;
    int distancia;

    TipoLista lista;
    iniciarLista(&lista);

    while(op==1){
        scanf(""%d"", &op);
        

        
        if(op==1){
            scanf(""%d %d"", &IDcidade, &distancia);
            inserir(&lista, IDcidade, distancia);
        }

            else if(distancia != 0){
                printf(""trajeto invalido"");
                return 0;
            }
            
        
        else if(op==2){
            scanf(""%d"", &IDcidade);
            flag = jaPercorri(&lista, IDcidade);
            if(flag==0){
                break;
            }
        }

        
        else if(op==3){
            scanf(""%d"", &IDcidade);
            flag = faltamPercorrer(&lista, IDcidade);
            if(flag==0){
                break;
            }
        }

        
        else if(op==4){
            calculaTrajetoTotal(&lista);
            break;
        }

        else{
            printf(""opcao invalida"");
            break;
        }
    }
    return 0;    
}",39,1218,1336
"float angulo = 20.0;
float tempoDeAnimacao = 100;

void init(){
     glClearColor(0.0,0.0,0.0,0.0);
     glEnable(GL_DEPTH_TEST); 
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
     glOrtho(-7.0,7.0,-7.0,7.0,-7.0,7.0);
     glPushMatrix();
}

void desenhaCabeca(){
    glPushMatrix();
        glColor3f(1.0,1.0,1.0);
        glRotatef(angulo,0.0,1.0,0.0);
        glutWireSphere(2.0, 20, 20);
    glPopMatrix();
}

void desenhaChapeu(){
    glPushMatrix();
        glColor3f(0.0,1.0,0.0);
        glRotatef(angulo,0.0,1.0,0.0);
        glRotatef(30.0, 0.0, 0.0, 1.0);
        glRotatef(-90.0, 1.0, 0.0, 0.0);
        glTranslatef(0.0, 0.0, 2.0);
        glutWireCone(2.0,4.0,20,20);
        glutWireTorus(0.2, 2.2, 10, 25);
    glPopMatrix();
}

void desenhaNariz(){
    glPushMatrix();
    glColor3f(1.0, 0.0, 0.0);
    glRotatef(angulo,0.0,1.0,0.0);
    glTranslatef(0.0, 0.0, 2.0);
    glutWireSphere(0.5, 20, 20);
    glPopMatrix();
}

void desenhaCabeloEsquerda(){
    glPushMatrix();
        glColor3f(1.0, 0.0, 0.0);
        glRotatef(angulo,0.0,1.0,0.0);
        glTranslatef(-2.5, 0.0, 0.0);
        glutWireSphere(0.5, 10, 10);
    glPopMatrix();

    glPushMatrix();
        glColor3f(1.0, 0.0, 0.0);
        glRotatef(angulo,0.0,1.0,0.0);
        glTranslatef(-2.2, 0.7 , 0.0);
        glutWireSphere(0.5, 10, 10);
    glPopMatrix();

    glPushMatrix();
        glColor3f(1.0, 0.0, 0.0);
        glRotatef(angulo,0.0,1.0,0.0);
        glTranslatef(-2.2, -0.7, 0.0);
        glutWireSphere(0.5, 10, 10);
    glPopMatrix();
}

void desenhaCabeloDireita(){
    glPushMatrix();
        glColor3f(1.0, 0.0, 0.0);
        glRotatef(angulo,0.0,1.0,0.0);
        glTranslatef(2.5, 0.0, 0.0);
        glutWireSphere(0.5, 10, 10);
    glPopMatrix();

    glPushMatrix();
        glColor3f(1.0, 0.0, 0.0);
        glRotatef(angulo,0.0,1.0,0.0);
        glTranslatef(2.2, 0.7 , 0.0);
        glutWireSphere(0.5, 10, 10);
    glPopMatrix();

    glPushMatrix();
        glColor3f(1.0, 0.0, 0.0);
        glRotatef(angulo,0.0,1.0,0.0);
        glTranslatef(2.2, -0.7, 0.0);
        glutWireSphere(0.5, 10, 10);
    glPopMatrix();
}

void display()
{
    glMatrixMode(GL_MODELVIEW);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();
    glTranslatef(0.0, 0.0, -9.0);

    glPopMatrix();
    glPushMatrix();

    desenhaCabeca();
    desenhaChapeu();
    desenhaNariz();
    desenhaCabeloEsquerda();
    desenhaCabeloDireita();

    glutSwapBuffers();
}

void animate(int value)
{
    angulo += 5.0;
    if(angulo > 360.0){
        angulo -= 360.0;
    }
    glutTimerFunc(tempoDeAnimacao, animate, 1);
    glutPostRedisplay();
}

int main(int argc, char *argv[])
{
     glutInit(&argc,argv);
     glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);
     glutInitWindowPosition(50,50);
     glutInitWindowSize(600,600);
     glutCreateWindow(""Palhaco Animado - OpenGL"");
     glutDisplayFunc(display);
     glutTimerFunc(5, animate, 1);
     init();
     glutMainLoop();
}",39,1219,1478
"float up = 0.0;
float right = 0.0;

void point(){
    glColor3f(0.0, 0.0, 1.0); 
    glPointSize(5.0f); 
    glBegin(GL_POINTS);
        glVertex2f(0.0+up,0.0+right);
    glEnd();
}

void desenha()
{
    glClearColor(0, 0, 0, 0); 
    glClear(GL_COLOR_BUFFER_BIT);
    point();
    glFlush();
}


void mouse(int botao, int estado, int x, int y)
{
    float mx = x;
    float my = y;
    float ox = (mx / 200 - 1.0);
    float oy = -(my / 200 - 1.0);

    switch (botao)
    {
    case GLUT_LEFT_BUTTON:
        if (estado == GLUT_DOWN){
            printf(""x = %f, y = %f\n"", ox, oy);
            up = ox;
            right = oy;
            point();
        }
        break;

    default:
        break;
    }
    glutPostRedisplay();
}

int main(int argc, char *argv[])
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowPosition(50, 100);
    glutInitWindowSize(400, 400);

    glutCreateWindow(""Exercicio 01"");
    glutDisplayFunc(desenha);

    glutMouseFunc(mouse);
    glutMainLoop();
    return 0;
}",39,1220,457
"int binsearchv2(int x, int v[], int n);
int binsearch(int x, int v[], int n);
void selection_sort(int a[], int n);
void change(int a[], int b, int c);

int main(){
  int x, r, rv2, n;
  clock_t start, end;
  double time;

  printf(""Size of the array\n"");
  scanf(""%d"", &n);
  int array[n];
  
  for(int i = 0; i < n; i++)
    array[i] = rand() % n+1;
  selection_sort(array, n);
  
  printf(""============================\n"");
  for(int i = 0; i < n; i++)
    printf(""%d "", array[i]);
  printf(""\n============================\n"");
  
  printf(""\nNumber you're looking for: "");
  scanf(""%d"", &x);

  start = clock();
  r = binsearch(x, array, n);
  r == -1 ? printf(""\n%d was not found\n"", x) : printf(""\n%d was found on %d\n"", x, r);
  end = clock();
  time = (double) (end-start)/ CLOCKS_PER_SEC;
  printf(""On an array of %d elements, binsearch takes: %f segs\n"", n, time);

  start = clock();
  rv2 = binsearchv2(x, array, n);
  rv2 == -1 ? printf(""\n%d was not found\n"", x) : printf(""\n%d was found on %d\n"", x, rv2);
  end = clock();
  time = (double) (end-start)/ CLOCKS_PER_SEC;
  printf(""On an array of %d elements, binsearchV2 takes: %f segs\n"", n, time);
}


int binsearch(int x, int v[], int n){
  int low, high, mid;
  
  low = 0;
  high = n-1;
  while(low <= high){
    mid = (low+high) /2;
    if(x < v[mid])
      high = mid - 1;
    else if(x > v[mid])
      low = mid + 1;
    else 
      return mid;
  }
  return -1; 
}



int binsearchv2(int x, int v[], int n){
  int low, high, mid;
  
  low = 0;
  high = n-1;
  while(low < high){
    mid = (low+high)/2;
    if(x < v[mid])
      high = mid-1;
    else
      low = mid+1;
  }

  
  if(v[low-1] == x)
    return low-1;
  else if(v[low] == x)
    return low;
  else if(v[low+1] == x)
    return low+1;
  
  return -1; 
}

void selection_sort(int a[], int n){
  int smallest;
  int k;
  
  for(int i = 0; i < n - 1; i++){
    smallest = a[i];
    k = i;
    for(int j = i+1; j < n; j++)
      if(a[j] < smallest){
    smallest = a[j];
    k = j;
      }
    if(i != k)
      change(a, i, k);
  }
}

void change(int a[], int b, int c){
  int aux = a[b];
  a[b] = a[c];
  a[c] = aux;
}
",40,1221,937
"#define MAXLINE 1000
#define SPACES 8     

int getlinee(void);
void detab(void);

char line[MAXLINE];
char lineS[MAXLINE];

int main (){
  int len;
  extern char lineS[];
  
  while((len = getlinee())  > 0 ){
    detab();
    printf(""%s"", lineS);
  }
}

int getlinee(void){
  int c, i;
  extern char line[];
  
  for(i = 0; i < MAXLINE - 1 && ( c = getchar()) != EOF && c != '\n'; i++)
    line[i] = c;
  if(c == '\n'){
    line[i] = c;
    ++i;
  }  
  line[i] = '\0';
  return i;
}


void detab(void){
  extern char line[];
  extern char lineS[];
  int i, j;
  
  i = j = 0;
  while(line[i] != '\0'){
    if(line[i] == '\t')
      for(int l = 0; l < SPACES; l++){
    lineS[j] = ' ';
    ++j;
      }
    else{
      lineS[j] = line[i];
      ++j;
    }
    ++i;
  }
  lineS[j] = '\0';
}
",40,1222,367
"int get_numbers(int n, int max, int ns[], int i);
void imprime(int ns[]);
int check_number(int n, int ns[], int i);
int valid_array(int ns[], int x);
void quicksort(int vector[], int inf, int sup);
void change(int vector[], int i, int j);
  
int main(){
  int t, x;

  scanf(""%d"", &t);

  for(int i = 1; i <= t; i++){
    int numbers[9] = {0};
    
    scanf(""%d"", &x);
    
    if(x < 10)
      printf(""%d\n"", x);
      else{
    if(get_numbers(x, 9, numbers, 0)){
      quicksort(numbers, 0, 9);
      imprime(numbers);
    }
    else
      printf(""-%d\n"", 1);
      }
  }
 
}



int get_numbers(int n, int max, int ns[], int i){
  int r = n - max;
  int check;

  if(i == 10)
    return 0;

  if(r < 10 && check_number(r, ns, i)){
    ns[i] = max;
    i++;
    if(check_number(r, ns, i)){
    ns[i] = r;
    return 1;
      }
    else{
      check = get_numbers(r, max-1, ns, i);
    }
  }
  else{
    ns[i] = max;
    i++;
    check = get_numbers(r, max-1, ns, i);
  }
  return (max == 9)? valid_array(ns, n): check;
}


int check_number(int n, int ns[], int i){
  for(int j = 0; j <= i; j++)
    if( n == ns[j])
      return 0;
  return 1;
}



int valid_array(int ns[], int x){
  int sum;

  sum = 0;
  for(int i = 0; i < 9; i++)
    sum += ns[i];
  return (sum == x)? 1 : 0;
}


void imprime(int ns[]){
  for(int i = 0; i < 9; i++)
    if(ns[i] != 0)
      printf(""%d"", ns[i]);
  printf(""\n"");
}



void change(int vector[], int i, int j){
  int aux;
  
  aux = vector[i];
  vector[i] = vector[j];
  vector[j] = aux;
}

void quicksort(int vector[], int inf, int sup){
  int i, j, x;
  
  i = inf;
  j = sup;
  x = vector[(i+j)/2];
  
  while(i <= j){ 
      while(vector[i] < x)    
    i++;
      while(vector[j] > x)  
    j--;
      if(i<=j){
    change(vector, i, j);
    i++;
    j--;
      }
  }
  
  if(inf < j)
    quicksort(vector, inf, j);
  if(i < sup)
    quicksort(vector, i, sup);
}
",40,1223,858
"#define MAXLINE 10000     

int max;                  
char line [MAXLINE];      
char longest [MAXLINE];   

int getlinee(void);
void copy(void);


int main(){
  int len;
  extern int max;
  extern char longest [];

  max = 0;
  while((len = getlinee()) > 0)
    if(len > max){
      max = len;
      copy();
    }
  if(max > 0)
    printf(""%s\n"", longest);
  return 0;
}


int getlinee(void){
  int c, i;
  extern char line[];

  for(i = 0; i < MAXLINE -1
    && (c = getchar()) != EOF && c != '\n'; ++i)
    line[i] = c;

  if (c == '\n'){
    line[i] = c;
    ++i;
  }
  line[i] = '\0';
  return i;
}


void copy(void){
  int i;
  extern char line[], longest[];

  i = 0;
  while((longest[i] = line[i]) != '\0')
    ++i;
}
",40,1224,314
"#define MAXLINE 1000

int getlinee(char line[]);
void escape(char s[], char t[]);
void inverse_escape(char s[], char t[]);

int main(){
  char s[MAXLINE];
  char t[MAXLINE];
  char r[MAXLINE];
  int len = getlinee(s);

  escape(s, t);
  inverse_escape(t, r);
  printf(""word received:%s"", s);
  printf(""after escape:%s\n"", t);
  printf(""inverse_escape:%s"", r);
}



int getlinee(char line[]){
  int c, i;
  
  for(i = 0; i < MAXLINE - 1 && ( c = getchar()) != EOF && c != '\n'; i++)
    line[i] = c;
  if(c == '\n'){
    line[i] = c;
    ++i;
  }  
  line[i] = '\0';
  return i;
}


void escape(char s[], char t[]){
  int i, j;

  j = 0;
  for(i = 0; s[i] != '\0'; i++)
    switch(s[i]){
    case '\n':
      t[j++] = '\\';
      t[j++] = 'n';
      break;
    case '\t':
      t[j++] = '\\';
      t[j++] = 't';
      break;
    case '\a':
      
      t[j++] = '\\';
      t[j++] = 'a';
      break;
    case '\b':
      t[j++] = '\\';
      t[j++] = 'b';
      break;
    case '\f':
      t[j++] = '\\';
      t[j++] = 'f';
      break;
    case '\r':
      t[j++] = '\\';
      t[j++] = 'r';
      break;
    case '\v':
      t[j++] = '\\';
      t[j++] = 'v';
      break;
    case '\\':
      t[j++] = '\\';
      t[j++] = '\\';
      break;
    case '\?':
      t[j++] = '\\';
      t[j++] = '?';
      break;
    case '\'':
      t[j++] = '\\';
      t[j++] = '\'';
      break;
    case '\""':
      t[j++] = '\\';
      t[j++] ='\""';
      break;
    default:
      t[j++] = s[i];
      break;
    }
  t[j] = '\0';
}


void inverse_escape(char s[], char t[]){
  int i, j;
  
  j = 0;
  for(i = 0; s[i] != '\0'; i++)
    switch(s[i]){
    case '\\':
      switch(s[++i]){
      case 'n':
    t[j++] = '\n';
    break;
      case 't':
    t[j++] = '\t';
    break;
      case 'a':
    t[j++] = '\a';
    break;
      case 'b':
    t[j++] = '\b';
    break;
      case 'f':
    t[j++] = '\f';
    break;
      case 'r':
    t[j++] = '\r';
    break;
      case 'v':
    t[j++] = '\v';
    break;
      case '\\':
    t[j++] = '\\';
    break;
      case '?':
    t[j++] = '\?';
    break;
      case '\'':
    t[j++] = '\'';
    break;
      case '""':
    t[j++] = '\""';
    break;
      }
      break;
    default:
      t[j++] = s[i];
      break;
    }
  t[j] = '\0';
}
",40,1225,1049
"int main(){
  int n, aux;
  int cont = 0;
  
  scanf(""%d"", &n);
  
  if(n < 1 || n > 1000000)
    return 0;


  while(n>0){
    
    if(n - 5  >= 0)
      aux = 5;

    else if(n - 4 >= 0)
      aux = 4;

    else if(n - 3 >= 0)
      aux = 3;

    else if(n - 2 >= 0)
      aux = 2;

    else if(n - 1 >= 0)
      aux = 1;
    

    n -= aux;
    cont++;
  }

  printf(""%d\n"", cont);
  
}
",40,1226,206
"void change(int vector[],int i, int j);
void quicksort(int vector[],int inf, int sup);

int main(){
  int x[4];
  int a,b,c;
  
  for(int i = 0; i < 4; i++)
    scanf(""%d"", &x[i]);

  quicksort(x, 0, 3);

  b = (x[2] - x[1] + x[0]) / 2;
  a = x[2] - b;
  c = x[0]- b;
  printf(""%d %d %d\n"", a, b, c);

}

void change(int vector[], int i, int j){
  int aux;
  
  aux = vector[i];
  vector[i] = vector[j];
  vector[j] = aux;
}


void quicksort(int vector[], int inf, int sup){
  int i, j, x;
  
  i = inf;
  j = sup;
  x = vector[(i+j)/2];
  
  while(i <= j){ 
      while(vector[i] < x)    
    i++;
      while(vector[j] > x)  
    j--;
      if(i<=j){
    change(vector, i, j);
    i++;
    j--;
      }
  }
  
  if(inf < j)
    quicksort(vector, inf, j);
  if(i < sup)
    quicksort(vector, i, sup);
}

",40,1227,386
"#define IN 1
#define OUT 0
main(){
  int c, state, aux, cont;
  int wlong[10];
  state = OUT;
  cont  = aux = 0;
  for(int i = 0; i < 10; i++)
    wlong[i] = 0;
  
  while((c = getchar()) != EOF){
    if(c == 11 || c == 32 || c == 10){
      state = OUT;
      if(cont < 10){
    aux = cont - 1;
    wlong[aux]++;
      }
      else
    wlong[9]++;
    }
    else {
      if(state == OUT){
      state = IN;
      cont = 0;
      }
      cont++;
    }
  }


  aux = 0;
  int e = 9;
  for(int i = 0; i < 5; i++){
    if(wlong[i] > wlong[e] && wlong[i] > aux)
      aux = wlong[i];
    else if(wlong[e] > aux)
      aux = wlong[e];
    e--;
  }
  
  while(aux >= 1){
    for(int i = 0; i < 10; i++){
      if(wlong[i] >= aux)
    printf(""  | "");
      else
    printf(""    "");
    }
    printf(""\n"");
    aux--;
  }
  
  cont = 0;
  while(cont < 10){
    int r = cont+1;
    if(cont < 9)
      printf("" %2d "", r);
    else
      printf("" +%d \n"", cont);
    cont++;
  }
  
}
",40,1228,449
"void change(char s[], int i, int j);

int main(){
  int n, t;
  
  scanf(""%d"", &n);
  scanf(""%d"", &t);

  char s[n];
  
  if(n < 1 || t < 1
     || n > 50 || t > 50)
    return 0;
  
  scanf(""%s"", s);
  for(int j = 1; j <=t; j++)
    for(int i = 0; i < n; i++)
      if(i+1 < n)
    if(s[i] == 'B' && s[i+1] == 'G'){
      change(s, i, i+1);
      i = i+1;
    }
  printf(""%s\n"", s);
}

void change(char s[], int i, int j){
  char aux = s[i];
  s[i] = s[j];
  s[j] = aux;
}
",40,1229,250
"int htoi(char s[]);
int hexa_to_int(char s);
int get_decimal(int hexa[], int cont);
int eleva(int base, int exp);

void main(){
  char s[100];
  int res;
  
  scanf(""%s"", s);
  res = htoi(s);
  if(res >= 0)
    printf(""%d\n"",res);
  else
    printf(""Invalid Input\n"");
}


int htoi(char s[]){
  int cont = 0;

  if(s[0] != '0' || (s[1] != 'x' && s[1] != 'X'))
     return -1;
    
  for(int i = 2; (s[i]>= '0' && s[i] <= '9') || (s[i] >= 'a' && s[i] <= 'f')
    || (s[i] >= 'A' && s[i] <= 'F'); i++, cont++)
    ;
  
  int hexa[cont];
  
  for(int i = 2; (s[i]>= '0' && s[i] <= '9') || (s[i] >= 'a' && s[i] <= 'f')
    || (s[i] >= 'A' && s[i] <= 'F'); i++)
    hexa[i-2] = hexa_to_int(s[i]);
  
  return get_decimal(hexa, cont);
}


int hexa_to_int(char s){
  if(s == 'a' || s == 'A')
    return 10;
  if(s == 'b' || s == 'B')
    return 11;
  if(s == 'c' || s == 'C')
    return 12;
  if(s == 'd' || s == 'D')
    return 13;
  if(s == 'e' || s == 'E')
    return 14;
  if(s == 'f' || s == 'F')
    return 15;
  return s - '0';
}


int get_decimal(int hexa[], int cont){
  int res = 0;
  int exp = cont-1;
  
  for(int i = 0; i < cont; i++){
    res += hexa[i] * eleva(16, exp--);
  }
  return res;
}


int eleva(int base, int exp){
  if(exp == 0)
    return 1;
  else
    return base * eleva(base, exp -1);
}
",40,1230,660
"#define MAXLINE 1000 

int getlinee(char line[], int maxline);

int main(){
  int len; 
  int max; 
  char line[MAXLINE];

  max = 0;
  while((len = getlinee(line, MAXLINE))> 0)
    if(len > 80)
      printf(""%s\n"", line);
    
  return 0;
}

int getlinee(char s[], int lim){
  int c, i, j;
  lim = lim - 2;
  for(i = 0; (c = getchar()) != EOF && c != '\n'; i++)
    if(i < lim){
      s[i] = c;
      j = i;
    }
  if(j == lim - 1){
    s[j] = '\n';
    j++;
    s[j] = '\0';
    if(i > 0)
      i++;
  }
  else{
    if(c == '\n'){
      s[i] = c;
      i++;
    }
    s[i] = '\0';
  }
  return i;
}
",40,1231,293
"int main(){
  int n, k, aux, aux2;
  int cont = 0;
  
  scanf(""%d"", &n);
  scanf(""%d"", &k);
  
  if(k < 1 || k > 50 ||n < 1
     || n > 50 || k > n)
    return 0;
 
  for(int i = 1; i <= n; i++){

    if(i <= k){
      scanf(""%d"", &aux);
      if(aux >0)
    cont++;
      else
    break;
    }
    
    else if(i>k){
      scanf(""%d"", &aux2);
      if(aux2 == aux)
    cont++;
    }
    
  }
  
  printf(""%d\n"", cont);
}
",40,1232,202
"int get_numbers(int n, int max, int ns[], int i);
void imprime(int ns[]);
int check_number(int n, int ns[], int i);
int valid_array(int ns[], int x);
void quicksort(int vector[], int inf, int sup);
void change(int vector[], int i, int j);
  
int main(){
  int t, x;

  scanf(""%d"", &t);

  for(int i = 1; i <= t; i++){
    int numbers[9] = {0};
    
    scanf(""%d"", &x);
    
    if(x < 10)
      printf(""%d\n"", x);
    
    else{
      
      if(x > 45)
        printf(""-%d\n"", 1);
      
      else{
    get_numbers(x, 9, numbers, 0);
    quicksort(numbers, 0, 9);
    imprime(numbers);
    }
    }
  }
 
}


int get_numbers(int n, int max, int ns[], int i){
  int r = n - max;
  int check;

  if(i == 10)
    return 0;

  if(r < 10 && check_number(r, ns, i)){
    ns[i] = max;
    i++;
    if(check_number(r, ns, i)){
    ns[i] = r;
    return 1;
      }
    else{
      check = get_numbers(r, max-1, ns, i);
    }
  }
  else{
    ns[i] = max;
    i++;
    check = get_numbers(r, max-1, ns, i);
  }
  return (max == 9)? valid_array(ns, n): check;
}


int check_number(int n, int ns[], int i){
  for(int j = 0; j <= i; j++)
    if( n == ns[j])
      return 0;
  return 1;
}



int valid_array(int ns[], int x){
  int sum;

  sum = 0;
  for(int i = 0; i < 9; i++)
    sum += ns[i];
  return (sum == x)? 1 : 0;
}


void imprime(int ns[]){
  for(int i = 0; i < 9; i++)
    if(ns[i] != 0)
      printf(""%d"", ns[i]);
  printf(""\n"");
}



void change(int vector[], int i, int j){
  int aux;
  
  aux = vector[i];
  vector[i] = vector[j];
  vector[j] = aux;
}

void quicksort(int vector[], int inf, int sup){
  int i, j, x;
  
  i = inf;
  j = sup;
  x = vector[(i+j)/2];
  
  while(i <= j){ 
      while(vector[i] < x)    
    i++;
      while(vector[j] > x)  
    j--;
      if(i<=j){
    change(vector, i, j);
    i++;
    j--;
      }
  }
  
  if(inf < j)
    quicksort(vector, inf, j);
  if(i < sup)
    quicksort(vector, i, sup);
}
",40,1233,872
"main(){
  int c, aux, cont;
  int abcd[28];
  cont  = aux = 0;
  for(int i = 0; i < 28; i++)
    abcd[i] = 0;
  
  while((c = getchar()) != EOF){
    switch(c){
    case 32:
      break;
    case 9:
      break;
    case 10:
      break;
    case 65:
      abcd[0]++;
      break;
    case 66:
      abcd[1]++;
      break;
    case 67:
      abcd[2]++;
      break;
    case 68:
      abcd[3]++;
      break;
    case 69:
      abcd[4]++;
      break;
    case 70:
      abcd[5]++;
      break;
    case 71:
      abcd[6]++;
      break;
    case 72:
      abcd[7]++;
      break;
    case 73:
      abcd[8]++;
      break;
    case 74:
      abcd[9]++;
      break;
    case 75:
      abcd[10]++;
      break;
    case 76:
      abcd[11]++;
      break;
    case 77:
      abcd[12]++;
      break;
    case 78:
      abcd[13]++;
      break;
    case 165:
      abcd[14]++;
      break;
    case 79:
      abcd[15]++;
      break;
    case 80:
      abcd[16]++;
      break;
    case 81:
      abcd[17]++;
      break;
    case 82:
      abcd[18]++;
      break;
    case 83:
      abcd[19]++;
      break;
    case 84:
      abcd[20]++;
      break;
    case 85:
      abcd[21]++;
      break;
    case 86:
      abcd[22]++;
      break;
    case 87:
      abcd[23]++;
      break;
    case 88:
      abcd[24]++;
      break;
    case 89:
      abcd[25]++;
      break;
    case 90:
      abcd[26]++;
      break;
      
    case 97:
      abcd[0]++;
      break;
    case 98:
      abcd[1]++;
      break;
    case 99:
      abcd[2]++;
      break;
    case 100:
      abcd[3]++;
      break;
    case 101:
      abcd[4]++;
      break;
    case 102:
      abcd[5]++;
      break;
    case 103:
      abcd[6]++;
      break;
    case 104:
      abcd[7]++;
      break;
    case 105:
      abcd[8]++;
      break;
    case 106:
      abcd[9]++;
      break;
    case 107:
      abcd[10]++;
      break;
    case 108:
      abcd[11]++;
      break;
    case 109:
      abcd[12]++;
      break;
    case 110:
      abcd[13]++;
      break;
    case 164:
      abcd[14]++;
      break;
    case 111:
      abcd[15]++;
      break;
    case 112:
      abcd[16]++;
      break;
    case 113:
      abcd[17]++;
      break;
    case 114:
      abcd[18]++;
      break;
    case 115:
      abcd[19]++;
      break;
    case 116:
      abcd[20]++;
      break;
    case 117:
      abcd[21]++;
      break;
    case 118:
      abcd[22]++;
      break;
    case 119:
      abcd[23]++;
      break;
    case 120:
      abcd[24]++;
      break;
    case 121:
      abcd[25]++;
      break;
    case 122:
      abcd[26]++;
      break;
    default:
      abcd[27]++;
      break;
    }      
  }
  int r = 97;
  for(int i = 0; i < 28; i++){
    if(i < 27 ){
      if(i != 14)
    printf("" %2c :"", r);
      else{
    printf(""  Ã± :"");
    r= r-1;
      }
      r++;
    }
    else
      printf("" Other characters :"");
    
    for(int l = 0; l < abcd[i]; l++)
      printf( ""-"");    
    printf(""\n"");
  }
  
}
",40,1234,1365
"#define IN 1
#define OUT 0
main(){
  int c, state, aux, cont;
  int wlong[10];
  state = OUT;
  cont = aux = 0;
  for(int i = 0; i < 10; i++)
    wlong[i] = 0;
  
  while((c = getchar()) != EOF){
    if(c == 11 || c == 32 || c == 10){
      state = OUT;
      if(cont < 10){
    aux = cont - 1;
    wlong[aux]++;
      }
      else
    wlong[9]++;
    }
    else {
      if(state == OUT){
      state = IN;
      cont = 0;
      }
      cont++;
    }
  }
  
  for(int i = 0; i < 10; i++){
    int r = i+1;
    if(i < 9)
      printf("" %2d :"", r);
    else
      printf("" +%d :"", i);
    for(int l = 0; l < wlong[i]; l++)
    printf( ""-"");    
    printf(""\n"");
  }
}
",40,1235,304
"#define MAXLINE 1000
#define SPACES 8     

int getlinee(void);
void entab(void);

char line[MAXLINE];
char lineS[MAXLINE];

main(){
  int len;
  extern char lineS[];

  while(getlinee() > 0 ){
    entab();
    printf(""%s"", lineS);
  }
}

int getlinee(void){
  int c, i;
  extern char line[];
  
  for(i = 0; i < MAXLINE - 1 && ( c = getchar()) != EOF && c != '\n'; i++)
    line[i] = c;
  if(c == '\n'){
    line[i] = c;
    ++i;
  }  
  line[i] = '\0';
  return i;
}


void entab(void){
  extern char line[];
  extern char lineS[];
  int i, j, cont, aux;
  
  i = j = 0;
  while(line[i] != '\0'){
    if(line[i] == ' '){
      aux = i;
      cont = 0;
      while(line[aux] == ' '){
    ++cont;
    ++aux;
      }
      if(cont % 8 == 0)
    while(cont > 0){
      lineS[j] = '\t';
      ++j;
      cont = cont - 8;
    }
      else{
    if(cont > 8){
      while(cont >= 8){
        lineS[j] = '\t';
        ++j;
        cont = cont - 8;
      }
      for(int l = 0; l < cont; l++){
        lineS[j] = ' ';
        ++j;
      }
    }
    else
      for(int l = 0; l < cont; l++){
        lineS[j] = ' ';
        ++j;
      }
      }
      i = aux;
    }
    else{
      lineS[j] = line[i];
      ++j;
      ++i;
    }
  }
  lineS[j] = '\0';
}
",40,1236,552
"float cal(float u, int n)
{
    float temp = u;
    for (int i = 1; i < n; i++)
        temp = temp * (u - i);
    return temp;
}
int fact(int n)
{
    int f = 1;
    for (int i = 2; i <= n; i++)
        f *= i;
    return f;
}
int main()
{
    int n,i,j,u;
    float x[90],value;
    float y[90][90],sum=0;
    printf(""\n\n***INPUT***\n\n"");
    printf(""Enter n:\n"");
    scanf(""%d"",&n);
    printf(""Enter the values of x\n"");
    for(i=0;i<n;i++)
        scanf(""%f"",&x[i]);
    printf(""Enter the values of y\n"");
    for(i=0;i<n;i++)
    {
        for(j=0;j<1;j++)
        {
            scanf(""%f"",&y[i][j]);
        }
    }
    for (int i = 1; i < n; i++)
    {
        for (int j = 0; j < n - i; j++)
            y[j][i] = y[j + 1][i - 1] - y[j][i - 1];
    }
    printf(""forward difference table is:\n"");
    for (int i = 0; i < n; i++)
    {
        printf(""%f "",x[i]);
        for (int j = 0; j < n - i; j++)
            printf(""%f "",y[i][j]);
        printf(""\n"");
    }
    printf(""Enter value:\n"");
    scanf(""%f"",&value);
    sum = y[0][0];
    u = (value - x[0]) / (x[1] - x[0]);
    for (int i = 1; i < n; i++) {
        sum = sum + (cal(u, i) * y[0][i]) /
                                 fact(i);
    }
    printf(""\n\n***OUTPUT***\n\n"");
    printf(""Value at %f is %f"",value,sum);
    return 0;
}
",41,1237,570
"# include<stdio.h>
void main()
{
    int a[90],i,n;
    printf(""enter the limit"");
    scanf(""%d"",&n);
    printf(""enter the array elements"");
    for(i=0;i<n;i++)
        scanf(""%d"",&a[i]);
    sorting(a,n);
}
void sorting(int a[],int n)
{
    int i,j,t;
    for(i=0;i<n;i++)
    {
        for(j=0;j<n-i-1;j++)
        {
            if(a[j]>a[j+1])
            {
                t=a[j];
                a[j]=a[j+1];
                a[j+1]=t;
            }
        }

    }
    for(i=0;i<n;i++)
        printf(""%d"",a[i]);

}
",41,1238,234
"# include<stdio.h>
float fun(float x)
{
    float temp;
    temp=1/(1+(x*x));
    return temp;
}
int main()
{
    float x0,xn;
    int n;
    float h,s=0,sume=0,sumo=0;
    printf(""\n\n***INPUT***\n\n"");
    printf(""Enter value of n\n"");
    scanf(""%d"",&n);
    printf(""Enter x0 and xn\n"");
    scanf(""%f%f"",&x0,&xn);
    h=(xn-x0)/n;
    s=fun(x0)+fun(xn);
    for(int i=1;i<n;i++)
    {
        if(i%2==0)
            s=s+2*fun(x0+i*h);
        else
            s=s+4*fun(x0+i*h);
    }
    s=s*h/3;
    printf(""\n\n***OUTPUT***\n\n"");
    printf(""Result is %f"",s);
    return 0;
}
",41,1239,286
"# include<stdio.h>
void main()
{
    int a[90][90],r,c,i,j;
    printf(""enter no. of rows and columns"");
    scanf(""%d%d"",&r,&c);
    printf(""enter array elements"");
    for(i=0;i<r;i++)
    {
        for(j=0;j<c;j++)
        {
            scanf(""%d"",&a[i][j]);
        }
    }
    sumofrows(a,r,c);
    sumofcolumns(a,r,c);

}
void sumofrows(int a[][90],int r,int c)
{
    int i,j,sumofrows;
    for(i=0;i<r;i++)
    {
        sumofrows=0;
        for(j=0;j<c;j++)
        {
            sumofrows=sumofrows+a[i][j];
        }
        printf(""%d"",sumofrows);

    }
}
void sumofcolumns(int a[][90],int r,int c)
{
    int i,j,sumofcolumns;
    for(i=0;i<r;i++)
    {
        sumofcolumns=0;
        for(j=0;j<c;j++)
        {
            sumofcolumns=sumofcolumns+a[j][i];
        }
        printf(""%d"",sumofcolumns);
    }
}
",41,1240,366
"int main()
{
    int m,i,j;
    float Y[20][20]={0},x,res=1.0,sum=0;
    printf(""\n\n\t\t\t\t***INPUT*"");
    printf(""\nEnter the limit:"");
    scanf(""%d"",&m);
    printf(""\nEnter the elements of x and y:"");
    for(i=0;i<m;i++)
    {
        for(j=0;j<2;j++)
            scanf(""%f"",&Y[i][j]);
    }
    printf(""\nThe table entered is:\n"");
     for(i=0;i<m;i++)
    {
        for(j=0;j<2;j++)
            printf(""%0.3f  "",Y[i][j]);
        printf(""\n"");
    }
    printf(""\nEnter the value of x to find y:"");
    scanf(""%f"",&x);
    printf(""\n\n\t\t\t\t***OUTPUT*\n"");
    for(i=0;i<m;i++)
    {
        res=1.0;
        for(j=0;j<m;j++)
        {
            if(j!=i)
                res*=((x-Y[j][0])*1.0)/(Y[i][0]-Y[j][0]);
            else
                continue;
        }
        sum+=res*Y[i][1];
    }
    printf(""The value of y at x=%0.3f is %0.3f"",x,sum);
}
",41,1241,393
"# include<stdio.h>
void main()
{
    int a[90][90],r,c,i,j;
    printf(""enter no. of rows and columns"");
    scanf(""%d%d"",&r,&c);
    printf(""enter array elements"");
    for(i=0;i<r;i++)
    {
        for(j=0;j<c;j++)
        {
            scanf(""%d"",&a[i][j]);
        }
    }

}
void sumofrows(int b[][90],int r,int c)
{
    int sum=0,i,j;
    for(i=0;i<r;i++)
    {
        for(j=0;j<c;j++)
        {
            sum=sum+b[i][j];
        }
        printf(""hggh"");
        printf(""%d"",sum);
    }

}
",41,1242,228
"# include<stdio.h>
void main()
{
    int a[90][90],r,c,i,j;
    printf(""enter no. of rows and columns"");
    scanf(""%d%d"",&r,&c);
    printf(""enter array elements"");
    for(i=0;i<r;i++)
    {
        for(j=0;j<c;j++)
        {
            scanf(""%d"",&a[i][j]);
        }
    }
    sum(a,r,c);
}
void sum(int a[][90],int r,int c)
{
    int i,j,sum=0;
    if(r!=c)
        printf(""not a square matrix"");
    else
    {
        for(i=0;i<r;i++)
        {
            for(j=0;j<c;j++)
            {
                if(j<i)
                    sum=sum+a[i][j];
            }
        }
    }
    printf(""%d"",sum);
}
",41,1243,261
"# include<stdio.h>
# include<math.h>
float function(float);
void main()
{
    float a,b,fa,fb,c,fc;
    do
    {
        printf(""Enter interval\n"");
        scanf(""%f%f"",&a,&b);
        fa=function(a);
        printf(""Value of fa=%f\n"",fa);
        fb=function(b);
        printf(""Value of fb=%f\n"",fb);
    }while(fa*fb>0);
    printf(""next loop"");
    do
    {
        c=(a+b)/2.0;
        printf(""c is now=%f\n"",c);
        fa=function(a);
        fb=function(c);
        printf(""fb becomes=%f\n"",fb);
        if(fa*fb<0)
            b=c;
        else
            a=c;
        printf(""fabs=%f"",fabs(fb));
    }while(fabs(fb)>=0.0001);
    printf(""The root is %f"",c);
}
float function(float x)
{
    float f;
    f=x+cos(x);
    return(f);
}
",41,1244,302
"# include<stdio.h>
void main()
{
    float a,b,c,d,x1,x2,realpart,imaginarypart;
    printf(""\n\n***INPUT***\n\n"");
    printf(""enter coefficients a,b and c \n"");
    scanf(""%f%f%f"",&a,&b,&c);
    d=b*b-4*a*c;
    printf(""\n\n***OUTPUT***\n\n"");
    if(d>0)
    {
        x1=(-b+sqrt(d))/(2*a);
        x2=(-b-sqrt(d))/(2*a);
        printf(""root1 is %f and root2 is %f"",x1,x2);
    }
    else if(d==0)
    {
        x2=(-b)/(2*a);
        x1=x2;
        printf(""equal roots are %f and %f"",x1,x2);
    }
    else
    {
        realpart=-b/(2*a);
        imaginarypart=sqrt(-d)/(2*a);
        printf(""root1=%f+i%f & root2=%f-i%f"",realpart,imaginarypart,realpart,imaginarypart);

    }

}
",41,1245,321
"float u_cal(float u, int n)
{
    float temp = u;
    for (int i = 1; i < n; i++)
        temp = temp * (u + i);
    return temp;
}
int fact(int n)
{
    int f = 1;
    for (int i = 2; i <= n; i++)
        f *= i;
    return f;
}

int main()
{
    int n,i,j;
    float x[90],value,sum=0;
    float y[90][90];
    printf(""\n\n***INPUT***\n\n"");
    printf(""Enter n\n"");
    scanf(""%d"",&n);
    printf(""Enter value of x:\n"");
    for(i=0;i<n;i++)
        scanf(""%f"",&x[i]);
    printf(""Enter value of y:\n"");
    for(i=0;i<n;i++)
    {
        for(j=0;j<1;j++)
        {
            printf(""Enter y[%d][%d] "",i,j);
            scanf(""%f"",&y[i][j]);
        }
    }
    for (int i = 1; i < n; i++) {
        for (int j = n - 1; j >= i; j--)
            y[j][i] = y[j][i - 1] - y[j - 1][i - 1];
    }
    printf(""Backward difference table:\n"");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j <= i; j++)
            printf(""%.2f "",y[i][j]);
        printf(""\n"");
    }
    printf(""Enter value of which you want the answer:\n"");
    scanf(""%f"",&value);
    sum = y[n - 1][0];
    float u = (value - x[n - 1]) / (x[1] - x[0]);
    for (int i = 1; i < n; i++) {
        sum = sum + (u_cal(u, i) * y[n - 1][i]) /
                                     fact(i);
    }
    printf(""\n\n***OUTPUT***\n\n"");
    printf(""\n Value at %f is %f"",value,sum);
    return 0;
}
",41,1246,594
"# include<stdio.h>
int compare(char[],char[]);
void main()
{
    char str1[90],str2[90];
    int z;
    printf(""enter string1"");
    gets(str1);
    printf(""enter string2"");
    gets(str2);
    z=compare(str1,str2);
    if(z==1)
        printf(""equal"");
    else
        printf(""notequal"");
}
int compare(char str1[],char str2[])
{
    int i=0,j=0,f=0;
   while(str1[i]==str2[j])
   {
       if(str1[i]!='\0'||str2[j]!='\0')
       {
           f=1;
           break;
       }
       i++;
       j++;
   }
   if(f==1)
    return 1;
   else
    return 0;
}
",41,1247,237
"# include<stdio.h>
float function(float x)
{
    return(2*x-log10(x)-7);
}
void main()
{
    float a,b,fa,fb,c,fc;
    printf(""\n\n***INPUT***\n\n"");
    do
    {
        printf(""Enter intervals a and b"");
        
        scanf(""%f%f"",&a,&b);
        fa=function(a);
        fb=function(b);
    }while(fa*fb>0);
    int i=-1;
    float d=-1;
    do
    {
        i++;
        if(i!=0)
        d=c;
        fa=function(a);
        fb=function(b);
        c=a-((b-a)/(function(b)-function(a)))*function(a);
        fc=function(c);
        if(fa*fc>0)
            a=c;
        else
            b=c;
    }while(d!=c);
    printf(""\n\n***OUTPUT***\n\n"");
    printf(""The required root is %f \n"",c);
}
",41,1248,289
"# include<stdio.h>
void main()
{
    int ar[90],n,i;
    printf(""enter the limit"");
    scanf(""%d"",&n);
    for(i=0;i<n;i++)
        scanf(""%d"",&ar[i]);
    largest(ar,n);
    sumaverage(ar,n);
    sorting(ar,n);
}
void largest(int ar[],int n)
{
    int max,i;
    max=ar[0];
    for(i=0;i<n;i++)
    {
        if(max<ar[i])
            max=ar[i];
    }
    printf(""%d"",max);
}
void sumaverage(int ar[],int n)
{
    int i,sum=0;
    float avg;
    for(i=0;i<n;i++)
        sum=sum+ ar[i];
        avg=(float)sum/n;
    printf(""%d%f"",sum,avg);
}
void sorting(int a[],int n)
{
    int i,j,t;
    for(i=0;i<n;i++)
    {
        for(j=0;j<n-i-1;j++)
        {
            if(a[j]>a[j+1])
            {
                t=a[j];
                a[j]=a[j+1];
                a[j+1]=t;
            }
        }
    }
    for(i=0;i<n;i++)
    printf(""\n%d"",a[i]);
}
",41,1249,399
"# include<stdio.h>
float func(float x,float y)
{
    return ((x-y)/(x+y));
}
int main()
{
    int i,n;
    float x0,y0,h,xn,k1,k2,k3,k4,x,y,k;
    printf(""\n\n***INPUT***\n\n"");
    printf(""Enter x0,y0,h,xn:\n"");
    scanf(""%f%f%f%f"",&x0,&y0,&h,&xn);
    n=(xn-x0)/h;
    x=x0;
    y=y0;
    for(i=0;i<=n;i++)
    {
        k1=h*func(x,y);
        k2=h*func(x+(h/2),y+(k1/2));
        k3=h*func(x+(h/2),y+(k2/2));
        k4=h*func(x+h,y+k3);
        k=(k1+2*(k2+k3)+k4)/6.0;
        x=x+h;
        y=y+k;
    }
    printf(""\n\n***OUTPUT***\n\n"");
    printf(""Result is:\n"");
    printf(""x=%f y=%f"",x,y);
    return 0;
}
",41,1250,349
"# include<stdio.h>
void sumofdigits(void);
void sumofseries(void);
void perfectno(void);
void exit(void);
void main()
{
    char option;
    printf (""choose the option"");
    scanf(""%c"",&option);
    switch(option)
    {
    case'A':
        sumofdigits();
        break;
    case'B':
        perfectno();
        break;
    case'C':
        sumofseries();
        break;
    case'D':
        exit();
        break;
    }
}
void sumofdigits(void)
{
    int n,sum=0,d;
    printf(""enter a number"");
    scanf(""%d"",&n);
    while(n>0)
    {
        d=n%10;
        sum+=d;
        n=n/10;
    }
    printf(""%d"",sum);
}
void sumofseries(void)
{
    int n,i,sum=0;
    printf(""enter the limit"");
    scanf(""%d"",&n);
    for(i=1;i<=n;i=i+2)
    {
        sum+=i;
    }
    printf(""%d"",sum);
}

void perfectno(void)
{

    int i,sum=0,r;
    printf(""enter the number"");
    scanf(""%d"",&r);
   for(i=1;i<=r/2;i++)
   {
       if(r%i==0)
        sum+=i;

   }
   if(sum==r)
   printf(""perfect no."");
   else
    printf(""not"");

}

void exit(void)
{
    return;
}
",41,1251,432
"struct stack{
     int size;
     char top;
     char *arr;
};

int isFull(struct stack*ptr){
     if(ptr->top == ptr->size-1){
          return 1;
     }
     else{
          return 0;
     }

}

int stackTop(struct stack*sp){
    return sp->arr[sp->top];
}

int isEmpty(struct stack*ptr){
     if(ptr->top == -1){
          return 1;
     }
     else{
          return 0;
     }

}

char push(struct stack*ptr, char val){
    if(isFull(ptr)){
        printf(""Stack Overflow! Cannot push %d to the stack\n"", val);
    }
    else{
        ptr->top++;
        ptr->arr[ptr->top]=val;
        
    }
}

char pop(struct stack*ptr){
    if(isEmpty(ptr)){
        printf(""Stack Underflow! Cannot pop from the stack\n"");
        return -1;
    }
    else{
        int val = ptr->arr[ptr->top];
        ptr->top--;
        return val;
        
    }
}

int precedence(char ch){
     if(ch == '*' || ch=='/'){
          return 3;
     }
     else if(ch=='+' || ch=='-')
          return 2;
     else
          return 0;
     
}
int isOperator(char ch){
     if(ch=='+' || ch=='-' || ch=='*' || ch=='/'){
          return 1;
     }
     else
          return 0;

}

char*infixToPostfix(char* infix){
     struct stack *sp = (struct stack *)malloc(sizeof(struct stack));
     sp->size = 100;
     sp->top = -1;
     sp->arr = (char*)malloc(sp->size * sizeof(char));
     char *postfix = (char *)malloc((strlen(infix)+1)* sizeof(char));
     int i = 0;
     int j = 0;
     while(infix[i]!='\0'){
          if(!isOperator(infix[i])){
               postfix[j]=infix[i];
               j++;
               i++;
          }
          else{
               if(precedence(infix[i])> precedence(stackTop(sp))){
                    push(sp, infix[i]);
                    i++;

               }
               else
               {
                    postfix[j]=pop(sp);
                    j++;

               }
             
          }
          while(!isEmpty(sp)){
               postfix[j]=pop(sp);
               j++;


          }
          postfix[j]='\0';
          return postfix;
     }

}
 

int main(){
     char * infix = ""a-b+t/6"";
     printf(""postfix is %s"", infixToPostfix(infix));

     

  
     return 0;
}
",42,1252,767
"struct Node{
     int data;
     struct Node *next;
};

void linkedListtraversal(struct Node*ptr){
     while(ptr!=NULL){
          printf(""%d\n"", ptr->data);
          ptr=ptr->next;
     }

}

struct Node * deleteByInfo(struct Node*head, int value){
     struct Node*ptr=head;
     struct Node*q=head->next;
     while(q->data!=value){
          ptr=ptr->next;
          q=q->next;
     };
     ptr->next=q->next;
     free(q);
     return head; 
}

int main(){

     struct Node*head,
     *second,
     *third, 
     *fourth, 
     *fifth, 
     *sixth, 
     *seventh;

     head= (struct Node*)malloc(sizeof(struct Node));
     second = (struct Node*)malloc(sizeof(struct Node));
     third = (struct Node *)malloc(sizeof(struct Node));
     fourth = (struct Node*)malloc(sizeof(struct Node));
     fifth = (struct Node*)malloc(sizeof(struct Node));
     sixth = (struct Node*)malloc(sizeof(struct Node));
     seventh = (struct Node*)malloc(sizeof(struct Node));
 
     head->data =100;
     head->next = second;

     second->data= 200;
     second->next= third;

     third->data=300;
     third->next=fourth;

     fourth->data=400;
     fourth->next=fifth;

     fifth->data=500;
     fifth->next= sixth;

     sixth->data=600;
     sixth->next=seventh;

     seventh->data=700;
     seventh->next=NULL;

     linkedListtraversal(head);

     head = deleteByInfo(head, 300);

     linkedListtraversal(head);

}",42,1253,496
"struct stack{
    int size;
    int top;
    int *arr;
};

int isEmpty(struct stack*ptr){
    if(ptr->top== -1){
        printf(""Stack is empty..\n"");
        return 1;
    }
    else{
        return 0;
    }
    
}
int isFull(struct stack*ptr){
    if(ptr->top == ptr->size-1){
        printf(""Stack is Full(overflow)..\n"");
        return 1;
    }
    else{
        
        return 0;
    }
    
}

void push(struct stack*ptr, int val){
    if(isFull(ptr)){
        printf(""Stack Overflow! Cannot push %d to the stack\n"", val);
    }
    else{
        ptr->top++;
        ptr->arr[ptr->top]=val;
        
    }
}

int pop(struct stack*ptr){
    if(isEmpty(ptr)){
        printf(""Stack Underflow! Cannot pop from the stack\n"");
        return -1;
    }
    else{
        int val = ptr->arr[ptr->top];
        ptr->top--;
        return val;
        
        
    }
}


int main()
{
    struct stack *sp=(struct stack*)malloc(sizeof(struct stack));
    sp->size=10;
    sp->top= -1;
    sp->arr= (int *)malloc(sp->size* sizeof(int));
    
    
    printf(""Before pushing, Full: %d\n"", isFull(sp));
    printf(""Before pushing, Empty: %d\n"", isEmpty(sp));
    
    push(sp, 56);
    push(sp, 55);
    push(sp, 54);
    push(sp, 53);
    push(sp, 52);
    push(sp, 51);
    push(sp, 50);
    push(sp, 49);
    push(sp, 48);
    push(sp, 47); 
    push(sp, 46);
    
    printf(""After pushing, Full: %d\n"", isFull(sp));
    printf(""After pushing, Empty: %d\n"", isEmpty(sp));
    
    printf(""Popped %d from the stack\n"", pop(sp)); 
     
    

    return 0;
}",42,1254,592
"void main(){
     int gd=DETECT,gm;
     int x1,x2,x3,y1,y2,y3,nx1,nx2,nx3,ny1,ny2,ny3;
     int xt,yt,;
     
     initgraph(&gd, &gm, ""c:\\tc\\bgi"");
     printf(""\n\t Enter the points of triangle: "");
     setcolor(5);
     scanf(""%d %d %d %d %d %d"", &x1, &x2, &x3, &y1, &y2, &y3);

     line(x1,y1,x2,y2);
     line(x2,y2,x3,y3);
     line(x3,y3,x1,y1);

     printf(""\nEnter Translation factor \n"");
     scanf(""%d %d"", &xt, &yt);

     nx1 = x1 + xt;
     ny1 = y1 + yt;
     nx2 = x2 + xt;
     ny2 = y2 + yt;
     nx3 = x3 + xt;
     ny3 = y3 + yt;

     line(nx1,ny1,nx2,ny2);
     line(nx2,ny2,nx3,ny3);
     line(nx3,ny3,nx1,ny1);

     getch();


}




",42,1255,359
"typedef struct Node 
{
        int data; 
        struct Node *next; 
}node;

struct Node * insert(struct Node *head, int data, int index){
     struct Node * ptr = (struct Node *) malloc(sizeof(struct Node));
     struct Node * p = head;
     int i = 0;
     while (i!=index-1)
     {
          p = p->next;
          i++;
     }
     ptr->data = data;
     ptr->next = p->next;
     p->next = ptr;
     return head;

};

int find(node *ptr, int key)
{
        node *start = ptr;
        ptr =  ptr -> next; 
        
        while(ptr!=start)
        {
                if(ptr->data == key) 
                {
                        return 1;
                }
                ptr = ptr -> next;  
        }
        
        return 0;
}
struct Node * deleteByGivenKey(struct Node * head, int value){
     struct Node *p = head;
     struct Node *q = head->next;

     while ( q->data != value && q->next != NULL)
     {
          p = p->next;
          q = q->next;
     }

     if (q->data == value)
     {
          p->next = q->next;
          free(q);
     }

     return head;
}

void print(node *start,node *ptr)
{
        if(ptr==start)
        {
                return;
        }
        printf(""%d "",ptr->data);
        print(start,ptr->next);
}
int main()
{
        
        node *start,*temp, *Head; 
        start = (node *)malloc(sizeof(node)); 
        temp = start;  
        temp -> next = start; 

 
        printf("" Linked List Example\n"");
        printf(""Choose List operation "");
           
        printf(""1. Insert\n"");
        printf(""2. Delete\n"");
        printf(""3. Print\n"");
        printf(""4. Find\n"");
        printf(""5. EXIT\n"");

        
        

 while(1)
        {
                printf("" Press your choice \n""); 

                int choice;  
                scanf(""%d"",&choice); 

                if(choice==1) 
                {
                        int data;
                        printf(""The Element to be inserted in the list is: "");
                        scanf(""%d"",&data);
                        insert(struct node *start, int data, int index);
                }
                else if(choice==2)
                {
                        int data;
                        printf(""The Element to be deleted from the list is: "");
                        scanf(""%d"",&data);
                        delete(start,data);   
                }
                else if(choice==3)
                {
                        printf(""The list is "");
                        print(start,start->next);   
                        printf(""\n"");
                }
                else if(choice==4)
                {
                        int data;
                        printf(""The Element is to be searched in the list is: "");
                        scanf(""%d"",&data);
                        int status = find(start,data);    
                        if(status)
                        {
                                printf(""Element Found\n"");
                        }
                        else
                        {
                                printf(""Element Not Found\n"");
                        }
                }
        else
                    break;
        }
}

",42,1256,863
"struct stack{
     int size;
     int top;
     int *arr;
};

int isFull(struct stack*ptr){
     if(ptr->top == ptr->size-1){
          return 1;
     }
     else{
          return 0;
     }

}

int isEmpty(struct stack*ptr){
     if(ptr->top == -1){
          return 1;
     }
     else{
          return 0;
     }

}

int main(){

     
     
     
     

     struct stack * s;
     s->size = 80;
     s->top = -1;
     s->arr = (int*)malloc(s->size*sizeof(int));

     
     s->arr[0]= 7;
     s->top++;

     
     if(isEmpty(s)){
          printf(""The stack is empty..\n"");
     }
     else{
          printf(""The stack is not empty..\n"");
     }

  
     return 0;
}",42,1257,255
"struct myArray{
     int totalSize;
     int usedSize;
     int *ptr; 

};

void createArray(struct myArray * a, int tSize, int uSize){

     
     
     
     

     a->totalSize = tSize; 
     a->usedSize = uSize; 
     a->ptr = (int *) malloc(tSize*sizeof(int)); 
}

void show(struct myArray *a){
     for (int i = 0; i < a->usedSize; i++)
     {
          printf(""%d\n"", (a->ptr)[i]);
     }
   
}

void setVal(struct myArray *a){
     int n;
     for (int i = 0; i < a->usedSize; i++)
     {
          printf(""Enter element %d: "", i);
          scanf(""%d"", &n);
          (a->ptr)[i] = n;
     }
   
}

int main(){
     struct myArray marks;
     createArray(&marks, 100, 2);
     
     printf(""We are running setVal function now.\n"");
     setVal(&marks);
     printf(""We are running show function now.\n"");
     show(&marks);

     return 0;
}",42,1258,312
"struct node
{
    int data; 
    struct node *right_child; 
    struct node *left_child; 
};

struct node* search(struct node *root, int x)
{
    if(root==NULL || root->data==x) 
        return root;
    else if(x>root->data) 
        return search(root->right_child, x);
    else 
        return search(root->left_child,x);
}


struct node* find_minimum(struct node *root)
{
    if(root == NULL)
        return NULL;
    else if(root->left_child != NULL) 
        return find_minimum(root->left_child); 

    return root;
}


struct node* new_node(int x)
{
    struct node *p;
    p = malloc(sizeof(struct node));
    p->data = x;
    p->left_child = NULL;
    p->right_child = NULL;

    return p;
}

struct node* insert(struct node *root, int x)
{
    
    if(root==NULL)
        return new_node(x);
    else if(x>root->data) 
        root->right_child = insert(root->right_child, x);
    else 
        root->left_child = insert(root->left_child,x);
    return root;
}


struct node* delete(struct node *root, int x)
{
    
    if(root==NULL)
        return NULL;
    if (x>root->data)
        root->right_child = delete(root->right_child, x);
    else if(x<root->data)
        root->left_child = delete(root->left_child, x);
    else
    {
        
        if(root->left_child==NULL && root->right_child==NULL)
        {
            free(root);
            return NULL;
        }

        
        else if(root->left_child==NULL || root->right_child==NULL)
        {
            struct node *temp;
            if(root->left_child==NULL)
                temp = root->right_child;
            else
                temp = root->left_child;
            free(root);
            return temp;
        }

        
        else
        {
            struct node *temp = find_minimum(root->right_child);
            root->data = temp->data;
            root->right_child = delete(root->right_child, temp->data);
        }
    }
    return root;
}

void inorder(struct node *root)
{
    if(root!=NULL) 
    {
        inorder(root->left_child); 
        printf("" %d "", root->data); 
        inorder(root->right_child);
    }
}

int main()
{
    
    struct node *root;
    root = new_node(20);
    insert(root,5);
    insert(root,1);
    insert(root,15);
    insert(root,9);
    insert(root,7);
    insert(root,12);
    insert(root,30);
    insert(root,25);
    insert(root,40);
    insert(root, 45);
    insert(root, 42);

    inorder(root);
    printf(""\n"");

    root = delete(root, 1);
    

    root = delete(root, 40);
    

    
    

    inorder(root);
    
    printf(""\n"");

    return 0;
}",42,1259,895
"struct Node{
     int data;
     struct Node*left;
     struct Node*right;
     };

struct Node*create(int x){
     struct Node*temp=(struct Node*)malloc(sizeof(struct Node));
     temp->data=x;
     temp->left=NULL;
     temp->right=NULL;
}


void inOrderTraversal(struct Node *root){
     if(root==NULL){
          return;
     }else{
          inOrderTraversal(root->left);
          printf(""%d "",root->data);
          inOrderTraversal(root->right);
          return;
     }
}


struct Node*insert(struct Node*root, int value){
     if(root==NULL){
          root = create(value);
     }
     else if(value<root->data){
          root->left = insert(root->left, value);
     }
     else if (value > root->data){
          root->right = insert(root->right, value);
     }

     
     else{
          printf(""\nValue: %d you enterd is already exist\n"", value);
     }

     return root;
}

struct Node*findMinimum(struct Node*root){
     
     if(root==NULL){
          return NULL;
     }
     else if(root->left!=NULL){
          return findMinimum(root->left);
     }
     return root;
}
struct Node*delete(struct Node*root, int value){
     if(root==NULL){
          printf(""\nValue: %d is not present or the tree is empty!\n"", value);
          return NULL;
     }
     else if(value<root->data){
          root->left = delete(root->left, value);
     }
     else if(value>root->data){
          root->right= delete(root->right, value);
     }
     else{
          
          if(root->left == NULL && root->right==NULL){
               
               free(root);
               return NULL;
          }
          
          else if(root->left ==NULL || root->right==NULL){
               
               
               struct Node*temp=root;
               if(root->left==NULL){
                    root=root->right;
               }
               else{
                    root=root->left;
               }
               free(temp);
               
          }
          
          else{
               
               
               struct Node*temp = findMinimum(root->right);
               root->data=temp->data;
               

               root->right= delete(root->right, temp->data);

          }
     }
     return root;
}

struct Node*verify(struct Node*root, int value){
     if(root==NULL){
          printf(""\nThe Tree maybe Empty or value is not present...\n"");
          return root;
     }
     else if(value<root->data){
          root->left= verify(root->left, value);
     }
     else if(value>root->data)
     {
          root->right= verify(root->right, value);
     }
     else if(root->data==value){
          printf(""\nThe value you mentioned is present in this tree..(value: %d)\n"", root->data);
     }
     else{
          printf(""\nValue you entered is no present..\n"");
     }
     return root;
     
}

int main(){
     
     struct Node*root=NULL;
     
     root=create(10);
     
     insert(root, 5);
     insert(root, 7);
     insert(root, 13);
     insert(root, 1);
     insert(root, 49);
     insert(root, 50);
     insert(root, 35);
     insert(root, 8);
     insert(root, 8);

     delete(root,49);
     delete(root,99);

     verify(root, 70);

     printf(""\n--inOrder Traversal--\n"");
     inOrderTraversal(root);

     return 0;
}",42,1260,1001
"struct Node
{
     int data;
     struct Node *next;
};

void linkedListTreversal(struct Node*ptr){
     while (ptr!=NULL)
     {
          printf(""Element : %d\n"", ptr->data);
          ptr=ptr->next;
     }
     

}

struct Node *reversedList(struct Node *head){
     struct Node *p = head;
     printf(""%d\n"", p->data);
     struct Node *q = head->next;
     printf(""%d\n"", q->data);
     head=head->next;
     printf(""%d\n"", head->data);
     p->next=NULL;
     while (q->next!=NULL)
     {
          

          head=head->next;
          printf(""b\n"");

          
          

          q=q->next;
          printf(""d\n"");

          p=q->next;
          printf(""a\n"");

     }
     return head;
      
     
};


int main(){
     struct Node *head;
     struct Node *second;
     struct Node *third;
     struct Node *fourth;

     head = (struct Node *)malloc(sizeof(struct Node));
     second = (struct Node *)malloc(sizeof(struct Node));
     third = (struct Node *)malloc(sizeof(struct Node));
     fourth = (struct Node *)malloc(sizeof(struct Node));

     head->data=100;
     head->next=second;

     second ->data=200;
     second->next=third;

     third->data=300;
     third->next=fourth;

     fourth->data=400;
     fourth->next=NULL;

     printf(""---Linked list before reverse---\n"");
     linkedListTreversal(head);
     head = reversedList(head);
     printf(""%d\n"", head->data);
     printf(""---Linked list after reverse---\n"");
     linkedListTreversal(head);
 
     return 0;
}



",42,1261,508
"struct stack{
    int size;
    int top;
    int *arr;
};

int isEmpty(struct stack*ptr){
    if(ptr->top== -1){
        printf(""Stack is empty..\n"");
        return 1;
    }
    else{
        return 0;
    }
    
}
int isFull(struct stack*ptr){
    if(ptr->top == ptr->size-1){
        printf(""Stack is Full(overflow)..\n"");
        return 1;
    }
    else{
        
        return 0;
    }
    
}

void push(struct stack*ptr, int val){
    if(isFull(ptr)){
        printf(""Stack Overflow! Cannot push %d to the stack\n"", val);
    }
    else{
        ptr->top++;
        ptr->arr[ptr->top]=val;
        
    }
}

int pop(struct stack*ptr){
    if(isEmpty(ptr)){
        printf(""Stack Underflow! Cannot pop from the stack\n"");
        return -1;
    }
    else{
        int val = ptr->arr[ptr->top];
        ptr->top--;
        return val;
        
        
    }
}

int peek(struct stack* sp, int i){
    int arrayInd = sp->top-i+1;
    if(arrayInd<0){
        printf(""Not a valid position for stack\n"");
        return -1;
        
    }
    else{
        return sp->arr[arrayInd];
    }
}

int stackTop(struct stack*sp){
    return sp->arr[sp->top];
}

int stackBottom(struct stack* sp){
    return sp->arr[0];
}

int main()
{
    struct stack *sp=(struct stack*)malloc(sizeof(struct stack));
    sp->size=10;
    sp->top= -1;
    sp->arr= (int *)malloc(sp->size* sizeof(int));
    
    
    printf(""Before pushing, Full: %d\n"", isFull(sp));
    printf(""Before pushing, Empty: %d\n"", isEmpty(sp));
    
    push(sp, 56);
    push(sp, 55);
    push(sp, 54);
    push(sp, 53);
    push(sp, 52);
    push(sp, 51);
    push(sp, 50);
    push(sp, 49);
    push(sp, 48);
    push(sp, 47); 
    push(sp, 46); 
    
    printf(""After pushing, Full: %d\n"", isFull(sp));
    printf(""After pushing, Empty: %d\n"", isEmpty(sp));
    
    
    printf(""Popped %d from the stack\n"", pop(sp));
     
    
    
    
    
    
    printf(""The top most value of this stack is %d\n"", stackTop(sp));
    
     printf(""The bottom most value of this stack is %d\n"", stackBottom(sp));
    

    return 0;
}",42,1262,775
"struct Node{
     int data;
     struct Node *next;

};
void linkedListTraversal(struct Node*ptr){
     while(ptr!=NULL){
          printf(""Element: %d\n"",ptr->data);
          ptr=ptr->next;
     }
}

int main(){
     
     struct Node *head;
     struct Node *second;
     struct Node *third;
     struct Node *fourth;
 
     
     head = (struct Node *) malloc(sizeof(struct Node));
     second = (struct Node *) malloc(sizeof(struct Node));
     third = (struct Node *) malloc(sizeof(struct Node));
     fourth = (struct Node *) malloc(sizeof(struct Node));


     
     head->data=7;
     head->next=second;

     
     second->data=11;
     second->next=third;

     
     third->data=70;
     third->next=fourth;

     
     fourth->data=22;
     fourth->next=NULL;

     linkedListTraversal(head);

     return 0;
}




",42,1263,273
"int display(int arr[], int n)
{
     for(int i = 0; i < n; i++){
          printf(""%d "",arr[i]);
     }
     printf(""\n"");
}

int indInsertion(int arr[], int size, int element, int capacity, int index){ 
     if(size >= capacity){
          printf(""Insertion failed!"");
          return 0;
     }
     for(int i = size-1; i >= index; i-- ){
          arr[i+1] = arr[i];
     }
     arr[index] = element;
     size +=1;
     display(arr, size);
     
}

int main(){
     int arr[100] = {7, 8, 12, 27, 88};
     int size = 5, element = 40, index = 3;
     display(arr, size);
     indInsertion(arr, size, element, 100, index);
     
 
     return 0;
}",42,1264,250
"struct Node
{
     int data;          
     struct Node *next; 
};
void linkedListTraversal(struct Node *ptr)
{
     while (ptr != NULL)
     {
          printf(""Element: %d\n"", ptr->data);
          ptr = ptr->next;
     }
};


struct Node *insertAtFirst(struct Node *head, int data)
{
     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));
     ptr->next = head;
     ptr->data = data;
     return ptr;
};


struct Node *insertAtIndex(struct Node *head, int data, int index)
{
     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));
     struct Node *p = head;
     int i = 0;
     while (i != index - 1) 
     {
          p = p->next; 
          i++;
     }
     ptr->data = data;
     ptr->next = p->next;
     p->next = ptr;
     return head; 
};


struct Node *insertAtEnd(struct Node *head, int data)
{
     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));
     ptr->data = data;
     struct Node *p = head;
     while (p->next != NULL)
     {
          p = p->next;
     }
     p->next = ptr;
     ptr->next = NULL;
     return head; 
};

struct Node *insertAfterNode(struct Node *head, struct Node *previousNode, int data)
{
     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));
     ptr->data = data;
     ptr->next = previousNode->next;
     previousNode->next = ptr;
     return head; 
};


struct Node *deleteFirst(struct Node *head)
{
     struct Node *ptr = head;
     head = head->next;
     free(ptr);
     return head;
}

struct Node *deleteInBetween(struct Node *head, int index)
{
     struct Node *p = head;
     struct Node *q = head->next;
     for (int i = 0; i < index - 1; i++)
     {
          p = p->next;
          q = q->next;
     }
     p->next = q->next;
     free(q);
     return head;
}

struct Node *deleteLastNode(struct Node *head)
{
     struct Node *p = head;
     struct Node *q = head->next;
     while (q->next != NULL)
     {
          p = p->next;
          q = q->next;
     }
     p->next = NULL;
     free(q);
     return head;
}

struct Node *deleteByGivenKey(struct Node *head, int value)
{
     struct Node *p = head;
     struct Node *q = head->next;

     while (q->data != value && q->next != NULL)
     {
          p = p->next;
          q = q->next;
     }

     if (q->data == value)
     {
          p->next = q->next;
          free(q);
     }

     return head;
}

int main()
{
     
     struct Node *head;
     struct Node *second;
     struct Node *third;
     struct Node *fourth;

     
     head = (struct Node *)malloc(sizeof(struct Node));
     second = (struct Node *)malloc(sizeof(struct Node));
     third = (struct Node *)malloc(sizeof(struct Node));
     fourth = (struct Node *)malloc(sizeof(struct Node));

     
     head->data = 7;
     head->next = second;

     
     second->data = 11;
     second->next = third;

     
     third->data = 70;
     third->next = fourth;

     
     fourth->data = 22;
     fourth->next = NULL;

     printf(""\nLinked list before insertion\n"");
     linkedListTraversal(head);
     
     
     
     head = insertAfterNode(head, second, 45);
     printf(""\nLinked list after insertion\n"");
     linkedListTraversal(head);

     
     
     
     
     

     
     
     
     

     
     
     
     

     
     
     
     

     return 0;
}




",42,1265,1107
"struct InsertionAtGiven
{
     int data;
     struct InsertionAtGiven *next;  
};

void listTravesal(struct InsertionAtGiven*ptr){
     

     while (ptr!=NULL)
     {
          printf(""%d\n"", ptr->data);
          ptr=ptr->next;
     }
   
}

struct InsertionAtGiven* insertAfterValue(struct InsertionAtGiven*head, int info, int value){
     struct InsertionAtGiven*ptr=head;
     struct InsertionAtGiven*q= head->next;
     struct InsertionAtGiven*insert;
     insert->data=value;

     while (ptr->data!=info)
     {
         ptr=ptr->next;
         q=q->next;

     }
     ptr->next=insert;
     insert->next=q;
     return head;
      
}

int main(){
     struct InsertionAtGiven*head,
     *second,
     *third,
     *fourth,
     *fifth;

     head = (struct InsertionAtGiven * )malloc(sizeof(struct InsertionAtGiven));
     second = (struct InsertionAtGiven *)malloc(sizeof(struct InsertionAtGiven));
     third = (struct InsertionAtGiven *)malloc(sizeof( struct InsertionAtGiven));
     fourth = (struct InsertionAtGiven *)malloc(sizeof(struct InsertionAtGiven));
     fifth = (struct InsertionAtGiven *)malloc(sizeof(struct InsertionAtGiven));

     head->data=100;
     head->next=second;

     second->data=200;
     second->next=third;

     third->data=300;
     third->next=fourth;

     fourth->data=400;
     fourth->next=NULL;


     listTravesal(head);

     head = insertAfterValue(head, 200, 550);

     listTravesal(head);

  
     return 0;
}
",42,1266,505
"struct Node
{
     int data;          
     struct Node *next; 
     struct Node *prev; 
};

int Traversal(struct Node *ptr)
{
     while (ptr != NULL)
     {
          printf(""Element: %d\n"", ptr->data);
          ptr = ptr->next;
     }
}


struct Node *insertAtFirst(struct Node *head, int data)
{
     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));
     ptr->next = head;
     ptr->data = data;
     head->prev = ptr;
     ptr->prev = NULL;
     return ptr;
};


struct Node *insertAtIndex(struct Node *head, int data, int index)
{
     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));
     struct Node *p = head;
     int i = 0;
     while (i != index - 1) 
     {
          p = p->next; 
          i++;
     }
     ptr->data = data;
     ptr->next = p->next;
     p->next = ptr;
     p->next->prev = ptr;
     ptr->prev = p;
     return head; 
};


struct Node *insertAtEnd(struct Node *head, int data)
{
     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));
     struct Node *p = head;
     while (p->next != NULL)
     {
          p = p->next;
     }
     ptr->data = data;
     p->next = ptr;
     ptr->next = NULL;
     ptr->prev = p;

     return head;
};





struct Node *deleteFirst(struct Node *head)
{
     struct Node *ptr = head;
     head = head->next;
     head->prev = NULL;
     free(ptr);
     return head;
}


struct Node *deleteInBetween(struct Node *head, int index)
{
     struct Node *p = head;
     struct Node *q = head->next;
     for (int i = 0; i < index - 1; i++)
     {
          p = p->next;
          q = q->next;
     }
     p->next = q->next;
     q->next->prev = p;
     free(q);
     return head;
}


struct Node *deleteLastNode(struct Node *head)
{
     struct Node *p = head;
     struct Node *q = head->next;
     while (q->next != NULL)
     {
          p = p->next;
          q = q->next;
     }
     p->next = NULL;
     free(q);
     return head;
}

int main()
{
     
     struct Node *head;
     struct Node *second;
     struct Node *third;
     struct Node *fourth;

     
     head = (struct Node *)malloc(sizeof(struct Node));
     second = (struct Node *)malloc(sizeof(struct Node));
     third = (struct Node *)malloc(sizeof(struct Node));
     fourth = (struct Node *)malloc(sizeof(struct Node));

     
     head->data = 7;
     head->next = second;
     head->prev = NULL;

     
     second->data = 11;
     second->next = third;
     second->prev = head;

     
     third->data = 70;
     third->next = fourth;
     third->prev = second;

     
     fourth->data = 22;
     fourth->next = NULL;
     fourth->prev = third;

     Traversal(head); 

     
     
     

     
     
     

     
     
     

     

     
     
     
     

     
     
     
     

     
     head = deleteLastNode(head);
     printf(""---After deletion---\n"");
     Traversal(head);

     return 0;
}








",42,1267,991
"struct stack{
    int size;
    int top;
    int *arr;
};

int isEmpty(struct stack*ptr){
    if(ptr->top== -1){
        printf(""Stack is empty..\n"");
        return 1;
    }
    else{
        return 0;
    }
    
}
int isFull(struct stack*ptr){
    if(ptr->top == ptr->size-1){
        printf(""Stack is Full(overflow)..\n"");
        return 1;
    }
    else{
        
        return 0;
    }
    
}

void push(struct stack*ptr, int val){
    if(isFull(ptr)){
        printf(""Stack Overflow! Cannot push %d to the stack\n"", val);
    }
    else{
        ptr->top++;
        ptr->arr[ptr->top]=val;
        
    }
}

int pop(struct stack*ptr){
    if(isEmpty(ptr)){
        printf(""Stack Underflow! Cannot pop from the stack\n"");
        return -1;
    }
    else{
        int val = ptr->arr[ptr->top];
        ptr->top--;
        return val;
        
        
    }
}

int peek(struct stack* sp, int i){
    int arrayInd = sp->top-i+1;
    if(arrayInd<0){
        printf(""Not a valid position for stack\n"");
        return -1;
        
    }
    else{
        return sp->arr[arrayInd];
    }
}

int main()
{
    struct stack *sp=(struct stack*)malloc(sizeof(struct stack));
    sp->size=10;
    sp->top= -1;
    sp->arr= (int *)malloc(sp->size* sizeof(int));
    
    
    printf(""Before pushing, Full: %d\n"", isFull(sp));
    printf(""Before pushing, Empty: %d\n"", isEmpty(sp));
    
    push(sp, 56);
    push(sp, 55);
    push(sp, 54);
    push(sp, 53);
    push(sp, 52);
    push(sp, 51);
    push(sp, 50);
    push(sp, 49);
    push(sp, 48);
    push(sp, 47); 
    push(sp, 46); 
    
    printf(""After pushing, Full: %d\n"", isFull(sp));
    printf(""After pushing, Empty: %d\n"", isEmpty(sp));
    
    
    printf(""Popped %d from the stack\n"", pop(sp));
     
    
    for(int j=1; j <= sp->top + 1; j++){
        printf(""The value at position %d is %d\n"",j,peek(sp, j));
    }

    return 0;
}",42,1268,721
"struct stack{
     int size;
     char top;
     char *arr;
};

int isFull(struct stack*ptr){
     if(ptr->top == ptr->size-1){
          return 1;
     }
     else{
          return 0;
     }

}

int isEmpty(struct stack*ptr){
     if(ptr->top == -1){
          return 1;
     }
     else{
          return 0;
     }

}

char push(struct stack*ptr, char val){
    if(isFull(ptr)){
        printf(""Stack Overflow! Cannot push %d to the stack\n"", val);
    }
    else{
        ptr->top++;
        ptr->arr[ptr->top]=val;
        
    }
}

char pop(struct stack*ptr){
    if(isEmpty(ptr)){
        printf(""Stack Underflow! Cannot pop from the stack\n"");
        return -1;
    }
    else{
        int val = ptr->arr[ptr->top];
        ptr->top--;
        return val;
        
    }
}

int match(char a, char b){
     if (a=='{' && b=='}' )
     {
          return 1;
     }

     if (a=='[' && b==']' )
     {
          return 1;
     }

     if (a=='(' && b==')' )
     {
          return 1;
     }
     return 0;
}


int parenthesisMatch(char*exp){
     
     struct stack* sp;
     sp->size=100;
     sp->top= -1;
     sp->arr = (char*)malloc(sp->size * sizeof(char));

     char popped_ch;

     for (int i = 0; exp[i]!='\0'; i++)
     {
          if (exp[i]=='(' || exp[i]=='[' || exp[i]=='{' )
          {
               push(sp, exp[i]);
          }
          else if (exp[i]==')' || exp[i]=='}' || exp[i]==']')
          {
               if (isEmpty(sp))
               {
                    return 0;
               }
               popped_ch = pop(sp);
               if(!match(popped_ch, exp[i])){
                    return 0;
               }
          }
          
     }
     if (isEmpty(sp))
     {
          return 1;
     }
     else{
          return 0;
     }
     
     
}

int main(){
     
     
     char*exp = ""(8*{19*(4-2)*([9-7]})"";

     
     if(parenthesisMatch(exp)){
          printf(""The Parenthesis are balanced.\n"");
     }
     else{
          printf(""The Parenthesis are not balanced.\n"");
     }

  
     return 0;
}

 ",42,1269,742
"struct Node{
     int data;
     struct Node *next;

};
void linkedListTraversal(struct Node*ptr){
     while(ptr!=NULL){
          printf(""Element: %d\n"",ptr->data);
          ptr=ptr->next;
          
     }
};


struct Node * insertAtFirst(struct Node *head, int data){
     struct Node * ptr = (struct Node *) malloc(sizeof(struct Node));
     ptr->next = head;
     ptr->data = data;
     return ptr;

};


struct Node * insertAtIndex(struct Node *head, int data, int index){
     struct Node * ptr = (struct Node *) malloc(sizeof(struct Node));
     struct Node * p = head;
     int i = 0;
     while (i!=index-1)
     {
          p = p->next;
          i++;
     }
     ptr->data = data;
     ptr->next = p->next;
     p->next = ptr;
     return head;
      
};


struct Node * insertAtEnd(struct Node *head, int data){
     struct Node * ptr = (struct Node *) malloc(sizeof(struct Node));
     ptr->data = data;
     struct Node * p = head; 
     while (p->next != NULL)
     {
         p = p->next;  
     }
     p->next =ptr;
     ptr->next= NULL;
     return head;
    
};

struct Node * insertAfterNode(struct Node *head, struct Node *previousNode, int data){
     struct Node * ptr = (struct Node *) malloc(sizeof(struct Node));
     ptr->data = data;
     ptr->next = previousNode->next;
     previousNode->next = ptr;
     return head;

 
};

int main(){
     
     struct Node*head;
     struct Node*second;
     struct Node*third;
     struct Node*fourth;
 
     
     head = (struct Node *) malloc(sizeof(struct Node));
     second = (struct Node *) malloc(sizeof(struct Node));
     third = (struct Node *) malloc(sizeof(struct Node));
     fourth = (struct Node *) malloc(sizeof(struct Node));

     
     head->data=7;
     head->next=second;

     
     second->data=11;
     second->next=third;

     
     third->data=70;
     third->next=fourth;

     
     fourth->data=22;
     fourth->next=NULL;

     printf(""\nLinked list before insertion\n"");
     linkedListTraversal(head);
     
     
     
     head= insertAfterNode(head, second, 45);
     printf(""\nLinked list after insertion\n"");


     linkedListTraversal(head);

     return 0;
}




",42,1270,697
"void main()
{
    int i, j, count = 0, pos, flag = 0;
    char s1[100], s2[10], s3[100];
    char *ptr1, *ptr2, *ptr3;
 
    printf(""\nenter the String:"");
    scanf("" %[^\n]s"", s1);
    printf(""\nenter the string to be inserted:"");
    scanf("" %[^\n]s"", s2);
    printf(""\nenter the position you like to insert:"");
    scanf(""%d"", &pos);
 
    ptr1 = s1;
    ptr3 = s3;
    
    for (i = 0, j = 0;*ptr1 != '\0'; ptr1++, i++, j++, ptr3++)
    {
        s3[j] = s1[i];
        if (*ptr1 == ' ' && flag != 1)
            ++count;
        if (flag != 1 && count == pos - 1)
        {
            flag = 1;
            for(ptr2 = s2;*ptr2 != '\0'; ptr2++)
            {
                s3[++j] = *ptr2;
                ptr3++;
            }
            s3[++j] = ' ';
            ptr3++;
        }
    }
    s3[j] = '\0';
    printf(""\nthe string after modification is\n\n %s\n"", s3);
}",42,1271,355
"int linearSearch(int arr[], int size, int element){
     for (int i =0; i < size; i++){
          if(arr[i]== element){
               return 1;
          }
     }
     return -1;
}

int binarySearch(int arr[], int size, int element){
     int low,mid,high;
     low=0;
     high = size-1;
     
     while(low<=high){
          mid = (low+high)/2; 
          if(arr[mid]==element){
               return mid;
          }
          if(arr[mid]<element){
               low=mid+1;
               
          }
          else{
               high = mid-1;
          }
     
     }
     return -1;

}


int main(){
     
     
     

     
     int arr[] = {1,3,5,7,9,56,574,594,599,632};
     int size = sizeof(arr)/sizeof(int);

     int element = 6;
     
     int searchIndex = binarySearch(arr,size,element);

     printf(""The element %d was found at index %d \n"", element, searchIndex);
     return 0;
}",42,1272,314
"void spi_data(int);

int main()
{
    PINSEL0 |= (1<<8)|(1<<10)|(1<<12);  
    PINSEL0 &= ~((1<<9)|(1<<11)|(1<<13));
    IODIR0 |= (1<<7);       
    
    S0SPCR = (1<<2)|(1<<3)|(1<<4)|(1<<5);       
    S0SPCCR = 8;        
    spi_data(0x0C01);               
    spi_data(0x0900);               
    spi_data(0x0A00);               
    spi_data(0x0B03);               
    
    spi_data(0x0177);       
    spi_data(0x021F);       
    spi_data(0x034E);       
    spi_data(0x043D);       
}

void spi_data(int data)
{
    IOCLR0  =   (1<<7);         
    S0SPDR = data;              
    while(!(S0SPSR & (1<<7)));
    IOSET0 = (1<<7);            
}

",43,1273,316
"void delay(int);
void blink_led(int);
void interrupt_config(void);
void eint_isr(void) __irq; 
int main()
{
    IODIR1 = IODIR1 | (0XFF<<17);
    
    interrupt_config();
    while(1)
    {
     blink_led(24); 
    }
}

void interrupt_config(void)
{
 PINSEL0 |= (1<<29);
 PINSEL0 &=~(1<<28);
 VICIntSelect &= ~(1<<15); 
 VICVectCntl1 = (   1<<5)|15;   
 VICVectAddr1 = (long)eint_isr;
 VICIntEnable = (1<<15);
 EXTMODE = (1<<1);
 EXTPOLAR = (1<<1); 

}
void eint_isr(void) __irq
{
blink_led(17);
EXTINT = (1<<1); 
VICVectAddr =  0X00000000;
}
void blink_led(int led)
{
IOSET1 = 1<<led;
delay(300);
IOCLR1 = 1<<led;
delay(300);
}

void delay(int ct)
{int i,j;
{
for(i=0;i<=ct;i++)
for(j=0;j<=6000;++j)
{}
}
}
",43,1274,382
"void delay_ms(int);
int main()
{

    PINSEL0 |= (1<<17);
    PINSEL0 &= ~(1<<16);                
    PWMPR = 14;
    PWMMR0 = 10000;                         
    PWMLER = (1<<0);
    PWMMCR = (1<<1);                        
    PWMPCR |= (1<<12);                  
    PWMPCR &= ~(1<<4);                  
    PWMTCR = (1<<0) | (1<<3);       
    while(1)
    {
        PWMMR4 = 2500;              
        PWMLER = (1<<4);
        delay_ms(1000);
        
        PWMMR4 = 5000;              
        PWMLER = (1<<4);
        delay_ms(1000);
        
        PWMMR4 = 7500;              
        PWMLER = (1<<4);
        delay_ms(1000);
        
        PWMMR4 = 10000;             
        PWMLER = (1<<4);
        delay_ms(1000);
    }   
}

void delay_ms(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}
",43,1275,388
"#include ""../lcd_header.h""
#define ROWS (0x0F<<21)
#define COLS (0x0F<<17)

void rows(void);
void cols(void);


int main()
{

    lcd_config();
    while(1)
    {
        rows();
        delay(1000);
        lcd_cmd(0x01);
        
    }
}

void rows(void)
{
    int val;

    IODIR1 = IODIR1 & ~ROWS;        
    IODIR1 = IODIR1 | COLS;         
    val = IOPIN1 & ROWS;        
    val = val >> 21;
    switch(val)
    {
        case 0x0E:  lcd_str(""r1""); cols();  delay(200); break;
        case 0x0D:  lcd_str(""r2""); cols();  delay(200); break;
        case 0x0B:  lcd_str(""r3""); cols();  delay(200); break;
        case 0x07:  lcd_str(""r4""); cols();  delay(200); break;
    }
}

void cols(void)
{
    int val;
    IODIR1 = IODIR1 & ~COLS;        
    IODIR1 = IODIR1 | ROWS;         
    
    val = IOPIN1 & COLS;        
    val = val >> 17;
    switch(val)
    {
        case 0x0E:  lcd_str(""C1"");  delay(200); break;
        case 0x0D:  lcd_str(""C2"");  delay(200); break;
        case 0x0B:  lcd_str(""C3"");  delay(200); break;
        case 0x07:  lcd_str(""C4"");  delay(200); break;
    }
}
",43,1276,497
"void delay(int );
void blink_LED(int );
void intr_config(void);
void eint1_isr(void) __irq;
int main()
{
    IODIR1 |= (0xFF<<17);
    intr_config();
    while(1)
    {
        blink_LED(24);
    }
}

void intr_config(void)
{
    PINSEL1 |= (1<<29);
    PINSEL1 &= ~(1<<28);    
    
    VICIntSelect &= ~(1<<17);       
    VICVectCntl1    = (1<<5)| 17;   
    VICVectAddr1    =   (long)eint1_isr;
    VICIntEnable = 1<<17;
    EXTMODE = (1<<3);       
    EXTPOLAR    = (1<<3);       

}

void eint1_isr(void) __irq
{
    blink_LED(17);
    EXTINT  = (1<<3);
    VICVectAddr = 0;
}

void blink_LED(int led)
{
    IOSET1 = 1<<led;
    delay(300);             
    IOCLR1 = 1<<led;
    delay(300);             
}

void delay(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)             
        {}
    }
}
",43,1277,406
"void delay(int );
void blink_led(int);

int main()
{
    IODIR1 |= 0xFF<<17;
    WDMOD = (1<<1) | (1<<0);   
    WDTC = 0xFFFFFF;
    blink_led(24);
    WDFEED = 0xAA; 
    WDFEED = 0x55;
    while(1)
    {
        blink_led(17);
    }
}

void delay(int ct)
{
    for(int i=0;i<ct;i++)
    {
        for(int j=0;j<6000;j++)
        {}
    }
}

void blink_led(int led)
{
    IOSET1 = 1<<led;
        delay(500);
        IOCLR1 = 1<<led;
        delay(500);
}
",43,1278,237
"void pll_48MHz(void);
void pll_36MHz(void);
void pll_12MHz(void);
void blink_led(int );
void delay_ms(int );
int count = 0;

int main()
{
    IODIR1 |= (0xFF<<17);
    while(1)
    {
        IOSET1 = 0xFF<<17;          
        delay_ms(500);
        IOCLR1 = 0xFF<<17;
        delay_ms(500);
        count++;
        if(count >= 10 && count<20)
        {
            pll_36MHz();                    
        }
        if (count >= 20 && count<25)
        { 
            pll_12MHz();                
        } else if(count >= 25)
        {
            pll_48MHz();
        }
    
    }
}

void pll_36MHz(void)
{
    PLLCON = 1<<0;              
    PLLFEED = 0xAA;
    PLLFEED = 0x55;             
    PLLCFG = (1<<6)| 2; 
    PLLCFG &= ~(1<<5);
    while(!(PLLSTAT & (1<<10)));            
    PLLCON = (1<<1)|(1<<0);         
    PLLFEED = 0xAA;
    PLLFEED = 0x55;             
}

void pll_48MHz(void)
{
    PLLCON = 1<<0;              
    PLLFEED = 0xAA;
    PLLFEED = 0x55;             
    PLLCFG = (1<<5)| 3; 
    PLLCFG &= ~(1<<5);
    while(!(PLLSTAT & (1<<10)));            
    PLLCON = (1<<1)|(1<<0);         
    PLLFEED = 0xAA;
    PLLFEED = 0x55;             
}

void pll_12MHz(void)
{
    PLLCON = 1<<0;              
    PLLFEED = 0xAA;
    PLLFEED = 0x55;             
    PLLCFG = (1<<6)| (1<<5) | 0;    
    while(!(PLLSTAT & (1<<10)));            
    PLLCON = (1<<1)|(1<<0);         
    PLLFEED = 0xAA;
    PLLFEED = 0x55;             
}


void blink_led(int led)
{
        IOSET1 = 1<<led;  
        delay_ms(100);
        IOCLR1 = 1<<led;   
        delay_ms(100);
}

void delay_ms(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}
",43,1279,790
"void delay(int);
int main()
{
    PINSEL0 |= (1<<17);
    PINSEL0 &= ~(1<<16);  
    

    
    PWMPR = 14;
    PWMMR0 = 10000;
    PWMLER = 1<<0;
    PWMMCR = (1<<1);   
    PWMPCR = (1<<4)|(1<<12);  
    PWMTCR = (1<<0)|(1<<3);  
    
        while(1)
        {
            PWMMR3 = 1000;   
            PWMMR4 = 3500;
            PWMLER = (1<<3)|(1<<4);
            delay(500);
            
            PWMMR3 = 1000;  
            PWMMR4 = 6000;
            PWMLER = (1<<3)|(1<<4);
            delay(500);
            
            PWMMR3 = 1000;  
            PWMMR4 = 8500;
            PWMLER = (1<<3)|(1<<4);
            delay(500);
        
    }
}

void delay(int ct)
{
    for(int i=0;i<ct;i++)
    {
        for(int j=0;j<6000;j++)
        {
        }
    }
}
",43,1280,378
"void delay(int );
void blink_LED(int );
void intr_config(void);
void eint1_isr(void) __irq;
int main()
{
    IODIR1 |= (0xFF<<17);
    intr_config();
    while(1)
    {
        blink_LED(24);
    }
}

void intr_config(void)
{
    PINSEL0 |= (1<<29);
    PINSEL0 &= ~(1<<28);    
    
    VICIntSelect &= ~(1<<15);       
    VICVectCntl1    = (1<<5)| 15;   
    VICVectAddr1    =   (long)eint1_isr;
    VICIntEnable = 1<<15;
    EXTMODE = (1<<1);       
    EXTPOLAR    = (1<<1);       

}

void eint1_isr(void) __irq
{
    blink_LED(17);
    EXTINT  = (1<<1);
    VICVectAddr = 0;
}

void blink_LED(int led)
{
    IOSET1 = 1<<led;
    delay(300);             
    IOCLR1 = 1<<led;
    delay(300);             
}

void delay(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)             
        {}
    }
}
",43,1281,406
"#include ""../lcd_header.h""

void i2c_config(void);
void i2c_start(void);
void i2c_data(char );
void i2c_stop(void);


int main()
{
    lcd_config();
    i2c_config();
    
    i2c_start();
    i2c_data(0xA0);     
    i2c_data(0x00);     
    i2c_data('A');
    i2c_data('B');
    i2c_data('C');
    i2c_stop();
    
}

void i2c_config(void)
{
    PINSEL0 |= (1<<4)|(1<<6);           
    PINSEL0 &= ~((1<<5)|(1<<7));
    
    I2CONSET    = 1<<6;     
    I2SCLH = 75;                
    I2SCLL = 75;
}

void i2c_start(void)
{
    I2CONCLR = 1<<3;
    I2CONSET = 1<<5;        
    while(!(I2CONSET & (1<<3)));    
    I2CONCLR = 1<<3;        
    I2CONCLR = 1<<5;        
}

void i2c_data(char data)
{
    I2DAT = data;
    while(!(I2CONSET & (1<<3)));    
    I2CONCLR = 1<<3;
}

void i2c_stop(void)
{
    I2CONSET = 1<<4;    
}



",43,1282,419
"#include ""lcd_header.h""

void lcd_config(void)
{
    IODIR0 = IODIR0 | RS | RW | EN | DATA; 
    
    lcd_cmd(0x38);  
    lcd_cmd(0x0E);  
    lcd_cmd(0x01);  
    lcd_cmd(0x80);  
}

void lcd_cmd(char c)
{
    
    
    
    IOCLR0 = DATA;    
    IOSET0 = c<<15;
    IOCLR0 = RW;    
    IOCLR0 = RS;    
    IOSET0 = EN;
    delay(100);
    IOCLR0 = EN;    
}

void lcd_data(char d)
{
    IOCLR0 = DATA;
    IOSET0 = d <<15;
    IOCLR0 = RW;
    IOSET0 = RS;
    IOSET0 = EN;
    delay(100);
    IOCLR0 = EN;
}

void lcd_str(char str[])
{
    for(int i=0;str[i]!='\0';i++)
    {
        lcd_data(str[i]);
    }





}

void lcd_num(int num)
{
    if(num)
    {
        lcd_num(num/10);
        lcd_data(num%10 + 0x30);
    }
}

void delay(int ct)
{
    for(int i =0 ;i<ct; i++)
    {
        for(int j=0;j<6000;++j)
        {
        }
    }
}
",43,1283,445
"void delay(int );
void blink_LED(int );
void timer0_config(void);
void timer1_config(void);
void interrupt_config(void);
void timer0_isr1(void) __irq;               
void timer1_isr2(void) __irq;               
void eint1_isr(void) __irq;

int main()
{
    IODIR1 = IODIR1 | (0xFF<<17);       
    IODIR0 |= (1<<11);
    timer1_config();
    timer0_config();
    interrupt_config();
    while(1)
    {
            blink_LED(24);
    }
}

void interrupt_config(void)
{
    PINSEL0 |= (1<<29);
    PINSEL0 &= ~(1<<28);                                                    
    VICIntSelect &= ~((1<<4)|(1<<5)|(1<<15));           
    VICVectCntl1    = (1<<5)| 15;                                       
    VICVectAddr1    =   (long)eint1_isr;
    VICVectCntl4    = (1<<5)|4;                                             
    VICVectAddr4    = (long)timer0_isr1;                                
    VICVectCntl5    = (1<<5)|5;                                                 
    VICVectAddr5    = (long)timer1_isr2;
    VICIntEnable    = (1<<4)|(1<<5)|(1<<15) ;               
    EXTMODE = (1<<1);                                                       
    EXTPOLAR    = (1<<1);                                                       
}

void timer0_isr1(void) __irq
{
    blink_LED(17);
    T0IR = (1<<0);          
    VICVectAddr =   0x00000000;     
}

void timer1_isr2(void) __irq
{
    blink_LED(20);
    T1IR = (1<<0);          
    VICVectAddr =   0x00000000;     
}

void eint1_isr(void) __irq
{
    IOSET0 = 1<<11;
    delay(300);             
    IOCLR0 = 1<<11;
    delay(300);             
    EXTINT  = (1<<1);
    VICVectAddr = 0x00000000;
}

void timer0_config(void)
{
    T0PR = 14;
    T0MR0 = 2000000;                            
    T0MCR = (1<<0)|(1<<1);
    T0TCR = (1<<0);
}

void timer1_config(void)
{
    T1PR = 14;
    T1MR0 = 2000000;                            
    T1MCR = (1<<0)|(1<<1);
    T1TCR = (1<<0);
    
}

void blink_LED(int led)
{
    IOSET1 = 1<<led;
    delay(300);             
    IOCLR1 = 1<<led;
    delay(300);             
}

void delay(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)             
        {}
    }
}
",43,1284,920
"#include ""../lcd_header.h""

void i2c_config(void);
void i2c_start(void);
void i2c_data(char );
char i2c_recv(void);
void i2c_stop(void);


int main()
{
    char data;
    lcd_config();
    i2c_config();
    
    
    I2CONSET = 1<<2;        
    
    i2c_start();
    i2c_data(0xA0);
    i2c_data(0x00);         
    
    i2c_start();
    i2c_data(0xA1);         
    data = i2c_recv();
    lcd_data(data);
    data = i2c_recv();
    lcd_data(data);
    data = i2c_recv();
    lcd_data(data);
    i2c_stop();
    
}

void i2c_config(void)
{
    PINSEL0 |= (1<<4)|(1<<6);           
    PINSEL0 &= ~((1<<5)|(1<<7));
    
    I2CONSET    = 1<<6;     
    I2SCLH = 75;                
    I2SCLL = 75;
}

void i2c_start(void)
{
    I2CONCLR = 1<<3;
    I2CONSET = 1<<5;        
    while(!(I2CONSET & (1<<3)));    
    I2CONCLR = 1<<3;        
    I2CONCLR = 1<<5;        
}

void i2c_data(char data)
{
    I2DAT = data;           
    while(!(I2CONSET & (1<<3)));    
    I2CONCLR = 1<<3;
}

char i2c_recv(void)
{
    char recv;
    while(!(I2CONSET & (1<<3)));    
    I2CONCLR = 1<<3;
    recv = I2DAT;
    return recv;
}

void i2c_stop(void)
{
    I2CONSET = 1<<4;    
}



",43,1285,572
"#include ""lcd_header.h""


int main()
{
    int res,done = 1;
    


    PINSEL1 |= 1<<24;
    PINSEL1 &= ~(1<<25); 
    lcd_config();

    ADCR = (1<<1)|(4<<8)|(1<<21)|(1<<24);  
    while(1)
    {
        
        
        while(!(ADDR & (done<<31)));
        res = ADDR & (0x3FF<<6);   
        res = res>>6;                               
        res = res/3.3;  
        lcd_num(res);
        delay(1000);

        
    }
}

void adc_pot(void)
{
    int res,done = 1;
    ADCR = (1<<0)|(4<<8)|(1<<21)|(1<<24); 
    while(!(ADDR & (done<<31)));
    res = ADDR & (0x3FF<<6);   
    res = res>>6;       
}

void adc_temp(void)
{
    int res,done = 1;
    ADCR = (1<<1)|(4<<8)|(1<<21)|(1<<24); 
    while(!(ADDR & (done<<31)));
    res = ADDR & (0x3FF<<6);   
    res = res>>6;       
}",43,1286,371
"#include ""lcd_header.h""

void lcd_config(void)
{
    IODIR0 |= DATA_PINS|RS|RW|EN;       
                        
                        
    lcd_cmd(0x38);  
    lcd_cmd(0x0E);  
    lcd_cmd(0x01);  
    lcd_cmd(0x80);  
}

void lcd_cmd(char cmd)
{
    IOCLR0 = DATA_PINS;     
    IOSET0 = cmd<<15;  
    IOCLR0 = RW;                
    IOCLR0 = RS;        
    IOSET0 = EN;
    delay(100);
    IOCLR0 = EN;
}

void lcd_data(char data)
{
    IOCLR0 = DATA_PINS;     
    IOSET0 = data<<15;  
    IOCLR0 = RW;                
    IOSET0 = RS;            
    IOSET0 = EN;
    delay(100);
    IOCLR0 = EN;
}

void delay(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)             
        {}
    }
}


void lcd_str(char str[])
{
    int i;
    for(i=0;str[i]!='\0';++i)
        {
            lcd_data(str[i]);
        }
}

void lcd_str1(char str[])
{
    int i,count=0;
    for(i=0;str[i]!='\0';++i)
        {
            lcd_data(str[i]);
            if(count == 16)
            {
                lcd_cmd(0xC0);
            }
            count++;
        }
}

void lcd_num(int num)
{
    if(num)
    {
        lcd_num(num/10);
        lcd_data(num%10 + 0x30);
    }
}






",43,1287,560
"void blink_led(int );
void delay_ms(int );
int main()
{
    IODIR1 |= (0xFF<<17);
    WDMOD = (1<<0)|(1<<1);
    WDTC = 0xFFFFFF;            
    WDFEED = 0xAA;              
    WDFEED = 0x55;
    blink_led(24);          
    while(1)
    {
        blink_led(17);
    }
}

void blink_led(int led)
{
        IOSET1 = 1<<led;  
        delay_ms(100);
        IOCLR1 = 1<<led;   
        delay_ms(100);
}

void delay_ms(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}
",43,1288,253
"void spi_data(int);

int main()
{
    PINSEL0 |= (1<<8)|(1<<10)|(1<<12);  
    PINSEL0 &= ~((1<<9)|(1<<11)|(1<<13));
    IODIR0 |= (1<<7);       
    
    S0SPCR = (1<<2)|(1<<3)|(1<<4)|(1<<5);       
    S0SPCCR = 8;        
    spi_data(0x0C01);               
    spi_data(0x090F);               
    spi_data(0x0AFF);               
    spi_data(0x0B03);               
    
    spi_data(0x010C);               
    spi_data(0x020B);       
    spi_data(0x030D);       
    spi_data(0x040E);       
}

void spi_data(int data)
{
    IOCLR0  =   (1<<7);         
    S0SPDR = data;              
    while(!(S0SPSR & (1<<7)));
    IOSET0 = (1<<7);            
}

",43,1289,315
"void delay(int);

int main()
{
    IODIR1 = IODIR1 | (0xFF<<17);
                                    
    while(1)
    {
        for(int led =17;led <= 24; led++)
        {
            IOSET1 = 1<<led;
            delay(100);
            IOCLR1 = 1<<led;
            delay(100);
        }
    }
}
void delay(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)             
        {}
    }
}
",43,1290,174
"#define LED_ALL (0xFF<<17)

void delay_ms(int );
void blink_led(int );
void timer0_isr(void)__irq;

int main()
{
        IODIR1 = IODIR1| LED_ALL;
        
        T0PR = 14;
        T0MR0 = 2000000;
        T0MCR = (1<<0)|(1<<1);
        T0TCR = (1<<0);
        
        VICIntSelect = VICIntSelect & ~(1<<4); 


        VICVectCntl1 = (1<<5)|4;   
        VICVectAddr1 = (long)&timer0_isr;       
        VICIntEnable = (1<<4);   
        while(1)
        {
            blink_led(17);
        }
}

void timer0_isr(void)__irq
{
    IOSET1 = 1<<24;  
    delay_ms(100);
    IOCLR1 = 1<<24;   
    delay_ms(100);
    T0IR = 1<<0;            
    VICVectAddr = 0x00000000;  
    
}
void blink_led(int led)
{
        IOSET1 = 1<<led;  
        delay_ms(100);
        IOCLR1 = 1<<led;   
        delay_ms(100);
}

void delay_ms(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}





",43,1291,452
"#define RS (1<<10)
#define RW (1<<12)
#define EN (1<<13)
#define DATA_PINS (0xFF<<15)

void lcd_config(void);
void lcd_cmd(char);
void lcd_data(char);
void lcd_str(char []);
void lcd_str1(char []);
void delay(int);

int main()
{



        int num = 8,res,quotient,remainder;     
        res = 66 + 33;
        lcd_config();   
        quotient = res/10;
        remainder = res%10;
        lcd_data(quotient + 0x30);
        lcd_data(remainder + 0x30);
    







}

void lcd_config(void)
{
    IODIR0 |= DATA_PINS|RS|RW|EN;       
                        
                        
    lcd_cmd(0x38);  
    lcd_cmd(0x0E);  
    lcd_cmd(0x01);  
    lcd_cmd(0x80);  
}

void lcd_cmd(char cmd)
{
    IOCLR0 = DATA_PINS;     
    IOSET0 = cmd<<15;  
    IOCLR0 = RW;                
    IOCLR0 = RS;        
    IOSET0 = EN;
    delay(100);
    IOCLR0 = EN;
}

void lcd_data(char data)
{
    IOCLR0 = DATA_PINS;     
    IOSET0 = data<<15;  
    IOCLR0 = RW;                
    IOSET0 = RS;            
    IOSET0 = EN;
    delay(100);
    IOCLR0 = EN;
}

void delay(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)             
        {}
    }
}


void lcd_str(char str[])
{
    int i;
    for(i=0;str[i]!='\0';++i)
        {
            lcd_data(str[i]);
        }
}

void lcd_str1(char str[])
{
    int i,count=0;
    for(i=0;str[i]!='\0';++i)
        {
            lcd_data(str[i]);
            if(count == 16)
            {
                lcd_cmd(0xC0);
            }
            count++;
        }
}








",43,1292,709
"#define LED_ALL (0xFF<<17)

void delay_ms(int );
void blink_led(int );
void timer0_isr(void)__irq;
void timer1_isr(void)__irq;
void timer_config(void);
void intr_config(void);

int main()
{
        IODIR1 = IODIR1| LED_ALL;
        timer_config();
        intr_config();
        while(1)
        {
            blink_led(17);
        }
}

void timer_config(void)
{
    
        T0PR = 14;
        T0MR0 = 2000000;
        T0MCR = (1<<0)|(1<<1);
        
    
        T1PR = 14;
        T1MR0 = 2000000;
        T1MCR = (1<<0)|(1<<1);
        T1TCR = (1<<0);
    
    T0TCR = (1<<0);
}

void intr_config(void)
{
    
        VICIntSelect = VICIntSelect & ~((1<<4)|(1<<5)); 
        VICVectCntl2 = (1<<5)|4;   
        VICVectAddr2 = (long)&timer0_isr;
        
        VICVectCntl1 = (1<<5)|5;   
        VICVectAddr1 = (long)&timer1_isr;
    
        VICIntEnable = (1<<5)|(1<<4);   
}

void timer0_isr(void)__irq
{
    IOSET1 = 1<<20;  
    delay_ms(100);
    IOCLR1 = 1<<20;   
    delay_ms(100);
    T0IR = 1<<0;            
    VICVectAddr = 0x00000000;  
    
}

void timer1_isr(void)__irq
{
    IOSET1 = 1<<24;  
    delay_ms(100);
    IOCLR1 = 1<<24;   
    delay_ms(100);
    T1IR = 1<<0;            
    VICVectAddr = 0x00000000;  
    
}
void blink_led(int led)
{
        IOSET1 = 1<<led;  
        delay_ms(100);
        IOCLR1 = 1<<led;   
        delay_ms(100);
}

void delay_ms(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}





",43,1293,731
"void delay(int);
int main()
{
    PINSEL0 |= (1<<17);
    PINSEL0 &= ~(1<<16);  
    

    
    PWMPR = 14;
    PWMMR0 = 10000;
    PWMLER = 1<<0;
    PWMMCR = (1<<1);   
    PWMPCR &= ~(1<<4);  
    PWMPCR = (1<<12);
    PWMTCR = (1<<0)|(1<<3);  
    
        while(1)
        {
            PWMMR4 = 2500;   
            PWMLER = 1<<4;
            delay(500);
            
            PWMMR4 = 5000;   
            PWMLER = 1<<4;
            delay(500);
            
            PWMMR4 = 7500;   
            PWMLER = 1<<4;
            delay(500);
            
            PWMMR4 = 10000;   
            PWMLER = 1<<4;
            delay(500);
        
    }
}

void delay(int ct)
{
    for(int i=0;i<ct;i++)
    {
        for(int j=0;j<6000;j++)
        {
        }
    }
}
",43,1294,367
"#include ""../lcd_header.h""

#define ROW (0x0F<<17)   
#define COL (0x0F<<21)   

int main()
{
    int val;
    IODIR1 = IODIR1 & ~(ROW);

    IODIR1 = IODIR1 | (COL);




    lcd_config();
    while(1)
    {
        val = (IOPIN1 & ROW); 
        val = val >> 17;





    




        if(val == 0x0E)
        {
            lcd_str(""row1"");
            delay(500);
        }



        if(val == 0x0D)
        {
            lcd_str(""row2"");
            delay(500);
        }



        if(val == 0x0B)
        {
            lcd_str(""row3"");
            delay(500);
        }



        if(val == 0x07)
        {
            lcd_str(""Row4"");
            delay(500);
        }
       








        lcd_cmd(0x01);
    
    }   
}
",43,1295,320
"void delay(int );
void blink_LED(int );

int main()
{
    IODIR1 = IODIR1 | (0xFF<<17);       
    T0PR = 14;                  
    T0MR0 = 500000;     
    T0MCR   = (1<<0)|(1<<1);            
    T0TCR   = (1<<0);           
    while(1)
    {
        blink_LED(24);
        if(T0IR & (1<<0))           
        {
            blink_LED(17);
            T0IR = 1<<0;            
        }
    }
}

void blink_LED(int led)
{
    IOSET1 = 1<<led;
    delay(1000);                
    IOCLR1 = 1<<led;
    delay(1000);                
}

void delay(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)             
        {}
    }
}
",43,1296,289
"void delay(int);



int main()
{
    IODIR1 = IODIR1 | (1<<17)|(1<<18);
    while(1)
    {
        IOSET1 = (1<<17)|(1<<18);
        delay(1000);
        IOCLR1 = (1<<17)|(1<<18);
        delay(1000);
    }
}

void delay(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}
",43,1297,168
"#include ""../lcd_header.h""

#define ROW (0x0F<<21)    
#define COL (0x0F<<17)    
void row_key(void);
void col_key(void);
int main()
{
    lcd_config();
    while(1)
    {
        row_key();
    }   
}

void row_key(void)
{
        int val;
        IODIR1 = IODIR1 & ~(ROW);
        IODIR1 = IODIR1 | (COL);
        val = (IOPIN1 & ROW); 
        val = val >> 21;
        switch(val)
        {
            case 0x0E: 
                lcd_str(""R1"");
                col_key();
                break;
            case 0x0D:
                lcd_str(""R2"");
                col_key();
                break;
            case 0x0B:
                lcd_str(""R3"");
                col_key();
                break;
            case 0x07:
                lcd_str(""R4"");
                col_key();
                break;
            default:
                delay(1000);
                lcd_cmd(0x01);
        }
}

void col_key(void)
{
        int val;
        IODIR1 = IODIR1 & ~(COL);  
        IODIR1 = IODIR1 | (ROW);  
    
        val = (IOPIN1 & COL); 
        val = val >> 17;
        lcd_cmd(0xC0);
        switch(val)
        {
            case 0x0E: 
                lcd_str(""C1"");
                delay(200);
                break;
            case 0x0D:
                lcd_str(""C2"");
                delay(200);
                break;
            case 0x0B:
                lcd_str(""C3"");
                delay(200);
                break;
            case 0x07:
                lcd_str(""C4"");
                delay(200);
                break;
            default:
                delay(1000);
                lcd_cmd(0x01);          
        }
}

",43,1298,563
"void delay(int );
void blink_LED(int );
void timer0_config(void);
void timer1_config(void);
void interrupt_config(void);

void nonvic_isr(void) __irq;


int main()
{
    IODIR1 = IODIR1 | (0xFF<<17);       
    IODIR0 |= (1<<11);
    timer1_config();
    timer0_config();
    interrupt_config();
    while(1)
    {
            blink_LED(24);
    }
}

void interrupt_config(void)
{
    PINSEL0 |= (1<<29);
    PINSEL0 &= ~(1<<28);                                                    
    VICIntSelect &= ~((1<<4)|(1<<5)|(1<<15));           
    
    VICDefVectAddr  = (long)nonvic_isr;
    
    VICIntEnable    = (1<<4)|(1<<5)|(1<<15) ;               
    EXTMODE = (1<<1);                                                       
    EXTPOLAR    = (1<<1);                                                       
}
void nonvic_isr(void) __irq
{
    blink_LED(17);
    T0IR = (1<<0);          
    T1IR = (1<<0);
    EXTINT  =(1<<1);
    VICVectAddr =   0x00000000;     

}


void timer0_config(void)
{
    T0PR = 14;
    T0MR0 = 4000000;                            
    T0MCR = (1<<0)|(1<<1);
    T0TCR = (1<<0);
}

void timer1_config(void)
{
    T1PR = 14;
    T1MR0 = 5000000;                            
    T1MCR = (1<<0)|(1<<1);
    T1TCR = (1<<0);
    
}

void blink_LED(int led)
{
    IOSET1 = 1<<led;
    delay(300);             
    IOCLR1 = 1<<led;
    delay(300);             
}

void delay(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)             
        {}
    }
}
",43,1299,643
"#define LED_ALL (0xFF<<17)

void delay_ms(int );
void blink_led(int );
void nonvic_isr(void)__irq;
void timer_config(void);
void intr_config(void);


int main()
{
        IODIR1 = IODIR1| LED_ALL;
        PINSEL0 = PINSEL0 | (1<<29); 
        PINSEL0 = PINSEL0 & ~(1<<28);
        timer_config();
        intr_config();
        while(1)
        {
            blink_led(17);
        }
}

void timer_config(void)
{
    
        T0PR = 14;
        T0MR0 = 3000000;
        T0MCR = (1<<0)|(1<<1);
        
    
        T1PR = 14;
        T1MR0 = 3500000;
        T1MCR = (1<<0)|(1<<1);
        T1TCR = (1<<0);
    
        T0TCR = (1<<0);
}

void intr_config(void)
{
    
        VICIntSelect = VICIntSelect & ~((1<<4)|(1<<5)|(1<<15)); 
    
        VICDefVectAddr = (long)nonvic_isr;
    
        VICIntEnable = (1<<5)|(1<<4)|(1<<15);   
        
        EXTMODE = 1<<1; 
        EXTPOLAR = 1<<1;    
}

void nonvic_isr(void)__irq
{
    blink_led(24);
    T0IR = 1<<0;
    T1IR = 1<<0;
    EXTINT = 1<<1;
    VICVectAddr = 0x00000000;
}

void blink_led(int led)
{
        IOSET1 = 1<<led;  
        delay_ms(100);
        IOCLR1 = 1<<led;   
        delay_ms(100);
}

void delay_ms(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}





",43,1300,623
"#include ""../lcd_header.h""
#define ROWS (0x0F<<21)
#define COLS (0x0F<<17)

void rows(void);
void col_1(void);
void col_2(void);
void col_3(void);
void col_4(void);

int main()
{

    lcd_config();
    while(1)
    {
        rows();


        
    }
}

void rows(void)
{
    int val;

    IODIR1 = IODIR1 & ~ROWS;        
    IODIR1 = IODIR1 | COLS;         
    val = IOPIN1 & ROWS;        
    val = val >> 21;
    switch(val)
    {
        case 0x0E:   col_1();   delay(200); break;
        case 0x0D:   col_2();   delay(200); break;
        case 0x0B:   col_3();   delay(200); break;
        case 0x07:   col_4();   delay(200); break;
    }
}

void col_1(void)                    
{
    int val;
    IODIR1 = IODIR1 & ~COLS;        
    IODIR1 = IODIR1 | ROWS;         
    
    val = IOPIN1 & COLS;        
    val = val >> 17;
    switch(val)
    {
        case 0x0E:  lcd_data('7');  delay(200); break;
        case 0x0D:  lcd_data('8');  delay(200); break;
        case 0x0B:  lcd_data('9');  delay(200); break;
        case 0x07:  lcd_data('/');  delay(200); break;
    }
}

void col_2(void)                    
{
    int val;
    IODIR1 = IODIR1 & ~COLS;        
    IODIR1 = IODIR1 | ROWS;         
    
    val = IOPIN1 & COLS;        
    val = val >> 17;
    switch(val)
    {
        case 0x0E:  lcd_data('4');  delay(200); break;
        case 0x0D:  lcd_data('5');  delay(200); break;
        case 0x0B:  lcd_data('6');  delay(200); break;
        case 0x07:  lcd_data('x');  delay(200); break;
    }
}

void col_3(void)            
{
    int val;
    IODIR1 = IODIR1 & ~COLS;        
    IODIR1 = IODIR1 | ROWS;         
    
    val = IOPIN1 & COLS;        
    val = val >> 17;
    switch(val)
    {
        case 0x0E:  lcd_data('1');  delay(200); break;
        case 0x0D:  lcd_data('2');  delay(200); break;
        case 0x0B:  lcd_data('3');  delay(200); break;
        case 0x07:  lcd_data('-');  delay(200); break;
    }
}

void col_4(void)    
{
    int val;
    IODIR1 = IODIR1 & ~COLS;        
    IODIR1 = IODIR1 | ROWS;         
    
    val = IOPIN1 & COLS;        
    val = val >> 17;
    switch(val)
    {
        case 0x0E:  lcd_data('.');  delay(200); break;
        case 0x0D:  lcd_data('0');  delay(200); break;
        case 0x0B:  lcd_data('=');  delay(200); break;
        case 0x07:  lcd_data('+');  delay(200); break;
    }
}



",43,1301,1048
"int main()
{


    int count=0;
    IODIR1 = IODIR1 | (0xFF<<17);       
    T0PR = 14;                                          
    T0MR0 = 2000000;                                
    T0MR1 = 4000000;                                
    T0MCR   = (1<<0)|(1<<3)|(1<<4);     
    T0TCR   = (1<<0);                                   
    while(1)
    {
        count++;
        if(T0IR & (1<<0))                           
        {
            IOSET1 = (0xFF<<17);
            T0IR = 1<<0;                                
        }
        
        if(T0IR & (1<<1))                           
        {
            IOCLR1 = (0xFF<<17);
            T0IR = 1<<1;                                
        }








    
    }
}
",43,1302,250
"#include ""../lcd_header.h""
void i2c_init(void);
void i2c_Start(void);
void i2c_tx_data(char );
char i2c_rx_data(void);
void i2c_stop(void);

int main()
{   
    char i2c_rdata;
    lcd_config();
    i2c_init();
    
    i2c_Start();
    i2c_tx_data(0xA0);          
    i2c_tx_data(0x41);          
    i2c_tx_data('J');   
    i2c_tx_data('R');   
    i2c_tx_data('A');   
    i2c_tx_data('M');
        
    i2c_stop();

    lcd_str(""Data sent"");
    delay(1000);
    lcd_cmd(0x01);
    
    i2c_Start();
    i2c_tx_data(0xA0);          
    i2c_tx_data(0x41);          
    
    I2CONSET = (1<<2);          
    
    i2c_Start();                        
    i2c_tx_data(0xA1);          
    
    i2c_rdata = i2c_rx_data();
    lcd_data(i2c_rdata);        
    i2c_rdata = i2c_rx_data();
    lcd_data(i2c_rdata);        
    i2c_rdata = i2c_rx_data();
    lcd_data(i2c_rdata);        
    i2c_rdata = i2c_rx_data();
    lcd_data(i2c_rdata);        

    
    i2c_stop();

    lcd_cmd(0xC0);
    lcd_str(""Data from EEPROM"");
}

void i2c_init(void)
{
    PINSEL0 |= (1<<4)|(1<<6);
    PINSEL0 &= ~((1<<5)|(1<<7));        
    I2CONSET = 1<<6;                                
    I2SCLH = 75;                                        
    I2SCLL = 75;
}

void i2c_Start(void)
{
    I2CONCLR = (1<<3);      
    I2CONSET = (1<<5);          
    while(!(I2CONSET &(1<<3)));
    I2CONCLR = (1<<5);          
    I2CONCLR = (1<<3);          
}

void i2c_tx_data(char idata)
{
    I2DAT = idata;
    while(!(I2CONSET &(1<<3)));
    I2CONCLR = (1<<3);          
}

char i2c_rx_data(void)
{
    char recv_data;
    while(!(I2CONSET &(1<<3)));
    I2CONCLR = (1<<3);
    recv_data = I2DAT;
    return recv_data;
}

void i2c_stop(void)
{
    I2CONSET = (1<<4);
}
",43,1303,823
"#define LED_ALL (0xFF<<17)

void delay_ms(int );
void blink_led(int );
void timer0_isr(void)__irq;
void timer1_isr(void)__irq;
void ext_isr(void)__irq;
void timer_config(void);
void intr_config(void);


int main()
{
        IODIR1 = IODIR1| LED_ALL;
        PINSEL0 = PINSEL0 | (1<<29); 
        PINSEL0 = PINSEL0 & ~(1<<28);
        timer_config();
        intr_config();
        while(1)
        {
            blink_led(17);
        }
}

void timer_config(void)
{
    
        T0PR = 14;
        T0MR0 = 2000000;
        T0MCR = (1<<0)|(1<<1);
        
    
        T1PR = 14;
        T1MR0 = 2000000;
        T1MCR = (1<<0)|(1<<1);
        T1TCR = (1<<0);
    
        T0TCR = (1<<0);
}

void intr_config(void)
{
    
        VICIntSelect = VICIntSelect & ~((1<<4)|(1<<5)|(1<<15)); 
    
        VICVectCntl2 = (1<<5)|4;   
        VICVectAddr2 = (long)&timer0_isr;
        
        VICVectCntl1 = (1<<5)|5;   
        VICVectAddr1 = (long)&timer1_isr;
        
        VICVectCntl3 = (1<<5)|15;   
        VICVectAddr3 = (long)&ext_isr;
    
    
        VICIntEnable = (1<<5)|(1<<4)|(1<<15);   
        
        EXTMODE = 1<<1; 
        EXTPOLAR = 1<<1;    
}

void timer0_isr(void)__irq
{
    IOSET1 = 1<<20;  
    delay_ms(100);
    IOCLR1 = 1<<20;   
    delay_ms(100);
    T0IR = 1<<0;            
    VICVectAddr = 0x00000000;  
    
}

void timer1_isr(void)__irq
{
    IOSET1 = 1<<22;  
    delay_ms(100);
    IOCLR1 = 1<<22;   
    delay_ms(100);
    T1IR = 1<<0;            
    VICVectAddr = 0x00000000;  
    
}

void ext_isr(void)__irq
{
    blink_led(24);
    EXTINT = 1<<1; 
    VICVectAddr = 0x00000000;
}

void blink_led(int led)
{
        IOSET1 = 1<<led;  
        delay_ms(100);
        IOCLR1 = 1<<led;   
        delay_ms(100);
}

void delay_ms(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}





",43,1304,931
"void delay(int);

int main()
{

    IODIR1 = IODIR1 | (0xFF << 17);   

    while(1)
    {
        for(int i=17;i<=24;++i)
        {
            IOSET1 = (1<<i);
            delay(100);
            IOCLR1 = (1<<i);
            delay(100);
        }
        
        for(int i=24;i>=17;--i)
        {
            IOSET1 = (1<<i);
            delay(100);
            IOCLR1 = (1<<i);
            delay(100);
        }
    }
}

void delay(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}
",43,1305,239
"#include ""../lcd_header.h""


int main()
{
    lcd_config();
    CCR =1<<0;
    PREINT = 456;
    PREFRAC = 25024;
    
    HOUR = 7;
    MIN = 0;
    SEC = 0;
    
    while(1)
    {
        lcd_cmd(0x80);
        lcd_num(HOUR);
        lcd_data(':');
        lcd_cmd(0x83);
        lcd_num(MIN);
        lcd_data(':');
        if(SEC < 9)
        {
            lcd_cmd(0x86);
            lcd_data('0');
            lcd_num(SEC);
        }else{
            lcd_cmd(0x86);
            lcd_num(SEC);
        }
    }
}

",43,1306,239
"#define LED_ALL (0xFF<<17)

void delay_ms(int );
void blink_led(int );
void intr_config(void);
void ext_isr(void)__irq;
int main()
{
    IODIR1 |= LED_ALL;
    PINSEL0 = PINSEL0 | (1<<29); 
    PINSEL0 = PINSEL0 & ~(1<<28);
    intr_config();
    while(1)
    {
            blink_led(17);
    }
}

void intr_config(void)
{
    VICIntSelect &= ~(1<<15);   
    VICVectCntl2 = (1<<5)|15;
    VICVectAddr2 = (long)ext_isr;
    VICIntEnable = (1<<15);
    
    EXTMODE = 1<<1;  
    
    EXTPOLAR = (1<<1); 
    
}

void ext_isr(void)__irq
{
    blink_led(24);
    EXTINT = 1<<1; 
    VICVectAddr = 0x00000000;
}

void blink_led(int led)
{
        IOSET1 = 1<<led;  
        delay_ms(100);
        IOCLR1 = 1<<led;   
        delay_ms(100);
}

void delay_ms(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}





",43,1307,440
"#define LED_ALL (0xFF<<17)
void delay(int );
void blink_led(int );

int main()
{
    IODIR1 = IODIR1 | LED_ALL ;  
    IODIR1 = IODIR1 & ~(1<<25);  




    while(1)
    {
        if(IOPIN1 & (1<<25))
        {
            IOSET1 = 0x0F<<17;
        }
        
    }
}



void blink_led(int led)
{
        IOSET1 = 1<<led;  
        delay(100);
        IOCLR1 = 1<<led;   
        delay(100);
}

void delay(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}
",43,1308,245
"#include ""../lcd_header.h""
void i2c_init(void);
void i2c_Start(void);
void i2c_tx_data(char );
char i2c_rx_data(void);
void i2c_stop(void);

int main()
{   
    char i2c_rdata;
    lcd_config();
    i2c_init();
    
    i2c_Start();
    i2c_tx_data(0xA0);          
    i2c_tx_data(0x01);          
    
    I2CONSET = (1<<2);          
    
    i2c_Start();                        
    i2c_tx_data(0xA1);          
    
    i2c_rdata = i2c_rx_data();
    lcd_data(i2c_rdata);        
    i2c_rdata = i2c_rx_data();
    lcd_data(i2c_rdata);        
    i2c_rdata = i2c_rx_data();
    lcd_data(i2c_rdata);        
    i2c_rdata = i2c_rx_data();
    lcd_data(i2c_rdata);        
    i2c_rdata = i2c_rx_data();
    lcd_data(i2c_rdata);        
    i2c_rdata = i2c_rx_data();
    lcd_data(i2c_rdata);        
    
    i2c_stop();

    lcd_cmd(0xC0);
    lcd_str(""Data from EEPROM"");
}

void i2c_init(void)
{
    PINSEL0 |= (1<<4)|(1<<6);
    PINSEL0 &= ~((1<<5)|(1<<7));        
    I2CONSET = 1<<6;                                
    I2SCLH = 75;                                        
    I2SCLL = 75;
}

void i2c_Start(void)
{
    I2CONCLR = (1<<3);      
    I2CONSET = (1<<5);          
    while(!(I2CONSET &(1<<3)));
    I2CONCLR = (1<<5);          
    I2CONCLR = (1<<3);          
}

void i2c_tx_data(char idata)
{
    I2DAT = idata;
    while(!(I2CONSET &(1<<3)));
    I2CONCLR = (1<<3);          
}

char i2c_rx_data(void)
{
    char recv_data;
    while(!(I2CONSET &(1<<3)));
    I2CONCLR = (1<<3);
    recv_data = I2DAT;
    return recv_data;
}

void i2c_stop(void)
{
    I2CONSET = (1<<4);
}
",43,1309,751
"#define LED_ALL (0xFF<<17)

void blink_led(int);
void delay(int);

int main()
{
    IODIR1 = IODIR1 | LED_ALL ;  
    T0PR = 14;
    T0MR0 = 2000000;
    T0MCR = (1<<0)|(1<<1);  
    T0TCR = (1<<1);     
    T0TCR = (1<<0);  
    while(1)
    {
        if(T0IR & (1<<0))  
        {
            blink_led(17);
            T0IR = (1<<0); 
        }
    }
    
}

void blink_led(int led)
{
        IOSET1 = 1<<led;  
        delay(100);
        IOCLR1 = 1<<led;   
        delay(100);
}

void delay(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}
",43,1310,298
"int main()
{
    IODIR1 = IODIR1 | (0xFF<<17);       
    T0PR = 14;                                          
    T0MR0 = 1000000;                                
    T0MR1 = 2000000;                                
    T0MR2 = 3000000;                                
    T0MR3   = 4000000;                              
    T0MCR   = (1<<0)|(1<<3)|(1<<6)|(1<<9)|(1<<10);      
    T0TCR   = (1<<0);                                   
    while(1)
    {
        if(T0IR & (1<<0))                           
        {
            IOSET1 = (1<<17);
            T0IR = 1<<0;                                
        }
        
        if(T0IR & (1<<1))                           
        {
            IOCLR1 = (1<<17);
            T0IR = 1<<1;                                
        }
        if(T0IR & (1<<2))                           
        {
            IOSET1 = (1<<24);
            T0IR = 1<<2;                                
        }
        
        if(T0IR & (1<<3))                           
        {
            IOCLR1 = (1<<24);
            T0IR = 1<<3;                                
        }
    }
}
",43,1311,366
"#define RS (1<<10)
#define RW (1<<12)
#define EN (1<<13)
#define DATA (0xFF<<15)

void delay(int);
void lcd_config(void);
void lcd_cmd(char );
void lcd_data(char );
void lcd_str(char []);
void lcd_num(int );

int main()
{

    int num = 12345678;

    lcd_config();
    
    lcd_num(num);






    
    






    






}

void lcd_config(void)
{
    IODIR0 = IODIR0 | RS | RW | EN | DATA; 
    
    lcd_cmd(0x38);  
    lcd_cmd(0x0E);  
    lcd_cmd(0x01);  
    lcd_cmd(0x80);  
}

void lcd_cmd(char c)
{
    
    
    
    IOCLR0 = DATA;    
    IOSET0 = c<<15;
    IOCLR0 = RW;    
    IOCLR0 = RS;    
    IOSET0 = EN;
    delay(100);
    IOCLR0 = EN;    
}

void lcd_data(char d)
{
    IOCLR0 = DATA;
    IOSET0 = d <<15;
    IOCLR0 = RW;
    IOSET0 = RS;
    IOSET0 = EN;
    delay(100);
    IOCLR0 = EN;
}

void lcd_str(char str[])
{
    for(int i=0;str[i]!='\0';i++)
    {
        lcd_data(str[i]);
    }





}

void lcd_num(int num)
{
    if(num)
    {
        lcd_num(num/10);
        lcd_data(num%10 + 0x30);
    }
}

void delay(int ct)
{
    for(int i =0 ;i<ct; i++)
    {
        for(int j=0;j<6000;++j)
        {
        }
    }
}
















",43,1312,616
"#include ""../lcd_header.h""

#define ROW (0x0F<<21)    
#define COL (0x0F<<17)   
void rows(void);
void row_key(void);
void col_key(void);
int main()
{
    

    lcd_config();
    while(1)
    {
        col_key();
    }   
}


void col_key(void)
{
        int val;
        IODIR1 = IODIR1 & ~(COL);  
        IODIR1 = IODIR1 | (ROW);  
    
        val = (IOPIN1 & COL); 
        val = val >> 17;
        
        switch(val)
        {
            case 0x0E: 
                lcd_str(""C1"");
                delay(500);
                break;
            case 0x0D:
                lcd_str(""C2"");
                delay(500);
                break;
            case 0x0B:
                lcd_str(""C3"");
                delay(500);
                break;
            case 0x07:
                lcd_str(""C4"");
                delay(500);
                break;
            default:
                delay(1000);
                lcd_cmd(0x01);
            
        }

}


",43,1313,343
"void delay(int);

int main()
{
    int flag = 0;
    IODIR1 |= (0xFF<<17);       
    IODIR1 = IODIR1 & ~(1<<25);     
    while(1)
    {
        if(IOPIN1 & (1<<25))  
        {
            if(flag == 0)               
            {
                IOSET1 = 1<<17;
                delay(500);
                flag = 1;
            }
            else if(flag ==1)       
            {
                IOCLR1 = 1<<17;
                delay(500);
                flag = 0;
            }
        }
    }
}

void delay(int ct)
{
    for(int i=0;i<ct;++i)
    {
        for(int j=0;j<6000;j++)
        {}
    }
}





",43,1314,239
"#include ""../lcd_header.h""

#define ROW (0x0F<<21)    
#define COL (0x0F<<17)    
void row_key(void);
void col_key1(void);
void col_key2(void);
void col_key3(void);
void col_key4(void);
int main()
{
    lcd_config();
    while(1)
    {
        row_key();
    }   
}

void row_key(void)
{
        int val;
        IODIR1 = IODIR1 & ~(ROW);
        IODIR1 = IODIR1 | (COL);
        val = (IOPIN1 & ROW); 
        val = val >> 21;
        switch(val)
        {
            case 0x0E: 
                col_key1();  
                break;
            case 0x0D:
                col_key2();  
                break;
            case 0x0B:
                col_key3();  
                break;
            case 0x07:
                col_key4();  
                break;



        }
}

void col_key1(void)
{
        int val;
        IODIR1 = IODIR1 & ~(COL);  
        IODIR1 = IODIR1 | (ROW);  
        val = (IOPIN1 & COL); 
        val = val >> 17;
        switch(val)
        {
            case 0x0E: 
                lcd_data('1');
                delay(500);
                break;
            case 0x0D:
                lcd_data('2');
                delay(500);
                break;
            case 0x0B:
                lcd_data('3');
                delay(500);
                break;
            case 0x07:
                lcd_data('+');
                delay(500);
                break;
                        
        }
}

void col_key2(void)
{
        int val;
        IODIR1 = IODIR1 & ~(COL);  
        IODIR1 = IODIR1 | (ROW);  
        val = (IOPIN1 & COL); 
        val = val >> 17;
        switch(val)
        {
            case 0x0E: 
                lcd_data('4');
                delay(500);
                break;
            case 0x0D:
                lcd_data('5');
                delay(500);
                break;
            case 0x0B:
                lcd_data('6');
                delay(500);
                break;
            case 0x07:
                lcd_data('-');
                delay(500);
                break;
                    
        }
}
void col_key3(void)
{
        int val;
        IODIR1 = IODIR1 & ~(COL);  
        IODIR1 = IODIR1 | (ROW);  
        val = (IOPIN1 & COL); 
        val = val >> 17;
        switch(val)
        {
            case 0x0E: 
                lcd_data('7');
                delay(500);
                break;
            case 0x0D:
                lcd_data('8');
                delay(500);
                break;
            case 0x0B:
                lcd_data('9');
                delay(500);
                break;
            case 0x07:
                lcd_data('*');
                delay(500);
                break;
                        
        }
}

void col_key4(void)
{
        int val;
        IODIR1 = IODIR1 & ~(COL);  
        IODIR1 = IODIR1 | (ROW);  
        val = (IOPIN1 & COL); 
        val = val >> 17;
        switch(val)
        {
            case 0x0E: 
                lcd_data('#');
                delay(500);
                break;
            case 0x0D:
                lcd_data('0');
                delay(500);
                break;
            case 0x0B:
                lcd_data('=');
                delay(500);
                break;
            case 0x07:
                lcd_data('/');
                delay(500);
                break;
                        
        }
}





",43,1315,1119
"#define LED_ALL (0xff<<17)
#define LED1    (1<<17)         
#define LED2    (1<<18)         
void delay(int);

int main()
{
    IODIR1 = IODIR1 | LED_ALL;
    
    while(1)
    {
        for(int i=17; i<= 24;i++)
        {
        IOSET1 = 1<<i;
        delay(1000);
        }
        IOCLR1 = LED_ALL;
        delay(1000);
    }
}

void delay(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}
",43,1316,209
"#include ""..\lcd_header.h""

int main()
{
    char var;
    PINSEL0 |= (1<<0)|(1<<2);   
    PINSEL0 &= ~((1<<1)|(1<<3));
    lcd_config();
    U0LCR = (1<<7);     
    U0DLL = 97;             
    U0DLM = 0;
    U0LCR &= ~(1<<7);   
    U0LCR = (1<<0)|(1<<1); 
    
    while(1)
    {
        while(!(U0LSR & (1<<0)));   
            var = U0RBR;            
            lcd_data(var);
    }
}


















",43,1317,207
"#include ""../lcd_header.h""

#define ROW (0x0F<<21)    
#define COL (0x0F<<17)    
void rows(void);
void row_key(void);
void col_key(void);
int main()
{
    




    lcd_config();
    while(1)
    {
        row_key();
    }   
}

void row_key(void)
{
        int val;
        IODIR1 = IODIR1 & ~(ROW);
        IODIR1 = IODIR1 | (COL);
    
        val = (IOPIN1 & ROW); 
        val = val >> 21;
        
        switch(val)
        {
            case 0x0E: 
                lcd_str(""R1"");
                delay(500);
                break;
            case 0x0D:
                lcd_str(""R2"");
                delay(500);
                break;
            case 0x0B:
                lcd_str(""R3"");
                delay(500);
                break;
            case 0x07:
                lcd_str(""R4"");
                delay(500);
                break;
            default:
                delay(1000);
                lcd_cmd(0x01);
        }
}

void col_key(void)
{
        int val;
        IODIR1 = IODIR1 & ~(COL);  
        IODIR1 = IODIR1 | (ROW);  
    
        val = (IOPIN1 & COL); 
        val = val >> 21;
        
        switch(val)
        {
            case 0x0E: 
                lcd_str(""C1"");
                delay(500);
                break;
            case 0x0D:
                lcd_str(""C2"");
                delay(500);
                break;
            case 0x0B:
                lcd_str(""C3"");
                delay(500);
                break;
            case 0x07:
                lcd_str(""C4"");
                delay(500);
                break;
            default:
                delay(1000);
                lcd_cmd(0x01);
            
        }

}

void rows(void)
{
        int val;
        IODIR1 = IODIR1 & ~(ROW);
        IODIR1 = IODIR1 | (COL);
    
        val = (IOPIN1 & ROW); 
        val = val >> 17;
        if(val == 0x0E)
        {
            lcd_str(""row1"");
            delay(500);
        }
        if(val == 0x0D)
        {
            lcd_str(""row2"");
            delay(500);
        }
        if(val == 0x0B)
        {
            lcd_str(""row3"");
            delay(500);
        }
        if(val == 0x07)
        {
            lcd_str(""Row4"");
            delay(500);
        }
        delay(1000);
        lcd_cmd(0x01);
}
",43,1318,812
"void delay(int );
void blink_LED(int );

int main()
{
    IODIR1 = IODIR1 | (0xFF<<17);       
    T0PR = 14;                  
    T0MR0 = 5000000;        
    T0MCR   = (1<<0)|(1<<1);            
    T0TCR   = (1<<0);           
    while(1)
    {
        blink_LED(24);

        while(!(T0IR & (1<<0)))         
        {}
        blink_LED(17);
        T0IR = 1<<0;            

    }
}

void blink_LED(int led)
{
    IOSET1 = 1<<led;
    delay(300);             
    IOCLR1 = 1<<led;
    delay(300);             
}

void delay(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)             
        {}
    }
}
",43,1319,288
"#define LED_ALL (0xFF<<17)

void blink_led(int);
void delay(int);

int main()
{
    IODIR1 = IODIR1 | LED_ALL ;  
    T0PR = 14;
    T0MR0 = 1000000;
    T0MR1 = 2000000;
    T0MCR = (1<<0)|(1<<3)|(1<<4);   
    T0TCR = (1<<1);     
    T0TCR = (1<<0);  
    while(1)
    {
        if(T0IR & (1<<0))  
        {
            IOSET1 = 1<<17;
            T0IR = (1<<0); 
        }
        else if(T0IR & (1<<1))  
        {
            IOCLR1 = 1<<17;
            T0IR = (1<<1); 
        }
    }
    
}

void blink_led(int led)
{
        IOSET1 = 1<<led;  
        delay(100);
        IOCLR1 = 1<<led;   
        delay(100);
}

void delay(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}










",43,1320,377
"#define LED_ALL (0xFF<<17)

void delay_ms(int );
void blink_led(int );
void timer1_isr(void)__irq;
void timer_config(void);
void intr_config(void);

int main()
{
        IODIR1 = IODIR1| LED_ALL;
        timer_config();
        intr_config();
        while(1)
        {
            blink_led(17);
        }
}

void timer_config(void)
{
    
        T1PR = 14;
        T1MR0 = 2000000;
        T1MCR = (1<<0)|(1<<1);
        T1TCR = (1<<0);
}

void intr_config(void)
{
    
        VICIntSelect = VICIntSelect & ~((1<<4)|(1<<5)); 
        VICVectCntl1 = (1<<5)|5;   
        VICVectAddr1 = (long)&timer1_isr;       
        VICIntEnable = (1<<4)|(1<<5);   
}
void timer1_isr(void)__irq
{
    IOSET1 = 1<<24;  
    delay_ms(100);
    IOCLR1 = 1<<24;   
    delay_ms(100);
    T1IR = 1<<0;            
    VICVectAddr = 0x00000000;  
    
}
void blink_led(int led)
{
        IOSET1 = 1<<led;  
        delay_ms(100);
        IOCLR1 = 1<<led;   
        delay_ms(100);
}

void delay_ms(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}





",43,1321,513
"#include ""../lcd_header.h""
#define ROWS (0x0F<<21)
#define COLS (0x0F<<17)

int main()
{
    int val;



    IODIR1 = IODIR1 & ~ROWS;        
    IODIR1 = IODIR1 | COLS;         
    lcd_config();
    while(1)
    {
        val = IOPIN1 & ROWS;        
        val = val >> 21;
        switch(val)
        {
            case 0x0E:  lcd_str(""r1"");  delay(300); break;
            case 0x0D:  lcd_str(""r2"");  delay(300); break;
            case 0x0B:  lcd_str(""r3"");  delay(300); break;
            case 0x07:  lcd_str(""r4"");  delay(300); break;
        }
    }
}
",43,1322,248
"void delay(int);

int main()
{
    int flag = 0;
    IODIR0 = IODIR0 | (1<<11);      
    IODIR1 = IODIR1 & ~(1<<25);     
    while(1)
    {
        if(IOPIN1 & (1<<25))  
        {
            IOSET0 = 1<<11;
            delay(100);
            IOCLR0 = 1<<11;
            delay(100);         
        }
    }
}

void delay(int ct)
{
    for(int i=0;i<ct;++i)
    {
        for(int j=0;j<6000;j++)
        {}
    }
}





",43,1323,195
"#define LED_ALL (0xFF<<17)

void blink_led(int);
void delay(int);

int main()
{
    IODIR1 = IODIR1 | LED_ALL ;  
    T0PR = 14;
    T0MR0 = 3000000;
    T0MCR = (1<<0)|(1<<1);  
    T0TCR = (1<<1);     
    T0TCR = (1<<0);  
    while(1)
    {
        blink_led(17);

        while(!(T0IR & (1<<0))) 
        {}
                
            blink_led(24);
            T0IR = (1<<0); 

        blink_led(18);
        blink_led(19);
        blink_led(20);
        blink_led(21);

        
        
    }
    
}

void blink_led(int led)
{
        IOSET1 = 1<<led;  
        delay(100);
        IOCLR1 = 1<<led;   
        delay(100);
}

void delay(int ct)
{
    int i,j;
    for(i=0;i<ct;++i)
    {
        for(j=0;j<6000;++j)
        {}
    }
}
",43,1324,355
"bool is_pass(bool* info) {
    for (int i = 0; i < 7; i++)
        if (!info[i]) return false;
    return true;
}

char *get_field(size_t *n, FILE *f) { 
    char *field = calloc(sizeof(char), 20);
    size_t i = 0;
    for (char cur = fgetc(f); cur != ' ' && cur != '\n'; cur = fgetc(f)) {
        field[i] = cur;
        i++;
    }
    *n = i;
    return field;
}

bool is_hair_color(char *field, size_t n) {
    if (field[0] != '#') return false;
    for (size_t i = 1; i < n; i++)
        if ((field[i] < '0' || '9' < field[i])
            && (field[i] < 'a' || 'f' < field[i]))
            return false;
    return true;
}

bool is_eye_color(char *field) {
    return strcmp(field, ""amb"") == 0 || strcmp(field, ""blu"") == 0
        || strcmp(field, ""brn"") == 0 || strcmp(field, ""gry"") == 0
        || strcmp(field, ""grn"") == 0 || strcmp(field, ""hzl"") == 0
        || strcmp(field, ""oth"") == 0;
}

bool is_pid(char *field, size_t n) {
    if (n != 9) return false;
    for (size_t i = 0; i < n; i++) {
        if (!isdigit(field[i])) return false;
    }
    return true;
}

int main() {
    char *filename = ""Passports.txt"";
    FILE *f = fopen(filename, ""r"");
    size_t count = 0;

    bool *valids = calloc(sizeof(bool), 7);
    char *curs = calloc(sizeof(char), 3);

    for (char cur = fgetc(f); cur != EOF; cur = fgetc(f)) {
        if (cur == ':') switch (curs[0] + curs[1] + curs[2]) {
            case 333: { 
                size_t n = 0;
                char *field = get_field(&n, f);
                char *tmp = NULL;
                int byr = strtol(field, &tmp, 10);
                if (1920 <= byr && byr <= 2002)
                    valids[0] = true;
                free(field); break;
            } case 340: { 
                size_t n = 0;
                char *field = get_field(&n, f);
                char *tmp = NULL;
                int iyr = strtol(field, &tmp, 10);
                if (2010 <= iyr && iyr <= 2020)
                    valids[1] = true;
                free(field); break;
            } case 336: { 
                size_t n = 0;
                char *field = get_field(&n, f);
                char *tmp = NULL;
                int eyr = strtol(field, &tmp, 10);
                if (2020 <= eyr && eyr <= 2030)
                    valids[2] = true;
                free(field); break;
            } case 323: { 
                size_t n = 0;
                char *field = get_field(&n, f);
                char *tmp = NULL;
                int hgt = strtol(field, &tmp, 10);
                if (strcmp(tmp, ""cm"") == 0 && 150 <= hgt && hgt <= 193
                    || strcmp(tmp, ""in"") == 0 && 59 <= hgt && hgt <= 76)
                    valids[3] = true;
                free(field); break;
            } case 311: { 
                size_t n = 0;
                char *field = get_field(&n, f);
                if (is_hair_color(field, n))
                    valids[4] = true;
                free(field); break;
            } case 308: { 
                size_t n = 0;
                char *field = get_field(&n, f);
                if (is_eye_color(field))
                    valids[5] = true;
                free(field); break;
            } case 317: { 
                size_t n = 0;
                char *field = get_field(&n, f);
                if (is_pid(field, n))
                    valids[6] = true;
                free(field); break;
            } case 304: { 
                size_t n = 0;
                char *field = get_field(&n, f);
                free(field); break;
            }
        }
        
        if (cur == '\n') {
            if (is_pass(valids)) count++;
            free(valids);
            valids = calloc(sizeof(bool), 7);
        }
        curs[0] = curs[1];
        curs[1] = curs[2];
        curs[2] = cur;
    }

    printf(""Answer: %zu\n"", count);

    free(valids);
    free(curs);
    fclose(f);

    return 0;
}",44,1325,1402
"size_t num_rows(char *filename) {
    size_t n = 0;
    FILE *f = fopen(filename, ""r"");
    for (char c = fgetc(f); c != EOF; c = fgetc(f))
        if (c == '\n') n++;
    fclose(f);
    return n;
}

size_t num_cols(char *filename) {
    size_t m = 0;
    FILE *f = fopen(filename, ""r"");
    for (char c = fgetc(f); c != '\n'; c = fgetc(f))
        m++;
    fclose(f);
    return m;
}

bool **get_trees(char *filename, size_t n, size_t m) {
    FILE *f = fopen(filename, ""r"");
    bool **trees = calloc(sizeof(bool*), n);
    for (size_t i = 0; i < n; i++)
        trees[i] = calloc(sizeof(bool), m);
    
    char c;
    for (size_t i = 0; i < n; i++)
        for (size_t j = 0; j < m; j++) {
            c = fgetc(f);
            if (c == '\n') c = fgetc(f);
            if (c == '#') trees[i][j] = true;
        }

    fclose(f);
    return trees;
}

size_t encountered(bool **trees, int n, int m, int rowadd, int coladd) {
    size_t count = 0;
    size_t j = 0;
    for (size_t i = 0; i < n; i += rowadd) {
        if (trees[i][j]) count++;
        j = (j + coladd) % m;
    }

    return count;
}

int main() {
    char *filename = ""Trees.txt"";
    size_t n = num_rows(filename);
    size_t m = num_cols(filename);
    bool **trees = get_trees(filename, n, m);

    size_t count = 1;
    count *= encountered(trees, n, m, 1, 1);
    count *= encountered(trees, n, m, 1, 3);
    count *= encountered(trees, n, m, 1, 5);
    count *= encountered(trees, n, m, 1, 7);
    count *= encountered(trees, n, m, 2, 1);
    printf(""Answer: %zu\n"", count);

    for (size_t i = 0; i < n; i++)
        free(trees[i]);
    free(trees);
    
    return 0;
}",44,1326,688
"int main() {
    char *filename = ""num.txt"";
    FILE *f = fopen(filename, ""r"");

    size_t num_ints = 0;
    for (char c = fgetc(f); c != EOF; c = fgetc(f)) {
        if (isdigit(c))
            num_ints++;
    }
    fclose(f);
    size_t *digits = calloc(sizeof(size_t), num_ints);
    f = fopen(filename, ""r"");
    for (size_t i = 0; i < num_ints; i++) {
        char c = fgetc(f);
        if (!isdigit(c))
            c = fgetc(f);
        digits[i] = c - '0';
    }
    size_t max_prod = 0;
    for (size_t i = 0; i < num_ints - 12; i++) {
        size_t tmp_prod = digits[i] * digits[i + 1] * digits[i + 2] * digits[i + 3]
                        * digits[i + 4] * digits[i + 5] * digits[i + 6] * digits[i + 7]
                        * digits[i + 8] * digits[i + 9] * digits[i + 10]
                        * digits[i + 11] * digits[i + 12];
        if (tmp_prod > max_prod)
            max_prod = tmp_prod;
    }
    printf(""Answer: %zu\n"", max_prod);
    free(digits);
    fclose(f);
    return 0;
}",44,1327,414
"int main() {
    char *filename = ""Passwords.txt"";
    FILE *f = fopen(filename, ""r"");
    char *line = NULL;
    size_t n = 0;
    size_t valids = 0;
    while (getline(&line, &n, f) != -1) {
        char *str = strchr(line, ':');
        char *pass = calloc(sizeof(char), strlen(str) - 2);
        strcpy(pass, &str[2]);
        int i = strtol(line, &line, 10);
        line++;
        int j = strtol(line, &line, 10);
        char c = line[1];
        
        if ((pass[i - 1] == c || pass[j - 1] == c) && pass[i - 1] != pass[j - 1])
            valids++;

        free(pass);
    }

    printf(""Answer: %zu\n"", valids);
    fclose(f);

    return 0;
}",44,1328,261
"size_t count_yes(size_t *yes, size_t num) {
    size_t count = 0;
    for (size_t i = 0; i < 26; i++)
        if (yes[i] == num) count++;
    return count;
}

int main() {
    char *filename = ""Answers.txt"";
    FILE *f = fopen(filename, ""r"");
    size_t *yes = calloc(sizeof(size_t), 26);
    char *person = NULL; size_t n = 0;
    size_t num = 0; size_t count = 0;

    while (getline(&person, &n, f) != -1) {
        if (strcmp(person, ""\n"") == 0) {
            count += count_yes(yes, num);
            free(yes); yes = calloc(sizeof(size_t), 26);
            num = 0;
        } else {
            num++;
            for (size_t i = 0; i < strlen(person) - 1; i++)
                yes[person[i] - 'a']++;
        }
    }
    printf(""Answer: %zu\n"", count);
    fclose(f);
    return 0;
}",44,1329,315
"size_t num_rows(char *filename) {
    size_t n = 0;
    FILE *f = fopen(filename, ""r"");
    for (char c = fgetc(f); c != EOF; c = fgetc(f))
        if (c == '\n') n++;
    fclose(f);
    return n;
}

size_t num_cols(char *filename) {
    size_t m = 0;
    FILE *f = fopen(filename, ""r"");
    for (char c = fgetc(f); c != '\n'; c = fgetc(f))
        m++;
    fclose(f);
    return m;
}

bool **get_trees(char *filename, size_t n, size_t m) {
    FILE *f = fopen(filename, ""r"");
    bool **trees = calloc(sizeof(bool*), n);
    for (size_t i = 0; i < n; i++)
        trees[i] = calloc(sizeof(bool), m);
    
    char c;
    for (size_t i = 0; i < n; i++)
        for (size_t j = 0; j < m; j++) {
            c = fgetc(f);
            if (c == '\n') c = fgetc(f);
            if (c == '#') trees[i][j] = true;
        }

    fclose(f);
    return trees;
}

int main() {
    char *filename = ""Trees.txt"";
    size_t n = num_rows(filename);
    size_t m = num_cols(filename);
    bool **trees = get_trees(filename, n, m);

    size_t count = 0;
    size_t j = 0;
    for (size_t i = 0; i < n; i++) {
        if (trees[i][j]) count++;
        j = (j + 3) % m;
    }
    printf(""Answer: %zu\n"", count);

    for (size_t i = 0; i < n; i++)
        free(trees[i]);
    free(trees);
    
    return 0;
}",44,1330,546
"int main() {
    char *filename = ""num.txt"";
    FILE *f = fopen(filename, ""r"");
    char *line = NULL; size_t len = 0; char *tmp = NULL;
    getline(&line, &len, f);
    size_t p = strtol(line, &tmp, 10);
    size_t size = ceil(sqrt(p));
    bool *primes = calloc(sizeof(bool), size + 1); 

    for (size_t i = 2; i < size + 1; i++) {
        if (!primes[i])
            for (size_t j = 2 * i; j < size + 1; j += i)
                primes[j] = true;
    }
    size_t maxp = 0;
    for (size_t i = 2; i < size + 1; i++) {
        if (!primes[i] && p % i == 0 && i > maxp)
            maxp = i;
    }
    printf(""Answer: %zu\n"", maxp);
    free(primes);
    fclose(f); free(line);
    return 0;
}",44,1331,291
"size_t find_empty(bool *seats) {
    for (size_t i = 8; i < 126 * 8 + 7; i++)
        if (seats[i - 1] && !seats[i] && seats[i + 1]) return i;
    return 0;
}

int main() {
    char *filename = ""Seats.txt"";
    FILE *f = fopen(filename, ""r"");
    bool *seats = calloc(sizeof(bool), 128 * 8);
    char *seat = NULL; size_t n = 0;

    while (getline(&seat, &n, f) != -1) {
        size_t low = 0; size_t high = 127;
        for (int i = 0; i < 7; i++) {
            if (seat[i] == 'F') high -= (high - low + 1) / 2;
            else low += (high - low + 1) / 2;
        }
        size_t row = low;
        low = 0; high = 7;
        for (int i = 7; i < 10; i++) {
            if (seat[i] == 'L') high -= (high - low + 1) / 2;
            else low += (high - low + 1) / 2;
        }
        size_t col = low;
        size_t id = row * 8 + col;
        seats[id] = true;
    }
    printf(""Answer: %zu\n"", find_empty(seats));
    free(seat);
    free(seats);
    fclose(f);
    return 0;
}",44,1332,424
"int main() {
    char *filename = ""num.txt"";
    FILE *f = fopen(filename, ""r"");
    char *line = NULL; size_t len = 0; char *thing = NULL;
    getline(&line, &len, f);
    
    size_t max = strtol(line, &thing, 10);
    size_t *primes = calloc(sizeof(size_t), max / 4);
    size_t num = 0;
    for (size_t test = 2; test < max; test++) {
        bool isPrime = true;
        for (size_t i = 0; i < num; i++) {
            if (test % primes[i] == 0)
                isPrime = false;
        }
        if (isPrime) {
            primes[num] = test;
            num++;
        }
    }
    
    size_t sum = 0;
    for (size_t i = 0; i < num; i++)
        sum += primes[i];
    printf(""Answer: %zu\n"", sum);
    free(primes);
    fclose(f);
    free(line);
    return 0;
}",44,1333,299
"int num_digits(size_t i) {
    if (i < 10) return 1;
    return 1 + num_digits(i / 10);
}

int power(size_t x, size_t y) {
    if (y == 0) return 1;
    return x * pow(x, y - 1);
}

bool is_palin(size_t i, size_t num_digits) {
    if (num_digits < 2) return true;
    return i % 10 == i / power(10, num_digits - 1)
        && is_palin((i % power(10, num_digits - 1)) / 10, num_digits - 2);
}

int main() {
    size_t max_palin = 0;
    for (size_t i = 100; i < 1000; i++)
        for (size_t j = i; j < 1000; j++)
            if (is_palin(i * j, num_digits(i * j)) && i * j > max_palin)
                max_palin = i * j;
    printf(""Answer: %zu\n"", max_palin);
    return 0;
}",44,1334,320
"#define m 3
#define n 4
int available[m],allocation[n][m],request[n][m];
int safety_module()
{
    int work[m],finish[n],i,j,flag=0,set;
    for(i=0;i<m;i++)
        work[i]=available[i];
    for(i=0;i<n;i++)
    {
        flag=0;
        for(j=0;j<m;j++)
        {
            if(allocation[i][j]!=0)
            {
                flag=1;
                break;
            }
            else
                continue;
        }
        if(flag==1)
            finish[i]=0;
        else
            finish[i]=1;
    }
    while(1)
    {
        set=-1;
        for(i=0;i<n;i++)
        {
            flag=0;
            for(j=0;j<m;j++)
            {
                if(request[i][j]<=work[j])
                    continue;
                else
                {
                    flag=1;
                    break;
                }
            }
            if(flag==0 && finish[i]==0)
            {
                set=i;
                finish[i]=1;
                for(j=0;j<m;j++)
                    work[j]=work[j]+allocation[i][j];
                break;
            }
        }
        if(set==-1)
            break;
        else
            continue;
    }
    flag=0;
    printf(""\nProcessess in deadlock are : \n"");
    for(i=0;i<n;i++)
    {
        if(finish[i]!=1)
        {
            printf(""%d\t"",i);
            flag=-1;
        }
    }
    if(flag==0)
        return(1);
    else
        return(0);
}
void main()
{
    int i,j,s;
    printf(""\nEnter the available resources  : "");
    for(i=0;i<m;i++)
        scanf(""%d"",&available[i]);
    printf(""\nEnter allocation : "");    
    for(i=0;i<n;i++)
    {
        printf(""\nfor process %d : "",i);
        for(j=0;j<m;j++)
        {
            scanf(""%d"",&allocation[i][j]);
        }
    }
    printf(""\nEnter request : \n"");
    for(i=0;i<n;i++)
    {
        printf(""\nfor process %d : "",i);
        for(j=0;j<m;j++)
        {
            scanf(""%d"",&request[i][j]);
        }
    }
    s=safety_module();
    if(s==1)
        printf(""No Deadlock"");
    else
        printf(""\nDeadlock"");
}",45,1335,739
"int Mem,block;
struct program
{
    char name[10];
    int If,size,status;
};
void main()
{
    int n,i,size,IF=0,EF=0;
    printf(""\nEnter the size of memory : "");
    scanf(""%d"",&Mem);
    printf(""\nEnter size of each block : "");
    scanf(""%d"",&block);
    printf(""\nEnter the number of programs : "");
    scanf(""%d"",&n);
    struct program p[n];
    for(i=0;i<n;i++)
    {
        printf(""\nEnter name : "");
        scanf(""%s"",p[i].name);
        printf(""\nEnter size : "");
        scanf(""%d"",&p[i].size);
        p[i].If=0;
        p[i].status=0;
    }
    for(i=0;i<n;i++)
    {
        if(p[i].size<=block)
        {
            p[i].status=1;
            p[i].If=block-p[i].size;
            IF=IF+p[i].If;
        }
        else
        {
            EF=EF+block;
        }
    }
    printf(""\nprogram\tsize\tIF\n"");
    for(i=0;i<n;i++)
        printf(""%s\t%d\t%d\n"",p[i].name,p[i].size,p[i].If);
    printf(""\nTotal Internal Fragmentation is : %d"",IF);
    printf(""\nTotal External Fragmentation is : %d"",EF);
}",45,1336,402
"void Brute_Force(char S[],char P[],int n,int m)
{
    int i=0,j=0;
    int flag=-1;
    while(i<n && j<m)
    {
        if(P[j]==S[i])
        {
            i=i+1;
            j=j+1;
        }
        else
        {
            i=i+1;
            j=0;
        }
    if(j==m)
    {
        flag=1;
        printf(""\npattern found at %d"",(i-j+1));
        j=0;
    }
}
    if(flag==-1)
    {
        printf(""pattern not found"");
    }
}
void main()
{
    int n,m,i;
    char S[100],P[100];
    printf(""\nEnter String:"");
    gets(S);
    printf(""\nEnter Pattern:"");
    gets(P);
    n=strlen(S);
    m=strlen(P);
    Brute_Force(S,P,n,m);
}
",45,1337,282
"struct list
{
    int val;
    struct list* next;
}*front=NULL,*rear=NULL,*temp=NULL,*q=NULL;
int value,i=0;
void insert(int tar)
{
    struct list* p=(struct list*)malloc(sizeof(struct list));
    p->val=tar;
    p->next=NULL;
    if(rear==NULL)
    {
        front=rear=p;
    }
    else
    {
        rear->next=p;
        rear=p;
        rear->next=front;
    }
}
void delete(int tar)
{
    if(rear==NULL)
    {
        printf(""\nlist is empty"");
    }
    else
    {
        temp=front;
        q=front;
        while(temp!=rear)
        {
            if(temp->val==tar)
            {
                if(temp==front)
                {
                    front=front->next;
                    rear->next=front;
                    free(temp);
                    temp=front;
                }
                else
                {
                    q->next=temp->next;
                    free(temp);
                    temp=q->next;
                }
            }
            q=temp;
            temp=temp->next;
        }
        if(temp->val==tar)
        {
            q->next=front;
            temp=NULL;
            free(temp);
        }
    }
}
void search(int tar)
{
    if(rear==NULL)
    {
        printf(""\nlist is empty"");
    }
    else
    {
        for(temp=front;temp!=rear;temp=temp->next)
        {
            if(temp->val==tar)
            {
                printf(""\nvalue found"");
                i++;
            }
        }
        if(temp->val==tar)
        {
            printf(""\nvalue found"");
            i++;
        }
    }
    if(i==0)
    printf(""\nvalue not found in the list"");
}
void display()
{
    if(rear==NULL)
    printf(""\nlist is empty"");
    else
    {
        printf(""\nList is:\n"");
        for(temp=front;temp!=rear;temp=temp->next)
        {
            printf(""\t%d"",temp->val);
        }
        printf(""\t%d"",temp->val);
        printf(""\t%d"",temp->next->val);
    }
}
void main()
{
    int ch;
    while(1)
    {
        printf(""\nEnter choice:"");
        scanf(""%d"",&ch);
        switch(ch)
        {
            case 1:
            {
                printf(""\nEnter the value to insert:"");
                scanf(""%d"",&value);
                insert(value);
                break;
            }
            case 2:
            {
                printf(""\nEnter the value to delete:"");
                scanf(""%d"",&value);
                delete(value);
                break;
            }
            case 3:
            {
                printf(""\nEnter the value to search:"");
                scanf(""%d"",&value);
                search(value);
                break;
            }
            case 4:
            {
                display();
                break;
            }
            default:
            {
                exit(0);
                break;
            }
        }
    }
}",45,1338,846
"#define m 3
#define n 5
int available[m],max[n][m],allocation[n][m],need[n][m],request[n][m];
int safety_module()
{
    int work[m],finish[n],i,j,flag=0;
    for(i=0;i<m;i++)
        work[i]=available[i];
    for(i=0;i<n;i++)
        finish[i]=0;
    while(1)
    {
        for(i=0;i<n;i++)
        {
            flag=0;
            for(j=0;j<m;j++)
            {
                if(need[i][j]<=work[j])
                    continue;
                else
                {
                    flag=1;
                    break;
                }
            }
            if(flag==0 && finish[i]==0)
            {
                finish[i]=1;
                for(j=0;j<m;j++)
                    work[j]=work[j]+allocation[i][j];
                break;
            }
        }
        if(i==5)
            break;
        else
            continue;
    }
    for(i=0;i<n;i++)
    {
        if(finish[i]!=1)
            break;
    }
    if(i==5)
        return(1);
    else
        return(0);
}
void resource_request(int pr)
{
    int i,s,flag=-1;
    for(i=0;i<m;i++)
    {
        if(request[pr][i]<=need[pr][i])
            continue;
        else
        {
            flag=1;
            break;
        }
    }
    if(flag==1)
        printf(""Terminate!"");
    else
    {
        for(i=0;i<m;i++)
        {
            if(request[pr][i]<=available[i])
                continue;
            else
            {
                flag=1;
                break;
            }
        }   
        if(flag==1)
            printf(""Process has to wait"");
        else
        {
            for(i=0;i<m;i++)
            {
                available[i]=available[i]-request[pr][i];
                allocation[pr][i]=allocation[pr][i]+request[pr][i];
                need[pr][i]=need[pr][i]-request[pr][i];
            }
            s=safety_module();
            if(s==1)
                printf(""\nRequest Granted"");
            else
            {
                printf(""\nRestore"");
                for(i=0;i<m;i++)
                {
                    available[i]=available[i]+request[pr][i];
                    allocation[pr][i]=allocation[pr][i]-request[pr][i];
                    need[pr][i]=need[pr][i]+request[pr][i];
                }
            }
        }
    }
}
void main()
{
    int i,j,pr;
    printf(""\nEnter the available resources  : "");
    for(i=0;i<m;i++)
        scanf(""%d"",&available[i]);
    printf(""\nEnter maximum : "");   
    for(i=0;i<n;i++)
    {
        printf(""\nfor process %d : "",i);
        for(j=0;j<m;j++)
        {
            scanf(""%d"",&max[i][j]);
        }
    }
    printf(""\nEnter allocation : "");    
    for(i=0;i<n;i++)
    {
        printf(""\nfor process %d : "",i);
        for(j=0;j<m;j++)
        {
            scanf(""%d"",&allocation[i][j]);
        }
    }
    for(i=0;i<n;i++)
    {
        for(j=0;j<m;j++)
        {
            need[i][j]=max[i][j]-allocation[i][j];
        }
    }
    printf(""\nenter the process to take request : "");
    scanf(""%d"",&pr);
    printf(""\nEnter request : "");
    for(j=0;j<m;j++)
    {
        scanf(""%d"",&request[pr][j]);
    }
    resource_request(pr);
}",45,1339,1103
"int Mem[16],index1;
struct table
{
    int id,size,indices[16];
}t[16];
int get_count()
{
    int i,ct=0;
    for(i=0;i<16;i++)
    {
        if(Mem[i]==0)
            ct=ct+1;
    }
    return(ct);
}
void rem_program(int id1)
{
    int i,k;
    for(i=0;i<16;i++)
    {
        if(Mem[i]==id1)
        {
            Mem[i]=0;
        }
    }
    for(i=0;i<index1;i++)
    {
        if(t[i].id==id1)
            break;
    }
    t[i].id=-1;
    t[i].size=-1;
    for(k=0;k<16;k++)
    {
        if(t[i].indices[k]!=-1)
            t[i].indices[k]=-1;
        else
            break;
    }
}
void add_program(int id,int size)
{
    int ct=get_count();
    int temp=size;
    int i,k,ch=1,id1;
    if(ct>=size)
    {
        k=0;
        for(i=0;i<16 && size>0;i++)
        {
            if(Mem[i]==0)
            {
                Mem[i]=id;
                size=size-1;
                t[index1].indices[k]=i;
                k++;
            }
        }
        t[index1].id=id;
        t[index1].size=temp;
        t[index1].indices[k]=-1;
        index1=index1+1;
    }
    else
    {
        while(ch==1)
        {
            printf(""\nIs there any possiblity of removing a program : "");
            scanf(""%d"",&ch);
            if(ch==1)
            {
                printf(""\nEnter program id : "");
                scanf(""%d"",&id1);
                rem_program(id1);
            }
            else
            {
                break;
            }
        }
        ct=get_count();
        if(ct>=size)
        {
            k=0;
            for(i=0;i<16 && size>0;i++)
            {
                if(Mem[i]==0)
                {
                    Mem[i]=id;
                    size=size-1;
                    t[index1].indices[k]=i;
                    k++;
                }
            }
            t[index1].id=id;
            t[index1].size=temp;
            t[index1].indices[k]=-1;
            index1=index1+1;
        }
        else
            printf(""\nNot possible"");
    }
}
void display_table()
{
    int i,j;
    printf(""\nProgram_id\tsize\tpages\n"");
    for(i=0;i<index1;i++)
    {
        printf(""\n%d\t%d\t"",t[i].id,t[i].size);
        for(j=0;j<16;j++)
        {
            if(t[i].indices[j]!=-1)
            {
                printf(""%d "",t[i].indices[j]);
            }
            else
            {
                break;
            }
        }
    }
}
void display_Mem()
{
    int i;
    printf(""\nMemory is : "");
    for(i=0;i<16;i++)
        printf(""%d\t"",Mem[i]);
}
void main()
{
    int ch,id,size,i;
    for(i=0;i<16;i++)
        Mem[i]=0;
    while(1)
    {
        printf(""\nEnter choice : "");
        scanf(""%d"",&ch);
        switch(ch)
        {
            case 1: 
            {
                printf(""\nEnter program id : "");
                scanf(""%d"",&id);
                printf(""\nEnter the size in terms of pages : "");
                scanf(""%d"",&size);
                add_program(id,size);
                break;
            }
            case 2:
            {
                printf(""\nEnter program id : "");
                scanf(""%d"",&id);
                rem_program(id);
                break;
            }
            case 3:
            {
                display_table();
                break;
            }
            case 4:
            {   
                display_Mem();
                break;
            }
            default:
            {
                exit(0);
                break;
            }
        }
    }
}
",45,1340,1219
"struct Disk
{
    int id,next_index;
}disk[16];
int ispossible()
{
    int i,ct=0;
    for(i=0;i<16;i++)
    {
        if(disk[i].id==0)
            ct++;
    }
    return(ct);
}
void add_file(int id,int size)
{
    int ct=ispossible(),i,j;
    if(ct>=size)
    {
        for(i=0;i<16 && size>0;i++)
        {
            if(disk[i].id==0)
            {
                disk[i].id=id;
                size--;
                for(j=i+1;j<16;j++)
                {
                    if(disk[j].id==0 && size>0)
                    {
                        disk[i].next_index=j;
                        break;
                    }
                }
            }
        }
    }
    else
    {
        printf(""\nNot possible"");
    }
}
void rem_file(int id)
{
    int i;
    for(i=0;i<16;i++)
    {
        if(disk[i].id==id)
        {
            disk[i].id=0;
            disk[i].next_index=-1;
        }
    }
}
void display()
{
    int i;
    printf(""\nDisk is : ""); 
    for(i=0;i<16;i++)
    {
        printf(""\n%d\t%d"",disk[i].id,disk[i].next_index);
    }
}
void main()
{
    int ch,id,size,i;
    for(i=0;i<16;i++)
    {
        disk[i].id=0;
        disk[i].next_index=-1;
    }
    while(1)
    {
        printf(""\nEnter choice : "");
        scanf(""%d"",&ch);
        switch(ch)
        {
            case 1: 
            {
                printf(""\nEnter file id : "");
                scanf(""%d"",&id);
                printf(""\nEnter size : "");
                scanf(""%d"",&size);
                add_file(id,size);
                break;
            }
            case 2:
            {
                printf(""\nEnter file id : "");
                scanf(""%d"",&id);
                rem_file(id);
                break;
            }
            case 3:
            {
                display();
                break;
            }
            default:
            {
                exit(0);
                break;
            }
        }
    }
}",45,1341,671
"struct Dir
{
    char file;
    struct Dir* next;
}*dir[5],*temp,*q;
int isthere(int d,char name)
{
    int flag=-1;
    temp=dir[d];
    while(temp!=NULL)
    {
        if(temp->file==name)
        {
            flag=1;
            break;
        }
        temp=temp->next;
    }
    return(flag);
}
void add_file(int d,char name)
{
    struct Dir* p=(struct Dir*)malloc(sizeof(struct Dir));
    p->file=name;
    p->next=NULL;
    if(isthere(d,name)==-1)
    {
        if(dir[d]==NULL)
            dir[d]=p;
        else
        {
            temp=dir[d];
            while(temp->next!=NULL)
                temp=temp->next;
            temp->next=p;
        }
    }   
    else
        printf(""file already exists in that directory"");
}
void rem_file(int d,char name)
{
    if(isthere(d,name)==-1)
        printf(""file doesnot exist in the directory"");
    else
    {
        temp=dir[d];
        q=temp;
        while(temp->next!=NULL)
        {
            if(temp->file==name)
            {
                if(temp==dir[d])
                {
                    dir[d]=dir[d]->next;
                    free(temp);
                    temp=dir[d];
                }
                else
                {
                    q->next=temp->next;
                    free(temp);
                    temp=q->next;
                }
            }
            q=temp;
            temp=temp->next;
        }
        if(temp->file==name)
        {
            q->next=NULL;
            free(temp);
        }
    }
}
void display()
{
    int i;
    for(i=0;i<5;i++)
    {
        temp=dir[i];
        printf(""\nDirectory %d - "",i);
        while(temp!=NULL)
        {
            printf(""%c\t"",temp->file);
            temp=temp->next;
        }
    }
}
void main()
{
    int ch,dir;
    char name[5];
    while(1)
    {
        printf(""\nEnter choice : "");
        scanf(""%d"",&ch);
        switch(ch)
        {
            case 1: 
            {
                printf(""\nEnter directory : "");
                scanf(""%d"",&dir);
                printf(""\nEnter file name : "");
                scanf(""%s"",name);
                add_file(dir,name[0]);
                break;
            }
            case 2: 
            {
                printf(""\nEnter directory : "");
                scanf(""%d"",&dir);
                printf(""\nEnter file name : "");
                scanf(""%s"",name);
                rem_file(dir,name[0]);
                break;
            }
            case 3:
            {
                display();
                break;
            }
            default:
            {
                exit(0);
                break;
            }
        }
    }
}",45,1342,809
"#define MAX 100
int queue[MAX];
int value,front=-1,rear=-1;
void enqueue(int queue[],int val)
{
    if(rear==MAX-1)
    printf(""\nqueue is full"");
    if(front==-1 && rear==-1)
    {
        front=0;
        rear=rear+1;
        queue[rear]=val;
    }
    else
    {
        rear=rear+1;
        queue[rear]=val;
    }
}
void dequeue(int queue[])
{
    if(front==-1 || front>rear)
    {
        printf(""\nqueue is empty"");
    }
    else
    {
        printf(""\nThe value popped is : %d"",queue[front]);
        front=front+1;
    }
}
void search(int queue[],int val)
{
    int i,c=0;
    if(front==-1 || front>rear)
    printf(""\nqueue is empty"");
    else
    {
        for(i=front;i<=rear;i++)
        {
            if(queue[i]==val)
            {
                printf(""\nvalue found"");
                c=c+1;
                break;
            }
        }
        if(c==0)
        printf(""\nvalue not found"");
    }
}
void display(int stack[])
{
    int i;
    if(front==-1 || front>rear)
    printf(""\nqueue is empty"");
    else
    {
        printf(""\nqueue is :\n"");
        for(i=front;i<=rear;i++)
        printf(""\t%d"",queue[i]);
    }
}
void main()
{
    int ch;
    printf(""1.ENQUEUE\n2.DEQUEUE\n3.SEARCH\n4.PRINT\n\n"");
    while(1)
    {
        printf(""\nEnter choice:"");
        scanf(""%d"",&ch);
        switch(ch)
        {
            case 1:
            {
                printf(""\nEnter the value to insert:"");
                scanf(""%d"",&value);
                enqueue(queue,value);
                break;
            }
            case 2:
            {
                dequeue(queue);
                break;
            }
            case 3:
            {
                printf(""\nEnter the value to search:"");
                scanf(""%d"",&value);
                search(queue,value);
                break;
            }
            case 4:
            {
                display(queue);
                break;
            }
            default:
            {
                exit(0);
                break;
            }
        }
    }
}",45,1343,674
"int STACK[100],top=-1;
void push(int x)
{
    if(top==99)
    printf(""Stack isFull"");
    else
    {
        top=top+1;
        STACK[top]=x;
    }
}
int pop()
{
    int x;
    if(top==-1)
    printf(""\nStack is Empty"");
    else
    {
        x=STACK[top];
        top=top-1;
        return(x);
    }
}
struct graph
{
    int val;
    struct graph* next;
}*G[10],*last;
void create(struct graph* G[],int n)
{
    int i,j,m,data;
    for(i=0;i<n;i++)
    {
        printf(""\nenter the number of vertices adjacent to vertex %d :"",i);
        scanf(""%d"",&m);
        for(j=0;j<m;j++)
        {
            printf(""\nEnter the vertex to be inserted:"");
            scanf(""%d"",&data);
            struct graph* p=(struct graph*)malloc(sizeof(struct graph));
            p->val=data;
            p->next=NULL;
            if(G[i]==NULL)
                G[i]=p;
            else
            {
                last=G[i];
                while(last->next!=NULL)
                    last=last->next;
                last->next=p;
            }
        }
    }
}
void display(struct graph* G[],int n)
{
    int i,j;
    for(i=0;i<n;i++)
    {
        last=G[i];
        printf(""\nThe vertices adjacent to %d are :\n"",i);
        while(last->next!=NULL)
        {
            printf(""\t%d"",last->val);
            last=last->next;
        }
        printf(""\t%d"",last->val);
    }
}
void main()
{
    int n,i,vertices[10],ct=0,v,visited[10]={1,1,1,1,1,1,1,1,1,1};
    printf(""\nEnter the number of vertices of graph:"");
    scanf(""%d"",&n);
    for(i=0;i<n;i++)
    G[i]=NULL;
    create(G,n);
    display(G,n);
    printf(""\nEnter the starting vertex:"");
    scanf(""%d"",&v);
    push(v);
    ct=0;
    
    while(top>=0)
    {
        vertices[ct]=pop(); 
        visited[v]=3;
        v=vertices[ct];
        ct++;
        last=G[v];
        while(last!=NULL)
        {
            if(visited[last->val]==1)
            {   push(last->val);
                visited[last->val]=2;
            }
            last=last->next;
        }
    }       
    printf(""\nThe graph is:\n"");
    for(i=0;i<ct;i++)
    {
        printf(""\t%d"",vertices[i]);
    }
}",45,1344,801
"#define MAX 100
void RestoreHeapUp(int HEAP[],int index)
{
    int val=HEAP[index];
    while(index>1 && (HEAP[index/2]<val))
    {
        HEAP[index]=HEAP[index/2];
        index=index/2;
    }
    HEAP[index]=val;
}
void RestoreHeapDown(int HEAP[],int index,int n)
{
    int val=HEAP[index];
    int j=index*2;
    while(j<=n)
    {
        if(j<n && HEAP[j]<HEAP[j+1])
        j++;
        if(HEAP[j]<HEAP[j/2])
        break;
        else
        {
            HEAP[j/2]=HEAP[j];
            j=j*2;
        }
        HEAP[j/2]=val;
    }
}
void main()
{
    int HEAP[MAX],i,j,n,temp;
    printf(""\nEnter the value of n:"");
    scanf(""%d"",&n);
    printf(""\nEnter the values:"");
    for(i=1;i<=n;i++)
    {
        scanf(""%d"",&HEAP[i]);
        RestoreHeapUp(HEAP,i);
    }
    j=n;
    for(i=1;i<=j;i++)
    {
        temp=HEAP[1];
        HEAP[1]=HEAP[n];
        HEAP[n]=temp;
        n=n-1;
        RestoreHeapDown(HEAP,1,n);
    }
    n=j;
    printf(""\nThe sorted array:\n"");
    for(i=1;i<=n;i++)
    {
        printf(""\t%d"",HEAP[i]);
    }
}
",45,1345,469
"int STACK[100],top=-1;
void push(int x)
{
    if(top==99)
    printf(""Stack isFull"");
    else
    {
        top=top+1;
        STACK[top]=x;
    }
}
int pop()
{
    int x;
    if(top==-1)
    printf(""\nStack is Empty"");
    else
    {
        x=STACK[top];
        top=top-1;
        return(x);
    }
}
void main()
{
    int graph[10][10],n,i,j,ct,v,x,vertices[10],visited[10]={1,1,1,1,1,1,1,1,1,1};
    printf(""\nEnter the number of vertices of G:"");
    scanf(""%d"",&n);
    printf(""\nEnter the adjacency matrix of graph"");
    for(i=0;i<n;i++)
    {
        for(j=0;j<n;j++)
        {
            scanf(""%d"",&graph[i][j]);
        }

    }
    printf(""\nThe adjacency matrix of given graph:\n"");
    {
        for(i=0;i<n;i++)
        {
            for(j=0;j<n;j++)
            {
                printf(""\t%d"",graph[i][j]);
            }
            printf(""\n"");
        }
    }
    printf(""\nEnter the starting vertex:"");
    scanf(""%d"",&v);
    push(v);
    ct=0;
    
    while(top>=0)
    {
        vertices[ct]=pop(); 
        visited[v]=3;
        v=vertices[ct];
        ct++;
        for(i=0;i<n;i++)
        {
            if(graph[v][i]==1 && visited[i]==1)
            {
                push(i);
                visited[i]=2;   
            }
        }
    }       
    printf(""\nThe graph is:\n"");
    for(i=0;i<ct;i++)
    {
        printf(""\t%d"",vertices[i]);
    }
}
",45,1346,557
"void Brute_Force(char S[],char P[],int n,int m)
{
    int i=0,j=0,k;
    while(i<n && j<m)
    {
        k=i-m+1;
        if(P[j]==S[i])
        {
            i=i+1;
            j=j+1;
        }
        else
        {
            i=i+1;
            j=0;
        }
    }
    if(j==m)    
    {
        printf(""pattern found at %d"",k);
    }
    else
    {
        printf(""pattern not found"");
    }
}
void main()
{
    int n,m,i;
    char S[100],P[100];
    printf(""\nEnter String:"");
    scanf(""%s"",S);
    printf(""\nEnter Pattern:"");
    scanf(""%s"",P);
    n=strlen(S);
    m=strlen(P);
    Brute_Force(S,P,n,m);
}",45,1347,270
"#define F 3
int n,page[100];
int Queue[F],r=-1,f=-1;
int find_pos(int pg,int pos)
{
    int i,set=0;
    for(i=pos;i>=0;i--)
    {
        if(page[i]==pg)
        {
            set=i;
            break;
        }
    }
    return(set);
}
void enqueue(int page,int pos)
{
    int i,new,set=0,min;
    if(r==-1 && f==-1)
    {
        f=f+1;
        r=r+1;
        Queue[r]=page;
    }
    else if(r<2)
    {
        r=r+1;
        Queue[r]=page;
    }
    else
    {
        min=1000;
        for(i=0;i<3;i++)
        {
            new=find_pos(Queue[i],pos-1);
            if(new<min)
            {
                min=new;
                set=i;
            }
        }
        Queue[set]=page;
    }   
}
int isthere(int page)
{
    int i,flag=-1;
    for(i=0;i<3;i++)
    {
        if(Queue[i]==page)
        {
            flag=1;
            break;
        }
    }   
    return(flag);
}
void main()
{
    int i,j,PFR=0;
    for(i=0;i<3;i++)
        Queue[i]=-1;
    printf(""\nEnter the number of pages : "");
    scanf(""%d"",&n);
    for(i=0;i<n;i++)
    {
        printf(""\nEnter the page : "");
        scanf(""%d"",&page[i]);
    }
    for(i=0;i<n;i++)
    {
        if(isthere(page[i])==-1)
        {
            enqueue(page[i],i);
            PFR=PFR+1;
        }
        printf(""\nStatus : "");
        for(j=0;j<3;j++)
            printf(""%d\t"",Queue[j]);
    }
    printf(""\nPage Fault Rate is : %d"",PFR);
}",45,1348,601
"#define MAX 5
int queue[MAX];
int value;
int i=0,x=0;
int f=-1,r=-1;
void enqueue(int val)
{
    if(r==-1)
    {
        f=(f+1)%MAX;
        r=(r+1)%MAX;
        queue[r]=val;
    }
    else if((r==MAX-1 && f==0) || r==f-1)
    {
        printf(""\nQueue is FULL"");
    }
    else
    {
        r=(r+1)%MAX;
        queue[r]=val;
    }
}
int dequeue()
{
    if((f==-1 && r==-1))
    {
        printf(""\nQueue is Empty"");
        return(-1);
    }
    else
    {
        if(f==(r+1)%MAX && queue[f]==-1)    
        {
            printf(""\nQueue is Empty"");
            return(-1);
        }
        else
        {
            value=queue[f];
            queue[f]=-1;
            f=(f+1)%MAX;
            return(value);
        }
    }
}
void search(int val)
{
    i=0;
    if((f==-1 && r==-1))
    printf(""\nQueue is Empty"");
    else if(f==(r+1)%MAX && queue[f]==-1)
    printf(""\nQueue is Empty"");
    else
    {   
        i=f;
        while(i!=r)
        {
            if(queue[i]==val)
            {
                printf(""\nvalue found"");
                x++;
            }
            i=(i+1)%MAX;
        }
        if(queue[i]==val)
        {
            printf(""\nvalue found"");
            x++;
        }
        if(x==0)
        printf(""\nthe value is not found in the queue"");
    }

}
void display()
{
    if((f==-1 && r==-1))
    printf(""\nQueue is Empty"");
    else if(f==(r+1)%MAX && queue[f]==-1)
    printf(""\nQueue is Empty"");
    else
    {
        printf(""\nQueue is:\n"");
        i=f;
        while(i!=r)
        {           
            printf(""\t%d"",queue[i]);
            i=(i+1)%MAX;
        }
        printf(""\t%d"",queue[r]);
    }
}
void main()
{
    int ch;
    while(1)
    {
        printf(""\nEnter choice:"");
        scanf(""%d"",&ch);
        switch(ch)
        {
            case 1:
            {
                printf(""\nEnter value to insert:"");
                scanf(""%d"",&value);
                enqueue(value);
                break;
            }
            case 2:
            {
                printf(""\nthe popped value is %d"",dequeue()); 
                break;
            }
            case 3:
            {
                printf(""\nEnter the value to search"");
                scanf(""%d"",&value);
                search(value);
                break;
            }
            case 4:
            {
                display();
                break;
            }
            default:
            {
                exit(0);
                break;
            }
        }
    }
}
",45,1349,853
"char Queue[100];
int r=-1,f=-1;
struct process
{
    char name[10];  
    int AT,BT,CT,TAT,WT,BT1,status;
};
void enqueue(char c)
{
    if(f==-1 && r==-1)
    {
        f=f+1;
        r=r+1;
        Queue[r]=c;
    }
    else
    {
        r=r+1;
        Queue[r]=c;
    }
}
char dequeue()
{
    char c;
    if(r!=-1 && f!=-1)
    {
        c=Queue[f];
        f=f+1;
        return(c);
    }
}
int isempty()
{
    if(r==-1)
        return(1);
    else
        return(0);
}
void main()
{
    int n,i,j,temp,min,k,k1,init_temp,sum=0,T,flag=0,set=0;
    float Waiting_time;
    char s[10];
    printf(""\nEnter time slice : "");
    scanf(""%d"",&T);
    printf(""\nEnter the number of processess : "");
    scanf(""%d"",&n);
    struct process p[n];
    for(i=0;i<n;i++)
    {
        printf(""\nEnter name : "");
        scanf(""%s"",p[i].name);
        printf(""\nEnter AT : "");
        scanf(""%d"",&p[i].AT);
        printf(""\nEnter BT : "");
        scanf(""%d"",&p[i].BT);
        p[i].CT=0;
        p[i].status=0;
        p[i].BT1=p[i].BT;
    }
    for(i=0;i<n;i++)
    {
        for(j=i+1;j<n;j++)
        {
            if(p[i].AT>p[j].AT)
            {
                temp=p[i].AT;
                p[i].AT=p[j].AT;
                p[j].AT=temp;
                temp=p[i].BT;
                p[i].BT=p[j].BT;
                p[j].BT=temp;
                temp=p[i].BT1;
                p[i].BT1=p[j].BT1;
                p[j].BT1=temp;
                strcpy(s,p[i].name);
                strcpy(p[i].name,p[j].name);
                strcpy(p[j].name,s);
            }
        }
    }
    k=0;
    temp=0;
    while(isempty())
    {
        for(i=0;i<n;i++)
        {
            if(p[i].AT<=temp)
            {
                enqueue(p[i].name[0]);
                break;
            }
        }
        if(isempty())
            temp++;
    }
    while(k<n)
    {
        s[0]=dequeue();
        for(i=0;i<n;i++)
        {
            flag=0;
            if(p[i].name[0]==s[0] && p[i].BT1!=0)
            {
                printf(""%c\t"",s[0]);
                flag=1;
                set=i;
                if(p[i].BT1>T)
                {
                    p[i].BT1=p[i].BT1-T;
                    temp=temp+T;
                    p[i].CT=temp;
                }
                else
                {
                    temp=temp+p[i].BT1;
                    p[i].CT=temp;
                    p[i].BT1=0;
                }
            }
            if(flag==1)
            {
                for(j=0;j<n;j++)
                {
                    if(p[j].name[0]!=s[0] && p[j].AT<=temp && p[j].BT1!=0)
                        enqueue(p[j].name[0]);
                }
                if(p[set].BT1!=0)
                    enqueue(p[set].name[0]);
                break;
            }
        }
        for(i=0;i<n;i++)
        {
            if(p[i].BT1==0 && p[i].status==0)
            {
                k++;
                p[i].status=k;
            }
        }   
    }
    printf(""\nstatus : "");
    for(i=0;i<n;i++)
        printf(""\t%d"",p[i].status);
    printf(""\nprocess\tAT\tBT\tCT\tTAT\tWT"");
    k1=1;
    while(k1<=k)
    {
        for(i=0;i<n;i++)
        {
            if(p[i].status==k1)
            {
                p[i].TAT=p[i].CT-p[i].AT;
                p[i].WT=p[i].TAT-p[i].BT;
                sum=sum+p[i].WT;
                printf(""\n%s\t%d\t%d\t%d\t%d\t%d"",p[i].name,p[i].AT,p[i].BT,p[i].CT,p[i].TAT,p[i].WT);
                k1++;
            }
        }
    }
    Waiting_time=(sum*1.0)/n;
    printf(""\nAverage Waiting_time : %f"",Waiting_time);
}",45,1350,1455
"#define MAX 100
int queue[MAX];
int value,front=-1,rear=-1;
void enqueueF(int val)
{
    if(front==-1 && rear==-1)
    {
        front=front+1;
        rear=rear+1;
        queue[front]=val;
    }
    else if(front==0)
    {
        printf(""\ncannot be inserted"");
    }
    else
    {
        front=front-1;
        queue[front]=val;
    }
}
void enqueueR(int val)
{
    if(front==-1 && rear==-1)
    {
        front=front+1;
        rear=rear+1;
        queue[rear]=val;
    }
    if(rear==MAX-1)
    printf(""queue is full"");
    else
    {
        rear=rear+1;
        queue[rear]=val;
    }
}
void dequeueF()
{
    if((front==-1 && rear==-1) || front>rear)
    printf(""queue is empty"");
    else
    {
        printf(""The value popped is %d"",queue[front]);
        front=front+1;
    }
}
void dequeueR()
{
    if((front==-1 && rear==-1) || front>rear)
    printf(""queue is empty"");
    else
    {
        printf(""The value popped is %d"",queue[rear]);
        rear=rear-1;
    }
}
void search(int val)
{
    int i,c=0;
    if((front==-1 && rear==-1) || front>rear)
    printf(""\nqueue is empty"");
    else
    {
        for(i=front;i<=rear;i++)
        {
            if(queue[i]==val)
            {
                printf(""\nvalue found"");
                c=c+1;
                break;
            }
        }
        if(c==0)
        printf(""\nvalue not found"");
    }
}
void display()
{
    int i;
    if((front==-1 && rear==-1) || front>rear)
    printf(""\nqueue is empty"");
    else
    {
        printf(""\nqueue is :\n"");
        for(i=front;i<=rear;i++)
        printf(""\t%d"",queue[i]);
    }
}
void main()
{
    int ch;
    printf(""1.enqueueF\n2.enqueueR\n3.dequeueF\n4.dequeueR\n5.search\n6.print\n\n"");
    while(1)
    {
        printf(""\nEnter choice:"");
        scanf(""%d"",&ch);
        switch(ch)
        {
            case 1:
            {
                printf(""\nEnter the value to insert:"");
                scanf(""%d"",&value);
                enqueueF(value);
                break;
            }
            case 2:
            {
                printf(""\nEnter the value to insert:"");
                scanf(""%d"",&value);
                enqueueR(value);
                break;
            }
            case 3:
            {
                dequeueF();
                break;
            }
            case 4:
            {
                dequeueR();
                break;
            }
            case 5:
            {
                printf(""\nEnter the value to search:"");
                scanf(""%d"",&value);
                search(value);
                break;
            }
            case 6:
            {
                display();
                break;
            }
            default:
            {
                exit(0);
                break;
            }
        }
    }
}",45,1351,925
"void main()
{
    char c[100];
    int length,i,n,j,temp;
    printf(""Enter the string:"");
    gets(c);
    length=strlen(c);
    printf(""\nEnter the number of shifts:"");
    scanf(""%d"",&n);
    while(n!=0)
    {
        i=length-1;
        j=i;
        temp=c[i];
        while(j>=0)
        {
            i--;
             c[j]=c[i];
             j--;

        }
        c[0]=temp;
        n--;
    }
    printf(""\nAfter shifting:"");
    puts(c);
}

",45,1352,178
"struct process
{
    char name[10];
    int AT,BT,CT,TAT,WT;
};
void main()
{
    int n,i,j,temp,sum=0;
    float Waiting_time;
    char s[10];
    printf(""\nEnter the number of processess : "");
    scanf(""%d"",&n);
    struct process p[n];
    for(i=0;i<n;i++)
    {
        printf(""\nEnter process : "");
        scanf(""%s"",p[i].name);
        printf(""\nEnter AT : "");    
        scanf(""%d"",&p[i].AT);
        printf(""\nEnter BT : "");
        scanf(""%d"",&p[i].BT);
        p[i].CT=0;
    }
    for(i=0;i<n;i++)
    {
        for(j=i+1;j<n;j++)
        {
            if(p[i].AT>p[j].AT)
            {
                temp=p[i].AT;
                p[i].AT=p[j].AT;
                p[j].AT=temp;
                temp=p[i].BT;
                p[i].BT=p[j].BT;
                p[j].BT=temp;
                strcpy(s,p[i].name);
                strcpy(p[i].name,p[j].name);
                strcpy(p[j].name,s);
            }   
        }
    }
    p[0].CT=p[0].AT;
    for(i=0;i<n;i++)
    {
        if(i!=0)
            p[i].CT=p[i-1].CT;
        p[i].CT=p[i].CT+p[i].BT;
        p[i].TAT=p[i].CT-p[i].AT;
        p[i].WT=p[i].TAT-p[i].BT;
        sum=sum+p[i].WT;
    }
    printf(""\nprocess\tAT\tBT\tCT\tTAT\tWT"");
    for(i=0;i<n;i++)
        printf(""\n%s\t%d\t%d\t%d\t%d\t%d"",p[i].name,p[i].AT,p[i].BT,p[i].CT,p[i].TAT,p[i].WT);
    Waiting_time=(sum*1.0)/n;
    printf(""\nAverage Waiting_time : %f"",Waiting_time);
}
",45,1353,654
"int Last_Occurence(char P[],int m,char c)
{
    int i,k=0;
    for(i=m-1;i>=0;i--)
    {
        if(P[i]==c)
        k=i;
    }
    return(k);
}
int Boyre_Moore(char S[],char P[],int n,int m)
{
    int i=m-1,j=m-1,l;
    while(i<n && i>=0)
    {
        if(P[j]==S[i])
        {
            if(j==0)
            return(i);
            else
            {
                i=i-1;
                j=j-1;
            }
        }
        else
        {
            l=Last_Occurence(P,m,S[i]);
            i=i+m-(l+1);
            j=m-1;
        }
    }
}
void main()
{
    int n,m,i;
    char S[100],P[100];
    printf(""\nEnter String:"");
    scanf(""%s"",S);
    printf(""\nEnter Pattern:"");
    scanf(""%s"",P);
    n=strlen(S);
    m=strlen(P);
    i=Boyre_Moore(S,P,n,m);
    printf(""\nThe pattern is found at position %d"",i);
}",45,1354,363
"struct hash
{
    int val;
    struct hash* next;
}*temp,*q;
struct hash* HASH[5];
int val,key;
int H(int key)
{
    return(key%10);
}
void insert(int key,int value)
{
    int index=H(key);
    struct hash* p=(struct hash*)malloc(sizeof(struct hash));
    p->val=value;
    p->next=NULL;
    if(HASH[index]==NULL)
    {
        HASH[index]=p;
    }
    else
    {
        temp=HASH[index];
        while(temp->next!=NULL)
            temp=temp->next;
        temp->next=p;
    }
}
void delete(int key,int value)
{
    int index=H(key);
    int ct=0;
    if(HASH[index]!=NULL)
    {
        temp=HASH[index];
        q=temp;
        while(temp->next!=NULL)
        {
            if(temp->val==value)
            {
                if(temp==HASH[index])
                {
                    HASH[index]=temp->next;
                    free(temp);
                    temp=HASH[index];
                    printf(""\nValue deleted"");
                    ct++;
                }
                else
                {
                    q->next=temp->next;
                    free(temp);
                    printf(""\nValue deleted"");
                    ct++;
                }
            }
            q=temp;
            temp=temp->next;
        }
        if(temp->val==value)
        {
            q->next=NULL;
            free(temp);
            printf(""\nValue deleted"");
            ct++;
        }
        if(ct==0)
        printf(""\nValue is not found"");
    }
}
void search(int key,int value)
{
    int index=H(key);
    int ct=0;
    if(HASH[index]!=NULL)
    {
        temp=HASH[index];
        while(temp->next!=NULL)
        {
            if(temp->val==value)
            {
                printf(""\nValue found"");
                ct++;
            }
            temp=temp->next;
        }
        if(temp->val==value)
        {
            printf(""\nValue found"");
            ct++;
        }
        if(ct==0)
        printf(""\nValue not found"");
    }
}
void display()
{
    int i;
    for(i=0;i<5;i++)
    {
        if(HASH[i]!=NULL)
        {
            printf(""\nvalues with index %d \n"",i);
            temp=HASH[i];
            while(temp->next!=NULL)
            {
                printf(""\t%d"",temp->val);
                temp=temp->next;
            }
            printf(""\t%d"",temp->val);
        }
    }
}
void main()
{
    int ch,i;
    for(i=0;i<5;i++)
    HASH[i]=NULL;
    printf(""\n1.INSERT\n2.DELETE\n3.SEARCH\n4.DISPLAY\n\n"");
    while(1)
    {
        printf(""\nEnter choice:"");
        scanf(""%d"",&ch);
        switch(ch)
        {
            case 1:
            {
                printf(""\nEnter the key:"");
                scanf(""%d"",&key);
                printf(""\nEnter the value:"");
                scanf(""%d"",&val);
                insert(key,val);
                break;
            }
            case 2:
            {
                printf(""\nEnter the key:"");
                scanf(""%d"",&key);
                printf(""\nEnter the value:"");
                scanf(""%d"",&val);
                delete(key,val);
                break;
            }
            case 3:
            {
                printf(""\nEnter the key:"");
                scanf(""%d"",&key);
                printf(""\nEnter the value:"");
                scanf(""%d"",&val);
                search(key,val);
                break;
            }
            case 4:
            {
                display();
                break;
            }
            default:
            {
                exit(0);
                break;
            }
        }
    }
}",45,1355,1086
"int HASH[10],key,val,i;
int H(int value)
{
    return(value%10);
}
void insert(int key,int value)
{
    int index=H(key);
    int i;
    if(HASH[index]==-1)
    {
        HASH[index]=value;
    }
    else
    {
        for(i=index+1;i<10;i++)
        {
            if(HASH[i]==-1)
            {
                HASH[i]=value;
                break;
            }
        }
    }
}
void delete(int key,int value)
{
    int index=H(key);
    int ct=0,i;
    if(HASH[index]==value)
    {
        HASH[index]=-1;
        printf(""\nValue deleted"");
        ct++;
    }
    else
    {
        for(i=index+1;i<10;i++)
        {
            if(HASH[i]==value)
            {
                HASH[i]=-1;
                printf(""\nValue deleted"");
                ct++;
                break;
            }
        }
    }
    if(ct==0)
    {
        printf(""\nThe key with that value is not found"");
    }
}
void search(int key,int value)
{
    int index=H(key);
    int i;
    int ct=0;
    if(HASH[index]==value)
    {
        printf(""\nThe value found at index %d "",index);
        ct++;
    }
    else
    {
        for(i=index+1;i<10;i++)
        {
            if(HASH[i]==value)
            {
                printf(""\nValue found at index %d "",i);
                ct++;
                break;
            }
        }
    }
    if(ct==0)
    {
        printf(""\nThe key with that value is not found"");
    }   
}
void display()
{
    int i;
    for(i=0;i<10;i++)
    {
        if(HASH[i]!=-1)
        printf(""\nkey : %d\tvalue : %d"",i,HASH[i]);
    }
}
void main()
{
    int ch,i;
    for(i=0;i<10;i++)
    HASH[i]=-1;
    printf(""\n1.INSERT\n2.DELETE\n3.SEARCH\n4.DISPLAY\n\n"");
    while(1)
    {
        printf(""\nEnter choice:"");
        scanf(""%d"",&ch);
        switch(ch)
        {
            case 1:
            {
                printf(""\nEnter the key:"");
                scanf(""%d"",&key);
                printf(""\nEnter the value:"");
                scanf(""%d"",&val);
                insert(key,val);
                break;
            }
            case 2:
            {
                printf(""\nEnter the key:"");
                scanf(""%d"",&key);
                printf(""\nEnter the value:"");
                scanf(""%d"",&val);
                delete(key,val);
                break;
            }
            case 3:
            {
                printf(""\nEnter the key:"");
                scanf(""%d"",&key);
                printf(""\nEnter the value:"");
                scanf(""%d"",&val);
                search(key,val);
                break;
            }
            case 4:
            {
                display();
                break;
            }
            default:
            {
                exit(0);
                break;
            }
        }
    }
}",45,1356,926
"#define MAX 100
int stack[MAX];
int value,top=-1,key;
void push(int stack[],int val)
{
    if(top==MAX-1)
    printf(""\nstack is full"");
    else
    {
        top=top+1;
        stack[top]=val;
    }
}
void pop(int stack[])
{
    if(top==-1)
    {
        printf(""\nstack is empty"");
    }
    else
    {
        printf(""\nThe value popped is : %d"",stack[top]);
        top=top-1;
    }
}
void search(int stack[],int val)
{
    int i,c=0;
    if(top==-1)
    printf(""\nstack is empty"");
    else
    {
        for(i=0;i<=top;i++)
        {
            if(stack[i]==val)
            {
                printf(""\nvalue found"");
                c=c+1;
                break;
            }
        }
        if(c==0)
        printf(""\nvalue not found"");
    }
}
void display(int stack[])
{
    int i;
    if(top==-1)
    printf(""\nstack is empty"");
    else
    {
        printf(""\nstack is :\n"");
        for(i=0;i<=top;i++)
        printf(""\t%d"",stack[i]);
    }
}
void main()
{
    int ch;
    printf(""1.INSERT\n2.DELETE\n3.SEARCH\n4.PRINT\n\n"");
    while(1)
    {
        printf(""\nEnter choice:"");
        scanf(""%d"",&ch);
        switch(ch)
        {
            case 1:
            {
                printf(""\nEnter the value to insert:"");
                scanf(""%d"",&value);
                push(stack,value);
                break;
            }
            case 2:
            {
                pop(stack);
                break;
            }
            case 3:
            {
                printf(""\nEnter the value to search:"");
                scanf(""%d"",&value);
                search(stack,value);
                break;
            }
            case 4:
            {
                display(stack);
                break;
            }
            default:
            {
                exit(0);
                break;
            }
        }
    }
}",45,1357,600
"int pos;
struct graph
{
    char name;
    int id;
    char parent;
    struct graph* next;
}*G[10],*temp,*q;
void add_dir(char dir)
{
    int i,flag=-1;
    char root[10];
    struct graph* p=(struct graph*)malloc(sizeof(struct graph));
    p->name=dir;
    p->id=1;
    printf(""\nEnter root directory : "");
    scanf(""%s"",root);
    p->parent=root[0];
    p->next=NULL;
    if(root[0]=='!')
    {
        G[pos]=p;
        pos=pos+1;
    }
    else
    {
        for(i=0;i<pos;i++)
        {
            temp=G[i];
            q=temp->next;
            while(temp!=NULL)
            {
                if(temp->name==root[0])
                {
                    p->next=temp->next;
                    temp->next=p;
                    flag=1;
                    break;
                }
                else
                {
                    temp=temp->next;
                    q=temp->next;
                }
            }
            if(flag==1)
                break;
        }
    }
}
void add_file(char dir,char file)
{
    int i,flag=-1;
    struct graph* p=(struct graph*)malloc(sizeof(struct graph));
    p->name=file;
    p->id=2;
    p->parent=dir;
    p->next=NULL;
    for(i=0;i<pos;i++)
    {
        temp=G[i];
        q=temp->next;
        while(temp!=NULL)
        {
            if(temp->name==dir && temp->id==1)
            {
                p->next=temp->next;
                temp->next=p;
                flag=1;
                break;
            }
            else
            {
                q=temp;
                temp=temp->next;
            }
        }
        if(flag==1)
            break;
    }
}
void del_dir(char dir)
{
    int i;
    for(i=0;i<pos;i++)
    {
        temp=G[i];
        if(temp->name==dir)
        {
            temp->next=NULL;
            free(temp);
            break;
        }
        else
        {
            q=temp;
            while(temp!=NULL)
            {
                if(temp->name==dir && temp->id==1)
                {
                    q->next=temp->next;
                    
                    temp=q->next;
                    continue;
                }
                else if(temp->parent==dir && temp->id==2)
                {
                    q->next=temp->next;
                    
                    temp=q->next;
                    continue;   
                }
                q=temp;
                temp=temp->next;
            }
            
        }
    }
}
void del_file(char dir,char file)
{
    int i,flag=-1;
    for(i=0;i<pos;i++)
    {
        temp=G[i];
        q=temp;
        while(temp!=NULL)
        {
            if(temp->name==file && temp->id==2 && temp->parent==dir)
            {
                q->next=temp->next;
                temp=q->next;
                flag=1;
                break;
            }
            q=temp;
            temp=temp->next;
        }
        if(flag==1)
            break;
    }
}
void display()
{
    int i;
    for(i=0;i<pos;i++)
    {
        temp=G[i];
        printf(""\nDirectory (%c) : "",temp->name);
        while(temp!=NULL)
        {
            printf(""(%c,%d,%c)"",temp->name,temp->id,temp->parent);
            temp=temp->next;
        }
    }
}
int check(char dir)
{
    int flag=-1;
    int i;
    for(i=0;i<pos;i++)
    {
        temp=G[i];
        while(temp!=NULL)
        {
            if(temp->name==dir && temp->id==1)
            {
                flag=1;
                break;
            }
            else
            {
                temp=temp->next;
            }
        }
        if(flag==1)
            break;
    }
    return(flag);
}
void main()
{
    int status=-1,ch;
    char dir[10],file[10];
    while(1)
    {
        printf(""\nEnter choice : "");
        scanf(""%d"",&ch);
        switch(ch)
        {
            case 1:
            {
                printf(""\nEnter the name of directory : "");
                scanf(""%s"",dir);
                add_dir(dir[0]);
                break;
            }
            case 2:
            {
                printf(""\nEnter the name of file to add : "");
                scanf(""%s"",file);
                printf(""\nEnter the directory : "");
                scanf(""%s"",dir);
                status=check(dir[0]);
                if(status==1)
                    add_file(dir[0],file[0]);
                else
                {
                    add_dir(dir[0]);
                    add_file(dir[0],file[0]);
                }
                break;
            }
            case 3:
            {
                printf(""\nEnter the directory to delete : "");
                scanf(""%s"",dir);
                del_dir(dir[0]);
                break;
            }
            case 4:
            {
                printf(""\nEnter the file to delete : "");
                scanf(""%s"",file);
                printf(""\nEnter the directory to which it belongs : "");
                scanf(""%s"",dir);
                del_file(dir[0],file[0]);
                break;
            }
            case 5:
            {
                display();
                break;
            }
            default:
            {
                exit(0);
                break;
            }
        }
    }
}",45,1358,1558
"struct tree
{
    int val;
    struct tree *left;
    struct tree *right;
}*root=NULL,*temp=NULL,*q=NULL;
int value;
struct tree* find_max(struct tree* root)
{
    if(root==NULL || root->right==NULL)
    return(root);
    else
    return(find_max(root->right));  
}
struct tree* insert(struct tree* root,int tar)
{
    struct tree* p=(struct tree*)malloc(sizeof(struct tree));
    p->val=tar;
    p->left=NULL;
    p->right=NULL;
    if(root!=NULL)
    {
        if(tar<root->val)
        root->left=insert(root->left,tar);
        else if(tar>root->val)
        root->right=insert(root->right,tar);
        else if(tar==root->val)
        return(root);
    }
    else
    {
        root=p;
        return(root);
    }
}
struct tree* delete(struct tree* root,int tar)
{
    if(root!=NULL)
    {
        if(tar<root->val)
        root->left=delete(root->left,tar);
        else if(tar>root->val)
        root->right=delete(root->right,tar);
        else if(tar==root->val)
        {
            if(root->left==NULL && root->right==NULL)
            {
                root=NULL;
            }
            else if(root->left==NULL && root->right!=NULL)
            {
                temp=root;
                root=root->right;
                free(temp);
            }
            else if(root->left!=NULL && root->right==NULL)
            {
                temp=root;
                root=root->left;
                free(temp);
            }
            else
            {
                temp=find_max(root->left);
                root->val=temp->val;
                root->left=delete(root->left,temp->val);
            }
        }
        return(root);
    }
    else
    {
        return(root);
    }
}
struct tree* search(struct tree* root,int tar)
{
    if(root!=NULL)
    {
        if(tar<root->val)
        root->left=search(root->left,tar);
        else if(tar>root->val)
        root->right=search(root->right,tar);
        else if(tar==root->val)
        {
            printf(""\nElement found"");
            return(root);
        }       
    }
    else
    {
        printf(""\neither tree is empty or element not found"");
        return(root);
    }
}
void inorder(struct tree* root)
{
    if(root!=NULL)
    {
        inorder(root->left);
        printf(""\t%d"",root->val);
        inorder(root->right);
    }
}
void preorder(struct tree* root)
{
    if(root!=NULL)
    {
        printf(""\t%d"",root->val);
        preorder(root->left);
        preorder(root->right);
    }
}
void postorder(struct tree* root)
{
    if(root!=NULL)
    {
        postorder(root->left);
        postorder(root->right);
        printf(""\t%d"",root->val);
    }
}
void main()
{
    int ch;
    while(1)
    {
        printf(""\nEnter choice:"");
        scanf(""%d"",&ch);
        switch(ch)
        {
            case 1:
            {
                printf(""\nEnter value to insert:"");
                scanf(""%d"",&value);
                root=insert(root,value);
                break;
            }
            case 2:
            {
                printf(""\nEnter the value to delete:"");
                scanf(""%d"",&value);
                root=delete(root,value);
                break;
            }
            case 3:
            {
                printf(""\nEnter the value to search:"");
                scanf(""%d"",&value);
                root=search(root,value);
                break;
            }
            case 4:
            {
                inorder(root);
                break;
            }
            case 5:
            {
                preorder(root);
                break;
            }
            case 6:
            {
                postorder(root);
                break;
            }
            default:
            {
                exit(0);
                break;
            }
        }
    }
}",45,1359,1141
"struct List
{
    int val;
    struct List *prev;
    struct List *next;
}*start=NULL,*temp=NULL,*q=NULL;
int value,pos,i=0;
void insert(int tar,int pos)
{
    struct List* p=(struct List*)malloc(sizeof(struct List));
    p->val=tar;
    p->prev=NULL;
    p->next=NULL;
    if(start==NULL)
    {
        start=p;
    }
    else
    {
        if(pos==0)
        {
            p->next=start;
            start=p;
        }
        else
        {
            temp=start;
            for(i=0;i<(pos-1);i++)
            {
                temp=temp->next;
            }
            p->next=temp->next;
            p->prev=temp;
            temp->next->prev=p;
            temp->next=p;   
        }
    }
}
void delete(int tar)
{
    if(start==NULL)
    printf(""\nList is empty"");
    else
    {
        temp=start;
        q=temp;
        while(temp->next!=NULL)
        {
            if(temp->val==start->val && temp->val==tar)
            {
                start=start->next;
                start->prev=NULL;
                free(temp);
                temp=start;
            }
            else if(temp->val==tar)
            {
                q->next=temp->next;
                temp->next->prev=q;
                free(temp);
                temp=q->next;
            }
            q=temp;
            temp=temp->next;
        }
        if(temp->val==tar && temp->next==NULL)
        {
            q->next=NULL;
            temp->prev=NULL;
            free(temp);
        }
    }
}
void search(int tar)
{
    int ct=0;
    if(start==NULL)
    printf(""\nList is empty"");
    else
    {
        temp=start;
        while(temp->next!=NULL)
        {
            if(temp->val==tar)
            {
                printf(""\nElement found"");
                ct++;
                break;
            }
            temp=temp->next;
        }
        if(temp->val==tar && temp->next==NULL)
        {
            printf(""\nElement found"");
            ct++;
        }
        if(ct==0)
        {
            printf(""\nthe element is not found in the list"");
        }
    }
}
void display()
{
    if(start==NULL)
    printf(""\nList is empty"");
    else
    {
        temp=start;
        while(temp->next!=NULL)
        {
            printf(""\t%d"",temp->val);
            temp=temp->next;
        }
    }
    printf(""\t%d"",temp->val);
}
void main()
{
    int ch;
    while(1)
    {
        printf(""\nEnter choice:"");
        scanf(""%d"",&ch);
        switch(ch)
        {
            case 1:
            {
                printf(""\nEnter the value and position to insert:"");
                scanf(""%d%d"",&value,&pos);
                insert(value,pos);
                break;
            }
            case 2:
            {
                printf(""\nEnter the value to delete:"");
                scanf(""%d"",&value);
                delete(value);
                break;
            }
            case 3:
            {
                printf(""\nEnter the value to search:"");
                scanf(""%d"",&value);
                search(value);
                break;
            }
            case 4:
            {
                display();
                break;
            }
            default:
            {
                exit(0);
                break;
            }
        }
    }
}",45,1360,967
"int Mem;
struct program
{
    char name[10];
    int size,status;
};
void main()
{
    int n,i,rem,EF=0;
    printf(""\Enter the size of memory : "");
    scanf(""%d"",&Mem);
    printf(""\nEnter the number of programs : "");
    scanf(""%d"",&n);
    struct program p[n];
    rem=Mem;
    for(i=0;i<n;i++)
    {
        printf(""\nEnter name : "");
        scanf(""%s"",p[i].name);
        printf(""\nEnter size : "");
        scanf(""%d"",&p[i].size);
        p[i].status=0;
    }
    for(i=0;i<n;i++)
    {
        if(p[i].size<=rem)
        {
            p[i].status=1;
            rem=rem-p[i].size;
        }
    }
    EF=rem;
    printf(""\nprogram\tsize\tstatus\n"");
    for(i=0;i<n;i++)
        printf(""%s\t%d\t%d\n"",p[i].name,p[i].size,p[i].status);
    printf(""\nTotal External Fragmentation is : %d"",EF);
}",45,1361,323
"void main()
{
    char a[100];
    char b[100];
    int i;
    int s;
    int ct=0;
    printf(""enter string-1:"");
    gets(a);
    printf(""\nenter string-2"");
    gets(b);
    s=(strlen(a)>strlen(b))?(strlen(a)):(strlen(b));
    for(i=0;i<s;i++)
    {
        if(a[i]==b[i])
        {
            ct++;
        }
        else
        {
            ct=-1;
            break;
        }
    }
    if(ct==-1)
    printf(""\nstrings are not equal"");
    else
    printf(""\nstrings are same"");
}
",45,1362,197
"int ARR[100];
int Partition(int ARR[],int BEG,int END)
{
    int Left=BEG,Right=END,LOC=BEG,FLAG=0,temp;
    while(FLAG!=1)
    {
        while(ARR[LOC]<=ARR[Right] && LOC!=Right)
        {
            Right=Right-1;
        }
        if(LOC==Right)
        {
            FLAG=1;
        }
        else if(ARR[LOC]>ARR[Right])
        {
            temp=ARR[LOC];
            ARR[LOC]=ARR[Right];
            ARR[Right]=temp;
            LOC=Right;
        }
        if(FLAG!=1)
        {
            while(ARR[LOC]>=ARR[Left] && LOC!=Left)
            {
                Left=Left+1;
            }
            if(LOC==Left)
            {
                FLAG=1;
            }
            else if(ARR[LOC]<ARR[Left])
            {
                temp=ARR[LOC];
                ARR[LOC]=ARR[Left];
                ARR[Left]=temp;
                LOC=Left;
            }
        }
    }
    return(LOC);
}   
void QuickSort(int ARR[],int BEG,int END)
{
    int LOC;
    if(BEG<END)
    {
        LOC=Partition(ARR,BEG,END);
        QuickSort(ARR,BEG,LOC-1);
        QuickSort(ARR,LOC+1,END);
    }
}
void main()
{
    int n,i;
    printf(""\nEnter the number of elements in the array:"");
    scanf(""%d"",&n);
    printf(""\nEnter the elements of the array:"");
    for(i=0;i<n;i++)
    {
        scanf(""%d"",&ARR[i]);
    }
    QuickSort(ARR,0,n-1);
    printf(""\nThe sorted array is:\n"");
    for(i=0;i<n;i++)
    {
        printf(""\t%d"",ARR[i]);
    }
}
",45,1363,552
"#define MAX 4
#define MIN 2

  struct btreeNode {
        int val[MAX + 1], count;
        struct btreeNode *link[MAX + 1];
  };

  struct btreeNode *root;

  
  struct btreeNode * createNode(int val, struct btreeNode *child) {
        struct btreeNode *newNode;
        newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));
        newNode->val[1] = val;
        newNode->count = 1;
        newNode->link[0] = root;
        newNode->link[1] = child;
        return newNode;
  }

  
  void addValToNode(int val, int pos, struct btreeNode *node,
                        struct btreeNode *child) {
        int j = node->count;
        while (j > pos) {
                node->val[j + 1] = node->val[j];
                node->link[j + 1] = node->link[j];
                j--;
        }
        node->val[j + 1] = val;
        node->link[j + 1] = child;
        node->count++;
  }

  
  void splitNode (int val, int *pval, int pos, struct btreeNode *node,
     struct btreeNode *child, struct btreeNode **newNode) {
        int median, j;

        if (pos > MIN)
                median = MIN + 1;
        else
                median = MIN;

        *newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));
        j = median + 1;
        while (j <= MAX) {
                (*newNode)->val[j - median] = node->val[j];
                (*newNode)->link[j - median] = node->link[j];
                j++;
        }
        node->count = median;
        (*newNode)->count = MAX - median;

        if (pos <= MIN) {
                addValToNode(val, pos, node, child);
        } else {
                addValToNode(val, pos - median, *newNode, child);
        }
        *pval = node->val[node->count];
        (*newNode)->link[0] = node->link[node->count];
        node->count--;
  }

  
  int setValueInNode(int val, int *pval,
     struct btreeNode *node, struct btreeNode **child) {

        int pos;
        if (!node) {
                *pval = val;
                *child = NULL;
                return 1;
        }

        if (val < node->val[1]) {
                pos = 0;
        } else {
                for (pos = node->count;
                        (val < node->val[pos] && pos > 1); pos--);
                if (val == node->val[pos]) {
                        printf(""Duplicates not allowed\n"");
                        return 0;
                }
        }
        if (setValueInNode(val, pval, node->link[pos], child)) {
                if (node->count < MAX) {
                        addValToNode(*pval, pos, node, *child);
                } else {
                        splitNode(*pval, pval, pos, node, *child, child);
                        return 1;
                }
        }
        return 0;
  }

  
  void insertion(int val) {
        int flag, i;
        struct btreeNode *child;

        flag = setValueInNode(val, &i, root, &child);
        if (flag)
                root = createNode(i, child);
  }

  
  void copySuccessor(struct btreeNode *myNode, int pos) {
        struct btreeNode *dummy;
        dummy = myNode->link[pos];

        for (;dummy->link[0] != NULL;)
                dummy = dummy->link[0];
        myNode->val[pos] = dummy->val[1];

  }

  
  void removeVal(struct btreeNode *myNode, int pos) {
        int i = pos + 1;
        while (i <= myNode->count) {
                myNode->val[i - 1] = myNode->val[i];
                myNode->link[i - 1] = myNode->link[i];
                i++;
        }
        myNode->count--;
  }

  
  void doRightShift(struct btreeNode *myNode, int pos) {
        struct btreeNode *x = myNode->link[pos];
        int j = x->count;

        while (j > 0) {
                x->val[j + 1] = x->val[j];
                x->link[j + 1] = x->link[j];
        }
        x->val[1] = myNode->val[pos];
        x->link[1] = x->link[0];
        x->count++;

        x = myNode->link[pos - 1];
        myNode->val[pos] = x->val[x->count];
        myNode->link[pos] = x->link[x->count];
        x->count--;
        return;
  }

  
  void doLeftShift(struct btreeNode *myNode, int pos) {
        int j = 1;
        struct btreeNode *x = myNode->link[pos - 1];

        x->count++;
        x->val[x->count] = myNode->val[pos];
        x->link[x->count] = myNode->link[pos]->link[0];

        x = myNode->link[pos];
        myNode->val[pos] = x->val[1];
        x->link[0] = x->link[1];
        x->count--;

        while (j <= x->count) {
                x->val[j] = x->val[j + 1];
                x->link[j] = x->link[j + 1];
                j++;
        }
        return;
  }

  
  void mergeNodes(struct btreeNode *myNode, int pos) {
        int j = 1;
        struct btreeNode *x1 = myNode->link[pos], *x2 = myNode->link[pos - 1];

        x2->count++;
        x2->val[x2->count] = myNode->val[pos];
        x2->link[x2->count] = myNode->link[0];

        while (j <= x1->count) {
                x2->count++;
                x2->val[x2->count] = x1->val[j];
                x2->link[x2->count] = x1->link[j];
                j++;
        }

        j = pos;
        while (j < myNode->count) {
                myNode->val[j] = myNode->val[j + 1];
                myNode->link[j] = myNode->link[j + 1];
                j++;
        }
        myNode->count--;
        free(x1);
  }

  
  void adjustNode(struct btreeNode *myNode, int pos) {
        if (!pos) {
                if (myNode->link[1]->count > MIN) {
                        doLeftShift(myNode, 1);
                } else {
                        mergeNodes(myNode, 1);
                }
        } else {
                if (myNode->count != pos) {
                        if(myNode->link[pos - 1]->count > MIN) {
                                doRightShift(myNode, pos);
                        } else {
                                if (myNode->link[pos + 1]->count > MIN) {
                                        doLeftShift(myNode, pos + 1);
                                } else {
                                        mergeNodes(myNode, pos);
                                }
                        }
                } else {
                        if (myNode->link[pos - 1]->count > MIN)
                                doRightShift(myNode, pos);
                        else
                                mergeNodes(myNode, pos);
                }
        }
  }

  
  int delValFromNode(int val, struct btreeNode *myNode) {
        int pos, flag = 0;
        if (myNode) {
                if (val < myNode->val[1]) {
                        pos = 0;
                        flag = 0;
                } else {
                        for (pos = myNode->count;
                                (val < myNode->val[pos] && pos > 1); pos--);
                         if (val == myNode->val[pos]) {
                                flag = 1;
                        } else {
                                flag = 0;
                        }
                }
                if (flag) {
                        if (myNode->link[pos - 1]) {
                                copySuccessor(myNode, pos);
                                flag = delValFromNode(myNode->val[pos], myNode->link[pos]);
                                if (flag == 0) {
                                        printf(""Given data is not present in B-Tree\n"");
                                }
                        } else {
                                removeVal(myNode, pos);
                        }
                } else {
                        flag = delValFromNode(val, myNode->link[pos]);
                }
                if (myNode->link[pos]) {
                        if (myNode->link[pos]->count < MIN)
                                adjustNode(myNode, pos);
                }
        }
        return flag;
  }

  
  void deletion(int val, struct btreeNode *myNode) {
        struct btreeNode *tmp;
        if (!delValFromNode(val, myNode)) {
                printf(""Given value is not present in B-Tree\n"");
                return;
        } else {
                if (myNode->count == 0) {
                        tmp = myNode;
                        myNode = myNode->link[0];
                        free(tmp);
                }
        }
        root = myNode;
        return;
  }

  
  void searching(int val, int *pos, struct btreeNode *myNode) {
        if (!myNode) {
                return;
        }

        if (val < myNode->val[1]) {
                *pos = 0;
        } else {
                for (*pos = myNode->count;
                        (val < myNode->val[*pos] && *pos > 1); (*pos)--);
                if (val == myNode->val[*pos]) {
                        printf(""Given data %d is present in B-Tree"", val);
                        return;
                }
        }
        searching(val, pos, myNode->link[*pos]);
        return;
  }

  
  void traversal(struct btreeNode *myNode) {
        int i;
        if (myNode) {
                for (i = 0; i < myNode->count; i++) {
                        traversal(myNode->link[i]);
                        printf(""%d "", myNode->val[i + 1]);
                }
                traversal(myNode->link[i]);
        }
  }

  int main() {
        int val, ch;
        while (1) {
                printf(""1. Insertion\t2. Deletion\n"");
                printf(""3. Searching\t4. Traversal\n"");
                printf(""5. Exit\nEnter your choice:"");
                scanf(""%d"", &ch);
                switch (ch) {
                        case 1:
                                printf(""Enter your input:"");
                                scanf(""%d"", &val);
                                insertion(val);
                                break;
                        case 2:
                                printf(""Enter the element to delete:"");
                                scanf(""%d"", &val);
                                deletion(val, root);
                                break;
                        case 3:
                                printf(""Enter the element to search:"");
                                scanf(""%d"", &val);
                                searching(val, &ch, root);
                                break;
                        case 4:
                                traversal(root);
                                break;
                        case 5:
                                exit(0);
                        default:
                                printf(""U have entered wrong option!!\n"");
                                break;
                }
                printf(""\n"");
        }
  }

",45,1364,3087
"struct process
{
    char name[10];
    int AT,BT,CT,TAT,WT,Pr,status;
};
void main()
{
    int n,i,j,sum=0,temp,init_temp,k=0,k1;
    char s[10];
    float Waiting_time;
    printf(""\nEnter the number of processess : "");
    scanf(""%d"",&n);
    struct process p[n];
    for(i=0;i<n;i++)
    {
        printf(""\nEnter name : "");
        scanf(""%s"",p[i].name);
        printf(""\nEnter AT : "");
        scanf(""%d"",&p[i].AT);
        printf(""\nEnter BT : "");
        scanf(""%d"",&p[i].BT);
        printf(""\nEnter priority : "");
        scanf(""%d"",&p[i].Pr);
        p[i].status=0;
    }
    for(i=0;i<n;i++)
    {
        for(j=i+1;j<n;j++)
        {
            if(p[i].Pr>p[j].Pr)
            {
                temp=p[i].AT;
                p[i].AT=p[j].AT;
                p[j].AT=temp;
                temp=p[i].BT;
                p[i].BT=p[j].BT;
                p[j].BT=temp;
                temp=p[i].Pr;
                p[i].Pr=p[j].Pr;
                p[j].Pr=temp;
                strcpy(s,p[i].name);
                strcpy(p[i].name,p[j].name);
                strcpy(p[j].name,s);
            }   
        }
    }
    temp=0;
    while(k<n)
    {
        init_temp;
        for(i=0;i<n;i++)
        {
            if(p[i].AT<=temp && p[i].status==0)
            {
                p[i].CT=p[i].BT+temp;
                temp=temp+p[i].BT;
                k++;
                p[i].status=k;
                break;
            }
        }
        if(init_temp==temp)
            temp++;
    }
    printf(""\nprocess\tAT\tBT\tCT\tTAT\tWT"");
    k1=1;
    while(k1<=k)
    {
        for(i=0;i<n;i++)
        {
            if(p[i].status==k1)
            {
                p[i].TAT=p[i].CT-p[i].AT;
                p[i].WT=p[i].TAT-p[i].BT;
                sum=sum+p[i].WT;
                printf(""\n%s\t%d\t%d\t%d\t%d\t%d"",p[i].name,p[i].AT,p[i].BT,p[i].CT,p[i].TAT,p[i].WT);
                k1++;
            }
        }
    }
    Waiting_time=(sum*1.0)/n;
    printf(""\nAverage Waiting_time : %f"",Waiting_time);
}",45,1365,831
"int Mem[16];
int get_count()
{
    int i,ct=0;
    for(i=0;i<16;i++)
    {
        if(Mem[i]==0)
            ct=ct+1;
    }
    return(ct);
}
void rem_program(int id)
{
    int i,j,k;
    for(i=0;i<16;i++)
    {
        if(Mem[i]==id)
            break;
    }
    for(k=15;k>=0;k--)
    {
        if(Mem[k]==id)
            break;
    }
    j=k-i+1;
    k=k+1;
    while(k<16)
    {
        Mem[i]=Mem[k];
        i++;
        k++;
    }
    k=15;
    while(j!=0)
    {
        Mem[k]=0;
        k--;
        j--;
    }
}
void add_program(int id,int size)
{
    int ct=get_count(),i,ch=1,id1;
    if(ct>=size)
    {
        for(i=0;i<16 && size>0;i++)
        {
            if(Mem[i]==0)
            {
                Mem[i]=id;
                size--;
            }
        }
    }
    else
    {
        while(ch==1)
        {
            printf(""\nIs there any possibility of removing a program : "");
            scanf(""%d"",&ch);
            if(ch==1)
            {
                printf(""\nEnter id : "");
                scanf(""%d"",&id1);
                rem_program(id1);
            }
            else
            {
                break;
            }
        }
        ct=get_count();
        if(ct>=size)
        {
            for(i=0;i<16 && size>0;i++)
            {
                if(Mem[i]==0)
                {
                    Mem[i]=id;
                    size--;
                }
            }
        }
        else
        {
            printf(""\nNot possible"");
        }
    }
}
void display_Mem()
{
    int i;
    printf(""\nMemory is : "");
    for(i=0;i<16;i++)
        printf(""%d\t"",Mem[i]);
}
void main()
{
    int ch,id,size,temp;
    while(1)
    {
        printf(""\nEnter choice : "");
        scanf(""%d"",&ch);
        switch(ch)
        {
            case 1:
            {
                printf(""\nEnter program id : "");
                scanf(""%d"",&id);
                printf(""\nEnter program size in terms of no of segments : "");
                scanf(""%d"",&size);
                add_program(id,size);
                break;
            }
            case 2:
            {
                printf(""\nEnter program id : "");
                scanf(""%d"",&id);
                rem_program(id);
                break;
            }
            case 3:
            {
                display_Mem();
                break;
            }
            default:
            {
                exit(0);
                break;
            }
        }
    }
}",45,1366,833
"int disk[16],d_array[16][16],pos=0;
int ispossible()
{
    int i,ct=0;
    for(i=1;i<16;i++)
    {
        if(disk[i]==0)
            ct++;
    }
    return(ct);
}
void add_file(int id,int size)
{
    int ct=ispossible(),i,j;
    if(ct>=size)
    {
        d_array[pos][0]=id;
        j=1;
        for(i=1;i<16 && size>0;i++)
        {
            if(disk[i]==0)
            {
                disk[i]=id;
                size--;
                d_array[pos][j]=i;
                j++;
            }
        }
        pos++;
    }
    else
    {
        printf(""\nNot possible"");
    }
}
void rem_file(int id)
{
    int i,j;
    for(i=1;i<16;i++)
    {
        if(disk[i]==id)
        {
            disk[i]=0;
        }
    }
    for(i=0;i<16;i++)
    {
        if(d_array[i][0]==id)
        {
            d_array[i][0]=0;
            for(j=1;j<16;j++)
            {
                if(d_array[i][j]!=0)
                    d_array[i][j]=0;
                else
                    break;
            }
        }
    }
}
void display()
{
    int i,j;
    printf(""\nDisk is : ""); 
    for(i=1;i<16;i++)
    {
        printf(""\t%d"",disk[i]);
    }
    printf(""\nd_array is : "");
    for(i=0;i<pos;i++)
    {
        if(d_array[i][0]!=0)
        {
            printf(""\n%d"",d_array[i][0]);
            for(j=1;j<16;j++)   
            {
                if(d_array[i][j]!=0)
                    printf(""\t%d"",d_array[i][j]);
                else
                    break;
            }
        }
    }
}
void main()
{
    int ch,id,size,i;
    for(i=0;i<16;i++)
    {
        disk[i]=0;
    }
    while(1)
    {
        printf(""\nEnter choice : "");
        scanf(""%d"",&ch);
        switch(ch)
        {
            case 1: 
            {
                printf(""\nEnter file id : "");
                scanf(""%d"",&id);
                printf(""\nEnter size : "");
                scanf(""%d"",&size);
                add_file(id,size);
                break;
            }
            case 2:
            {
                printf(""\nEnter file id : "");
                scanf(""%d"",&id);
                rem_file(id);
                break;
            }
            case 3:
            {
                display();
                break;
            }
            default:
            {
                exit(0);
                break;
            }
        }
    }
}",45,1367,840
"#define F 3
int Queue[F],r=-1,f=-1;
int n,page[100];
int find_pos(int pg,int x)
{
    int i,set=0;
    for(i=x;i<n;i++)
    {
        if(page[i]==pg)
        {
            set=i;
            break;
        }
    }
    return(set);
}
void enqueue(int page,int pos)
{
    int i,new,max=0,set=0;
    if(f==-1 && r==-1)
    {
        f=f+1;
        r=r+1;
        Queue[r]=page;
    }
    else if(r<2)
    {
        r=r+1;
        Queue[r]=page;
    }
    else
    {
        max=0;
        for(i=0;i<3;i++)
        {
            new=find_pos(Queue[i],pos+1);
            if(new>max)
            {
                max=new;
                set=i;
            }
            else if(new==0)
            {
                set=i;
                break;
            }
        }
        Queue[set]=page;
    }
}
int isthere(int page)
{
    int i,flag=-1;
    for(i=0;i<3;i++)
    {
        if(Queue[i]==page)
        {
            flag=1;
            break;
        }
    }
    return(flag);
}
void main()
{
    int PFR=0,j,i;
    for(i=0;i<3;i++)
        Queue[i]=-1;
    printf(""\nEnter the  number of pages : "");
    scanf(""%d"",&n);
    for(i=0;i<n;i++)
    {
        printf(""\nEnter page : "");
        scanf(""%d"",&page[i]);
    }
    for(i=0;i<n;i++)
    {
        if(isthere(page[i])==-1)
        {
            enqueue(page[i],i);
            PFR=PFR+1;
        }
        printf(""\nStatus : "");
        for(j=0;j<3;j++)
            printf(""%d\t"",Queue[j]);
    }
    printf(""\nPage Fault Rate is : %d"",PFR);
}",45,1368,622
"int ARR[100];
int TEMP[100];
void Merge(int ARR[],int BEG,int MID,int END)
{
    int k=0,I=BEG,J=MID+1,INDEX=BEG;
    while(I<=MID && J<=END)
    {
        if(ARR[I]<ARR[J])
        {
            TEMP[INDEX]=ARR[I];
            I=I+1;
        }
        else
        {
            TEMP[INDEX]=ARR[J];
            J=J+1;
        }
        INDEX=INDEX+1;
    }
    if(I>MID)
    {
        while(J<=END)
        {
            TEMP[INDEX]=ARR[J];
            J=J+1;
            INDEX=INDEX+1;
        }
    }
    else
    {
        while(I<=MID)
        {
            TEMP[INDEX]=ARR[I];
            I=I+1;
            INDEX=INDEX+1;
        }
    }
    for(k=BEG;k<INDEX;k++)
    {
        ARR[k]=TEMP[k];
    }
}
void MergeSort(int ARR[],int BEG,int END)
{
    int MID;
    if(BEG<END)
    {
        MID=(BEG+END)/2;
        MergeSort(ARR,BEG,MID);
        MergeSort(ARR,MID+1,END);
        Merge(ARR,BEG,MID,END);
    }
}
void main()
{
    int n,i;
    printf(""\nEnter the number of elements in the array:"");
    scanf(""%d"",&n);
    printf(""\nEnter the elements of the array:"");
    for(i=0;i<n;i++)
    {
        scanf(""%d"",&ARR[i]);
    }
    MergeSort(ARR,0,n-1);
    printf(""\nThe sorted array is:\n"");
    for(i=0;i<n;i++)
    {
        printf(""\t%d"",ARR[i]);
    }
}",45,1369,556
"int main()
{
    int soc_fd, bind_fd;
    int connect_fd;
    ssize_t write_fd;
    char buff[]=""data from client\n"";

    struct sockaddr_un addr;
    addr.sun_family = AF_UNIX;

    
    strcpy(addr.sun_path, PATHNAME);
    perror(""strcpy"");

    
    soc_fd = socket(AF_UNIX, SOCK_STREAM, 0);
    perror(""socket"");
    printf(""Return value of Socket = %d\n"",soc_fd);

    
    connect_fd = connect(soc_fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_un));
    perror(""connect"");

    
    write_fd = write(soc_fd, buff, sizeof(buff));
    perror(""write"");

    close(soc_fd);
}
",46,1370,229
"#include ""stack.h""

#define MAX 5

int count = -1;
int arr[MAX];


int full(void);
int empty(void);


void push(int data)
{
    if(full())
    {
        
        printf(""Stack is full\n"");
    }
    else
    {
        
        count++;
        arr[count]=data;
    }
}


void pop(void)
{
    if(empty())
    {
        
        printf(""Stack is empty\n"");
    }
    else
    {
        
        count = count-1;
    }
}


int full()
{
    if(count == (MAX-1))
        return 1;
    else
        return 0;
}


int empty()
{
    if(count == -1)
        return 1;
    else
        return 0;

}

int main()
{
    
    push(10);
    push(11);
    push(12);
    push(13);
    push(14);

    printf(""Before pop\n"");
    int i;
    for(i=0;i<count+1;i++)
        printf(""%d\n"",arr[i]);

    
    pop();
    printf(""After pop\n"");
    for(i=0;i<count+1;i++)
        printf(""%d\n"",arr[i]);
}
",46,1371,362
"#include ""write_to_new_file.h""

int main()
{
    int shmid1;
   int fd;
   ssize_t ret_write;
    char data[136];
    char *data_ptr;

   
    shmid1 = shmget(111, 8192, 0);
    perror(""shmget: "");
    
    
    
    data_ptr = shmat(shmid1, NULL,0);
    perror(""shmat: "");

    
    strcpy(data, data_ptr);

   
    printf(""%s\n"",data);

   
   
   fd = open(""./file"", O_CREAT | O_WRONLY ,0644 );

   
   ret_write = write(fd, data , 136);

   
    shmdt(data_ptr);
    perror(""shmdt: "");

    return 0;
}
",46,1372,239
"#include ""open_read.h""

int main()
{
    int file_des,c;
    ssize_t rd,wt;
    char arr[50],arr1[50];

    file_des = open(""/home/sugu/Linux_Programming/file.txt"",O_RDONLY,0640);

    perror(""open"");
    printf(""File_descriptor %d\n"",file_des);

    rd = read(file_des,arr,10);
    perror(""read"");
    printf(""Read %d\n"",rd);

    snprintf(arr1,10,""%s\n"",arr);
    printf(""%s\n"",arr1);

    c = close(file_des);
    perror(""close"");
    printf(""close%d\n"",c);
}
",46,1373,210
"#include ""sender.h""

int main()
{
   int create_pipe;
   int fd,fd_1;
   ssize_t ret_read,ret_write;

   
   char buffer[9000000];

   
   create_pipe = mknod(""fifo"" , S_IFIFO | 0764,0);

   
   fd = open(""/home/sugu/Downloads/baby.mp3"",O_RDONLY);

   
   ret_read = read(fd,buffer,9000000);
 
   
   fd_1 = open(""fifo"",O_WRONLY);

   
   ret_write = write(fd_1,buffer,9000000);

   
   close(fd);
   close(fd_1);
}
",46,1374,214
"#include ""flock1.h""








int main()
{
    int file_des;
    ssize_t wt;
    char arr[]=""mara_mani"";  
    file_des = open(""./text"",O_RDWR);
    perror(""open"");             

    wt = write(file_des,arr,9); 
    perror(""write"");  

    flock(file_des,LOCK_UN);    
    perror(""flock"");

    close(file_des);            
}

",46,1375,139
"#include ""read_txt_header.h""

int main()
{
    int shmid;
    char data[30];
    char *data_ptr;

    
    shmid = shmget(100, 8192, 0); 
    perror(""shmget: "");
    
    
    data_ptr = shmat(shmid, NULL,0);
    perror(""shmat: "");
    
   
    strcpy(data, data_ptr);
 
   
    printf(""%s\n"",data);

   
    shmdt(data_ptr);
    perror(""shmdt: "");

    return 0;
}
",46,1376,167
"#include ""fstat.h""








int main()
{
    int fst,file_des;
    struct stat detail;

    file_des = open(""./text"",O_RDONLY);
    perror(""open"");
    printf(""fd %d\n"",file_des);

    fst = fstat(file_des,&detail);
    perror(""fstat"");
    printf(""fst %d\n"",fst);

    printf(""inode number %lu\n"",detail.st_ino);
    printf(""hard link  %lu\n"",detail.st_nlink);
    printf(""user id %lu\n"",detail.st_uid);
    printf(""group id %lu\n"",detail.st_gid);
    printf(""size %lu\n"",detail.st_size);
}
",46,1377,208
"#include ""sparse_matrix.h""

int main()
{
    int row,column;

    printf(""Enter the row value\n"");
    scanf(""%d"",&row);
    printf(""Enter the column value\n"");
    scanf(""%d"",&column);

    if(row == 0 | column == 0) {
        printf(""Invalid row or column value\n"");
        exit(0);
    }
    int sparse_matrix[row][column];

    int i, j, size = 0;
    printf(""Enter the values for Sparse matrix\n"");

    for(i = 0; i < row; i++ ) {
        for(j = 0; j < column; j++) {
            printf(""Enter the value of Row %d\t Column %d\n"",i,j);
            scanf(""%d"",&sparse_matrix[i][j]);
            if(sparse_matrix[i][j] != 0)
                size = size + 1;
        }
    }

    int new_matrix[row][size]; 
    int k = 0;
    for(i = 0; i < row; i++ ) {
        for(j = 0; j < column; j++) {
            if( sparse_matrix[i][j] != 0) {
                new_matrix[0][k] = i;
                new_matrix[1][k] = j;
                new_matrix[2][k] = sparse_matrix[i][j];
                k++;
            }
        }
    }


    for(i = 0; i < row; i++ ) {
        i==0 ? printf(""Row   \t"") : i==1 ? printf(""column\t""):printf(""Value \t"");
        for(j = 0; j < size; j++) {
            printf(""%d "",new_matrix[i][j]);
        }
        printf(""\n"");
    }
}
",46,1378,472
"#include ""flock.h""

int main()
{
    int file_des;
    ssize_t wt,rd;
    char arr[]=""sugukavi"";
    char buf[10];
    file_des = open(""./text"",O_CREAT | O_RDWR,0644);
    perror(""open"");              

    wt = write(file_des,arr,8);  
    perror(""write"");

    
    
    flock(file_des,LOCK_EX | LOCK_NB);
    perror(""flock"");
    sleep(10);                   

    rd = read(file_des,buf,8);   
    perror(""read"");

    close(file_des);             
}
",46,1379,188
"#include ""header.h""

struct my_message
{
   long mtype; 
   char buffer[30]; 
};

char string1[]=""string 14 through msgqueue\n"";

int main()
{
   int msgid;
   int size;
   int ret_msgsnd;
   struct my_message msg_buffer;

   
   
   
   msgid = msgget(1004,IPC_CREAT | 0644);
   perror(""msgget"");

   
   strcpy(msg_buffer.buffer,string1);

   
   msg_buffer.mtype = 14; 
   size = strlen(string1)+1;

   
   
   ret_msgsnd = msgsnd(msgid,&msg_buffer,size,0);
   perror(""msgget"");
}
",46,1380,213
"#include""single_linked_list.h""


void print_list();


struct node
{
    char data;
    struct node *next;
};


struct node *head=NULL;
struct node *print_ptr=NULL;

int main()
{
    
    struct node *ptr1 = (struct node *)malloc(sizeof(struct node));
    ptr1->data = 'A';
    ptr1->next = NULL;

    
    struct node *ptr2 = (struct node *)malloc (sizeof(struct node));
    ptr2->data = 'B';
    ptr2->next = NULL;

    head = ptr1;
    
    ptr1->next = ptr2;

    
    printf(""Before insertion\n"");
    print_list();

    
    struct node *insert_ptr = (struct node *)malloc(sizeof(struct node));
    insert_ptr->data = 'C';
    insert_ptr->next = NULL;

    ptr2->next = insert_ptr;

    
    printf(""After insertion\n"");
    print_list();

    
    ptr2->next = NULL;

    printf(""After deletion\n"");
    print_list();

    
    free(ptr1);
    free(ptr2);
    free(insert_ptr);
}
void print_list()
{
    int index=0;
    print_ptr = head;
    while(print_ptr!=NULL)
    {
        
        index++;
        
        printf(""Node Index %d Data value %c\n"",index,print_ptr->data);
        
        print_ptr=print_ptr->next;
    }
}
",46,1381,406
"#include ""single_link_list.h""


struct node
{
    int regno;
    char *name;
    struct node *next;
};
struct node * head = NULL;
struct node * print_ptr = NULL;
struct node * sort = NULL;
void sort_node();

int i=0;
void print_list();

void insert_node(int data,char *ptr3)
{
    struct node *ptr = (struct node *)malloc(sizeof(struct node));
    ptr->regno = data;
    ptr->name = ptr3;
    ptr->next = head;
    head = ptr;
    i++;
}

int main()
{
    
    insert_node(3,""you"");
    insert_node(1,""i"");
    insert_node(2,""love"");

    printf(""\nBefore sorting\n"");
    print_list();

    sort_node();

    printf(""\nAfter sorting\n"");
    print_list();

}

void sort_node()
{
    print_ptr=sort= head;
    int j=0,regno;
    char *name;

    
    while(sort != NULL)
    {
        
        print_ptr = head;
        for(j=0 ;j<i; j++)
        {
            
            if(sort->regno < print_ptr->regno)
            {
                
                regno = print_ptr->regno;
                name = print_ptr->name;
                print_ptr->regno = sort->regno;
                print_ptr->name = sort->name;
                sort->regno = regno;
                sort->name = name;
            }
            
            print_ptr = print_ptr->next;
        }
        sort = sort->next;;
    }
}

void print_list()
{
    int i=0;
    
    print_ptr = head;
    while(print_ptr != NULL)
    {
        i++;
        printf(""node %d regno %d name %s\n"",i,print_ptr->regno,print_ptr->name);
        print_ptr = print_ptr->next;
    }
}
",46,1382,532
"#include ""tree.h""



struct database {
    int roll_no;
    struct database *left;
    struct database *right;
};

extern struct database * root;
struct database *root = NULL;


void add_element(void);


void print_element(void);


void inorder(struct  database *node);
void preorder(struct  database *node);
void postorder(struct  database *node);

void inorder_1(struct  database *node);
void preorder_1(struct  database *node);
void postorder_1(struct  database *node);

int main(){
    add_element();
    add_element();
    add_element();
    add_element();
    add_element();
    add_element();

    printf(""Inorder\n"");
    inorder(root);
    printf(""preorder\n"");
    preorder(root);
    printf(""postorder\n"");
    postorder(root);
    printf(""Inorder_1\n"");
    inorder_1(root);
    printf(""preorder_1\n"");
    preorder_1(root);
    printf(""postorder_1\n"");
    postorder_1(root);

    return 0;
}

void add_element(void) 
{
    struct database * current_node = root;
    struct database * temp_ptr = (struct database* )malloc (sizeof(struct database ));

    printf(""Enter the value:"");
    scanf(""%d"",&temp_ptr->roll_no);

    temp_ptr->left = NULL;
    temp_ptr->right = NULL;
    
    if(root == NULL){
        root = temp_ptr;
    } else {
        while (current_node != NULL) {
            if(temp_ptr->roll_no > current_node->roll_no){
                if (current_node->right !=NULL){
                    current_node = current_node ->right;
                } else {
                    current_node->right = temp_ptr;
                    return;
                }
            }else {
                if(current_node->left !=NULL){
                    current_node = current_node->left;
                }else {
                    current_node->left = temp_ptr;
                    return;
                }
            }
        }
    }

}



void inorder(struct  database *node){
    if(node == NULL){
        return;
    } else { 
        inorder(node->left);
        printf(""%d\n"",node->roll_no);
        inorder(node->right);
    }
}

void preorder(struct database *node){
    if(node == NULL) {
        return;
    } else {
        printf(""%d\n"",node->roll_no);
        preorder(node->left);
        preorder(node->right);
    }
}

void postorder(struct database *node){
    if(node == NULL) {
        return;
    } else {
        postorder(node->left);
        postorder(node->right);
        printf(""%d\n"",node->roll_no);
    }
}

void inorder_1(struct database *node){
    if(node == NULL){
        return;
    } else {
        inorder_1(node->right);
        printf(""%d\n"",node->roll_no);
        inorder_1(node->left);
    }
}

void preorder_1(struct database *node){
    if(node == NULL) {
        return;
    } else {
        printf(""%d\n"",node->roll_no);
        preorder_1(node->right);
        preorder_1(node->left);
    }
}

void postorder_1(struct database *node){
    if(node == NULL) {
        return;
    } else {
        postorder_1(node->right);
        postorder_1(node->left);
        printf(""%d\n"",node->roll_no);
    }
}
",46,1383,990
"#include ""truncate.h""


int main()
{
    int tr,file_des,sn;
    char buf[10],snp[30],snp1[30];
    char buf1[8]=""sugukavi"";
    ssize_t rd,wt;

    file_des = open(""./text"",O_CREAT | O_RDWR,0644);
    perror(""open"");                   
    printf(""fd %d\n"",file_des);       

    wt = write(file_des,buf1,8);      
    perror(""write"");
    printf(""write %d\n"",wt);

    rd = read(file_des,buf,8);        
    perror(""read"");
    printf(""read %d\n"",rd);

    sn = snprintf(snp1,20,""%s"",buf);   
    printf(""%s\n"",snp1);              
    printf(""snprintf %d\n"",sn);

    tr = truncate(""./text"",20);       
    perror(""truncate"");
    printf(""truncate %d\n"",tr);

    lseek(file_des,0,SEEK_SET);       
    rd = read(file_des,buf,20);      
    perror(""read"");

    snprintf(snp1,20,""%s"",buf);
    printf(""%s\n"",snp1);

    close(file_des);                  
}
",46,1384,370
"#include ""read_data_print.h""

int main()
{
   int fd,m_sync,unmap;
   char *addr;
   ssize_t rd;
   char buffer[20];

   
   fd = shm_open(""/posix"", O_RDWR , 0);
   perror(""shm_open"");

   
   addr = mmap(NULL, 20 , PROT_READ | PROT_WRITE , MAP_SHARED, fd, 0);
   perror(""mmap"");

   printf(""%s\n"",addr);

   
   
   shm_unlink(""/posix"");
}
",46,1385,165
"#include ""P_msgq_rcv.h""

char buffer[8192];

int main()
{
    int mq_op_ret,mq_rcv_ret;
    struct mq_attr my_mq_attr;
    unsigned int msg_pri = 10;

    my_mq_attr.mq_flags    = 0;
    my_mq_attr.mq_maxmsg  = 10;
    my_mq_attr.mq_msgsize = 8192;

    
    
    mq_op_ret = mq_open(""/P_msgq"", O_RDONLY);
    perror(""mq_open"");

    printf(""ret value of mq_open = %d\n"",mq_op_ret);

    
    
    mq_rcv_ret = mq_receive(mq_op_ret, buffer, 8192,&msg_pri);
    perror(""mq_receive"");

    printf(""ret value of mq_receive = %d\n"",mq_rcv_ret);
    printf(""Data from sender ==> %s\n"",buffer);

}
",46,1386,287
"#include ""receiver.h""

int main()
{
   int ret_val;
   int fd,fd_1;
   char buffer[9000000];
   ssize_t ret_read,ret_write;

   
   fd = open(""fifo"",O_RDONLY);
   perror(""open :"");

   
   ret_read = read(fd,buffer,9000000);
   perror(""read :"");

   
   fd_1 = open(""rcv.mp3"", O_CREAT | O_WRONLY ,0764);
   perror(""read :"");

   
   ret_write = write(fd_1,buffer,9000000);
   perror(""close :"");

   
   close(fd);
   close(fd_1);
}
",46,1387,213
"#include ""open_read_write.h""

int main()
{
    int file_des,i;
    char arr[13]=""hi i am arr1\n"";
    char arr1[13]=""hi i am arr1\n"";
    char arr2[13]=""hi i am arr2\n"";
    char rd_fd[100];
    char sarr[100];

    file_des = open(""/home/sugu/Linux_Programming/file.txt"",O_CREAT | O_RDWR,0655);
    perror(""open"");

    ssize_t wt,rd;

    
    i=lseek(file_des,0,SEEK_SET); 
    perror(""lseek"");              
    printf(""lseek%d\n"",i);        

    
    wt = write(file_des,arr,13);  
    perror(""write"");              
    printf(""write%d\n"",wt);       

    
    rd = read(file_des,rd_fd,13); 
    perror(""read"");               
    printf(""Read%d\n"",rd);        
    snprintf(sarr,13,""%s\n"",rd_fd);
    printf(""%s\n"",sarr);           
    i=lseek(file_des,0,SEEK_CUR);  
    perror(""lseek"");               
    printf(""lseek%d\n"",i);         

    
    wt = write(file_des,arr1,13);  
    perror(""write"");               
    printf(""write%d\n"",wt);        

    
    rd = read(file_des,rd_fd,13);  
    perror(""read"");                
    printf(""read%d\n"",rd);         
    snprintf(sarr,13,""%s\n"",rd_fd);
    printf(""%s\n"",sarr);           

    i=lseek(file_des,-15,SEEK_END);
    perror(""lseek"");               
    printf(""lseek%d\n"",i);         

    
    wt = write(file_des,arr2,13);  
    perror(""write"");               
    printf(""write%d\n"",wt);        

    
    rd = read(file_des,rd_fd,13);  
    perror(""read"");                
    printf(""Read%d\n"",rd);         
    snprintf(sarr,13,""%s\n"",rd_fd);
    printf(""%s\n"",sarr);           

    close(file_des);               
    perror(""close"");
}
",46,1388,667
"#include ""semaphore.h""

char str[]=""semaphore is in lock\n"";
char buff[1024];

int main()
{
    int open_fd;
        ssize_t write_fd,read_fd;
    struct sembuf sem_buf;
    sem_buf.sem_num = 3;
    sem_buf.sem_op  = -1;

    int semid;
        
    semid = semget(93, 5,IPC_CREAT | 0600);
    perror(""semget"");

    
    semop(semid, &sem_buf, 1); 
    perror(""semop"");

        open_fd = open(""test.txt"",O_CREAT | O_RDONLY, 0644);
        perror(""open"");

        read_fd = read(open_fd, buff, 1024);
        perror(""read"");
  
        close(open_fd);
        perror(""close"");
   
        for(int i=0; i<10; i++) {
              printf(""%s\n"",buff);
              sleep(1);
        }

    sem_buf.sem_op = 1;
    semop(semid, &sem_buf, 1);
    perror(""semop"");
}
",46,1389,330
"#include ""ftruncate.h""


int main()
{
    int ftr,file_des;
    char buf[10],snp[30],snp1[30];
    char buf1[8]=""sugukavi"";
    ssize_t rd,wt;

    file_des = open(""./ftext"",O_CREAT | O_RDWR,0644); 
    perror(""open"");                  

    wt = write(file_des,buf1,8);     
    perror(""write"");

    ftr = ftruncate(file_des,4);     
    perror(""ftruncate"");
    printf(""ftruncate %d\n"",ftr);    

    lseek(file_des,0,SEEK_SET);      
    rd = read(file_des,buf,5);       
    perror(""read"");

    snprintf(snp1,5,""%s"",buf);       
    printf(""%s"",snp1);

    close(file_des);                 
}
",46,1390,266
"#include ""collects_msg.h""

struct my_message
{
  long mtype; 
  char Buffer[150]; 
};

int main()
{
  int msgid;
  int shmid1,i=0,j;
  char *data_ptr;
  int ret_msgrcv;
  struct my_message msg_buffer;
  char str[136];

  
  
  msgid = msgget(1001,0644);
  perror(""msgget :"");

  
  
  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,11 ,0);
  perror(""msgrcv :"");

  
  for(j=0 ;msg_buffer.Buffer[j]!='\0'; i++ ,j++)
     str[i]=msg_buffer.Buffer[j];
  
  str[i]='\n';

  
  
  msgid = msgget(1002,0644);
  perror(""msgget :"");

  
  
  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,12 ,0);
  perror(""msgrcv :"");

  
  for(j=0 ;msg_buffer.Buffer[j]!='\0'; i++ ,j++)
     str[i]=msg_buffer.Buffer[j];
  
  str[i]='\n';

  
  
  msgid = msgget(1003,IPC_CREAT|0644);
  perror(""msgget :"");

  
  
  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,13 ,0); 
  perror(""msgrcv :"");

  
  for(j=0 ;msg_buffer.Buffer[j]!='\0'; i++ ,j++)
     str[i]=msg_buffer.Buffer[j];
  
  str[i]='\n';

  
  
  msgid = msgget(1004,IPC_CREAT|0644);
  perror(""msgget :"");

  
  
  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,14 ,0); 
  perror(""msgrcv :"");

  
  for(j=0 ;msg_buffer.Buffer[j]!='\0'; i++ ,j++)
     str[i]=msg_buffer.Buffer[j];
  
  str[i]='\n';

  
  
  msgid = msgget(1005,IPC_CREAT|0644);
  perror(""msgget :"");

  
  
  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,15 ,0); 
  perror(""msgrcv :"");

  
  for(j=0 ;msg_buffer.Buffer[j]!='\0'; i++ ,j++)
     str[i]=msg_buffer.Buffer[j];
  
  str[i]='\n';

  
  printf(""i = %d\n"",i);

  
  shmid1 = shmget(111,8192,IPC_CREAT | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
  perror(""shmget :"");

  
  data_ptr = shmat(shmid1,NULL,0);
  perror(""shmat  :"");

  
  strcpy(data_ptr,str);

  
  shmdt(data_ptr);
  perror(""shmdt  :"");
  return 0;
}
",46,1391,936
"#include ""store_txt_header.h""

int main()
{
   int fd,shmid;
   ssize_t rd,op;
   char buffer[30],*data_ptr;

   
   fd = open(""./txt"",O_RDONLY);

   
   rd = read(fd,buffer,20);

   
   shmid = shmget(100,8192,IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH); 
   perror(""shmget "");

   
   data_ptr = shmat(shmid,NULL,0);
   perror(""shmat  "");

   
   strcpy(data_ptr,buffer);

   
   shmdt(data_ptr);
   perror(""shmdt  "");
   return 0;
}
",46,1392,230
"#include ""msg_q_crt.h""


struct mymsg {
    long mtype;
    char mtext[200];
};


char str1[]=""Message from str1\n"";
char str2[]=""Message from str2\n"";
char str3[]=""Message from str3\n"";

int main(){
    printf(""\033[1;31mSystem V Message queue Creating a message\033[0m\n"");
    int mesg_id,msgsnd_return;

    struct mymsg my_data1,my_data2,my_data3;

    
    my_data1.mtype  = 1; 
    my_data2.mtype  = 2;
    my_data3.mtype  = 3;

    
    strncpy(my_data1.mtext,str1,strlen(str1)+1);
    strncpy(my_data2.mtext,str2,strlen(str2)+1);
    strncpy(my_data3.mtext,str3,strlen(str3)+1);

    
    mesg_id = msgget(103,IPC_CREAT|0644);
    perror(""msgget"");

    
    
    msgsnd_return = msgsnd(mesg_id, &my_data1, strlen(str1)+1, 1);
    perror(""msgsnd"");
    msgsnd_return = msgsnd(mesg_id, &my_data2, strlen(str2)+1, 2);
    perror(""msgsnd"");
    msgsnd_return = msgsnd(mesg_id, &my_data3, strlen(str3)+1, 3);
    perror(""msgsnd"");
}
",46,1393,445
"#include ""queue.h""

#define SIZE 10

int queue[SIZE], front = -1, rear = -1;

void enqueue(void);
void dequeue(void);
void display(void);


int main()
{
    int choice;

    while(1){
        printf(""Enter the choice\n1. Insertion\n2. Deletion\n3. Display\n4. Exit\n"");
        scanf(""%d"",&choice);

        switch (choice){
            case 1:
                enqueue();
                break;
            case 2:
                dequeue();
                break;
            case 3:
                display();
                break;
            case 4:
                exit(0);
            default:
                printf(""Invalid Choice\n"");
        }
    }
}

void enqueue(void) {
    int value;
    printf(""Enter the value to insert\n"");
    scanf(""%d"",&value);

    if(rear == SIZE-1){
        printf(""Queue is Full!!!\n"");
    }else {
        if(front == -1)
            front = 0;
        rear = rear +1;
        queue[rear] = value;
        printf(""Inserion Success..!!!\n"");
    }
}

void dequeue(void) {
    if(front == rear)
        printf(""Queue is Empty!!\n"");
    else {
        printf(""Dleted : %d"",queue[front]);
        front = front+1;
        if(front == rear)
            front = rear = -1;
    }
}

void display(void){
    if(rear == -1)
        printf(""Queue is empty\n"");
    else {
        int i;
        printf(""Queue elements are:\n"");
        for(i=front; i<=rear; i++)
            printf(""%d\t"",queue[i]);
        printf(""\n"");
    }
}
",46,1394,481
"#include ""fork.h""

int main()
{
    pid_t pid;

    pid = fork();

    if(pid == 0) {
        printf(""child process....\n"");
        printf(""PID = %d\nPPID = %d\n"",getpid(),getppid());
        printf(""child process exit......\n"");
    }
    else if(pid > 0 ){
        int status;
        printf(""Before child process creation\n"");

        pid_t wt_rv = wait(&status);
        printf(""Parent process....\n"");

        printf(""PID = %d\nPPID = %d\n"",getpid(),getppid());
        printf(""Status %d\n"",WIFEXITED(status));  

        printf(""Wait ret value %d\n"",wt_rv);
        printf(""Parent process exit......\n"");
    }
    else{
        printf(""Fork failed\n"");
    }
}
",46,1395,240
"#include ""P_msgq_snd.h""

char str[]=""Data from POSIX msg queue send\n"";









int main()
{
    int mq_op_ret,mq_send_ret;
    struct mq_attr my_mq_attr;

    my_mq_attr.mq_flags   = 0;   
    my_mq_attr.mq_maxmsg  = 10;
    my_mq_attr.mq_msgsize = 8192;

    
    
    mq_op_ret = mq_open(""/P_msgq"", O_CREAT | O_RDWR, 0644, &my_mq_attr);
    perror(""mq_open"");

    printf(""ret value of mq_open = %d\n"",mq_op_ret);

    
    mq_send_ret = mq_send(mq_op_ret, str, strlen(str)+1,10);
    perror(""mq_send"");

    printf(""ret value of mq_send = %d\n"",mq_send_ret);
}
",46,1396,281
"#include ""posix_shm.h""

int main()
{
   int open_fd, munmap_ret, msync_ret;
   ssize_t write_fd;
   char *mmap_ret;
   char buff[50]=""Data stored in posix shared memory\n"";

   
   open_fd = shm_open(""/posix"" , O_CREAT | O_RDWR | O_TRUNC , 0644);
   if(open_fd == -1){
       perror(""shm_open"");
       printf(""Return value of shm_open %d\n"",open_fd);
   }else {
       perror(""shm_open"");
       printf(""Return value of shm_open %d\n"",open_fd);
   }


   
   write_fd = write(open_fd,buff,strlen(buff)+1);
   if(write_fd == -1){
    perror(""write"");
   }else {
    perror(""write"");
   }

   
   
   mmap_ret = mmap(NULL , 4096 , PROT_READ | PROT_WRITE, MAP_SHARED ,open_fd ,0);
   perror(""mmap"");

   
   
   msync_ret = msync(mmap_ret, 4096, MS_SYNC);
   if(msync_ret == -1){
       perror(""msync"");
   }else {
       perror(""msync"");
   }

   
   munmap_ret = munmap(mmap_ret, 4096);
   if(munmap_ret == -1) {
       perror(""munmap"");
   }else {
       perror(""munmap"");
   }       
   
}
",46,1397,440
"int main()
{
    int soc_fd, bind_fd;
    int listen_fd, accept_fd;
    ssize_t read_fd;
    char buff[1024];

    struct sockaddr_un addr;
    addr.sun_family = AF_UNIX;

    strcpy(addr.sun_path, PATHNAME);
    perror(""strcpy"");

    
    soc_fd = socket(AF_UNIX, SOCK_STREAM, 0);
    perror(""socket"");

    
    bind_fd = bind(soc_fd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un));
    perror(""bind"");

    
    listen_fd = listen(soc_fd, 11);
    perror(""listen"");

    
    accept_fd = accept(soc_fd, NULL, NULL);
    perror(""accept"");

    
    read_fd = read(accept_fd, buff, 30);
    perror(""read"");

    printf(""Data from client\n"");
    printf(""==> %s\n"",buff);

}
",46,1398,278
"void err_thread(int ret, char *str)
{
    if(ret != 0)
    {
        fprintf(stderr, ""%s:%s\n"", str, strerror(ret));
        pthread_exit(NULL);
    }
}

struct msg
{
    int num;
    struct msg *next; 
};
struct msg *head;

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;      
pthread_cond_t has_data = PTHREAD_COND_INITIALIZER;     

void *producer(void *arg)
{
    while(1)
    {
        struct msg *mp = malloc(sizeof(struct msg));
        mp->num = rand() % 1000 + 1;                    
        printf(""-----produce %d\n"", mp->num);

        pthread_mutex_lock(&mutex);                     
        mp->next = head;                                
        head = mp;
        pthread_mutex_unlock(&mutex);                   

        pthread_cond_signal(&has_data);              

        sleep(rand()%3);
    }

    return NULL;
}

void *comsumer(void *arg)
{
    while(1)
    {
        pthread_mutex_lock(&mutex);                     

        while(head == NULL)                             
        {
            pthread_cond_wait(&has_data, &mutex);       
        }                                               

        struct msg *mp = head;
        head = head->next;
         
        pthread_mutex_unlock(&mutex);                   
        printf(""----------comsumer id: %lu : %d\n"", pthread_self(), mp->num);

        free(mp);
        sleep(rand()%3);
    }

    return NULL;
}

int main()
{
    srand(time(NULL));

    pthread_t pid, cid1, cid2, cid3;
    int ret = pthread_create(&pid, NULL, producer, NULL);   
    if(ret != 0)
        err_thread(ret, ""pthread_create producer error"");

    ret = pthread_create(&cid1, NULL, comsumer, NULL);       
    if(ret != 0)
        err_thread(ret, ""pthread_create comsumer error"");

    ret = pthread_create(&cid2, NULL, comsumer, NULL);       
    if(ret != 0)
        err_thread(ret, ""pthread_create comsumer error"");
    
    ret = pthread_create(&cid3, NULL, comsumer, NULL);       
    if(ret != 0)
        err_thread(ret, ""pthread_create comsumer error"");

    pthread_join(pid, NULL);
    pthread_join(cid1, NULL);
    pthread_join(cid2, NULL);
    pthread_join(cid3, NULL);

    return 0;
}",47,1399,747
"int main(int argc, char *argv[])
{
    pid_t pid = fork();
    if(pid == -1)
    {
        perror(""fork error"");
        exit(1);
    }
    else if(pid == 0)
    {
        printf(""I'm child, pid = %d, going to sleep 10s\n"", getpid());
        sleep(10);
        printf(""--------child die---------\n"");
    }
    else if(pid > 0)
    {
        int wpid;
        int status;
        
        wpid = wait(&status);       
        if(wpid == -1)
        {
            perror(""wait error"");
            exit(1);
        }
        if(WIFEXITED(status))       
        {
            printf(""child exit with %d\n"", WEXITSTATUS(status));
        }
        if(WIFSIGNALED(status))     
        {  
            printf(""child bekill with signal %d\n"", WTERMSIG(status));
        }
        printf(""-----parent wait child %d finish-----\n"", wpid);
    }

    return 0;
}",47,1400,289
"void isFile(char *filename);

void readDir(char *dir)
{
    
    DIR *dp = opendir(dir);
    if(dp == NULL)
    {
        perror(""opendir error"");
        return;
    }

    
    char path[256] = {0};
    struct dirent *sdp;
    while((sdp = readdir(dp)) != NULL)
    {
        if(strcmp(sdp->d_name, ""."") == 0 || strcmp(sdp->d_name, "".."") == 0)
            continue;
        
        
        sprintf(path, ""%s/%s"", dir, sdp->d_name);
        
        isFile(path);
    }

    closedir(dp);
    return;
}

void isFile(char *filename)
{
    
    struct stat buf;
    int ret = stat(filename, &buf);
    if(ret == -1)
    {
        perror(""stat error"");
        return;
    }

    
    if(S_ISDIR(buf.st_mode))
    {
        readDir(filename);
    }

    
    printf(""%s\t%ld\n"", filename, buf.st_size);

    return;
}

int main(int argc, char *argv[])
{
    
    if(argc == 1)
    {
        isFile(""."");
    }
    else
    {
        isFile(argv[1]);
    }

    return 0;
}",47,1401,385
"#define MAXLINE 10

int main(int argc, char *argv[])
{
    char buf[MAXLINE];
    char ch = 'a';

    int pfd[2];
    pipe(pfd);

    pid_t pid = fork();
    if(pid == 0)            
    {
        close(pfd[0]);
        int i;
        while(1)
        {
            
            for(i = 0; i < MAXLINE/2; i++)
            {
                buf[i] = ch;
            }
            buf[i-1] = '\n';
            ch++;

            
            for(; i < MAXLINE; i++)
            {
                buf[i] = ch;
            }
            buf[i-1] = '\n';
            ch++;
            
            write(pfd[1], buf, sizeof(buf));
            sleep(5);
        }
        close(pfd[1]);
    }
    else if(pid > 0)        
    {
        close(pfd[1]);

        struct epoll_event event;               
        struct epoll_event resevent[10];        
 
        int efd = epoll_create(10);
        event.events = EPOLLIN|EPOLLET;         
        
        event.data.fd = pfd[0];
        epoll_ctl(efd, EPOLL_CTL_ADD, pfd[0], &event);

        int res, len;
        while(1)
        {
            res = epoll_wait(efd, resevent, 10, -1);
            
            if(resevent[0].data.fd == pfd[0])
            {
                len = read(pfd[0], buf, MAXLINE/2);
                write(STDOUT_FILENO, buf, len);
            }
        }

        close(pfd[0]);
        close(efd);
    }
    else
    {
        perror(""fork"");
        exit(-1);
    }
    return 0;
}
",47,1402,511
"#include ""../../base.h""




#define MAXLINE 80
#define OPEN_MAX 1024

int main()
{
    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);

    int opt = 1;
    setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in serv_adr;
    bzero(&serv_adr, sizeof(serv_adr));
    serv_adr.sin_family = AF_INET;
    serv_adr.sin_port = htons(9999);
    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);

    Bind(serv_sock, (struct sockaddr*)&serv_adr, sizeof(serv_adr));

    Listen(serv_sock, 128);

    int epfd = epoll_create(OPEN_MAX);                          
    if(epfd == -1)
        sys_err(""epoll_create() error"");

    struct epoll_event temp;                                    
    struct epoll_event ep[OPEN_MAX];                            

    temp.events = EPOLLIN;                                      
    temp.data.fd = serv_sock;

    int res = epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, &temp); 
    if(res == -1)
        sys_err(""epoll_ctl() error"");

    
    char buf[MAXLINE], str[INET_ADDRSTRLEN];
    struct sockaddr_in clnt_adr;
    socklen_t clnt_adr_len;
    int ret, conn_sock, clnt_sock, i, n, num = 0;
    while(1)
    {
        ret = epoll_wait(epfd, ep, OPEN_MAX, -1);               
        if(ret == -1)
            sys_err(""epoll_wait() error"");
        
        for(i = 0; i < ret; i++)
        {
            if(!ep[i].events & EPOLLIN)                         
                continue;
            
            if(ep[i].data.fd == serv_sock)
            {
                clnt_adr_len = sizeof(clnt_adr);
                conn_sock = Accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_len);

                printf(""receive from %s at PORT %d\n"", inet_ntop(AF_INET, &clnt_adr.sin_addr, str, sizeof(str)), ntohs(clnt_adr.sin_port));
                printf(""cfd %d --- client %d\n"", conn_sock, ++num);

                temp.events = EPOLLIN;
                temp.data.fd = conn_sock;
                res = epoll_ctl(epfd, EPOLL_CTL_ADD, conn_sock, &temp);     
                if(res == -1)
                    sys_err(""epoll_ctl() error"");
            }
            else
            {
                clnt_sock = ep[i].data.fd;
                n = Read(clnt_sock, buf, MAXLINE);
                if(n == 0)
                {
                    res = epoll_ctl(epfd, EPOLL_CTL_DEL, clnt_sock, NULL);  
                    if(res == -1)
                        sys_err(""epoll_ctl() error"");
                    Close(clnt_sock);
                    printf(""client[%d] closed connection\n"", clnt_sock);
                }
                else
                {
                    for(i = 0; i < n; i++)
                        buf[i] = toupper(buf[i]);
                    
                    Write(STDOUT_FILENO, buf, n);
                    Write(clnt_sock, buf, n);
                }
            }
        }
    }
    Close(serv_sock);
    Close(epfd);
    return 0;
}",47,1403,1019
"int main(int argc, char *argv[])
{
    struct stat buf;
    
    int ret = lstat(argv[1], &buf);
    if(ret == -1)
    {
        perror(""stat error"");
        exit(1);
    }

    printf(""file size:%d\n"", buf.st_size);
    printf(""inode number:%d\n"", buf.st_ino);

    if(S_ISREG(buf.st_mode))
        printf(""%s is a regular file\n"", argv[1]);
    else if(S_ISDIR(buf.st_mode))
        printf(""%s is a directory\n"", argv[1]);
    else if(S_ISLNK(buf.st_mode))
        printf(""%s is a symbolic link\n"", argv[1]);      
    

    return 0;
}",47,1404,214
"void sys_err(const char *str)
{
    perror(str);
    exit(1);
}

void* thread_fun(void *arg)
{
    printf(""thread:pid = %d, tid = %lu\n"", getpid(), pthread_self());
    return NULL;
}

int main()
{
    printf(""main:pid = %d, tid = %lu\n"", getpid(), pthread_self());
    
    pthread_t tid;
    int ret = pthread_create(&tid, NULL, thread_fun, NULL);
    if(ret != 0)
        sys_err(""pthread_create error"");

    sleep(1);
    return 0;    
}",47,1405,174
"#include ""../../base.h""




#define MAXLINE 80
#define OPEN_MAX 1024

int main()
{
    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);

    int opt = 1;
    setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in serv_adr;
    bzero(&serv_adr, sizeof(serv_adr));
    serv_adr.sin_family = AF_INET;
    serv_adr.sin_port = htons(9999);
    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);

    Bind(serv_sock, (struct sockaddr*)&serv_adr, sizeof(serv_adr));

    Listen(serv_sock, 128);

    struct pollfd client[OPEN_MAX];
    client[0].fd = serv_sock;       
    client[0].events = POLLIN;      

    for(int i = 1; i < OPEN_MAX; i++)
    {
        client[i].fd = -1;
    }

    int maxi = 0;           
    char buf[MAXLINE], str[INET_ADDRSTRLEN];
    struct sockaddr_in clnt_adr;
    socklen_t clnt_adr_len;
    int ret, conn_sock, clnt_sock, i, n;
    while(1)
    {
        ret = poll(client, maxi+1, -1);
        if(ret < 0)
        {
            sys_err(""poll() err"");
        }

        if(client[0].revents & POLLIN)
        {
            clnt_adr_len = sizeof(clnt_adr);
            conn_sock = Accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_len);
            printf(""receive from %s at PORT %d\n"", inet_ntop(AF_INET, &clnt_adr.sin_addr, str, sizeof(str)), ntohs(clnt_adr.sin_port));

            for(i = 1; i < OPEN_MAX; i++)
            {
                if(client[i].fd < 0)
                {
                    client[i].fd = conn_sock;           
                    break;
                }
            }
            if(i == OPEN_MAX)
            {
                fputs(""too many clients\n"", stderr);            
                exit(1);
            }
            
            client[i].events = POLLIN;                  
            if(i > maxi)
                maxi = i;                               
            if(--ret <= 0)
                continue;                               
        }

        for(i = 1; i <= maxi; i++)
        {
            if((clnt_sock = client[i].fd) < 0)
                continue;

            if(client[i].revents & POLLIN)
            {
                if((n = Read(clnt_sock, buf, MAXLINE)) < 0)
                {
                    if(errno == ECONNRESET)             
                    {
                        printf(""client[%d] aborted connection\n"", i);
                        Close(clnt_sock);
                        client[i].fd = -1;              
                    }
                    else
                    {
                        sys_err(""read() error"");
                    }
                }
                else if(n == 0)                         
                {
                    printf(""client[%d] closed connection\n"", i);
                    Close(clnt_sock);
                    client[i].fd = -1;
                }
                else
                {
                    for(int j = 0; j < n; j++)
                        buf[j] = toupper(buf[j]);
                    Write(clnt_sock, buf, n);
                }

                if(--ret <= 0)
                    break;
            }
        }
    }
    Close(serv_sock);
    return 0;
}",47,1406,1044
"int main(int argc, char *argv[])
{
    FILE *fp1 = fopen(argv[1], ""r"");
    if(fp1 == NULL)
    {
        perror(""file1 fopen error"");
        exit(1);
    }

    FILE *fp2 = fopen(argv[2], ""w"");
    if(fp2 == NULL)
    {
        perror(""file2 fopen error"");
        exit(1);
    }

    int n;
    while((n = fgetc(fp1)) != EOF)
    {
        fputc(n, fp2);
    }
    
    fclose(fp1);
    fclose(fp2);
    return 0;
}




",47,1407,184
"int main()
{
    pid_t pid;
    if((pid = fork()) < 0)
    {
        perror(""fork error"");
        exit(1);
    }
    else if(pid == 0)
    {
        sleep(5);
        printf(""Child process PID is %d\n"", getpid());
        printf(""Group ID of child is %d\n"", getpgid(0));
        printf(""Session ID of child is %d\n"", getsid(0));

        sleep(10);
        setsid();           

        printf(""Changed:\n"");

        printf(""Child process PID is %d\n"", getpid());
        printf(""Group ID of child is %d\n"", getpgid(0));
        printf(""Session ID of child is %d\n"", getsid(0));

        sleep(10);
    }

    sleep(5);       
    return 0;
}",47,1408,227
"int main()
{
    int i;
    pid_t wpid, temp;
    for(i = 0; i < 5; i++)
    {
        temp = fork();
        if(temp == 0)
            break;
    }

    if(i == 5)
    {
        

        while((wpid = waitpid(-1, NULL, WNOHANG)) != -1)        
        {
            if(wpid > 0)
            {
                printf(""wait child pid = %d\n"", wpid);
            }
            else if(wpid == 0)
            {
                
            }
            
        }
    }
    else
    {
        sleep(i);
        printf(""I'm %dth child, pid = %d\n"", i+1, getpid());
    }

    return 0;
}",47,1409,213
"void sys_err(const char *str)
{
    perror(str);
    exit(1);
}

void* thread_fun(void *arg)
{
    int i = (int)arg;
    sleep(i);
    if(i == 2)
    {
        
        
        pthread_exit(NULL);
    }
    printf(""I'm %dth thread:pid = %d, tid = %lu\n"", i+1, getpid(), pthread_self());
    return NULL;
}

int main()
{
    int i;
    int ret;
    pthread_t tid;

    for(i = 0; i < 5; i++)
    {
        ret = pthread_create(&tid, NULL, thread_fun, (void*)i);
        if(ret != 0)
            sys_err(""pthread_create error"");
    }

    
    printf(""I'm main thread:pid = %d, tid = %lu\n"", getpid(), pthread_self());

    
    pthread_exit(NULL);     
}",47,1410,267
"void sys_err(const char *str)
{
    perror(str);
    exit(1);
}

struct student
{
    int id;
    char name[256];
    int age;
};

int main()
{
    struct student stu = {1, ""zhangsan"", 18};
    int fd = open(""temp"", O_RDWR|O_CREAT|O_TRUNC, 0644);
    if(fd == -1)
        sys_err(""open error"");

    ftruncate(fd, sizeof(stu)); 

    struct student *p = mmap(NULL, sizeof(stu), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if(p == MAP_FAILED)
        sys_err(""mmap error"");

    close(fd);
    
    while(1)
    {
        memcpy(p, &stu, sizeof(stu));
        stu.id++;
        sleep(1);
    }

    munmap(p, sizeof(stu));

    return 0;
}",47,1411,283
"void sys_error(const char *str)
{
    perror(str);
    exit(1);
}

int main()
{
    int fd[2];
    int ret = pipe(fd);
    if(ret == -1)
        sys_error(""pipe error"");
    
    int i;
    for(i = 0; i < 2; i++)
    {
        pid_t pid = fork();
        if(pid == -1)
            sys_error(""fork error"");
        else if(pid == 0)
            break;
    }

    char buf[1024];
    int n;
    if (i == 0)
    {
        close(fd[1]);
        n = read(fd[0], buf, 6);
        write(STDOUT_FILENO, buf, n);
    }
    else if (i == 1)
    {
        close(fd[1]);
        n = read(fd[0], buf, 6);
        write(STDOUT_FILENO, buf, n);
    }
    else if(i == 2)
    {
        close(fd[0]);
        write(fd[1], ""hello world\n"", strlen(""hello world\n""));

        wait(NULL);
        wait(NULL);
    }

    return 0;
}",47,1412,331
"#include ""../../base.h""



#define MAXLINE 10

int main(int argc, char *argv[])
{
    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in serv_adr;
    bzero(&serv_adr, sizeof(serv_adr));
    serv_adr.sin_family = AF_INET;
    serv_adr.sin_port = htons(9999);
    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);

    Bind(serv_sock, (struct sockaddr*)&serv_adr, sizeof(serv_adr));

    Listen(serv_sock, 128);

    struct epoll_event event;               
    struct epoll_event resevent[10];        

    int efd = epoll_create(10);
    event.events = EPOLLIN|EPOLLET;       
    

    printf(""Accepting connection ...\n"");

    struct sockaddr_in clnt_adr;
    socklen_t clnt_adr_len = sizeof(clnt_adr);
    int clnt_sock = Accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_len);

    char str[INET_ADDRSTRLEN];
    printf(""receive from %s at PORT %d\n"", inet_ntop(AF_INET, &clnt_adr.sin_addr, str, sizeof(str)), ntohs(clnt_adr.sin_port));

    event.data.fd = clnt_sock;
    epoll_ctl(efd, EPOLL_CTL_ADD, clnt_sock, &event);

    int res, len;
    char buf[MAXLINE];
    while(1)
    {
        res = epoll_wait(efd, resevent, 10, -1);
        
        if(resevent[0].data.fd == clnt_sock)
        {
            len = read(clnt_sock, buf, MAXLINE/2);
            write(STDOUT_FILENO, buf, len);
        }
    }

    Close(serv_sock);
    Close(efd);
    return 0;
}
",47,1413,572
"void sys_error(const char *str)
{
    perror(str);
    exit(1);
}

int main()
{
    int fd[2];
    int ret = pipe(fd);
    if(ret == -1)
        sys_error(""pipe error"");
    
    int i;
    for(i = 0; i < 2; i++)
    {
        pid_t pid = fork();
        if(pid == -1)
            sys_error(""fork error"");
        else if(pid == 0)
            break;
    }

    if(i == 2)
    {
        
        
        wait(NULL);
        wait(NULL);
    }
    else if (i == 0)
    {
        close(fd[0]);
        dup2(fd[1], STDOUT_FILENO);
        execlp(""ls"", ""ls"", NULL);
        sys_error(""execlp ls error"");
    }
    else if (i == 1)
    {
        close(fd[1]);
        dup2(fd[0], STDIN_FILENO);
        execlp(""wc"", ""wc"", ""-l"", NULL);
        sys_error(""execlp wc error"");
    }

    return 0;
}",47,1414,312
"int val1;
int val2;
pthread_mutex_t mutex1;
pthread_mutex_t mutex2;

void* fun1(void *arg)
{
    pthread_mutex_lock(&mutex1);
    printf(""val1 = %d\n"", val1);
    sleep(1);
    pthread_mutex_lock(&mutex2);
    val2 = 100;
    printf(""val2 = %d\n"", val2);
    pthread_mutex_unlock(&mutex2);
    pthread_mutex_unlock(&mutex1);

    return NULL;
}

void* fun2(void *arg)
{
    pthread_mutex_lock(&mutex2);
    printf(""val2 = %d\n"", val2);
    sleep(1);
    pthread_mutex_lock(&mutex1);
    val1 = 200;
    printf(""val1 = %d\n"", val1);
    pthread_mutex_unlock(&mutex1);
    pthread_mutex_unlock(&mutex2);
    return NULL;
}

int main()
{
    pthread_mutex_init(&mutex1, NULL);
    pthread_mutex_init(&mutex2, NULL);
    pthread_t tid1, tid2;

    pthread_create(&tid1, NULL, fun1, NULL);
    pthread_create(&tid2, NULL, fun2, NULL);

    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);

    pthread_mutex_destroy(&mutex1);
    pthread_mutex_destroy(&mutex2);
    return 0;
}",47,1415,430
"void* thread_fun(void *arg)
{   
    while(1)
    {
        printf(""thread:pid = %d, tid = %lu\n"", getpid(), pthread_self());
        sleep(1);
    }
    
    return NULL;
}

int main()
{
    pthread_t tid;
    int ret = pthread_create(&tid, NULL, thread_fun, NULL);
    if(ret != 0)
    {
        fprintf(stderr, ""pthread_create error:%s\n"", strerror(errno));
        exit(1);
    }

    printf(""main:pid = %d, tid = %lu\n"", getpid(), pthread_self());
    sleep(5);
    ret = pthread_cancel(tid);          
    if(ret != 0)
    {
        fprintf(stderr, ""pthread_cancel error:%s\n"", strerror(errno));
        exit(1);
    }
    
    while(1);

    return 0;    
}",47,1416,256
"int main()
{
    int fd = open(""/dev/tty"", O_RDONLY|O_NONBLOCK);
    if(fd < 0)
    {
        perror(""open /dev/tty"");
        exit(1);
    }
    printf(""open /dev/tty ok, fd = %d\n"", fd);

    char buf[10];
    int n;
    while(1)
    {
        n = read(fd, buf, 10);
        if(n < 0)
        {
            if(errno != EAGAIN)
            {
                perror(""read /dev/tty"");
                exit(1);
            }
            else
            {
                write(STDOUT_FILENO, ""try again\n"", strlen(""try again\n""));
                sleep(2);
                continue;
            }
        }
        break;
    }

    write(STDOUT_FILENO, buf, n);
    close(fd);

    return 0;
}
",47,1417,255
"#include ""../../base.h""


          

#define MAXLINE 10

int main(int argc, char *argv[])
{
    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in serv_adr;
    bzero(&serv_adr, sizeof(serv_adr));
    serv_adr.sin_family = AF_INET;
    serv_adr.sin_port = htons(9999);
    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);

    Bind(serv_sock, (struct sockaddr*)&serv_adr, sizeof(serv_adr));

    Listen(serv_sock, 128);

    struct epoll_event event;               
    struct epoll_event resevent[10];        

    int efd = epoll_create(10);
    event.events = EPOLLIN|EPOLLET;       

    printf(""Accepting connection ...\n"");

    struct sockaddr_in clnt_adr;
    socklen_t clnt_adr_len = sizeof(clnt_adr);
    int clnt_sock = Accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_len);

    char str[INET_ADDRSTRLEN];
    printf(""receive from %s at PORT %d\n"", inet_ntop(AF_INET, &clnt_adr.sin_addr, str, sizeof(str)), ntohs(clnt_adr.sin_port));

    int flag = fcntl(clnt_sock, F_GETFL);       
    flag |= O_NONBLOCK;
    fcntl(clnt_sock, F_SETFL, flag);

    event.data.fd = clnt_sock;
    epoll_ctl(efd, EPOLL_CTL_ADD, clnt_sock, &event);

    int res, len;
    char buf[MAXLINE];
    while(1)
    {
        printf(""epoll_wait begin\n"");
        res = epoll_wait(efd, resevent, 10, -1);
        printf(""epoll_wait end res %d\n"", res);

        if(resevent[0].data.fd == clnt_sock)
        {
            while((len = read(clnt_sock, buf, MAXLINE/2)) > 0)      
                write(STDOUT_FILENO, buf, len);
        }
    }

    Close(serv_sock);
    Close(efd);
    return 0;
}
",47,1418,659
"struct thrd
{
    int var;
    char str[256];
};

void sys_err(const char *str)
{
    perror(str);
    exit(1);
}

void* thread_fun(void *arg)
{
    struct thrd *tval;
    tval = malloc(sizeof(struct thrd));
    tval->var = 100;
    strcpy(tval->str, ""hello thread"");

    return (void *)tval;
}

int main()
{
    pthread_t tid;
    int ret = pthread_create(&tid, NULL, thread_fun, NULL);
    if(ret != 0)
        sys_err(""pthread_create error"");
    
    struct thrd *retval;
    ret = pthread_join(tid, (void**)&retval);
    if(ret != 0)
        sys_err(""pthread join error"");

    printf(""child thread exit with var = %d, str = %s\n"", retval->var, retval->str);

    pthread_exit(NULL);
}",47,1419,272
"void sys_error(char *str)
{
    perror(str);
    exit(1);
}

int main()
{
    int fd[2];
    int ret = pipe(fd);
    if(ret == -1)
        sys_error(""pipe error"");
    
    char str[] = ""hello world\n"";
    char buf[100];
    int pid = fork();
    if(pid == 0)
    {
        close(fd[1]);
        
        int n = read(fd[0], buf, sizeof(buf));
        if(n > 0)
        {
            printf(""%s"", buf);
        }
        else
        {
            sys_error(""read error"");
        }
        close(fd[0]);
    }
    else if (pid > 0)
    {
        close(fd[0]);
        int n = write(fd[1], str, strlen(str));
        if(n > 0)
        {
            printf(""write ok, n = %d\n"", n);
        }
        sleep(1);
        close(fd[1]);
    }
    
    return 0;
}",47,1420,286
"void myfunc(int signo)
{
    printf(""hello world\n"");
}

int main()
{
    struct itimerval newit, oldit;

    signal(SIGALRM, myfunc);

    newit.it_value.tv_sec = 2;
    newit.it_value.tv_usec = 0;

    newit.it_interval.tv_sec = 5;
    newit.it_interval.tv_usec = 0;

    if(setitimer(ITIMER_REAL, &newit, &oldit) == -1)
    {
        perror(""setitimer error"");
        return -1;
    }
    while(1);
    
    return 0;
}",47,1421,188
"pthread_mutex_t mutex;  

void *fun(void *arg)
{
    srand(time(NULL));

    while (1)
    {
        pthread_mutex_lock(&mutex);     
        printf(""hello "");
        sleep(rand()%3);    
        printf(""world\n"");
        pthread_mutex_unlock(&mutex);   
        sleep(rand()%3);
    }

    return NULL;
}

int main()
{
    srand(time(NULL));
    pthread_t tid;

    int ret = pthread_mutex_init(&mutex, NULL);     
    if(ret != 0)
    {
        fprintf(stderr, ""pthread_mutex_init error:%s\n"", strerror(ret));
        exit(1);
    }

    pthread_create(&tid, NULL, fun, NULL);
    while (1)
    {
        pthread_mutex_lock(&mutex);     
        printf(""HELLO "");
        sleep(rand()%3);
        printf(""WORLD\n"");
        pthread_mutex_unlock(&mutex);   
        sleep(rand()%3);
    }
    pthread_join(tid, NULL);
    pthread_mutex_destroy(&mutex);      
    return 0;
}",47,1422,332
"int val = 100;

void sys_err(const char *str)
{
    perror(str);
    exit(1);
}

int main()
{
    pid_t pid = fork();
    if(pid > 0)
    {
        while(1)
        {
            printf(""parent, pid = %d\n"", getpid());
            sleep(1);
        }
    }
    else if(pid == 0)
    {
        

        

        sleep(5);
        printf(""child pid = %d, ppid = %d\n"", getpid(), getppid());         
        kill(0, SIGKILL);
    }
    
    return 0;
}",47,1423,177
"#define _POSIX_SOURCE







void sys_err(const char* str)
{
    perror(str);
    exit(1);
}

void print_set(sigset_t *pset)
{
    for(int i = 1; i < 32; i++)
    {
        if(sigismember(pset, i))
            putchar('1');
        else
            putchar('0');
    }
    printf(""\n"");
}

int main()
{
    sigset_t set;
    sigemptyset(&set);
    sigaddset(&set, SIGINT);
    sigaddset(&set, SIGQUIT);
    sigaddset(&set, SIGKILL);   
    sigaddset(&set, SIGBUS);

    sigset_t oldset;
    int ret = sigprocmask(SIG_BLOCK, &set, &oldset);
    if(ret == -1)
        sys_err(""sigprocmask error"");
    
    sigset_t pendset;
    while(1)
    {
        ret = sigpending(&pendset);
        if(ret == -1)
            sys_err(""sigpending error"");

        print_set(&pendset);
        sleep(1);
    }

    return 0;
}",47,1424,330
"#include ""../../base.h""


#define MAXLINE 10

int main(int argc, char *argv[])
{
    int sockfd = Socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in serv_adr;
    bzero(&serv_adr, sizeof(serv_adr));
    serv_adr.sin_family = AF_INET;
    serv_adr.sin_port = htons(9999);
    inet_pton(AF_INET, ""127.0.0.1"", &serv_adr.sin_addr.s_addr);
    
    Connect(sockfd, (struct sockaddr*)&serv_adr, sizeof(serv_adr));

    char ch = 'a';
    char buf[MAXLINE];
    int i;
    while(1)
    {
        
        for(i = 0; i < MAXLINE/2; i++)
        {
            buf[i] = ch;
        }
        buf[i-1] = '\n';
        ch++;

        
        for(; i < MAXLINE; i++)
        {
            buf[i] = ch;
        }
        buf[i-1] = '\n';
        ch++;
        
        write(sockfd, buf, sizeof(buf));
        sleep(5);
    }

    Close(sockfd);
    return 0;
}
",47,1425,349
"void* thread_fun(void *arg)
{
    printf(""thread:pid = %d, tid = %lu\n"", getpid(), pthread_self());
    return NULL;
}

int main()
{
    pthread_t tid;
    int ret = pthread_create(&tid, NULL, thread_fun, NULL);
    if(ret != 0)
    {
        fprintf(stderr, ""pthread_create error: %s\n"", strerror(ret));   
        exit(1);
    }
    
    ret = pthread_detach(tid);              
    if(ret != 0)
    {
        fprintf(stderr, ""pthread_detach error: %s\n"", strerror(ret));
        exit(1);
    }

    sleep(1);

    ret = pthread_join(tid, NULL);
    
    if(ret != 0)                                    
    {
        fprintf(stderr, ""pthread_join error: %s\n"", strerror(ret));
        exit(1);
    }

    printf(""main:pid = %d, tid = %lu\n"", getpid(), pthread_self());

    return 0;    
}",47,1426,298
"#define MSG_TRY ""try again\n""

int main()
{
    int flags = fcntl(STDIN_FILENO, F_GETFL);   
    if(flags == -1)
    {
        perror(""fcntl error"");
        exit(1);
    }
    
    flags |= O_NONBLOCK;
    int ret = fcntl(STDIN_FILENO, F_SETFL, flags);
    if(ret == -1)
    {
        perror(""fcntl error"");
        exit(1);
    }

    char buf[10];
    int n;
    while(1)
    {
        n = read(STDIN_FILENO, buf, 10);
        if(n < 0)
        {
            if(errno != EAGAIN)
            {
                perror(""read /dev/tty"");
                exit(1);
            }
            else
            {
                write(STDOUT_FILENO, MSG_TRY, strlen(MSG_TRY));
                sleep(2);
                continue;
            }
        }
        break;
    }

    write(STDOUT_FILENO, buf, n);

    return 0;
}
",47,1427,312
"#include ""../../base.h""




int main()
{
    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);

    int opt = 1;
    setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in serv_adr;
    bzero(&serv_adr, sizeof(serv_adr));
    serv_adr.sin_family = AF_INET;
    serv_adr.sin_port = htons(9999);
    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);

    Bind(serv_sock, (struct sockaddr *)&serv_adr, sizeof(serv_adr));

    Listen(serv_sock, 128);

    int maxfd = serv_sock;          

    fd_set rset, allset;            
    FD_ZERO(&allset);               
    FD_SET(serv_sock, &allset);     
     
    int clnt_sock;
    struct sockaddr_in clnt_adr;
    socklen_t clnt_adr_len;
    char buf[BUFSIZ];
    int ret, n;
    while(1)
    {
        rset = allset;              
        ret = select(maxfd+1, &rset, NULL, NULL, NULL);     
        if (ret < 0)
        {
            sys_err(""select() error"");
        }

        if(FD_ISSET(serv_sock, &rset))                      
        {
            clnt_adr_len = sizeof(clnt_adr);
            clnt_sock = Accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_len);      
            FD_SET(clnt_sock, &allset);                     
            
            if(maxfd < clnt_sock)       
                maxfd = clnt_sock;
            
            if(ret == 1)                
                continue;
        }

        for(int i = serv_sock+1; i <= maxfd; i++)   
        {
            if(FD_ISSET(i, &rset))
            {
                n = Read(i, buf, sizeof(buf));
                if(n == 0)
                {
                    Close(i);
                    FD_CLR(i, &allset);             
                }
                else
                {
                    for(int j = 0; j < n; j++)
                    {
                        buf[j] = toupper(buf[j]);
                    }
                    Write(i, buf, n);
                    Write(STDOUT_FILENO, buf, n);
                }
            }
        } 
    }

    Close(serv_sock);
    return 0;
}",47,1428,716
"void sys_err(const char *str)
{
    perror(str);
    exit(1);
}

int main()
{
    int fd = open(""testmap"", O_RDWR|O_CREAT|O_TRUNC, 0644);
    if(fd == -1)
        sys_err(""open error"");

    
    
    ftruncate(fd, 20);              

    int len = lseek(fd, 0, SEEK_END);
    char *p = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if(p == MAP_FAILED)
        sys_err(""mmap error"");

    
    strcpy(p, ""hello map"");
    printf(""%s\n"", p);

    int ret = munmap(p, len);
    if(ret == -1)
        sys_err(""munmap error"");

    return 0;
}",47,1429,250
"void sys_err(const char *str)
{
    perror(str);
    exit(1);
}

int main(int argc, char *argv[])
{
    int serv_sock = socket(AF_INET, SOCK_STREAM, 0);
    if(serv_sock == -1)
    {
        sys_err(""socket() error"");
    }

    int ret = 0;
    struct sockaddr_in serv_addr;
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(9999);
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    ret = bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
    if(ret == -1)
    {
        sys_err(""bind() error"");
    }
    
    ret = listen(serv_sock, 128);
    if(ret == -1)
    {
        sys_err(""listen() error"");
    }

    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_len = sizeof(clnt_addr);
    int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_len);
    if(clnt_sock == -1)
    {
        sys_err(""accept error"");
    }

    char clnt_IP[1024];
    printf(""client ip:%s, port:%d\n"", inet_ntop(AF_INET, &clnt_addr.sin_addr.s_addr, clnt_IP, sizeof(clnt_IP)), ntohs(clnt_addr.sin_port));

    char buf[BUFSIZ];
    while(1)
    {
        int ret = read(clnt_sock, buf, sizeof(buf));
        if(ret == 0)
        {
            break;
        }
        write(STDOUT_FILENO, buf, ret);

        for(int i = 0; i < ret; i++)
        {
            buf[i] = toupper(buf[i]);
        }
        write(clnt_sock, buf, ret);
    }

    close(serv_sock);
    close(clnt_sock);
    return 0;
}",47,1430,592
"#include ""../base.h""
    



struct clnt_info                
{
    struct sockaddr_in clnt_addr;
    int clnt_sock; 
};

void *do_work(void *arg)
{
    struct clnt_info *p_cInfo = (struct clnt_info *)arg;
    char buf[BUFSIZ];
    char str[16];       
    int n;

    while(1)
    {
        n = Read(p_cInfo->clnt_sock, buf, sizeof(buf));
        if(n == 0)
        {
            printf(""the client %d closed...\n"", p_cInfo->clnt_sock);
            break;
        }

        printf(""received from %s at PORT %d\n"", inet_ntop(AF_INET, &(p_cInfo->clnt_addr.sin_addr), str, sizeof(str)), ntohs(p_cInfo->clnt_addr.sin_port));  

        for(int i = 0; i < n; i++)
        {
            buf[i] = toupper(buf[i]);
        }

        Write(STDOUT_FILENO, buf, n);
        Write(p_cInfo->clnt_sock, buf, n);
    }
    Close(p_cInfo->clnt_sock);
    return (void*)0;        
}

int main()
{
    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in serv_addr;
    bzero(&serv_addr, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(9999);
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    
    
    Bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

    Listen(serv_sock, 128);

    printf(""Accepting client connect...\n"");
    struct clnt_info c_info[256];
    int i = 0;
    int clnt_sock;
    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_len;
    pthread_t tid;
    while(1)
    {
        clnt_addr_len = sizeof(clnt_addr);
        clnt_sock = Accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_len);
        c_info[i].clnt_addr = clnt_addr;
        c_info[i].clnt_sock = clnt_sock;

        pthread_create(&tid, NULL, do_work, (void*)&c_info[i]);     
        pthread_detach(tid);            
        i++;
    }

    return 0;
}",47,1431,738
"int main()
{
    int i;
    pid_t pid, wpid, temp;
    for(i = 0; i < 5; i++)
    {
        temp = fork();
        if(temp == 0)
            break;
        
        if(i == 2)
        {
            pid = temp;
            printf(""2th child pid = %d\n"", pid);
        }
    }

    if(i == 5)
    {
        sleep(5);
        
        wpid = waitpid(pid, NULL, WNOHANG);         
        if(wpid == -1)
        {
            perror(""waitpid error"");
            exit(1);
        }
        printf(""I'm parent, wait a child finish : %d\n"", wpid);
    }
    else
    {
        sleep(i);
        printf(""I'm %dth child, pid = %d\n"", i+1, getpid());
    }

    return 0;
}",47,1432,247
"void* thread_fun(void *arg)
{
    printf(""thread:pid = %d, tid = %lu\n"", getpid(), pthread_self());
    return NULL;
}

int main()
{
    pthread_attr_t attr;
    int ret = pthread_attr_init(&attr);
    if(ret != 0)
    {
        fprintf(stderr, ""pthread_attr_init error:%s\n"", strerror(ret));
        exit(1);
    }

    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);      
    if(ret != 0)
    {
        fprintf(stderr, ""pthread_attr_init error:%s\n"", strerror(ret));
        exit(1);
    }

    pthread_t tid;
    ret = pthread_create(&tid, &attr, thread_fun, NULL);
    if(ret != 0)
    {
        fprintf(stderr, ""pthread_create error:%s\n"", strerror(ret));
        exit(1);
    }

    ret = pthread_attr_destroy(&attr);
    if(ret != 0)
    {
        fprintf(stderr, ""pthread_attr_destroy error:%s\n"", strerror(ret));
        exit(1);
    }

    ret = pthread_join(tid, NULL);
    if(ret != 0)
    {
        fprintf(stderr, ""pthread_join error:%s\n"", strerror(ret));
        exit(1);
    }

    printf(""main:pid = %d, tid = %lu\n"", getpid(), pthread_self());

    return 0;    
}",47,1433,430
"#define NUM 5
int queue[NUM];                        
sem_t blank_number;                     
sem_t product_number;                   
int i = 0;

void *product(void *arg)
{
    int i = 0;
    while(1)
    {
        sem_wait(&blank_number);                    
        queue[i] = rand() % 1000 + 1;              
        printf(""-----Produce %d\n"", queue[i]);                     

        sem_post(&product_number);     
        i = (i+1) % NUM;                    

        sleep(rand()%1);
    }
}

void *comsumer(void *arg)
{
    while(1)
    {
        sem_wait(&product_number);                 
        printf(""Comsume:%lu queue[%d]=%d\n"", pthread_self(), i, queue[i]);           
        queue[i] = 0;                                                 
        sem_post(&blank_number);     
        i = (i+1) % NUM;                                       
        
        sleep(rand()%2);
    }
}

int main()
{
    srand(time(NULL));
    pthread_t cid[5], pid;

    sem_init(&blank_number, 0, NUM);            
    sem_init(&product_number, 0, 0);            

    pthread_create(&pid, NULL, product, NULL);
    for(int i = 0; i < 5; i++)
    {
        pthread_create(&cid[i], NULL, comsumer, NULL);
    }

    pthread_join(pid, NULL);
    for(int i = 0; i < 5; i++)
    {
        pthread_join(cid[i], NULL);
    }

    sem_destroy(&blank_number);
    sem_destroy(&product_number);

    return 0;
}",47,1434,481
"void sys_err(const char *str)
{
    perror(str);
    exit(1);
}

void* thread_fun(void *arg)
{
    int i = *((int*)arg);           
    sleep(i);
    printf(""I'm %dth thread:pid = %d, tid = %lu\n"", i+1, getpid(), pthread_self());
    return NULL;
}

int main()
{
    int i;
    int ret;
    pthread_t tid;

    for(i = 0; i < 5; i++)
    {
        ret = pthread_create(&tid, NULL, thread_fun, (void*)&i);    
        if(ret != 0)
            sys_err(""pthread_create error"");
    }

    sleep(6);
    printf(""I'm main thread:pid = %d, tid = %lu\n"", getpid(), pthread_self());

    return 0;    
}",47,1435,242
"#define MSG_TRY ""try again\n""
#define MSG_TIMEOUT ""time out\n""

int main()
{
    int fd = open(""/dev/tty"", O_RDONLY|O_NONBLOCK);
    if(fd < 0)
    {
        perror(""open /dev/tty"");
        exit(1);
    }
    printf(""open /dev/tty ok, fd = %d\n"", fd);

    char buf[10];
    int i, n;
    for(i = 0; i < 5; i++)
    {
        n = read(fd, buf, 10);
        if(n > 0)
            break;

        if(errno != EAGAIN)
        {
            perror(""read /dev/tty"");
            exit(1);
        }
        else
        {
            write(STDOUT_FILENO, MSG_TRY, strlen(MSG_TRY));
            sleep(2);
        }
    }

    if(i == 5)
        write(STDOUT_FILENO, MSG_TIMEOUT, strlen(MSG_TIMEOUT));
    else
        write(STDOUT_FILENO, buf, n);

    close(fd);
    return 0;
}
",47,1436,326
"#include ""../base.h""

int main(int argc, char *argv[])
{
    int clnt_sock = Socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in serv_addr;
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(9999);
    inet_pton(AF_INET, ""127.0.0.1"", &serv_addr.sin_addr.s_addr);
    Connect(clnt_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

    int ret;
    int counter = 10;
    char buf[BUFSIZ];
    while(counter--)
    {
        Write(clnt_sock, ""hello\n"", 6);
        ret = Read(clnt_sock, buf, sizeof(buf));
        if(ret == 0)
        {
            break;
        }
        Write(STDOUT_FILENO, buf, ret);
        sleep(1);
    }

    Close(clnt_sock);
    return 0;
}",47,1437,286
"#include ""../base.h""

int main(int argc, char *argv[])
{
    int clnt_sock = Socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in serv_addr;
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(9999);
    inet_pton(AF_INET, ""127.0.0.1"", &serv_addr.sin_addr.s_addr);
    Connect(clnt_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

    int ret;
    int counter = 10;
    char buf[BUFSIZ];
    while(counter--)
    {
        Write(clnt_sock, ""hello\n"", 6);
        ret = Read(clnt_sock, buf, sizeof(buf));
        if(ret == 0)
        {
            break;
        }
        Write(STDOUT_FILENO, buf, ret);
        sleep(1);
    }

    Close(clnt_sock);
    return 0;
}",47,1438,286
"#include ""base.h""

void sys_err(const char *str)
{
    perror(str);
    exit(1);
}

int Socket(int domain, int type, int protocol)
{
    int sockfd = socket(domain, type, protocol);
    if(sockfd == -1)
    {
        sys_err(""socket() error"");
    }
    return sockfd;
}

int Bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
{
    int ret = bind(sockfd, addr, addrlen);
    if(ret == -1)
    {
        sys_err(""bind() error"");
    }
    return ret;
}

int Listen(int sockfd, int backlog)
{
    int ret = listen(sockfd, backlog);
    if(ret == -1)
    {
        sys_err(""listen() error"");
    }
    return ret;
}

int Accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
{
    int clnt_sock;
    while((clnt_sock = accept(sockfd, addr, addrlen)) == -1)
    {
        if(errno == EINTR)      
            continue;
        else
            sys_err(""accept() error"");
    }
    return clnt_sock;
}

int Connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
{
    int ret = connect(sockfd, addr, addrlen);
    if(ret == -1)
    {
        sys_err(""connect() error"");
    }
    return ret;
}

ssize_t Read(int fd, void *buf, size_t count)
{
    int ret;
    while((ret = read(fd, buf, count)) == -1)
    {                                           
        if(errno == EINTR)                      
            continue;                           
        else
            sys_err(""read() error"");
    }
    return ret;
}

ssize_t Write(int fd, const void *buf, size_t count)
{
    int ret;
    while((ret = write(fd, buf, count)) == -1)
    {
        if(errno == EINTR)
            continue;
        else
            sys_err(""write() error"");
    }
    return ret;
}

int Close(int fd)
{
    int ret = close(fd);
    if(ret == -1)
    {
        sys_err(""close() error"");
    }
    return ret;
}",47,1439,658
"int main()
{
    int fd = open(""temp.txt"", O_RDWR|O_CREAT|O_TRUNC, 0644);
    if(fd < 0)
    {
        perror(""open temp error"");
        exit(1);
    }

    int ret;
    ret = unlink(""temp.txt"");       
    if(ret < 0)
    {
        perror(""unlink error"");
        exit(1);
    }

    char *p1 = ""test of unlink\n"";
    char *p2 = ""after write something\n"";
    ret = write(fd, p1, strlen(p1));
    if(ret == -1)
        perror(""write error"");

    printf(""write ok\n"");
    ret = write(fd, p2, strlen(p2));
    if(ret == -1)
        perror(""write error"");

    printf(""Enter any key continue\n"");
    getchar();

    

    close(fd);

    

    return 0;
}",47,1440,265
"#include ""../../base.h""




int main()
{
    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);

    int opt = 1;
    setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in serv_adr;
    bzero(&serv_adr, sizeof(serv_adr));
    serv_adr.sin_family = AF_INET;
    serv_adr.sin_port = htons(9999);
    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);

    Bind(serv_sock, (struct sockaddr *)&serv_adr, sizeof(serv_adr));

    Listen(serv_sock, 128);

    int maxfd = serv_sock;          

    int maxi = -1;                  
    int clnt[FD_SETSIZE];           
    for(int i = 0; i < FD_SETSIZE; i++)
    {
        clnt[i] = -1;
    }

    fd_set rset, allset;            
    FD_ZERO(&allset);              
    FD_SET(serv_sock, &allset);  
     
    int clnt_sock;
    struct sockaddr_in clnt_adr;
    socklen_t clnt_adr_len;
    char buf[BUFSIZ], str[INET_ADDRSTRLEN];     
    int ret, n, i, sockfd;
    while(1)
    {
        rset = allset;                          
        ret = select(maxfd+1, &rset, NULL, NULL, NULL);     
        if (ret < 0)
        {
            sys_err(""select() error"");
        }

        if(FD_ISSET(serv_sock, &rset))                      
        {
            clnt_adr_len = sizeof(clnt_adr);
            clnt_sock = Accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_len);
            printf(""received from %s at PORT %d\n"", inet_ntop(AF_INET, &clnt_adr.sin_addr, str, sizeof(str)), ntohs(clnt_adr.sin_port));

            for(i = 0; i < FD_SETSIZE; i++)             
            {
                if(clnt[i] < 0)
                {
                    clnt[i] = clnt_sock;            
                    break;
                }
            }
            if(i == FD_SETSIZE)                         
            {
                fputs(""too many clients\n"", stderr);
                exit(1);
            }

            FD_SET(clnt_sock, &allset);                     
            
            if(maxfd < clnt_sock)       
                maxfd = clnt_sock;
            
            if(i > maxi)                    
                maxi = i;

            if(--ret == 0)                       
                continue;
        }

        for(i = 0; i <= maxi; i++)          
        {
            if((sockfd = clnt[i]) < 0)
            {
                continue;
            }
            if(FD_ISSET(sockfd, &rset))
            {
                n = Read(sockfd, buf, sizeof(buf));
                if(n == 0)     
                {
                    Close(sockfd);
                    FD_CLR(sockfd, &allset);
                    clnt[i] = -1;           
                }
                else
                {
                    for(int j = 0; j < n; j++)
                    {
                        buf[j] = toupper(buf[j]);
                    }
                    Write(sockfd, buf, n);
                    Write(STDOUT_FILENO, buf, n);
                }

                if(--ret == 0)
                    break;          
            }
        } 
    }

    Close(serv_sock);
    return 0;
}",47,1441,1039
"void sys_error(const char *str)
{
    perror(str);
    exit(1);
}

int main(int argc, char *argv[])
{
    if(argc < 2)
    {
        printf(""enter a fifo name\n"");
        return -1;
    }

    int fd = open(argv[1], O_WRONLY);
    if(fd < 0)
        sys_error(""open error"");
    
    int i = 0;
    char buf[1024];
    while(1)
    {
        sprintf(buf, ""hello world %d\n"", i++);
        write(fd, buf, strlen(buf));
        sleep(1);
    }

    close(fd);
    return 0;
}
",47,1442,198
"void* thread_fun1(void *arg)
{   
    printf(""thread 1 return\n"");
    return (void*)111;
}

void* thread_fun2(void *arg)
{   
    printf(""thread 2 return\n"");
    pthread_exit((void*)222);
}

void* thread_fun3(void *arg)
{   
    

    

    
   
    return (void*)666;
}

int main()
{
    pthread_t tid;
    void *retval = NULL;

    pthread_create(&tid, NULL, thread_fun1, NULL);
    pthread_join(tid, &retval);
    printf(""thread 1 exit code = %d\n\n"", (int)retval);

    pthread_create(&tid, NULL, thread_fun2, NULL);
    pthread_join(tid, &retval);
    printf(""thread 2 exit code = %d\n\n"", (int)retval);

    pthread_create(&tid, NULL, thread_fun3, NULL);
    sleep(3);
    pthread_cancel(tid);
    pthread_join(tid, &retval);
    printf(""thread 3 exit code = %d\n\n"", (int)retval);     

    return 0;    
}",47,1443,332
"#define _POSIX_SOURCE










void sys_err(const char* str)
{
    perror(str);
    exit(1);
}

void catch_child(int signo)
{
    pid_t wpid;
    int status;

    
    while((wpid = waitpid(-1, &status, 0)) != -1)      
    {
        if(WIFEXITED(status))
            printf(""catch child, pid = %d, ret = %d\n"", wpid, WEXITSTATUS(status));
    }

    
    
    
    return;
}

int main()
{
    
    sigset_t set;
    sigemptyset(&set);
    sigaddset(&set, SIGCHLD);
    sigprocmask(SIG_BLOCK, &set, NULL);

    pid_t pid;
    int i;
    for(i = 0; i < 10; i++)
    {
        if((pid =fork()) == 0)          
            break;
    }

    if(i == 10)
    {
        struct sigaction act;               
        act.sa_handler = catch_child;       
        sigemptyset(&act.sa_mask);          
        act.sa_flags = 0;                   
        sigaction(SIGCHLD, &act, NULL);     

        
        sigprocmask(SIG_UNBLOCK, &set, NULL);   

        printf(""I'm parent, pid = %d\n"", getpid());
        
        int num = 0;
        while(1)
        {
            printf(""num = %d\n"", num++);
            sleep(1);
        }
    }
    else
    {
        printf(""I'm child, pid = %d\n"", getpid());
        return i;
    }

    return 0;
}",47,1444,473
"int main(int argc, char *argv[])
{
    int fd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0644);
    if(fd < 0)
    {
        perror(""open error"");
        exit(1);
    }

    char msg[] = ""It's a test for lseek\n"";
    write(fd, msg, strlen(msg));    

    

    int n;
    char ch;
    while(n = read(fd, &ch, 1))
    {
        if(n < 0)
        {
            perror(""read error"");
            exit(1);
        }
        write(STDOUT_FILENO, &ch, n);
    }

    close(fd);
    return 0;
}",47,1445,207
"void sys_error(const char *str)
{
    perror(str);
    exit(1);
}

int main()
{
    int fd[2];
    int ret = pipe(fd);
    if(ret == -1)
        sys_error(""pipe error"");
    
    pid_t pid = fork();
    if(pid == -1)
    {   
        sys_error(""fork error"");
    }
    else if (pid > 0)
    {
        close(fd[1]);
        dup2(fd[0], STDIN_FILENO);
        execlp(""wc"", ""wc"", ""-l"", NULL);
        sys_error(""execlp wc error"");
    }
    else if (pid == 0)
    {
        close(fd[0]);
        dup2(fd[1], STDOUT_FILENO);
        execlp(""ls"", ""ls"", NULL);
        sys_error(""execlp ls error"");
    }

    return 0;
}",47,1446,246
"#include ""../base.h""
          

int main(int argc, char *argv[])
{
    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in serv_addr;
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(9999);
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    Bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
    
    Listen(serv_sock, 128);

    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_len = sizeof(clnt_addr);
    int clnt_sock = Accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_len);

    char clnt_IP[1024];
    printf(""client ip:%s, port:%d\n"", inet_ntop(AF_INET, &clnt_addr.sin_addr.s_addr, clnt_IP, sizeof(clnt_IP)), ntohs(clnt_addr.sin_port));

    char buf[BUFSIZ];
    while(1)
    {
        int ret = Read(clnt_sock, buf, sizeof(buf));
        if(ret == 0)
        {
            break;
        }
        Write(STDOUT_FILENO, buf, ret);

        for(int i = 0; i < ret; i++)
        {
            buf[i] = toupper(buf[i]);
        }
        Write(clnt_sock, buf, ret);
    }

    Close(serv_sock);
    Close(clnt_sock);
    return 0;
}",47,1447,460
"#define _POSIX_SOURCE





void sys_err(const char* str)
{
    perror(str);
    exit(1);
}

void sig_catch(int signo)           
{
    if(signo == SIGINT)
    {
        printf(""catch SIGINT!!! %d\n"", signo);
        sleep(10);
    }
    else if(signo == SIGBUS)
        printf(""catch SIGBUS!!! %d\n"", signo);
    return;
}

int main()
{
    struct sigaction act, oldact;

    act.sa_handler = sig_catch;         
    sigemptyset(&act.sa_mask);          
    act.sa_flags = 0;                   

    int ret = sigaction(SIGINT, &act, &oldact);     
    if(ret == -1)
        sys_err(""sigaction error"");
    
    ret = sigaction(SIGBUS, &act, &oldact);
    if(ret == -1)
        sys_err(""sigaction error"");

    while(1);
    
    return 0;
}",47,1448,285
"void *fun(void *arg)
{
    srand(time(NULL));

    while (1)
    {
        printf(""hello "");
        sleep(rand()%3);    
        printf(""world\n"");
        sleep(rand()%3);
    }

    return NULL;
}

int main()
{
    srand(time(NULL));
    pthread_t tid;

    pthread_create(&tid, NULL, fun, NULL);
    while (1)
    {
        printf(""HELLO "");
        sleep(rand()%3);
        printf(""WORLD\n"");
        sleep(rand()%3);
    }
    pthread_join(tid, NULL);
    return 0;
}",47,1449,179
"int main(int argc, char *argv[])
{
    pid_t pid = fork();
    if(pid == -1)
    {
        perror(""fork error"");
        exit(1);
    }
    else if(pid == 0)
    {
        printf(""I'm child, my parent pid = %d, going to sleep 10s\n"", getppid());
        sleep(10);
        printf(""--------child die---------\n"");
    }
    else if(pid > 0)
    {
        while(1)
        {
            printf(""I'm parent, pid = %d, myson = %d\n"", getpid(), pid);
            sleep(1);
        }
    }

    return 0;
}",47,1450,186
"int main(int argc, char *argv[])
{
    printf(""before fork-1-\n"");
    printf(""before fork-2-\n"");
    printf(""before fork-3-\n"");
    printf(""before fork-4-\n"");

    pid_t pid = fork();
    if(pid == -1)
    {
        perror(""fork error"");
        exit(1);
    }
    else if(pid == 0)
    {
        printf(""child is created\n"");
    }
    else if(pid > 0)
    {
        printf(""parent process:child is %d\n"", pid);
    }

    printf(""end of file\n"");
    return 0;
}",47,1451,174
"#define N 1

int main(int argc, char *argv[])
{
    int fd1 = open(argv[1], O_RDONLY);
    if(fd1 < 0)
    {
        perror(""file1 open error"");
        exit(1);
    }

    int fd2 = open(argv[2], O_WRONLY|O_CREAT|O_TRUNC, 0644);
    if(fd2 < 0)
    {
        perror(""file2 open error"");
        exit(1);
    }

    char buf[N];
    int n;
    while((n = read(fd1, buf, N)) != 0)
    {
        if(n < 0)
        {
            perror(""read error"");
            break;
        }
        write(fd2, buf, N);
    }

    close(fd1);
    close(fd2);
    return 0;
}




",47,1452,245
"#define _XOPEN_SOURCE 500     





int counter;
pthread_rwlock_t rwlock;


void *thread_write(void *arg)
{
    int t;
    int i = (int)arg;
    while(1)
    {
        pthread_rwlock_wrlock(&rwlock);     
        t = counter;
        usleep(1000);       
        printf(""write %d:%lu: counter=%d ++counter=%d\n"", i, pthread_self(), t, ++counter);
        pthread_rwlock_unlock(&rwlock);
        usleep(10000);
    }
    return NULL;
}

void *thread_read(void *arg)
{
    int i = (int)arg;
    while(1)
    {
        pthread_rwlock_wrlock(&rwlock);     
        printf(""read %d:%lu: counter=%d\n"", i, pthread_self(), counter);
        pthread_rwlock_unlock(&rwlock);
        usleep(2000);
    }
    return NULL;
}

int main()
{
    pthread_t tid[8];
    pthread_rwlock_init(&rwlock, NULL);

    int i;
    for(i = 0; i < 3; i++)
        pthread_create(&tid[i], NULL, thread_write, (void*)i);
    
    for(i = 0; i < 5; i++)
        pthread_create(&tid[i+3], NULL, thread_read, (void*)i);
    
    for(i = 0; i < 8; i++)
        pthread_join(tid[i], NULL);

    pthread_rwlock_destroy(&rwlock);

    return 0;
}

",47,1453,454
"void sys_err(const char *str)
{
    perror(str);
    exit(1);
}

struct student
{
    int id;
    char name[256];
    int age;
};

int main()
{
    struct student stu;
    int fd = open(""temp"", O_RDONLY);
    if(fd == -1)
        sys_err(""open error"");

    struct student *p = mmap(NULL, sizeof(stu), PROT_READ, MAP_SHARED, fd, 0);
    if(p == MAP_FAILED)
        sys_err(""mmap error"");

    close(fd);
    
    while(1)
    {
        printf(""id = %d, name = %s, age = %d\n"", p->id, p->name, p->age);
        sleep(1);
    }

    munmap(p, sizeof(stu));

    return 0;
}",47,1454,244
"int main(int argc, char *argv[])
{
    pid_t pid = fork();
    if(pid == -1)
    {
        perror(""fork error"");
        exit(1);
    }
    else if(pid == 0)
    {
        while(1)
        {
            printf(""I'm child, my parent pid = %d\n"", getppid());
            sleep(1);
        }
    }
    else if(pid > 0)
    {
        printf(""I'm parent, my pid = %d\n"", getpid());
        sleep(9);
        printf(""--------parent process going to die---------\n"");
    }

    return 0;
}",47,1455,173
"#include ""BinHexConverter.h""




static inline char convertBinValueToHexDigit(uint8_t value, bool upperCase);

static inline char convertBinValueToHexDigit(uint8_t value, bool upperCase)
{
  char hexA = (upperCase) ? ('A') : ('a');
  return ((char)((value < 10) ? ('0' + value) : (hexA + value - 10)));
}

uint8_t convertHexDigitToBinValue(char inputChr)
{
  if (inputChr >= '0' && inputChr <= '9') 
  {
    return ((uint8_t)(inputChr - '0'));
  }
  else if (inputChr >= 'a' && inputChr <= 'f') {
    return 10 + ((uint8_t)(inputChr - 'a'));
  }
  else if (inputChr >= 'A' && inputChr <= 'F') {
    return 10 + ((uint8_t)(inputChr - 'A'));
  }
  return 0;
}

size_t convertBinValueToHexString8(uint8_t inputValue, char *outputStr, size_t outputStrSize, bool upperCase)
{
  if (outputStrSize < 2) 
  {
    return 0;
  }
  outputStr[0] = convertBinValueToHexDigit(((inputValue & 0xF0u) >> 4), upperCase);
  outputStr[1] = convertBinValueToHexDigit((inputValue & 0x0Fu), upperCase);
  return 2;
}

uint8_t convertHexString8ToBinValue(char *inputStr, size_t inputStrLength)
{
  if (inputStrLength != 2) 
  {
    return 0;
  }
  uint8_t outputValue = convertHexDigitToBinValue(inputStr[0]) << 4;
  outputValue |= convertHexDigitToBinValue(inputStr[1]);
  return outputValue;
}

size_t convertBinDataToHexString8(uint8_t *inputData, size_t inputDataSize, char *outputStr, size_t outputStrSize, bool upperCase)
{
  if (outputStrSize < inputDataSize * 2) 
  {
    return 0;
  }
  outputStr[0] = '\0';
  size_t count = 0;
  for ( size_t i = 0 ; i < inputDataSize; i++ )
  {
    count += convertBinValueToHexString8(inputData[i], outputStr + 2 * i, outputStrSize - count, upperCase);
  }
  if (outputStrSize > count) 
  {
    outputStr[count++] = '\0';
  }
  return count;
}

size_t convertHexString8ToBinData(char *inputStr, size_t inputStrLength, uint8_t *pOutputData, size_t outputDataSize)
{
  if (outputDataSize < inputStrLength >> 1) 
  {
    return 0;
  }
  if ((inputStrLength & 0x01u) != 0) 
  {
    return 0;
  }
  memset(pOutputData, 0x00u, outputDataSize);
  for ( size_t i = 0 ; i < inputStrLength; i = i + 2 )
  {
    pOutputData[i >> 1] = convertHexString8ToBinValue(inputStr + i, 2);
  }
  return inputStrLength >> 1;
}
",48,1456,913
"#include ""SPIFlashHelper.h""
#include ""user_config.h""
#include ""DemoFOTAUpdateWorkflowPersistence.h""


void ICACHE_FLASH_ATTR saveState(int16_t state)
{
  uint16_t sector = getFlashSector(DEMO_FOTA_UPDATE_STATE_FLASH_SECTOR_ADDRESS);
  if (spi_flash_erase_sector(sector) != SPI_FLASH_RESULT_OK) 
  {
    os_printf(""Failed to erase NVS sector %d\n"", DEMO_FOTA_UPDATE_STATE_FLASH_SECTOR_ADDRESS);
  }
  if (spi_flash_write(DEMO_FOTA_UPDATE_STATE_FLASH_SECTOR_ADDRESS, ((uint32_t *)(&state)), ((uint32_t)(sizeof(state)))) != SPI_FLASH_RESULT_OK) 
  {
    os_printf(""Failed write statemachine state to NVS sector %d\n"", DEMO_FOTA_UPDATE_STATE_FLASH_SECTOR_ADDRESS);
  }
}

int16_t ICACHE_FLASH_ATTR loadState(void)
{
  int16_t state = 0;
  if (spi_flash_read(DEMO_FOTA_UPDATE_STATE_FLASH_SECTOR_ADDRESS, ((uint32_t *)(&state)), ((uint32_t)(sizeof(state)))) != SPI_FLASH_RESULT_OK) 
  {
    return 0;
  }
  
  if (state == -1) 
  {
    return 0;
  }
  return state;
}
",48,1457,435
"#include ""UARTDrv.h""

#include ""MultiPartitionDemoFirmwareUpdateInfoSerialReader.h""



static void ICACHE_FLASH_ATTR uart_recvTask(os_event_t *pEvent);

static uint8_t uartUnit;

void ICACHE_FLASH_ATTR one_uart_init(uint8_t unit, UartBautRate baudrate)
{
  uartUnit = unit;
  system_os_task(&uart_recvTask, uart_recvTaskPrio, uart_recvTaskQueue, uart_recvTaskQueueLen);
  
  UartDev.baut_rate = baudrate;
  uart_config(unit);
  
  ETS_UART_INTR_ENABLE();
}

static void ICACHE_FLASH_ATTR uart_recvTask(os_event_t *pEvent)
{
  if (pEvent->sig == uart_recvTaskSignal) 
  {
    
    uint32_t uartStatus = READ_PERI_REG(UART_STATUS(uartUnit));
    uint8_t rxFIFOLength = UART_RXFIFO_DATA_LEN(uartStatus);
    
    
    for ( int16_t __i = 0 ; __i < rxFIFOLength; __i++ )
    {
      uint32_t uartFifo = READ_PERI_REG(UART_FIFO(uartUnit));
      uint8_t rxChar = UART_RXFIFO_DATA(uartFifo);
      firmwareUpdateInfoReader_onCharacterReceived(rxChar);
    }
    
    
    WRITE_PERI_REG(UART_INT_CLR(uartUnit),UART_RXFIFO_FULL_INT_CLR | UART_RXFIFO_TOUT_INT_CLR);
    
    
    uart_rx_intr_enable(uartUnit);
  }
}
",48,1458,508
"#include ""SinglePartitionDemoFirmwareUpdateInfoFileReader.h""

#include ""BinHexConverter.h""
#include ""DemoProductInfo.h""
#include ""FotaHub.h""



#include ""ctype.h""



static bool isWhitespace(char *str);

static bool createFirmwareUpdateInfoFile(void);

static void openFirmwareUpdateInfoFileInVSCode(void);

static bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize);

static bool parseFirmwareUpdateInfo(char *updateInfoString);

static char lastUpdateInfoString[260 + 1] = { 0 };

static char updateVersion[MAX_UPDATE_VERSION_LENGTH + 1] = { 0 };

static uint8_t *updateVerificationData = NULL;

static bool isWhitespace(char *str)
{
  size_t idx = 0;
  char currentChr = str[idx++];
  while (currentChr != '\0')
  {
    if (isspace(currentChr) == 0) 
    {
      return false;
    }
    currentChr = str[idx++];
  }
  return true;
}

void firmwareUpdateInfoReader_init(void)
{
  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);
  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));
  memset(updateVerificationData, 0, updateVerificationDataSize);
  
  if (!createFirmwareUpdateInfoFile()) 
  {
    return;
  }
  
  openFirmwareUpdateInfoFileInVSCode();
}

void firmwareUpdateInfoReader_run(void)
{
  
  char updateInfoString[260 + 1] = """";
  if (!loadFirmwareUpdateInfoFile(updateInfoString, sizeof(updateInfoString))) 
  {
    memset(lastUpdateInfoString, 0, sizeof(lastUpdateInfoString));
    return;
  }
  
  
  if (strncmp(updateInfoString, lastUpdateInfoString, 260) == 0) 
  {
    return;
  }
  strncpy(lastUpdateInfoString, updateInfoString, 260);
  
  
  if (!parseFirmwareUpdateInfo(updateInfoString)) 
  {
    return;
  }
  
  
  printf(""Firmware update request towards version %s received\n"", updateVersion);
  fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);
}

static bool createFirmwareUpdateInfoFile(void)
{
  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, ""w"");
  if (updateInfoFile == NULL) 
  {
    printf(""Failed to create %s: %s (error code: %i)\n"", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, strerror(errno), errno);
    return false;
  }
  fclose(updateInfoFile);
  return true;
}

static void openFirmwareUpdateInfoFileInVSCode(void)
{
  char vsCodePath[260 + 1] = """";
  char *os = getenv(""OS"");
  if (os != NULL && strcmp(os, ""Windows_NT"") == 0) 
  {
    snprintf(vsCodePath, sizeof(vsCodePath), ""C:\\Users\\%s\\AppData\\Local\\Programs\\Microsoft VS Code\\bin\\code"", getenv(""USERNAME""));
  }
  else
  {
    snprintf(vsCodePath, sizeof(vsCodePath), ""/usr/bin/code"");
  }
  
  if (access(vsCodePath, F_OK) != -1) 
  {
    char openCommand[260 + 1] = """";
    snprintf(openCommand, sizeof(openCommand), ""code %s"", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);
    system(openCommand);
  }
}

static bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize)
{
  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, ""r"");
  if (updateInfoFile == NULL) 
  {
    
    return false;
  }
  memset(updateInfoString, 0, updateInfoStringSize);
  while (isWhitespace(updateInfoString))
  {
    if (fgets(updateInfoString, ((int32_t) updateInfoStringSize), updateInfoFile) == NULL) 
    {
      
      fclose(updateInfoFile);
      return false;
    }
  }
  fclose(updateInfoFile);
  return true;
}

static bool parseFirmwareUpdateInfo(char *updateInfoString)
{
  
  memset(updateVersion, 0, sizeof(updateVersion));
  memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
  if (strstr(updateInfoString, UPDATE_INFO_SEPARATOR) == NULL) 
  {
    printf(""Firmware update request with missing version and/or verification data entered\n"");
    return false;
  }
  
  
  char *parsedVersion = strtok(updateInfoString, UPDATE_INFO_DELIMITERS);
  if (parsedVersion == NULL) 
  {
    printf(""Firmware update request with missing version and verification data entered\n"");
    return false;
  }
  if (strlen(parsedVersion) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) 
  {
    printf(""Received firmware update version too long (max. length = %hhu)\n"", MAX_UPDATE_VERSION_LENGTH);
    return false;
  }
  strncpy(updateVersion, parsedVersion, sizeof(updateVersion));
  
  
  char *parsedVerificationData = strtok(NULL, UPDATE_INFO_DELIMITERS);
  if (parsedVerificationData == NULL) 
  {
    printf(""Firmware update request with missing version or verification data entered\n"");
    memset(updateVersion, 0, sizeof(updateVersion));
    return false;
  }
  if (strlen(parsedVerificationData) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) 
  {
    printf(""Received firmware update verification data too long (max. length = %hhu)\n"", MAX_UPDATE_VERSION_LENGTH << 1);
    memset(updateVersion, 0, sizeof(updateVersion));
    return false;
  }
  if (convertHexString8ToBinData(parsedVerificationData, strlen(parsedVerificationData), updateVerificationData, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) == 0) 
  {
    printf(""Firmware update request with invalid verification data entered\n"");
    memset(updateVersion, 0, sizeof(updateVersion));
    memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
    return false;
  }
  
  return true;
}

void fotahub_onProvideFirmwareUpdateVerificationInfo(FirmwareUpdateInfo_t const *pUpdateInfo, FOTAUpdateVerificationAlgorithm_t *pVerificationAlgorithm, uint8_t const  **ppVerificationData)
{
  *pVerificationAlgorithm = DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM;
  *ppVerificationData = updateVerificationData;
}
",48,1459,2006
"#include ""MultiPartitionDemoFirmwareUpdateInfoSerialReader.h""

#include ""DemoFOTAUpdateWorkflow.h""
#include ""BinHexConverter.h""
#include ""FotaHub.h""
#include ""DemoProductInfo.h""
#include ""ctype.h""



enum FirmwareUpdateInfoParser__inevents {
  FirmwareUpdateInfoParser_characterReceived__event,
  FirmwareUpdateInfoParser_updateInfoPickedUp__event
};
typedef enum FirmwareUpdateInfoParser__inevents FirmwareUpdateInfoParser__inevents_t;

enum FirmwareUpdateInfoParser__states {
  FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state = 0,
  FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state,
  FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state,
  FirmwareUpdateInfoParser_yielding__state
};
typedef enum FirmwareUpdateInfoParser__states FirmwareUpdateInfoParser__states_t;

struct FirmwareUpdateInfoParser__data {
  FirmwareUpdateInfoParser__states_t __currentState;
  size_t characterIdx;
  size_t partitionIdx;
  uint8_t *pCurrentVerificationData;
};
typedef struct FirmwareUpdateInfoParser__data FirmwareUpdateInfoParser__data_t;

static void ICACHE_FLASH_ATTR FirmwareUpdateInfoParser__init(FirmwareUpdateInfoParser__data_t *instance);

static bool ICACHE_FLASH_ATTR FirmwareUpdateInfoParser__execute(FirmwareUpdateInfoParser__data_t *instance, FirmwareUpdateInfoParser__inevents_t event, void **arguments);

static char updateVersion[MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH + 1] = { 0 };

static uint8_t *updateVerificationData[UPDATE_PARTITION_COUNT] = { NULL, NULL };

static FirmwareUpdateInfoParser__data_t updateInfoParser;

void ICACHE_FLASH_ATTR firmwareUpdateInfoReader_init(void)
{
  FirmwareUpdateInfoParser__init(&updateInfoParser);
  
  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);
  updateVerificationData[0] = ((uint8_t *)(os_malloc(updateVerificationDataSize)));
  updateVerificationData[1] = ((uint8_t *)(os_malloc(updateVerificationDataSize)));
  os_memset(updateVerificationData[0], 0, updateVerificationDataSize);
  os_memset(updateVerificationData[1], 0, updateVerificationDataSize);
}

void ICACHE_FLASH_ATTR firmwareUpdateInfoReader_run(void)
{
  if ((updateInfoParser.__currentState == FirmwareUpdateInfoParser_yielding__state)) 
  {
    os_printf(""Firmware update request towards version %s received\n"", updateVersion);
    fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);
    FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_updateInfoPickedUp__event, NULL);
  }
}

void ICACHE_FLASH_ATTR firmwareUpdateInfoReader_onCharacterReceived(uint8_t character)
{
  uint8_t ___FirmwareUpdateInfoParser_characterReceived_character__arg = character;
  void *___FirmwareUpdateInfoParser_characterReceived__args[1] = { &___FirmwareUpdateInfoParser_characterReceived_character__arg };
  FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_characterReceived__event, ___FirmwareUpdateInfoParser_characterReceived__args);
}

static void ICACHE_FLASH_ATTR FirmwareUpdateInfoParser__init(FirmwareUpdateInfoParser__data_t *instance)
{
  instance->characterIdx = 0;
  instance->partitionIdx = 0;
  instance->pCurrentVerificationData = updateVerificationData[0];
  instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;
}

static bool ICACHE_FLASH_ATTR FirmwareUpdateInfoParser__execute(FirmwareUpdateInfoParser__data_t *instance, FirmwareUpdateInfoParser__inevents_t event, void **arguments)
{
  switch (instance->__currentState)
  {
    case FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state:
    {
      switch (event)
      {
        case FirmwareUpdateInfoParser_characterReceived__event:
        {
          if ((*((uint8_t *)((arguments[0])))) != COLON && isspace((*((uint8_t *)((arguments[0]))))) == 0 && instance->characterIdx < MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH - 1) 
          {
            
            
            updateVersion[instance->characterIdx++] = ((char)((*((uint8_t *)((arguments[0]))))));
            
            
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == COLON && instance->characterIdx > 0) 
          {
            
            
            updateVersion[instance->characterIdx] = '\0';
            instance->characterIdx = 0;
            instance->pCurrentVerificationData = updateVerificationData[instance->partitionIdx];
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) != COLON && isspace((*((uint8_t *)((arguments[0]))))) == 0 && instance->characterIdx >= MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH - 1) 
          {
            
            os_printf(""Received firmware update version too long (max. length = %d)\n"", MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH);
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == COLON && instance->characterIdx == 0) 
          {
            
            os_printf(""Firmware update request with missing version received\n"");
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx == 0) 
          {
            
            os_printf(""Empty firmware update request received\n"");
            instance->characterIdx = 0;
            instance->partitionIdx = 0;
            
            
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0) 
          {
            
            os_printf(""Firmware update request with missing verification data received\n"");
            memset(updateVersion, 0, sizeof(updateVersion));
            instance->characterIdx = 0;
            instance->partitionIdx = 0;
            
            
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state:
    {
      switch (event)
      {
        case FirmwareUpdateInfoParser_characterReceived__event:
        {
          if ((*((uint8_t *)((arguments[0])))) != LF) 
          {
            
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF) 
          {
            
            memset(updateVersion, 0, sizeof(updateVersion));
            os_memset(updateVerificationData[0], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
            os_memset(updateVerificationData[1], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
            instance->characterIdx = 0;
            instance->partitionIdx = 0;
            
            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state) 
            {
              
              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;
            }
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state:
    {
      switch (event)
      {
        case FirmwareUpdateInfoParser_characterReceived__event:
        {
          if (isxdigit((*((uint8_t *)((arguments[0]))))) != 0 && instance->characterIdx < getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) 
          {
            
            
            if (((instance->characterIdx & (1)) == 0)) 
            {
              
              instance->pCurrentVerificationData[instance->characterIdx >> 1] = convertHexDigitToBinValue(((char)((*((uint8_t *)((arguments[0]))))))) << 4;
            }
            else
            {
              
              (instance->pCurrentVerificationData[instance->characterIdx >> 1] |= (convertHexDigitToBinValue(((char)((*((uint8_t *)((arguments[0])))))))));
            }
            instance->characterIdx++;
            
            
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == COMMA && instance->characterIdx > 0 && instance->partitionIdx < UPDATE_PARTITION_COUNT - 1) 
          {
            
            instance->characterIdx = 0;
            instance->partitionIdx++;
            instance->pCurrentVerificationData = updateVerificationData[instance->partitionIdx];
            
            
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0 && instance->partitionIdx == UPDATE_PARTITION_COUNT - 1) 
          {
            
            instance->__currentState = FirmwareUpdateInfoParser_yielding__state;
            break;
          }
          if (isxdigit((*((uint8_t *)((arguments[0]))))) != 0 && instance->characterIdx >= getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) 
          {
            
            os_printf(""Received firmware update verification data #%d too long (max. length = %d)\n"", instance->partitionIdx + 1, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1);
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == COMMA && instance->characterIdx == 0) 
          {
            
            os_printf(""Firmware update request with missing verification data #%d received\n"", instance->partitionIdx + 1);
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == COMMA && instance->characterIdx > 0 && instance->partitionIdx >= UPDATE_PARTITION_COUNT - 1) 
          {
            
            os_printf(""Firmware update request with too many verifications data received (max. # = %d)\n"", UPDATE_PARTITION_COUNT);
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx == 0) 
          {
            
            os_printf(""Firmware update request with missing verification data #%d received\n"", instance->partitionIdx + 1);
            memset(updateVersion, 0, sizeof(updateVersion));
            os_memset(updateVerificationData[0], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
            os_memset(updateVerificationData[1], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
            instance->characterIdx = 0;
            instance->partitionIdx = 0;
            
            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state) 
            {
              
              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;
            }
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0 && instance->partitionIdx < UPDATE_PARTITION_COUNT - 1) 
          {
            
            os_printf(""Firmware update request with missing verification data #%d received\n"", instance->partitionIdx + 2);
            memset(updateVersion, 0, sizeof(updateVersion));
            os_memset(updateVerificationData[0], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
            os_memset(updateVerificationData[1], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
            instance->characterIdx = 0;
            instance->partitionIdx = 0;
            
            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state) 
            {
              
              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;
            }
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case FirmwareUpdateInfoParser_yielding__state:
    {
      switch (event)
      {
        case FirmwareUpdateInfoParser_updateInfoPickedUp__event:
        {
          
          instance->characterIdx = 0;
          instance->partitionIdx = 0;
          
          
          instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    default: {
      break;
    }
  }
  return true;
}

void ICACHE_FLASH_ATTR fotahub_onProvideFirmwareUpdateVerificationInfo(FirmwareUpdateInfo_t const *pUpdateInfo, FOTAUpdateVerificationAlgorithm_t *pVerificationAlgorithm, uint8_t const  **ppVerificationData)
{
  *pVerificationAlgorithm = DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM;
  if (pUpdateInfo->partitionIdx >= 0 && pUpdateInfo->partitionIdx < UPDATE_PARTITION_COUNT) 
  {
    *ppVerificationData = updateVerificationData[((size_t)(pUpdateInfo->partitionIdx))];
  }
  else
  {
    *ppVerificationData = NULL;
  }
}
",48,1460,4032
"#include ""SinglePartitionDemoFirmwareUpdateInfoFileReader.h""

#include ""BinHexConverter.h""
#include ""DemoProductInfo.h""
#include ""FotaHub.h""



#include ""ctype.h""


static bool isWhitespace(char *str);

static char *separator(void);

static bool createFirmwareUpdateInfoFile(void);

static bool canOpenFirmwareUpdateInfoFile(void);

static void openFirmwareUpdateInfoFile(void);

static bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize);

static bool parseFirmwareUpdateInfo(char *updateInfoString);

static char lastUpdateInfoString[260 + 1] = { 0 };

static char updateVersion[MAX_UPDATE_VERSION_LENGTH + 1] = { 0 };

static uint8_t *updateVerificationData = NULL;

static bool isWhitespace(char *str)
{
  size_t idx = 0;
  char currentChr = str[idx++];
  while (currentChr != '\0')
  {
    if (isspace(currentChr) == 0) 
    {
      return false;
    }
    currentChr = str[idx++];
  }
  return true;
}

static char *separator(void)
{
  char *os = getenv(""OS"");
  if (os != NULL && strcmp(os, ""Windows_NT"") == 0) 
  {
    return ""\\"";
  }
  else
  {
    return ""/"";
  }
}

void firmwareUpdateInfoReader_init(void)
{
  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);
  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));
  memset(updateVerificationData, 0, updateVerificationDataSize);
  
  
  if (!createFirmwareUpdateInfoFile()) 
  {
    return;
  }
  
  if (canOpenFirmwareUpdateInfoFile()) 
  {
    openFirmwareUpdateInfoFile();
  }
}

void firmwareUpdateInfoReader_explain(char *programDir)
{
  
  char *sep = (strlen(programDir) > 0) ? (separator()) : ("""");
  printf(""Waiting for firmware update info to be entered and saved in '%s%s%s' file\n(if this file has not been opened automatically already, just open it manually in an editor of your choice)\n"", programDir, sep, DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);
  printf(""Expected firmware update info format: <new-version>:<checksum-or-signature> (e.g., 1.1:8639e6e80b089338e51fac17d5faa647c4c05368e46af5c42583fb34c0) \n"");
}

void firmwareUpdateInfoReader_run(void)
{
  
  char updateInfoString[260 + 1] = """";
  if (!loadFirmwareUpdateInfoFile(updateInfoString, sizeof(updateInfoString))) 
  {
    memset(lastUpdateInfoString, 0, sizeof(lastUpdateInfoString));
    return;
  }
  
  
  if (strncmp(updateInfoString, lastUpdateInfoString, 260) == 0) 
  {
    return;
  }
  strncpy(lastUpdateInfoString, updateInfoString, 260);
  
  
  if (!parseFirmwareUpdateInfo(updateInfoString)) 
  {
    return;
  }
  
  
  printf(""Firmware update request towards version %s received\n"", updateVersion);
  fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);
}

static bool createFirmwareUpdateInfoFile(void)
{
  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, ""wb"");
  if (updateInfoFile == NULL) 
  {
    printf(""Failed to create %s: %s (error code: %i)\n"", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, strerror(errno), errno);
    return false;
  }
  fclose(updateInfoFile);
  return true;
}

static bool canOpenFirmwareUpdateInfoFile(void)
{
  
  char *os = getenv(""OS"");
  char command[260 + 1] = """";
  if (os != NULL && strcmp(os, ""Windows_NT"") == 0) 
  {
    snprintf(command, sizeof(command), ""powershell -command \""where.exe code | Measure-Object -Line | Select-Object -ExpandProperty Lines\"""");
  }
  else
  {
    snprintf(command, sizeof(command), ""which code | wc -l"");
  }
  
  
  FILE *commandPipe = popen(command, ""r"");
  if (commandPipe == NULL) 
  {
    printf(""Failed to run '%s' command: %s (error code: %i)\n"", command, strerror(errno), errno);
    return false;
  }
  
  
  int32_t count = 0;
  if (fscanf(commandPipe, ""%d"", &count) != 1) 
  {
    pclose(commandPipe);
    return false;
  }
  pclose(commandPipe);
  return count > 0;
}

static void openFirmwareUpdateInfoFile(void)
{
  
  char command[260 + 1] = """";
  snprintf(command, sizeof(command), ""code %s"", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);
  system(command);
}

static bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize)
{
  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, ""r"");
  if (updateInfoFile == NULL) 
  {
    
    return false;
  }
  memset(updateInfoString, 0, updateInfoStringSize);
  while (isWhitespace(updateInfoString))
  {
    if (fgets(updateInfoString, ((int32_t) updateInfoStringSize), updateInfoFile) == NULL) 
    {
      
      fclose(updateInfoFile);
      return false;
    }
  }
  fclose(updateInfoFile);
  return true;
}

static bool parseFirmwareUpdateInfo(char *updateInfoString)
{
  
  memset(updateVersion, 0, sizeof(updateVersion));
  memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
  if (strstr(updateInfoString, UPDATE_INFO_SEPARATOR) == NULL) 
  {
    printf(""Firmware update request with missing version and/or verification data entered\n"");
    return false;
  }
  
  
  char *parsedVersion = strtok(updateInfoString, UPDATE_INFO_DELIMITERS);
  if (parsedVersion == NULL) 
  {
    printf(""Firmware update request with missing version and verification data entered\n"");
    return false;
  }
  if (strlen(parsedVersion) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) 
  {
    printf(""Received firmware update version too long (max. length = %hhu)\n"", MAX_UPDATE_VERSION_LENGTH);
    return false;
  }
  strncpy(updateVersion, parsedVersion, sizeof(updateVersion));
  
  
  char *parsedVerificationData = strtok(NULL, UPDATE_INFO_DELIMITERS);
  if (parsedVerificationData == NULL) 
  {
    printf(""Firmware update request with missing version or verification data entered\n"");
    memset(updateVersion, 0, sizeof(updateVersion));
    return false;
  }
  if (strlen(parsedVerificationData) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) 
  {
    printf(""Received firmware update verification data too long (max. length = %hhu)\n"", MAX_UPDATE_VERSION_LENGTH << 1);
    memset(updateVersion, 0, sizeof(updateVersion));
    return false;
  }
  if (convertHexString8ToBinData(parsedVerificationData, strlen(parsedVerificationData), updateVerificationData, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) == 0) 
  {
    printf(""Firmware update request with invalid verification data entered\n"");
    memset(updateVersion, 0, sizeof(updateVersion));
    memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
    return false;
  }
  
  return true;
}

void fotahub_onProvideFirmwareUpdateVerificationInfo(FirmwareUpdateInfo_t const *pUpdateInfo, FOTAUpdateVerificationAlgorithm_t *pVerificationAlgorithm, uint8_t const  **ppVerificationData)
{
  *pVerificationAlgorithm = DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM;
  *ppVerificationData = updateVerificationData;
}
",48,1461,2464
"#include ""user_pre_init_default.h""





static void ICACHE_FLASH_ATTR initPartitionTable(enum flash_size_map flashSizeMap);

static void ICACHE_FLASH_ATTR adjustPartitionTableDataForFlashSize_512(void);

static partition_item_t partitionTable[] = 
{
  { SYSTEM_PARTITION_BOOTLOADER, 0x0u, 0x1000u }, 
  { SYSTEM_PARTITION_OTA_1, 0x1000u, SYSTEM_PARTITION_OTA_SIZE }, 
  { SYSTEM_PARTITION_OTA_2, 0x101000u, SYSTEM_PARTITION_OTA_SIZE }, 
  { SYSTEM_PARTITION_RF_CAL, 0x3fb000u, 0x1000u }, 
  { SYSTEM_PARTITION_PHY_DATA, 0x3fc000u, 0x1000u }, 
  { SYSTEM_PARTITION_SYSTEM_PARAMETER, 0x3fd000u, 0x3000u }
};

static void ICACHE_FLASH_ATTR initPartitionTable(enum flash_size_map flashSizeMap)
{
  
  switch (flashSizeMap)
  {
    case FLASH_SIZE_16M_MAP_1024_1024:
    {
      partitionTable[3].addr = 0x1fb000u;
      partitionTable[4].addr = 0x1fc000u;
      partitionTable[5].addr = 0x1fd000u;
      break;
    }
    case FLASH_SIZE_32M_MAP_512_512:
    {
      adjustPartitionTableDataForFlashSize_512();
      break;
    }
    case FLASH_SIZE_16M_MAP_512_512:
    {
      adjustPartitionTableDataForFlashSize_512();
      partitionTable[3].addr = 0x1fb000u;
      partitionTable[4].addr = 0x1fc000u;
      partitionTable[5].addr = 0x1fd000u;
      break;
    }
    case FLASH_SIZE_8M_MAP_512_512:
    {
      adjustPartitionTableDataForFlashSize_512();
      partitionTable[3].addr = 0xfb000u;
      partitionTable[4].addr = 0xfc000u;
      partitionTable[5].addr = 0xfd000u;
      break;
    }
    default: {
      
    }
  }
}

static void ICACHE_FLASH_ATTR adjustPartitionTableDataForFlashSize_512(void)
{
  partitionTable[1].size = 0x7A000u;
  partitionTable[2].addr = 0x81000u;
  partitionTable[2].size = 0x7A000u;
  
}

void ICACHE_FLASH_ATTR user_pre_init(void)
{
  enum flash_size_map flashSizeMap = system_get_flash_size_map();
  if (flashSizeMap < 2) 
  {
    os_printf(""The flash map is not supported\n"");
    while (true)
    {
    }
  }
  
  initPartitionTable(flashSizeMap);
  
  if (!system_partition_table_regist(partitionTable, sizeof(partitionTable) / sizeof(partitionTable[0]), flashSizeMap)) 
  {
    os_printf(""system_partition_table_regist fail\n"");
    while (true)
    {
    }
  }
}

uint32_t user_iram_memory_is_enabled(void)
{
  return 1;
}
",48,1462,1012
"#include ""DemoFOTAUpdateWorkflow.h""

#include ""DemoProductInfo.h""


enum DemoFOTAUpdateWorkflowEngine__inevents {
  DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event,
  DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event,
  DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event
};
typedef enum DemoFOTAUpdateWorkflowEngine__inevents DemoFOTAUpdateWorkflowEngine__inevents_t;

enum DemoFOTAUpdateWorkflowEngine__states {
  DemoFOTAUpdateWorkflowEngine_idle__state = 0,
  DemoFOTAUpdateWorkflowEngine_connected__state,
  DemoFOTAUpdateWorkflowEngine_downloading__state,
  DemoFOTAUpdateWorkflowEngine_restarting__state
};
typedef enum DemoFOTAUpdateWorkflowEngine__states DemoFOTAUpdateWorkflowEngine__states_t;

struct DemoFOTAUpdateWorkflowEngine__data {
  DemoFOTAUpdateWorkflowEngine__states_t __currentState;
  FirmwareUpdateInfo_t updateInfo;
};
typedef struct DemoFOTAUpdateWorkflowEngine__data DemoFOTAUpdateWorkflowEngine__data_t;

static void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance);

static bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments);

static inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);

static inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);

static DemoFOTAUpdateWorkflowEngine__data_t updateWorkflowEngine;

void fotaUpdateWorkflow_init(void)
{
  DemoFOTAUpdateWorkflowEngine__init(&updateWorkflowEngine);
}

void fotahub_onConnectionStatusChanged(ConnectionStatus_t status)
{
  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;
  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);
}

void fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)
{
  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;
  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);
}

void fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)
{
  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;
  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);
}

static void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance)
{
  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;
  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;
  instance->updateInfo.version = NULL;
  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;
  instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;
}

static bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)
{
  switch (instance->__currentState)
  {
    case DemoFOTAUpdateWorkflowEngine_idle__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:
        {
          
          printf(""Cannot handle firmware over-the-air update request (missing network connection)\n"");
          
          
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_connected__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:
        {
          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) != 0) 
          {
            
            bool __transitionResult = true;
            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;
            
            
            instance->updateInfo.version = (*((char **)((arguments[0]))));
            
            
            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) 
            {
              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) 
            {
              
              instance->__currentState = __targetState;
              switch (__targetState)
              {
                case DemoFOTAUpdateWorkflowEngine_connected__state:
                {
                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
                  break;
                }
                default: {
                  break;
                }
              }
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
            break;
          }
          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) == 0) 
          {
            
            printf(""Ignoring firmware over-the-air update request to version %s as this version is already running\n"", (*((char **)((arguments[0])))));
            
            
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_downloading__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:
        {
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) 
          {
            
            bool __transitionResult = true;
            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;
            
            
            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) 
            {
              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) 
            {
              
              instance->__currentState = __targetState;
              switch (__targetState)
              {
                case DemoFOTAUpdateWorkflowEngine_restarting__state:
                {
                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);
                  break;
                }
                case DemoFOTAUpdateWorkflowEngine_connected__state:
                {
                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
                  break;
                }
                default: {
                  break;
                }
              }
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
            break;
          }
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;
            break;
          }
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_restarting__state:
    {
      switch (event)
      {
        default: {
          break;
        }
      }
      break;
    }
    default: {
      break;
    }
  }
  return true;
}

static inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)
{
  printf(""Ready for firmware over-the-air update\n"");
}

static inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)
{
  printf(""Waiting for restart\n"");
}
",48,1463,2759
"#include ""UARTDefinitions.h""

uart_config_t const UART_BASIC_CONFIG_DEFAULT_FOR_115200_Bd = 
{
  .baud_rate = UART_BAUDRATE_115200, 
  .data_bits = UART_DATA_8_BITS, 
  .parity = UART_PARITY_DISABLE, 
  .stop_bits = UART_STOP_BITS_1, 
  .flow_ctrl = UART_HW_FLOWCTRL_DISABLE, 
  .rx_flow_ctrl_thresh = 122
};

UARTPinConfig_t const UART0_PIN_CONFIG_DEFAULT = 
{
  .tx = GPIO_NUM_1, 
  .rx = GPIO_NUM_3, 
  .rts = GPIO_NUM_22, 
  .cts = GPIO_NUM_19
};


UARTPinConfig_t const UART1_PIN_CONFIG_DEFAULT = 
{
  .tx = GPIO_NUM_4, 
  .rx = GPIO_NUM_5, 
  .rts = GPIO_NUM_21, 
  .cts = GPIO_NUM_18
};


UARTPinConfig_t const UART2_PIN_CONFIG_DEFAULT = 
{
  .tx = GPIO_NUM_17, 
  .rx = GPIO_NUM_16, 
  .rts = GPIO_NUM_26, 
  .cts = GPIO_NUM_23
};
",48,1464,420
"#include ""DemoFOTAUpdateWorkflowFilePersistence.h""

#include ""DemoFOTAUpdateWorkflowPersistence.h""

void saveState(int16_t state)
{
  FILE *file = fopen(DEMO_PRODUCT_UPDATE_STATE_FILE_NAME, ""wb"");
  if (file == NULL) 
  {
    printf(""Failed to open %s for writing\n"", DEMO_PRODUCT_UPDATE_STATE_FILE_NAME);
    return;
  }
  if (fwrite(&state, sizeof(state), 1, file) != 1) 
  {
    printf(""Failed to write statemachine state %hi to %s\n"", state, DEMO_PRODUCT_UPDATE_STATE_FILE_NAME);
    fclose(file);
    return;
  }
  fclose(file);
}

int16_t loadState(void)
{
  FILE *file = fopen(DEMO_PRODUCT_UPDATE_STATE_FILE_NAME, ""rb"");
  if (file == NULL) 
  {
    return 0;
  }
  int16_t state = 0;
  if (fread(&state, sizeof(state), 1, file) != 1) 
  {
    fclose(file);
    return 0;
  }
  fclose(file);
  return state;
}
",48,1465,340
"#include ""DemoFOTAUpdateSelfTest.h""

#include ""FotaHub.h""



static bool runRandomSelfTest(uint8_t successRate);

void fotaUpdateSelfTest_init(void)
{
  srand(((uint32_t)(time(NULL))));
}

static bool runRandomSelfTest(uint8_t successRate)
{
  if (((uint8_t)((rand() % 100))) >= (successRate)) 
  {
    printf(""Firmware self test failed (reason: simulated pseudo-random failure)\n"");
    return false;
  }
  return true;
}

void validateFirmwareUpdateActivation(void)
{
  printf(""Validating firmware update\n"");
  
  if (runRandomSelfTest(SIMULATED_ACTIVATION_SUCCESS_RATE)) 
  {
    printf(""Firmware update successfully activated\n"");
    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED);
  }
  else
  {
    printf(""Firmware update activation failed\n"");
    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_ACTIVATION_FAILED);
  }
}

void validateFirmwareUpdateReversion(void)
{
  printf(""Validating previous firmware\n"");
  
  if (runRandomSelfTest(SIMULATED_REVERSION_SUCCESS_RATE)) 
  {
    printf(""Firmware update successfully reverted\n"");
    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_REVERSION_SUCCEEDED);
  }
  else
  {
    printf(""Firmware update reversion failed\n"");
    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_REVERSION_FAILED);
  }
}
",48,1466,480
"#include ""BlinkDrv.h""




static uint16_t currentTick;

static uint16_t expirationTick;

void ICACHE_FLASH_ATTR blink_init(uint16_t runPeriod, uint16_t blinkPeriod)
{
  PIN_FUNC_SELECT(BLINK_PIN_NAME,BLINK_FUNC_GPIO);
  
  currentTick = 0;
  expirationTick = (blinkPeriod >> 1) / runPeriod;
}

void ICACHE_FLASH_ATTR blink_run(void)
{
  if (currentTick == expirationTick) 
  {
    uint32_t state = GPIO_INPUT_GET(BLINK_PIN);
    (state ^= (0x01u));
    GPIO_OUTPUT_SET(BLINK_PIN,state);
    
    currentTick = 0;
  }
  else
  {
    currentTick++;
  }
}
",48,1467,266
"#include ""DemoFOTAUpdateSelfTest.h""

#include ""FotaHub.h""



static bool ICACHE_FLASH_ATTR runRandomSelfTest(uint8_t successRate);

void ICACHE_FLASH_ATTR fotaUpdateSelfTest_init(void)
{
  srand(((uint32_t)(time(NULL))));
}

static bool ICACHE_FLASH_ATTR runRandomSelfTest(uint8_t successRate)
{
  if (((uint8_t)((os_random() % 100))) >= (successRate)) 
  {
    os_printf(""Firmware self test failed (reason: simulated pseudo-random failure)\n"");
    return false;
  }
  return true;
}

void ICACHE_FLASH_ATTR validateFirmwareUpdateActivation(void)
{
  os_printf(""Validating firmware update\n"");
  
  if (runRandomSelfTest(SIMULATED_ACTIVATION_SUCCESS_RATE)) 
  {
    os_printf(""Firmware update successfully activated\n"");
    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED);
  }
  else
  {
    os_printf(""Firmware update activation failed\n"");
    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_ACTIVATION_FAILED);
  }
}

void ICACHE_FLASH_ATTR validateFirmwareUpdateReversion(void)
{
  os_printf(""Validating previous firmware\n"");
  
  if (runRandomSelfTest(SIMULATED_REVERSION_SUCCESS_RATE)) 
  {
    os_printf(""Firmware update successfully reverted\n"");
    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_REVERSION_SUCCEEDED);
  }
  else
  {
    os_printf(""Firmware update reversion failed\n"");
    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_REVERSION_FAILED);
  }
}
",48,1468,541
"#include ""UARTDrv.h""

#include ""freertos/FreeRTOS.h""


static uart_port_t uartUnit;

void uart_init(uart_port_t unit, uart_config_t *config, uint8_t txPin, uint8_t rxPin)
{
  uartUnit = unit;
  
  uart_param_config(unit, config);
  
  uart_set_pin(unit, txPin, rxPin, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);
  
  uart_driver_install(unit, UART_BUFFER_SIZE, UART_BUFFER_SIZE, 0, NULL, 0);
  
  uart_set_mode(unit, UART_MODE_UART);
}

void uart_recvTask(void)
{
  size_t rxDataLen = 0;
  if (uart_get_buffered_data_len(uartUnit, &rxDataLen) != ESP_OK) 
  {
    return;
  }
  if (rxDataLen == 0) 
  {
    return;
  }
  
  uint8_t *data = ((uint8_t *)(malloc(rxDataLen)));
  
  uart_read_bytes(uartUnit, data, ((uint32_t)(rxDataLen)), 100 / portTICK_RATE_MS);
  
  for ( int64_t __i = 0 ; __i < rxDataLen; __i++ )
  {
    firmwareUpdateInfoReader_onCharacterReceived(*(data + __i));
  }
  if (data != NULL) 
  {
    free(data);
  }
}
",48,1469,444
"#include ""SinglePartitionDemoFirmwareUpdateInfoFileReader.h""

#include ""BinHexConverter.h""
#include ""DemoProductInfo.h""
#include ""FotaHub.h""



#include ""ctype.h""



static bool isWhitespace(char *str);

static bool createFirmwareUpdateInfoFile(void);

static void openFirmwareUpdateInfoFileInVSCode(void);

static bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize);

static bool parseFirmwareUpdateInfo(char *updateInfoString);

static char lastUpdateInfoString[260 + 1] = { 0 };

static char updateVersion[MAX_UPDATE_VERSION_LENGTH + 1] = { 0 };

static uint8_t *updateVerificationData = NULL;

static bool isWhitespace(char *str)
{
  size_t idx = 0;
  char currentChr = str[idx++];
  while (currentChr != '\0')
  {
    if (isspace(currentChr) == 0) 
    {
      return false;
    }
    currentChr = str[idx++];
  }
  return true;
}

void firmwareUpdateInfoReader_init(void)
{
  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);
  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));
  memset(updateVerificationData, 0, updateVerificationDataSize);
  
  if (!createFirmwareUpdateInfoFile()) 
  {
    return;
  }
  
  openFirmwareUpdateInfoFileInVSCode();
}

void firmwareUpdateInfoReader_run(void)
{
  
  char updateInfoString[260 + 1] = """";
  if (!loadFirmwareUpdateInfoFile(updateInfoString, sizeof(updateInfoString))) 
  {
    memset(lastUpdateInfoString, 0, sizeof(lastUpdateInfoString));
    return;
  }
  
  
  if (strncmp(updateInfoString, lastUpdateInfoString, 260) == 0) 
  {
    return;
  }
  strncpy(lastUpdateInfoString, updateInfoString, 260);
  
  
  if (!parseFirmwareUpdateInfo(updateInfoString)) 
  {
    return;
  }
  
  
  printf(""Firmware update request towards version %s received\n"", updateVersion);
  fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);
}

static bool createFirmwareUpdateInfoFile(void)
{
  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, ""w"");
  if (updateInfoFile == NULL) 
  {
    printf(""Failed to create %s: %s (error code: %i)\n"", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, strerror(errno), errno);
    return false;
  }
  fclose(updateInfoFile);
  return true;
}

static void openFirmwareUpdateInfoFileInVSCode(void)
{
  char vsCodePath[260 + 1] = """";
  char *os = getenv(""OS"");
  if (os != NULL && strcmp(os, ""Windows_NT"") == 0) 
  {
    snprintf(vsCodePath, sizeof(vsCodePath), ""C:\\Users\\%s\\AppData\\Local\\Programs\\Microsoft VS Code\\bin\\code"", getenv(""USERNAME""));
  }
  else
  {
    snprintf(vsCodePath, sizeof(vsCodePath), ""/usr/bin/code"");
  }
  
  if (access(vsCodePath, F_OK) != -1) 
  {
    char openCommand[260 + 1] = """";
    snprintf(openCommand, sizeof(openCommand), ""code %s"", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);
    system(openCommand);
  }
}

static bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize)
{
  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, ""r"");
  if (updateInfoFile == NULL) 
  {
    
    return false;
  }
  memset(updateInfoString, 0, updateInfoStringSize);
  while (isWhitespace(updateInfoString))
  {
    if (fgets(updateInfoString, ((int32_t) updateInfoStringSize), updateInfoFile) == NULL) 
    {
      
      fclose(updateInfoFile);
      return false;
    }
  }
  fclose(updateInfoFile);
  return true;
}

static bool parseFirmwareUpdateInfo(char *updateInfoString)
{
  
  memset(updateVersion, 0, sizeof(updateVersion));
  memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
  if (strstr(updateInfoString, UPDATE_INFO_SEPARATOR) == NULL) 
  {
    printf(""Firmware update request with missing version and/or verification data entered\n"");
    return false;
  }
  
  
  char *parsedVersion = strtok(updateInfoString, UPDATE_INFO_DELIMITERS);
  if (parsedVersion == NULL) 
  {
    printf(""Firmware update request with missing version and verification data entered\n"");
    return false;
  }
  if (strlen(parsedVersion) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) 
  {
    printf(""Received firmware update version too long (max. length = %hhu)\n"", MAX_UPDATE_VERSION_LENGTH);
    return false;
  }
  strncpy(updateVersion, parsedVersion, sizeof(updateVersion));
  
  
  char *parsedVerificationData = strtok(NULL, UPDATE_INFO_DELIMITERS);
  if (parsedVerificationData == NULL) 
  {
    printf(""Firmware update request with missing version or verification data entered\n"");
    memset(updateVersion, 0, sizeof(updateVersion));
    return false;
  }
  if (strlen(parsedVerificationData) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) 
  {
    printf(""Received firmware update verification data too long (max. length = %hhu)\n"", MAX_UPDATE_VERSION_LENGTH << 1);
    memset(updateVersion, 0, sizeof(updateVersion));
    return false;
  }
  if (convertHexString8ToBinData(parsedVerificationData, strlen(parsedVerificationData), updateVerificationData, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) == 0) 
  {
    printf(""Firmware update request with invalid verification data entered\n"");
    memset(updateVersion, 0, sizeof(updateVersion));
    memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
    return false;
  }
  
  return true;
}

void fotahub_onProvideFirmwareUpdateVerificationInfo(FirmwareUpdateInfo_t const *pUpdateInfo, FOTAUpdateVerificationAlgorithm_t *pVerificationAlgorithm, uint8_t const  **ppVerificationData)
{
  *pVerificationAlgorithm = DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM;
  *ppVerificationData = updateVerificationData;
}
",48,1470,2006
"#include ""WiFiStationDrv.h""

#include ""FotaHub.h""
#include ""esp_event_loop.h""
#include ""esp_wifi.h""


static esp_err_t wifiEventHandlerCallback(void *ctx, system_event_t *event);

void wifi_init(void)
{
  tcpip_adapter_init();
  esp_event_loop_init(&wifiEventHandlerCallback, NULL);
  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
  esp_wifi_init(&cfg);
  esp_wifi_set_mode(WIFI_MODE_STA);
  esp_wifi_set_storage(WIFI_STORAGE_RAM);
}

bool wifiStation_connect(char const *ssid, char const *passphrase)
{
  wifi_config_t config = 
  {
    .sta = 
    {
      .bssid_set = false
    }
  };
  size_t ssidLen = strlen(ssid);
  memcpy(config.sta.ssid, ssid, ssidLen);
  if (ssidLen < sizeof(config.sta.ssid)) 
  {
    config.sta.ssid[ssidLen] = 0;
  }
  size_t passphraseLen = strlen(passphrase);
  memcpy(config.sta.password, passphrase, passphraseLen);
  if (passphraseLen < sizeof(config.sta.password)) 
  {
    config.sta.password[passphraseLen] = 0;
  }
  
  esp_wifi_set_config(WIFI_IF_STA, &config);
  esp_wifi_start();
  esp_wifi_connect();
  
  return true;
}

static esp_err_t wifiEventHandlerCallback(void *ctx, system_event_t *event)
{
  switch (event->event_id)
  {
    case SYSTEM_EVENT_STA_GOT_IP:
    {
      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);
      break;
    }
    case SYSTEM_EVENT_STA_LOST_IP:
    case SYSTEM_EVENT_STA_DISCONNECTED:
    case SYSTEM_EVENT_STA_STOP:
    case SYSTEM_EVENT_STA_DHCP_TIMEOUT:
    {
      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_DISCONNECTED);
      break;
    }
    default: {
      break;
    }
  }
  return ESP_OK;
}
",48,1471,684
"#include ""SinglePartitionDemoFirmwareUpdateInfoSerialReader.h""

#include ""DemoFOTAUpdateWorkflow.h""
#include ""BinHexConverter.h""
#include ""FotaHub.h""
#include ""DemoProductInfo.h""
#include ""ctype.h""



enum FirmwareUpdateInfoParser__inevents {
  FirmwareUpdateInfoParser_characterReceived__event,
  FirmwareUpdateInfoParser_updateInfoPickedUp__event
};
typedef enum FirmwareUpdateInfoParser__inevents FirmwareUpdateInfoParser__inevents_t;

enum FirmwareUpdateInfoParser__states {
  FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state = 0,
  FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state,
  FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state,
  FirmwareUpdateInfoParser_yielding__state
};
typedef enum FirmwareUpdateInfoParser__states FirmwareUpdateInfoParser__states_t;

struct FirmwareUpdateInfoParser__data {
  FirmwareUpdateInfoParser__states_t __currentState;
  size_t characterIdx;
};
typedef struct FirmwareUpdateInfoParser__data FirmwareUpdateInfoParser__data_t;

static void FirmwareUpdateInfoParser__init(FirmwareUpdateInfoParser__data_t *instance);

static bool FirmwareUpdateInfoParser__execute(FirmwareUpdateInfoParser__data_t *instance, FirmwareUpdateInfoParser__inevents_t event, void **arguments);

static char updateVersion[MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH + 1] = { 0 };

static uint8_t *updateVerificationData = NULL;

static FirmwareUpdateInfoParser__data_t updateInfoParser;

void firmwareUpdateInfoReader_init(void)
{
  FirmwareUpdateInfoParser__init(&updateInfoParser);
  
  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);
  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));
  memset(updateVerificationData, 0, updateVerificationDataSize);
}

void firmwareUpdateInfoReader_run(void)
{
  if ((updateInfoParser.__currentState == FirmwareUpdateInfoParser_yielding__state)) 
  {
    printf(""Firmware update request towards version %s received\n"", updateVersion);
    fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);
    FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_updateInfoPickedUp__event, NULL);
  }
}

void firmwareUpdateInfoReader_onCharacterReceived(uint8_t character)
{
  uint8_t ___FirmwareUpdateInfoParser_characterReceived_character__arg = character;
  void *___FirmwareUpdateInfoParser_characterReceived__args[1] = { &___FirmwareUpdateInfoParser_characterReceived_character__arg };
  FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_characterReceived__event, ___FirmwareUpdateInfoParser_characterReceived__args);
}

static void FirmwareUpdateInfoParser__init(FirmwareUpdateInfoParser__data_t *instance)
{
  instance->characterIdx = 0;
  instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;
}

static bool FirmwareUpdateInfoParser__execute(FirmwareUpdateInfoParser__data_t *instance, FirmwareUpdateInfoParser__inevents_t event, void **arguments)
{
  switch (instance->__currentState)
  {
    case FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state:
    {
      switch (event)
      {
        case FirmwareUpdateInfoParser_characterReceived__event:
        {
          if ((*((uint8_t *)((arguments[0])))) != COLON && isspace((*((uint8_t *)((arguments[0]))))) == 0 && instance->characterIdx < MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH - 1) 
          {
            
            
            updateVersion[instance->characterIdx++] = ((char)((*((uint8_t *)((arguments[0]))))));
            
            
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == COLON && instance->characterIdx > 0) 
          {
            
            
            updateVersion[instance->characterIdx] = '\0';
            instance->characterIdx = 0;
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) != COLON && isspace((*((uint8_t *)((arguments[0]))))) == 0 && instance->characterIdx >= MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH - 1) 
          {
            
            printf(""Received firmware update version too long (max. length = %hhu)\n"", MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH);
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == COLON && instance->characterIdx == 0) 
          {
            
            printf(""Firmware update request with missing version received\n"");
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx == 0) 
          {
            
            printf(""Empty firmware update request received\n"");
            instance->characterIdx = 0;
            
            
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0) 
          {
            
            printf(""Firmware update request with missing verification data received\n"");
            memset(updateVersion, 0, sizeof(updateVersion));
            instance->characterIdx = 0;
            
            
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state:
    {
      switch (event)
      {
        case FirmwareUpdateInfoParser_characterReceived__event:
        {
          if ((*((uint8_t *)((arguments[0])))) != LF) 
          {
            
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF) 
          {
            
            memset(updateVersion, 0, sizeof(updateVersion));
            memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
            instance->characterIdx = 0;
            
            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state) 
            {
              
              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;
            }
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state:
    {
      switch (event)
      {
        case FirmwareUpdateInfoParser_characterReceived__event:
        {
          if (isxdigit((*((uint8_t *)((arguments[0]))))) != 0 && instance->characterIdx < getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) 
          {
            
            
            if (((instance->characterIdx & (1)) == 0)) 
            {
              
              updateVerificationData[instance->characterIdx >> 1] = convertHexDigitToBinValue(((char)((*((uint8_t *)((arguments[0]))))))) << 4;
            }
            else
            {
              
              (updateVerificationData[instance->characterIdx >> 1] |= (convertHexDigitToBinValue(((char)((*((uint8_t *)((arguments[0])))))))));
            }
            instance->characterIdx++;
            
            
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0) 
          {
            
            instance->__currentState = FirmwareUpdateInfoParser_yielding__state;
            break;
          }
          if (isxdigit((*((uint8_t *)((arguments[0]))))) != 0 && instance->characterIdx >= getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) 
          {
            
            printf(""Received firmware update verification data too long (max. length = %d)\n"", getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1);
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx == 0) 
          {
            
            printf(""Firmware update request with missing verification data received\n"");
            memset(updateVersion, 0, sizeof(updateVersion));
            memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
            instance->characterIdx = 0;
            
            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state) 
            {
              
              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;
            }
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case FirmwareUpdateInfoParser_yielding__state:
    {
      switch (event)
      {
        case FirmwareUpdateInfoParser_updateInfoPickedUp__event:
        {
          
          instance->characterIdx = 0;
          
          
          instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    default: {
      break;
    }
  }
  return true;
}

void fotahub_onProvideFirmwareUpdateVerificationInfo(FirmwareUpdateInfo_t const *pUpdateInfo, FOTAUpdateVerificationAlgorithm_t *pVerificationAlgorithm, uint8_t const  **ppVerificationData)
{
  *pVerificationAlgorithm = DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM;
  *ppVerificationData = updateVerificationData;
}
",48,1472,2909
"#include ""user_pre_init_default.h""





static void ICACHE_FLASH_ATTR initPartitionTable(enum flash_size_map flashSizeMap);

static void ICACHE_FLASH_ATTR adjustPartitionTableDataForFlashSize_512(void);

static partition_item_t partitionTable[] = 
{
  { SYSTEM_PARTITION_BOOTLOADER, 0x0u, 0x1000u }, 
  { SYSTEM_PARTITION_OTA_1, 0x1000u, SYSTEM_PARTITION_OTA_SIZE }, 
  { SYSTEM_PARTITION_OTA_2, 0x101000u, SYSTEM_PARTITION_OTA_SIZE }, 
  { SYSTEM_PARTITION_RF_CAL, 0x3fb000u, 0x1000u }, 
  { SYSTEM_PARTITION_PHY_DATA, 0x3fc000u, 0x1000u }, 
  { SYSTEM_PARTITION_SYSTEM_PARAMETER, 0x3fd000u, 0x3000u }
};

static void ICACHE_FLASH_ATTR initPartitionTable(enum flash_size_map flashSizeMap)
{
  
  switch (flashSizeMap)
  {
    case FLASH_SIZE_16M_MAP_1024_1024:
    {
      partitionTable[3].addr = 0x1fb000u;
      partitionTable[4].addr = 0x1fc000u;
      partitionTable[5].addr = 0x1fd000u;
      break;
    }
    case FLASH_SIZE_32M_MAP_512_512:
    {
      adjustPartitionTableDataForFlashSize_512();
      break;
    }
    case FLASH_SIZE_16M_MAP_512_512:
    {
      adjustPartitionTableDataForFlashSize_512();
      partitionTable[3].addr = 0x1fb000u;
      partitionTable[4].addr = 0x1fc000u;
      partitionTable[5].addr = 0x1fd000u;
      break;
    }
    case FLASH_SIZE_8M_MAP_512_512:
    {
      adjustPartitionTableDataForFlashSize_512();
      partitionTable[3].addr = 0xfb000u;
      partitionTable[4].addr = 0xfc000u;
      partitionTable[5].addr = 0xfd000u;
      break;
    }
    default: {
      
    }
  }
}

static void ICACHE_FLASH_ATTR adjustPartitionTableDataForFlashSize_512(void)
{
  partitionTable[1].size = 0x7A000u;
  partitionTable[2].addr = 0x81000u;
  partitionTable[2].size = 0x7A000u;
  
}

void ICACHE_FLASH_ATTR user_pre_init(void)
{
  enum flash_size_map flashSizeMap = system_get_flash_size_map();
  if (flashSizeMap < 2) 
  {
    os_printf(""The flash map is not supported\n"");
    while (true)
    {
    }
  }
  
  initPartitionTable(flashSizeMap);
  
  if (!system_partition_table_regist(partitionTable, sizeof(partitionTable) / sizeof(partitionTable[0]), flashSizeMap)) 
  {
    os_printf(""system_partition_table_regist fail\n"");
    while (true)
    {
    }
  }
}

uint32_t user_iram_memory_is_enabled(void)
{
  return 1;
}
",48,1473,1012
"#include ""BinHexConverter.h""




static inline char convertBinValueToHexDigit(uint8_t value, bool upperCase);

static inline char convertBinValueToHexDigit(uint8_t value, bool upperCase)
{
  char hexA = (upperCase) ? ('A') : ('a');
  return ((char)((value < 10) ? ('0' + value) : (hexA + value - 10)));
}

uint8_t convertHexDigitToBinValue(char inputChr)
{
  if (inputChr >= '0' && inputChr <= '9') 
  {
    return ((uint8_t)(inputChr - '0'));
  }
  else if (inputChr >= 'a' && inputChr <= 'f') {
    return 10 + ((uint8_t)(inputChr - 'a'));
  }
  else if (inputChr >= 'A' && inputChr <= 'F') {
    return 10 + ((uint8_t)(inputChr - 'A'));
  }
  return 0;
}

size_t convertBinValueToHexString8(uint8_t inputValue, char *outputStr, size_t outputStrSize, bool upperCase)
{
  if (outputStrSize < 2) 
  {
    return 0;
  }
  outputStr[0] = convertBinValueToHexDigit(((inputValue & 0xF0u) >> 4), upperCase);
  outputStr[1] = convertBinValueToHexDigit((inputValue & 0x0Fu), upperCase);
  return 2;
}

uint8_t convertHexString8ToBinValue(char *inputStr, size_t inputStrLength)
{
  if (inputStrLength != 2) 
  {
    return 0;
  }
  uint8_t outputValue = convertHexDigitToBinValue(inputStr[0]) << 4;
  outputValue |= convertHexDigitToBinValue(inputStr[1]);
  return outputValue;
}

size_t convertBinDataToHexString8(uint8_t *inputData, size_t inputDataSize, char *outputStr, size_t outputStrSize, bool upperCase)
{
  if (outputStrSize < inputDataSize * 2) 
  {
    return 0;
  }
  outputStr[0] = '\0';
  size_t count = 0;
  for ( size_t i = 0 ; i < inputDataSize; i++ )
  {
    count += convertBinValueToHexString8(inputData[i], outputStr + 2 * i, outputStrSize - count, upperCase);
  }
  if (outputStrSize > count) 
  {
    outputStr[count++] = '\0';
  }
  return count;
}

size_t convertHexString8ToBinData(char *inputStr, size_t inputStrLength, uint8_t *pOutputData, size_t outputDataSize)
{
  if (outputDataSize < inputStrLength >> 1) 
  {
    return 0;
  }
  if ((inputStrLength & 0x01u) != 0) 
  {
    return 0;
  }
  memset(pOutputData, 0x00u, outputDataSize);
  for ( size_t i = 0 ; i < inputStrLength; i = i + 2 )
  {
    pOutputData[i >> 1] = convertHexString8ToBinValue(inputStr + i, 2);
  }
  return inputStrLength >> 1;
}
",48,1474,913
"#include ""MultiPartitionDemoFirmwareUpdateInfoSerialReader.h""

#include ""DemoFOTAUpdateWorkflow.h""
#include ""BinHexConverter.h""
#include ""FotaHub.h""
#include ""DemoProductInfo.h""
#include ""ctype.h""



enum FirmwareUpdateInfoParser__inevents {
  FirmwareUpdateInfoParser_characterReceived__event,
  FirmwareUpdateInfoParser_updateInfoPickedUp__event
};
typedef enum FirmwareUpdateInfoParser__inevents FirmwareUpdateInfoParser__inevents_t;

enum FirmwareUpdateInfoParser__states {
  FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state = 0,
  FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state,
  FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state,
  FirmwareUpdateInfoParser_yielding__state
};
typedef enum FirmwareUpdateInfoParser__states FirmwareUpdateInfoParser__states_t;

struct FirmwareUpdateInfoParser__data {
  FirmwareUpdateInfoParser__states_t __currentState;
  size_t characterIdx;
  size_t partitionIdx;
  uint8_t *pCurrentVerificationData;
};
typedef struct FirmwareUpdateInfoParser__data FirmwareUpdateInfoParser__data_t;

static void ICACHE_FLASH_ATTR FirmwareUpdateInfoParser__init(FirmwareUpdateInfoParser__data_t *instance);

static bool ICACHE_FLASH_ATTR FirmwareUpdateInfoParser__execute(FirmwareUpdateInfoParser__data_t *instance, FirmwareUpdateInfoParser__inevents_t event, void **arguments);

static char updateVersion[MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH + 1] = { 0 };

static uint8_t *updateVerificationData[UPDATE_PARTITION_COUNT] = { NULL, NULL };

static FirmwareUpdateInfoParser__data_t updateInfoParser;

void ICACHE_FLASH_ATTR firmwareUpdateInfoReader_init(void)
{
  FirmwareUpdateInfoParser__init(&updateInfoParser);
  
  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);
  updateVerificationData[0] = ((uint8_t *)(os_malloc(updateVerificationDataSize)));
  updateVerificationData[1] = ((uint8_t *)(os_malloc(updateVerificationDataSize)));
  os_memset(updateVerificationData[0], 0, updateVerificationDataSize);
  os_memset(updateVerificationData[1], 0, updateVerificationDataSize);
}

void ICACHE_FLASH_ATTR firmwareUpdateInfoReader_run(void)
{
  if ((updateInfoParser.__currentState == FirmwareUpdateInfoParser_yielding__state)) 
  {
    os_printf(""Firmware update request towards version %s received\n"", updateVersion);
    fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);
    FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_updateInfoPickedUp__event, NULL);
  }
}

void ICACHE_FLASH_ATTR firmwareUpdateInfoReader_onCharacterReceived(uint8_t character)
{
  uint8_t ___FirmwareUpdateInfoParser_characterReceived_character__arg = character;
  void *___FirmwareUpdateInfoParser_characterReceived__args[1] = { &___FirmwareUpdateInfoParser_characterReceived_character__arg };
  FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_characterReceived__event, ___FirmwareUpdateInfoParser_characterReceived__args);
}

static void ICACHE_FLASH_ATTR FirmwareUpdateInfoParser__init(FirmwareUpdateInfoParser__data_t *instance)
{
  instance->characterIdx = 0;
  instance->partitionIdx = 0;
  instance->pCurrentVerificationData = updateVerificationData[0];
  instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;
}

static bool ICACHE_FLASH_ATTR FirmwareUpdateInfoParser__execute(FirmwareUpdateInfoParser__data_t *instance, FirmwareUpdateInfoParser__inevents_t event, void **arguments)
{
  switch (instance->__currentState)
  {
    case FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state:
    {
      switch (event)
      {
        case FirmwareUpdateInfoParser_characterReceived__event:
        {
          if ((*((uint8_t *)((arguments[0])))) != COLON && isspace((*((uint8_t *)((arguments[0]))))) == 0 && instance->characterIdx < MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH - 1) 
          {
            
            
            updateVersion[instance->characterIdx++] = ((char)((*((uint8_t *)((arguments[0]))))));
            
            
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == COLON && instance->characterIdx > 0) 
          {
            
            
            updateVersion[instance->characterIdx] = '\0';
            instance->characterIdx = 0;
            instance->pCurrentVerificationData = updateVerificationData[instance->partitionIdx];
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) != COLON && isspace((*((uint8_t *)((arguments[0]))))) == 0 && instance->characterIdx >= MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH - 1) 
          {
            
            os_printf(""Received firmware update version too long (max. length = %d)\n"", MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH);
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == COLON && instance->characterIdx == 0) 
          {
            
            os_printf(""Firmware update request with missing version received\n"");
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx == 0) 
          {
            
            os_printf(""Empty firmware update request received\n"");
            instance->characterIdx = 0;
            instance->partitionIdx = 0;
            
            
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0) 
          {
            
            os_printf(""Firmware update request with missing verification data received\n"");
            memset(updateVersion, 0, sizeof(updateVersion));
            instance->characterIdx = 0;
            instance->partitionIdx = 0;
            
            
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state:
    {
      switch (event)
      {
        case FirmwareUpdateInfoParser_characterReceived__event:
        {
          if ((*((uint8_t *)((arguments[0])))) != LF) 
          {
            
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF) 
          {
            
            memset(updateVersion, 0, sizeof(updateVersion));
            os_memset(updateVerificationData[0], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
            os_memset(updateVerificationData[1], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
            instance->characterIdx = 0;
            instance->partitionIdx = 0;
            
            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state) 
            {
              
              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;
            }
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state:
    {
      switch (event)
      {
        case FirmwareUpdateInfoParser_characterReceived__event:
        {
          if (isxdigit((*((uint8_t *)((arguments[0]))))) != 0 && instance->characterIdx < getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) 
          {
            
            
            if (((instance->characterIdx & (1)) == 0)) 
            {
              
              instance->pCurrentVerificationData[instance->characterIdx >> 1] = convertHexDigitToBinValue(((char)((*((uint8_t *)((arguments[0]))))))) << 4;
            }
            else
            {
              
              (instance->pCurrentVerificationData[instance->characterIdx >> 1] |= (convertHexDigitToBinValue(((char)((*((uint8_t *)((arguments[0])))))))));
            }
            instance->characterIdx++;
            
            
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == COMMA && instance->characterIdx > 0 && instance->partitionIdx < UPDATE_PARTITION_COUNT - 1) 
          {
            
            instance->characterIdx = 0;
            instance->partitionIdx++;
            instance->pCurrentVerificationData = updateVerificationData[instance->partitionIdx];
            
            
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0 && instance->partitionIdx == UPDATE_PARTITION_COUNT - 1) 
          {
            
            instance->__currentState = FirmwareUpdateInfoParser_yielding__state;
            break;
          }
          if (isxdigit((*((uint8_t *)((arguments[0]))))) != 0 && instance->characterIdx >= getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) 
          {
            
            os_printf(""Received firmware update verification data #%d too long (max. length = %d)\n"", instance->partitionIdx + 1, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1);
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == COMMA && instance->characterIdx == 0) 
          {
            
            os_printf(""Firmware update request with missing verification data #%d received\n"", instance->partitionIdx + 1);
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == COMMA && instance->characterIdx > 0 && instance->partitionIdx >= UPDATE_PARTITION_COUNT - 1) 
          {
            
            os_printf(""Firmware update request with too many verifications data received (max. # = %d)\n"", UPDATE_PARTITION_COUNT);
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx == 0) 
          {
            
            os_printf(""Firmware update request with missing verification data #%d received\n"", instance->partitionIdx + 1);
            memset(updateVersion, 0, sizeof(updateVersion));
            os_memset(updateVerificationData[0], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
            os_memset(updateVerificationData[1], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
            instance->characterIdx = 0;
            instance->partitionIdx = 0;
            
            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state) 
            {
              
              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;
            }
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0 && instance->partitionIdx < UPDATE_PARTITION_COUNT - 1) 
          {
            
            os_printf(""Firmware update request with missing verification data #%d received\n"", instance->partitionIdx + 2);
            memset(updateVersion, 0, sizeof(updateVersion));
            os_memset(updateVerificationData[0], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
            os_memset(updateVerificationData[1], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
            instance->characterIdx = 0;
            instance->partitionIdx = 0;
            
            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state) 
            {
              
              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;
            }
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case FirmwareUpdateInfoParser_yielding__state:
    {
      switch (event)
      {
        case FirmwareUpdateInfoParser_updateInfoPickedUp__event:
        {
          
          instance->characterIdx = 0;
          instance->partitionIdx = 0;
          
          
          instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    default: {
      break;
    }
  }
  return true;
}

void ICACHE_FLASH_ATTR fotahub_onProvideFirmwareUpdateVerificationInfo(FirmwareUpdateInfo_t const *pUpdateInfo, FOTAUpdateVerificationAlgorithm_t *pVerificationAlgorithm, uint8_t const  **ppVerificationData)
{
  *pVerificationAlgorithm = DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM;
  if (pUpdateInfo->partitionIdx >= 0 && pUpdateInfo->partitionIdx < UPDATE_PARTITION_COUNT) 
  {
    *ppVerificationData = updateVerificationData[((size_t)(pUpdateInfo->partitionIdx))];
  }
  else
  {
    *ppVerificationData = NULL;
  }
}
",48,1475,4032
"#include ""Main.h""

#include ""Configuration.h""
#include ""DemoFOTAUpdateWorkflow.h""
#include ""SinglePartitionDemoFirmwareUpdateInfoFileReader.h""
#include ""DemoFOTAUpdateWorkflowFilePersistence.h""
#include ""DemoFOTAUpdateSelfTest.h""
#include ""DemoProductInfo.h""
#include ""FotaHub.h""





int32_t main(int32_t argc, char *argv[])
{
  
  char *programDir = dirname(strdup(argv[0]));
  chdir(programDir);
  
  firmwareUpdateInfoReader_init();
  fotaUpdateWorkflow_init();
  fotaUpdateSelfTest_init();
  fotahub_init(argv[0], DEMO_PRODUCT_ID, DEMO_PRODUCT_NAME, &FOTA_UPDATE_CLIENT_CONFIG);
  
  printf(""\n--------------------------------------------------------------------------\n"");
  printf(""Running %s %s firmware\n"", DEMO_PRODUCT_NAME, DEMO_PRODUCT_FIRMWARE_VERSION);
  printf(""--------------------------------------------------------------------------\n\n"");
  
  
  fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);
  
  char *separator = (strlen(programDir) > 0) ? (""/"") : ("""");
  printf(""Waiting for firmware update info (<new-version>:<checksum-or-signature>) to be entered and saved in '%s%s%s' file\n"", programDir, separator, DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);
  
  while (true)
  {
    firmwareUpdateInfoReader_run();
    fotahub_run();
  }
}
",48,1476,450
"#include ""DemoFOTAUpdateWorkflowNVSFlashPersistence.h""

#include ""Configuration.h""
#include ""DemoFOTAUpdateWorkflowPersistence.h""
#include ""nvs_flash.h""


void saveState(int16_t state)
{
  nvs_handle *nvsHandle = ((nvs_handle *)(malloc(sizeof(nvs_handle))));
  if (nvsHandle == NULL) 
  {
    return;
  }
  if (nvs_open(DEMO_PRODUCT_STORAGE_NAMESPACE, NVS_READWRITE, nvsHandle) == ESP_OK) 
  {
    nvs_set_u8(*nvsHandle, DEMO_PRODUCT_FLASH_STORE_KEY, ((uint8_t) state));
    nvs_commit(*nvsHandle);
    nvs_close(*nvsHandle);
    free(nvsHandle);
    return;
  }
  free(nvsHandle);
  printf(""Failed write statemachine state to NVS\n"");
}

int16_t loadState(void)
{
  int16_t state = 0;
  nvs_handle *nvsHandle = ((nvs_handle *)(malloc(sizeof(nvs_handle))));
  if (nvsHandle == NULL) 
  {
    return 0;
  }
  if (nvs_open(DEMO_PRODUCT_STORAGE_NAMESPACE, NVS_READONLY, nvsHandle) == ESP_OK) 
  {
    nvs_get_u8(*nvsHandle, DEMO_PRODUCT_FLASH_STORE_KEY, ((uint8_t *)(&state)));
  }
  nvs_close(*nvsHandle);
  free(nvsHandle);
  
  if (state == -1) 
  {
    return 0;
  }
  return state;
}
",48,1477,478
"#include ""Main.h""

#include ""Configuration.h""
#include ""DemoFOTAUpdateWorkflow.h""
#include ""SinglePartitionDemoFirmwareUpdateInfoFileReader.h""
#include ""DemoProductInfo.h""
#include ""FotaHub.h""




static char *dirname(char *path);

int32_t main(int32_t argc, char *argv[])
{
  
  char *programDir = dirname(_strdup(argv[0]));
  _chdir(programDir);
  
  printf(""\n--------------------------------------------------------------------------\n"");
  printf(""Running %s %s firmware\n"", DEMO_PRODUCT_NAME, DEMO_PRODUCT_FIRMWARE_VERSION);
  printf(""--------------------------------------------------------------------------\n\n"");
  
  firmwareUpdateInfoReader_init();
  fotaUpdateWorkflow_init();
  fotahub_init(argv[0], DEMO_PRODUCT_ID, DEMO_PRODUCT_NAME, &FOTA_UPDATE_CLIENT_CONFIG);
  
  fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);
  
  firmwareUpdateInfoReader_explain(programDir);
  
  while (true)
  {
    firmwareUpdateInfoReader_run();
    fotahub_run();
  }
}

static char *dirname(char *path)
{
  char *lastSeparator = strrchr(path, '\\');
  if (lastSeparator != NULL) 
  {
    *lastSeparator = '\0';
    return path;
  }
  else
  {
    *path = '\0';
  }
  return path;
}
",48,1478,430
"#include ""SinglePartitionDemoFirmwareUpdateInfoSerialReader.h""

#include ""DemoFOTAUpdateWorkflow.h""
#include ""BinHexConverter.h""
#include ""FotaHub.h""
#include ""DemoProductInfo.h""
#include ""ctype.h""



enum FirmwareUpdateInfoParser__inevents {
  FirmwareUpdateInfoParser_characterReceived__event,
  FirmwareUpdateInfoParser_updateInfoPickedUp__event
};
typedef enum FirmwareUpdateInfoParser__inevents FirmwareUpdateInfoParser__inevents_t;

enum FirmwareUpdateInfoParser__states {
  FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state = 0,
  FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state,
  FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state,
  FirmwareUpdateInfoParser_yielding__state
};
typedef enum FirmwareUpdateInfoParser__states FirmwareUpdateInfoParser__states_t;

struct FirmwareUpdateInfoParser__data {
  FirmwareUpdateInfoParser__states_t __currentState;
  size_t characterIdx;
};
typedef struct FirmwareUpdateInfoParser__data FirmwareUpdateInfoParser__data_t;

static void FirmwareUpdateInfoParser__init(FirmwareUpdateInfoParser__data_t *instance);

static bool FirmwareUpdateInfoParser__execute(FirmwareUpdateInfoParser__data_t *instance, FirmwareUpdateInfoParser__inevents_t event, void **arguments);

static char updateVersion[MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH + 1] = { 0 };

static uint8_t *updateVerificationData = NULL;

static FirmwareUpdateInfoParser__data_t updateInfoParser;

void firmwareUpdateInfoReader_init(void)
{
  FirmwareUpdateInfoParser__init(&updateInfoParser);
  
  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);
  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));
  memset(updateVerificationData, 0, updateVerificationDataSize);
}

void firmwareUpdateInfoReader_run(void)
{
  if ((updateInfoParser.__currentState == FirmwareUpdateInfoParser_yielding__state)) 
  {
    printf(""Firmware update request towards version %s received\n"", updateVersion);
    fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);
    FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_updateInfoPickedUp__event, NULL);
  }
}

void firmwareUpdateInfoReader_onCharacterReceived(uint8_t character)
{
  uint8_t ___FirmwareUpdateInfoParser_characterReceived_character__arg = character;
  void *___FirmwareUpdateInfoParser_characterReceived__args[1] = { &___FirmwareUpdateInfoParser_characterReceived_character__arg };
  FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_characterReceived__event, ___FirmwareUpdateInfoParser_characterReceived__args);
}

static void FirmwareUpdateInfoParser__init(FirmwareUpdateInfoParser__data_t *instance)
{
  instance->characterIdx = 0;
  instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;
}

static bool FirmwareUpdateInfoParser__execute(FirmwareUpdateInfoParser__data_t *instance, FirmwareUpdateInfoParser__inevents_t event, void **arguments)
{
  switch (instance->__currentState)
  {
    case FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state:
    {
      switch (event)
      {
        case FirmwareUpdateInfoParser_characterReceived__event:
        {
          if ((*((uint8_t *)((arguments[0])))) != COLON && isspace((*((uint8_t *)((arguments[0]))))) == 0 && instance->characterIdx < MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH - 1) 
          {
            
            
            updateVersion[instance->characterIdx++] = ((char)((*((uint8_t *)((arguments[0]))))));
            
            
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == COLON && instance->characterIdx > 0) 
          {
            
            
            updateVersion[instance->characterIdx] = '\0';
            instance->characterIdx = 0;
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) != COLON && isspace((*((uint8_t *)((arguments[0]))))) == 0 && instance->characterIdx >= MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH - 1) 
          {
            
            printf(""Received firmware update version too long (max. length = %hhu)\n"", MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH);
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == COLON && instance->characterIdx == 0) 
          {
            
            printf(""Firmware update request with missing version received\n"");
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx == 0) 
          {
            
            printf(""Empty firmware update request received\n"");
            instance->characterIdx = 0;
            
            
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0) 
          {
            
            printf(""Firmware update request with missing verification data received\n"");
            memset(updateVersion, 0, sizeof(updateVersion));
            instance->characterIdx = 0;
            
            
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state:
    {
      switch (event)
      {
        case FirmwareUpdateInfoParser_characterReceived__event:
        {
          if ((*((uint8_t *)((arguments[0])))) != LF) 
          {
            
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF) 
          {
            
            memset(updateVersion, 0, sizeof(updateVersion));
            memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
            instance->characterIdx = 0;
            
            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state) 
            {
              
              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;
            }
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state:
    {
      switch (event)
      {
        case FirmwareUpdateInfoParser_characterReceived__event:
        {
          if (isxdigit((*((uint8_t *)((arguments[0]))))) != 0 && instance->characterIdx < getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) 
          {
            
            
            if (((instance->characterIdx & (1)) == 0)) 
            {
              
              updateVerificationData[instance->characterIdx >> 1] = convertHexDigitToBinValue(((char)((*((uint8_t *)((arguments[0]))))))) << 4;
            }
            else
            {
              
              (updateVerificationData[instance->characterIdx >> 1] |= (convertHexDigitToBinValue(((char)((*((uint8_t *)((arguments[0])))))))));
            }
            instance->characterIdx++;
            
            
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0) 
          {
            
            instance->__currentState = FirmwareUpdateInfoParser_yielding__state;
            break;
          }
          if (isxdigit((*((uint8_t *)((arguments[0]))))) != 0 && instance->characterIdx >= getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) 
          {
            
            printf(""Received firmware update verification data too long (max. length = %d)\n"", getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1);
            
            
            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;
            break;
          }
          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx == 0) 
          {
            
            printf(""Firmware update request with missing verification data received\n"");
            memset(updateVersion, 0, sizeof(updateVersion));
            memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
            instance->characterIdx = 0;
            
            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state) 
            {
              
              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;
            }
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case FirmwareUpdateInfoParser_yielding__state:
    {
      switch (event)
      {
        case FirmwareUpdateInfoParser_updateInfoPickedUp__event:
        {
          
          instance->characterIdx = 0;
          
          
          instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    default: {
      break;
    }
  }
  return true;
}

void fotahub_onProvideFirmwareUpdateVerificationInfo(FirmwareUpdateInfo_t const *pUpdateInfo, FOTAUpdateVerificationAlgorithm_t *pVerificationAlgorithm, uint8_t const  **ppVerificationData)
{
  *pVerificationAlgorithm = DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM;
  *ppVerificationData = updateVerificationData;
}
",48,1479,2909
"#include ""WiFiStationDrv.h""

#include ""FotaHub.h""



static void ICACHE_FLASH_ATTR wifiEventHandlerCallback(System_Event_t *sys_evt);

bool ICACHE_FLASH_ATTR wifiStation_connect(char const *ssid, char const *password)
{
  wifi_set_event_handler_cb(&wifiEventHandlerCallback);
  
  uint8_t currentMode = wifi_get_opmode();
  currentMode = ((currentMode |= (STATION_MODE)));
  currentMode = ((currentMode &= ~(SOFTAP_MODE)));
  if (!wifi_set_opmode_current(currentMode)) 
  {
    os_printf(""Failed to activate Wi-Fi station mode\n"");
    return false;
  }
  
  struct station_config config = { 0 };
  size_t ssidLen = os_strlen(ssid);
  os_memcpy(config.ssid, ssid, ssidLen);
  if (ssidLen < sizeof(config.ssid)) 
  {
    config.ssid[ssidLen] = 0;
  }
  size_t passwordLen = os_strlen(password);
  os_memcpy(config.password, password, passwordLen);
  if (passwordLen < sizeof(config.password)) 
  {
    config.password[passwordLen] = 0;
  }
  if (!wifi_station_set_config_current(&config)) 
  {
    os_printf(""Failed to set Wi-Fi station configuration\n"");
    return false;
  }
  
  
  wifi_station_connect();
  return true;
}

static void ICACHE_FLASH_ATTR wifiEventHandlerCallback(System_Event_t *sys_evt)
{
  switch (sys_evt->event)
  {
    case EVENT_STAMODE_CONNECTED:
    {
      
      break;
    }
    case EVENT_STAMODE_DISCONNECTED:
    {
      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_DISCONNECTED);
      break;
    }
    case EVENT_STAMODE_AUTHMODE_CHANGE:
    {
      
      break;
    }
    case EVENT_STAMODE_GOT_IP:
    {
      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);
      break;
    }
    case EVENT_STAMODE_DHCP_TIMEOUT:
    {
      os_printf(""Failed to obtain Wi-Fi station IP address\n"");
      break;
    }
    case EVENT_SOFTAPMODE_PROBEREQRECVED:
    {
      
      break;
    }
    case EVENT_OPMODE_CHANGED:
    {
      
      break;
    }
    default: {
      os_printf(""Unexpected Wi-Fi event encountered: %d\n"", sys_evt->event);
      break;
    }
  }
}
",48,1480,784
"#include ""DemoFOTAUpdateWorkflow.h""

#include ""DemoProductInfo.h""


enum DemoFOTAUpdateWorkflowEngine__inevents {
  DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event,
  DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event,
  DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event
};
typedef enum DemoFOTAUpdateWorkflowEngine__inevents DemoFOTAUpdateWorkflowEngine__inevents_t;

enum DemoFOTAUpdateWorkflowEngine__states {
  DemoFOTAUpdateWorkflowEngine_idle__state = 0,
  DemoFOTAUpdateWorkflowEngine_connected__state,
  DemoFOTAUpdateWorkflowEngine_downloading__state,
  DemoFOTAUpdateWorkflowEngine_restarting__state
};
typedef enum DemoFOTAUpdateWorkflowEngine__states DemoFOTAUpdateWorkflowEngine__states_t;

struct DemoFOTAUpdateWorkflowEngine__data {
  DemoFOTAUpdateWorkflowEngine__states_t __currentState;
  FirmwareUpdateInfo_t updateInfo;
};
typedef struct DemoFOTAUpdateWorkflowEngine__data DemoFOTAUpdateWorkflowEngine__data_t;

static void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance);

static bool ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments);

static inline void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);

static inline void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);

static DemoFOTAUpdateWorkflowEngine__data_t updateWorkflowEngine;

void ICACHE_FLASH_ATTR fotaUpdateWorkflow_init(void)
{
  DemoFOTAUpdateWorkflowEngine__init(&updateWorkflowEngine);
}

void ICACHE_FLASH_ATTR fotahub_onConnectionStatusChanged(ConnectionStatus_t status)
{
  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;
  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);
}

void ICACHE_FLASH_ATTR fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)
{
  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;
  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);
}

void ICACHE_FLASH_ATTR fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)
{
  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;
  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);
}

static void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance)
{
  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;
  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;
  instance->updateInfo.version = NULL;
  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;
  instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;
}

static bool ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)
{
  switch (instance->__currentState)
  {
    case DemoFOTAUpdateWorkflowEngine_idle__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:
        {
          
          os_printf(""Cannot handle firmware over-the-air update request (missing network connection)\n"");
          
          
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_connected__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:
        {
          if (os_strcmp((*((char **)((arguments[0])))), ((char *)(DEMO_PRODUCT_FIRMWARE_VERSION))) != 0) 
          {
            
            bool __transitionResult = true;
            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;
            
            
            instance->updateInfo.version = (*((char **)((arguments[0]))));
            
            
            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) 
            {
              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) 
            {
              
              instance->__currentState = __targetState;
              switch (__targetState)
              {
                case DemoFOTAUpdateWorkflowEngine_connected__state:
                {
                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
                  break;
                }
                default: {
                  break;
                }
              }
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
            break;
          }
          if (os_strcmp((*((char **)((arguments[0])))), ((char *)(DEMO_PRODUCT_FIRMWARE_VERSION))) == 0) 
          {
            
            os_printf(""Ignoring firmware over-the-air update request to version %s as this version is already running\n"", (*((char **)((arguments[0])))));
            
            
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_downloading__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:
        {
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) 
          {
            
            bool __transitionResult = true;
            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;
            
            
            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) 
            {
              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) 
            {
              
              instance->__currentState = __targetState;
              switch (__targetState)
              {
                case DemoFOTAUpdateWorkflowEngine_restarting__state:
                {
                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);
                  break;
                }
                case DemoFOTAUpdateWorkflowEngine_connected__state:
                {
                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
                  break;
                }
                default: {
                  break;
                }
              }
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
            break;
          }
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;
            break;
          }
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_restarting__state:
    {
      switch (event)
      {
        default: {
          break;
        }
      }
      break;
    }
    default: {
      break;
    }
  }
  return true;
}

static inline void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)
{
  os_printf(""Ready for firmware over-the-air update\n"");
}

static inline void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)
{
  os_printf(""Waiting for restart\n"");
}
",48,1481,2887
"#include ""UARTDrv.h""

#include ""freertos/FreeRTOS.h""


static uart_port_t uartUnit;

void uart_init(uart_port_t unit, uart_config_t *config, uint8_t txPin, uint8_t rxPin)
{
  uartUnit = unit;
  
  uart_param_config(unit, config);
  
  uart_set_pin(unit, txPin, rxPin, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);
  
  uart_driver_install(unit, UART_BUFFER_SIZE, UART_BUFFER_SIZE, 0, NULL, 0);
  
  uart_set_mode(unit, UART_MODE_UART);
}

void uart_recvTask(void)
{
  size_t rxDataLen = 0;
  if (uart_get_buffered_data_len(uartUnit, &rxDataLen) != ESP_OK) 
  {
    return;
  }
  if (rxDataLen == 0) 
  {
    return;
  }
  
  uint8_t *data = ((uint8_t *)(malloc(rxDataLen)));
  
  uart_read_bytes(uartUnit, data, ((uint32_t)(rxDataLen)), 100 / portTICK_RATE_MS);
  
  for ( int64_t __i = 0 ; __i < rxDataLen; __i++ )
  {
    firmwareUpdateInfoReader_onCharacterReceived(*(data + __i));
  }
  if (data != NULL) 
  {
    free(data);
  }
}
",48,1482,444
"#include ""DemoFOTAUpdateWorkflow.h""

#include ""DemoProductInfo.h""
#include ""DemoFOTAUpdateWorkflowPersistence.h""
#include ""DemoFOTAUpdateSelfTest.h""


enum DemoFOTAUpdateWorkflowEngine__inevents {
  DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event,
  DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event,
  DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event
};
typedef enum DemoFOTAUpdateWorkflowEngine__inevents DemoFOTAUpdateWorkflowEngine__inevents_t;

enum DemoFOTAUpdateWorkflowEngine__states {
  DemoFOTAUpdateWorkflowEngine_idle__state = 0,
  DemoFOTAUpdateWorkflowEngine_connected__state,
  DemoFOTAUpdateWorkflowEngine_downloading__state,
  DemoFOTAUpdateWorkflowEngine_restarting__state,
  DemoFOTAUpdateWorkflowEngine_activating__state,
  DemoFOTAUpdateWorkflowEngine_reverting__state
};
typedef enum DemoFOTAUpdateWorkflowEngine__states DemoFOTAUpdateWorkflowEngine__states_t;

struct DemoFOTAUpdateWorkflowEngine__data {
  DemoFOTAUpdateWorkflowEngine__states_t __currentState;
  FirmwareUpdateInfo_t updateInfo;
};
typedef struct DemoFOTAUpdateWorkflowEngine__data DemoFOTAUpdateWorkflowEngine__data_t;

static void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution);

static bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments);

static inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);

static inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);

static DemoFOTAUpdateWorkflowEngine__data_t updateWorkflowEngine;

void fotaUpdateWorkflow_init(void)
{
  DemoFOTAUpdateWorkflowEngine__init(&updateWorkflowEngine, false);
}

void fotahub_onConnectionStatusChanged(ConnectionStatus_t status)
{
  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;
  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);
}

void fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)
{
  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;
  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);
}

void fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)
{
  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;
  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);
}

static void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution)
{
  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;
  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;
  instance->updateInfo.version = NULL;
  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;
  if (!postponeInitialExecution) 
  {
    instance->__currentState = loadState();
    switch (instance->__currentState)
    {
      case DemoFOTAUpdateWorkflowEngine_connected__state:
      {
        DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
        break;
      }
      case DemoFOTAUpdateWorkflowEngine_restarting__state:
      {
        DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);
        break;
      }
      default: {
        break;
      }
    }
  }
}

static bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)
{
  switch (instance->__currentState)
  {
    case DemoFOTAUpdateWorkflowEngine_idle__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:
        {
          
          printf(""Cannot handle firmware over-the-air update request (missing network connection)\n"");
          
          
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_connected__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:
        {
          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) != 0) 
          {
            
            bool __transitionResult = true;
            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;
            
            
            instance->updateInfo.version = (*((char **)((arguments[0]))));
            
            
            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) 
            {
              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) 
            {
              
              instance->__currentState = __targetState;
              switch (__targetState)
              {
                case DemoFOTAUpdateWorkflowEngine_connected__state:
                {
                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
                  break;
                }
                default: {
                  break;
                }
              }
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
            break;
          }
          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) == 0) 
          {
            
            printf(""Ignoring firmware over-the-air update request to version %s as this version is already running\n"", (*((char **)((arguments[0])))));
            
            
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_downloading__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:
        {
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) 
          {
            
            bool __transitionResult = true;
            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;
            
            
            saveState(DemoFOTAUpdateWorkflowEngine_activating__state);
            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) 
            {
              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);
              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) 
            {
              
              instance->__currentState = __targetState;
              switch (__targetState)
              {
                case DemoFOTAUpdateWorkflowEngine_restarting__state:
                {
                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);
                  break;
                }
                case DemoFOTAUpdateWorkflowEngine_connected__state:
                {
                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
                  break;
                }
                default: {
                  break;
                }
              }
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
            break;
          }
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;
            break;
          }
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_restarting__state:
    {
      switch (event)
      {
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_activating__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            validateFirmwareUpdateActivation();
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) 
            {
              
            }
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:
        {
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED) 
          {
            
            bool __transitionResult = true;
            
            
            saveState(DemoFOTAUpdateWorkflowEngine_idle__state);
            if (!fotahub_confirmFirmwareUpdate(&instance->updateInfo)) 
            {
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) 
            {
              
              instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
              DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
            break;
          }
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_FAILED) 
          {
            
            bool __transitionResult = true;
            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;
            
            
            saveState(DemoFOTAUpdateWorkflowEngine_reverting__state);
            if (!fotahub_revertFirmwareUpdate(&instance->updateInfo)) 
            {
              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);
              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) 
            {
              
              instance->__currentState = __targetState;
              switch (__targetState)
              {
                case DemoFOTAUpdateWorkflowEngine_restarting__state:
                {
                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);
                  break;
                }
                case DemoFOTAUpdateWorkflowEngine_connected__state:
                {
                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
                  break;
                }
                default: {
                  break;
                }
              }
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_reverting__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            validateFirmwareUpdateReversion();
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_reverting__state) 
            {
              
            }
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:
        {
          
          
          saveState(DemoFOTAUpdateWorkflowEngine_idle__state);
          
          
          instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
          DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    default: {
      break;
    }
  }
  return true;
}

static inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)
{
  printf(""Ready for firmware over-the-air update\n"");
}

static inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)
{
  printf(""Waiting for restart\n"");
}
",48,1483,4053
"#include ""DemoFOTAUpdateWorkflow.h""

#include ""DemoProductInfo.h""
#include ""DemoFOTAUpdateWorkflowPersistence.h""
#include ""DemoFOTAUpdateSelfTest.h""


enum DemoFOTAUpdateWorkflowEngine__inevents {
  DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event,
  DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event,
  DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event
};
typedef enum DemoFOTAUpdateWorkflowEngine__inevents DemoFOTAUpdateWorkflowEngine__inevents_t;

enum DemoFOTAUpdateWorkflowEngine__states {
  DemoFOTAUpdateWorkflowEngine_idle__state = 0,
  DemoFOTAUpdateWorkflowEngine_connected__state,
  DemoFOTAUpdateWorkflowEngine_downloading__state,
  DemoFOTAUpdateWorkflowEngine_restarting__state,
  DemoFOTAUpdateWorkflowEngine_activating__state,
  DemoFOTAUpdateWorkflowEngine_reverting__state
};
typedef enum DemoFOTAUpdateWorkflowEngine__states DemoFOTAUpdateWorkflowEngine__states_t;

struct DemoFOTAUpdateWorkflowEngine__data {
  DemoFOTAUpdateWorkflowEngine__states_t __currentState;
  FirmwareUpdateInfo_t updateInfo;
};
typedef struct DemoFOTAUpdateWorkflowEngine__data DemoFOTAUpdateWorkflowEngine__data_t;

static void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution);

static bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments);

static inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);

static inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);

static DemoFOTAUpdateWorkflowEngine__data_t updateWorkflowEngine;

void fotaUpdateWorkflow_init(void)
{
  DemoFOTAUpdateWorkflowEngine__init(&updateWorkflowEngine, false);
}

void fotahub_onConnectionStatusChanged(ConnectionStatus_t status)
{
  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;
  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);
}

void fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)
{
  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;
  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);
}

void fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)
{
  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;
  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);
}

static void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution)
{
  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;
  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;
  instance->updateInfo.version = NULL;
  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;
  if (!postponeInitialExecution) 
  {
    instance->__currentState = loadState();
    switch (instance->__currentState)
    {
      case DemoFOTAUpdateWorkflowEngine_connected__state:
      {
        DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
        break;
      }
      case DemoFOTAUpdateWorkflowEngine_restarting__state:
      {
        DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);
        break;
      }
      default: {
        break;
      }
    }
  }
}

static bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)
{
  switch (instance->__currentState)
  {
    case DemoFOTAUpdateWorkflowEngine_idle__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:
        {
          
          printf(""Cannot handle firmware over-the-air update request (missing network connection)\n"");
          
          
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_connected__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:
        {
          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) != 0) 
          {
            
            bool __transitionResult = true;
            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;
            
            
            instance->updateInfo.version = (*((char **)((arguments[0]))));
            
            
            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) 
            {
              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) 
            {
              
              instance->__currentState = __targetState;
              switch (__targetState)
              {
                case DemoFOTAUpdateWorkflowEngine_connected__state:
                {
                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
                  break;
                }
                default: {
                  break;
                }
              }
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
            break;
          }
          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) == 0) 
          {
            
            printf(""Ignoring firmware over-the-air update request to version %s as this version is already running\n"", (*((char **)((arguments[0])))));
            
            
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_downloading__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:
        {
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) 
          {
            
            bool __transitionResult = true;
            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;
            
            
            saveState(DemoFOTAUpdateWorkflowEngine_activating__state);
            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) 
            {
              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);
              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) 
            {
              
              instance->__currentState = __targetState;
              switch (__targetState)
              {
                case DemoFOTAUpdateWorkflowEngine_restarting__state:
                {
                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);
                  break;
                }
                case DemoFOTAUpdateWorkflowEngine_connected__state:
                {
                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
                  break;
                }
                default: {
                  break;
                }
              }
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
            break;
          }
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;
            break;
          }
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_restarting__state:
    {
      switch (event)
      {
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_activating__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            validateFirmwareUpdateActivation();
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) 
            {
              
            }
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:
        {
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED) 
          {
            
            bool __transitionResult = true;
            
            
            saveState(DemoFOTAUpdateWorkflowEngine_idle__state);
            if (!fotahub_confirmFirmwareUpdate(&instance->updateInfo)) 
            {
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) 
            {
              
              instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
              DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
            break;
          }
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_FAILED) 
          {
            
            bool __transitionResult = true;
            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;
            
            
            saveState(DemoFOTAUpdateWorkflowEngine_reverting__state);
            if (!fotahub_revertFirmwareUpdate(&instance->updateInfo)) 
            {
              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);
              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) 
            {
              
              instance->__currentState = __targetState;
              switch (__targetState)
              {
                case DemoFOTAUpdateWorkflowEngine_restarting__state:
                {
                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);
                  break;
                }
                case DemoFOTAUpdateWorkflowEngine_connected__state:
                {
                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
                  break;
                }
                default: {
                  break;
                }
              }
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_reverting__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            validateFirmwareUpdateReversion();
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_reverting__state) 
            {
              
            }
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:
        {
          
          
          saveState(DemoFOTAUpdateWorkflowEngine_idle__state);
          
          
          instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
          DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    default: {
      break;
    }
  }
  return true;
}

static inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)
{
  printf(""Ready for firmware over-the-air update\n"");
}

static inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)
{
  printf(""Waiting for restart\n"");
}
",48,1484,4053
"#include ""user_config.h""
#include ""WiFiStationDrv.h""
#include ""UARTDrv.h""
#include ""UserLoopDrv.h""
#include ""BlinkDrv.h""
#include ""MultiPartitionDemoFirmwareUpdateInfoSerialReader.h""
#include ""DemoFOTAUpdateWorkflow.h""
#include ""DemoProductInfo.h""
#include ""FotaHub.h""

#include ""user_loop.h""
#include ""user_pre_init_default.h""

void ICACHE_FLASH_ATTR user_init(void)
{
  one_uart_init(UART_UNIT, UART_BAUDRATE);
  
  os_printf(""\n--------------------------------------------------------------------------\n"");
  os_printf(""Running %s %s firmware from partition %d\n"", ((char *)(DEMO_PRODUCT_NAME)), ((char *)(DEMO_PRODUCT_FIRMWARE_VERSION)), system_upgrade_userbin_check() + 1);
  os_printf(""--------------------------------------------------------------------------\n\n"");
  
  userLoop_init();
  blink_init(USER_LOOP_INTERVAL, BLINK_PERIOD);
  
  firmwareUpdateInfoReader_init();
  fotaUpdateWorkflow_init();
  fotahub_init(((char *)(DEMO_PRODUCT_ID)), ((char *)(DEMO_PRODUCT_NAME)), &ESP8266_FOTA_UPDATE_CLIENT_CONFIG, 0xFAu);
  
  wifiStation_connect(((char *)(WIFI_STATION_SSID)), ((char *)(WIFI_STATION_PASSWORD)));
}

void ICACHE_FLASH_ATTR user_loop(void)
{
  firmwareUpdateInfoReader_run();
  fotahub_run();
  blink_run();
}
",48,1485,473
"#include ""WiFiStationDrv.h""

#include ""FotaHub.h""



static void ICACHE_FLASH_ATTR wifiEventHandlerCallback(System_Event_t *sys_evt);

bool ICACHE_FLASH_ATTR wifiStation_connect(char const *ssid, char const *password)
{
  wifi_set_event_handler_cb(&wifiEventHandlerCallback);
  
  uint8_t currentMode = wifi_get_opmode();
  currentMode = ((currentMode |= (STATION_MODE)));
  currentMode = ((currentMode &= ~(SOFTAP_MODE)));
  if (!wifi_set_opmode_current(currentMode)) 
  {
    os_printf(""Failed to activate Wi-Fi station mode\n"");
    return false;
  }
  
  struct station_config config = { 0 };
  size_t ssidLen = os_strlen(ssid);
  os_memcpy(config.ssid, ssid, ssidLen);
  if (ssidLen < sizeof(config.ssid)) 
  {
    config.ssid[ssidLen] = 0;
  }
  size_t passwordLen = os_strlen(password);
  os_memcpy(config.password, password, passwordLen);
  if (passwordLen < sizeof(config.password)) 
  {
    config.password[passwordLen] = 0;
  }
  if (!wifi_station_set_config_current(&config)) 
  {
    os_printf(""Failed to set Wi-Fi station configuration\n"");
    return false;
  }
  
  
  wifi_station_connect();
  return true;
}

static void ICACHE_FLASH_ATTR wifiEventHandlerCallback(System_Event_t *sys_evt)
{
  switch (sys_evt->event)
  {
    case EVENT_STAMODE_CONNECTED:
    {
      
      break;
    }
    case EVENT_STAMODE_DISCONNECTED:
    {
      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_DISCONNECTED);
      break;
    }
    case EVENT_STAMODE_AUTHMODE_CHANGE:
    {
      
      break;
    }
    case EVENT_STAMODE_GOT_IP:
    {
      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);
      break;
    }
    case EVENT_STAMODE_DHCP_TIMEOUT:
    {
      os_printf(""Failed to obtain Wi-Fi station IP address\n"");
      break;
    }
    case EVENT_SOFTAPMODE_PROBEREQRECVED:
    {
      
      break;
    }
    case EVENT_OPMODE_CHANGED:
    {
      
      break;
    }
    default: {
      os_printf(""Unexpected Wi-Fi event encountered: %d\n"", sys_evt->event);
      break;
    }
  }
}
",48,1486,784
"#include ""SinglePartitionDemoFirmwareUpdateInfoFileReader.h""

#include ""BinHexConverter.h""
#include ""DemoProductInfo.h""
#include ""FotaHub.h""



#include ""ctype.h""


static bool isWhitespace(char *str);

static char *separator(void);

static bool createFirmwareUpdateInfoFile(void);

static bool canOpenFirmwareUpdateInfoFile(void);

static void openFirmwareUpdateInfoFile(void);

static bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize);

static bool parseFirmwareUpdateInfo(char *updateInfoString);

static char lastUpdateInfoString[260 + 1] = { 0 };

static char updateVersion[MAX_UPDATE_VERSION_LENGTH + 1] = { 0 };

static uint8_t *updateVerificationData = NULL;

static bool isWhitespace(char *str)
{
  size_t idx = 0;
  char currentChr = str[idx++];
  while (currentChr != '\0')
  {
    if (isspace(currentChr) == 0) 
    {
      return false;
    }
    currentChr = str[idx++];
  }
  return true;
}

static char *separator(void)
{
  char *os = getenv(""OS"");
  if (os != NULL && strcmp(os, ""Windows_NT"") == 0) 
  {
    return ""\\"";
  }
  else
  {
    return ""/"";
  }
}

void firmwareUpdateInfoReader_init(void)
{
  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);
  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));
  memset(updateVerificationData, 0, updateVerificationDataSize);
  
  
  if (!createFirmwareUpdateInfoFile()) 
  {
    return;
  }
  
  if (canOpenFirmwareUpdateInfoFile()) 
  {
    openFirmwareUpdateInfoFile();
  }
}

void firmwareUpdateInfoReader_explain(char *programDir)
{
  
  char *sep = (strlen(programDir) > 0) ? (separator()) : ("""");
  printf(""Waiting for firmware update info to be entered and saved in '%s%s%s' file\n(if this file has not been opened automatically already, just open it manually in an editor of your choice)\n"", programDir, sep, DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);
  printf(""Expected firmware update info format: <new-version>:<checksum-or-signature> (e.g., 1.1:8639e6e80b089338e51fac17d5faa647c4c05368e46af5c42583fb34c0) \n"");
}

void firmwareUpdateInfoReader_run(void)
{
  
  char updateInfoString[260 + 1] = """";
  if (!loadFirmwareUpdateInfoFile(updateInfoString, sizeof(updateInfoString))) 
  {
    memset(lastUpdateInfoString, 0, sizeof(lastUpdateInfoString));
    return;
  }
  
  
  if (strncmp(updateInfoString, lastUpdateInfoString, 260) == 0) 
  {
    return;
  }
  strncpy(lastUpdateInfoString, updateInfoString, 260);
  
  
  if (!parseFirmwareUpdateInfo(updateInfoString)) 
  {
    return;
  }
  
  
  printf(""Firmware update request towards version %s received\n"", updateVersion);
  fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);
}

static bool createFirmwareUpdateInfoFile(void)
{
  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, ""wb"");
  if (updateInfoFile == NULL) 
  {
    printf(""Failed to create %s: %s (error code: %i)\n"", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, strerror(errno), errno);
    return false;
  }
  fclose(updateInfoFile);
  return true;
}

static bool canOpenFirmwareUpdateInfoFile(void)
{
  
  char *os = getenv(""OS"");
  char command[260 + 1] = """";
  if (os != NULL && strcmp(os, ""Windows_NT"") == 0) 
  {
    snprintf(command, sizeof(command), ""powershell -command \""where.exe code | Measure-Object -Line | Select-Object -ExpandProperty Lines\"""");
  }
  else
  {
    snprintf(command, sizeof(command), ""which code | wc -l"");
  }
  
  
  FILE *commandPipe = popen(command, ""r"");
  if (commandPipe == NULL) 
  {
    printf(""Failed to run '%s' command: %s (error code: %i)\n"", command, strerror(errno), errno);
    return false;
  }
  
  
  int32_t count = 0;
  if (fscanf(commandPipe, ""%d"", &count) != 1) 
  {
    pclose(commandPipe);
    return false;
  }
  pclose(commandPipe);
  return count > 0;
}

static void openFirmwareUpdateInfoFile(void)
{
  
  char command[260 + 1] = """";
  snprintf(command, sizeof(command), ""code %s"", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);
  system(command);
}

static bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize)
{
  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, ""r"");
  if (updateInfoFile == NULL) 
  {
    
    return false;
  }
  memset(updateInfoString, 0, updateInfoStringSize);
  while (isWhitespace(updateInfoString))
  {
    if (fgets(updateInfoString, ((int32_t) updateInfoStringSize), updateInfoFile) == NULL) 
    {
      
      fclose(updateInfoFile);
      return false;
    }
  }
  fclose(updateInfoFile);
  return true;
}

static bool parseFirmwareUpdateInfo(char *updateInfoString)
{
  
  memset(updateVersion, 0, sizeof(updateVersion));
  memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
  if (strstr(updateInfoString, UPDATE_INFO_SEPARATOR) == NULL) 
  {
    printf(""Firmware update request with missing version and/or verification data entered\n"");
    return false;
  }
  
  
  char *parsedVersion = strtok(updateInfoString, UPDATE_INFO_DELIMITERS);
  if (parsedVersion == NULL) 
  {
    printf(""Firmware update request with missing version and verification data entered\n"");
    return false;
  }
  if (strlen(parsedVersion) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) 
  {
    printf(""Received firmware update version too long (max. length = %hhu)\n"", MAX_UPDATE_VERSION_LENGTH);
    return false;
  }
  strncpy(updateVersion, parsedVersion, sizeof(updateVersion));
  
  
  char *parsedVerificationData = strtok(NULL, UPDATE_INFO_DELIMITERS);
  if (parsedVerificationData == NULL) 
  {
    printf(""Firmware update request with missing version or verification data entered\n"");
    memset(updateVersion, 0, sizeof(updateVersion));
    return false;
  }
  if (strlen(parsedVerificationData) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) 
  {
    printf(""Received firmware update verification data too long (max. length = %hhu)\n"", MAX_UPDATE_VERSION_LENGTH << 1);
    memset(updateVersion, 0, sizeof(updateVersion));
    return false;
  }
  if (convertHexString8ToBinData(parsedVerificationData, strlen(parsedVerificationData), updateVerificationData, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) == 0) 
  {
    printf(""Firmware update request with invalid verification data entered\n"");
    memset(updateVersion, 0, sizeof(updateVersion));
    memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));
    return false;
  }
  
  return true;
}

void fotahub_onProvideFirmwareUpdateVerificationInfo(FirmwareUpdateInfo_t const *pUpdateInfo, FOTAUpdateVerificationAlgorithm_t *pVerificationAlgorithm, uint8_t const  **ppVerificationData)
{
  *pVerificationAlgorithm = DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM;
  *ppVerificationData = updateVerificationData;
}
",48,1487,2464
"#include ""WiFiStationDrv.h""

#include ""FotaHub.h""
#include ""esp_event_loop.h""
#include ""esp_wifi.h""


static esp_err_t wifiEventHandlerCallback(void *ctx, system_event_t *event);

void wifi_init(void)
{
  tcpip_adapter_init();
  esp_event_loop_init(&wifiEventHandlerCallback, NULL);
  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
  esp_wifi_init(&cfg);
  esp_wifi_set_mode(WIFI_MODE_STA);
  esp_wifi_set_storage(WIFI_STORAGE_RAM);
}

bool wifiStation_connect(char const *ssid, char const *passphrase)
{
  wifi_config_t config = 
  {
    .sta = 
    {
      .bssid_set = false
    }
  };
  size_t ssidLen = strlen(ssid);
  memcpy(config.sta.ssid, ssid, ssidLen);
  if (ssidLen < sizeof(config.sta.ssid)) 
  {
    config.sta.ssid[ssidLen] = 0;
  }
  size_t passphraseLen = strlen(passphrase);
  memcpy(config.sta.password, passphrase, passphraseLen);
  if (passphraseLen < sizeof(config.sta.password)) 
  {
    config.sta.password[passphraseLen] = 0;
  }
  
  esp_wifi_set_config(WIFI_IF_STA, &config);
  esp_wifi_start();
  esp_wifi_connect();
  
  return true;
}

static esp_err_t wifiEventHandlerCallback(void *ctx, system_event_t *event)
{
  switch (event->event_id)
  {
    case SYSTEM_EVENT_STA_GOT_IP:
    {
      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);
      break;
    }
    case SYSTEM_EVENT_STA_LOST_IP:
    case SYSTEM_EVENT_STA_DISCONNECTED:
    case SYSTEM_EVENT_STA_STOP:
    case SYSTEM_EVENT_STA_DHCP_TIMEOUT:
    {
      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_DISCONNECTED);
      break;
    }
    default: {
      break;
    }
  }
  return ESP_OK;
}
",48,1488,684
"#include ""Main.h""

#include ""DemoFOTAUpdateSelfTest.h""
#include ""Configuration.h""
#include ""DemoFOTAUpdateWorkflow.h""
#include ""SinglePartitionDemoFirmwareUpdateInfoSerialReader.h""
#include ""BlinkDrv.h""
#include ""DemoProductInfo.h""
#include ""FotaHub.h""
#include ""freertos/FreeRTOS.h""
#include ""freertos/task.h""

void app_main(void)
{
  nvs_init();
  uart_init(UART_UNIT, &UART_CONFIG, UART_TX_PIN, UART_RX_PIN);
  blink_init(BLINK_PERIOD);
  wifi_init();
  
  printf(""\n--------------------------------------------------------------------------\n"");
  printf(""Running %s %s firmware\n"", DEMO_PRODUCT_NAME, DEMO_PRODUCT_FIRMWARE_VERSION);
  printf(""--------------------------------------------------------------------------\n\n"");
  
  firmwareUpdateInfoReader_init();
  fotaUpdateWorkflow_init();
  fotahub_init(DEMO_PRODUCT_ID, DEMO_PRODUCT_NAME, &ESP32_FOTA_UPDATE_CLIENT_CONFIG);
  
  wifiStation_connect(WIFI_STATION_SSID, WIFI_STATION_PASSPHRASE);
  
  xTaskCreate(&demoTasks,""demoTasks"",TASK_DEFAULT_STACK_SIZE * 5,NULL,10,NULL);
}

void demoTasks(void *args)
{
  while (true)
  {
    uart_recvTask();
    firmwareUpdateInfoReader_run();
    fotahub_run();
    blink_run();
    vTaskDelay(10);
  }
}
",48,1489,465
"#include ""DemoFOTAUpdateWorkflow.h""

#include ""DemoProductInfo.h""
#include ""DemoFOTAUpdateWorkflowPersistence.h""
#include ""DemoFOTAUpdateSelfTest.h""


enum DemoFOTAUpdateWorkflowEngine__inevents {
  DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event,
  DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event,
  DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event
};
typedef enum DemoFOTAUpdateWorkflowEngine__inevents DemoFOTAUpdateWorkflowEngine__inevents_t;

enum DemoFOTAUpdateWorkflowEngine__states {
  DemoFOTAUpdateWorkflowEngine_idle__state = 0,
  DemoFOTAUpdateWorkflowEngine_connected__state,
  DemoFOTAUpdateWorkflowEngine_downloading__state,
  DemoFOTAUpdateWorkflowEngine_restarting__state,
  DemoFOTAUpdateWorkflowEngine_activating__state,
  DemoFOTAUpdateWorkflowEngine_reverting__state
};
typedef enum DemoFOTAUpdateWorkflowEngine__states DemoFOTAUpdateWorkflowEngine__states_t;

struct DemoFOTAUpdateWorkflowEngine__data {
  DemoFOTAUpdateWorkflowEngine__states_t __currentState;
  FirmwareUpdateInfo_t updateInfo;
};
typedef struct DemoFOTAUpdateWorkflowEngine__data DemoFOTAUpdateWorkflowEngine__data_t;

static void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution);

static bool ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments);

static inline void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);

static inline void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);

static DemoFOTAUpdateWorkflowEngine__data_t updateWorkflowEngine;

void ICACHE_FLASH_ATTR fotaUpdateWorkflow_init(void)
{
  DemoFOTAUpdateWorkflowEngine__init(&updateWorkflowEngine, false);
}

void ICACHE_FLASH_ATTR fotahub_onConnectionStatusChanged(ConnectionStatus_t status)
{
  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;
  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);
}

void ICACHE_FLASH_ATTR fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)
{
  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;
  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);
}

void ICACHE_FLASH_ATTR fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)
{
  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;
  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };
  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);
}

static void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution)
{
  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;
  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;
  instance->updateInfo.version = NULL;
  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;
  if (!postponeInitialExecution) 
  {
    instance->__currentState = loadState();
    switch (instance->__currentState)
    {
      case DemoFOTAUpdateWorkflowEngine_connected__state:
      {
        DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
        break;
      }
      case DemoFOTAUpdateWorkflowEngine_restarting__state:
      {
        DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);
        break;
      }
      default: {
        break;
      }
    }
  }
}

static bool ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)
{
  switch (instance->__currentState)
  {
    case DemoFOTAUpdateWorkflowEngine_idle__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:
        {
          
          os_printf(""Cannot handle firmware over-the-air update request (missing network connection)\n"");
          
          
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_connected__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:
        {
          if (os_strcmp((*((char **)((arguments[0])))), ((char *)(DEMO_PRODUCT_FIRMWARE_VERSION))) != 0) 
          {
            
            bool __transitionResult = true;
            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;
            
            
            instance->updateInfo.version = (*((char **)((arguments[0]))));
            
            
            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) 
            {
              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) 
            {
              
              instance->__currentState = __targetState;
              switch (__targetState)
              {
                case DemoFOTAUpdateWorkflowEngine_connected__state:
                {
                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
                  break;
                }
                default: {
                  break;
                }
              }
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
            break;
          }
          if (os_strcmp((*((char **)((arguments[0])))), ((char *)(DEMO_PRODUCT_FIRMWARE_VERSION))) == 0) 
          {
            
            os_printf(""Ignoring firmware over-the-air update request to version %s as this version is already running\n"", (*((char **)((arguments[0])))));
            
            
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_downloading__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:
        {
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) 
          {
            
            bool __transitionResult = true;
            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;
            
            
            saveState(DemoFOTAUpdateWorkflowEngine_activating__state);
            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) 
            {
              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);
              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) 
            {
              
              instance->__currentState = __targetState;
              switch (__targetState)
              {
                case DemoFOTAUpdateWorkflowEngine_restarting__state:
                {
                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);
                  break;
                }
                case DemoFOTAUpdateWorkflowEngine_connected__state:
                {
                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
                  break;
                }
                default: {
                  break;
                }
              }
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
            break;
          }
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;
            break;
          }
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) 
          {
            
            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_restarting__state:
    {
      switch (event)
      {
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_activating__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            validateFirmwareUpdateActivation();
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) 
            {
              
            }
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:
        {
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED) 
          {
            
            bool __transitionResult = true;
            
            
            saveState(DemoFOTAUpdateWorkflowEngine_idle__state);
            if (!fotahub_confirmFirmwareUpdate(&instance->updateInfo)) 
            {
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) 
            {
              
              instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
              DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
            break;
          }
          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_FAILED) 
          {
            
            bool __transitionResult = true;
            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;
            
            
            saveState(DemoFOTAUpdateWorkflowEngine_reverting__state);
            if (!fotahub_revertFirmwareUpdate(&instance->updateInfo)) 
            {
              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);
              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;
              __transitionResult = false;
            }
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) 
            {
              
              instance->__currentState = __targetState;
              switch (__targetState)
              {
                case DemoFOTAUpdateWorkflowEngine_restarting__state:
                {
                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);
                  break;
                }
                case DemoFOTAUpdateWorkflowEngine_connected__state:
                {
                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
                  break;
                }
                default: {
                  break;
                }
              }
            }
            
            if (!__transitionResult) 
            {
              return false;
            }
          }
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    case DemoFOTAUpdateWorkflowEngine_reverting__state:
    {
      switch (event)
      {
        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:
        {
          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) 
          {
            
            validateFirmwareUpdateReversion();
            
            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_reverting__state) 
            {
              
            }
          }
          break;
        }
        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:
        {
          
          
          saveState(DemoFOTAUpdateWorkflowEngine_idle__state);
          
          
          instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;
          DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);
          break;
        }
        default: {
          break;
        }
      }
      break;
    }
    default: {
      break;
    }
  }
  return true;
}

static inline void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)
{
  os_printf(""Ready for firmware over-the-air update\n"");
}

static inline void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)
{
  os_printf(""Waiting for restart\n"");
}
",48,1490,4181
"#include ""user_config.h""
#include ""WiFiStationDrv.h""
#include ""UARTDrv.h""
#include ""UserLoopDrv.h""
#include ""BlinkDrv.h""
#include ""MultiPartitionDemoFirmwareUpdateInfoSerialReader.h""
#include ""DemoFOTAUpdateWorkflow.h""
#include ""DemoFOTAUpdateSelfTest.h""
#include ""DemoProductInfo.h""
#include ""FotaHub.h""

#include ""user_loop.h""
#include ""user_pre_init_default.h""

void ICACHE_FLASH_ATTR user_init(void)
{
  one_uart_init(UART_UNIT, UART_BAUDRATE);
  
  os_printf(""\n--------------------------------------------------------------------------\n"");
  os_printf(""Running %s %s firmware from partition %d\n"", ((char *)(DEMO_PRODUCT_NAME)), ((char *)(DEMO_PRODUCT_FIRMWARE_VERSION)), system_upgrade_userbin_check() + 1);
  os_printf(""--------------------------------------------------------------------------\n\n"");
  
  userLoop_init();
  blink_init(USER_LOOP_INTERVAL, BLINK_PERIOD);
  
  firmwareUpdateInfoReader_init();
  fotaUpdateWorkflow_init();
  fotaUpdateSelfTest_init();
  fotahub_init(((char *)(DEMO_PRODUCT_ID)), ((char *)(DEMO_PRODUCT_NAME)), &ESP8266_FOTA_UPDATE_CLIENT_CONFIG, 0xFAu);
  
  wifiStation_connect(((char *)(WIFI_STATION_SSID)), ((char *)(WIFI_STATION_PASSWORD)));
}

void ICACHE_FLASH_ATTR user_loop(void)
{
  firmwareUpdateInfoReader_run();
  fotahub_run();
  blink_run();
}
",48,1491,497
"#include ""Main.h""

#include ""Configuration.h""
#include ""DemoFOTAUpdateWorkflow.h""
#include ""SinglePartitionDemoFirmwareUpdateInfoFileReader.h""
#include ""DemoProductInfo.h""
#include ""FotaHub.h""




int32_t main(int32_t argc, char *argv[])
{
  
  char *programDir = dirname(strdup(argv[0]));
  chdir(programDir);
  
  firmwareUpdateInfoReader_init();
  fotaUpdateWorkflow_init();
  fotahub_init(argv[0], DEMO_PRODUCT_ID, DEMO_PRODUCT_NAME, &FOTA_UPDATE_CLIENT_CONFIG);
  
  printf(""\n--------------------------------------------------------------------------\n"");
  printf(""Running %s %s firmware\n"", DEMO_PRODUCT_NAME, DEMO_PRODUCT_FIRMWARE_VERSION);
  printf(""--------------------------------------------------------------------------\n\n"");
  
  
  fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);
  
  char *separator = (strlen(programDir) > 0) ? (""/"") : ("""");
  printf(""Waiting for firmware update info (<new-version>:<checksum-or-signature>) to be entered and saved in '%s%s%s' file\n"", programDir, separator, DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);
  
  while (true)
  {
    firmwareUpdateInfoReader_run();
    fotahub_run();
  }
}
",48,1492,408
"#include ""BinHexConverter.h""




static inline char ICACHE_FLASH_ATTR convertBinValueToHexDigit(uint8_t value, bool upperCase);

static inline char ICACHE_FLASH_ATTR convertBinValueToHexDigit(uint8_t value, bool upperCase)
{
  char hexA = (upperCase) ? ('A') : ('a');
  return ((char)((value < 10) ? ('0' + value) : (hexA + value - 10)));
}

uint8_t ICACHE_FLASH_ATTR convertHexDigitToBinValue(char inputChr)
{
  if (inputChr >= '0' && inputChr <= '9') 
  {
    return ((uint8_t)(inputChr - '0'));
  }
  else if (inputChr >= 'a' && inputChr <= 'f') {
    return 10 + ((uint8_t)(inputChr - 'a'));
  }
  else if (inputChr >= 'A' && inputChr <= 'F') {
    return 10 + ((uint8_t)(inputChr - 'A'));
  }
  return 0;
}

size_t ICACHE_FLASH_ATTR convertBinValueToHexString8(uint8_t inputValue, char *outputStr, size_t outputStrSize, bool upperCase)
{
  if (outputStrSize < 2) 
  {
    return 0;
  }
  outputStr[0] = convertBinValueToHexDigit(((inputValue & 0xF0u) >> 4), upperCase);
  outputStr[1] = convertBinValueToHexDigit((inputValue & 0x0Fu), upperCase);
  return 2;
}

uint8_t ICACHE_FLASH_ATTR convertHexString8ToBinValue(char *inputStr, size_t inputStrLength)
{
  if (inputStrLength != 2) 
  {
    return 0;
  }
  uint8_t outputValue = convertHexDigitToBinValue(inputStr[0]) << 4;
  outputValue |= convertHexDigitToBinValue(inputStr[1]);
  return outputValue;
}

size_t ICACHE_FLASH_ATTR convertBinDataToHexString8(uint8_t *inputData, size_t inputDataSize, char *outputStr, size_t outputStrSize, bool upperCase)
{
  if (outputStrSize < inputDataSize * 2) 
  {
    return 0;
  }
  outputStr[0] = '\0';
  size_t count = 0;
  for ( size_t i = 0 ; i < inputDataSize; i++ )
  {
    count += convertBinValueToHexString8(inputData[i], outputStr + 2 * i, outputStrSize - count, upperCase);
  }
  if (outputStrSize > count) 
  {
    outputStr[count++] = '\0';
  }
  return count;
}

size_t ICACHE_FLASH_ATTR convertHexString8ToBinData(char *inputStr, size_t inputStrLength, uint8_t *pOutputData, size_t outputDataSize)
{
  if (outputDataSize < inputStrLength >> 1) 
  {
    return 0;
  }
  if ((inputStrLength & 0x01u) != 0) 
  {
    return 0;
  }
  os_memset(pOutputData, 0x00u, outputDataSize);
  for ( size_t i = 0 ; i < inputStrLength; i = i + 2 )
  {
    pOutputData[i >> 1] = convertHexString8ToBinValue(inputStr + i, 2);
  }
  return inputStrLength >> 1;
}
",48,1493,978
"#include ""BinHexConverter.h""




static inline char convertBinValueToHexDigit(uint8_t value, bool upperCase);

static inline char convertBinValueToHexDigit(uint8_t value, bool upperCase)
{
  char hexA = (upperCase) ? ('A') : ('a');
  return ((char)((value < 10) ? ('0' + value) : (hexA + value - 10)));
}

uint8_t convertHexDigitToBinValue(char inputChr)
{
  if (inputChr >= '0' && inputChr <= '9') 
  {
    return ((uint8_t)(inputChr - '0'));
  }
  else if (inputChr >= 'a' && inputChr <= 'f') {
    return 10 + ((uint8_t)(inputChr - 'a'));
  }
  else if (inputChr >= 'A' && inputChr <= 'F') {
    return 10 + ((uint8_t)(inputChr - 'A'));
  }
  return 0;
}

size_t convertBinValueToHexString8(uint8_t inputValue, char *outputStr, size_t outputStrSize, bool upperCase)
{
  if (outputStrSize < 2) 
  {
    return 0;
  }
  outputStr[0] = convertBinValueToHexDigit(((inputValue & 0xF0u) >> 4), upperCase);
  outputStr[1] = convertBinValueToHexDigit((inputValue & 0x0Fu), upperCase);
  return 2;
}

uint8_t convertHexString8ToBinValue(char *inputStr, size_t inputStrLength)
{
  if (inputStrLength != 2) 
  {
    return 0;
  }
  uint8_t outputValue = convertHexDigitToBinValue(inputStr[0]) << 4;
  outputValue |= convertHexDigitToBinValue(inputStr[1]);
  return outputValue;
}

size_t convertBinDataToHexString8(uint8_t *inputData, size_t inputDataSize, char *outputStr, size_t outputStrSize, bool upperCase)
{
  if (outputStrSize < inputDataSize * 2) 
  {
    return 0;
  }
  outputStr[0] = '\0';
  size_t count = 0;
  for ( size_t i = 0 ; i < inputDataSize; i++ )
  {
    count += convertBinValueToHexString8(inputData[i], outputStr + 2 * i, outputStrSize - count, upperCase);
  }
  if (outputStrSize > count) 
  {
    outputStr[count++] = '\0';
  }
  return count;
}

size_t convertHexString8ToBinData(char *inputStr, size_t inputStrLength, uint8_t *pOutputData, size_t outputDataSize)
{
  if (outputDataSize < inputStrLength >> 1) 
  {
    return 0;
  }
  if ((inputStrLength & 0x01u) != 0) 
  {
    return 0;
  }
  memset(pOutputData, 0x00u, outputDataSize);
  for ( size_t i = 0 ; i < inputStrLength; i = i + 2 )
  {
    pOutputData[i >> 1] = convertHexString8ToBinValue(inputStr + i, 2);
  }
  return inputStrLength >> 1;
}
",48,1494,913
"#include ""DemoFOTAUpdateWorkflowFilePersistence.h""

#include ""DemoFOTAUpdateWorkflowPersistence.h""

void saveState(int16_t state)
{
  FILE *file = fopen(DEMO_PRODUCT_UPDATE_STATE_FILE_NAME, ""wb"");
  if (file == NULL) 
  {
    printf(""Failed to open %s for writing\n"", DEMO_PRODUCT_UPDATE_STATE_FILE_NAME);
    return;
  }
  if (fwrite(&state, sizeof(state), 1, file) != 1) 
  {
    printf(""Failed to write statemachine state %hi to %s\n"", state, DEMO_PRODUCT_UPDATE_STATE_FILE_NAME);
    fclose(file);
    return;
  }
  fclose(file);
}

int16_t loadState(void)
{
  FILE *file = fopen(DEMO_PRODUCT_UPDATE_STATE_FILE_NAME, ""rb"");
  if (file == NULL) 
  {
    return 0;
  }
  int16_t state = 0;
  if (fread(&state, sizeof(state), 1, file) != 1) 
  {
    fclose(file);
    return 0;
  }
  fclose(file);
  return state;
}
",48,1495,340
"#include ""DemoFOTAUpdateSelfTest.h""

#include ""FotaHub.h""



static bool runRandomSelfTest(uint8_t successRate);

void fotaUpdateSelfTest_init(void)
{
  srand(((uint32_t)(time(NULL))));
}

static bool runRandomSelfTest(uint8_t successRate)
{
  if (((uint8_t)((rand() % 100))) >= (successRate)) 
  {
    printf(""Firmware self test failed (reason: simulated pseudo-random failure)\n"");
    return false;
  }
  return true;
}

void validateFirmwareUpdateActivation(void)
{
  printf(""Validating firmware update\n"");
  
  if (runRandomSelfTest(SIMULATED_ACTIVATION_SUCCESS_RATE)) 
  {
    printf(""Firmware update successfully activated\n"");
    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED);
  }
  else
  {
    printf(""Firmware update activation failed\n"");
    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_ACTIVATION_FAILED);
  }
}

void validateFirmwareUpdateReversion(void)
{
  printf(""Validating previous firmware\n"");
  
  if (runRandomSelfTest(SIMULATED_REVERSION_SUCCESS_RATE)) 
  {
    printf(""Firmware update successfully reverted\n"");
    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_REVERSION_SUCCEEDED);
  }
  else
  {
    printf(""Firmware update reversion failed\n"");
    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_REVERSION_FAILED);
  }
}
",48,1496,480
"#include ""WiFiHelper.h""

static esp_err_t setMode(wifi_mode_t mode, bool enable);

esp_err_t enableStationMode(void)
{
  return setMode(WIFI_MODE_STA, true);
}

esp_err_t disableStationMode(void)
{
  return setMode(WIFI_MODE_STA, false);
}

esp_err_t enableAccessPointMode(void)
{
  return setMode(WIFI_MODE_AP, true);
}

esp_err_t disableAccessPointMode(void)
{
  return setMode(WIFI_MODE_AP, false);
}

static esp_err_t setMode(wifi_mode_t mode, bool enable)
{
  wifi_mode_t currentMode;
  esp_err_t error = ESP_OK;
  
  esp_wifi_get_mode(&currentMode);
  printf(""Old wifi mode: %u\n"", ((uint32_t)((currentMode))));
  
  bool isEnabled = (currentMode & mode) != 0;
  if (isEnabled != enable) 
  {
    if (enable) 
    {
      error = esp_wifi_set_mode(((wifi_mode_t)((currentMode | mode))));
    }
    else
    {
      wifi_mode_t nextMode = ((wifi_mode_t)((currentMode & (~mode))));
      if (nextMode == WIFI_MODE_NULL) 
      {
        
        esp_wifi_set_mode(WIFI_MODE_NULL);
        error = esp_wifi_stop();
      }
      else
      {
        error = esp_wifi_set_mode(nextMode);
      }
    }
  }
  return error;
}

bool getIPConfig(IPConfig_t *pIPConfig, wifi_mode_t mode)
{
  if (pIPConfig == NULL) 
  {
    return false;
  }
  tcpip_adapter_ip_info_t info;
  if (tcpip_adapter_get_ip_info((mode == WIFI_MODE_AP) ? (TCPIP_ADAPTER_IF_AP) : (TCPIP_ADAPTER_IF_STA), &info) == ESP_OK) 
  {
    pIPConfig->localIPAddress = info.ip.addr;
    pIPConfig->gatewayIPAddress = info.gw.addr;
    pIPConfig->subnetMask = info.netmask.addr;
    return true;
  }
  return false;
}
",48,1497,646
"#include ""Main.h""

#include ""Configuration.h""
#include ""DemoFOTAUpdateWorkflow.h""
#include ""SinglePartitionDemoFirmwareUpdateInfoFileReader.h""
#include ""DemoFOTAUpdateWorkflowFilePersistence.h""
#include ""DemoFOTAUpdateSelfTest.h""
#include ""DemoProductInfo.h""
#include ""FotaHub.h""




static char *dirname(char *path);

int32_t main(int32_t argc, char *argv[])
{
  
  char *programDir = dirname(_strdup(argv[0]));
  _chdir(programDir);
  
  printf(""\n--------------------------------------------------------------------------\n"");
  printf(""Running %s %s firmware\n"", DEMO_PRODUCT_NAME, DEMO_PRODUCT_FIRMWARE_VERSION);
  printf(""--------------------------------------------------------------------------\n\n"");
  
  firmwareUpdateInfoReader_init();
  fotaUpdateWorkflow_init();
  fotaUpdateSelfTest_init();
  fotahub_init(argv[0], DEMO_PRODUCT_ID, DEMO_PRODUCT_NAME, &FOTA_UPDATE_CLIENT_CONFIG);
  
  fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);
  
  firmwareUpdateInfoReader_explain(programDir);
  
  while (true)
  {
    firmwareUpdateInfoReader_run();
    fotahub_run();
  }
}

static char *dirname(char *path)
{
  char *lastSeparator = strrchr(path, '\\');
  if (lastSeparator != NULL) 
  {
    *lastSeparator = '\0';
    return path;
  }
  else
  {
    *path = '\0';
  }
  return path;
}
",48,1498,471
"#define eps (1.0e-11)
#define f(x) (x*x*2-8)
#define df(x) (x*4)

int main(){
    FILE *gp;
    double xn, xo;
    int i=0, max=100;

    gp = popen(""gnuplot -persist"", ""w"");
    fprintf(gp, ""set yrange [-100: 1000]\n"");
    fprintf(gp, ""set xrange [-10: 60]\n"");
    fprintf(gp, ""plot x*x*2-8, 0\n"");
    xo = (xn = 20) + 1;
    while(fabs(xn - xo) > eps && i < max){
        xo = xn;
        xn = xo - f(xo)/df(xo);
        fprintf(gp, ""replot (%lf*4)*(x-%lf) + (%lf*%lf*2-8)\n"", xo, xo, xo, xo);
        i++;
        printf(""[round:%2d], x = %.10lf\n"", i, xo);
    }
    pclose(gp);
    if(i == max) printf(""Not found answer.\n"");
    else printf(""%.10lf\n"", xo);
    return 0;
}
",49,1499,360
"void Create(){
    FILE *rf;
    double sum, a, kakuritu[27];
    int i = 0, n;

    srand(time(NULL));
    rf = fopen(""probability.txt"", ""r"");
    while( ! feof(rf)){
        fscanf(rf, ""%lf\n"", &kakuritu[i]);
        i++;
    }
    for(i = 0; i < 100; i++){
        a = (rand() % 1000000 + 1);
        a /= 1000000;
        for(sum = n = 0; sum < 1; n++){
            sum += kakuritu[n];
            if(a < sum){
                if(n == 26){
                    printf(""%c"", 0x20);
                    break;
                }else{
                    printf(""%c"", n+65);
                    break;
                }
            }
        }
    }
    printf(""\n"");
}

int main(){
    Create();
    return 0;
}
",49,1500,276
"double dist(double x1, double y1, double x2, double y2);


int main(){
 double a, b, c, d, e, f;
 double z[3], k, o, p, q;
 int i, j;
 printf(""3ç¹ã®åº§æ¨ãå¥åãã¦ä¸ãã\n"");
 printf(""1ã¤ãã®åº§æ¨:"");
 scanf(""%lf%lf"", &a, &b);
 printf(""2ã¤ãã®åº§æ¨:"");
 scanf(""%lf%lf"", &c, &d);
 printf(""3ã¤ãã®åº§æ¨:"");
 scanf(""%lf%lf"", &e, &f);
 

 z[0]=dist(a, b, c, d);
 z[1]=dist(c, d, e, f);
 z[2]=dist(e, f, a, b);

 for(i=0; i<3; i++){
  for(j=0; j<3; j++){
   if(z[i]<z[j]){
    k=z[i];
    z[i]=z[j];
    z[j]=k;
   }
  }
 }

 if(z[0]+z[1]>z[2] && z[1]+z[2]>z[0] && z[2]+z[0]>z[1]){
  printf(""3ã¤ã®è¾ºã®é·ãã¯\n"");
  o=z[0];
  p=z[1];
  q=z[2];

  printf(""a=%.2f\nb=%.2f\nc=%.2f\n"", o, p, q);
  printf(""ãã®3è¾ºã§çµã°ããå³å½¢ã¯"");

  if(o == p && o == q/sqrt(2)){
   printf(""ç´è§ä¸è§å½¢ã§ã\n""); 
   return 0; 
  }else if(sqrt(o*o+p*p) == q){
   printf(""ç´è§ä¸è§å½¢ã§ã\n""); 
   return 0; 
  }
   o*=o;
   p*=p;
   q*=q;
  
  if(q==o+p){
   printf(""ç´è§ä¸è§å½¢ã§ã\n"");
  }else if(q < o+p){
   printf(""é­è§ä¸è§å½¢ã§ã\n"");
  }else if(q > o+p){
   printf(""éè§ä¸è§å½¢ã§ã\n"");
  }
 }
 else{
  printf(""ä¸è§å½¢ã§ã¯ãªã\n"");
 }

 return 0;
}

double dist(double x1, double y1, double x2, double y2){
 double r;
 r=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
 return r;
}
",49,1501,893
"#define error 0.0000000001 
#define N 2 

int main(){
    double a[N][N] = { { 4.0, 2.0 }, { 4.0, 5.0 } };
    double b[N] = { 2.0, -7.0 };
    double x[N], y[N];
    int i, j, k;

    for( i = 0; i < N; i++ ) x[i]=1.0;
    for( i = 0; i < 30; i++ ){
        for( j = 0; j < N; j++ ){
            for( k = 0; k < N; k++ ) y[k] = x[k];
            x[j] = ( (a[j][j] * y[j]) + b[j] );
            for( k = 0; k < N; k++ ){
                x[j] -= ( a[j][k] * y[k] );
            }
            x[j] /= a[j][j];
        }
        printf(""[i=%2d]"", i+1 );
        for( j = 0; j < N; j++ ){
            printf("" x%d = %.10f "", j+1, x[j]);
        } 
        printf(""\n"");
    }
    return 0;
}
",49,1502,342
"int main(void) {
  
  float wait_time = 0.01;

  
  
  int barw = 20, barh = 150;
  
  int bardy = 50;
  
  int bar1x = 70, bar1y = DL_HEIGHT / 2;
  
  int bar1kup = 'w', bar1kdown = 's';
  
  int bar2x = DL_WIDTH - 70, bar2y = DL_HEIGHT / 2;
  
  int bar2kup = 'i', bar2kdown = 'k';

  
  
  int br = 15;
  
  int bvx = 5.0, bvy = 5.0;
  
  int bx = DL_WIDTH / 2, by = DL_HEIGHT / 2;

  
  int score1 = 0, score2 = 0;
  
  int sx = DL_WIDTH / 2 - 120, sy = 50;
  
  char sscore[] = ""   :   "";

  
  
  int t, k, x, y;
  
  dl_initialize(1.0);
  
  while (1) {
    
    while (dl_get_event(&t, &k, &x, &y)) {
      if (t == DL_EVENT_KEY) {
    if (k == bar1kup)
      bar1y -= bardy;
    else if (k == bar1kdown)
      bar1y += bardy;
    else if (k == bar2kup)
      bar2y -= bardy;
    else if (k == bar2kdown)
      bar2y += bardy;
      }
    }
    if (bar1y - barh / 2 < 0)
      bar1y = barh / 2;
    if (bar1y + barh / 2 > DL_HEIGHT)
      bar1y = DL_HEIGHT - barh / 2;
    if (bar2y - barh / 2 < 0)
      bar2y = barh / 2;
    if (bar2y + barh / 2 > DL_HEIGHT)
      bar2y = DL_HEIGHT - barh / 2;

    
    bx += bvx;
    if (bx - br <= 0 || bx + br >= DL_WIDTH) 
      bvx *= -1;
    by += bvy;
    if (by - br <= 0 || by + br >= DL_HEIGHT)
      bvy *= -1;

    
    if (by > bar1y - barh / 2 && by < bar1y + barh / 2) {
      if (bvx < 0 && bx - br <= bar1x + barw / 2 && bx - br >= bar1x - barw / 2) 
    bvx *= -1;
      if (bvx > 0 && bx + br >= bar1x - barw / 2 && bx + br <= bar1x + barw / 2)
    bvx *= -1;
    }
    if (by > bar2y - barh / 2 && by < bar2y + barh / 2) {
      if (bvx < 0 && bx - br <= bar2x + barw / 2 && bx - br >= bar2x - barw / 2) 
    bvx *= -1;
      if (bvx > 0 && bx + br >= bar2x - barw / 2 && bx + br <= bar2x + barw / 2)
    bvx *= -1;
    }

    
    if (bx - br <= 0) {
      score2++;
      bx = bar1x + barw + 1;
      by = bar1y;
      bvx = abs(bvx) + 0.1;
    }
    if (bx + br >= DL_WIDTH) {
      score1++;
      bx = bar2x - barw - 1;
      by = bar2y;
      bvx = -abs(bvx) - 0.1;
    }
    if(score1 > 999)
      score1 = 999;
    if(score2 > 999)
      score2 = 999;
    
    
    dl_stop();
    dl_clear(DL_C(""black""));
    
    dl_rectangle(bar1x - barw / 2, bar1y - barh / 2,
         bar1x + barw / 2, bar1y + barh / 2, DL_C(""red""), 1, 1);
    dl_rectangle(bar2x - barw / 2, bar2y - barh / 2,
         bar2x + barw / 2, bar2y + barh / 2, DL_C(""green""), 1, 1);
    
    dl_circle(bx, by, br, DL_C(""blue""), 1, 1);
    
    sprintf (sscore, ""%3d:%d"", score1, score2);
    dl_text (sscore, sx, sy, 2.0, DL_C(""white""), 2);
    
    dl_resume();

    dl_wait(wait_time);
  }

  return 0;
}
",49,1503,1375
"#define eps (1.0e-11)
#define f(x) (log(x)-1)
#define df(x) (1/x)

int main(){
    FILE *gp;
    double xn, xo;
    int i=0, max=100;

    gp = popen(""gnuplot -persist"", ""w"");
    fprintf(gp, ""set yrange [-2: 2]\n"");
    fprintf(gp, ""set xrange [0.5: 5]\n"");
    fprintf(gp, ""plot log(x)-1, 0\n"");
    xo = (xn = 1) + 1;
    while(fabs(xn - xo) > eps && i < max){
        xo = xn;
        xn = xo - f(xo)/df(xo);
        fprintf(gp, ""replot (1/%lf)*(x-%lf) + (log(%lf)-1)\n"", xo, xo, xo);
        i++;
        printf(""[round:%2d], x = %.10lf\n"", i, xo);
    }
    pclose(gp);
    if(i == max) printf(""Not found answer.\n"");
    else if(i == 1) printf(""Not found answer.\n"");
    else printf(""%.10lf\n"", xo);
    return 0;
}
",49,1504,359
"void dl_hexagon(int x, int y ,int z){

dl_line(15+x , 8+y , 25+x , 8+y ,DL_RGB(100-z,125,20+z),3);
dl_line(25+x , 8+y , 35+x , 16+y ,DL_RGB(100-z,125,20+z),3);
dl_line(35+x , 16+y , 25+x , 25+y ,DL_RGB(100-z,125,20+z),3);
dl_line(25+x , 25+y , 15+x, 25+y ,DL_RGB(100-z,125,20+z),3);
dl_line(15+x , 25+y , 5+x , 16+y ,DL_RGB(100-z,125,20+z),3);
dl_line(5+x , 16+y , 15+x , 8+y ,DL_RGB(100-z,125,20+z),3);

}

int main(void) {
    int i , q;

    dl_initialize(1.0);
  
    for (i = 0; i < 13; i++) {
                dl_hexagon(-i*i+400 , i*13 , i*30);
                dl_hexagon(i*i+150 , i*13 , i*30);
                dl_hexagon(-i*i+500 , i*13 , i*17);
                dl_hexagon(i*i+50 , i*13 , i*17);
                dl_circle(13*cos(M_PI/6*i)+150, 13*sin(M_PI/6*i)+300, 7, DL_RGB(200-i*15 , 200+i*i , 30*i*i), 1 , 1);
                dl_circle(29*cos(M_PI/6*i)+150, 29*sin(M_PI/6*i)+300, 10, DL_RGB(200-i*15 , 200+i*i , 30*i*i), 1 , 1);
                dl_circle(56*cos(M_PI/6*i)+150, 56*sin(M_PI/6*i)+300, 18, DL_RGB(200-i*15 , 200+i*i , 30*i*i), 1 , 1);
                dl_circle(100*cos(M_PI/6*i)+150, 100*sin(M_PI/6*i)+300, 27, DL_RGB(200-i*15 , 200+i*i , 30*i*i), 1 , 1);
  }
        for (q = 0; q < 51; q++) {
                dl_circle(50*cos(M_PI*q/25)+500, 50*sin(M_PI*q/25)+300, 50, DL_RGB(50 , 250-q*q , 10), 3 , 0);
  }
    while (1) {
        dl_wait(1.0);
  } 

    return 0;
}

",49,1505,923
"#define error 0.0000000001 
#define N 3 

int i, j, k;

void initial_value( double x[N] ){ 
    for( i = 0; i < N; i++ ) x[i] = 1.0;
}

void Seidel( double x[N], double  y[N], double a[N][N], double b[N]){ 
    for( j = 0; j < N; j++ ){
        for( k = 0; k < N; k++ ) y[k] = x[k];
        x[j] = ( (a[j][j] * y[j]) + b[j] );
        for( k = 0; k < N; k++ ) x[j] -= ( a[j][k] * y[k] );
        x[j] /= a[j][j];
    }
}

int Convergence_test( double x[N], double y[N] ){ 
    for( j = 0; j < N; j++ ){
        if( error < fabs( x[j] - y[j] ))return (1);
    }
    return (0);
}

int main(){ 
    double a[N][N] = { { 5.0, 1.0, 1.0 }, { 1.0, 4.0, 1.0 }, { 2.0, 1.0, 3.0 } }; 
    double b[N] = { 10.0, 12.0, 13.0 };
    double x[N], y[N];
    int c = 0;

    initial_value( x );

    while( Convergence_test( x, y) ){ 
        Seidel( x, y, a, b );
        c++; 
    }
    printf(""[%3dé±ç®] "", c ); 
    for( i = 0; i < N; i++) printf("" x%d = %.10f "", i+1, x[i] );
    printf(""\n"");
    return 0;
}
",49,1506,528
"void Count(){
    FILE *rf, *wf;
    int i, j, k, a, b, c;
    double count[27][27][27], total = .0;
    for(i = 0; i < 27; i++){
        for(j = 0; j < 27; j++){
            for(k = 0; k < 27; k++) count[i][j][k] = .0;
        }
    }
    if((rf = fopen(""outtext.txt"", ""r"")) != NULL){
        b = fgetc(rf);
        c = fgetc(rf);
        while( ! feof(rf)){
            a = b;
            b = c;
            c = fgetc(rf);
            if('A' <= a && a <= 'Z'){
                if('A' <= b && b <= 'Z'){
                    if('A' <= c && c <= 'Z') count[a-'A'][b-'A'][c-'A']++;
                    else if(c == 0X20) count[a-'A'][b-'A'][26]++;
                }else if(b == 0X20){
                    if('A' <= c && c <= 'Z') count[a-'A'][26][c-'A']++;
                    else if(c == 0X20) count[a-'A'][26][26]++;
                }
            }else if(a = 0X20){
                if('A' <= b && b <= 'Z'){
                    if('A' <= c && c <= 'Z') count[26][b-'A'][c-'A']++;
                    else if(c == 0X20) count[26][b-'A'][26]++;
                }else if(b == 0X20){
                    if('A' <= c && c <= 'Z') count[26][26][c-'A']++;
                    else if(c == 0X20) count[26][26][26]++;
                }
            }
            total++;
        }
        fclose(rf);
    }else printf(""File not open\n"");
    wf = fopen(""probability3.txt"", ""w"");
    for(i = 0; i < 27; i++){
        for(j = 0; j < 27; j++){
            for(k = 0; k < 27; k++){
                printf(""%c%c%c : %g\n"", i+65, j+65, k+65, count[i][j][k]);
                fprintf(wf, ""%.6lf\n"", count[i][j][k]/total);
            }
        }
    }
}

int main(){
    Count();
    return 0;
}
 
",49,1507,717
"double f(double x){ 
    return x+cos(x);
}

void initial_value(double x[2] ){ 
    while( (f(x[0])>0 || f(x[1])<0) && (f(x[0])<0 || f(x[1])>0) ){
        x[0] += 100;
        x[1] -= 100;
    }
}

void dichotomy(double x[2] ){ 
    double c;
    while(1){
        c = (x[0] + x[1]) / 2;
        if(f(c)*f(x[0]) < 0) x[1] = c;
        else x[0] = c;
        if(fabs(x[0]-x[1])<0.0000000001){
            printf(""x = %.10lf\n"",c);
            exit(1);
        }
    }
}

int main(){ 
    double x[2] = { 0, 0};
    initial_value(x);
    dichotomy(x);
    return 0;
}
",49,1508,289
"FILE *rf, *wf;
int a , i = 0, n;
double count[28], kakuritu[27];
double r, sum, total = .0;

void Conversion(){
    if((rf = fopen(""intext.txt"", ""r"")) != NULL){
        wf = fopen(""outtext.txt"", ""w"");
        while((a = fgetc(rf)) != EOF){
            if('A' <= a && a <= 'Z') a = a;
            else if('a' <= a && a <= 'z') a = a-0X20;
            else if(a == 0X0A) a = a;
            else a = 0X20;
            fputc(a, wf);
        }
        fclose(rf);
        fclose(wf);
    }else printf(""File not open\n"");
}

void Count(){
    for(i = 0; i < 28; i++) count[i] = .0;
    if((rf = fopen(""outtext.txt"", ""r"")) != NULL){
        while((a = fgetc(rf)) != EOF){
            if('A' <= a && a <= 'Z') count[a-'A']++;
            else if(a == 0X20) count[26]++;
            else if(a == 0X0A) count[27]++;
            if(a != 0X0A) total++;
        }
        fclose(rf);
    }else printf(""File not open\n"");
    wf = fopen(""probability.txt"", ""w"");
    for(i = 0; i < 27; i++) fprintf(wf, ""%.6lf\n"", count[i]/total);
    fclose(wf);
}

void Create(){
    srand(time(NULL));
    i = 0;
    rf = fopen(""probability.txt"", ""r"");
    while(! feof(rf)){
        fscanf(rf, ""%lf\n"", &kakuritu[i]);
        i++;
    }
    for(i = 0; i < 100; i++){
        r = (rand() % 1000000 + 1);
        r /= 1000000;
        for(sum = n = 0; sum < 1; n++){
            sum += kakuritu[n];
            if(r < sum){
                if(n == 26){
                    printf(""%c"", 0X20);
                    break;
                }else{
                    printf(""%c"", n+65);
                    break;
                }
            }
        }
    }
    printf(""\n"");
    fclose(rf);
}

int main(){
    Conversion();
    Count();
    Create();
    return 0;
}
",49,1509,709
"void Count(){
    FILE *rf, *wf;
    int i, a;
    double count[28], total = .0, total2 = .0;
    for(i = 0; i < 28; i++) count[i] = .0;
    if((rf = fopen(""outtext.txt"", ""r"")) != NULL){
        while((a = fgetc(rf)) != EOF){
            if('A' <= a && a <= 'Z') count[a-'A']++;
            else if(a == 0x20) count[26]++;
            else if(a == 0x0A) count[27]++;
            if(a != 0x0A) total++;
        }
        fclose(rf);
    }else{
        printf(""File open error!\n"");
    }
    wf = fopen(""probability.txt"", ""w"");
    for(i = 0; i < 26; i++) printf(""%c  : %g\n"", i+65, count[i]);
    printf(""SPC: %g\n"", count[26]);
    printf(""LF : %g\n"", count[27]);
    printf(""total : %g\n"", total);
    for(i = 0; i < 27; i++) total2 += count[i];
    printf(""total : %g\n"", total2);
    for(i = 0; i < 27; i++) fprintf(wf, ""%.6lf\n"", count[i]/total);
}
int main(){
    Count();
    return 0;
}
",49,1510,395
"void reflect (float *vx, float *vy, int y, int bary, int barh) {
  float hity = fabs((float)(y - bary) / (barh / 2));
  float weight = 0.75 * hity + 0.75;
  
  *vx *= -1.0 * weight;
  *vy *= weight;
}

int main(void) {
  float wait_time = 0.01;

  int barw = 20, barh = 150;
  int bardy = 50;
  int bardx = 200;
  int bar1ix = 70, bar2ix = DL_WIDTH - 70;
  int bar1x = bar1ix, bar1y = DL_HEIGHT / 2;
  int bar1kup = 'w', bar1kdown = 's', bar1ka = 'e';
  int bar2x = bar2ix, bar2y = DL_HEIGHT / 2;
  int bar2kup = 'i', bar2kdown = 'k', bar2ka = 'u';

  int br = 15;
  float bvx = 4.0, bvy = 2.0;
  int bx = DL_WIDTH / 2, by = DL_HEIGHT / 2;

  int score1 = 0, score2 = 0;
  int score1changed = 0;
  int score2changed = 0;
  int sx = DL_WIDTH / 2 - 120, sy = 50;
  char sscore[] = ""   :   "";

  int t, k, x, y;
  
  dl_initialize(1.0);
  
  while (1) {
    while (dl_get_event(&t, &k, &x, &y)) {
      if (t == DL_EVENT_KEY) {
        if (k == bar1kup)
          bar1y -= bardy;
        else if (k == bar1kdown)
          bar1y += bardy;
        else if (k == bar1ka) {
          if (bar1x > bar1ix) 
            bar1x = bar1ix;
          else
            bar1x += bardx;
        } else if (k == bar2kup)
          bar2y -= bardy;
        else if (k == bar2kdown)
          bar2y += bardy;
        else if (k == bar2ka) {
          if (bar2x < bar2ix) 
            bar2x = bar2ix;
          else
            bar2x -= bardx;
        }
      }
    }
    if (bar1y - barh / 2 < 0)
      bar1y = barh / 2;
    if (bar1y + barh / 2 > DL_HEIGHT)
      bar1y = DL_HEIGHT - barh / 2;
    if (bar2y - barh / 2 < 0)
      bar2y = barh / 2;
    if (bar2y + barh / 2 > DL_HEIGHT)
      bar2y = DL_HEIGHT - barh / 2;

    bx += bvx;
    if (bx - br <= 0 || bx + br >= DL_WIDTH) 
      bvx *= -1;
      by += bvy;
    if (by - br <= 0) {
      by = br + 1;
      bvy *= -1;
    } else if (by + br >= DL_HEIGHT) {
      by = DL_HEIGHT - br - 1;
      bvy *= -1;
    }

    if (by > bar1y - barh / 2 && by < bar1y + barh / 2) {
      if (bvx < 0 && bx - br <= bar1x + barw / 2 && bx - br >= bar1x - barw / 2
            || bvx > 0 && bx + br >= bar1x - barw / 2 && bx + br <= bar1x + barw / 2) {
        reflect (&bvx, &bvy, by, bar1y, barh);
      }
    }
    if (by > bar2y - barh / 2 && by < bar2y + barh / 2) {
      if (bvx < 0 && bx - br <= bar2x + barw / 2 && bx - br >= bar2x - barw / 2
        || bvx > 0 && bx + br >= bar2x - barw / 2 && bx + br <= bar2x + barw / 2) {
        reflect (&bvx, &bvy, by, bar2y, barh);
      }
    }

        score1changed = 0;
        score2changed = 0;

    if (bx - br <= 0) {
      score2++;
      bx = bar1x + barw + 1;
      by = bar1y;
      bvx = 4.0;
      bvy = 2.0;
      score2changed = 1;
    }
    if (bx + br >= DL_WIDTH) {
      score1++;
      bx = bar2x - barw - 1;
      by = bar2y;
      bvx = -4.0;
      bvy = 2.0;
      score1changed = 1;
    }
    if(score1 > 999)
      score1 = 999;
    if(score2 > 999)
      score2 = 999;
      
    
    if (score1changed) {
dl_text(""+1POINT"",100,50,1.0,DL_C(""red""),2);
sleep(1);
if (score1>=7){
 dl_text(sscore,sx,sy,2.0,DL_C(""white""),2);
 dl_text(""RED WINNER!"",0,300,2.5,DL_C(""red""),2);
 dl_resume();
 sleep(3);
 exit(0);
}
            
    }
    if (score2changed) {
dl_text(""+1POINT"",450,50,1.0,DL_C(""green""),2);
sleep(1);
if (score2>=7){
 dl_text(sscore,sx,sy,2.0,DL_C(""white""),2);
 dl_text(""GREEN WINNER!"",0,300,2.0,DL_C(""green""),2);
 dl_resume();
 sleep(3);
 exit(0);
}
            
        }  
          
    dl_stop();
    dl_clear(DL_C(""black""));
    dl_rectangle(bar1x - barw / 2, bar1y - barh / 2,
         bar1x + barw / 2, bar1y + barh / 2, DL_C(""red""), 1, 1);
    dl_rectangle(bar2x - barw / 2, bar2y - barh / 2,
         bar2x + barw / 2, bar2y + barh / 2, DL_C(""green""), 1, 1);
    dl_circle(bx, by, br, DL_C(""blue""), 1, 1);
    sprintf(sscore, ""%3d:%d"", score1, score2);
    dl_text(sscore, sx, sy, 2.0, DL_C(""white""), 2);
    dl_resume();

    dl_wait(wait_time);
  }

  return 0;
}
",49,1511,1949
"void Count(){
    FILE *rf, *wf;
    int i, n, a, b;
    double count[27][27], total = .0;
    for(i = 0; i < 27; i++) {
        for(n = 0; n < 27; n++) count[i][n] = .0;
    }
    if((rf = fopen(""outtext.txt"", ""r"")) != NULL){
        b = fgetc(rf);
        while( ! feof(rf)){
            a = b;
            b = fgetc(rf);
            if('A' <= a && a <= 'Z'){
                if('A' <= b && b <= 'Z') count[a-'A'][b-'A']++;
                else if(b == 0X20) count[a-'A'][26]++;
            }else if(a == 0X20){
                if('A' <= b && b <= 'Z') count[26][b-'A']++;
                else if(b == 0X20) count[26][26]++;
            }
            total++;
        }
        fclose(rf);
    }else{
        printf(""File not open\n"");
    }
    wf = fopen(""probability2.txt"", ""w"");
    for(i = 0; i < 27; i++){
        for(n = 0; n < 27; n++){
            printf(""%c%c : %g\n"", i+65, n+65, count[i][n]);
            fprintf(wf, ""%.6lf\n"", count[i][n]/total);
        }
    }
}

int main(){
    Count();
    return 0;
}
",49,1512,438
"#include ""main.h""
#include ""stm32f4xx_hal.h""


#include ""sdinit.h""



SDRAM_HandleTypeDef hsdram1;







void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_FMC_Init(void);



void mainApp(void);








int main(void)
{
  

  

  

  
  HAL_Init();

  

  

  
  SystemClock_Config();

  

  

  
  MX_GPIO_Init();
  MX_FMC_Init();
  
  SDRAM_Initialization_Sequence(&hsdram1);
  

  
  
  mainApp();
  while (1)
  {

  

  

  }
  

}


void SystemClock_Config(void)
{

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

    
  __HAL_RCC_PWR_CLK_ENABLE();

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

    
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 168;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

    
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

    
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);

    
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);

  
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
}


static void MX_FMC_Init(void)
{
  FMC_SDRAM_TimingTypeDef SdramTiming;

  
  hsdram1.Instance = FMC_SDRAM_DEVICE;
  
  hsdram1.Init.SDBank = FMC_SDRAM_BANK2;
  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_8;
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_12;
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_3;
  hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_2;
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_DISABLE;
  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_1;
  
  SdramTiming.LoadToActiveDelay = 2;
  SdramTiming.ExitSelfRefreshDelay = 7;
  SdramTiming.SelfRefreshTime = 4;
  SdramTiming.RowCycleDelay = 7;
  SdramTiming.WriteRecoveryTime = 3;
  SdramTiming.RPDelay = 2;
  SdramTiming.RCDDelay = 2;

  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

}


static void MX_GPIO_Init(void)
{

  
  __HAL_RCC_GPIOF_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOG_CLK_ENABLE();
  __HAL_RCC_GPIOE_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

}






void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  

  
  if (htim->Instance == TIM6) {
    HAL_IncTick();
  }
  

  
}


void _Error_Handler(char *file, int line)
{
  
  
  while(1)
  {
  }
  
}

#ifdef  USE_FULL_ASSERT

void assert_failed(uint8_t* file, uint32_t line)
{ 
  
  
  
}
#endif 






",50,1513,1796
"#undef errno
extern int32_t errno;

uint8_t *__env[1] = { 0 };
uint8_t **environ = __env;



void initialise_monitor_handles()
{
}

int _getpid(void)
{
    errno = ENOSYS;
    return -1;
}

int _gettimeofday(struct timeval  *ptimeval, void *ptimezone)
{
  errno = ENOSYS;
  return -1;
}

int _kill(int32_t pid, int32_t sig)
{
    errno = ENOSYS;
    return -1;
}

void _exit(int32_t status)
{
    while (1) {}        
}

int _write(int32_t file, uint8_t *ptr, int32_t len)
{
    
    
    int i;
    for(i = 0; i < len; i++)
        ITM_SendChar(*ptr++);
    return len;
}

void * _sbrk(int32_t incr)
{
    extern char   end; 
    static char * heap_end;
    char *        prev_heap_end;

    if (heap_end == 0) {
        heap_end = & end;
    }

    prev_heap_end = heap_end;
    heap_end += incr;

    return (void *) prev_heap_end;
}

int _close(int32_t file)
{
    errno = ENOSYS;
    return -1;
}


int _fstat(int32_t file, struct stat *st)
{
    errno = ENOSYS;
    return -1;
}

int _isatty(int32_t file)
{
    errno = ENOSYS;
    return 0;
}

int _lseek(int32_t file, int32_t ptr, int32_t dir)
{
    errno = ENOSYS;
    return -1;
}

int _read(int32_t file, uint8_t *ptr, int32_t len)
{
    errno = ENOSYS;
    return -1;
}

int _readlink(const char *path, char *buf, size_t bufsize)
{
  errno = ENOSYS;
  return -1;
}

int _open(const uint8_t *path, int32_t flags, int32_t mode)
{
    errno = ENOSYS;
    return -1;
}

int _wait(int32_t *status)
{
    errno = ENOSYS;
    return -1;
}

int _unlink(const uint8_t *name)
{
    errno = ENOSYS;
    return -1;
}

int _times(struct tms *buf)
{
    errno = ENOSYS;
    return -1;
}

int _stat(const uint8_t *file, struct stat *st)
{
    errno = ENOSYS;
    return -1;
}

int _symlink(const char *path1, const char *path2)
{
  errno = ENOSYS;
  return -1;
}

int _link(const uint8_t *old, const uint8_t *new)
{
    errno = ENOSYS;
    return -1;
}

int _fork(void)
{
    errno = ENOSYS;
    return -1;
}

int _execve(const uint8_t *name, uint8_t * const *argv, uint8_t * const *env)
{
    errno = ENOSYS;
    return -1;
}

",50,1514,965
"#include ""main.h""
#include ""charlcd.h""


#define TIMEBASE              200


#ifdef  osCMSIS
#define Delay(t)              osDelay(t)
#define GetTime()             osKernelSysTick()
#else
#define Delay(t)              HAL_Delay(t)
#define GetTime()             HAL_GetTick()
#endif


#ifdef osCMSIS
void StartDefaultTask(void const * argument)
#else
void mainApp(void)
#endif
{
  static uint32_t cycle;
  uint32_t lastmsec = 0, t, ca = 0, cycle1 = 0, cycle2 = 0, c;

  LcdInit();                            
  #if (1UL * LCD_WIDTH * LCD_LINES) < 80
  
  #if LCD_BLINKCHAR == 1
  for(c = 24; c < 32; c++)
    LcdBlinkChar(c);
  #endif 
  #else  
  
  memcpy((char *)LcdText +   0, ""****************************************"", 40);
  memcpy((char *)LcdText +  40, ""*          LCD CPU used meter          *"", 40);
  memcpy((char *)LcdText +  80, ""*                                      *"", 40);
  memcpy((char *)LcdText + 120, ""****************************************"", 40);
  #if LCD_BLINKCHAR == 1
  for(c = 41; c < 78; c++)
    LcdBlinkChar(c);
  #endif 
  #endif 

  while(1)
  {
    t = GetTime();

    if(lastmsec + TIMEBASE <= t)
    {

      if(!ca)
      {
        LcdRefreshStop();
        cycle1 = cycle;
        cycle = 0;
      }
      else
      {
        LcdRefreshStart();
        cycle2 = cycle;
        cycle = 0;
      }
      ca = 1 - ca;

      if(cycle1 && cycle2)
      {
        
        #if (1UL * LCD_WIDTH * LCD_LINES) < 80
        
        memcpy((char *)LcdText, ""                                "", 32);
        utoa(cycle1,  (char *)LcdText +  0, 10);
        utoa(cycle2,  (char *)LcdText +  8, 10);
        utoa(100 - (201 * cycle1 / (2 * cycle2)), (char *)LcdText + 16, 10);
        #else  
        
        
        memcpy((char *)LcdText +  80, ""*With:        Without:              %  *"", 40);
        utoa(cycle1,  (char *)LcdText +  86, 10);
        utoa(cycle2,  (char *)LcdText + 102, 10);
        utoa(100 - (201 * cycle1 / (2 * cycle2)), (char *)LcdText + 113, 10);
        #endif 
      }

      lastmsec = GetTime();
    }
    cycle++;
  }
}
",50,1515,844
"#include ""stm32f1xx_hal.h""





#ifdef HAL_CORTEX_MODULE_ENABLED















void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  
  NVIC_SetPriorityGrouping(PriorityGroup);
}


void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
  uint32_t prioritygroup = 0x00U;
  
  
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}


void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
  
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  
  NVIC_EnableIRQ(IRQn);
}


void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
  
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  
  NVIC_DisableIRQ(IRQn);
}


void HAL_NVIC_SystemReset(void)
{
  
  NVIC_SystemReset();
}


uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}




#if (__MPU_PRESENT == 1U)

void HAL_MPU_Disable(void)
{
  
  __DMB();

  
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
  
  
  MPU->CTRL = 0U;
}


void HAL_MPU_Enable(uint32_t MPU_Control)
{
  
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
  
  
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
  
  
  __DSB();
  __ISB();
}


void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
  
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  
  MPU->RNR = MPU_Init->Number;

  if ((MPU_Init->Enable) != RESET)
  {
    
    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
  }
  else
  {
    MPU->RBAR = 0x00U;
    MPU->RASR = 0x00U;
  }
}
#endif 


uint32_t HAL_NVIC_GetPriorityGrouping(void)
{
  
  return NVIC_GetPriorityGrouping();
}


void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
{
  
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 
  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
}


void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  
  NVIC_SetPendingIRQ(IRQn);
}


uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
  
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  
  return NVIC_GetPendingIRQ(IRQn);
}


void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  
  NVIC_ClearPendingIRQ(IRQn);
}


uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
{
  
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  
  return NVIC_GetActive(IRQn);
}


void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
  }
}


void HAL_SYSTICK_IRQHandler(void)
{
  HAL_SYSTICK_Callback();
}


__weak void HAL_SYSTICK_Callback(void)
{
  
}





#endif 





",50,1516,2088
"#include ""main.h""
#include ""charlcd.h""


#define TIMEBASE              1000

#if LCD_MODE != 1
#error LCD MODE is wrong setting !
#endif


#ifdef  osCMSIS
#define Delay(t)              osDelay(t)
#define GetTime()             osKernelSysTick()
#else
#define Delay(t)              HAL_Delay(t)
#define GetTime()             HAL_GetTick()
#endif

#if (1UL * LCD_WIDTH * LCD_LINES < 80)
#define  FPSPOZ     0
#define  CPSPOZ     16
#else  
#define  FPSPOZ     82
#define  CPSPOZ     98
#endif 


#ifdef osCMSIS
void StartDefaultTask(void const * argument)
#else
void mainApp(void)
#endif
{
  uint32_t lastmsec = 0, t1, t2, res, cycle = 0;

  LcdInit();                            
  #if (1UL * LCD_WIDTH * LCD_LINES) < 80
  
  #else  
  
  memcpy((char *)LcdText +   0, ""****************************************"", 40);
  memcpy((char *)LcdText +  40, ""*            LCD speed meter           *"", 40);
  memcpy((char *)LcdText +  80, ""*                                      *"", 40);
  memcpy((char *)LcdText + 120, ""****************************************"", 40);
  #endif 

  while(1)
  {
    LcdRefreshAll();
    cycle++;                            

    t1 = GetTime();
    if(lastmsec + TIMEBASE <= t1)
    {
      t2 = GetTime();
      memcpy((char *)LcdText + FPSPOZ, ""FPS:      "", 10);
      memcpy((char *)LcdText + CPSPOZ, ""CPS:      "", 10);
      res = cycle * 1000 / (t2 - lastmsec);
      utoa(res, (char *)LcdText +  FPSPOZ + 4, 10);
      utoa(res * (1UL * LCD_LINES * (LCD_WIDTH + 1)), (char *)LcdText +  CPSPOZ + 4, 10);
      lastmsec = GetTime();
      cycle = 0;
    }
  }
}
",50,1517,649
"#include ""stm32f4xx_hal.h""

#define SDRAM_BANK_ADDR                 ((uint32_t)0xD0000000)


#define SDRAM_MEMORY_WIDTH            FMC_SDRAM_MEM_BUS_WIDTH_16


#define SDCLOCK_PERIOD                FMC_SDRAM_CLOCK_PERIOD_3

#define SDRAM_TIMEOUT                            ((uint32_t)0xFFFF)

#define SDRAM_MODEREG_BURST_LENGTH_1             ((uint16_t)0x0000)
#define SDRAM_MODEREG_BURST_LENGTH_2             ((uint16_t)0x0001)
#define SDRAM_MODEREG_BURST_LENGTH_4             ((uint16_t)0x0002)
#define SDRAM_MODEREG_BURST_LENGTH_8             ((uint16_t)0x0004)
#define SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL      ((uint16_t)0x0000)
#define SDRAM_MODEREG_BURST_TYPE_INTERLEAVED     ((uint16_t)0x0008)
#define SDRAM_MODEREG_CAS_LATENCY_2              ((uint16_t)0x0020)
#define SDRAM_MODEREG_CAS_LATENCY_3              ((uint16_t)0x0030)
#define SDRAM_MODEREG_OPERATING_MODE_STANDARD    ((uint16_t)0x0000)
#define SDRAM_MODEREG_WRITEBURST_MODE_PROGRAMMED ((uint16_t)0x0000)
#define SDRAM_MODEREG_WRITEBURST_MODE_SINGLE     ((uint16_t)0x0200)

#define REFRESH_COUNT       ((uint32_t)0x056A)   


void SDRAM_Initialization_Sequence(SDRAM_HandleTypeDef *hsdram)
{
  __IO uint32_t tmpmrd =0;
  FMC_SDRAM_CommandTypeDef Command;
  
  Command.CommandMode       = FMC_SDRAM_CMD_CLK_ENABLE;
  Command.CommandTarget     = FMC_SDRAM_CMD_TARGET_BANK2;
  Command.AutoRefreshNumber   = 1;
  Command.ModeRegisterDefinition = 0;

  
  HAL_SDRAM_SendCommand(hsdram, &Command, 0x1000);

  
  HAL_Delay(100);

  
  Command.CommandMode       = FMC_SDRAM_CMD_PALL;
  Command.CommandTarget       = FMC_SDRAM_CMD_TARGET_BANK2;
  Command.AutoRefreshNumber   = 1;
  Command.ModeRegisterDefinition = 0;

  
  HAL_SDRAM_SendCommand(hsdram, &Command, 0x1000);

  
  Command.CommandMode       = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
  Command.CommandTarget     = FMC_SDRAM_CMD_TARGET_BANK2;
  Command.AutoRefreshNumber   = 4;
  Command.ModeRegisterDefinition = 0;

  
  HAL_SDRAM_SendCommand(hsdram, &Command, 0x1000);

  
  tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_2          |
                     SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL   |
                     SDRAM_MODEREG_CAS_LATENCY_3           |
                     SDRAM_MODEREG_OPERATING_MODE_STANDARD |
                     SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;

  Command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;
  Command.CommandTarget     = FMC_SDRAM_CMD_TARGET_BANK2;
  Command.AutoRefreshNumber   = 1;
  Command.ModeRegisterDefinition = tmpmrd;

  
  HAL_SDRAM_SendCommand(hsdram, &Command, 0x1000);

  
  
  
  HAL_SDRAM_ProgramRefreshRate(hsdram, REFRESH_COUNT);
}
",50,1518,1155
"#include ""stm32f4xx_hal.h""





#ifdef HAL_PWR_MODULE_ENABLED



    
#define PWR_OVERDRIVE_TIMEOUT_VALUE  1000U
#define PWR_UDERDRIVE_TIMEOUT_VALUE  1000U
#define PWR_BKPREG_TIMEOUT_VALUE     1000U
#define PWR_VOSRDY_TIMEOUT_VALUE     1000U


   









HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void)
{
  uint32_t tickstart = 0U;

  *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)ENABLE;

  
  tickstart = HAL_GetTick();

    
  while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) == RESET)
  {
    if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    } 
  }
  return HAL_OK;
}


HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)
{
  uint32_t tickstart = 0U;

  *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)DISABLE;

  
  tickstart = HAL_GetTick();

    
  while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)
  {
    if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    } 
  }
  return HAL_OK;
}


void HAL_PWREx_EnableFlashPowerDown(void)
{
  *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)ENABLE;
}


void HAL_PWREx_DisableFlashPowerDown(void)
{
  *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)DISABLE;
}

  
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return (PWR->CR & PWR_CR_VOS);
}

#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)

HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
  uint32_t tickstart = 0U;
  
  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
  
  
  __HAL_RCC_PWR_CLK_ENABLE();
  
  
  __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);
  
  
  tickstart = HAL_GetTick();
  while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))
  {
    if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    } 
  }

  return HAL_OK;
}

#elif defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
      defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || \
      defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) || \
      defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || \
      defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)

HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
  uint32_t tickstart = 0U;
  
  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
  
  
  __HAL_RCC_PWR_CLK_ENABLE();
  
  
  if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
  {
    
    __HAL_RCC_PLL_DISABLE();
    
    
    tickstart = HAL_GetTick();    
      
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
    {
      if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
      {
        return HAL_TIMEOUT;
      }
    }
    
    
    __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);
    
    
    __HAL_RCC_PLL_ENABLE();
    
    
    tickstart = HAL_GetTick();
      
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
      {
        return HAL_TIMEOUT;
      } 
    }
    
    
    tickstart = HAL_GetTick();
    while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))
    {
      if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)
      {
        return HAL_TIMEOUT;
      } 
    }
  }
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
#endif 

#if defined(STM32F469xx) || defined(STM32F479xx)

void HAL_PWREx_EnableWakeUpPinPolarityRisingEdge(void)
{
  *(__IO uint32_t *) CSR_WUPP_BB = (uint32_t)DISABLE;
}


void HAL_PWREx_EnableWakeUpPinPolarityFallingEdge(void)
{
  *(__IO uint32_t *) CSR_WUPP_BB = (uint32_t)ENABLE;
}
#endif 

#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) ||\
    defined(STM32F411xE) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\
    defined(STM32F413xx) || defined(STM32F423xx)

void HAL_PWREx_EnableMainRegulatorLowVoltage(void)
{
  *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)ENABLE;
}


void HAL_PWREx_DisableMainRegulatorLowVoltage(void)
{
  *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)DISABLE;
}


void HAL_PWREx_EnableLowRegulatorLowVoltage(void)
{
  *(__IO uint32_t *) CR_LPLVDS_BB = (uint32_t)ENABLE;
}


void HAL_PWREx_DisableLowRegulatorLowVoltage(void)
{
  *(__IO uint32_t *) CR_LPLVDS_BB = (uint32_t)DISABLE;
}

#endif 

#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)

HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
  uint32_t tickstart = 0U;

  __HAL_RCC_PWR_CLK_ENABLE();
  
  
  __HAL_PWR_OVERDRIVE_ENABLE();

  
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
  {
    if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  }
  
  
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();

  
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
}


HAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void)
{
  uint32_t tickstart = 0U;
  
  __HAL_RCC_PWR_CLK_ENABLE();
    
  
  __HAL_PWR_OVERDRIVESWITCHING_DISABLE();
  
  
  tickstart = HAL_GetTick();
 
  while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
  {
    if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  } 
  
  
  __HAL_PWR_OVERDRIVE_DISABLE();

  
  tickstart = HAL_GetTick();

  while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
  {
    if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  }
  
  return HAL_OK;
}


HAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
{
  uint32_t tmpreg1 = 0U;

  
  assert_param(IS_PWR_REGULATOR_UNDERDRIVE(Regulator));
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
  
  
  __HAL_RCC_PWR_CLK_ENABLE();
  
  
  __HAL_PWR_CLEAR_ODRUDR_FLAG();
  
   
  __HAL_PWR_UNDERDRIVE_ENABLE();

  
  tmpreg1 = PWR->CR;
  
  tmpreg1 &= (uint32_t)~(PWR_CR_PDDS | PWR_CR_LPDS | PWR_CR_LPUDS | PWR_CR_MRUDS);
  
  
  tmpreg1 |= Regulator;
  
  
  PWR->CR = tmpreg1;
  
  
  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
  
  
  if(STOPEntry == PWR_SLEEPENTRY_WFI)
  {   
    
    __WFI();
  }
  else
  {
    
    __WFE();
  }
  
  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);

  return HAL_OK;  
}

#endif 




#endif 





",50,1519,3430
"#include ""stm32f4xx_hal.h""





#ifdef HAL_DMA_MODULE_ENABLED







static void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);











HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
{
  HAL_StatusTypeDef status = HAL_OK;
  
  
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
  
  
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
    status = HAL_ERROR;
  }
  else
  {
    
    __HAL_LOCK(hdma);
    
    if(HAL_DMA_STATE_READY == hdma->State)
    {
      
      hdma->State = HAL_DMA_STATE_BUSY; 
      
      
      hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;
      
      
      hdma->Instance->M1AR = SecondMemAddress;
      
      
      DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);
      
      
      __HAL_DMA_ENABLE(hdma);
    }
    else
    {
      
      status = HAL_BUSY;
    }
  }
  return status;
}


HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
{
  HAL_StatusTypeDef status = HAL_OK;
  
  
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
  
  
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
    return HAL_ERROR;
  }
  
  
  if ((NULL == hdma->XferCpltCallback) || (NULL == hdma->XferM1CpltCallback) || (NULL == hdma->XferErrorCallback))
  {
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
    return HAL_ERROR;
  }
  
  
  __HAL_LOCK(hdma);
  
  if(HAL_DMA_STATE_READY == hdma->State)
  {
    
    hdma->State = HAL_DMA_STATE_BUSY;
    
    
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
    
    
    hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;
    
    
    hdma->Instance->M1AR = SecondMemAddress;
    
    
    DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength); 
    
    
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));

    
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
    hdma->Instance->FCR |= DMA_IT_FE;
    
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
    {
      hdma->Instance->CR  |= DMA_IT_HT;
    }
    
    
    __HAL_DMA_ENABLE(hdma); 
  }
  else
  {     
    
    __HAL_UNLOCK(hdma);   
    
    
    status = HAL_BUSY;
  }  
  return status; 
}


HAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory)
{
  if(memory == MEMORY0)
  {
    
    hdma->Instance->M0AR = Address;
  }
  else
  {
    
    hdma->Instance->M1AR = Address;
  }

  return HAL_OK;
}








static void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{  
  
  hdma->Instance->NDTR = DataLength;
  
  
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
  {   
    
    hdma->Instance->PAR = DstAddress;
    
    
    hdma->Instance->M0AR = SrcAddress;
  }
  
  else
  {
    
    hdma->Instance->PAR = SrcAddress;
    
    
    hdma->Instance->M0AR = DstAddress;
  }
}



#endif 





",50,1520,1602
"#include ""stm32f4xx_hal.h""





#ifdef HAL_CORTEX_MODULE_ENABLED















void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  
  NVIC_SetPriorityGrouping(PriorityGroup);
}


void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
  uint32_t prioritygroup = 0x00U;
  
  
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}


void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
  
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  
  NVIC_EnableIRQ(IRQn);
}


void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
  
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  
  NVIC_DisableIRQ(IRQn);
}


void HAL_NVIC_SystemReset(void)
{
  
  NVIC_SystemReset();
}


uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}




#if (__MPU_PRESENT == 1U)

void HAL_MPU_Disable(void)
{
  
  __DMB();

  
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
  
  
  MPU->CTRL = 0U;
}


void HAL_MPU_Enable(uint32_t MPU_Control)
{
  
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
  
  
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
  
  
  __DSB();
  __ISB();
}


void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
  
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  
  MPU->RNR = MPU_Init->Number;

  if ((MPU_Init->Enable) != RESET)
  {
    
    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
  }
  else
  {
    MPU->RBAR = 0x00U;
    MPU->RASR = 0x00U;
  }
}
#endif 


uint32_t HAL_NVIC_GetPriorityGrouping(void)
{
  
  return NVIC_GetPriorityGrouping();
}


void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
{
  
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 
  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
}


void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  
  NVIC_SetPendingIRQ(IRQn);
}


uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
  
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  
  return NVIC_GetPendingIRQ(IRQn);
}


void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  
  NVIC_ClearPendingIRQ(IRQn);
}


uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
{
  
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  
  return NVIC_GetActive(IRQn);
}


void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
  }
}


void HAL_SYSTICK_IRQHandler(void)
{
  HAL_SYSTICK_Callback();
}


__weak void HAL_SYSTICK_Callback(void)
{
  
}





#endif 





",50,1521,2093
"#include ""stm32f1xx_hal.h""
#include ""stm32f1xx.h""
#include ""stm32f1xx_it.h""








 



void NMI_Handler(void)
{
  

  
  

  
}


void HardFault_Handler(void)
{
  

  
  while (1)
  {
    
    
  }
  

  
}


void MemManage_Handler(void)
{
  

  
  while (1)
  {
    
    
  }
  

  
}


void BusFault_Handler(void)
{
  

  
  while (1)
  {
    
    
  }
  

  
}


void UsageFault_Handler(void)
{
  

  
  while (1)
  {
    
    
  }
  

  
}


void SVC_Handler(void)
{
  

  
  

  
}


void DebugMon_Handler(void)
{
  

  
  

  
}


void PendSV_Handler(void)
{
  

  
  

  
}


void SysTick_Handler(void)
{
  

  
  HAL_IncTick();
  HAL_SYSTICK_IRQHandler();
  

  
}












",50,1522,390
"#include ""main.h""

#include ""multi_heap.h""

#define POINTERS_NUM          512     
#define IMALLOC_SIZE          1024    
#define EMALLOC_SIZE          128000  

#define PRINTF_DELAY          20



#ifdef  osCMSIS
#define Delay(t)              osDelay(t)
#define GetTime()             osKernelSysTick()
#else
#define Delay(t)              HAL_Delay(t)
#define GetTime()             HAL_GetTick()
#endif



#ifdef osCMSIS
void StartDefaultTask(void const * argument)
#else
void mainApp(void)
#endif
{
  static uint8_t * p[POINTERS_NUM];
  uint32_t i;
  printf(""\r\nMem malloc test\r\n"");
  Delay(PRINTF_DELAY);

  i = 0;
  do
  {
    p[i] = malloc_int(IMALLOC_SIZE);
    printf(""int ram malloc:p%d:0x%x, 0x%x\r\n"", (unsigned int)i, (unsigned int)p[i], (unsigned int)heapsize_int());
    Delay(PRINTF_DELAY);
    i++;
  } while((i < POINTERS_NUM) && p[i - 1]);
  i = 0;
  do
  {
    if(p[i] == NULL)
      break;
    else
    {
      free(p[i]);
      printf(""int ram free:p%d:0x%x, 0x%x\r\n"", (unsigned int)i, (unsigned int)p[i], (unsigned int)heapsize_int());
      Delay(PRINTF_DELAY);
    }
    i++;
  } while(i < POINTERS_NUM);

  i = 0;
  do
  {
    p[i] = malloc_ext(EMALLOC_SIZE);
    printf(""ext ram malloc:p%d:0x%x, 0x%x\r\n"", (unsigned int)i, (unsigned int)p[i], (unsigned int)heapsize_ext());
    Delay(PRINTF_DELAY);
    i++;
  } while((i < POINTERS_NUM) && p[i - 1]);
  i = 0;
  do
  {
    if(p[i] == NULL)
      break;
    else
    {
      free(p[i]);
      printf(""ext ram free:p%d:0x%x, 0x%x\r\n"", (unsigned int)i, (unsigned int)p[i], (unsigned int)heapsize_ext());
      Delay(PRINTF_DELAY);
    }
    i++;
  } while(i < POINTERS_NUM);

  printf(""End test\r\n"");

  while(1)
  {
    Delay(1000);
  }
}



#ifdef osCMSIS
void StartTask02(void const * argument)
{
  for(;;)
  {
    Delay(1);
  }
}
#endif
",50,1523,825
"#include ""main.h""
#include ""uart.h""





#define MODE_DIGITAL_INPUT    0x0
#define MODE_OUT              0x1
#define MODE_ALTER            0x2
#define MODE_ANALOG_INPUT     0x3


#define MODE_SPD_LOW          0x0
#define MODE_SPD_MEDIUM       0x1
#define MODE_SPD_HIGH         0x2
#define MODE_SPD_VHIGH        0x3


#define MODE_OT_PP            0x0
#define MODE_OT_OD            0x1


#define MODE_PU_NONE          0x0
#define MODE_PU_UP            0x1
#define MODE_PU_DOWN          0x2

#define GPIOX_(a,b,c)         GPIO ## a
#define GPIOX(a)              GPIOX_(a)

#define GPIOX_PIN_(a,b,c)     b
#define GPIOX_PIN(a)          GPIOX_PIN_(a)

#define GPIOX_AFR_(a,b,c)     GPIO ## a->AFR[b >> 3] = (GPIO ## a->AFR[b >> 3] & ~(0x0F << (4 * (b & 7)))) | (c << (4 * (b & 7)));
#define GPIOX_AFR(a)          GPIOX_AFR_(a)

#define GPIOX_MODER_(a,b,c,d) GPIO ## b->MODER = (GPIO ## b->MODER & ~(3 << (2 * c))) | (a << (2 * c));
#define GPIOX_MODER(a, b)     GPIOX_MODER_(a, b)

#define GPIOX_OTYPER_(a,b,c,d) GPIO ## b->OTYPER = (GPIO ## b->OTYPER & ~(1 << c)) | (a << c);
#define GPIOX_OTYPER(a, b)    GPIOX_OTYPER_(a, b)

#define GPIOX_OSPEEDR_(a,b,c,d) GPIO ## b->OSPEEDR = (GPIO ## b->OSPEEDR & ~(3 << (2 * c))) | (a << (2 * c));
#define GPIOX_OSPEEDR(a, b)   GPIOX_OSPEEDR_(a, b)

#define GPIOX_PUPDR_(a,b,c,d) GPIO ## b->PUPDR = (GPIO ## b->PUPDR & ~(3 << (2 * c))) | (a << (2 * c));
#define GPIOX_PUPDR(a, b)     GPIOX_PUPDR_(a, b)

#define GPIOX_SET_(a,b,c)     GPIO ## a ->BSRR = 1 << b
#define GPIOX_SET(a)          GPIOX_SET_(a)

#define GPIOX_CLR_(a,b,c)     GPIO ## a ->BSRR = 1 << (b + 16)
#define GPIOX_CLR(a)          GPIOX_CLR_(a)

#define GPIOX_IDR_(a,b,c)     (GPIO ## a ->IDR & (1 << b))
#define GPIOX_IDR(a)          GPIOX_IDR_(a)

#define GPIOX_LINE_(a,b,c)    EXTI_Line ## b
#define GPIOX_LINE(a)         GPIOX_LINE_(a)

#define GPIOX_PORTSRC_(a,b,c) GPIO_PortSourceGPIO ## a
#define GPIOX_PORTSRC(a)      GPIOX_PORTSRC_(a)

#define GPIOX_PINSRC_(a,b,c)  GPIO_PinSource ## b
#define GPIOX_PINSRC(a)       GPIOX_PINSRC_(a)

#define GPIOX_CLOCK_(a,b,c)   RCC_AHB1ENR_GPIO ## a ## EN
#define GPIOX_CLOCK(a)        GPIOX_CLOCK_(a)

#define GPIOX_PORTNUM_A       1
#define GPIOX_PORTNUM_B       2
#define GPIOX_PORTNUM_C       3
#define GPIOX_PORTNUM_D       4
#define GPIOX_PORTNUM_E       5
#define GPIOX_PORTNUM_F       6
#define GPIOX_PORTNUM_G       7
#define GPIOX_PORTNUM_H       8
#define GPIOX_PORTNUM_I       9
#define GPIOX_PORTNUM_J       10
#define GPIOX_PORTNUM_K       11
#define GPIOX_PORTNUM_(a,b,c) GPIOX_PORTNUM_ ## a
#define GPIOX_PORTNUM(a)      GPIOX_PORTNUM_(a)

#define GPIOX_PORTNAME_(a,b,c) a
#define GPIOX_PORTNAME(a)     GPIOX_PORTNAME_(a)


#if UART1_BAUDRATE > 0 && (GPIOX_PORTNUM(UART1_RX) >= GPIOX_PORTNUM_A && RXBUF1_SIZE >= 4 || GPIOX_PORTNUM(UART1_TX) >= GPIOX_PORTNUM_A && TXBUF1_SIZE >= 4)
#define UARTX                 USART1
#define UARTX_IRQHandler      USART1_IRQHandler
#define UARTX_IRQn            USART1_IRQn
#define UARTX_CLOCLK_ON       RCC->APB2ENR |= RCC_APB2ENR_USART1EN
#define UARTX_BRR_CALC        (UART_1_6_CLK) / UART1_BAUDRATE
#define UARTX_RX              UART1_RX
#define UARTX_TX              UART1_TX
#define TXBUFX_SIZE           TXBUF1_SIZE
#define RXBUFX_SIZE           RXBUF1_SIZE
#define UARTX_PRINTF          UART1_PRINTF
#define uartx_inited          uart1_inited
#define txx_restart           tx1_restart
#define bufx_r                buf1_r
#define bufx_t                buf1_t
#define rbufx                 rbuf1
#define tbufx                 tbuf1
#define uartx_init            uart1_init
#define uartx_sendchar        uart1_sendchar
#define uartx_getchar         uart1_getchar
#define uartx_cbrx            uart1_cbrx
#define uartx_cbrxof          uart1_cbrxof
#include ""uartx.h""
#endif

#if UART2_BAUDRATE > 0 && (GPIOX_PORTNUM(UART2_RX) >= GPIOX_PORTNUM_A && RXBUF2_SIZE >= 4 || GPIOX_PORTNUM(UART2_TX) >= GPIOX_PORTNUM_A && TXBUF2_SIZE >= 4)
#define UARTX                 USART2
#define UARTX_IRQHandler      USART2_IRQHandler
#define UARTX_IRQn            USART2_IRQn
#define UARTX_CLOCLK_ON       RCC->APB1ENR |= RCC_APB1ENR_USART2EN
#define UARTX_BRR_CALC        (UART_2_3_4_5_7_8_CLK) / UART2_BAUDRATE
#define UARTX_RX              UART2_RX
#define UARTX_TX              UART2_TX
#define TXBUFX_SIZE           TXBUF2_SIZE
#define RXBUFX_SIZE           RXBUF2_SIZE
#define UARTX_PRINTF          UART2_PRINTF
#define uartx_inited          uart2_inited
#define txx_restart           tx2_restart
#define bufx_r                buf2_r
#define bufx_t                buf2_t
#define rbufx                 rbuf2
#define tbufx                 tbuf2
#define uartx_init            uart2_init
#define uartx_sendchar        uart2_sendchar
#define uartx_getchar         uart2_getchar
#define uartx_cbrx            uart2_cbrx
#define uartx_cbrxof          uart2_cbrxof
#include ""uartx.h""
#endif

#if UART3_BAUDRATE > 0 && (GPIOX_PORTNUM(UART3_RX) >= GPIOX_PORTNUM_A && RXBUF3_SIZE >= 4 || GPIOX_PORTNUM(UART3_TX) >= GPIOX_PORTNUM_A && TXBUF3_SIZE >= 4)
#define UARTX                 USART3
#define UARTX_IRQHandler      USART3_IRQHandler
#define UARTX_IRQn            USART3_IRQn
#define UARTX_CLOCLK_ON       RCC->APB1ENR |= RCC_APB1ENR_USART3EN
#define UARTX_BRR_CALC        (UART_2_3_4_5_7_8_CLK) / UART3_BAUDRATE
#define UARTX_RX              UART3_RX
#define UARTX_TX              UART3_TX
#define TXBUFX_SIZE           TXBUF3_SIZE
#define RXBUFX_SIZE           RXBUF3_SIZE
#define UARTX_PRINTF          UART3_PRINTF
#define uartx_inited          uart3_inited
#define txx_restart           tx3_restart
#define bufx_r                buf3_r
#define bufx_t                buf3_t
#define rbufx                 rbuf3
#define tbufx                 tbuf3
#define uartx_init            uart3_init
#define uartx_sendchar        uart3_sendchar
#define uartx_getchar         uart3_getchar
#define uartx_cbrx            uart3_cbrx
#define uartx_cbrxof          uart3_cbrxof
#include ""uartx.h""
#endif

#if UART4_BAUDRATE > 0 && (GPIOX_PORTNUM(UART4_RX) >= GPIOX_PORTNUM_A && RXBUF4_SIZE >= 4 || GPIOX_PORTNUM(UART4_TX) >= GPIOX_PORTNUM_A && TXBUF4_SIZE >= 4)
#define UARTX                 UART4
#define UARTX_IRQHandler      UART4_IRQHandler
#define UARTX_IRQn            UART4_IRQn
#define UARTX_CLOCLK_ON       RCC->APB1ENR |= RCC_APB1ENR_UART4EN
#define UARTX_BRR_CALC        (UART_2_3_4_5_7_8_CLK) / UART4_BAUDRATE
#define UARTX_RX              UART4_RX
#define UARTX_TX              UART4_TX
#define TXBUFX_SIZE           TXBUF4_SIZE
#define RXBUFX_SIZE           RXBUF4_SIZE
#define UARTX_PRINTF          UART4_PRINTF
#define uartx_inited          uart4_inited
#define txx_restart           tx4_restart
#define bufx_r                buf4_r
#define bufx_t                buf4_t
#define rbufx                 rbuf4
#define tbufx                 tbuf4
#define uartx_init            uart4_init
#define uartx_sendchar        uart4_sendchar
#define uartx_getchar         uart4_getchar
#define uartx_cbrx            uart4_cbrx
#define uartx_cbrxof          uart4_cbrxof
#include ""uartx.h""
#endif

#if UART5_BAUDRATE > 0 && (GPIOX_PORTNUM(UART5_RX) >= GPIOX_PORTNUM_A && RXBUF5_SIZE >= 4 || GPIOX_PORTNUM(UART5_TX) >= GPIOX_PORTNUM_A && TXBUF5_SIZE >= 4)
#define UARTX                 UART5
#define UARTX_IRQHandler      UART5_IRQHandler
#define UARTX_IRQn            UART5_IRQn
#define UARTX_CLOCLK_ON       RCC->APB1ENR |= RCC_APB1ENR_UART5EN
#define UARTX_BRR_CALC        (UART_2_3_4_5_7_8_CLK) / UART5_BAUDRATE
#define UARTX_RX              UART5_RX
#define UARTX_TX              UART5_TX
#define TXBUFX_SIZE           TXBUF5_SIZE
#define RXBUFX_SIZE           RXBUF5_SIZE
#define UARTX_PRINTF          UART5_PRINTF
#define uartx_inited          uart5_inited
#define txx_restart           tx5_restart
#define bufx_r                buf5_r
#define bufx_t                buf5_t
#define rbufx                 rbuf5
#define tbufx                 tbuf5
#define uartx_init            uart5_init
#define uartx_sendchar        uart5_sendchar
#define uartx_getchar         uart5_getchar
#define uartx_cbrx            uart5_cbrx
#define uartx_cbrxof          uart5_cbrxof
#include ""uartx.h""
#endif

#if UART6_BAUDRATE > 0 && (GPIOX_PORTNUM(UART6_RX) >= GPIOX_PORTNUM_A && RXBUF6_SIZE >= 4 || GPIOX_PORTNUM(UART6_TX) >= GPIOX_PORTNUM_A && TXBUF6_SIZE >= 4)
#define UARTX                 USART6
#define UARTX_IRQHandler      USART6_IRQHandler
#define UARTX_IRQn            USART6_IRQn
#define UARTX_CLOCLK_ON       RCC->APB2ENR |= RCC_APB2ENR_USART6EN;
#define UARTX_BRR_CALC        (UART_1_6_CLK) / UART6_BAUDRATE
#define UARTX_RX              UART6_RX
#define UARTX_TX              UART6_TX
#define TXBUFX_SIZE           TXBUF6_SIZE
#define RXBUFX_SIZE           RXBUF6_SIZE
#define UARTX_PRINTF          UART6_PRINTF
#define uartx_inited          uart6_inited
#define txx_restart           tx6_restart
#define bufx_r                buf6_r
#define bufx_t                buf6_t
#define rbufx                 rbuf6
#define tbufx                 tbuf6
#define uartx_init            uart6_init
#define uartx_sendchar        uart6_sendchar
#define uartx_getchar         uart6_getchar
#define uartx_cbrx            uart6_cbrx
#define uartx_cbrxof          uart6_cbrxof
#include ""uartx.h""
#endif

#if UART7_BAUDRATE > 0 && (GPIOX_PORTNUM(UART7_RX) >= GPIOX_PORTNUM_A && RXBUF7_SIZE >= 4 || GPIOX_PORTNUM(UART7_TX) >= GPIOX_PORTNUM_A && TXBUF7_SIZE >= 4)
#define UARTX                 UART7
#define UARTX_IRQHandler      UART7_IRQHandler
#define UARTX_IRQn            UART7_IRQn
#define UARTX_CLOCLK_ON       RCC->APB1ENR |= RCC_APB1ENR_UART7EN
#define UARTX_BRR_CALC        (UART_2_3_4_5_7_8_CLK) / UART7_BAUDRATE
#define UARTX_RX              UART7_RX
#define UARTX_TX              UART7_TX
#define TXBUFX_SIZE           TXBUF7_SIZE
#define RXBUFX_SIZE           RXBUF7_SIZE
#define UARTX_PRINTF          UART7_PRINTF
#define uartx_inited          uart7_inited
#define txx_restart           tx7_restart
#define bufx_r                buf7_r
#define bufx_t                buf7_t
#define rbufx                 rbuf7
#define tbufx                 tbuf7
#define uartx_init            uart7_init
#define uartx_sendchar        uart7_sendchar
#define uartx_getchar         uart7_getchar
#define uartx_cbrx            uart7_cbrx
#define uartx_cbrxof          uart7_cbrxof
#include ""uartx.h""
#endif

#if UART8_BAUDRATE > 0 && (GPIOX_PORTNUM(UART8_RX) >= GPIOX_PORTNUM_A && RXBUF8_SIZE >= 4 || GPIOX_PORTNUM(UART8_TX) >= GPIOX_PORTNUM_A && TXBUF8_SIZE >= 4)
#define UARTX                 UART8
#define UARTX_IRQHandler      UART8_IRQHandler
#define UARTX_IRQn            UART8_IRQn
#define UARTX_CLOCLK_ON       RCC->APB1LENR |= RCC_APB1LENR_UART8EN
#define UARTX_BRR_CALC        (UART_2_3_4_5_7_8_CLK) / UART8_BAUDRATE
#define UARTX_RX              UART8_RX
#define UARTX_TX              UART8_TX
#define TXBUFX_SIZE           TXBUF8_SIZE
#define RXBUFX_SIZE           RXBUF8_SIZE
#define UARTX_PRINTF          UART8_PRINTF
#define uartx_inited          uart8_inited
#define txx_restart           tx8_restart
#define bufx_r                buf8_r
#define bufx_t                buf8_t
#define rbufx                 rbuf8
#define tbufx                 tbuf8
#define uartx_init            uart8_init
#define uartx_sendchar        uart8_sendchar
#define uartx_getchar         uart8_getchar
#define uartx_cbrx            uart8_cbrx
#define uartx_cbrxof          uart8_cbrxof
#include ""uartx.h""
#endif
",50,1524,5131
"#include ""stm32f1xx.h""









#if !defined  (HSE_VALUE) 
  #define HSE_VALUE               8000000U 
#endif 

#if !defined  (HSI_VALUE)
  #define HSI_VALUE               8000000U 
#endif 

 
#if defined(STM32F100xE) || defined(STM32F101xE) || defined(STM32F101xG) || defined(STM32F103xE) || defined(STM32F103xG)

#endif 

 

#define VECT_TAB_OFFSET  0x00000000U 











#if defined(STM32F100xB) ||defined(STM32F100xE)
  uint32_t SystemCoreClock         = 24000000U;        
#else 
  uint32_t SystemCoreClock         = 72000000U;        
#endif

const uint8_t AHBPrescTable[16U] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
const uint8_t APBPrescTable[8U] =  {0, 0, 0, 0, 1, 2, 3, 4};





#if defined(STM32F100xE) || defined(STM32F101xE) || defined(STM32F101xG) || defined(STM32F103xE) || defined(STM32F103xG)
#ifdef DATA_IN_ExtSRAM
  static void SystemInit_ExtMemCtl(void); 
#endif 
#endif 






void SystemInit (void)
{
  
  
  RCC->CR |= 0x00000001U;

  
#if !defined(STM32F105xC) && !defined(STM32F107xC)
  RCC->CFGR &= 0xF8FF0000U;
#else
  RCC->CFGR &= 0xF0FF0000U;
#endif    
  
  
  RCC->CR &= 0xFEF6FFFFU;

  
  RCC->CR &= 0xFFFBFFFFU;

  
  RCC->CFGR &= 0xFF80FFFFU;

#if defined(STM32F105xC) || defined(STM32F107xC)
  
  RCC->CR &= 0xEBFFFFFFU;

  
  RCC->CIR = 0x00FF0000U;

  
  RCC->CFGR2 = 0x00000000U;
#elif defined(STM32F100xB) || defined(STM32F100xE)
  
  RCC->CIR = 0x009F0000U;

  
  RCC->CFGR2 = 0x00000000U;      
#else
  
  RCC->CIR = 0x009F0000U;
#endif 
    
#if defined(STM32F100xE) || defined(STM32F101xE) || defined(STM32F101xG) || defined(STM32F103xE) || defined(STM32F103xG)
  #ifdef DATA_IN_ExtSRAM
    SystemInit_ExtMemCtl(); 
  #endif 
#endif 

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; 
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; 
#endif 
}


void SystemCoreClockUpdate (void)
{
  uint32_t tmp = 0U, pllmull = 0U, pllsource = 0U;

#if defined(STM32F105xC) || defined(STM32F107xC)
  uint32_t prediv1source = 0U, prediv1factor = 0U, prediv2factor = 0U, pll2mull = 0U;
#endif 

#if defined(STM32F100xB) || defined(STM32F100xE)
  uint32_t prediv1factor = 0U;
#endif 
    
  
  tmp = RCC->CFGR & RCC_CFGR_SWS;
  
  switch (tmp)
  {
    case 0x00U:  
      SystemCoreClock = HSI_VALUE;
      break;
    case 0x04U:  
      SystemCoreClock = HSE_VALUE;
      break;
    case 0x08U:  

      
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
      
#if !defined(STM32F105xC) && !defined(STM32F107xC)      
      pllmull = ( pllmull >> 18U) + 2U;
      
      if (pllsource == 0x00U)
      {
        
        SystemCoreClock = (HSI_VALUE >> 1U) * pllmull;
      }
      else
      {
 #if defined(STM32F100xB) || defined(STM32F100xE)
       prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1U;
       
       SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
 #else
        
        if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
        {
          SystemCoreClock = (HSE_VALUE >> 1U) * pllmull;
        }
        else
        {
          SystemCoreClock = HSE_VALUE * pllmull;
        }
 #endif
      }
#else
      pllmull = pllmull >> 18U;
      
      if (pllmull != 0x0DU)
      {
         pllmull += 2U;
      }
      else
      { 
        pllmull = 13U / 2U; 
      }
            
      if (pllsource == 0x00U)
      {
        
        SystemCoreClock = (HSI_VALUE >> 1U) * pllmull;
      }
      else
      {
        
        
        prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1U;
        
        if (prediv1source == 0U)
        { 
          
          SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull;          
        }
        else
        {
          
          
          prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4U) + 1U;
          pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8U) + 2U; 
          SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
        }
      }
#endif  
      break;

    default:
      SystemCoreClock = HSI_VALUE;
      break;
  }
  
  
  
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4U)];
  
  SystemCoreClock >>= tmp;  
}

#if defined(STM32F100xE) || defined(STM32F101xE) || defined(STM32F101xG) || defined(STM32F103xE) || defined(STM32F103xG)
 
#ifdef DATA_IN_ExtSRAM
 
void SystemInit_ExtMemCtl(void) 
{
  __IO uint32_t tmpreg;
  

  
  RCC->AHBENR = 0x00000114U;

  
  tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_FSMCEN);
  
  
  RCC->APB2ENR = 0x000001E0U;
  
  
  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPDEN);

  (void)(tmpreg);
  


  


  
  GPIOD->CRL = 0x44BB44BBU;  
  GPIOD->CRH = 0xBBBBBBBBU;

  GPIOE->CRL = 0xB44444BBU;  
  GPIOE->CRH = 0xBBBBBBBBU;

  GPIOF->CRL = 0x44BBBBBBU;  
  GPIOF->CRH = 0xBBBB4444U;

  GPIOG->CRL = 0x44BBBBBBU;  
  GPIOG->CRH = 0x444B4B44U;
   
  

  
  FSMC_Bank1->BTCR[4U] = 0x00001091U;
  FSMC_Bank1->BTCR[5U] = 0x00110212U;
}
#endif 
#endif 




  
    

",50,1525,2694
"#include ""stm32f4xx_hal.h""
#include ""stm32f4xx_hal_tim.h""


 





TIM_HandleTypeDef        htim6; 
uint32_t                 uwIncrementState = 0;




HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  RCC_ClkInitTypeDef    clkconfig;
  uint32_t              uwTimclock = 0;
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  
  
  HAL_NVIC_SetPriority(TIM6_DAC_IRQn, TickPriority ,0); 
  
  
  HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn); 
  
  
  __HAL_RCC_TIM6_CLK_ENABLE();
  
  
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
  
  
  uwTimclock = 2*HAL_RCC_GetPCLK1Freq();
   
  
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
  
  
  htim6.Instance = TIM6;
  
  
  htim6.Init.Period = (1000000 / 1000) - 1;
  htim6.Init.Prescaler = uwPrescalerValue;
  htim6.Init.ClockDivision = 0;
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
  if(HAL_TIM_Base_Init(&htim6) == HAL_OK)
  {
    
    return HAL_TIM_Base_Start_IT(&htim6);
  }
  
  
  return HAL_ERROR;
}


void HAL_SuspendTick(void)
{
  
  __HAL_TIM_DISABLE_IT(&htim6, TIM_IT_UPDATE);                                                  
}


void HAL_ResumeTick(void)
{
  
  __HAL_TIM_ENABLE_IT(&htim6, TIM_IT_UPDATE);
}

 

 


",50,1526,617
"#include ""stm32f1xx_hal.h""





#ifdef HAL_GPIO_MODULE_ENABLED






void HAL_GPIOEx_ConfigEventout(uint32_t GPIO_PortSource, uint32_t GPIO_PinSource)
{
  
  assert_param(IS_AFIO_EVENTOUT_PORT(GPIO_PortSource));
  assert_param(IS_AFIO_EVENTOUT_PIN(GPIO_PinSource));

  
  MODIFY_REG(AFIO->EVCR, (AFIO_EVCR_PORT) | (AFIO_EVCR_PIN), (GPIO_PortSource) | (GPIO_PinSource));
}


void HAL_GPIOEx_EnableEventout(void)
{
  SET_BIT(AFIO->EVCR, AFIO_EVCR_EVOE);
}


void HAL_GPIOEx_DisableEventout(void)
{
  CLEAR_BIT(AFIO->EVCR, AFIO_EVCR_EVOE);
}





#endif 






",50,1527,318
"#include ""stm32f4xx_hal.h""
extern void _Error_Handler(char *, int);




void HAL_MspInit(void)
{
  

  

  __HAL_RCC_SYSCFG_CLK_ENABLE();
  __HAL_RCC_PWR_CLK_ENABLE();

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);

  
  
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
  
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
  
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
  
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
  
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
  
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
  
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);

  

  
}

static uint32_t FMC_Initialized = 0;

static void HAL_FMC_MspInit(void){
  

  
  GPIO_InitTypeDef GPIO_InitStruct;
  if (FMC_Initialized) {
    return;
  }
  FMC_Initialized = 1;
  
  __HAL_RCC_FMC_CLK_ENABLE();
  
  
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 
                          |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_11|GPIO_PIN_12 
                          |GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = GPIO_PIN_0;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5 
                          |GPIO_PIN_8|GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 
                          |GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14 
                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14 
                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  

  
}

void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef* hsdram){
  

  
  HAL_FMC_MspInit();
  

  
}

static uint32_t FMC_DeInitialized = 0;

static void HAL_FMC_MspDeInit(void){
  

  
  if (FMC_DeInitialized) {
    return;
  }
  FMC_DeInitialized = 1;
  
  __HAL_RCC_FMC_CLK_DISABLE();
  
  
  HAL_GPIO_DeInit(GPIOF, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 
                          |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_11|GPIO_PIN_12 
                          |GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15);

  HAL_GPIO_DeInit(GPIOC, GPIO_PIN_0);

  HAL_GPIO_DeInit(GPIOG, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5 
                          |GPIO_PIN_8|GPIO_PIN_15);

  HAL_GPIO_DeInit(GPIOE, GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 
                          |GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14 
                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1);

  HAL_GPIO_DeInit(GPIOD, GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14 
                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1);

  HAL_GPIO_DeInit(GPIOB, GPIO_PIN_5|GPIO_PIN_6);

  

  
}

void HAL_SDRAM_MspDeInit(SDRAM_HandleTypeDef* hsdram){
  

  
  HAL_FMC_MspDeInit();
  

  
}










",50,1528,2309
"#include ""stm32f1xx_hal.h""





#ifdef HAL_PWR_MODULE_ENABLED





  
 
#define PVD_MODE_IT               0x00010000U
#define PVD_MODE_EVT              0x00020000U
#define PVD_RISING_EDGE           0x00000001U
#define PVD_FALLING_EDGE          0x00000002U



 

#define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
#define PWR_CR_OFFSET            0x00U
#define PWR_CSR_OFFSET           0x04U
#define PWR_CR_OFFSET_BB         (PWR_OFFSET + PWR_CR_OFFSET)
#define PWR_CSR_OFFSET_BB        (PWR_OFFSET + PWR_CSR_OFFSET)

   
  


#define LPSDSR_BIT_NUMBER        PWR_CR_LPDS_Pos
#define CR_LPSDSR_BB             ((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (LPSDSR_BIT_NUMBER * 4U)))


#define DBP_BIT_NUMBER            PWR_CR_DBP_Pos
#define CR_DBP_BB                ((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (DBP_BIT_NUMBER * 4U)))


#define PVDE_BIT_NUMBER           PWR_CR_PVDE_Pos
#define CR_PVDE_BB               ((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (PVDE_BIT_NUMBER * 4U)))







#define CSR_EWUP_BB(VAL)         ((uint32_t)(PERIPH_BB_BASE + (PWR_CSR_OFFSET_BB * 32U) + (POSITION_VAL(VAL) * 4U)))

  





static void PWR_OverloadWfe(void);


__NOINLINE
static void PWR_OverloadWfe(void)
{
  __asm volatile( ""wfe"" );
  __asm volatile( ""nop"" );
}









void HAL_PWR_DeInit(void)
{
  __HAL_RCC_PWR_FORCE_RESET();
  __HAL_RCC_PWR_RELEASE_RESET();
}


void HAL_PWR_EnableBkUpAccess(void)
{
  
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)ENABLE;
}


void HAL_PWR_DisableBkUpAccess(void)
{
  
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)DISABLE;
}






void HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
{
  
  assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
  assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));

  
  MODIFY_REG(PWR->CR, PWR_CR_PLS, sConfigPVD->PVDLevel);
  
  
  __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
  __HAL_PWR_PVD_EXTI_DISABLE_IT();
  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); 
  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();

  
  if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
  {
    __HAL_PWR_PVD_EXTI_ENABLE_IT();
  }
  
  
  if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
  {
    __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
  }
  
  
  if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
  {
    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
  }
  
  if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
  {
    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
  }
}


void HAL_PWR_EnablePVD(void)
{
  
  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)ENABLE;
}


void HAL_PWR_DisablePVD(void)
{
  
  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)DISABLE;
}


void HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinx)
{
  
  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
  
  *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)ENABLE;
}


void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
{
  
  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
  
  *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)DISABLE;
}


void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
{
  
  
  
  UNUSED(Regulator);

  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));

  
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));

  
  if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
  {
    
    __WFI();
  }
  else
  {
    
    __SEV();
    __WFE();
    __WFE();
  }
}


void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
{
  
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));

   
  CLEAR_BIT(PWR->CR,  PWR_CR_PDDS);

  
  MODIFY_REG(PWR->CR, PWR_CR_LPDS, Regulator);

  
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));

  
  if(STOPEntry == PWR_STOPENTRY_WFI)
  {
    
    __WFI();
  }
  else
  {
    
    __SEV();
    PWR_OverloadWfe(); 
    PWR_OverloadWfe(); 
  }
  
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
}


void HAL_PWR_EnterSTANDBYMode(void)
{
  
  SET_BIT(PWR->CR, PWR_CR_PDDS);

  
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));

  
#if defined ( __CC_ARM)
  __force_stores();
#endif
  
  __WFI();
}



void HAL_PWR_EnableSleepOnExit(void)
{
  
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
}



void HAL_PWR_DisableSleepOnExit(void)
{
  
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
}



void HAL_PWR_EnableSEVOnPend(void)
{
  
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
}



void HAL_PWR_DisableSEVOnPend(void)
{
  
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
}




void HAL_PWR_PVD_IRQHandler(void)
{
  
  if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
  {
    
    HAL_PWR_PVDCallback();

    
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
  }
}


__weak void HAL_PWR_PVDCallback(void)
{
   
}





#endif 





",50,1529,2518
"#pragma config FOSFPR = ECIO            
#pragma config FCKSMEN = CSW_FSCM_OFF   


#pragma config FWPSB = WDTPSB_16        
#pragma config FWPSA = WDTPSA_512       
#pragma config WDT = WDT_OFF            


#pragma config FPWRT = PWRT_64          
#pragma config BODENV = BORV20          
#pragma config BOREN = PBOR_ON          
#pragma config MCLRE = MCLR_EN          


#pragma config GWRP = GWRP_OFF          
#pragma config GCP = CODE_PROT_OFF      


#pragma config ICS = ICS_PGD            





",50,1530,189
"#include ""main.h""
#include ""charlcd.h""


#ifdef  osCMSIS
#define Delay(t)              osDelay(t)
#define GetTime()             osKernelSysTick()
#else
#define Delay(t)              HAL_Delay(t)
#define GetTime()             HAL_GetTick()
#endif


#ifdef osCMSIS
void StartDefaultTask(void const * argument)
#else
void mainApp(void)
#endif
{
  LcdInit();                            
  memcpy((char *)LcdText, ""   Hello world                  "", 32);
  #if LCD_MODE == 1 || LCD_MODE == 2 || LCD_MODE == 3
  LcdRefreshAll();
  #endif
  while(1)
  {
    #if LCD_MODE == 4
    LcdProcess();
    #endif
  }
}
",50,1531,233
"#include ""stm32f4xx_hal.h""
#include ""stm32f4xx.h""
#include ""stm32f4xx_it.h""







extern TIM_HandleTypeDef htim6;


 



void NMI_Handler(void)
{
  

  
  

  
}


void HardFault_Handler(void)
{
  

  
  while (1)
  {
    
    
  }
  

  
}


void MemManage_Handler(void)
{
  

  
  while (1)
  {
    
    
  }
  

  
}


void BusFault_Handler(void)
{
  

  
  while (1)
  {
    
    
  }
  

  
}


void UsageFault_Handler(void)
{
  

  
  while (1)
  {
    
    
  }
  

  
}


void SVC_Handler(void)
{
  

  
  

  
}


void DebugMon_Handler(void)
{
  

  
  

  
}


void PendSV_Handler(void)
{
  

  
  

  
}


void SysTick_Handler(void)
{
  

  
  HAL_SYSTICK_IRQHandler();
  

  
}









void TIM6_DAC_IRQHandler(void)
{
  

  
  HAL_TIM_IRQHandler(&htim6);
  

  
}





",50,1532,441
"#include ""stm32f4xx_hal.h""





#ifdef HAL_GPIO_MODULE_ENABLED




#define GPIO_MODE             0x00000003U
#define EXTI_MODE             0x10000000U
#define GPIO_MODE_IT          0x00010000U
#define GPIO_MODE_EVT         0x00020000U
#define RISING_EDGE           0x00100000U
#define FALLING_EDGE          0x00200000U
#define GPIO_OUTPUT_TYPE      0x00000010U

#define GPIO_NUMBER           16U












void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  uint32_t position;
  uint32_t ioposition = 0x00U;
  uint32_t iocurrent = 0x00U;
  uint32_t temp = 0x00U;

  
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    
    ioposition = 0x01U << position;
    
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
    {
      
      
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        temp = GPIOx->AFR[position >> 3U];
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
        GPIOx->AFR[position >> 3U] = temp;
      }

      
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
      GPIOx->MODER = temp;

      
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        
        temp = GPIOx->OSPEEDR; 
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
        temp |= (GPIO_Init->Speed << (position * 2U));
        GPIOx->OSPEEDR = temp;

        
        temp = GPIOx->OTYPER;
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
        GPIOx->OTYPER = temp;
      }

      
      temp = GPIOx->PUPDR;
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
      temp |= ((GPIO_Init->Pull) << (position * 2U));
      GPIOx->PUPDR = temp;

      
      
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
        }
        EXTI->EMR = temp;

        
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
        }
        EXTI->FTSR = temp;
      }
    }
  }
}


void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
  uint32_t position;
  uint32_t ioposition = 0x00U;
  uint32_t iocurrent = 0x00U;
  uint32_t tmp = 0x00U;

  
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  
  
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    
    ioposition = 0x01U << position;
    
    iocurrent = (GPIO_Pin) & ioposition;

    if(iocurrent == ioposition)
    {
      
      
      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2U));

      
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;

      
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));

      
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;

      
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));

      
      tmp = SYSCFG->EXTICR[position >> 2U];
      tmp &= (0x0FU << (4U * (position & 0x03U)));
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))
      {
        
        tmp = 0x0FU << (4U * (position & 0x03U));
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;

        
        EXTI->IMR &= ~((uint32_t)iocurrent);
        EXTI->EMR &= ~((uint32_t)iocurrent);
        
        
        EXTI->RTSR &= ~((uint32_t)iocurrent);
        EXTI->FTSR &= ~((uint32_t)iocurrent);
      }
    }
  }
}






GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  GPIO_PinState bitstatus;

  
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
  {
    bitstatus = GPIO_PIN_SET;
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}


void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
  
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
  }
}


void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
}


HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  __IO uint32_t tmp = GPIO_LCKR_LCKK;

  
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  
  tmp |= GPIO_Pin;
  
  GPIOx->LCKR = tmp;
  
  GPIOx->LCKR = GPIO_Pin;
  
  GPIOx->LCKR = tmp;
  
  tmp = GPIOx->LCKR;

 if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
  {
    return HAL_OK;
  }
  else
  {
    return HAL_ERROR;
  }
}


void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
}


__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  
  UNUSED(GPIO_Pin);
  
}






#endif 





",50,1533,3134
"#include ""stm32f4xx_hal.h""





#ifdef HAL_PWR_MODULE_ENABLED




  
     
#define PVD_MODE_IT               0x00010000U
#define PVD_MODE_EVT              0x00020000U
#define PVD_RISING_EDGE           0x00000001U
#define PVD_FALLING_EDGE          0x00000002U


    










void HAL_PWR_DeInit(void)
{
  __HAL_RCC_PWR_FORCE_RESET();
  __HAL_RCC_PWR_RELEASE_RESET();
}


void HAL_PWR_EnableBkUpAccess(void)
{
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)ENABLE;
}


void HAL_PWR_DisableBkUpAccess(void)
{
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)DISABLE;
}






void HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
{
  
  assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
  assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));
  
  
  MODIFY_REG(PWR->CR, PWR_CR_PLS, sConfigPVD->PVDLevel);
  
  
  __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
  __HAL_PWR_PVD_EXTI_DISABLE_IT();
  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); 

  
  if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
  {
    __HAL_PWR_PVD_EXTI_ENABLE_IT();
  }
  
  
  if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
  {
    __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
  }
  
  
  if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
  {
    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
  }
  
  if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
  {
    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
  }
}


void HAL_PWR_EnablePVD(void)
{
  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)ENABLE;
}


void HAL_PWR_DisablePVD(void)
{
  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)DISABLE;
}


void HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinx)
{
  
  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));

  
  SET_BIT(PWR->CSR, WakeUpPinx);
}


void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
{
  
  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));  

  
  CLEAR_BIT(PWR->CSR, WakeUpPinx);
}
  

void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
{
  
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));

  
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));

  
  if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
  {   
    
    __WFI();
  }
  else
  {
    
    __SEV();
    __WFE();
    __WFE();
  }
}


void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
{
  
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
  
  
  MODIFY_REG(PWR->CR, (PWR_CR_PDDS | PWR_CR_LPDS), Regulator);
  
  
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
  
  
  if(STOPEntry == PWR_STOPENTRY_WFI)
  {   
    
    __WFI();
  }
  else
  {
    
    __SEV();
    __WFE();
    __WFE();
  }
  
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  
}


void HAL_PWR_EnterSTANDBYMode(void)
{
  
  SET_BIT(PWR->CR, PWR_CR_PDDS);

  
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
  
  
#if defined ( __CC_ARM)
  __force_stores();
#endif
  
  __WFI();
}


void HAL_PWR_PVD_IRQHandler(void)
{
  
  if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
  {
    
    HAL_PWR_PVDCallback();
    
    
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
  }
}


__weak void HAL_PWR_PVDCallback(void)
{
   
}


void HAL_PWR_EnableSleepOnExit(void)
{
  
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
}


void HAL_PWR_DisableSleepOnExit(void)
{
  
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
}


void HAL_PWR_EnableSEVOnPend(void)
{
  
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
}


void HAL_PWR_DisableSEVOnPend(void)
{
  
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
}


  


#endif 





",50,1534,1969
"#include ""stm32f4xx_hal.h""









#define __STM32F4xx_HAL_VERSION_MAIN   (0x01U) 
#define __STM32F4xx_HAL_VERSION_SUB1   (0x07U) 
#define __STM32F4xx_HAL_VERSION_SUB2   (0x04U) 
#define __STM32F4xx_HAL_VERSION_RC     (0x00U)  
#define __STM32F4xx_HAL_VERSION         ((__STM32F4xx_HAL_VERSION_MAIN << 24U)\
                                        |(__STM32F4xx_HAL_VERSION_SUB1 << 16U)\
                                        |(__STM32F4xx_HAL_VERSION_SUB2 << 8U )\
                                        |(__STM32F4xx_HAL_VERSION_RC))
                                        
#define IDCODE_DEVID_MASK    0x00000FFFU


#define SYSCFG_OFFSET             (SYSCFG_BASE - PERIPH_BASE)
 
 
#define MEMRMP_OFFSET             SYSCFG_OFFSET 
#define UFB_MODE_BIT_NUMBER       SYSCFG_MEMRMP_UFB_MODE_Pos
#define UFB_MODE_BB               (uint32_t)(PERIPH_BB_BASE + (MEMRMP_OFFSET * 32U) + (UFB_MODE_BIT_NUMBER * 4U)) 

 
 
#define CMPCR_OFFSET              (SYSCFG_OFFSET + 0x20U) 
#define CMP_PD_BIT_NUMBER         SYSCFG_CMPCR_CMP_PD_Pos
#define CMPCR_CMP_PD_BB           (uint32_t)(PERIPH_BB_BASE + (CMPCR_OFFSET * 32U) + (CMP_PD_BIT_NUMBER * 4U))

 
 
#define MCHDLYCR_OFFSET            (SYSCFG_OFFSET + 0x30U) 
#define BSCKSEL_BIT_NUMBER         SYSCFG_MCHDLYCR_BSCKSEL_Pos
#define MCHDLYCR_BSCKSEL_BB        (uint32_t)(PERIPH_BB_BASE + (MCHDLYCR_OFFSET * 32U) + (BSCKSEL_BIT_NUMBER * 4U))





__IO uint32_t uwTick;
uint32_t uwTickPrio   = (1UL << __NVIC_PRIO_BITS); 
HAL_TickFreqTypeDef uwTickFreq = HAL_TICK_FREQ_DEFAULT;  









HAL_StatusTypeDef HAL_Init(void)
{
   
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
#endif 

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
#endif 

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif 

  
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);

  
  HAL_InitTick(TICK_INT_PRIORITY);

  
  HAL_MspInit();

  
  return HAL_OK;
}


HAL_StatusTypeDef HAL_DeInit(void)
{
  
  __HAL_RCC_APB1_FORCE_RESET();
  __HAL_RCC_APB1_RELEASE_RESET();

  __HAL_RCC_APB2_FORCE_RESET();
  __HAL_RCC_APB2_RELEASE_RESET();

  __HAL_RCC_AHB1_FORCE_RESET();
  __HAL_RCC_AHB1_RELEASE_RESET();

  __HAL_RCC_AHB2_FORCE_RESET();
  __HAL_RCC_AHB2_RELEASE_RESET();

  __HAL_RCC_AHB3_FORCE_RESET();
  __HAL_RCC_AHB3_RELEASE_RESET();

  
  HAL_MspDeInit();
    
  
  return HAL_OK;
}


__weak void HAL_MspInit(void)
{
  
}


__weak void HAL_MspDeInit(void)
{
   
}


__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
  {
    return HAL_ERROR;
  }

  
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    uwTickPrio = TickPriority;
  }
  else
  {
    return HAL_ERROR;
  }

  
  return HAL_OK;
}






__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
}


__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
}


uint32_t HAL_GetTickPrio(void)
{
  return uwTickPrio;
}


HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
{
  HAL_StatusTypeDef status  = HAL_OK;
  assert_param(IS_TICKFREQ(Freq));

  if (uwTickFreq != Freq)
  {
    uwTickFreq = Freq;

    
    status = HAL_InitTick(uwTickPrio);
  }

  return status;
}


HAL_TickFreqTypeDef HAL_GetTickFreq(void)
{
  return uwTickFreq;
}


__weak void HAL_Delay(uint32_t Delay)
{
  uint32_t tickstart = HAL_GetTick();
  uint32_t wait = Delay;

  
  if (wait < HAL_MAX_DELAY)
  {
    wait += (uint32_t)(uwTickFreq);
  }

  while((HAL_GetTick() - tickstart) < wait)
  {
  }
}


__weak void HAL_SuspendTick(void)
{
  
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
}


__weak void HAL_ResumeTick(void)
{
  
  SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
}


uint32_t HAL_GetHalVersion(void)
{
  return __STM32F4xx_HAL_VERSION;
}


uint32_t HAL_GetREVID(void)
{
  return((DBGMCU->IDCODE) >> 16U);
}


uint32_t HAL_GetDEVID(void)
{
  return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
}


void HAL_DBGMCU_EnableDBGSleepMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
}


void HAL_DBGMCU_DisableDBGSleepMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
}


void HAL_DBGMCU_EnableDBGStopMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
}


void HAL_DBGMCU_DisableDBGStopMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
}


void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
}


void HAL_DBGMCU_DisableDBGStandbyMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
}


void HAL_EnableCompensationCell(void)
{
  *(__IO uint32_t *)CMPCR_CMP_PD_BB = (uint32_t)ENABLE;
}


void HAL_DisableCompensationCell(void)
{
  *(__IO uint32_t *)CMPCR_CMP_PD_BB = (uint32_t)DISABLE;
}


void HAL_GetUID(uint32_t *UID)
{
  UID[0] = (uint32_t)(READ_REG(*((uint32_t *)UID_BASE)));
  UID[1] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
  UID[2] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
}

#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
    defined(STM32F469xx) || defined(STM32F479xx)

void HAL_EnableMemorySwappingBank(void)
{
  *(__IO uint32_t *)UFB_MODE_BB = (uint32_t)ENABLE;
}


void HAL_DisableMemorySwappingBank(void)
{
  *(__IO uint32_t *)UFB_MODE_BB = (uint32_t)DISABLE;
}
#endif 









",50,1535,2774
"#include ""stm32f4xx_hal.h""




#ifdef HAL_FLASH_MODULE_ENABLED
#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
    defined(STM32F412Rx) || defined(STM32F412Cx)












__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_StopFlashInterfaceClk(void)
{
  
  __HAL_RCC_PWR_CLK_ENABLE();
    
  SET_BIT(PWR->CR, PWR_CR_FISSR);
   
  return HAL_OK;
}


__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_StartFlashInterfaceClk(void)
{
  
  __HAL_RCC_PWR_CLK_ENABLE();
  
  CLEAR_BIT(PWR->CR, PWR_CR_FISSR);

  return HAL_OK;
}


__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_EnableFlashSleepMode(void)
{
  
  __HAL_RCC_PWR_CLK_ENABLE();
  
  SET_BIT(PWR->CR, PWR_CR_FMSSR);

  return HAL_OK;
}


__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_DisableFlashSleepMode(void)
{
  
  __HAL_RCC_PWR_CLK_ENABLE();
  
  CLEAR_BIT(PWR->CR, PWR_CR_FMSSR);
  
  return HAL_OK;
}





#endif 
#endif 





",50,1536,546
"int main(int argc, char *argv[]) {
    
    
    char nomeEvento[20], localEvento[40], dataEvento[8], horaEvento[5];
    int detalhes, cadastro, qntdIngressos;
    int qntdInteiro, qntdMeio, tipoCompra;
    int capacMax;
    int contadorCompra;
    float vlrIngresso, vlrMeioIngresso;
    float vlrPago, vlrTroco, vlrSobra;
    
    
    do
    {
        system(""cls"");
        printf(""-----------------------------------------------------------\n"");
        printf(""----------------   Vendedor de Ingressos   ----------------\n"");
        printf(""--------------    Configuracoes do Evento    --------------\n"");
        printf(""-----------------------------------------------------------\n\n\n"");
        printf(""Digite o nome do evento: "");
        setbuf(stdin, NULL);
        gets(nomeEvento);
        printf(""\n      |Deseja adicionar detalhes ao evento?\n"");
        do
        {
            printf(""        |   1. Sim\n"");
            printf(""        |   2. Nao, desejo inserir as inforamcoes sobre os ingressos\n      |\n"");
            printf(""        |   Digite a opcao desejada: "");
            scanf(""%d"", &detalhes);
                switch(detalhes)
                {
                    case 1:
                        printf(""        |\n     |Digite a data do evento (dd/mm/aa): "");
                        setbuf(stdin, NULL);
                        gets(dataEvento);
                        printf(""        |\n     |Digite a hora do evento (hh:mm): "");
                        setbuf(stdin, NULL);
                        gets(horaEvento);
                        printf(""        |\n     |Digite o local do evento (cidade, bairro, rua e logradouro): "");
                        setbuf(stdin, NULL);
                        gets(localEvento);
                        break;
                    case 2:
                        break;
                    default:
                        printf(""\n      |opcao invalida, digite novamente.\n"");
                }
        }
        while (detalhes>2 || detalhes<1);
        printf(""\nDigite o total de ingressos a serem vendidos: "");
        scanf(""%d"", &qntdIngressos);
        printf(""Digite o valor unitario de cada ingresso: R$"");
        scanf(""%f"", &vlrIngresso);
        do
        {
            printf(""\n\n\n          |Finalizar cadastro?                         |\n"");
            printf(""            |   1. Sim                               |\n"");
            printf(""            |   2. Nao, reenserir informacoes        |\n            |                                        |\n"");
            printf(""            |Digite a opcao desejada: "");
            scanf(""%d"", &cadastro); 
            if(cadastro >2 || cadastro<1)
            {
                printf(""            |\n         |   Opcao invalida, digite novamente: "");
            }
        }
        while(cadastro>2 || cadastro<1);
    }
    while(cadastro==2);
    

    qntdMeio = qntdIngressos*0.4;
    qntdInteiro = qntdIngressos-qntdMeio;
    vlrMeioIngresso = vlrIngresso*0.5;
    capacMax = qntdIngressos;
        
    do
    {   
        system(""cls"");
        printf(""---------------------------------------------------------\n"");
        printf(""| Auto atendimento - Venda de ingressos - %s | \n"", nomeEvento);
        printf(""---------------------------------------------------------\n"");
        if(detalhes==1)
        {
            printf(""\n  - Data: %s\n    - Hora: %s\n    - Local: %s"", dataEvento, horaEvento, localEvento);
        }
        printf(""\n  - Capacidade maxima: %d "", capacMax);
        printf(""\n  - Valor unitario ingresso: R$ %.2f\n\n "", vlrIngresso);printf(""__________________________________________________________"");
        printf(""\n\nDigite o tipo de ingresso que deseja comprar: "");
        printf(""\n  1. Ingresso inteiro"");
        printf(""\n  2. Meio ingresso"");
        printf(""\n\n    Digite a opcao desejada: "");
        scanf(""%d"", &tipoCompra);
            switch(tipoCompra)
            {           
                case 1:
                    if(qntdInteiro > 0)
                    {
                        printf(""\n\nValor a ser pago: R$%.2f"", vlrIngresso);
                        do
                        {
                            printf(""\n\nDigite o valor total que voce esta pagando a maquina: R$"");
                            scanf(""%g"", &vlrPago);
                            if(vlrPago>vlrIngresso)
                            {
                                vlrTroco = vlrPago - vlrIngresso;
                                printf(""Seu troco e: R$%.2f"", vlrTroco);
                            }else{
                                if(vlrPago==vlrIngresso)
                                {
                                    printf(""Nao ha troco."");;
                                }else{
                                    vlrSobra = vlrIngresso - vlrPago;
                                    printf(""Precisa-se de mais R$%.2f para completar a compra do ingresso."", vlrSobra);
                                    }
                                }
                        }while(vlrPago<vlrIngresso);
                        qntdInteiro--;
                    }else{
                    printf(""Infelizmente nao temos mais ingressos nesta categoria."");
                        }
                    break;
                case 2:
                    if(qntdMeio > 0)
                    {
                        printf(""\n\nValor a ser pago: R$%.2f"", vlrMeioIngresso);
                        do
                        {
                            printf(""\n\nDigite o valor total que voce esta pagando a maquina: R$"");
                            scanf(""%g"", &vlrPago);
                            if(vlrPago>vlrMeioIngresso)
                            {
                                vlrTroco = vlrPago - vlrMeioIngresso;
                                printf(""Seu troco e: R$%.2f"", vlrTroco);
                            }else{
                                if(vlrPago==vlrMeioIngresso)
                                {
                                    printf(""Nao ha troco."");
                                }else{
                                    vlrSobra = vlrMeioIngresso - vlrPago;
                                    printf(""Precisa-se de mais R$%.2f para completar a compra do ingresso."", vlrSobra);
                                    }
                                }
                        }while(vlrPago<vlrMeioIngresso);
                        qntdMeio--;
                    }else{
                    printf(""\n- Infelizmente nao temos mais ingressos nesta categoria."");
                        }
                    break;
                default:
                    printf(""\nOpcao invalida, digite novamente: "");
            }
        qntdIngressos = qntdInteiro + qntdMeio;
        printf(""\n\n\nObrigado por comprar conosco!\n\n___________________________________________________________"");
        printf(""\n                        Relatorio                            "");
        printf(""\n\n    Total de ingressos disponiveis = %d\n   Ingressos inteiros = %d Meio ingressos = %d"", qntdIngressos, qntdInteiro, qntdMeio);
        printf(""\n__________________________________________________________"");
        if(qntdIngressos > 0)
        {
            do
            {
                printf(""\n\n\nDeseja realizar uma nova compra?"");
                printf(""\n  1. Sim\n    2. Nao, desejo finalizar."");
                printf(""\n\n    Digite a opcao desejada: "");
                scanf(""%d"", &contadorCompra);
            }while(contadorCompra < 1 && contadorCompra > 2);
        }
    }while(contadorCompra == 1 && qntdIngressos > 0);
    if(qntdIngressos == 0)
    {
        printf(""\n\n\nNao ha mais ingressos disponiveis neste evento, todos foram vendidos."");
    }
    
return 0;
}
",51,1537,2226
"int srandString(int vetorCaptcha[6])
{
    int contador;
    int recebe;
    

    for(contador = 0; contador < 6; contador ++)
    {
        recebe = rand() % 3;
        if(recebe == 0);
        {
            vetorCaptcha[contador] = (rand() % 10) + (48);
        }
        if(recebe == 1)
        {
            vetorCaptcha[contador] = (rand() % 25) + (65);  
        }
        if(recebe == 2)
        {
            vetorCaptcha[contador] = (rand() % 25) + (97);
        }
        
        printf(""%c"", vetorCaptcha[contador]);
    }
    
    
}


int cmpString(char vetorUsuario[6], int vetorCaptcha[6])
{
    int contador;
    
    for(contador = 0; contador < 6; contador ++)
    {
        if(strlen(vetorUsuario) != 6)
        {
            if(vetorUsuario[contador] == vetorCaptcha[contador])
            {
                printf(""Digite novamente!!\n""); 
                return 0;
            }
        }
        else
        {   
            printf(""Voce digitou corretamente!!"");  
            return 1;
        }
            
    }
                
} 



int main(int argc, char *argv[]) 
{
    int vetorCaptcha[6];
    char vetorUsuario[6];
    
    int teste = 0;
    
    srand(time(NULL));
        
    srandString(vetorCaptcha);
    
    printf(""\n\n"");
    
    do
    {
        printf(""Digite corretamente o CAPTCHA acima: "");
        gets(vetorUsuario);
        
        teste = cmpString(vetorUsuario, vetorCaptcha);
        
        
    }
    while(teste == 0);
    
    
    
    return 0;
}
",51,1538,564
"int main(int argc, char *argv[]) {
    char nomeEvento[50];
    int capacidadeMax;
    float valorEntradaInteira;
    float valorEntradaMeia;
    int ingressosInteiros;
    int ingressosMeios;
    int iInteirosVendidos;
    int iMeiosVendidos;
    int verificaCompra;
    int tipoIngresso;
    float valorPagamento;
    float valorPagamentoFaltante;
    float valorPagamentoFaltPago;
    int ingressosInteirosSobrantes;
    int ingressosMeiosSobrantes;
    float troco;
    float arrecadadoMeios;
    float arrecadadoInteiros;
    int tolalIngressosVendidos;
    float totalArrecadado;


    printf(""Insira o Nome do evento \n"");
    scanf(""%s"",&nomeEvento);
    printf(""Insira a capacidade maxima \n"");
    scanf(""%d"",&capacidadeMax);
    printf(""Insira o valor da entrada inteira \n"");
    scanf(""%f"",&valorEntradaInteira);
    valorEntradaMeia = valorEntradaInteira / 2;
    
    ingressosMeios =  capacidadeMax*0.4;
    ingressosInteiros = capacidadeMax - ingressosMeios;
    verificaCompra = 1;
    
    while(verificaCompra == 1){
        if(ingressosMeios == 0 && ingressosInteiros == 0){
            printf(""Acabou os ingressos, fim do evento\n"");
            verificaCompra++;
        }else{
            printf(""-----------------------------------------------------------------------------\n"");
            printf(""Bem Vindo a compra de ingressos para o %s \n\n"", nomeEvento);
            printf(""Digite 1 para ingressos inteiros(%i) e 2 para meias("",ingressosInteiros);printf(""%i) e 3 para cancelar\n"", ingressosMeios);
            printf(""-----------------------------------------------------------------------------\n"");
            scanf(""%d"",&tipoIngresso);
            if(tipoIngresso == 1){
                if(ingressosInteiros == 0){
                    printf(""Os ingressos inteiros estao esgotados\n"");
                }else{
                    printf(""Voce escolheu o ingresso inteiro que custa %.2f, favor indicar o valor que voce pagara\n"", valorEntradaInteira);
                    scanf(""%f"",&valorPagamento);
                    while(valorPagamento < valorEntradaInteira){
                    valorPagamentoFaltante = valorEntradaInteira - valorPagamento;
                    printf(""Favor pagar o total do ingresso, faltam R$%.2f\n"", valorPagamentoFaltante);
                    scanf(""%f"",&valorPagamentoFaltPago);
                    valorPagamento = valorPagamentoFaltPago + valorPagamento;
                    }
                    if(valorPagamento > valorEntradaInteira){
                        troco = valorPagamento - valorEntradaInteira;
                        printf(""O troco e de %.2f\n"", troco);
                    }
                    ingressosInteiros = ingressosInteiros - 1;
                }
            }else{
                if(tipoIngresso == 2){
                    if(ingressosMeios == 0){
                        printf(""Os ingressos meios estao esgotados\n"");
                    }else{
                        printf(""Voce escolheu o ingresso meio que custa %.2f, favor indicar o valor que voce pagara\n"", valorEntradaMeia);
                        scanf(""%f"",&valorPagamento);
                        while(valorPagamento < valorEntradaMeia){
                        valorPagamentoFaltante = valorEntradaMeia - valorPagamento;
                        printf(""Favor pagar o total do ingresso, faltam R$%.2f\n"", valorPagamentoFaltante);
                        scanf(""%f"",&valorPagamentoFaltPago);
                        valorPagamento = valorPagamentoFaltPago + valorPagamento;
                        }
                        if(valorPagamento > valorEntradaMeia){
                            troco = valorPagamento - valorEntradaMeia;
                            printf(""O troco e de %.2f\n"", troco);
                        }
                        ingressosMeios = ingressosMeios - 1;
                    }
                }else{
                    if(tipoIngresso == 3){
                        break;
                    }else{
                    printf(""Digite uma opcao valida \n"");
                    }
                }
            }
            printf(""Digite 1 para comprar mais um ingresso e 2 para finalizar as compras\n"");
            scanf(""%i"", &verificaCompra);
            if(verificaCompra != 1 && verificaCompra != 2){
                printf(""Digite uma opcao valida \n"");
                verificaCompra = 1;
            }
        }
    }
    ingressosMeiosSobrantes =  capacidadeMax*0.4;
    ingressosInteirosSobrantes = capacidadeMax - ingressosMeiosSobrantes;
    ingressosMeiosSobrantes = ingressosMeiosSobrantes - ingressosMeios;
    ingressosInteirosSobrantes = ingressosInteirosSobrantes - ingressosInteiros;
    arrecadadoMeios = ingressosMeiosSobrantes * valorEntradaMeia;
    arrecadadoInteiros = ingressosInteirosSobrantes * valorEntradaInteira;
    tolalIngressosVendidos = ingressosInteirosSobrantes + ingressosMeiosSobrantes;
    totalArrecadado = arrecadadoMeios + arrecadadoInteiros;
    
    printf(""-------------------------------------------------\n"");
    printf(""\nEvento %s "", nomeEvento);
    printf(""finalizado.\n\nO total de ingressos inteiros vendidos foi de: %i;\nSobraram %i;\nTotal arrecadado R$%.2f.\n\nO total de ingressos meios vendidos foi de %i;\nSobraram %i;\nTotal arrecadado R$%.2f.\n\n"", ingressosInteirosSobrantes,ingressosInteiros,arrecadadoInteiros,ingressosMeiosSobrantes,ingressosMeios,arrecadadoMeios);
    printf(""O total de ingressos vendidos foi de %i.\nO total de dinheiro arrecadado foi de R$%.2f"",tolalIngressosVendidos,totalArrecadado);
    return 0;
}
",51,1539,1782
"int contShow;

struct evento{
    char nome[20];
    float valorIngresso;
    int cadeiras;
    int disponiveis;
    float lucro;
    int meia;
};

struct evento show[10];

    
void cadastrarEvento(struct evento show[])
{   
    printf(""Informe o nome do evento:\n"");
    fflush(stdin);
    gets(show[contShow].nome);
    printf(""Informe o valor do ingresso: \n"");
    scanf(""%g"", &show[contShow].valorIngresso);
    printf(""Informe a quantidade de lugares disponiveis: \n"");
    scanf(""%d"", &show[contShow].cadeiras);
    show[contShow].disponiveis = show[contShow].cadeiras;
    show[contShow].lucro = 0;
    show[contShow].meia = 0;
}

void listarEventos(struct evento show[])
{
    int cont;
    
    for(cont = 0; cont < contShow; cont++)
    {   
        printf(""Evento: %s\n"", show[cont].nome);
        printf(""Valor da entrada: %g\n"", show[cont].valorIngresso);
        printf(""Lugares disponiveis: %d\n"", show[cont].disponiveis);
        printf(""Codigo: %d \n\n\n"", cont);
    }
}

float pagarDinheiroInt(int contSelec , float pagamento, struct evento show[])
{
    float troco;
    
    show[contSelec].lucro += (show[contSelec].valorIngresso * 0.9);
    troco = pagamento - (show[contSelec].valorIngresso * 0.9);
    show[contSelec].disponiveis--;
    
    return troco;
}

float pagarDinheiroMeia(int contSelec, float pagamento, struct evento show[])
{
    float troco;
    
    show[contSelec].lucro += (show[contSelec].valorIngresso * 0.9) / 2;
    troco = pagamento - (show[contSelec].valorIngresso * 0.9) / 2;
    show[contSelec].disponiveis--;
    show[contSelec].meia++;
    
    return troco;
}

void pagarCartaoInt(int contSelec, struct evento show[])
{
    show[contSelec].lucro += show[contSelec].valorIngresso;
    show[contSelec].disponiveis--;
}

void pagarCartaoMeia(int contSelec, struct evento show[])
{
    show[contSelec].lucro += show[contSelec].valorIngresso / 2;
    show[contSelec].disponiveis--;
    show[contSelec].meia++;
}

void informarDados(struct evento show[])
{
    int cont, vendidos;
    
    for(cont = 0; cont < contShow; cont++)
    {
        printf(""Evento: %s \n"", show[cont].nome);
        printf(""Total arrecadado: %g \n"", show[cont].lucro);
        vendidos = show[cont].cadeiras - show[cont].disponiveis;
        printf(""Ingressos totais vendidos: %d \n"", vendidos);
        printf(""Ingressos de meia entrada vendidos: %d \n"", show[cont].meia);
        printf(""Ingressos restantes: %d \n\n\n"", show[cont].disponiveis);
    }
}


    
int main(int argc, char *argv[]) {

    float pagamento, troco, restante;
    int menu, contOpera, contSelec;
    
    
    contSelec = 0;
    contShow = 0;
    contOpera = 0;

    while(contOpera <= 0)
    {

        printf(""Iniciando cadastro de eventos \n\n"");   
        printf(""Informe a opcao desejada:\n"");
        printf(""Digite 1 para cadastrar um evento \n"");
        printf(""Digite 2 iniciar vendas \n"");
    
        scanf(""%d"", &menu);
        
        switch(menu)
        {
            case 1:
            {
                cadastrarEvento(show);
                contShow++;
                system(""cls"");
                break;
            }
            case 2:
            {
                printf(""Iniciando operacao de vendas\n"");
                contOpera++;
                break;
            }
            default:
            {
                printf(""Informe uma opcao valida\n"");
                break;
            }       
        }   
        if(contShow >= 10)
        {
            printf(""Limite de eventos atingido, prosseguindo para venda de ingressos.\n"");
            contOpera++;
        }
    }


    while(contOpera <= 1)
    {
        do{
        printf(""Escolha o codigo do evento que deseja participar: \n"");
        listarEventos(show);
        scanf(""%d"", &contSelec);
        if(show[contSelec].disponiveis <= 0)
        {
            printf(""Ingressos para este evento estao esgotados, retornando para a selecao. \n"");
        }
        }while(show[contSelec].disponiveis <= 0);
        
        printf(""Informe a opcao desejada:\n"");
        printf(""Digite 1 para comprar um ingresso inteiro. \n"");
        printf(""Digite 2 para comprar meia entrada. \n"");
        printf(""Digite 3 para mudar o evento selecionado. \n"");
        printf(""Digite 4 para fechar as operacoes. \n"");
    
        scanf(""%d"", &menu);
        
        switch(menu)
        {
            case 1:
            {
                printf(""Escolha a forma de pagamento: \n"");
                printf(""Pressione 1 para pagamento em dinheiro com desconto ou 2 para pagamento em cartao.\n"");
                scanf(""%d"", &menu);
                switch(menu)
                {
                    case 1:
                    {
                        printf(""Valor a ser pago: %g\n"", (show[contSelec].valorIngresso * 0.9));            
                        printf(""Informe o valor do pagamento: "");
                        do
                        {
                            scanf(""%g"", &pagamento);
                            if(pagamento < (show[contSelec].valorIngresso * 0.9))
                            {
                                restante = (show[contSelec].valorIngresso * 0.9) - pagamento;
                                printf(""Valor inserido insufuciente, faltou %g, insira o valor correto para prosseguir.\n"", restante);  
                            }
                        }while(pagamento < (show[contSelec].valorIngresso * 0.9));
                        troco = pagarDinheiroInt(contSelec, pagamento, show);
                        printf(""Seu troco e de: %g\n"", troco);                      
                        break;
                    }
                    case 2:
                    {
                        pagarCartaoInt;
                        break;
                    }
                }
                system(""cls"");
                break;
            }
            
            case 2:
            {
                if(show[contSelec].meia <= show[contSelec].cadeiras * 0.4)
                {
                
                    printf(""Escolha a forma de pagamento: \n"");
                    printf(""Pressione 1 para pagamento em dinheiro com desconto ou 2 para pagamento em cartao.\n"");
                    scanf(""%d"", &menu);
                    switch(menu)
                    {
                        case 1:
                        {   
                            printf(""Valor a ser pago: %g\n"", (show[contSelec].valorIngresso * 0.9 / 2) );           
                            printf(""Informe o valor do pagamento: "");
                            do
                            {
                                scanf(""%g"", &pagamento);
                                if(pagamento < ((show[contSelec].valorIngresso * 0.9 / 2)))
                                {
                                    restante = ((show[contSelec].valorIngresso * 0.9 / 2) ) - pagamento;
                                    printf(""Valor inserido insufuciente, faltou %g, insira o valor correto para prosseguir.\n"", restante);  
                                }
                            }while(pagamento < ((show[contSelec].valorIngresso * 0.9 / 2) ));
                            troco = pagarDinheiroMeia(contSelec, pagamento, show);
                            printf(""Seu troco e de: %g \n"", troco); 
                            break;
                        }
                        case 2:
                        {
                            pagarCartaoMeia;
                            printf(""O pagamento foi efetuado com sucesso.\n"");
                            break;
                        }
                    }
                }
                else
                {
                    printf(""Ingressos para este evento estao esgotados. \n"");
                }
                system(""cls"");
                break;              
            }
            
            case 3:
            {
                printf(""Retornando para a selecao. \n"");    
                system(""cls"");          
                break;
            }
            case 4:
            {
                printf(""Encerrando operacao de vendas. \n"");
                contOpera++;
                break;
            }
            default:
            {
                printf(""Informe uma opcao valida. \n"");
                break;
            }
        }
    }
    
    printf(""Operacao de vendas encerradas.\n"");
    informarDados(show);
    
    return 0;
}
",51,1540,2626
"int main(int argc, char *argv[]) {
    
    char name[80];
    int lotMax; 
    int contLot;
    int tipEnt;
    int contPag;
    int contEsco;
    int contIntMax;
    int contInt;
    int contMeiaMax;
    int contMeia;
    float priceMeia;
    float pricePag;
    float troco;
    float lucro;
    float price;
    
    
    
    printf(""Digite o nome do evento (utilize de ( / ) para espaco):\n"");
    scanf(""%s"", &name);
    
    do{
        
    printf(""\nDigite a capacidade maxima de pessoas(somente multiplos de 5):\n"");
    scanf(""%i"" ,&lotMax);
    
    }while (lotMax%5!=0 || lotMax <= 0);
    
    do{
    
    printf(""\nDigite o preco do ingresso:\n"");
    scanf(""%f"" ,&price);
    
    }while (price<0);
    
    
    
    
    
    
    
    priceMeia=price/2;
    contLot=lotMax;
    lucro=0;
    contIntMax=lotMax*0.6;
    contInt=contIntMax;
    contMeiaMax=lotMax*0.4;
    contMeia=contMeiaMax;
    
    printf(""\n\nEvento: %s\n"" ,name);
    
    do{
        
        do{
            printf(""\nDigite 1 para comprar um ingresso inteira.\nDigite 2 para comprar um ingresso meia.\n"");
            scanf(""%i"" ,&tipEnt);
            
            switch(tipEnt){
            
                case 1:
                                    
                                                        
                    contEsco=0;
                                            
                    if(contInt>0){
                        
                        contLot--;
                        contInt--;
                        do{
                        
                            printf(""\nVoce deve pagar %f.\n"" ,price);
                            printf(""Digite o preco pago:\n"");
                            scanf(""%f"" ,&pricePag);
                            
                            if(pricePag<price){
                            
                                contPag=0;
                                printf(""\nVoce nao pagou o suficiente, pague novamente.\n"");
                                                    
                            }
                            
                            if(pricePag==price){
                                
                                contPag=1;
                                printf(""\nVoce efetuou seu pagamento, Obrigado e volte sempre\n"");
                                lucro=lucro+price;
                                                    
                            }
                            if(pricePag>price){
                                
                                contPag=1;
                                troco=pricePag-price;
                                printf(""\nVoce recebe de troco %f.\n\n"" ,troco);
                                lucro=lucro+price;
                                
                            }
                            
                        }while(contPag==0);
                        
                    
                    }
                    else{
                        
                        printf(""\nAcabou os ingressos do tipo inteiro.\n"");
                        
                    }
                    
                    break;
                case 2:
                    
                    contEsco=0;
                    
                    if(contMeia>0){
                        
                        contLot--;
                        contMeia--;
                        do{                         
                            printf(""\nVoce deve pagar %f.\n"" ,priceMeia);
                            printf(""Digite o preco pago:\n"");
                            scanf(""%f"" ,&pricePag);
                        
                            if(pricePag<priceMeia){
                            
                                contPag=0;
                                printf(""\nVoce nao pagou o suficiente, pague novamente.\n\n"");
                            
                            }
                            
                            if(pricePag==priceMeia){
                                
                                contPag=1;
                                printf(""\nVoce efetuou seu pagamento, Obrigado e volte sempre\n"");
                                lucro=lucro+priceMeia;
                                                    
                            }
                            if(pricePag>priceMeia){
                                
                                contPag=1;
                                troco=pricePag-priceMeia;
                                printf(""\nVoce recebe de troco %f.\n\n"" ,troco);
                                lucro=lucro+priceMeia;
                                
                            }
                            
                        }while(contPag==0);
                        
                    }
                    else{
                        
                        printf(""\nAcabou os ingressos do tipo meia.\n"");
                        
                    }
                    
                    break;
                    
                default:
                        
                    contEsco=1;
                    printf(""\nDigite novamente sua escolha.\n\n"");
                        
                    break;
                                    
            }
            
        }while(contEsco==1);
        
        printf(""\n\nEvento: %s\n"" ,name);
        printf(""\nAinda se tem %i ingressos do tipo inteiro.\n"" ,contInt);
        printf(""Ainda se tem %i ingressos do tipo meia.\n"" ,contMeia);
        printf(""Voce tem um lucro de %f.\n\n"" ,lucro);
        
    }while (contLot>0);
    
    printf(""\n\nEvento: %s\n"" ,name);   
    printf(""\nacabou os ingressos.\n"");
    printf(""voce teve um lucro total de %f.\n"" ,lucro);
    
    
    
    return 0;
}
",51,1541,1481
"int main(int argc, char *argv[]) {

    int modoJogo;
    int jogarNovamente;
    int jogador1;
    int jogador2;
    int ia;
    int empates;
    int vitoriasP1;
    float porcentvitP1;
    int vitoriasP2;
    float porcentvitP2;
    int vitoriasIA;
    float porcentvitIA;
    int contador;

    printf(""-^^- JOKENPO GAME by TS -^^- \n \n \n"");
    printf(""Digite o numero de uma das opcoes abaixo:\n 1 - Jogar Player Vs Player \n 2- Jogar Player Vs IA\n 3- Sair\n"");
    scanf(""%d"", &modoJogo);
    while(modoJogo != 1 && modoJogo !=2 && modoJogo !=3 ) {
        printf(""Opcao Invalida, digite uma opcao valida:\n 1 - Jogar Player Vs Player \n 2- Jogar Player Vs IA\n 3- Sair\n"");
        scanf(""%d"", &modoJogo);

    }
    switch (modoJogo) {
        case 1:
        printf("" -^^- MODO PLAYER VS PLAYER -^^- \n \n \n"");
        jogarNovamente=1;
        vitoriasP1=0;
        vitoriasP2=0;
        contador=0;
        do {
            printf(""Player 1 -> Digite sua opcao de jogada: \n 1 - PEDRA \n 2 - PAPEL \n 3 - TESOURA \n"");
            scanf(""%d"", &jogador1);
            while(jogador1 >3) {
                printf(""Jogada Invalida, por favor digite uma jogada valida:\n 1 - PEDRA \n 2 - PAPEL \n 3 - TESOURA \n"");
                scanf(""%d"", & jogador1);
            }
            printf(""Player 2 -> Digite sua opcao de jogada: \n 1 - PEDRA \n 2 - PAPEL \n 3 - TESOURA \n"");
            scanf(""%d"", &jogador2);
            while(jogador2 >3) {
                printf(""Jogada Invalida, por favor digite uma jogada valida:\n 1 - PEDRA \n 2 - PAPEL \n 3 - TESOURA \n"");
                scanf(""%d"", & jogador2);
            }

            if((jogador1 == 1 && jogador2 == 1) || (jogador1 == 2 && jogador2 == 2)|| (jogador1==3 && jogador2==3)) {
                printf(""EMPATOU! \n"");
                empates++;
                contador++;

            } else {
                if(jogador1 == 1 && jogador2 == 2) {
                    printf(""PEDRA E PAPEL = VITORIA JOGADOR 2! \n"");
                    vitoriasP2++;
                    contador++;

                } else {
                    if(jogador1==1 && jogador2 == 3) {
                        printf(""PEDRA E TESOURA = VITORIA JOGADOR 1! \n"");
                        vitoriasP1++;
                        contador++;

                    } else {
                        if(jogador1==2 && jogador2==1) {
                            printf(""PAPEL E PEDRA = VITORIA JOGADOR 1! \n"");
                            vitoriasP1++;
                            contador++;


                        } else {
                            if(jogador1==2 && jogador2==3) {
                                printf(""PAPEL E TESOURA = VITORIA JOGADOR 2! \n"");
                                vitoriasP2++;
                                contador++;


                            } else {
                                if(jogador1==3 && jogador2==1) {
                                    printf(""TESOURA E PEDRA = VITORIA JOGADOR 2! \n"");
                                    vitoriasP2++;
                                    contador++;

                                } else {
                                    printf(""TESOURA E PAPEL = VITORIA JOGADOR 1! \n"");
                                    vitoriasP1++;
                                    contador++;


                                }


                            }

                        }
                    }
                }

            }
            printf(""Deseja jogar Novamente? \n 1- Sim\n 2-Nao \n"");
            scanf(""%d"", &jogarNovamente);
            while(jogarNovamente >2) {
                printf(""Opcao Invalida, digite uma opcao valida:\n 1- Sim\n 2-Nao \n"");
                scanf(""%d"", &jogarNovamente);
            }
        } while(jogarNovamente ==1);
        printf(""ESTATISTICAS: \n"");
        printf(""Numero de Vezes Jogadas: %d \n"", contador);
        printf(""Numero de Empates: %d \n"", empates);
        if(vitoriasP1 == 0 && vitoriasP2 == 0) {
            printf(""Porcentagem de Vitorias PLAYER 1 = 0 \nPorcentagem de Vitorias PLAYER 2 = 0"");
        } else {

            porcentvitP1=(vitoriasP1*100)/(contador-empates);
            porcentvitP2=(vitoriasP2*100)/(contador-empates);
            printf(""Porcentagem de Vitorias PLAYER 1 = %f \n"", porcentvitP1);
            printf(""Porcentagem de Vitorias PLAYER 2 = %f \n"", porcentvitP2);
        }
        break;
    case 2:
        printf("" -^^- MODO PLAYER VS I.A -^^- \n \n \n"");
        jogarNovamente=1;
        vitoriasP1=0;
        vitoriasIA=0;
        contador=0;
        do {
            printf(""Player -> Digite sua opcao de jogada: \n 1 - PEDRA \n 2 - PAPEL \n 3 - TESOURA \n"");
            scanf(""%d"", &jogador1);
            while(jogador1 >3) {
                printf(""Jogada Invalida, por favor digite uma jogada valida:\n 1 - PEDRA \n 2 - PAPEL \n 3 - TESOURA \n"");
                scanf(""%d"", & jogador1);
            }
            srand(time(NULL));
            ia=(rand() % 3)+1;
            printf(""Jogada da maquina:\n %d\n"", ia);

            if((jogador1 == 1 && ia == 1) || (jogador1 == 2 && ia == 2)|| (jogador1==3 && ia==3)) {
                printf(""EMPATOU! \n"");
                empates++;
                contador++;

            } else {
                if(jogador1 == 1 && ia == 2) {
                    printf(""PEDRA E PAPEL = VITORIA MAQUINA! \n"");
                    vitoriasIA++;
                    contador++;

                } else {
                    if(jogador1==1 && ia == 3) {
                        printf(""PEDRA E TESOURA = VITORIA JOGADOR! \n"");
                        vitoriasP1++;
                        contador++;

                    } else {
                        if(jogador1==2 && ia==1) {
                            printf(""PAPEL E PEDRA = VITORIA JOGADOR! \n"");
                            vitoriasP1++;
                            contador++;


                        } else {
                            if(jogador1==2 && ia==3) {
                                printf(""PAPEL E TESOURA = VITORIA MAQUINA! \n"");
                                vitoriasIA++;
                                contador++;


                            } else {
                                if(jogador1==3 && ia==1) {
                                    printf(""TESOURA E PEDRA = VITORIA MAQUINA! \n"");
                                    vitoriasIA++;
                                    contador++;

                                } else {
                                    printf(""TESOURA E PAPEL = VITORIA JOGADOR! \n"");
                                    vitoriasP1++;
                                    contador++;


                                }


                            }

                        }
                    }
                }

            }
            printf(""Deseja jogar Novamente? \n 1- Sim\n 2-Nao \n"");
            scanf(""%d"", &jogarNovamente);
            while(jogarNovamente >2) {
                printf(""Opcao Invalida, digite uma opcao valida:\n 1- Sim\n 2-Nao \n"");
                scanf(""%d"", &jogarNovamente);
            }
        } while(jogarNovamente ==1);
        printf(""ESTATISTICAS: \n"");
        printf(""Numero de Vezes Jogadas: %d \n"", contador);
        printf(""Numero de Empates: %d \n"", empates);
        if(vitoriasP1 == 0 && vitoriasIA == 0) {
            printf(""Porcentagem de Vitorias PLAYER 1 = 0 \nPorcentagem de Vitorias PLAYER 2 = 0"");
        } else {

            porcentvitP1=(vitoriasP1*100)/(contador-empates);
            porcentvitIA=(vitoriasIA*100)/(contador-empates);
            printf(""Porcentagem de Vitorias PLAYER 1 = %f \n"", porcentvitP1);
            printf(""Porcentagem de Vitorias da MAQUINA = %f \n"", porcentvitIA);
        }
        break;
        case 3:
            exit(0);
            break;
        }

    system(""pause"");
    return 0;
}
",51,1542,2645
"struct data
{
    int dia;
    int mes;
    int ano;    
};



int main(int argc, char *argv[]) 
{
    int capacidadeMaxima, ingressoComprado, opcao, escolha, contInteira, tipo, contMeia, ingressosRestantes, formaPagamento;
    float entradaInteira, meiaEntrada, valorPagar, pagamento, totalPagar;
    char nomeEvento[30]; 
    struct data diaEvento;
    
    

    opcao = 2;
    
while(opcao == 2)
{
    printf(""Criar evento:\n"");
    printf(""\nDigite o nome do Evento: "");
    scanf(""%s"", &nomeEvento);
    printf(""\nDigite o data que o evento ira acontecer: "");
    scanf(""%d/%d/%d"", &diaEvento.dia, &diaEvento.mes, &diaEvento.ano);
    printf(""\nDigite a capacidade maxima: "");
    scanf(""%d"", &capacidadeMaxima);
    printf(""\nDigite o valor da entrada inteira: "");
    scanf(""%g"", &entradaInteira);   
        

    
    contInteira = 0;
    contMeia = 0;
    ingressoComprado = 0;
    
    system(""cls"");
    opcao = 0;
    
    
    
    while(opcao != 2)
    {
        system(""cls"");
        
        printf(""Menu\n"");
        printf(""\n(1) Comprar Ingressos \n"");
        printf(""(2) Sair \n\n"");
        printf(""Digite a opcao desejada: "");
        scanf(""%d"", &opcao);
        
        if((contInteira + contMeia) == capacidadeMaxima)
        {
            opcao = 0;
            printf(""Ingressos Esgotados !\n"");
            system(""pause"");
        }
        
        
        system(""cls"");
        
        
        
        if(opcao == 1)
        {
            ingressoComprado= 0;
            printf(""Nome do Evento: %s\n"", nomeEvento);
            printf(""Capacidade Maxima: %d\n"", capacidadeMaxima);
            printf(""O Valor da Entrada Inteira: %g\n\n"", entradaInteira);
            
            while(escolha !=1 && escolha !=2)
            {
                printf(""\nIngressos:\n"");
                printf(""\n(1) Entrada Inteira\n"");
                printf(""(2) Meia Entrada\n\n"");
                printf(""Escolha a opcao desejada: "");
                scanf(""%d"", &escolha);
                
                
                if(escolha == 1)
                {
                    valorPagar = entradaInteira;
                    printf(""\nValor a pagar: %g"", valorPagar);
                    contInteira++;
                }
                else if(escolha == 2)
                {
                    valorPagar = entradaInteira / 2;
                    printf(""\nValor a pagar: %g"", valorPagar);
                    contMeia++;
                }else
                {
                    printf(""\nOpcao Invalida!"");
                    
                }
            
            }
            escolha = 0;
            while(ingressoComprado == 0)
            {
                printf(""\n\nEscolha a Forma de Pagamento:\n"");
                printf(""\nDigite 1 para pagar em dinheiro ou 2 para pagar com cartao:"");
                scanf(""%d"", &tipo);
                
                while(tipo == 1 || tipo == 2)
                {
                
                    if(tipo == 1)
                    {
                        printf(""\nDigite o valor em dinheiro:"");
                        scanf(""%g"", &pagamento);
                        totalPagar = pagamento - valorPagar * 0.9;
                        
                        
                        
                        if(totalPagar < 0)
                        {
                            printf(""\nValor menor que valor total do ingresso\n\n"");
                            system(""pause"");
                        }
                        else 
                        {
                            printf(""\ntroco eh: %g"", totalPagar);
                            ingressoComprado++;
                            break;
                        }               
                    }
                    else
                    {
                        if(tipo == 2)
                        {
                            while(formaPagamento !=1 && formaPagamento !=2)
                            {
                            
                                printf(""\nPagamento sendo realizado no cartao!\n"");
                                printf(""\nDigite 1 para Debito!\n"");
                                printf(""\nDigito 2 para credito!\n"");
                                printf(""\nEscolha opcao desejada:"");
                                scanf(""%d"", &formaPagamento);
                                
                                if(formaPagamento == 1)
                                {
                                    printf(""\nPagamento realizado no debito!\n"");
                                    ingressoComprado++;
                                    
                                    
                                }
                                else if(formaPagamento == 2)
                                {       
                                    printf(""\nPagamento realizado no credito!\n"");
                                    ingressoComprado++;
                                
                                    
                                }else
                                {
                                    printf(""\nOpcao Invalida!\n"");
                                }
                            }
                            formaPagamento= 0;
                            
                        }
                        
                        break;
                    }
                    
                
                    
                }
            
            }
            
        
            printf(""\n\nIngresso Comprado\n\n"");
            system(""pause"");    
            
                                
        }
        else if(opcao == 2)
        {
            printf(""Total de ingressos: %d\n"", capacidadeMaxima);
            ingressosRestantes = capacidadeMaxima - ingressoComprado;
            printf(""\nSobraram: %d\n\n"", ingressosRestantes);
            printf(""Ingressos comprados Entrada Inteira: %d\n"", contInteira);
            printf(""\nIngressos comprados Meia Entrada: %d\n\n"", contMeia);
            system(""pause"");
        }
        
        system(""cls"");
    }
    
    
    
}
    return 0;
}
",51,1543,1673
"float valorIngresso, meiaEntrada;
int capacidadeMax, capacidadeMeia, capacidadeInteira, iComprados, mComprados, contEvento, evento;
char nomeEvento[31][30];
int capacidade[31];
float preco[31];
int capacidadeI[31], capacidadeM[31];

void cabecalho()
{
    printf(""\t____________________________________________________________\n"");
    printf(""\n"");
    printf(""\t| Ingresso++ - Meu sistema de gestao de venda de ingressos |\n"");
    printf(""\n"");
    printf(""\t____________________________________________________________\n"");
    printf(""\n"");
}


void cadastrarEvento()
{
    
    fflush(stdin);
    printf(""\t-Digite o nome do evento: "");
    gets(nomeEvento[contEvento]);
    
    fflush(stdin);

    printf(""\n\t-Informe a capacidade maxima de pessoas: "");
    scanf(""%d"", &capacidadeMax);
    capacidade[contEvento] = capacidadeMax;
        
    capacidadeMeia = 0.4*capacidadeMax;
    capacidadeInteira = 0.6*capacidadeMax;
    
    capacidadeI[contEvento] = capacidadeInteira;
    capacidadeM[contEvento] = capacidadeMeia;
            
    printf(""\n\t-Digite o valor de cada ingresso: "");
    scanf(""%g"", &valorIngresso);
    preco[contEvento] = valorIngresso;
                
            
        contEvento++;   
}

int selecionarEvento()
{
    int contadorLista, existeEvento;
    
    printf(""\t\t\t\t\t\tEventos Cadastrados: \n"");
    printf(""\n\t\t\tNOME\t\t \t\tCAPACIDADE\t\t \t\tPRECO\n\n"");
    for(contadorLista = 0; contadorLista < 31; contadorLista++)
    {
        if(capacidade[contadorLista] != 0)
        {
            printf(""%d)\t%s\t\t\t\t\t\t%d pessoa(s)\t\t\t\tR$%.2f\n"", contadorLista, nomeEvento[contadorLista], capacidade[contadorLista], preco[contadorLista]);
        }
    }
    
        printf(""\n\n Digite o numero do evento desejado: "");
        scanf(""%d"", &evento);
        
        if(capacidade[evento] != 0)
        {
            capacidadeMax = capacidade[evento];
            valorIngresso = preco[evento];
            capacidadeInteira = capacidadeI[evento];
            capacidadeMeia = capacidadeM[evento];
            
            
            
            existeEvento = 1;
        }
            else
            {
                existeEvento = 0;
            }
    
    return existeEvento;
    
}


int escolherIngresso()
{   
    int tipoIngresso;
    

    meiaEntrada = valorIngresso*0.5;
    
        printf(""\t_______________________________________\n"");
        printf(""\n\t| ADQUIRA SEU INGRESSO PARA O EVENTO. |\n"");
        printf(""\t_______________________________________\n"");
            
        printf(""\n\t\tO valor do evento eh: R$%.2f \n\t\t(Meia entrada: R$%.2f)\n"", valorIngresso, meiaEntrada);    
                        
        printf(""\nEscolha o tipo de ingresso:\n"");
        printf(""\n\t-Digite 1 para inteira.\n"");
        printf(""\t-Digite 2 para meia.\n\n\t\t"");   
        scanf(""%d"", &tipoIngresso); 
        
        return tipoIngresso;
}

void comprarIngresso(int ingresso, float desconto)
{
    
    float valorPago, troco;
    
    
        
        switch (ingresso) 
        {
        case 1: 
            if(capacidadeInteira > 0)
            {           
        
                printf(""\n\nInsira o dinheiro: "");
                scanf(""%g"", &valorPago);
                                        
                if (valorPago < (valorIngresso - (valorIngresso*desconto)))
                {
                    printf(""Valor pago insuficiente!\n"");                       
                }
                    else
                    {
                        if (valorPago > (valorIngresso -(valorIngresso*desconto)))
                        {
                            troco = valorPago - (valorIngresso - (valorIngresso*desconto));                                 
                            printf(""\nSeu troco eh: R$%g\n"", troco);                            
                        }
                    printf(""\nCompra concluida!\n"");                
                    
                    capacidadeInteira--;
                    capacidadeI[evento] = capacidadeInteira;
                                        
                    printf(""\nevento: %d"", capacidadeI[evento]);
                    printf(""\n\tInteiros restantes: %d\n"", capacidadeInteira);
                    
                    iComprados = (capacidadeMax*0.6)-capacidadeInteira;
                    printf(""\n\tInteiros comprados: %d\n"", iComprados);
                        
                
                    }
            }
            else
                {
                    printf(""\t\t\nEntradas inteiras esgotadas!\n"");
                }
        break;
        case 2: 
            if(capacidadeMeia > 0)
            {
                            
                printf(""Insira o dinheiro: "");
                scanf(""%g"", &valorPago);
                    
                if (valorPago < (meiaEntrada - (meiaEntrada*desconto)))
                {
                    printf(""Valor pago insuficiente!\n"");                       
                }
                    else
                    {
                        if (valorPago > (meiaEntrada - (meiaEntrada*desconto)))
                        {
                            troco = valorPago - (meiaEntrada - (meiaEntrada*desconto));                                 
                            printf(""\nSeu troco eh: R$%g\n"", troco);                            
                        }
                        printf(""\nCompra concluida!\n"");
                                            
                    capacidadeMeia--;
                    capacidadeM[evento] = capacidadeMeia;
                                    
                    printf(""\n\tMeia entrada restantes: %d\n"", capacidadeMeia);
                    
                    mComprados = (capacidadeMax*0.4)-capacidadeMeia;
                    printf(""\n\tMeia entrada compradas: %d\n"", mComprados);
                    
                    capacidadeM[evento] = capacidadeMeia;
                    }   
            }
                else
                {
                    printf(""\t\t\nMeias entradas esgotadas!\n"");
                }
                            
        break; 
        default:
            printf(""Opcao invalida.\n"");
        break;
        }
}

void menuIngresso()
{                       
    int pagamento, existeEvento;
        
    if (capacidadeMax == 0)
    {
        printf(""Nao ha evento cadastrado\n"");   
    }
        else
        {   
            existeEvento = selecionarEvento();
            
            if(existeEvento == 1)   
            {
                printf(""\n\t\t\t\t(10%% de desconto no dinheiro)\n\n"");
                printf(""\n Digite 1 para pagamento no cartao: "");           
                printf(""\n Digite 2 para pagamento em dinheiro: \n\t"");
                scanf(""%d"", &pagamento);
            
            
                if(pagamento == 1)
                {           
                comprarIngresso(escolherIngresso(), 0);
                }
                    else
                    {
                        comprarIngresso(escolherIngresso(), 0.1);
                    }
            }
                else
                {
                    printf(""\n\n\tNao existe esse evento!\n"");
                }   
        }
}





int main(int argc, char *argv[]) 
{
    int opcao, loop;
    
    contEvento = 0;
    loop = 0;   
    
    cabecalho();
    
    while(loop == 0)
    {
    
    
        printf(""\n"");           
        printf(""\n1) Cadastro de Evento.\n"");       
        printf(""2) Compre seu ingresso.\n"");    
        printf(""3) Sair.\n"");
        printf(""\n"");       
            
        printf(""Digite a opcao desejada: "");
        scanf(""%d"", &opcao);
        printf(""\n"");
    
        switch (opcao)
        {
            case 1:
                cadastrarEvento();
            break;
            case 2: 
                menuIngresso();
            break;
            case 3:
                loop = 1;
            break;
            default:
                printf(""Opcao invalida!\n"");
            break;
            
        }   
    }
    
    
    return 0;
}
",51,1544,2471
"#define TAM 6





char validarDados (char vetorUsuario[TAM])
{
    int resultado = 0;
    
    if (strlen(vetorUsuario) > TAM)
    {
        system (""COLOR C"");
        printf (""\n\nERRO! Caracteres digitados em excesso. Tente novamente."");
        sleep(3);
        resultado = 1;
        system(""cls"");
    }
    return resultado;
}



char compararCaptcha (char vetorCaptcha[TAM], char vetorUsuario[TAM])
{
    int resultado;
    
    resultado = strcmp (vetorCaptcha, vetorUsuario);
    return resultado;
}



int exibirResultado (int comparacao)
{
    if (comparacao == 0)
    {
        printf (""\n\nCaracteres digitados corretamente!"");
    }else
    {
        system (""COLOR C"");
        printf (""\n\nERRO! Caracteres digitados de forma incorreta. Tente novamente.\n\n"");
        sleep(3);
        comparacao = 1;
        system(""cls"");
    }
    return comparacao;
}



int main(int argc, char *argv[]) {
    char vetorCaptcha[TAM];
    char vetorUsuario[TAM];
    int captcha;
    int validacaoDados;
    int comparacao;
    int resultado;
    int cont;
    
    srand(time(NULL));
    do 
    {
        system (""COLOR F"");
        system (""cls"");
        printf (""Teste de Turing.\n\n"");
        for (cont = 0; cont < 6; cont++)
        {
            do
            {
                captcha = (rand() % 122);
            }
            while (captcha <= 48 || captcha >= 57 && captcha <= 97 || captcha >= 122);
            vetorCaptcha[cont] = captcha;
            printf (""%c "", vetorCaptcha[cont]);
        }
        system (""COLOR F"");
        printf (""\n\nDigite os caracteres acima: "");
        gets(vetorUsuario);
        validacaoDados = validarDados (vetorUsuario);
        if (validacaoDados == 0)
        {
            comparacao = compararCaptcha (vetorCaptcha, vetorUsuario);
            resultado = exibirResultado (comparacao);
            if (resultado == 1)
            {
                validacaoDados = resultado;
                printf (""%d"", validacaoDados);
            }   
        }
    }
    while (validacaoDados != 0);
    return 0;
}
",51,1545,720
"void main(){
    char nome [60];
    int capacidadeMax, operacao, disponivelMeia, confirmacao, vendidoMeia, vendidoInteira;
    float valorInteira, meiaEntrada, valorTotal, troco;
    vendidoMeia = 0;
    vendidoInteira = 0;
        
    printf(""Ingressos++_Meu sistema de gestao de vendas de ingressos. \n"");
    printf(""\n\n Cadastre o seu evento. \n"");
    printf(""Nome do evento: \n"");
    gets(nome);
    printf(""Valor da entrada: \n"");
    scanf(""%f"", &valorInteira);
    meiaEntrada = valorInteira/2;
    printf(""Capacidade maxima do local: \n"");
    scanf(""%d"", &capacidadeMax);
    disponivelMeia = capacidadeMax*0.4;
    
    printf(""\n\n Evento: %s \n"", nome);
    printf(""Capacidade maxima de %d lugares \n"", capacidadeMax);
    printf(""Valor da entrada Inteira: %g \n"",valorInteira);
    printf(""Valor da Meia entrada: %g \n"",meiaEntrada);
                
    while(operacao != 3){
    
    printf(""\n\n Para comprar o seu ingresso escolha: \n"");
    printf(""[1] - Valor inteiro \n"");
    printf(""[2] - Meia entrada \n"");
    printf(""[3] - Finalizar vendas \n"");
    scanf(""%d"", &operacao);
    switch(operacao){
        case 1:
            
            if(capacidadeMax > 0){
            
                         
                printf(""Valor da compra: %g"", valorInteira);
                printf(""\n\n Concluir: \n"");
                printf(""[1] - SIM \n"");
                printf(""[2] - NAO \n"");
                scanf(""%d"", &confirmacao);
                
                if(confirmacao == 1)
                    printf(""\n Valor do ingresso: %g"", valorInteira);
                    printf(""\n Digite o valor pago: \n"");
                    scanf(""%g"", &valorTotal);
                    if(valorTotal >= valorInteira){
                                    
                    troco = valorTotal - valorInteira;
                    printf(""\n troco: %g \n"", troco);
                
                }else{
                    printf(""Valor insuficiente para concluir a compra."");
                    break;
                }   
                    printf(""\n Compra efeituada com exito."");
                    capacidadeMax = capacidadeMax - 1;
                    vendidoInteira++;
                                        
                    break;
                    
                }else{
                    printf(""Ingressos esgotados. \n"");
                    break;
                }
            
                    
        case 2:
            if(disponivelMeia > 0){
                
                printf(""\n Valor do ingresso: %g"", meiaEntrada);
                printf(""\n Confirmar: \n"");
                printf(""[1] - SIM \n"");
                printf(""[2] - NAO \n"");
                scanf(""%d"", &confirmacao);
                
                if(confirmacao == 1){
                    printf(""\n Valor do ingresso: %g"",meiaEntrada);
                    printf(""\n Digite o valor pago: \n"");
                    scanf(""\n %g"", &valorTotal);
                                                        
                    if(valorTotal >= meiaEntrada){
                    
                    troco = valorTotal - meiaEntrada;
                    printf(""\n troco: %g \n\n"", troco);
                    
                    printf(""Compra comcluida com exito. \n"");
                    disponivelMeia = disponivelMeia - 1;
                    capacidadeMax = capacidadeMax - 1;
                    vendidoMeia++;
                    break;
                        
                    }else{
                        printf(""\n quantia insuficiente"");
                        break;
                    }   
                                                
                }else{
                printf(""Ingressos de meia entrada esgotados. \n"");
                break;
                }
            }
        
        case 3: 
                printf(""\nTotal de ingressos tipo inteira vendido: %d \n"", vendidoInteira);
                printf(""Total de ingressos tipo meia vendido: %d \n"", vendidoMeia);
                printf(""Ingressos disponiveis: %d \n"", capacidadeMax);
                            
                break;
                
        default: 
            
                printf(""Opcao invalida."");  
            
                break;
            
    }
}

}









    
    

",51,1546,1238
"int main(void) {
    
    srand (time(NULL));
    
    int jogarNovamente;
    int jogarNovamente2;
    int jogarMais = 1;
    int escolhaJogo;
    int jogador1;
    int jogador2;
    int jogadaComputador;
    int linha;
    
    
    
    int pontosJogador1 = 0;
    int pontosJogador2 = 0;
    int pontosComputador = 0;
    int empate = 0;
    int totalJogadas;
    float porcentagemJogador1;
    float porcentagemJogador2;
    float porcentagemComputador;
    
    printf(""\n                              JOKENPO ULTIMATE!\n\n"");
    printf(""\n                    Digite >1< para jogar contra o computador.\n"");
    printf(""                    Digite >2< para jogar contra outro humano.\n\n"");
    printf(""                                     >"");
    scanf("" %d"", &escolhaJogo);
    
    while(jogarMais > 0){
    
        jogadaComputador = rand()%3+1;
    
        if(escolhaJogo == 1){ 
    
        printf(""\n                          Para jogar PEDRA digite    >1<\n"");
        printf(""                          Para jogar PAPEL digite    >2<\n"");
        printf(""                          Para jogar TESOURA digite  >3<\n\n"");
        
        printf(""\n                          HUMANO X COMPUTADOR, BOA SORTE!!"");
        printf(""\n                                Faca a sua jogada: \n\n"");
        printf(""                                     >"");
        scanf("" %d"", &jogador1);
        
            if(jogador1 >=1 && jogador1 <=3){ 
            
                printf(""\n                                  JO"");
                sleep(1);
                printf(""KEN"");
                sleep(1);
                printf(""PO!!! \n\n"");
                sleep(1);
                
                for( linha = 0; linha < 35; linha++){ 
                    printf( ""\n"" );
                }
                
                switch(jogador1){ 
                    case 1:
                        printf(""                                 PEDRA x "");
                        break;
                    case 2:
                        printf(""                                 PAPEL x "");
                        break;
                    case 3:
                        printf(""                                TESOURA x "");
                        break;
                }
            
                switch(jogadaComputador){ 
                    case 1:
                        printf(""PEDRA \n\n"");
                        break;
                    case 2:
                        printf(""PAPEL \n\n"");
                        break;
                    case 3:
                        printf(""TESOURA \n\n"");
                        break;
                }
                
                if ((jogador1 == 1 && jogadaComputador == 3) || (jogador1 == 2 && jogadaComputador == 1) || (jogador1 == 3 && jogadaComputador == 2)){ 
                
                    printf(""                                 VOCE VENCEU!!! \n\n"");
                    
                    pontosJogador1 = pontosJogador1 + 1;
                
                }
                
                if (jogador1 == jogadaComputador){ 
                    
                    printf(""                                    EMPATE! \n\n"");
                    
                    empate++;
                    
                }
                
                if ((jogadaComputador == 1 && jogador1 == 3) || (jogadaComputador == 2 && jogador1 == 1) || (jogadaComputador == 3 && jogador1 == 2)){ 
                
                    printf(""                                 VOCE PERDEU :( \n\n"");
                
                    pontosComputador = pontosComputador + 1;
                
            }
        } else { 
            
            printf(""\n                        Voce nao digitou um numero valido. \n"");
            
        }
        
        }
        
        if(escolhaJogo == 2){  
            
            printf(""\n                          Para jogar PEDRA digite    >1<\n"");
            printf(""                          Para jogar PAPEL digite    >2<\n"");
            printf(""                          Para jogar TESOURA digite  >3<\n\n"");
        
            printf(""\n                          HUMANO X HUMANO, BOA SORTE!!"");
            printf(""\n\n                          JOGADOR 1 Faca a sua jogada: \n\n"");
            printf(""                                     >"");
            scanf("" %d"", &jogador1);
            
            if(jogador1 >= 1 && jogador1 <= 3){
            
                for( linha = 0; linha < 35; linha++){ 
                    printf( ""\n"" );
                }
                
                printf(""\n                          Para jogar PEDRA digite    >1<\n"");
                printf(""                          Para jogar PAPEL digite    >2<\n"");
                printf(""                          Para jogar TESOURA digite  >3<\n\n"");
                
                printf(""\n                          HUMANO X HUMANO, BOA SORTE!!"");
                printf(""\n\n                          JOGADOR 2 Faca a sua jogada: \n\n"");
                printf(""                                     >"");
                scanf("" %d"", &jogador2);
                
                if(jogador2 >= 1 && jogador2 <= 3) {
                    
                    printf(""\n                                  JO"");
                    sleep(1);
                    printf(""KEN"");
                    sleep(1);
                    printf(""PO!!! \n\n"");
                    sleep(1);
                
                    for( linha = 0; linha < 35; linha++){ 
                        printf( ""\n"" );
                    }
                    
                    switch(jogador1){ 
                    case 1:
                        printf(""                                 PEDRA x "");
                        break;
                    case 2:
                        printf(""                                 PAPEL x "");
                        break;
                    case 3:
                        printf(""                                TESOURA x "");
                        break;
                    }
                    
                    switch(jogador2){ 
                    case 1:
                        printf(""PEDRA \n\n"");
                        break;
                    case 2:
                        printf(""PAPEL \n\n"");
                        break;
                    case 3:
                        printf(""TESOURA \n\n"");
                        break;
                    }
                    
                    if ((jogador1 == 1 && jogador2 == 3) || (jogador1 == 2 && jogador2 == 1) || (jogador1 == 3 && jogador2 == 2)){ 
                
                        printf(""                               JOGADOR 1 VENCEU! \n\n"");
                        
                        pontosJogador1 = pontosJogador1 + 1;
                
                    }
                
                    if (jogador1 == jogador2){ 
                    
                        printf(""                                    EMPATE! \n\n"");
                        
                        empate++;
                    
                    }
                
                    if ((jogador2 == 1 && jogador1 == 3) || (jogador2 == 2 && jogador1 == 1) || (jogador2 == 3 && jogador1 == 2)){ 
                
                        printf(""                               JOGADOR 2 VENCEU! \n\n"");
                        
                        pontosJogador2 = pontosJogador2 + 1;
                
                    }
            
                } else { 
            
                    printf(""\n                        Voce nao digitou um numero valido. \n"");
            
                }
        
            } else { 
            
                printf(""\n                        Voce nao digitou um numero valido. \n"");
            
            }
    
        }
        
        if(escolhaJogo > 2){  
            
            printf(""\n              Voce nao digitou um numero valido. Reinicie o jogo. \n"");
            exit(0);
            
        }

        printf(""\n\n\n\n\n\n\n\n                          Para jogar novamente digite >1< \n"");
        printf(""                          Para estatisticas digite    >2< \n"");
        printf(""                          Para sair digite            >3< \n\n"");
        printf(""                                     >"");
        scanf("" %d"", &jogarNovamente);
        
        if(jogarNovamente == 1){ 
            
            for( linha = 0; linha < 35; linha++){ 
                    printf( ""\n"" );
                }
            
        }

        if(jogarNovamente == 2){ 
            
            for( linha = 0; linha < 35; linha++){ 
                    printf( ""\n"" );
            }
            
            totalJogadas = pontosJogador1 + pontosJogador2 + pontosComputador + empate;
            
            printf(""\n                                 ESTATISTICAS!\n\n"");
            printf(""                          Vitorias do Jogador 1:     >%d< \n"", pontosJogador1);
            
            if(pontosJogador2 > 0){
                
                printf(""                      Vitorias do Jogador 2:     >%d< \n\n"", pontosJogador2);
                printf(""                      Empates:                   >%d< \n\n"", empate);
                
                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;
                porcentagemJogador2 = ((float)pontosJogador2 / (float)totalJogadas) * 100;
                
                printf(""                  Porcentagem de vitorias do Jogador 1:     >%.1f< \n"", porcentagemJogador1);
                printf(""                  Porcentagem de vitorias do Jogador 2:     >%.1f< \n"", porcentagemJogador2);
            
            }
            
            if(pontosComputador > 0){
                
                printf(""                          Vitorias do Computador:    >%d< \n\n"", pontosComputador);
                printf(""                          Empates:                   >%d< \n\n"", empate);
                
                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;
                porcentagemComputador = ((float)pontosComputador / (float)totalJogadas) * 100;
                
                printf(""                  Porcentagem de vitorias do Jogador 1:     >%.1f< \n"", porcentagemJogador1);
                printf(""                  Porcentagem de vitorias do Computador:    >%.1f< \n"", porcentagemComputador);
                
            }
            
            if(pontosJogador2 == 0 && pontosComputador == 0){
                
                if(escolhaJogo == 1){
                    
                    printf(""                          Vitorias do Computador:    >%d< \n\n"", pontosComputador);
                    
                }
                
                if(escolhaJogo == 2){
                    
                    printf(""                          Vitorias do Jogador 2:     >%d< \n\n"", pontosJogador2);
                    
                }
                
                if(empate > 0){
                    
                        printf(""                          Empates:                   >%d< \n\n"", empate);
                        
                }
                
                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;
                printf(""                  Porcentagem de vitorias do Jogador 1:     >%.1f< \n\n"", porcentagemJogador1);
                
            }
            
            for( linha = 0; linha < 13; linha++){ 
                    printf( ""\n"" );
            }
            
            printf(""                          Para jogar novamente digite >1< \n"");
            printf(""                          Para sair digite            >2< \n\n"");
            printf(""                                     >"");
            scanf("" %d"", &jogarNovamente2);
            
            if(jogarNovamente2 == 1){ 
                
                for( linha = 0; linha < 35; linha++){ 
                
                    printf( ""\n"" );
                    
                }
                
            }
            
            if(jogarNovamente2 == 2){ 
                
                exit(0);
                
            }
            
            if(jogarNovamente2 >= 3){
                
                printf(""\n              Voce nao digitou um numero valido. Reinicie o jogo. \n"");
                exit(0);
                
            }
            
        }
        
        if(jogarNovamente == 3){
        
            exit(0);
            
        }
        
        if(jogarNovamente >= 4){
            
            printf(""\n              Voce nao digitou um numero valido. Reinicie o jogo. \n"");
            exit(0);
            
        }
         
    }
    
    return 0;
}
",51,1547,3438
"char gerarCaptcha[6];

char gerado()
{
    int cont=0;
    int num=0;
    
    srand(time(NULL));
    while(cont<6)
    {
        if (cont == 4 || cont == 5)
        {
            gerarCaptcha[cont] = 48 + rand() % 9;
        }
        else if(cont == 1 || cont == 3)
        {
            gerarCaptcha[cont] = 97 + rand() % 26;
        }
        else if(cont == 0 || cont == 2)
        {
            gerarCaptcha[cont] = 65 + rand() % 26;
        }

        cont++;
    }
    
    
    printf(""%s\n"", gerarCaptcha);
}


int main(int argc, char *argv[]) {
    
    char captchaDigitado[6];
    int continuar = 1;
    
    while(continuar = 1)
    {
        printf(""CAPTCHA\n\n"");
        printf(""Captcha gerado:\n"");
        gerado();
        printf(""\n"");
        printf(""Digite o Captcha gerado:\n"");
        gets(captchaDigitado);
        printf(""\n"");
        
        if(strcmp (captchaDigitado, gerarCaptcha) == 0)
        {
            printf(""Captcha correto.\n\n"");
        }else{
            printf(""Captcha incorreto.\n\n"");
        }
        system(""pause"");
        system(""cls"");
    }
    
    
    return 0;
}
",51,1548,412
"int main(int argc, char *argv[]) {
    char opcaoMenu;
    char opcaoJogarNovamnt;
    char opcaoJogador1;
    char opcaoJogador2;
    int opcaoJogador3;
    int opcaoComputador;
    char nomeJogador1[15];
    char nomeJogador2[15];
    char nomeJogador3[15];
    char nomeComputador[15];
    int empates = 0;
    float vitoriasJogador1 = 0;
    float vitoriasJogador2 = 0;
    float vitoriasJogador3 = 0;
    float vitoriasComputador = 0;
    float percentVitJog1;
    float percentVitJog2;
    float percentVitJog3;
    float percentVitComp;
    int totalPartidas = 0;
    
    system (""COLOR 0F"");
    system (""cls"");
    printf (""Bem vindo ao jogo JOKENPO!"");
    printf (""\n\nDigite 1 para o modo Humano X Humano."");
    printf (""\nDigite 2 para o modo Humano X Computador."");
    printf (""\nDigite 3 para sair do jogo."");
    printf (""\n\nEscolha o modo de jogar: "");
    opcaoMenu = getch();
    switch (opcaoMenu)
        {
        case '1':
            system(""cls"");
            system (""COLOR 0E"");
            printf (""Jogo Jokenpo: Modo Humano X Humano."");
            printf (""\n\nJogador 1 - Digite seu nome: "");
            scanf (""%s"", &nomeJogador1);
            printf (""\nJogador 2 - Digite seu nome: "");
            scanf (""%s"", &nomeJogador2);
            do
            {
                system(""cls"");
                printf (""Jogo Jokenpo - Modo Humano X Humano."");
                printf (""\n\nDigite 1 para PEDRA."");
                printf (""\nDigite 2 para PAPEL."");
                printf (""\nDigite 3 para TESOURA."");
                printf (""\n\n%s - Escolha o que vai jogar: "", nomeJogador1);
                opcaoJogador1 = getch();
                printf (""\n\n%s - Escolha o que vai jogar: "", nomeJogador2);
                opcaoJogador2 = getch();
                if (opcaoJogador1 == opcaoJogador2)
                {
                    printf (""\n\n%s e %s, voces EMPATARAM!"", nomeJogador1,nomeJogador2);
                    empates++;
                }else
                {
                    if (opcaoJogador1 == '1' && opcaoJogador2 == '3')
                    {
                        printf (""\n\nVitoria %s! Pedra quebra a tesoura."", nomeJogador1);
                        vitoriasJogador1++;                         
                    }else
                    {
                        if (opcaoJogador1 == '2' && opcaoJogador2 == '1')
                        {
                            printf (""\n\nVitoria %s! Papel embrulha a pedra."", nomeJogador1);
                            vitoriasJogador1++; 
                        }else
                        {
                            if (opcaoJogador1 == '3' && opcaoJogador2 == '2')
                            {
                                printf (""\n\nVitoria %s! Tesoura corta o papel."", nomeJogador1);
                                vitoriasJogador1++;
                            }else
                            {
                                if (opcaoJogador1 == '1' && opcaoJogador2 == '2')
                                {
                                    printf (""\n\nVitoria %s! Papel embrulha a pedra."", nomeJogador2);
                                    vitoriasJogador2++;
                                }else
                                {
                                    if (opcaoJogador1 == '2' && opcaoJogador2 == '3')
                                    {
                                        printf (""\n\nVitoria %s! Tesoura corta o papel."", nomeJogador2);
                                        vitoriasJogador2++;
                                    }else
                                    {
                                        printf (""\n\nVitoria %s! Pedra quebra a tesoura."", nomeJogador2);
                                        vitoriasJogador2++;
                                    }
                                }
                            }
                        }
                    }
                }   
                sleep(2);
                totalPartidas++;
                printf (""\n\n\nDeseja jogar novamente? S/N"");
                opcaoJogarNovamnt = getch();
            }
            while (opcaoJogarNovamnt == 's');
            break;
        case '2':
            system (""COLOR 0A"");
            system(""cls"");
            printf (""Jogo Jokenpo - Modo Humano X Computador."");
            printf (""\n\nJogador - Digite seu nome: "");
            scanf (""%s"", &nomeJogador3);
            printf (""\n%s - Digite um nome para o computador: "",nomeJogador3);
            scanf (""%s"", &nomeComputador);
            do
            {
                system(""cls"");
                printf (""Jogo Jokenpo - Modo Humano X Computador."");
                printf (""\n\nDigite 1 para PEDRA."");
                printf (""\nDigite 2 para PAPEL."");
                printf (""\nDigite 3 para TESOURA."");
                printf (""\n\n%s - Escolha o que vai jogar: "", nomeJogador3);
                scanf (""%d"", &opcaoJogador3);
                printf (""\n%s: Escolha o que vai jogar:"", nomeComputador);
                sleep (2);
                srand((unsigned)time(NULL));
                opcaoComputador = (rand() % 3 + 1);
                if (opcaoJogador3 == opcaoComputador)
                {
                    printf (""\n\n%s e %s, voces EMPATARAM!"", nomeJogador3,nomeComputador);
                    empates++;
                }else
                {
                    if (opcaoJogador3 == 1 && opcaoComputador == 3)
                    {
                        printf (""\n\nVitoria %s! Pedra quebra a tesoura."", nomeJogador3);
                        vitoriasJogador3++;                         
                    }else
                    {
                        if (opcaoJogador3 == 2 && opcaoComputador == 1)
                        {
                            printf (""\n\nVitoria %s! Papel embrulha a pedra."", nomeJogador3);
                            vitoriasJogador3++; 
                        }else
                        {
                            if (opcaoJogador3 == 3 && opcaoComputador == 2)
                            {
                                printf (""\n\nVitoria %s! Tesoura corta o papel."", nomeJogador3);
                                vitoriasJogador3++;
                            }else
                            {
                                if (opcaoJogador3 == 1 && opcaoComputador == 2)
                                {
                                printf (""\n\nVitoria %s! Papel embrulha a pedra."", nomeComputador);
                                vitoriasComputador++;
                                }else
                                {
                                    if (opcaoJogador3 == 2 && opcaoComputador == 3)
                                    {
                                        printf (""\n\nVitoria %s! Tesoura corta o papel."", nomeComputador);
                                        vitoriasComputador++;
                                    }else
                                    {
                                        printf (""\n\nVitoria %s! Pedra quebra a tesoura."", nomeComputador);
                                        vitoriasComputador++;
                                    }
                                }
                            }
                        }
                    }
                }
                sleep (2);
                totalPartidas++;
                printf (""\n\n\nDeseja jogar novamente? S/N"");
                opcaoJogarNovamnt = getch();
            }
            while (opcaoJogarNovamnt == 's');
            break;
        case '3':
            system (""COLOR 0F"");
            printf (""\n\nSaindo do jogo..."");
            return 0;
        default:
            system (""COLOR 0F"");
            printf (""\n\nOpcao invalida. Saindo do jogo..."");
            return 0;
        }
    system(""cls"");
    system (""COLOR 0F"");
    if (totalPartidas == 1 && empates == 1)
    {
        printf (""Jogo Jokenpo. Resultados: Modo Humano X Humano."");
        printf (""\n\nTotal de partidas: %d"", totalPartidas);
        printf (""\nTotal de empates: %d"", empates);
        printf (""\n\nNao houve ganhador."");
    }else
    {
        if (opcaoMenu == '1')
        {
            printf (""Jogo Jokenpo. Resultados: Modo Humano X Humano."");
            printf (""\n\nTotal de partidas: %d"", totalPartidas);            printf (""\nTotal de empates: %d"", empates);
            printf (""\n\n%s:\nPercentual de vitorias: %.1f"", nomeJogador1,percentVitJog1 = (vitoriasJogador1 / (totalPartidas - empates)) * 100);
            printf (""\n\n%s:\nPercentual de vitorias: %.1f\n\n"", nomeJogador2,percentVitJog2 = (vitoriasJogador2 / (totalPartidas - empates)) * 100);   
        }
        else
        {
            if (opcaoMenu == '2')
            printf (""Jogo Jokenpo. Resultados: Modo Humano X Computador."");
            printf (""\n\nTotal de partidas: %d"", totalPartidas);
            printf (""\nTotal de empates: %d"", empates);
            printf (""\n\n%s:\nPercentual de vitorias: %.1f"", nomeJogador3,percentVitJog3 = (vitoriasJogador3 / (totalPartidas - empates)) * 100);
            printf (""\n\n%s:\nPercentual de vitorias: %.1f\n\n"", nomeComputador,percentVitComp = (vitoriasComputador / (totalPartidas - empates)) * 100);
        }
    }
return 0;
}
",51,1549,2770
"#define CAPTCHA 6



int loop = 1;


char * gerarCaptcha(char valor[CAPTCHA]) {
    
    int cont;
    int randomico;
    
    srand(time(NULL));
    
    for(cont = 0; cont < CAPTCHA; cont++){
        
        randomico = ((rand() % 122) + 1);
        
        if ((randomico >= 48 && randomico <= 57) || (randomico >= 65 && randomico <= 90) || (randomico >= 97 && randomico <= 122)) {
            
            valor[cont] = randomico;
            
        }else{
            
            cont--;
            
        }
        
    }
    
    return valor;
    
}


void trasformarCaptcha(char novaString[CAPTCHA], char digitado[CAPTCHA]) {
    
    strcpy(novaString, digitado);
    
}


void comparaCaptcha(char valor[CAPTCHA], char digitado[CAPTCHA]){
    
    if (strcmp(valor, digitado) == 0) {
        
        printf(""Obrigado, esta confirmado que voce nao e um robo!\n"");
        
        loop = 0;
        
    } else {
        
        printf(""CAPTCHA digitado incorretamente, por favor tente novamente.\n"");
        
    }
    
}


int main(void) {
    
    char valor[CAPTCHA], *retorno, digitado[CAPTCHA], copia[CAPTCHA + 1];
    
    while (loop == 1) {
        
        retorno = gerarCaptcha(valor);
        
        trasformarCaptcha(copia, retorno);
        
        printf(""%s"", retorno);
        
        printf(""\nDigite a CAPTCHA: "");
        gets(digitado);
        
        comparaCaptcha(copia, digitado);
        
    }
    
    return 0;
    
}
",51,1550,537
"int main(int argc, char *argv[]) 
{
    int opcao, opcaoDeJogadaHumano, opcaoDeJogadaComputador, opcaoDeJogadaHumano1, opcaoDeJogadaHumano2;
    int numeroDePartidas = 0, numeroDeVitoriasHumano = 0, numeroDeVitoriasComputador = 0;
    int numeroDeVitoriasHumano1 = 0, numeroDeVitoriasHumano2 = 0, numeroDeEmpates = 0;
    
    while(1)
    {
        system(""cls"");
        printf(""Jogo Jokenpo\n\n"");
        printf(""(1) humano x computador\n"");
        printf(""(2) humano x humano\n"");
        printf(""(3) resultado\n"");
        printf(""(4) sair\n\n"");
        printf(""Escolha uma das opcoes acima: "");
        scanf(""%d"", &opcao);
        
            
        if(opcao == 1)
        {
            numeroDePartidas++;
            printf(""\n(1) = pedra\n"");
            printf(""(2) = papel\n"");
            printf(""(3) = tesoura\n"");
            
            printf(""\nopcao de jogada humano: "");
            scanf(""%d"", &opcaoDeJogadaHumano);
            
            opcaoDeJogadaComputador = rand()%3;
            printf(""opcao de jogada computador: %d\n\n"", opcaoDeJogadaComputador);
            
            if(opcaoDeJogadaHumano == 1 && opcaoDeJogadaComputador == 1)
            {
                printf(""empate\n"");
                numeroDeEmpates++;
            }
            if(opcaoDeJogadaHumano == 1 && opcaoDeJogadaComputador == 2)
            {
                printf(""computador ganha\n"");
                numeroDeVitoriasComputador++;
            }
            if(opcaoDeJogadaHumano == 1 && opcaoDeJogadaComputador == 3)
            {
                printf(""humano ganha\n"");
                numeroDeVitoriasHumano++;
            }
            if(opcaoDeJogadaHumano == 2 && opcaoDeJogadaComputador == 2)
            {
                printf(""empate\n"");
                numeroDeEmpates++;
            }
            if(opcaoDeJogadaHumano == 2 && opcaoDeJogadaComputador == 1)
            {
                printf(""humano ganha\n"");
                numeroDeVitoriasHumano++;
            }
            if(opcaoDeJogadaHumano == 2 && opcaoDeJogadaComputador == 3)
            {
                printf(""computador ganha\n"");
                numeroDeVitoriasComputador++;
            }
            if(opcaoDeJogadaHumano == 3 && opcaoDeJogadaComputador == 3)
            {
                printf(""empate\n"");
                numeroDeEmpates++;
            }
            if(opcaoDeJogadaHumano == 3 && opcaoDeJogadaComputador == 1)
            {
                printf(""computador ganha\n"");
                numeroDeVitoriasComputador++;
            }
            if(opcaoDeJogadaHumano == 3 && opcaoDeJogadaComputador == 2)
            {
                printf(""humano ganha\n"");
                numeroDeVitoriasHumano++;
            }
            system(""pause"");
        }
        else
        {
            if(opcao == 2)
            {
                numeroDePartidas++;
                printf(""\n1 = pedra\n"");
                printf(""2 = papel\n"");
                printf(""3 = tesoura\n"");
                
                printf(""\nopcao de jogada humano 1: "");
                scanf(""%d"", &opcaoDeJogadaHumano1);
            
                printf(""\nopcao de jogada humano 2: "");
                scanf(""%d"", &opcaoDeJogadaHumano2);
                
                if(opcaoDeJogadaHumano1 == 1 && opcaoDeJogadaHumano2 == 1)
                {
                    printf(""\nempate\n"");
                    numeroDeEmpates++;
                }
                if(opcaoDeJogadaHumano1 == 1 && opcaoDeJogadaHumano2 == 2)
                {
                    printf(""\nhumano 2 ganha\n"");
                    numeroDeVitoriasHumano2++;
                }
                if(opcaoDeJogadaHumano1 == 1 && opcaoDeJogadaHumano2 == 3)
                {
                    printf(""\nhumano 1 ganha\n"");
                    numeroDeVitoriasHumano1++;
                }
                if(opcaoDeJogadaHumano1 == 2 && opcaoDeJogadaHumano2 == 2)
                {
                    printf(""\nempate\n"");
                    numeroDeEmpates++;
                }
                if(opcaoDeJogadaHumano1 == 2 && opcaoDeJogadaHumano2 == 1)
                {
                    printf(""\nhumano 1 ganha\n"");
                    numeroDeVitoriasHumano1++;
                }
                if(opcaoDeJogadaHumano1 == 2 && opcaoDeJogadaHumano2 == 3)
                {
                    printf(""\nhumano 2 ganha\n"");
                    numeroDeVitoriasHumano2++;
                }
                if(opcaoDeJogadaHumano1 == 3 && opcaoDeJogadaHumano2 == 3)
                {
                    printf(""\nempate\n"");
                    numeroDeEmpates++;
                }
                if(opcaoDeJogadaHumano1 == 3 && opcaoDeJogadaHumano2 == 1)
                {
                    printf(""\nhumano 2 ganha\n"");
                    numeroDeVitoriasHumano2++;
                }
                if(opcaoDeJogadaHumano1 == 3 && opcaoDeJogadaHumano2 == 2)
                {
                    printf(""\nhumano 1 ganha\n"");
                    numeroDeVitoriasHumano1++;
                }
                system(""pause"");
            }
            else
            {
                if(opcao == 3)
                {
                    printf(""\nNumero de partidas: %d\n"", numeroDePartidas);
                    printf(""Numero de vitorias humano: %d\n"", numeroDeVitoriasHumano);
                    printf(""Numero de vitorias computador: %d\n"", numeroDeVitoriasComputador);
                    printf(""Numero de vitorias humano 1: %d\n"", numeroDeVitoriasHumano1);
                    printf(""Numero de vitorias humano 2: %d\n"", numeroDeVitoriasHumano2);
                    printf(""Numero de empates: %d\n\n"", numeroDeEmpates);
                    system(""pause"");
                }
                else
                {
                    if(opcao == 4)
                    {
                        exit(0);
                    }
                    else
                    {
                        printf(""\nopcao invalida\n\n"");
                    }
                    system(""pause"");
                }
            }
                
        }
    
    }
    
    
    
    
    
    return 0;
}
",51,1551,1959
"#define PEDRA 1
#define PAPEL 2
#define TESOURA 3
#define LAGARTO 4
#define SPOCK 5

int main(int argc, char *argv[]) {
    
    int player1, player2, optP1, optP2;
    int mainMenu, playerMenu, modeMenu, novojogo;
    int totalJogadas, empates, vitoriasP1, vitoriasP2, totalNormal, totalMelhor, totalStartrek, totalDeath, tempVitP1, tempVitP2, especial, tempDeath;
    float percentP1, percentP2;
    
    srand( time(NULL) );
    totalJogadas=0;
    totalNormal=0;
    totalMelhor=0;
    totalStartrek=0;
    totalDeath=0;
    empates=0;
    vitoriasP1=0;
    vitoriasP2=0;
    especial=3;
    
    do {
    
        system(""cls"");
        printf(""\n     ___ _______ ___   _ _______ __    _ _______ _______ \n    |   |       |   | | |       |  |  | |       |       |\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\n|       |       |    _  |   |___| | |   |   |   |       |\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|"");
        
        printf(""\n\n\tO que voce quer fazer?\n"");
        printf(""\t1 - Jogar\n"");
        printf(""\t2 - Ver Regras\n"");
        printf(""\t3 - Ver Estatisticas\n"");
        printf(""\t4 - Sair\n\t"");
        
        if (totalJogadas > especial ) {
            printf(""\n\t0 - ESPECIAL DEATHMATCH\n"");
        }
        
        scanf(""%d"",&mainMenu);
        
        while( (mainMenu>4) || (totalJogadas<especial && mainMenu<1) ){
            printf(""\t-> Opcao invalida!\n"");
            printf(""\tO que voce quer fazer?\n\t"");
            scanf(""%d"",&mainMenu);
        }
        
        system(""cls"");
        
        if (mainMenu==1){
                
                printf(""\n     ___ _______ ___   _ _______ __    _ _______ _______ \n    |   |       |   | | |       |  |  | |       |       |\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\n|       |       |    _  |   |___| | |   |   |   |       |\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|"");
                printf(""\n\n\tComo voce quer jogar?\n"");
                printf(""\t1 - Player VS Player"");
                printf(""\n\t2 - Player VS Computador\n\t"");
                scanf(""%d"",&playerMenu);
                
                while(playerMenu<1 || playerMenu>2){
                    printf(""\t-> Opcao invalida!\n"");
                    printf(""\tComo voce quer jogar?\n\t"");
                    scanf(""%d"",&playerMenu);
                }
                
                system(""cls"");
                
                printf(""\n     ___ _______ ___   _ _______ __    _ _______ _______ \n    |   |       |   | | |       |  |  | |       |       |\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\n|       |       |    _  |   |___| | |   |   |   |       |\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|"");
                printf(""\n\n\tMODO DE JOGO:\n"");
                printf(""\t1 - Normal\n"");
                printf(""\t2 - Melhor de 3\n"");
                printf(""\t3 - Startreck\n\t"");
                scanf(""%d"",&modeMenu);
                
                while(modeMenu<1 || modeMenu>3){
                    printf(""-> Opcao invalida!\n"");
                    printf(""Como voce quer jogar?\n\t"");
                    scanf(""%d"",&modeMenu);
                }
                
                system(""cls"");
                
                if (modeMenu==1) {
                    
                    
                    do {
                        
                        printf(""Vez do Player 1.\n"");
                        printf(""Escolha uma opcao para jogar:\n"");
                        printf(""\t1 - Pedra\n"");
                        printf(""\t2 - Papel\n"");
                        printf(""\t3 - Tesoura\n"");
                        printf(""Numero: "");
                        scanf(""%d"",&optP1);
                        while( optP1<1 || optP1>3 ){
                            printf(""Opcao invalida. Digite novamente: "");
                            scanf(""%d"",&optP1);
                        }
                        
                        system(""cls"");
                        
                        printf(""Agora o Player 2.\n"");
                        printf(""Escolha uma opcao para jogar:\n"");
                        printf(""\t1 - Pedra\n"");
                        printf(""\t2 - Papel\n"");
                        printf(""\t3 - Tesoura\n"");
                        
                        system(""pause"");
                        printf(""Numero: "");
                        
                        if (playerMenu==1) {
                            scanf(""%d"",&optP2);
                            while( optP2<1 || optP2>3 ){
                                printf(""Opcao invalida. Digite novamente: "");
                                scanf(""%d"",&optP2);
                            }
                        } else {
                            optP2 = ( rand() % 2 ) + 1;
                            printf(""%d"",optP2);
                        
                        }
                        
                        totalJogadas++;
                        totalNormal++;
                        
                        if (optP1==optP2) {
                            printf(""\nEmpate!\n"");
                            empates++;
                        } else {
                            if ( (optP1==PEDRA&&optP2==TESOURA) || (optP1==PAPEL&&optP2==PEDRA) || (optP1==TESOURA&&optP2==PAPEL) ) {
                                printf(""\nPlayer 1 venceu!\n"");
                                vitoriasP1++;
                            } else {
                                printf(""\nPlayer 2 venceu!\n"");
                                vitoriasP2++;
                            }
                        }
                        
                        printf(""\nDigite 1 para jogar novamente, ou qualquer outro para sair!"");
                        scanf(""%d"",&novojogo);
                        system(""cls"");
                }while(novojogo==1);
                
                }
                else {
            
                    if (modeMenu==2) {
                        
                    do {
                        
                        tempVitP1=0;
                        tempVitP2=0;
                        
                            do {
                                system(""cls"");
                                printf(""P1(%d) VS P2 (%d)\n"",tempVitP1,tempVitP2);
                            
                            printf(""Vez do Player 1.\n"");
                            printf(""Escolha uma opcao para jogar:\n"");
                            printf(""\t1 - Pedra\n"");
                            printf(""\t2 - Papel\n"");
                            printf(""\t3 - Tesoura\n"");
                            printf(""Numero: "");
                            scanf(""%d"",&optP1);
                            while( optP1<1 || optP1>3 ){
                                printf(""Opcao invalida. Digite novamente: "");
                                scanf(""%d"",&optP1);
                            }
                            
                            system(""cls"");
                            
                            printf(""Agora o Player 2.\n"");
                            printf(""Escolha uma opcao para jogar:\n"");
                            printf(""\t1 - Pedra\n"");
                            printf(""\t2 - Papel\n"");
                            printf(""\t3 - Tesoura\n"");
    
                            system(""pause"");
                            printf(""Numero: "");
                            
                            if (playerMenu==1) {
                                scanf(""%d"",&optP2);
                                while( optP2<1 || optP2>3 ){
                                    printf(""Opcao invalida. Digite novamente: "");
                                    scanf(""%d"",&optP2);
                                }
                            } else {
                                optP2 = ( rand() % 2 ) + 1;
                                printf(""%d"",optP2);
                            }
                            
                            if (optP1==optP2) {
                                printf(""\nEmpate!\n"");
                                empates++;
                            } else {
                                if ( (optP1==PEDRA&&optP2==TESOURA) || (optP1==PAPEL&&optP2==PEDRA) || (optP1==TESOURA&&optP2==PAPEL) ) {
                                    printf(""\nPlayer 1 venceu a rodada!\n"");
                                    tempVitP1++;
                                } else {
                                    printf(""\nPlayer 2 venceu a rodada!\n"");
                                    tempVitP2++;
                                }
                            }
                            system(""pause"");
                        
                    }while( tempVitP1<2 && tempVitP2<2 );
                        
                        totalJogadas++;
                        totalMelhor++;
                        
                        system(""cls"");
                        if (tempVitP1 > tempVitP2) {
                            printf(""\nPlayer 1 venceu a partida!\n"");
                            vitoriasP1++;
                        } else {
                            printf(""\nPlayer 2 venceu a partida!\n"");
                            vitoriasP2++;
                        }
                        
                        system(""pause"");
                        system(""cls"");
                        
                        printf(""\nDigite 1 para jogar novamente, ou qualquer outro para sair!"");
                        scanf(""%d"",&novojogo);
                        system(""cls"");
                    }while(novojogo==1);
                        
                    } else {
                        
                        if (modeMenu==3) {
                            
                            do {

                        printf(""Vez do Player 1.\n"");
                        printf(""Escolha uma opcao para jogar:\n"");
                        printf(""\t1 - Pedra\n"");
                        printf(""\t2 - Papel\n"");
                        printf(""\t3 - Tesoura\n"");
                        printf(""\t4 - Lagarto\n"");
                        printf(""\t5 - Spoc\n"");
                        printf(""Numero: "");
                        scanf(""%d"",&optP1);
                        while( optP1<1 || optP1>5 ){
                            printf(""Opcao invalida. Digite novamente: "");
                            scanf(""%d"",&optP1);
                        }
                        
                        system(""cls"");
                        
                        printf(""Agora o Player 2.\n"");
                        printf(""Escolha uma opcao para jogar:\n"");
                        printf(""\t1 - Pedra\n"");
                        printf(""\t2 - Papel\n"");
                        printf(""\t3 - Tesoura\n"");
                        printf(""\t4 - Lagarto\n"");
                        printf(""\t5 - Spoc\n"");
                        
                        system(""pause"");
                        printf(""Numero: "");
                        
                        if (playerMenu==1) {
                            scanf(""%d"",&optP2);
                            while( optP2<1 || optP2>5 ){
                                printf(""Opcao invalida. Digite novamente: "");
                                scanf(""%d"",&optP2);
                            }
                        } else {
                            optP2 = ( rand() % 4 ) + 1;
                            printf(""%d"",optP2);
                        }
                        
                        totalJogadas++;
                        totalStartrek++;
                        
                        if (optP1==optP2) {
                            printf(""\nEmpate!\n"");
                            empates++;
                        } else {
                            if (
                            
                                (optP1==PEDRA&&optP2==TESOURA) ||
                                (optP1==PEDRA&&optP2==LAGARTO) ||
                                
                                (optP1==LAGARTO&&optP2==PAPEL) ||
                                (optP1==LAGARTO&&optP2==SPOCK) ||
                                
                                (optP1==SPOCK&&optP2==PEDRA) ||
                                (optP1==SPOCK&&optP2==TESOURA) ||
                                
                                (optP1==TESOURA&&optP2==LAGARTO) ||
                                (optP1==TESOURA&&optP2==PAPEL) ||
                                
                                (optP1==PAPEL&&optP2==PEDRA) ||
                                (optP1==PAPEL&&optP2==SPOCK)
                            
                            ) {
                                printf(""\nPlayer 1 venceu!\n"");
                                vitoriasP1++;
                            } else {
                                printf(""\nPlayer 2 venceu!\n"");
                                vitoriasP2++;
                            }
                        }
                        
                        printf(""\nDigite 1 para jogar novamente, ou qualquer outro para sair!!"");
                        scanf(""%d"",&novojogo);
                        system(""cls"");
                    }while(novojogo==1);
                            
                        }
                        
                    }
            
                }
        
        }
        
        else {
            
            if (mainMenu==2) {
                
                printf(""\n     ___ _______ ___   _ _______ __    _ _______ _______ \n    |   |       |   | | |       |  |  | |       |       |\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\n|       |       |    _  |   |___| | |   |   |   |       |\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|"");
                
                printf(""\n\n\tREGRAS:\n"");
                printf(""\tNo Jokenpo, os jogadores devem escolher numeros, no qual cada numero representa um simbolo.\n"");
                printf(""\tEsses simbolos sao comparados para ver quem ganhou, da seguinte forma:\n"");
                printf(""\t\t- PEDRA ganha da TESOURA (quebrando-a).\n"");
                printf(""\t\t- TESOURA ganha do PAPEL (cortando-o).\n"");
                printf(""\t\t- PAPEL ganha da PEDRA (embrulhando-o).\n"");
                printf(""\tNa variacao Star Trek as regras anteriores permanecem, e outras sao adicionadas:\n"");
                printf(""\t\t- PEDRA ganha do LAGARTO (esmagando-o).\n"");
                printf(""\t\t- TESOURA ganha do LAGARTO (matando-o).\n"");
                printf(""\t\t- PAPEL ganha do SPOCK (cegando-o).\n"");
                printf(""\t\t- LAGARTO ganha do PAPEL (comendo-o).\n"");
                printf(""\t\t- LAGARTO ganha do SPOCK (envenenando-o).\n"");
                printf(""\t\t- SPOCK ganha da PEDRA (vaporizando-a).\n"");
                printf(""\t\t- SPOCK ganha da TESOURA (quebrando-a).\n\n"");
                system(""pause"");
                
            } else {
                
                if (mainMenu==3) {
                    
                    printf(""\n     ___ _______ ___   _ _______ __    _ _______ _______ \n    |   |       |   | | |       |  |  | |       |       |\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\n|       |       |    _  |   |___| | |   |   |   |       |\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|"");
                    printf(""\n\n\tTotal de Jogadas: %d\n"",totalJogadas);
                    
                    printf(""\t\tEmpates: %d\n"",empates);
                    percentP1=(100.0*vitoriasP1)/totalJogadas;
                    printf(""\t\tVitorias Player 1: %d(%f%%)\n"",vitoriasP1,percentP1);
                    percentP2=(100.0*vitoriasP2)/totalJogadas;
                    printf(""\t\tVitorias Player 2: %d(%f%%)\n"",vitoriasP2,percentP2);

                    printf(""\tJogadas no Modo Normal: %d\n"",totalNormal);
                    printf(""\tJogadas no Modo Melhor de 3: %d\n"",totalMelhor);
                    printf(""\tJogadas no Modo Star Trek: %d\n"",totalStartrek);
                    system(""pause"");
                    
                } else if (mainMenu==0) {
                            
                    do {
                        
                        tempVitP1=0;
                        tempDeath=0;
                        
                            do {
                                
                            printf(""\tDEATMATCH\n"");
                            printf(""\tEste e o modo especial de Jokenpo. Resista o maximo que puder e veja quantas partidas seguidas voce consegue vencer!\n"");
                                
                            system(""cls"");
                            printf(""P1(%d) VS P2 (%d)\n"",tempVitP1,tempVitP2);
                            
                            printf(""Vez do Player 1.\n"");
                            printf(""Escolha uma opcao para jogar:\n"");
                            printf(""\t1 - Pedra\n"");
                            printf(""\t2 - Papel\n"");
                            printf(""\t3 - Tesoura\n"");
                            printf(""Numero: "");
                            scanf(""%d"",&optP1);
                            while( optP1<1 || optP1>3 ){
                                printf(""Opcao invalida. Digite novamente: "");
                                scanf(""%d"",&optP1);
                            }
                            
                            system(""cls"");
                            
                            printf(""Agora o Player 2.\n"");
                            printf(""Escolha uma opcao para jogar:\n"");
                            printf(""\t1 - Pedra\n"");
                            printf(""\t2 - Papel\n"");
                            printf(""\t3 - Tesoura\n"");
    
                            system(""pause"");
                            printf(""Numero: "");

                            optP2 = ( rand() % 2 ) + 1;
                            printf(""%d"",optP2);
                            
                            if (optP1==optP2) {
                                printf(""\nEmpate!\n"");
                                empates++;
                            } else {
                                if ( (optP1==PEDRA&&optP2==TESOURA) || (optP1==PAPEL&&optP2==PEDRA) || (optP1==TESOURA&&optP2==PAPEL) ) {
                                    printf(""\nPlayer 1 venceu a rodada!\n"");
                                    tempVitP1=1;
                                    tempDeath++;
                                } else {
                                    printf(""\nPlayer 2 venceu a rodada e encerrou a partida!\n"");
                                    tempVitP1=2;
                                }
                            }
                            system(""pause"");
                        
                    }while( tempVitP1==1 );
                        
                        totalJogadas++;
                        totalDeath++;
                        
                        system(""cls"");

                            printf(""\nVoce ganhou: %d partidas!\n"",tempDeath);
                            vitoriasP1++;
                        
                        system(""pause"");
                        system(""cls"");
                        
                        printf(""\nDigite 1 para jogar novamente, ou qualquer outro para sair!"");
                        scanf(""%d"",&novojogo);
                        system(""cls"");
                    }while(novojogo==1);
                    
                }
                
            }
            
        }
    
    }while(mainMenu>=1 && mainMenu<=3);
    return 0;
}
",51,1552,5690
"int main(void) {
    int jogadorUm, jogadorDois, nEmpatesUm, nEmpatesDois, nDerrotasUm , nDerrotasDois;
    int opcao, menu;
    float nVitoriasUm, nVitoriasDois, pVitoriasUm, pVitoriasDois, nJogadas;
    
    opcao = 1;
    nVitoriasDois = 0;
    nDerrotasUm = 0;
    
    printf(""------------------------------------\n-------------bem vindo!-------------\n------------------------------------\n\n"");
        
    while(opcao != 3){
    
    printf(""Selecione seu modo de jogo: \n\n"");
    printf(""1- PvC - Player vs Computer \n"");
    printf(""2- PvP - Player vs Player \n"");
    printf(""3- sair\n"");
    fflush(stdin);
    scanf(""%d"", &opcao);
    
    
    
    
    switch(opcao){
    
    
        case 1: 
        
         jogadorUm = 0;
         jogadorDois = 0;
         nVitoriasUm = 0;
         nVitoriasDois = 0;
         nEmpatesUm = 0;
         nEmpatesDois = 0;
         nJogadas = 0;
         nDerrotasUm  = 0;
         nDerrotasDois = 0;
         pVitoriasUm = 0;
         pVitoriasDois = 0;
        
        while(menu !=4){
                 
        
           printf(""\nSelecione sua opcao: \n"");
           printf(""1- Pedra\n 2- Papel \n 3- Tesoura. \n"");
           scanf(""%d"", &jogadorUm);
           
           srand(time(NULL));
           jogadorDois = 1 + rand() %3;
           printf(""\nOpcao jogadorDois = %d "", jogadorDois, (jogadorDois % 4));
           
           
if(jogadorUm == 1 && jogadorDois == 1){
            printf(""\nDeu Empate!\n"");
            nEmpatesUm = nEmpatesUm + 1;
            nEmpatesDois = nEmpatesDois + 1; 
            nJogadas = nJogadas + 1;
                
      }else{
          if(jogadorUm == 1 && jogadorDois == 2){  
                       printf(""\nO jogador Dois ganhou\n"");
                       nDerrotasUm = nDerrotasUm + 1;
                       nVitoriasDois = nVitoriasDois + 1;
                       nJogadas = nJogadas + 1;                   
                     
         }else{
              if(jogadorUm == 1 && jogadorDois == 3){
                           printf(""\nO Jogador Um ganhou\n"");
                           nDerrotasDois = nDerrotasDois + 1;
                           nVitoriasUm = nVitoriasUm + 1;
                           nJogadas = nJogadas + 1;
                           
                            
              }else{
                    if(jogadorUm == 2 && jogadorDois == 1){ 
                                 printf(""\nO jogador Dois ganhou\n"");
                                 nDerrotasUm = nDerrotasUm + 1;
                                 nVitoriasDois = nVitoriasDois + 1;
                                 nJogadas = nJogadas + 1;
                                
                           
                    }else{
                          if(jogadorUm == 2 && jogadorDois == 2){
                                       printf(""\nDeu empate\n"");
                                       nEmpatesUm = nEmpatesUm + 1;
                                       nEmpatesDois = nEmpatesDois + 1;
                                       nJogadas = nJogadas + 1;
                                       
                         }else{
                               if(jogadorUm == 2 && jogadorDois == 3){  
                                            printf(""\nO jogador dois ganhou\n"");
                                            nVitoriasDois = nVitoriasDois + 1;
                                            nDerrotasUm = nDerrotasUm + 1;
                                            nJogadas = nJogadas + 1;
                                           
                              }else{
                                    if (jogadorUm == 3 && jogadorDois == 1){
                                                  printf(""\nO jogador Dois ganhou\n"");
                                                  nVitoriasDois = nVitoriasDois + 1;
                                                  nDerrotasUm = nDerrotasUm + 1;
                                                  nJogadas = nJogadas + 1;
                                                  
                                                           
                                    }else{
                                          if(jogadorUm == 3 && jogadorDois == 2){
                                                       printf(""\nO jogador Um ganhou\n"");
                                                       nDerrotasDois = nDerrotasDois + 1;
                                                       nVitoriasUm = nVitoriasUm + 1;
                                                       nJogadas = nJogadas + 1;
                                                      
                                            }else{
                                                  if(jogadorUm == 3 && jogadorDois == 3){
                                                               printf(""\nDeu Empate\n"");
                                                               nEmpatesUm = nEmpatesUm + 1;
                                                               nEmpatesDois = nEmpatesDois + 1;
                                                               nJogadas = nJogadas + 1;
                                                    
                                                  }else{
                                                       printf(""\nJogada Invalida\n"");
                                                  } 
                                                            
}}}}}}}}
            
            if(nVitoriasUm == 0)
            {
                   pVitoriasUm = 0;
                   }else 
                   {
                          pVitoriasUm = ( nVitoriasUm/ nJogadas ) * 100;
                   }
                                if(nVitoriasDois == 0)
                                {
                                        pVitoriasDois = 0;
                                        }else
                                        {
                                                pVitoriasDois = ( nVitoriasDois / nJogadas ) * 100;
            }
            printf(""\nJOGADOR 1: \n"");
            printf(""\nQuantidade de Vitorias: %.0f"", nVitoriasUm);
            printf(""\nQuantidade de Derrotas: %d"", nDerrotasUm);
            printf(""\nQuantidade de Empates: %d"", nEmpatesUm);
            printf(""\nPercentual de Vitorias: %.2f %%"", pVitoriasUm );
            printf(""\n------------------------------------------------------------------"");
            printf(""\nJOGADOR 2: \n"");
            printf(""\nQuantidade de Vitorias: %.0f"", nVitoriasDois);
            printf(""\nQuantidade de Derrotas: %d"", nDerrotasDois);
            printf(""\nQuantidade de Empates: %d"", nEmpatesDois);
            printf(""\nPercentual de Vitorias: %.2f %%"", pVitoriasDois);
            printf(""\n------------------------------------------------------------------"");
            printf(""\nGERAL: \n"");
            printf(""Quantidade de Jogadas Total: %.0f"", nJogadas);

            printf(""\ndeseja jogar novamente?\n"");
            scanf(""%d"", &menu);
            system(""cls"");
    }
        break;
           
        case 2:  
        
         jogadorUm = 0;
         jogadorDois = 0;
         nVitoriasUm = 0;
         nVitoriasDois = 0;
         nEmpatesUm = 0;
         nEmpatesDois = 0;
         nJogadas = 0;
         nDerrotasUm  = 0;
         nDerrotasDois = 0;
         pVitoriasUm = 0;
         pVitoriasDois = 0;
        
        while(opcao != 3){
        
           printf(""\nSelecione sua opcao: \n"");
           printf(""1- Pedra\n 2- Papel \n 3- Tesoura. \n"");
           scanf(""%d"", &jogadorUm);
           
           printf(""\nSelecione sua opcao: \n"");
           printf(""1- Pedra\n 2- Papel \n 3- Tesoura. \n"");
           scanf(""%d"", &jogadorDois);
           system(""cls"");
                   
if(jogadorUm == 1 && jogadorDois == 1){
            printf(""\nDeu Empate!\n"");
            nEmpatesUm = nEmpatesUm + 1;
            nEmpatesDois = nEmpatesDois + 1; 
            nJogadas = nJogadas + 1;
                
      }else{
          if(jogadorUm == 1 && jogadorDois == 2){  
                       printf(""\nO jogador Dois ganhou\n"");
                       nDerrotasUm = nDerrotasUm + 1;
                       nVitoriasDois = nVitoriasDois + 1;
                       nJogadas = nJogadas + 1;                   
                     
         }else{
              if(jogadorUm == 1 && jogadorDois == 3){
                           printf(""\nO Jogador Um ganhou\n"");
                           nDerrotasDois = nDerrotasDois + 1;
                           nVitoriasUm = nVitoriasUm + 1;
                           nJogadas = nJogadas + 1;
                           
                            
              }else{
                    if(jogadorUm == 2 && jogadorDois == 1){ 
                                 printf(""\nO jogador Dois ganhou\n"");
                                 nDerrotasUm = nDerrotasUm + 1;
                                 nVitoriasDois = nVitoriasDois + 1;
                                 nJogadas = nJogadas + 1;
                                
                           
                    }else{
                          if(jogadorUm == 2 && jogadorDois == 2){
                                       printf(""\nDeu empate\n"");
                                       nEmpatesUm = nEmpatesUm + 1;
                                       nEmpatesDois = nEmpatesDois + 1;
                                       nJogadas = nJogadas + 1;
                                       
                         }else{
                               if(jogadorUm == 2 && jogadorDois == 3){  
                                            printf(""\nO jogador dois ganhou\n"");
                                            nVitoriasDois = nVitoriasDois + 1;
                                            nDerrotasUm = nDerrotasUm + 1;
                                            nJogadas = nJogadas + 1;
                                           
                              }else{
                                    if (jogadorUm == 3 && jogadorDois == 1){
                                                  printf(""\nO jogador Dois ganhou\n"");
                                                  nVitoriasDois = nVitoriasDois + 1;
                                                  nDerrotasUm = nDerrotasUm + 1;
                                                  nJogadas = nJogadas + 1;
                                                  
                                                           
                                    }else{
                                          if(jogadorUm == 3 && jogadorDois == 2){
                                                       printf(""\nO jogador Um ganhou\n"");
                                                       nDerrotasDois = nDerrotasDois + 1;
                                                       nVitoriasUm = nVitoriasUm + 1;
                                                       nJogadas = nJogadas + 1;
                                                      
                                            }else{
                                                  if(jogadorUm == 3 && jogadorDois == 3){
                                                               printf(""\nDeu Empate\n"");
                                                               nEmpatesUm = nEmpatesUm + 1;
                                                               nEmpatesDois = nEmpatesDois + 1;
                                                               nJogadas = nJogadas + 1;
                                                    
                                                        }else{
                                                                 printf(""\nJogada Invalida\n"");
           
                                                                                        
}}}}}}}}}
            
            if(nVitoriasUm == 0)
            {
                   pVitoriasUm = 0;
                 }
                 else
                     {
                        pVitoriasUm = ( nVitoriasUm / nJogadas ) * 100;
                     }
                             if(nVitoriasDois == 0){
                                    pVitoriasDois = 0;
                                    }
                                     else
                                     {
                                               pVitoriasDois = ( nVitoriasDois / nJogadas ) * 100;
            }
            
            printf(""\nJOGADOR 1: \n"");
            printf(""\nQuantidade de Vitorias: %.0f"", nVitoriasUm);
            printf(""\nQuantidade de Derrotas: %d"", nDerrotasUm);
            printf(""\nQuantidade de Empates: %d"", nEmpatesUm);
            printf(""\nPercentual de Vitorias: %.2f"", pVitoriasUm );
            printf(""\n------------------------------------------------------------------"");
            printf(""\nJOGADOR 2: \n"");
            printf(""\nQuantidade de Vitorias: %.0f"", nVitoriasDois);
            printf(""\nQuantidade de Derrotas: %d"", nDerrotasDois);
            printf(""\nQuantidade de Empates: %d"", nEmpatesDois);
            printf(""\nPercentual de Vitorias: %.2f %%"", pVitoriasDois);
            printf(""\n------------------------------------------------------------------"");
            printf(""\nGERAL: \n"");
            printf(""Quantidade de Jogadas Total: %.0f"", nJogadas);
            
                
            printf(""\ndeseja jogar novamente?\n"");
            scanf(""%d"", &menu);
            system(""cls"");      
        }

           break;
        case 3:
           printf(""Cansou de jogar? \n"");
           system(""exit"");
           
           break;
           
        default:           
            printf(""opcao invalida"");
            break;
        }
}

    
    if(menu == 2){
        
        printf(""Voce saira do jogo!"");
    }

}


",51,1553,3809
"char * gercaptcha (char captcha [6]) {
    int cont;
        
    for (cont = 0; cont < 6; cont ++)
    {
        if (cont== 0 || cont==3|| cont ==5)
        {
            captcha [cont] = 65 + (rand() % 26);
            
        }else {
            if (cont==1 || cont == 2|| cont==4)
            {
                captcha [cont] = 48 + (rand() % 10);
            }
        }
    }
    return captcha;
    
}
int comparar (char captchalido [6], char captchaescrito [6])
{
    int cont;
    int diferenca;
    
    diferenca = 0;
    
    for ( cont = 0; cont <6; cont++)
    {
        if (captchalido [cont]   != captchaescrito [cont])
        {
            diferenca ++;
        }
    }
        if (diferenca > 0){
            return 1;
            
        }
        else {
            return 0;
        }
}


int main (int argc, char *argv[]) {
    char captchaG [6];
    char *captcha;
    char leitura [6];
    int result;
    
    srand (time (NULL));
    
    
    printf (""Digite conforme o Captcha \n"");
    captcha = gercaptcha (captchaG);
    printf (""Captcha: %s \n"", captcha);
    
    gets (leitura);
    
    result = comparar (captcha, leitura); 
    
    if (result == 1)
    {
        printf (""Deu ruim"");
        }
        if (result ==0)
        {printf (""Deu bom"");
            }   
    
    
    
    return 0;
}








",51,1554,482
"int main(int argc, char *argv[]) {

    int modoJogo;
    int jogarNovamente;
    int jogador1;
    int jogador2;
    int ia;
    int empates;
    int vitoriasP1;
    float porcentvitP1;
    int vitoriasP2;
    float porcentvitP2;
    int vitoriasIA;
    float porcentvitIA;
    int contador;

    printf(""-^^- JOKENPO GAME by TS -^^- \n \n \n"");
    printf(""Digite o numero de uma das opcoes abaixo:\n 1 - Jogar Player Vs Player \n 2- Jogar Player Vs IA\n 3- Sair\n"");
    scanf(""%d"", &modoJogo);
    while(modoJogo != 1 && modoJogo !=2 && modoJogo !=3 ) {
        printf(""Opcao Invalida, digite uma opcao valida:\n 1 - Jogar Player Vs Player \n 2- Jogar Player Vs IA\n 3- Sair\n"");
        scanf(""%d"", &modoJogo);

    }
    switch (modoJogo) {
        case 1:
        printf("" -^^- MODO PLAYER VS PLAYER -^^- \n \n \n"");
        jogarNovamente=1;
        vitoriasP1=0;
        vitoriasP2=0;
        contador=0;
        do {
            printf(""Player 1 -> Digite sua opcao de jogada: \n 1 - PEDRA \n 2 - PAPEL \n 3 - TESOURA \n"");
            scanf(""%d"", &jogador1);
            while(jogador1 >3) {
                printf(""Jogada Invalida, por favor digite uma jogada valida:\n 1 - PEDRA \n 2 - PAPEL \n 3 - TESOURA \n"");
                scanf(""%d"", & jogador1);
            }
            printf(""Player 2 -> Digite sua opcao de jogada: \n 1 - PEDRA \n 2 - PAPEL \n 3 - TESOURA \n"");
            scanf(""%d"", &jogador2);
            while(jogador2 >3) {
                printf(""Jogada Invalida, por favor digite uma jogada valida:\n 1 - PEDRA \n 2 - PAPEL \n 3 - TESOURA \n"");
                scanf(""%d"", & jogador2);
            }

            if((jogador1 == 1 && jogador2 == 1) || (jogador1 == 2 && jogador2 == 2)|| (jogador1==3 && jogador2==3)) {
                printf(""EMPATOU! \n"");
                empates++;
                contador++;

            } else {
                if(jogador1 == 1 && jogador2 == 2) {
                    printf(""PEDRA E PAPEL = VITORIA JOGADOR 2! \n"");
                    vitoriasP2++;
                    contador++;

                } else {
                    if(jogador1==1 && jogador2 == 3) {
                        printf(""PEDRA E TESOURA = VITORIA JOGADOR 1! \n"");
                        vitoriasP1++;
                        contador++;

                    } else {
                        if(jogador1==2 && jogador2==1) {
                            printf(""PAPEL E PEDRA = VITORIA JOGADOR 1! \n"");
                            vitoriasP1++;
                            contador++;


                        } else {
                            if(jogador1==2 && jogador2==3) {
                                printf(""PAPEL E TESOURA = VITORIA JOGADOR 2! \n"");
                                vitoriasP2++;
                                contador++;


                            } else {
                                if(jogador1==3 && jogador2==1) {
                                    printf(""TESOURA E PEDRA = VITORIA JOGADOR 2! \n"");
                                    vitoriasP2++;
                                    contador++;

                                } else {
                                    printf(""TESOURA E PAPEL = VITORIA JOGADOR 1! \n"");
                                    vitoriasP1++;
                                    contador++;


                                }


                            }

                        }
                    }
                }

            }
            printf(""Deseja jogar Novamente? \n 1- Sim\n 2-Nao \n"");
            scanf(""%d"", &jogarNovamente);
            while(jogarNovamente >2) {
                printf(""Opcao Invalida, digite uma opcao valida:\n 1- Sim\n 2-Nao \n"");
                scanf(""%d"", &jogarNovamente);
            }
        } while(jogarNovamente ==1);
        printf(""ESTATISTICAS: \n"");
        printf(""Numero de Vezes Jogadas: %d \n"", contador);
        printf(""Numero de Empates: %d \n"", empates);
        if(vitoriasP1 == 0 && vitoriasP2 == 0) {
            printf(""Porcentagem de Vitorias PLAYER 1 = 0 \nPorcentagem de Vitorias PLAYER 2 = 0"");
        } else {

            porcentvitP1=(vitoriasP1*100)/(contador-empates);
            porcentvitP2=(vitoriasP2*100)/(contador-empates);
            printf(""Porcentagem de Vitorias PLAYER 1 = %f \n"", porcentvitP1);
            printf(""Porcentagem de Vitorias PLAYER 2 = %f \n"", porcentvitP2);
        }
        break;
    case 2:
        printf("" -^^- MODO PLAYER VS I.A -^^- \n \n \n"");
        jogarNovamente=1;
        vitoriasP1=0;
        vitoriasIA=0;
        contador=0;
        do {
            printf(""Player -> Digite sua opcao de jogada: \n 1 - PEDRA \n 2 - PAPEL \n 3 - TESOURA \n"");
            scanf(""%d"", &jogador1);
            while(jogador1 >3) {
                printf(""Jogada Invalida, por favor digite uma jogada valida:\n 1 - PEDRA \n 2 - PAPEL \n 3 - TESOURA \n"");
                scanf(""%d"", & jogador1);
            }
            srand(time(NULL));
            ia=(rand() % 3)+1;
            printf(""Jogada da maquina:\n %d\n"", ia);

            if((jogador1 == 1 && ia == 1) || (jogador1 == 2 && ia == 2)|| (jogador1==3 && ia==3)) {
                printf(""EMPATOU! \n"");
                empates++;
                contador++;

            } else {
                if(jogador1 == 1 && ia == 2) {
                    printf(""PEDRA E PAPEL = VITORIA MAQUINA! \n"");
                    vitoriasIA++;
                    contador++;

                } else {
                    if(jogador1==1 && ia == 3) {
                        printf(""PEDRA E TESOURA = VITORIA JOGADOR! \n"");
                        vitoriasP1++;
                        contador++;

                    } else {
                        if(jogador1==2 && ia==1) {
                            printf(""PAPEL E PEDRA = VITORIA JOGADOR! \n"");
                            vitoriasP1++;
                            contador++;


                        } else {
                            if(jogador1==2 && ia==3) {
                                printf(""PAPEL E TESOURA = VITORIA MAQUINA! \n"");
                                vitoriasIA++;
                                contador++;


                            } else {
                                if(jogador1==3 && ia==1) {
                                    printf(""TESOURA E PEDRA = VITORIA MAQUINA! \n"");
                                    vitoriasIA++;
                                    contador++;

                                } else {
                                    printf(""TESOURA E PAPEL = VITORIA JOGADOR! \n"");
                                    vitoriasP1++;
                                    contador++;


                                }


                            }

                        }
                    }
                }

            }
            printf(""Deseja jogar Novamente? \n 1- Sim\n 2-Nao \n"");
            scanf(""%d"", &jogarNovamente);
            while(jogarNovamente >2) {
                printf(""Opcao Invalida, digite uma opcao valida:\n 1- Sim\n 2-Nao \n"");
                scanf(""%d"", &jogarNovamente);
            }
        } while(jogarNovamente ==1);
        printf(""ESTATISTICAS: \n"");
        printf(""Numero de Vezes Jogadas: %d \n"", contador);
        printf(""Numero de Empates: %d \n"", empates);
        if(vitoriasP1 == 0 && vitoriasIA == 0) {
            printf(""Porcentagem de Vitorias PLAYER 1 = 0 \nPorcentagem de Vitorias PLAYER 2 = 0"");
        } else {

            porcentvitP1=(vitoriasP1*100)/(contador-empates);
            porcentvitIA=(vitoriasIA*100)/(contador-empates);
            printf(""Porcentagem de Vitorias PLAYER 1 = %f \n"", porcentvitP1);
            printf(""Porcentagem de Vitorias da MAQUINA = %f \n"", porcentvitIA);
        }
        break;
        case 3:
            exit(0);
            break;
        }

    system(""pause"");
    return 0;
}
",51,1555,2645
"char * gerarCaptcha(char captcha[6])
{
    int cont, num;
    srand(time(NULL));

    for(cont = 0; cont < 6; cont++)
    {
        num = rand() % 3;
        
        if(num == 0)
            captcha[cont] = 65 + (rand() % 26);
        else
            if(num == 1)
                captcha[cont] = 97 + (rand() % 26);
            else
                captcha[cont] = 48 + (rand() % 10);
    }
    return captcha;
}
int * compararCaptcha(char captcha[6], char vetor[6], int iguais)
{
    int cont;
    iguais = 0;
    
    for(cont = 0; cont < 6; cont++)
    {
        if(captcha[cont] == vetor[cont])
            iguais++;
    }
    
    if(iguais == 6)
        return iguais;
}
   
int main(int argc, char *argv[]) 
{
    char captcha[6];
    char vetor[6];
    int * retorno, * comparacao, cont;
    int iguais;
    
    printf(""Verificacao de Seguranca.\n\n"");
    retorno = gerarCaptcha(captcha);
    printf(""%s\n"", retorno);
    printf(""\nEscreva os 6 caracteres que voce ve acima: \n"");
    gets(vetor);
    
    comparacao = compararCaptcha(captcha, vetor, iguais);
    printf("""", comparacao);
    
    iguais = 0;
    
    if(comparacao == 6)
        printf(""\nOs caracteres sao iguais!\n"");
    else
    {
        printf(""\nOs caracteres sao diferentes. Tente novamente.\n"");
        
        while(comparacao != 6)
        {
            retorno = gerarCaptcha(captcha);
            printf(""%s\n"", retorno);
            printf(""\nEscreva os 6 caracteres que voce ve acima: \n"");
            gets(vetor);
            
            for(cont = 0; cont < 6; cont++)
            {
                if(captcha[cont] == vetor[cont])
                iguais++;
            }
            
            comparacao = iguais;
            
            if(comparacao == 6)
            {
                printf(""\nOs caracteres sao iguais!\n"");
                break;
            }
            else
            {
                printf(""\nOs caracteres sao diferentes. Tente novamente.\n"");
            }
        }
    }
    return 0;
}
",51,1556,701
"#define PEDRA 1
#define PAPEL 2
#define TESOURA 3
#define LAGARTO 4
#define SPOCK 5

int main(int argc, char *argv[]) {
    
    int player1, player2, optP1, optP2;
    int mainMenu, playerMenu, modeMenu, novojogo;
    int totalJogadas, empates, vitoriasP1, vitoriasP2, totalNormal, totalMelhor, totalStartrek, totalDeath, tempVitP1, tempVitP2, especial, tempDeath;
    float percentP1, percentP2;
    
    srand( time(NULL) );
    totalJogadas=0;
    totalNormal=0;
    totalMelhor=0;
    totalStartrek=0;
    totalDeath=0;
    empates=0;
    vitoriasP1=0;
    vitoriasP2=0;
    especial=3;
    
    do {
    
        system(""cls"");
        printf(""\n     ___ _______ ___   _ _______ __    _ _______ _______ \n    |   |       |   | | |       |  |  | |       |       |\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\n|       |       |    _  |   |___| | |   |   |   |       |\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|"");
        
        printf(""\n\n\tO que voce quer fazer?\n"");
        printf(""\t1 - Jogar\n"");
        printf(""\t2 - Ver Regras\n"");
        printf(""\t3 - Ver Estatisticas\n"");
        printf(""\t4 - Sair\n\t"");
        
        if (totalJogadas > especial ) {
            printf(""\n\t0 - ESPECIAL DEATHMATCH\n"");
        }
        
        scanf(""%d"",&mainMenu);
        
        while( (mainMenu>4) || (totalJogadas<especial && mainMenu<1) ){
            printf(""\t-> Opcao invalida!\n"");
            printf(""\tO que voce quer fazer?\n\t"");
            scanf(""%d"",&mainMenu);
        }
        
        system(""cls"");
        
        if (mainMenu==1){
                
                printf(""\n     ___ _______ ___   _ _______ __    _ _______ _______ \n    |   |       |   | | |       |  |  | |       |       |\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\n|       |       |    _  |   |___| | |   |   |   |       |\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|"");
                printf(""\n\n\tComo voce quer jogar?\n"");
                printf(""\t1 - Player VS Player"");
                printf(""\n\t2 - Player VS Computador\n\t"");
                scanf(""%d"",&playerMenu);
                
                while(playerMenu<1 || playerMenu>2){
                    printf(""\t-> Opcao invalida!\n"");
                    printf(""\tComo voce quer jogar?\n\t"");
                    scanf(""%d"",&playerMenu);
                }
                
                system(""cls"");
                
                printf(""\n     ___ _______ ___   _ _______ __    _ _______ _______ \n    |   |       |   | | |       |  |  | |       |       |\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\n|       |       |    _  |   |___| | |   |   |   |       |\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|"");
                printf(""\n\n\tMODO DE JOGO:\n"");
                printf(""\t1 - Normal\n"");
                printf(""\t2 - Melhor de 3\n"");
                printf(""\t3 - Startreck\n\t"");
                scanf(""%d"",&modeMenu);
                
                while(modeMenu<1 || modeMenu>3){
                    printf(""-> Opcao invalida!\n"");
                    printf(""Como voce quer jogar?\n\t"");
                    scanf(""%d"",&modeMenu);
                }
                
                system(""cls"");
                
                if (modeMenu==1) {
                    
                    
                    do {
                        
                        printf(""Vez do Player 1.\n"");
                        printf(""Escolha uma opcao para jogar:\n"");
                        printf(""\t1 - Pedra\n"");
                        printf(""\t2 - Papel\n"");
                        printf(""\t3 - Tesoura\n"");
                        printf(""Numero: "");
                        scanf(""%d"",&optP1);
                        while( optP1<1 || optP1>3 ){
                            printf(""Opcao invalida. Digite novamente: "");
                            scanf(""%d"",&optP1);
                        }
                        
                        system(""cls"");
                        
                        printf(""Agora o Player 2.\n"");
                        printf(""Escolha uma opcao para jogar:\n"");
                        printf(""\t1 - Pedra\n"");
                        printf(""\t2 - Papel\n"");
                        printf(""\t3 - Tesoura\n"");
                        
                        system(""pause"");
                        printf(""Numero: "");
                        
                        if (playerMenu==1) {
                            scanf(""%d"",&optP2);
                            while( optP2<1 || optP2>3 ){
                                printf(""Opcao invalida. Digite novamente: "");
                                scanf(""%d"",&optP2);
                            }
                        } else {
                            optP2 = ( rand() % 2 ) + 1;
                            printf(""%d"",optP2);
                        
                        }
                        
                        totalJogadas++;
                        totalNormal++;
                        
                        if (optP1==optP2) {
                            printf(""\nEmpate!\n"");
                            empates++;
                        } else {
                            if ( (optP1==PEDRA&&optP2==TESOURA) || (optP1==PAPEL&&optP2==PEDRA) || (optP1==TESOURA&&optP2==PAPEL) ) {
                                printf(""\nPlayer 1 venceu!\n"");
                                vitoriasP1++;
                            } else {
                                printf(""\nPlayer 2 venceu!\n"");
                                vitoriasP2++;
                            }
                        }
                        
                        printf(""\nDigite 1 para jogar novamente, ou qualquer outro para sair!"");
                        scanf(""%d"",&novojogo);
                        system(""cls"");
                }while(novojogo==1);
                
                }
                else {
            
                    if (modeMenu==2) {
                        
                    do {
                        
                        tempVitP1=0;
                        tempVitP2=0;
                        
                            do {
                                system(""cls"");
                                printf(""P1(%d) VS P2 (%d)\n"",tempVitP1,tempVitP2);
                            
                            printf(""Vez do Player 1.\n"");
                            printf(""Escolha uma opcao para jogar:\n"");
                            printf(""\t1 - Pedra\n"");
                            printf(""\t2 - Papel\n"");
                            printf(""\t3 - Tesoura\n"");
                            printf(""Numero: "");
                            scanf(""%d"",&optP1);
                            while( optP1<1 || optP1>3 ){
                                printf(""Opcao invalida. Digite novamente: "");
                                scanf(""%d"",&optP1);
                            }
                            
                            system(""cls"");
                            
                            printf(""Agora o Player 2.\n"");
                            printf(""Escolha uma opcao para jogar:\n"");
                            printf(""\t1 - Pedra\n"");
                            printf(""\t2 - Papel\n"");
                            printf(""\t3 - Tesoura\n"");
    
                            system(""pause"");
                            printf(""Numero: "");
                            
                            if (playerMenu==1) {
                                scanf(""%d"",&optP2);
                                while( optP2<1 || optP2>3 ){
                                    printf(""Opcao invalida. Digite novamente: "");
                                    scanf(""%d"",&optP2);
                                }
                            } else {
                                optP2 = ( rand() % 2 ) + 1;
                                printf(""%d"",optP2);
                            }
                            
                            if (optP1==optP2) {
                                printf(""\nEmpate!\n"");
                                empates++;
                            } else {
                                if ( (optP1==PEDRA&&optP2==TESOURA) || (optP1==PAPEL&&optP2==PEDRA) || (optP1==TESOURA&&optP2==PAPEL) ) {
                                    printf(""\nPlayer 1 venceu a rodada!\n"");
                                    tempVitP1++;
                                } else {
                                    printf(""\nPlayer 2 venceu a rodada!\n"");
                                    tempVitP2++;
                                }
                            }
                            system(""pause"");
                        
                    }while( tempVitP1<2 && tempVitP2<2 );
                        
                        totalJogadas++;
                        totalMelhor++;
                        
                        system(""cls"");
                        if (tempVitP1 > tempVitP2) {
                            printf(""\nPlayer 1 venceu a partida!\n"");
                            vitoriasP1++;
                        } else {
                            printf(""\nPlayer 2 venceu a partida!\n"");
                            vitoriasP2++;
                        }
                        
                        system(""pause"");
                        system(""cls"");
                        
                        printf(""\nDigite 1 para jogar novamente, ou qualquer outro para sair!"");
                        scanf(""%d"",&novojogo);
                        system(""cls"");
                    }while(novojogo==1);
                        
                    } else {
                        
                        if (modeMenu==3) {
                            
                            do {

                        printf(""Vez do Player 1.\n"");
                        printf(""Escolha uma opcao para jogar:\n"");
                        printf(""\t1 - Pedra\n"");
                        printf(""\t2 - Papel\n"");
                        printf(""\t3 - Tesoura\n"");
                        printf(""\t4 - Lagarto\n"");
                        printf(""\t5 - Spoc\n"");
                        printf(""Numero: "");
                        scanf(""%d"",&optP1);
                        while( optP1<1 || optP1>5 ){
                            printf(""Opcao invalida. Digite novamente: "");
                            scanf(""%d"",&optP1);
                        }
                        
                        system(""cls"");
                        
                        printf(""Agora o Player 2.\n"");
                        printf(""Escolha uma opcao para jogar:\n"");
                        printf(""\t1 - Pedra\n"");
                        printf(""\t2 - Papel\n"");
                        printf(""\t3 - Tesoura\n"");
                        printf(""\t4 - Lagarto\n"");
                        printf(""\t5 - Spoc\n"");
                        
                        system(""pause"");
                        printf(""Numero: "");
                        
                        if (playerMenu==1) {
                            scanf(""%d"",&optP2);
                            while( optP2<1 || optP2>5 ){
                                printf(""Opcao invalida. Digite novamente: "");
                                scanf(""%d"",&optP2);
                            }
                        } else {
                            optP2 = ( rand() % 4 ) + 1;
                            printf(""%d"",optP2);
                        }
                        
                        totalJogadas++;
                        totalStartrek++;
                        
                        if (optP1==optP2) {
                            printf(""\nEmpate!\n"");
                            empates++;
                        } else {
                            if (
                            
                                (optP1==PEDRA&&optP2==TESOURA) ||
                                (optP1==PEDRA&&optP2==LAGARTO) ||
                                
                                (optP1==LAGARTO&&optP2==PAPEL) ||
                                (optP1==LAGARTO&&optP2==SPOCK) ||
                                
                                (optP1==SPOCK&&optP2==PEDRA) ||
                                (optP1==SPOCK&&optP2==TESOURA) ||
                                
                                (optP1==TESOURA&&optP2==LAGARTO) ||
                                (optP1==TESOURA&&optP2==PAPEL) ||
                                
                                (optP1==PAPEL&&optP2==PEDRA) ||
                                (optP1==PAPEL&&optP2==SPOCK)
                            
                            ) {
                                printf(""\nPlayer 1 venceu!\n"");
                                vitoriasP1++;
                            } else {
                                printf(""\nPlayer 2 venceu!\n"");
                                vitoriasP2++;
                            }
                        }
                        
                        printf(""\nDigite 1 para jogar novamente, ou qualquer outro para sair!!"");
                        scanf(""%d"",&novojogo);
                        system(""cls"");
                    }while(novojogo==1);
                            
                        }
                        
                    }
            
                }
        
        }
        
        else {
            
            if (mainMenu==2) {
                
                printf(""\n     ___ _______ ___   _ _______ __    _ _______ _______ \n    |   |       |   | | |       |  |  | |       |       |\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\n|       |       |    _  |   |___| | |   |   |   |       |\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|"");
                
                printf(""\n\n\tREGRAS:\n"");
                printf(""\tNo Jokenpo, os jogadores devem escolher numeros, no qual cada numero representa um simbolo.\n"");
                printf(""\tEsses simbolos sao comparados para ver quem ganhou, da seguinte forma:\n"");
                printf(""\t\t- PEDRA ganha da TESOURA (quebrando-a).\n"");
                printf(""\t\t- TESOURA ganha do PAPEL (cortando-o).\n"");
                printf(""\t\t- PAPEL ganha da PEDRA (embrulhando-o).\n"");
                printf(""\tNa variacao Star Trek as regras anteriores permanecem, e outras sao adicionadas:\n"");
                printf(""\t\t- PEDRA ganha do LAGARTO (esmagando-o).\n"");
                printf(""\t\t- TESOURA ganha do LAGARTO (matando-o).\n"");
                printf(""\t\t- PAPEL ganha do SPOCK (cegando-o).\n"");
                printf(""\t\t- LAGARTO ganha do PAPEL (comendo-o).\n"");
                printf(""\t\t- LAGARTO ganha do SPOCK (envenenando-o).\n"");
                printf(""\t\t- SPOCK ganha da PEDRA (vaporizando-a).\n"");
                printf(""\t\t- SPOCK ganha da TESOURA (quebrando-a).\n\n"");
                system(""pause"");
                
            } else {
                
                if (mainMenu==3) {
                    
                    printf(""\n     ___ _______ ___   _ _______ __    _ _______ _______ \n    |   |       |   | | |       |  |  | |       |       |\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\n|       |       |    _  |   |___| | |   |   |   |       |\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|"");
                    printf(""\n\n\tTotal de Jogadas: %d\n"",totalJogadas);
                    
                    printf(""\t\tEmpates: %d\n"",empates);
                    percentP1=(100.0*vitoriasP1)/totalJogadas;
                    printf(""\t\tVitorias Player 1: %d(%f%%)\n"",vitoriasP1,percentP1);
                    percentP2=(100.0*vitoriasP2)/totalJogadas;
                    printf(""\t\tVitorias Player 2: %d(%f%%)\n"",vitoriasP2,percentP2);

                    printf(""\tJogadas no Modo Normal: %d\n"",totalNormal);
                    printf(""\tJogadas no Modo Melhor de 3: %d\n"",totalMelhor);
                    printf(""\tJogadas no Modo Star Trek: %d\n"",totalStartrek);
                    system(""pause"");
                    
                } else if (mainMenu==0) {
                            
                    do {
                        
                        tempVitP1=0;
                        tempDeath=0;
                        
                            do {
                                
                            printf(""\tDEATMATCH\n"");
                            printf(""\tEste e o modo especial de Jokenpo. Resista o maximo que puder e veja quantas partidas seguidas voce consegue vencer!\n"");
                                
                            system(""cls"");
                            printf(""P1(%d) VS P2 (%d)\n"",tempVitP1,tempVitP2);
                            
                            printf(""Vez do Player 1.\n"");
                            printf(""Escolha uma opcao para jogar:\n"");
                            printf(""\t1 - Pedra\n"");
                            printf(""\t2 - Papel\n"");
                            printf(""\t3 - Tesoura\n"");
                            printf(""Numero: "");
                            scanf(""%d"",&optP1);
                            while( optP1<1 || optP1>3 ){
                                printf(""Opcao invalida. Digite novamente: "");
                                scanf(""%d"",&optP1);
                            }
                            
                            system(""cls"");
                            
                            printf(""Agora o Player 2.\n"");
                            printf(""Escolha uma opcao para jogar:\n"");
                            printf(""\t1 - Pedra\n"");
                            printf(""\t2 - Papel\n"");
                            printf(""\t3 - Tesoura\n"");
    
                            system(""pause"");
                            printf(""Numero: "");

                            optP2 = ( rand() % 2 ) + 1;
                            printf(""%d"",optP2);
                            
                            if (optP1==optP2) {
                                printf(""\nEmpate!\n"");
                                empates++;
                            } else {
                                if ( (optP1==PEDRA&&optP2==TESOURA) || (optP1==PAPEL&&optP2==PEDRA) || (optP1==TESOURA&&optP2==PAPEL) ) {
                                    printf(""\nPlayer 1 venceu a rodada!\n"");
                                    tempVitP1=1;
                                    tempDeath++;
                                } else {
                                    printf(""\nPlayer 2 venceu a rodada e encerrou a partida!\n"");
                                    tempVitP1=2;
                                }
                            }
                            system(""pause"");
                        
                    }while( tempVitP1==1 );
                        
                        totalJogadas++;
                        totalDeath++;
                        
                        system(""cls"");

                            printf(""\nVoce ganhou: %d partidas!\n"",tempDeath);
                            vitoriasP1++;
                        
                        system(""pause"");
                        system(""cls"");
                        
                        printf(""\nDigite 1 para jogar novamente, ou qualquer outro para sair!"");
                        scanf(""%d"",&novojogo);
                        system(""cls"");
                    }while(novojogo==1);
                    
                }
                
            }
            
        }
    
    }while(mainMenu>=1 && mainMenu<=3);
    return 0;
}
",51,1557,5690
"int main(int argc, char *argv[]) {
    float percVitoriasComputador, percVitoriasJogador, percVitoriasJogador1, percVitoriasJogador2;
    int computador, jogador, jogador1, jogador2, opcao, jogar;
    int vitComputador, vitJogador, vitJogador1, vitJogador2, empate, partidas;
    srand(time(NULL));
    
    vitComputador = 0;
    vitJogador = 0;
    vitJogador1 = 0;
    vitJogador2 = 0;
    empate = 0;
    partidas = 0;
    
    printf(""\nDigite 1 para jogar contra o computador. \n"");
    printf(""Digite 2 para jogar contra outro jogador. \n"");
    scanf(""%d"", &opcao);
    while(opcao < 1 || opcao > 2)
    {
        printf(""Opcao invalida. Digite novamente."");
        printf(""\nDigite 1 para jogar contra o computador. \n"");
        printf(""Digite 2 para jogar contra outro jogador. \n"");
        scanf(""%d"", &opcao);
    }
        do{
            switch(opcao)
            {
                case 1:
                    printf(""\nEscolha uma opcao: \n"");
                    printf(""1. Pedra\n"");
                    printf(""2. Papel\n"");
                    printf(""3. Tesoura\n"");
                    scanf(""%d"", &jogador);
                    
                    while(jogador < 1 || jogador > 3)
                    {
                        printf(""Opcao invalida. Digite novamente.\n"");
                        printf(""\nEscolha uma opcao: \n"");
                        printf(""1. Pedra\n"");
                        printf(""2. Papel\n"");
                        printf(""3. Tesoura\n"");
                        scanf(""%d"", &jogador);
                    }
                    computador = rand();
                    printf("""", computador, (1 + computador % 3));
                    printf(""\nComputador escolheu %d\n"", (1 + computador % 3));
                    if((1 + computador % 3) == 2 && jogador == 1 || (1 + computador % 3) == 3 && jogador == 2 || (1 + computador % 3) == 1 && jogador == 3)
                    {
                        printf(""Computador ganhou.\n"");
                        vitComputador++;
                    }else
                    {
                        if(jogador == (1 + computador % 3))
                        {
                            printf(""Empate.\n"");
                            empate++;
                        }else
                        {
                            printf(""Jogador ganhou.\n"");
                            vitJogador++;
                        }
                    }
                    partidas++;
                    printf(""\nJogar novamente?\n"");
                    printf(""1. Sim\n"");
                    printf(""2. Nao\n"");
                    scanf(""%d"", &jogar);
                    while(jogar < 1 || jogar > 2)
                    {
                        printf(""Opcao invalida. Escolha novamente.\n"");
                        printf(""\nJogar novamente?\n"");
                        printf(""1. Sim\n"");
                        printf(""2. Nao\n"");
                        scanf(""%d"", &jogar);
                    }
                    break;
                case 2:
                    printf(""\nJogador 1 escolha uma opcao: \n"");
                    printf(""1. Pedra\n"");
                    printf(""2. Papel\n"");
                    printf(""3. Tesoura\n"");
                    scanf(""%d"", &jogador1);
                    
                    while(jogador1 < 1 || jogador1 > 3)
                    {
                        printf(""Opcao invalida. Digite novamente.\n"");
                        printf(""\nJogador 1 escolha uma opcao: \n"");
                        printf(""1. Pedra\n"");
                        printf(""2. Papel\n"");
                        printf(""3. Tesoura\n"");
                        scanf(""%d"", &jogador1);
                    }
                    printf(""\nJogador 2 escolha uma opcao: \n"");
                    printf(""1. Pedra\n"");
                    printf(""2. Papel\n"");
                    printf(""3. Tesoura\n"");
                    scanf(""%d"", &jogador2);
                    
                    while(jogador2 < 1 || jogador2 > 3)
                    {
                        printf(""Opcao invalida. Digite novamente.\n"");
                        printf(""\nJogador 2 escolha uma opcao: \n"");
                        printf(""1. Pedra\n"");
                        printf(""2. Papel\n"");
                        printf(""3. Tesoura\n"");
                        scanf(""%d"", &jogador2);
                    }
                    if(jogador1 == 2 && jogador2 == 1 || jogador1 == 3 && jogador2 == 2 || jogador1 == 1 && jogador2 == 3)
                    {
                        printf(""Jogador 1 ganhou.\n"");
                        vitJogador1++;
                    }else
                    {
                        if(jogador1 == jogador2)
                        {
                            printf(""Empate.\n"");
                            empate++;
                        }else
                        {
                            printf(""Jogador 2 ganhou.\n"");
                            vitJogador2++;
                        }
                    }
                    partidas++;
                    printf(""\nJogar novamente?\n"");
                    printf(""3. Sim\n"");
                    printf(""4. Nao\n"");
                    scanf(""%d"", &jogar);
                    while(jogar < 3 || jogar > 4)
                    {
                        printf(""Opcao invalida. Escolha novamente.\n"");
                        printf(""\nJogar novamente?\n"");
                        printf(""3. Sim\n"");
                        printf(""4. Nao\n"");
                        scanf(""%d"", &jogar);
                    }
                    break;
            }
            if(jogar == 1)
            {
            }else
            {
                if(jogar == 2)
                {
                    printf(""\nTotal de %d partida(s).\n"", partidas);
                    printf(""\nComputador venceu %d partida(s). \n"", vitComputador);
                    printf(""Jogador venceu %d partida(s). \n"", vitJogador);
                    printf(""Total de %d empate(s). \n"", empate);
                    percVitoriasComputador = (vitComputador * 100) / partidas;
                    printf(""Percentual de vitorias do computador = %.2f%%\n"", percVitoriasComputador);
                    percVitoriasJogador = (vitJogador * 100) / partidas;
                    printf(""Percentual de vitorias do jogador = %.2f%%\n"", percVitoriasJogador);
                    break;          
                }else
                {
                    if(jogar == 3)
                    {
                    }else
                    {
                        if(jogar == 4)
                        {
                            printf(""\nTotal de %d partida(s).\n"", partidas);
                            printf(""\nJogador 1 venceu %d partida(s). \n"", vitJogador1);
                            printf(""Jogador 2 venceu %d partida(s). \n"", vitJogador2);
                            printf(""Total de %d empate(s). \n"", empate);
                            percVitoriasJogador1 = (vitJogador1 * 100) / partidas;
                            printf(""Percentual de vitorias do jogador 1 = %.2f%\n"", percVitoriasJogador1);
                            percVitoriasJogador2 = (vitJogador2 * 100) / partidas;
                            printf(""Percentual de vitorias do jogador 2 = %.2f%\n"", percVitoriasJogador2);
                            break;
                        }
                    }
                }
            }       
        }while(opcao == 1 || opcao == 2);   
    return 0;
}
",51,1558,2197
"int main(void) {
    int jogadorUm, jogadorDois, nEmpatesUm, nEmpatesDois, nDerrotasUm , nDerrotasDois;
    int opcao, menu;
    float nVitoriasUm, nVitoriasDois, pVitoriasUm, pVitoriasDois, nJogadas;
    
    opcao = 1;
    nVitoriasDois = 0;
    nDerrotasUm = 0;
    
    printf(""------------------------------------\n-------------bem vindo!-------------\n------------------------------------\n\n"");
        
    while(opcao != 3){
    
    printf(""Selecione seu modo de jogo: \n\n"");
    printf(""1- PvC - Player vs Computer \n"");
    printf(""2- PvP - Player vs Player \n"");
    printf(""3- sair\n"");
    fflush(stdin);
    scanf(""%d"", &opcao);
    
    
    
    
    switch(opcao){
    
    
        case 1: 
        
         jogadorUm = 0;
         jogadorDois = 0;
         nVitoriasUm = 0;
         nVitoriasDois = 0;
         nEmpatesUm = 0;
         nEmpatesDois = 0;
         nJogadas = 0;
         nDerrotasUm  = 0;
         nDerrotasDois = 0;
         pVitoriasUm = 0;
         pVitoriasDois = 0;
        
        while(menu !=4){
                 
        
           printf(""\nSelecione sua opcao: \n"");
           printf(""1- Pedra\n 2- Papel \n 3- Tesoura. \n"");
           scanf(""%d"", &jogadorUm);
           
           srand(time(NULL));
           jogadorDois = 1 + rand() %3;
           printf(""\nOpcao jogadorDois = %d "", jogadorDois, (jogadorDois % 4));
           
           
if(jogadorUm == 1 && jogadorDois == 1){
            printf(""\nDeu Empate!\n"");
            nEmpatesUm = nEmpatesUm + 1;
            nEmpatesDois = nEmpatesDois + 1; 
            nJogadas = nJogadas + 1;
                
      }else{
          if(jogadorUm == 1 && jogadorDois == 2){  
                       printf(""\nO jogador Dois ganhou\n"");
                       nDerrotasUm = nDerrotasUm + 1;
                       nVitoriasDois = nVitoriasDois + 1;
                       nJogadas = nJogadas + 1;                   
                     
         }else{
              if(jogadorUm == 1 && jogadorDois == 3){
                           printf(""\nO Jogador Um ganhou\n"");
                           nDerrotasDois = nDerrotasDois + 1;
                           nVitoriasUm = nVitoriasUm + 1;
                           nJogadas = nJogadas + 1;
                           
                            
              }else{
                    if(jogadorUm == 2 && jogadorDois == 1){ 
                                 printf(""\nO jogador Dois ganhou\n"");
                                 nDerrotasUm = nDerrotasUm + 1;
                                 nVitoriasDois = nVitoriasDois + 1;
                                 nJogadas = nJogadas + 1;
                                
                           
                    }else{
                          if(jogadorUm == 2 && jogadorDois == 2){
                                       printf(""\nDeu empate\n"");
                                       nEmpatesUm = nEmpatesUm + 1;
                                       nEmpatesDois = nEmpatesDois + 1;
                                       nJogadas = nJogadas + 1;
                                       
                         }else{
                               if(jogadorUm == 2 && jogadorDois == 3){  
                                            printf(""\nO jogador dois ganhou\n"");
                                            nVitoriasDois = nVitoriasDois + 1;
                                            nDerrotasUm = nDerrotasUm + 1;
                                            nJogadas = nJogadas + 1;
                                           
                              }else{
                                    if (jogadorUm == 3 && jogadorDois == 1){
                                                  printf(""\nO jogador Dois ganhou\n"");
                                                  nVitoriasDois = nVitoriasDois + 1;
                                                  nDerrotasUm = nDerrotasUm + 1;
                                                  nJogadas = nJogadas + 1;
                                                  
                                                           
                                    }else{
                                          if(jogadorUm == 3 && jogadorDois == 2){
                                                       printf(""\nO jogador Um ganhou\n"");
                                                       nDerrotasDois = nDerrotasDois + 1;
                                                       nVitoriasUm = nVitoriasUm + 1;
                                                       nJogadas = nJogadas + 1;
                                                      
                                            }else{
                                                  if(jogadorUm == 3 && jogadorDois == 3){
                                                               printf(""\nDeu Empate\n"");
                                                               nEmpatesUm = nEmpatesUm + 1;
                                                               nEmpatesDois = nEmpatesDois + 1;
                                                               nJogadas = nJogadas + 1;
                                                    
                                                  }else{
                                                       printf(""\nJogada Invalida\n"");
                                                  } 
                                                            
}}}}}}}}
            
            if(nVitoriasUm == 0)
            {
                   pVitoriasUm = 0;
                   }else 
                   {
                          pVitoriasUm = ( nVitoriasUm/ nJogadas ) * 100;
                   }
                                if(nVitoriasDois == 0)
                                {
                                        pVitoriasDois = 0;
                                        }else
                                        {
                                                pVitoriasDois = ( nVitoriasDois / nJogadas ) * 100;
            }
            printf(""\nJOGADOR 1: \n"");
            printf(""\nQuantidade de Vitorias: %.0f"", nVitoriasUm);
            printf(""\nQuantidade de Derrotas: %d"", nDerrotasUm);
            printf(""\nQuantidade de Empates: %d"", nEmpatesUm);
            printf(""\nPercentual de Vitorias: %.2f %%"", pVitoriasUm );
            printf(""\n------------------------------------------------------------------"");
            printf(""\nJOGADOR 2: \n"");
            printf(""\nQuantidade de Vitorias: %.0f"", nVitoriasDois);
            printf(""\nQuantidade de Derrotas: %d"", nDerrotasDois);
            printf(""\nQuantidade de Empates: %d"", nEmpatesDois);
            printf(""\nPercentual de Vitorias: %.2f %%"", pVitoriasDois);
            printf(""\n------------------------------------------------------------------"");
            printf(""\nGERAL: \n"");
            printf(""Quantidade de Jogadas Total: %.0f"", nJogadas);

            printf(""\ndeseja jogar novamente?\n"");
            scanf(""%d"", &menu);
            system(""cls"");
    }
        break;
           
        case 2:  
        
         jogadorUm = 0;
         jogadorDois = 0;
         nVitoriasUm = 0;
         nVitoriasDois = 0;
         nEmpatesUm = 0;
         nEmpatesDois = 0;
         nJogadas = 0;
         nDerrotasUm  = 0;
         nDerrotasDois = 0;
         pVitoriasUm = 0;
         pVitoriasDois = 0;
        
        while(opcao != 3){
        
           printf(""\nSelecione sua opcao: \n"");
           printf(""1- Pedra\n 2- Papel \n 3- Tesoura. \n"");
           scanf(""%d"", &jogadorUm);
           
           printf(""\nSelecione sua opcao: \n"");
           printf(""1- Pedra\n 2- Papel \n 3- Tesoura. \n"");
           scanf(""%d"", &jogadorDois);
           system(""cls"");
                   
if(jogadorUm == 1 && jogadorDois == 1){
            printf(""\nDeu Empate!\n"");
            nEmpatesUm = nEmpatesUm + 1;
            nEmpatesDois = nEmpatesDois + 1; 
            nJogadas = nJogadas + 1;
                
      }else{
          if(jogadorUm == 1 && jogadorDois == 2){  
                       printf(""\nO jogador Dois ganhou\n"");
                       nDerrotasUm = nDerrotasUm + 1;
                       nVitoriasDois = nVitoriasDois + 1;
                       nJogadas = nJogadas + 1;                   
                     
         }else{
              if(jogadorUm == 1 && jogadorDois == 3){
                           printf(""\nO Jogador Um ganhou\n"");
                           nDerrotasDois = nDerrotasDois + 1;
                           nVitoriasUm = nVitoriasUm + 1;
                           nJogadas = nJogadas + 1;
                           
                            
              }else{
                    if(jogadorUm == 2 && jogadorDois == 1){ 
                                 printf(""\nO jogador Dois ganhou\n"");
                                 nDerrotasUm = nDerrotasUm + 1;
                                 nVitoriasDois = nVitoriasDois + 1;
                                 nJogadas = nJogadas + 1;
                                
                           
                    }else{
                          if(jogadorUm == 2 && jogadorDois == 2){
                                       printf(""\nDeu empate\n"");
                                       nEmpatesUm = nEmpatesUm + 1;
                                       nEmpatesDois = nEmpatesDois + 1;
                                       nJogadas = nJogadas + 1;
                                       
                         }else{
                               if(jogadorUm == 2 && jogadorDois == 3){  
                                            printf(""\nO jogador dois ganhou\n"");
                                            nVitoriasDois = nVitoriasDois + 1;
                                            nDerrotasUm = nDerrotasUm + 1;
                                            nJogadas = nJogadas + 1;
                                           
                              }else{
                                    if (jogadorUm == 3 && jogadorDois == 1){
                                                  printf(""\nO jogador Dois ganhou\n"");
                                                  nVitoriasDois = nVitoriasDois + 1;
                                                  nDerrotasUm = nDerrotasUm + 1;
                                                  nJogadas = nJogadas + 1;
                                                  
                                                           
                                    }else{
                                          if(jogadorUm == 3 && jogadorDois == 2){
                                                       printf(""\nO jogador Um ganhou\n"");
                                                       nDerrotasDois = nDerrotasDois + 1;
                                                       nVitoriasUm = nVitoriasUm + 1;
                                                       nJogadas = nJogadas + 1;
                                                      
                                            }else{
                                                  if(jogadorUm == 3 && jogadorDois == 3){
                                                               printf(""\nDeu Empate\n"");
                                                               nEmpatesUm = nEmpatesUm + 1;
                                                               nEmpatesDois = nEmpatesDois + 1;
                                                               nJogadas = nJogadas + 1;
                                                    
                                                        }else{
                                                                 printf(""\nJogada Invalida\n"");
           
                                                                                        
}}}}}}}}}
            
            if(nVitoriasUm == 0)
            {
                   pVitoriasUm = 0;
                 }
                 else
                     {
                        pVitoriasUm = ( nVitoriasUm / nJogadas ) * 100;
                     }
                             if(nVitoriasDois == 0){
                                    pVitoriasDois = 0;
                                    }
                                     else
                                     {
                                               pVitoriasDois = ( nVitoriasDois / nJogadas ) * 100;
            }
            
            printf(""\nJOGADOR 1: \n"");
            printf(""\nQuantidade de Vitorias: %.0f"", nVitoriasUm);
            printf(""\nQuantidade de Derrotas: %d"", nDerrotasUm);
            printf(""\nQuantidade de Empates: %d"", nEmpatesUm);
            printf(""\nPercentual de Vitorias: %.2f"", pVitoriasUm );
            printf(""\n------------------------------------------------------------------"");
            printf(""\nJOGADOR 2: \n"");
            printf(""\nQuantidade de Vitorias: %.0f"", nVitoriasDois);
            printf(""\nQuantidade de Derrotas: %d"", nDerrotasDois);
            printf(""\nQuantidade de Empates: %d"", nEmpatesDois);
            printf(""\nPercentual de Vitorias: %.2f %%"", pVitoriasDois);
            printf(""\n------------------------------------------------------------------"");
            printf(""\nGERAL: \n"");
            printf(""Quantidade de Jogadas Total: %.0f"", nJogadas);
            
                
            printf(""\ndeseja jogar novamente?\n"");
            scanf(""%d"", &menu);
            system(""cls"");      
        }

           break;
        case 3:
           printf(""Cansou de jogar? \n"");
           system(""exit"");
           
           break;
           
        default:           
            printf(""opcao invalida"");
            break;
        }
}

    
    if(menu == 2){
        
        printf(""Voce saira do jogo!"");
    }

}


",51,1559,3809
"char * gerarCaptcha(char captcha[6] )
 {
   
   int cont;
   
   for (cont = 0 ; cont < 4 ; cont++)
    {
       captcha[cont] = 97 + (rand() % 25);
    }
    
    
    for (cont = 4 ; cont < 6 ; cont++)
    {
       captcha[cont] = 48 + (rand() % 9);
    }
    
    captcha[0] = (captcha[0] - 32);
    
    return captcha;
}


char * lerDigitado(char digitado[50])
{
    gets(digitado);
    
    return digitado;
}


int compararCaptcha(char digitado[6] , char captcha[6])
{
  int cont;
  int resultadoComparacao;  
  
  resultadoComparacao = strcmp(digitado,captcha);
  
  return resultadoComparacao;
}



int main(int argc, char *argv[]) {
    
    srand(time(NULL));
    
    int cont;
    int resultado;
    
    char * captcha;
    char vetorCaptcha[7];
    
    char * digitado;
    char vetorDigitado[50];
    
    resultado = 1;
    
    printf(""\n =========\n |CAPTCHA| \n =========\n\nDite o codigo abaixo corretamente para continuar: \n\n"");
    
    do{
        captcha = gerarCaptcha(vetorCaptcha);
        printf(""%s\n"" , captcha);
            
        digitado = lerDigitado(vetorDigitado);
        
        resultado = compararCaptcha(digitado , captcha);
        
        if (resultado != 0)
        {
          printf(""\nIncorreto! Tente novamente:\n\n"");
        }
        
    }while(resultado != 0);
    
    printf(""\nCORRETO!!!\Agora ja pode prosseguir..."");
        
    return 0;
    
}
",51,1560,544
"#define TOTAL 6
#define bool int
#define TRUE 1
#define FALSE 0

struct Palavra {
    char nome[20];
    int tipo;
};
struct Palavra palavras[15];

int numeroAleatorio(int min, int max){
    int dif;
    max++;
    dif=max-min;
    return (rand()%dif)+min;
}
char * gerarCaptchaSimples(){
    
    int cont, tipo, min, max;
    char novoCaptcha[TOTAL], caractere;
    
    for(cont=0;cont<TOTAL;cont++){
        tipo=numeroAleatorio(1,3);
        
        switch(tipo){
            case 1:
                min=65;
                max=90;
            break;
            case 2:
                min=97;
                max=122;
            break;
            case 3:
                min=48;
                max=57;
            break;
        }
        
        caractere=numeroAleatorio(min,max);
        novoCaptcha[cont]=caractere;
        
    }
    novoCaptcha[TOTAL]=0;
    
    return novoCaptcha;
    
}
bool verificarCaptchaSimples(char stringA[TOTAL], char stringB[TOTAL]){
    if (strcmp(stringA,stringB)==0){
        return TRUE;
    } else {
        return FALSE;
    }   
}

char * gerarCaptchaMatematico(){
    
    int cont, tipo, caractere;
    char captcha[3];
    
    captcha[0]=numeroAleatorio(48,57);
    tipo=numeroAleatorio(1,2);
        switch(tipo){
            case 1:
                caractere=43;
            break;
            case 2:
                caractere=42;
            break;
        }
    captcha[1]=caractere;
    captcha[2]=numeroAleatorio(48,57);
    captcha[3]=0;
    
    return captcha;
    
}
int real(char caractere){
    int numero;
    
    switch(caractere){
        case 48:
        numero=0;
        break;
        case 49:
        numero=1;
        break;
        case 50:
        numero=2;
        break;
        case 51:
        numero=3;
        break;
        case 52:
        numero=4;
        break;
        case 53:
        numero=5;
        break;
        case 54:
        numero=6;
        break;
        case 55:
        numero=7;
        break;
        case 56:
        numero=8;
        break;
        case 57:
        numero=9;
        break;
    }
    return numero;
}
bool verificarCaptchaMatematico(char *conta, int resultado){
    
    int resultadoReal, valorA, valorB, simbolo;
    
    valorA=real(conta[0]);
    valorB=real(conta[2]);
    simbolo=conta[1];
    
    if (conta[1]==42){
        resultadoReal=valorA*valorB;
    } else {
        resultadoReal=valorA+valorB;
    }
    
    if (resultadoReal==resultado) {
        return TRUE;
    } else {
        return FALSE;
    }

}
char ** gerarCaptchaLogico(char verificador[7][20]){
    int tipo, cont, randPalavra, min, max, baseTipo;
    char novoCaptcha[7][20];
    
    for(cont=1;cont<6;cont++){
        tipo=numeroAleatorio(1,3);
        switch(tipo){
            case 1:
                min=0;
                max=4;
                break;
            case 2:
                min=5;
                max=9;
                break;
            case 3:
                min=10;
                max=14;
                break;
        }
        randPalavra=numeroAleatorio(min,max);
        strcpy(verificador[cont],palavras[randPalavra].nome);
    }
    
    baseTipo=buscaTipo(verificador[numeroAleatorio(1,5)]);
    switch(baseTipo){
        case 1:
            strcpy(verificador[0],""cor"");
            strcpy(verificador[6],""1"");
            break;
        case 2:
            strcpy(verificador[0],""animal"");
            strcpy(verificador[6],""2"");
            break;
        case 3:
            strcpy(verificador[0],""objeto"");
            strcpy(verificador[6],""3"");
            break;
    }
    
    return novoCaptcha;
}
int buscaTipo(char palavra[20]){
    int tipo, cont;
    
    for(cont=0;cont<15;cont++){
        if (strcmp(palavras[cont].nome,palavra)==0) {
            return palavras[cont].tipo;
            break;
        }
    }
    
    return FALSE;
}
bool verificarCaptchaLogico(char captcha[7][20],int alternativa){
    int tipo,numero;
    tipo=buscaTipo(captcha[alternativa]);
    numero=captcha[6][0]-48;
    
    if (tipo==numero) {
        return TRUE;
    } else {
        return FALSE;
    }
}
int main() {
    char captcha[TOTAL], entrada[TOTAL], verificador[7][20];
    int verificacao, entradaNumerica, cont;
    
    strcpy(palavras[0].nome,""Amarelo"");
    palavras[0].tipo=1;
    strcpy(palavras[1].nome,""Azul"");
    palavras[1].tipo=1;
    strcpy(palavras[2].nome,""Roxo"");
    palavras[2].tipo=1;
    strcpy(palavras[3].nome,""Verde"");
    palavras[3].tipo=1;
    strcpy(palavras[4].nome,""Cinza"");
    palavras[4].tipo=1;
    
    strcpy(palavras[5].nome,""Porco"");
    palavras[5].tipo=2;
    strcpy(palavras[6].nome,""Cavalo"");
    palavras[6].tipo=2;
    strcpy(palavras[7].nome,""Rato"");
    palavras[7].tipo=2;
    strcpy(palavras[8].nome,""Cachorro"");
    palavras[8].tipo=2;
    strcpy(palavras[9].nome,""Gato"");
    palavras[9].tipo=2;
    
    strcpy(palavras[10].nome,""Garfo"");
    palavras[10].tipo=3;
    strcpy(palavras[11].nome,""Faca"");
    palavras[11].tipo=3;
    strcpy(palavras[12].nome,""Prato"");
    palavras[12].tipo=3;
    strcpy(palavras[13].nome,""Copo"");
    palavras[13].tipo=3;
    strcpy(palavras[14].nome,""Panela"");
    palavras[14].tipo=3;
    
    srand(time(NULL));
    
    do {
        system(""cls"");
        strcpy(captcha,gerarCaptchaSimples());
        printf(""\n%s"",captcha);
        printf(""\nDigite os caracteres da linha anetior: "");
        gets(entrada);
        verificacao=verificarCaptchaSimples(captcha,entrada);
        if (verificacao) {
            printf(""\nCaptcha correto!\n"");
        } else {
            printf(""\nCaptcha incorreto!\n"");
        }
        system(""pause"");
    }while(verificacao==FALSE);
    
    do{
        system(""cls"");
        strcpy(captcha,gerarCaptchaMatematico());
        printf(""\n%s"",captcha);
        printf(""\nDigite o resultado da operacao anterior: "");
        scanf(""%d"",&entradaNumerica);
        verificacao=verificarCaptchaMatematico(captcha,entradaNumerica);
        if (verificacao) {
            printf(""\nCaptcha correto!\n"");
        } else {
            printf(""\nCaptcha incorreto!\n"");
        }
        system(""pause"");
    }while(verificacao==FALSE);
    
    do{
        system(""cls"");
        gerarCaptchaLogico(verificador);
        for(cont=1;cont<6;cont++){
            printf(""\n%d - %s"",cont,verificador[cont]);
        }
        printf(""\nSelecione um(a) %s da lista anterior:"",verificador[0]);
        scanf(""%d"",&entradaNumerica);
        while(entradaNumerica<1 || entradaNumerica>5){
            printf(""\nOpcao invalida. Digite novamente: "");
            scanf(""%d"",&entradaNumerica);
        }
        verificacao=verificarCaptchaLogico(verificador,entradaNumerica);
        if (verificacao) {
            printf(""\nCaptcha correto!\n"");
        } else {
            printf(""\nCaptcha incorreto!\n"");
        }
        system(""pause"");
    }while(verificacao==FALSE);

}

",51,1561,2542
"void main(){
    char nome[50];
    int capacidade,operacao,capacidadeMeiaEntrada,confirmacao,vendidoMeia,vendidoInteira;
    float valorInteira,meiaEntrada,valorPago,troco;
    vendidoMeia = 0;
    vendidoInteira = 0;
    
    printf(""Ingressos++"");
    printf(""\nCadastre um evento"");
    printf(""\nNome do evento: \n"");
    gets(nome);
    printf(""\nCapacidade maxima: \n"");
    scanf(""%d"", &capacidade);
    capacidadeMeiaEntrada = capacidade*0.4;
    printf(""\nValor da entrada: \n"");
    scanf(""%g"", &valorInteira);
    meiaEntrada = valorInteira/2;
    
    printf(""\nEvento: %s"", nome);
    printf(""\nCapacidade maxima de %d"", capacidade);
    printf(""\nValor da entrada(Inteira): %g"",valorInteira);
    printf(""\nValor da entrada(Meia): %g"",meiaEntrada);
    
    sleep(4);
    system(""cls""); 
        
    while(operacao != 3){
    
    printf(""\nComprar ingresso"");
    printf(""\n[1] - Valor inteiro"");
    printf(""\n[2] - Meia entrada"");
    printf(""\n[3] - Finalizar vendas\n"");
    scanf(""%d"", &operacao);
    switch(operacao){
        case 1:
            
            printf(""\nValor da compra: %g"", valorInteira);
                printf(""\n Confirmar:"");
                printf(""\n[1] - SIM"");
                printf(""\n[2] - NAO\n"");
                scanf(""%d"", &confirmacao);
                
                if(confirmacao == 1){
                    printf(""\nValor do ingresso: %g"", valorInteira);
                    printf(""\nValor pago\n"");
                    scanf(""%g"", &valorPago);
                    if(valorPago >= valorInteira){
                    
                    troco = valorPago - valorInteira;
                    printf(""\nTroco: %g"", troco);
                    
                    printf(""\nIngresso comprado com sucesso!"");
                    capacidade = capacidade - 1;
                    vendidoInteira++;
                    
                    printf(""\nValor do ingresso: %g \nvalor pago: %g \ntroco: %g"",valorInteira,valorPago,troco);
                    break;
                }else{
                    printf(""\nQuantia insuficiente!"");
                    break;
                }
                }else{
                    printf(""\nOperacao finalizada!"");
                    break;
                }
            
            
        case 2:
            if(capacidadeMeiaEntrada > 0 ){
                
                printf(""\nValor do ingresso: %g"", meiaEntrada);
                printf(""\nConfirmar:"");
                printf(""\n[1] - SIM"");
                printf(""\n[2] - NAO\n"");
                scanf(""%d"", &confirmacao);
                if(confirmacao == 1){
                    printf(""\nValor do ingresso: %g"",meiaEntrada);
                    printf(""\nValor pago:\n"");
                    scanf(""%g"", &valorPago);
                    if(valorPago>=meiaEntrada){
                    
                    troco = valorPago - meiaEntrada;
                    printf(""\nTroco: %g"", troco);
                    
                    printf(""\nIngresso comprado com sucesso!"");
                    capacidadeMeiaEntrada = capacidadeMeiaEntrada - 1;
                    capacidade = capacidade - 1;
                    vendidoMeia++;
                    printf(""\nValor do ingresso: %g \nValor pago: %g \nTroco: %g"",meiaEntrada,valorPago,troco);
                    break;
                    }else{
                        printf(""\nQuantia insuficiente!"");
                        break;
                    }
                }else{
                    printf(""\nOperacao finalizada!"");
                    break;
                }
                
            }else{
                printf(""\nIngressos de meia entrada esgotados!"");
                break;
            }
        
        case 3: 
            printf(""\nTotal de ingressos vendidos tipo inteira: %d"", vendidoInteira);
            printf(""\nTotal de ingressos vendidos tipo meia: %d"", vendidoMeia);
            printf(""\nIngressos disponiveis inteira: %d"", capacidade);
            printf(""\nIngressos disponiveis meia: %d"", capacidadeMeiaEntrada);
            
            break;
                
        default: 
            printf(""\nIngressos esgotados"");    
            sleep(5);
            break;
    }
}
    
    
    
}
",51,1562,1296
"int main(int argc, char *argv[]) 
{
    int modoJogo, jogada1, jogada2, partidas, empates, vencimento1, vencimento2, jogarNovamente, aleatorio, totalPartidas; 
    float vitorias1, vitorias2;
    
    empates=0;
    partidas=0;
    vencimento1=0;
    vencimento2=0;
    jogarNovamente=1; 
    
    printf (""*************************\n | Vamos Jogar Jokempo!| \n*************************\n \nPara iniciar, escolha o modo de jogo: \n 1- Para Jogar com outra pessoa \n 2- Para jogar com o computador \n "");
    scanf (""%d"" , &modoJogo);
    
    while (modoJogo<1 || modoJogo>2)
                {
                    printf(""Modo de Jogo Invalido! Tente novamnete:"");
                    scanf(""%d"" , &modoJogo);
                }
                
    switch (modoJogo)
    {
        
        case 1 :   
            
            printf (""\n Modo de Jogo 1 \n"");
            
            while ( jogarNovamente == 1)
            {
                
                 printf (""\n \n  Escolhas: \n 1- Para Pedra \n 2- Para Papel \n 3- Para Tesoura \n "");
              
                 printf (""\n \n Vez do Jogador 1:"");
                 scanf (""%d"" , &jogada1);
                 
                    while (jogada1>3 || jogada1<1)
                {
                    printf(""Opcao Invalida! Tente novamnete:"");
                    scanf(""%d"" , &jogada1);
                }
                
                 printf (""\n \n Vez do Jogador 2:"");
                 scanf (""%d"" , &jogada2);
                 
                 while (jogada2>3 || jogada2<1)
                {
                    printf(""Opcao Invalida! Tente novamnete:"");
                    scanf(""%d"" , &jogada2);
                }
                 
                    if ( jogada1 == 1 && jogada2 == 2 )
                    {
                       printf(""\n RESULTADO: Papel ganha da pedra, Ganhador: Jogador 2"");
                       partidas++;
                       vencimento2++;
                       
                    }else{
                        
                        if ( jogada1 == 2 && jogada2 == 1 )
                        {
                       printf(""\n RESULTADO: Papel ganha da pedra, Ganhador: Jogador 1"");
                       partidas++; 
                       vencimento1++;           
                       
                        }else{
                            
                            if ( jogada1 == 1 && jogada2 == 3 )
                            {
                             printf(""\n RESULTADO: Pedra ganha da tesoura, Ganhador: Jogador 1"");
                             partidas++;
                             vencimento1++;
                             
                            }else{
                                
                                if ( jogada1 == 3 && jogada2 == 1 )
                                
                                {
                                 printf(""\n RESULTADO: Pedra ganha da tesoura, Ganhador: Jogador 2"");
                                 partidas++;
                                 vencimento2++;
                                 
                                }else{
                                    
                                    if ( jogada1 == 3 && jogada2 == 2)
                                    {
                                     printf ("" \n RESULTADO: Tesoura ganha do papel, Gahador: Jogador 1"");
                                     partidas++;
                                     vencimento1++;
                                        
                                    }else{
                                        
                                        if ( jogada1 == 2 && jogada2 == 3 )
                                        {
                                         printf(""\n RESULTADO: Tesoura ganha do papel, Ganhador: Jogador 2"");
                                         partidas++;
                                         vencimento2++;
                                            
                                        }else{
                                            
                                            printf (""\n Houve Empate!"");
                                            empates++;
                                            
                                            
                                            }
                                        
                                        }
                                     }
                                }
                            }
                        }
                        
                printf(""\n \n Para jogar novamente digite = 1 ou sair digite = 2 : "");
                scanf(""%d"" , &jogarNovamente );
                
                while (jogarNovamente<1 || jogarNovamente>2)
                {
                    printf(""Opcao Invalida! Tente novamnete:"");
                    scanf(""%d"" , &jogarNovamente);
                }
                
            } 
            
        totalPartidas=partidas+empates;
        vitorias1=(100*vencimento1)/partidas;
        vitorias2=(100*vencimento2)/partidas;
    
        printf("" \n ==============\n |ESTATISTICAS| \n ==============\n Quantidade de Partidas: %d | Quantidade de Empates: %d"" , totalPartidas , empates) ;
        printf(""\n Percentual de Vitotias Jogador 1: %f  \n Percentual de Votorias Jogador 2: %f "" , vitorias1 , vitorias2);
    
                      
                        
                 break;
        
     
            
        case 2 : 
          
          printf (""\n Modo de Jogo 2 \n"");
            
            while ( jogarNovamente == 1)
            {
                
                 printf (""\n \n  Escolhas: \n 1- Para Pedra \n 2- Para Papel \n 3- Para Tesoura \n "");
              
                 printf (""\n \n Vez do Jogador :"");
                 scanf (""%d"" , &jogada1);
                 
                    while (jogada1>3 || jogada1<1)
                {
                    printf(""Opcao Invalida! Tente novamnete:"");
                    scanf(""%d"" , &jogada1);
                }
                
                 srand(time(NULL));
                 printf (""\n \n Vez do Computador:"" , rand() % 3);
                 jogada2 = (rand() % 3) +1;
                 printf(""%d"" , jogada2);
                 
                    if ( jogada1 == 1 && jogada2 == 2 )
                    {
                       printf(""\n RESULTADO: Papel ganha da pedra, Ganhador: Computador"");
                       partidas++;
                       vencimento2++;
                       
                    }else{
                        
                        if ( jogada1 == 2 && jogada2 == 1 )
                        {
                       printf(""\n RESULTADO: Papel ganha da pedra, Ganhador: Jogador "");
                       partidas++; 
                       vencimento1++;           
                       
                        }else{
                            
                            if ( jogada1 == 1 && jogada2 == 3 )
                            {
                             printf(""\n RESULTADO: Pedra ganha da tesoura, Ganhador: Jogador "");
                             partidas++;
                             vencimento1++;
                             
                            }else{
                                
                                if ( jogada1 == 3 && jogada2 == 1 )
                                
                                {
                                 printf(""\n RESULTADO: Pedra ganha da tesoura, Ganhador: Computador"");
                                 partidas++;
                                 vencimento2++;
                                 
                                }else{
                                    
                                    if ( jogada1 == 3 && jogada2 == 2)
                                    {
                                     printf ("" \n RESULTADO: Tesoura ganha do papel, Gahador: Jogador "");
                                     partidas++;
                                     vencimento1++;
                                        
                                    }else{
                                        
                                        if ( jogada1 == 2 && jogada2 == 3 )
                                        {
                                         printf(""\n RESULTADO: Tesoura ganha do papel, Ganhador: Computador"");
                                         partidas++;
                                         vencimento2++;
                                            
                                        }else{
                                            
                                            printf (""\n Houve Empate!"");
                                            empates++;
                                            
                                            
                                            }
                                        
                                        }
                                     }
                                }
                            }
                        }
                        
                printf(""\n \n Para jogar novamente digite = 1 ou sair digite = 2 : "");
                scanf(""%d"" , &jogarNovamente );
                
                while (jogarNovamente<1 || jogarNovamente>2)
                {
                    printf(""Opcao Invalida! Tente novamnete:"");
                    scanf(""%d"" , &jogarNovamente);
                }
                
            } 
            
        totalPartidas=partidas+empates; 
        vitorias1=(100*vencimento1)/partidas;
        vitorias2=(100*vencimento2)/partidas;
    
        printf("" \n ==============\n |ESTATISTICAS| \n ==============\n Quantidade de Partidas: %d | Quantidade de Empates: %d"" , totalPartidas , empates) ;
        printf(""\n Percentual de Vitotias do Jogador: %f  \n Percentual de Votorias do Computador: %f "" , vitorias1 , vitorias2);
                
        break;
        
    }
    

    return 0;
}
",51,1563,2491
"#define CAPTCHA 6


char * gerarCaptcha( char captchaSistema[CAPTCHA]){
    int cont, guardaValor, aleatorio[CAPTCHA], geradorCaptcha[CAPTCHA];
    srand(time(NULL));
    for (cont = 0;cont < CAPTCHA; cont++){
        guardaValor = rand();
        aleatorio[cont] = (guardaValor % 122);
        if((aleatorio[cont] >= 48 && aleatorio[cont] <= 57) || (aleatorio[cont] >= 65 && aleatorio[cont] <= 90) || (aleatorio[cont] >= 97 && aleatorio[cont] <= 122) ){
            captchaSistema[cont] = aleatorio[cont];
        }
        else{
            cont--;
        }
    }
    return captchaSistema;
}
int confirmacaoCaptcha(char *atribuicao, char captchaDigitado[CAPTCHA]){
    int comparaDigitado;
    comparaDigitado = strcmp(atribuicao, captchaDigitado);
    return comparaDigitado;
}

int main(int argc, char *argv[]) {
    char captchaDigitado[CAPTCHA], captchaSistema[CAPTCHA], *atribuicao;
    int comparaDigitado;
    do{
        atribuicao = gerarCaptcha(captchaSistema);
        printf(""%s"", atribuicao);
        printf(""\nDigite o captcha para provar q nao e um robo\n"");
        gets(captchaDigitado);
        comparaDigitado = confirmacaoCaptcha(atribuicao, captchaDigitado);
        if(comparaDigitado == 0){
            printf(""\nSao iguais!! Voce nao e um robo\n"");
        }
        else if(comparaDigitado < 0 || comparaDigitado > 0){
            printf(""\nCaptcha errado, um novo sera redefinido\n"");
        }

    }while(comparaDigitado < 0 || comparaDigitado > 0);

    return 0;
}
",51,1564,565
"int main(int argc, char *argv[]) {
        int pontosJogador1=0, pontosComputador=0, pontosJogador2=0;
        int jogador1, computador, jogador2;
        int numeroPartidas=0, numeroPartidasJogador2=0, numeroPartidasComputador=0, empate=0;
        int continuar=1, mododejogo;
        float percJogador1=0, percJogador2=0, percComputador=0;
        
        while(continuar == 1) {
            printf (""-------\n"");
            printf (""JOKENPO\n"");
            printf (""-------\n\n"");
            printf (""Quem sera o seu oponente:\n""
                    ""1. Computador\n""
                    ""2. Jogador\n"");
            scanf(""%d"", &mododejogo);
            printf (""\n"");
            numeroPartidas++;
            switch (mododejogo)
            {
            case 1: printf (""Jogador X Computador\n\n"");
                    printf (""1. Pedra\n"");
                    printf (""2. Papel\n"");
                    printf (""3. Tesoura\n"");
                    scanf (""%d"", &jogador1);
                    
                   numeroPartidasComputador++;
                   
                    srand(time(NULL));
                    computador = rand() % 3; 
                    
                    computador++;   
                        
                    switch (computador)
                    {
                        case 1: printf (""Computador --> Pedra\n"");break;
                        case 2: printf (""Computador --> Papel\n"");break;                        
                        case 3: printf (""Computador --> Tesoura\n"");break;                  
                    }
                    
                if ((jogador1 == 1 && computador==3) || (jogador1 == 2 && computador == 1) || (jogador1 == 3 && computador == 2)) 
                {
                    printf(""Voce venceu!\n\n\n"");
                    pontosJogador1++;
                } else if (jogador1 == computador) 
                {
                    printf (""Empate!\n\n\n"");
                    empate++;
                }
                else
                {
                    printf (""Computador venceu!\n\n\n"");
                    pontosComputador++;
                }
                printf(""Continuar: \n\n1.Sim\n2.Nao\n"");
                scanf(""%d"", &continuar);
                system(""cls"");
            break;
            
            case 2: printf (""Jogador1 X Jogador2\n\n"");
                    printf (""1. Pedra\n"");
                    printf (""2. Papel\n"");
                    printf (""3. Tesoura\n"");
                    scanf (""%d"", &jogador1);
                    scanf (""%d"", &jogador2);
                    
                    numeroPartidasJogador2++;
                    switch (jogador1)
                    {
                        case 1: printf (""Jogador1 --> Pedra\n"");break;
                        case 2: printf (""Jogador1 --> Papel\n"");break;
                        case 3: printf (""Jogador1 --> Tesoura\n"");break;
                    }
                    switch (jogador2)
                    {
                        case 1: printf (""Jogador2 --> Pedra\n"");break;
                        case 2: printf (""Jogador2 --> Papel\n"");break;
                        case 3: printf (""Jogador2 --> Tesoura\n"");break;
                    }
                    
                    if ((jogador1 == 1 && jogador2 == 3) || (jogador1 == 2 && jogador2 == 1) || (jogador1 == 3 && jogador2 == 2)) 
                        {
                            printf(""Jogador1 venceu!\n\n"");
                            pontosJogador1++;
                        } else if (jogador1 == jogador2) 
                        {
                            printf (""Empate!\n\n"");
                            empate ++;
                        }else
                        {
                            printf (""Jogador2 venceu!\n\n"");
                            pontosJogador2++;
                        }
                printf(""Continuar: \n\n1.Sim\n2.Nao\n"");
                scanf(""%d"", &continuar);
                system(""cls"");
            break;
            }
        }
        percJogador1 = (pontosJogador1 * 100) / (numeroPartidas);
        percJogador1 = percJogador1;
        if(numeroPartidasJogador2 != 0)
            percJogador2 = (pontosJogador2 * 100) / (numeroPartidasJogador2);
        percComputador = (pontosComputador * 100) / (numeroPartidasComputador);
        printf(""Percentual Jogador1: %f\n"", percJogador1);
        printf(""Percentual Computador: %f\n"", percComputador);
        printf(""Percentual Jogador2: %f\n"", percJogador2);
        printf(""Empate: %d\n"", empate);
        printf(""Numero Partidas: %d\n"", numeroPartidas);
        printf(""Pontos Jogador1: %d\n"", pontosJogador1);
        printf(""Pontos Jogador2: %d\n"", pontosJogador2);
        printf(""Pontos Computador: %d\n"", pontosComputador);
        
        
        return 0;
    }
",51,1565,1443
"int main(int argc, char *argv[]) 
{
    float valorIngresso, meiaEntrada, valorPago, troco;
    int opcao, capacidadeMaxima, tipoIngresso, x, y, quantidadeVendido, quantidadeRestante;
    char evento;    
    
    capacidadeMaxima = 0;
    quantidadeRestante = 1;
    x = 0;
    y = 0;
    
    printf(""\t____________________________________________________________\n"");
    printf(""\n"");
    printf(""\t| Ingresso++ - Meu sistema de gestao de venda de ingressos |\n"");
    printf(""\n"");
    printf(""\t____________________________________________________________\n"");
    printf(""\n"");
    
    while (y == 0)
    {
        while (x <= 50)
        {
            printf(""_"");
            x++;                
        }
            
        x = 0;
        
        
        printf(""\n"");           
        printf(""\n1) Cadastro de Evento.\n"");
        printf(""2) Compre seu ingresso.\n"");
        printf(""3) Sair.\n"");
        printf(""\n"");       
            
        printf(""Digite a opcao desejada: "");
        scanf(""%d"", &opcao);
        printf(""\n"");
    
        switch (opcao)
        {
            case 1:
                printf(""\t-Digite o nome do evento: "");
                scanf(""%s"", &evento);
                printf(""\n\t-Informe a capacidade maxima de pessoas: "");
                scanf(""%d"", &capacidadeMaxima);
                printf(""\n\t-Digite o valor de cada ingresso: "");
                scanf(""%g"", &valorIngresso);
                
                
                meiaEntrada = valorIngresso * 0.4;
                quantidadeVendido = 0;  
                quantidadeRestante = capacidadeMaxima;      
            break;
            case 2:
            
                if (capacidadeMaxima == 0)
                {
                    printf(""Nao ha evento cadastrado\n"");   
                }
                else
                {       
                    
                        
                    if(quantidadeRestante <= 0)
                    {
                    
                    printf(""Ingresso Esgotados!\n"");
                        
                    }
                    else
                    {                       
                        printf(""\t_______________________________________\n"");
                        printf(""\n\t| ADQUIRA SEU INGRESSO PARA O EVENTO. |\n"");
                        printf(""\t_______________________________________\n"");
                        
                        printf(""\n\t\tO valor do evento eh: R$%.2f \n\t\t(Meia entrada: R$%.2f)\n"", valorIngresso, meiaEntrada);
                        
                        printf(""\nEscolha o tipo de ingresso:\n"");
                        printf(""\n\t-Digite 1 para inteira.\n"");
                        printf(""\t-Digite 2 para meia.\n\n\t\t"");   
                        scanf(""%d"", &tipoIngresso); 
                        
                            
                        switch (tipoIngresso) 
                        {
                            case 1: 
                                printf(""\n\nInsira o dinheiro: "");
                                scanf(""%g"", &valorPago);
                                    
                                if (valorPago < valorIngresso)
                                {
                                        printf(""Valor pago insuficiente!\n"");                       
                                }
                                else
                                {
                                    if (valorPago > valorIngresso)  
                                    {
                                        troco = valorPago - valorIngresso;                                  
                                        printf(""\nSeu troco eh: R$%g\n"", troco);                            
                                    }
                                        printf(""\nCompra concluida!\n"");
                                        
                                        quantidadeVendido++;                                    
                                }
                            break; 
                            case 2: 
                                printf(""Insira o dinheiro: "");
                                scanf(""%g"", &valorPago);
                                
                                if (valorPago < meiaEntrada)
                                {
                                    printf(""Valor pago insuficiente!\n"");                       
                                }
                                else
                                {
                                    if (valorPago > meiaEntrada)
                                    {
                                        troco = valorPago - meiaEntrada;                                    
                                        printf(""\nSeu troco eh: R$%g\n"", troco);                            
                                    }
                                    printf(""\nCompra concluida!\n"");
                                            
                                    quantidadeVendido++;
                                }               
                            break;
                            default:
                                printf(""Opcao invalida.\n"");
                            break;
                                                                                                
                        } 
                    
                    quantidadeRestante = capacidadeMaxima - quantidadeVendido;
                printf(""\n\tQuantidade de entrada inteira restantes: %d\n"", quantidadeRestante);                
                printf(""\tQuantidade de meia entrada restantes: %d\n"", quantidadeRestante);
                    
                    }
                }
            break; 
                        
            case 3:
                y = 1;
            break;  
            
            default:
                printf(""Opcao invalida.\n"");
            break;  
                
                
        } 
    } 
    
    return 0;
}
",51,1566,1420
"int main(int argc, char *argv[]) 
{
    int capacidadeMaxima, ingressoComprado, opcao, escolha, contInteira, tipo, contMeia, ingressosRestantes;
    float entradaInteira, meiaEntrada, valorPagar, pagamento, totalPagar;
    char nomeEvento[30]; 

    printf(""Digite o nome do Evento: "");
    scanf(""%s"", &nomeEvento);
    printf(""\nDigite a capacidade maxima: "");
    scanf(""%d"", &capacidadeMaxima);
    printf(""\nDigite o valor da entrada inteira: "");
    scanf(""%g"", &entradaInteira);   
        

    
    contInteira = 0;
    contMeia = 0;
    
    system(""cls"");
    
    
    
    while(opcao != 2)
    {
        system(""cls"");
        
        printf(""Menu\n"");
        printf(""\n(1) Comprar Ingressos \n"");
        printf(""(2) Sair \n\n"");
        printf(""Digite a opcao desejada: "");
        scanf(""%d"", &opcao);
        
        if((contInteira + contMeia) == capacidadeMaxima)
        {
            opcao = 0;
            printf(""Ingressos Esgotados !\n"");
            system(""pause"");
        }
        
        
        system(""cls"");
        
        
        
        if(opcao == 1)
        {
            ingressoComprado= 0;
            printf(""Nome do Evento: %s\n"", nomeEvento);
            printf(""Capacidade Maxima: %d\n"", capacidadeMaxima);
            printf(""O Valor da Entrada Inteira: %g\n\n"", entradaInteira);
            
            printf(""\nIngressos:\n"");
            printf(""\n(1) Entrada Inteira\n"");
            printf(""(2) Meia Entrada\n\n"");
            printf(""Escolha a opcao desejada: "");
            scanf(""%d"", &escolha);
            
            
            if(escolha == 1)
            {
                valorPagar = entradaInteira;
                printf(""\nValor a pagar: %g"", valorPagar);
                contInteira++;
            }
            else
            {
                valorPagar = entradaInteira / 2;
                printf(""\nValor a pagar: %g"", valorPagar);
                contMeia++;
            }
            
            
            while(ingressoComprado == 0)
            {
                printf(""\n\nForma de Pagamento:\n"");
                printf(""\n(1) Somente em Dinheiro\n"");
                printf(""\nDigite 1 para iniciar o pagamento:"");
                scanf(""%d"", &tipo);
                
                if(tipo == 1)
                {
                    printf(""\nDigite o valor em dinheiro:"");
                    scanf(""%g"", &pagamento);
                    totalPagar = pagamento - valorPagar;
                    
                    if(totalPagar < 0)
                    {
                        printf(""\nValor menor que valor total do ingresso\n\n"");
                    }
                    else 
                    {
                        printf(""\ntroco eh: %g"", totalPagar);
                        ingressoComprado = 1;
                    }
                    
                }
                else
                {
                    printf(""Pagamento somente em dinherio !\n\n"");
                }
            }
            
        
            
            printf(""\n\nIngressos Comprado\n\n"");
            system(""pause"");
                                
        }
        else if(opcao == 2)
        {
            printf(""Total de ingressos: %d\n"", capacidadeMaxima);
            ingressosRestantes = capacidadeMaxima - ingressoComprado;
            printf(""\nSobraram: %d\n\n"", ingressosRestantes);
            system(""pause"");
        }
    }
    
    
    
    
    return 0;
}
",51,1567,1058
"int main(void) {
    
    srand (time(NULL));
    
    int jogarNovamente;
    int jogarNovamente2;
    int jogarMais = 1;
    int escolhaJogo;
    int jogador1;
    int jogador2;
    int jogadaComputador;
    int linha;
    
    
    
    int pontosJogador1 = 0;
    int pontosJogador2 = 0;
    int pontosComputador = 0;
    int empate = 0;
    int totalJogadas;
    float porcentagemJogador1;
    float porcentagemJogador2;
    float porcentagemComputador;
    
    printf(""\n                              JOKENPO ULTIMATE!\n\n"");
    printf(""\n                    Digite >1< para jogar contra o computador.\n"");
    printf(""                    Digite >2< para jogar contra outro humano.\n\n"");
    printf(""                                     >"");
    scanf("" %d"", &escolhaJogo);
    
    while(jogarMais > 0){
    
        jogadaComputador = rand()%3+1;
    
        if(escolhaJogo == 1){ 
    
        printf(""\n                          Para jogar PEDRA digite    >1<\n"");
        printf(""                          Para jogar PAPEL digite    >2<\n"");
        printf(""                          Para jogar TESOURA digite  >3<\n\n"");
        
        printf(""\n                          HUMANO X COMPUTADOR, BOA SORTE!!"");
        printf(""\n                                Faca a sua jogada: \n\n"");
        printf(""                                     >"");
        scanf("" %d"", &jogador1);
        
            if(jogador1 >=1 && jogador1 <=3){ 
            
                printf(""\n                                  JO"");
                sleep(1);
                printf(""KEN"");
                sleep(1);
                printf(""PO!!! \n\n"");
                sleep(1);
                
                for( linha = 0; linha < 35; linha++){ 
                    printf( ""\n"" );
                }
                
                switch(jogador1){ 
                    case 1:
                        printf(""                                 PEDRA x "");
                        break;
                    case 2:
                        printf(""                                 PAPEL x "");
                        break;
                    case 3:
                        printf(""                                TESOURA x "");
                        break;
                }
            
                switch(jogadaComputador){ 
                    case 1:
                        printf(""PEDRA \n\n"");
                        break;
                    case 2:
                        printf(""PAPEL \n\n"");
                        break;
                    case 3:
                        printf(""TESOURA \n\n"");
                        break;
                }
                
                if ((jogador1 == 1 && jogadaComputador == 3) || (jogador1 == 2 && jogadaComputador == 1) || (jogador1 == 3 && jogadaComputador == 2)){ 
                
                    printf(""                                 VOCE VENCEU!!! \n\n"");
                    
                    pontosJogador1 = pontosJogador1 + 1;
                
                }
                
                if (jogador1 == jogadaComputador){ 
                    
                    printf(""                                    EMPATE! \n\n"");
                    
                    empate++;
                    
                }
                
                if ((jogadaComputador == 1 && jogador1 == 3) || (jogadaComputador == 2 && jogador1 == 1) || (jogadaComputador == 3 && jogador1 == 2)){ 
                
                    printf(""                                 VOCE PERDEU :( \n\n"");
                
                    pontosComputador = pontosComputador + 1;
                
            }
        } else { 
            
            printf(""\n                        Voce nao digitou um numero valido. \n"");
            
        }
        
        }
        
        if(escolhaJogo == 2){  
            
            printf(""\n                          Para jogar PEDRA digite    >1<\n"");
            printf(""                          Para jogar PAPEL digite    >2<\n"");
            printf(""                          Para jogar TESOURA digite  >3<\n\n"");
        
            printf(""\n                          HUMANO X HUMANO, BOA SORTE!!"");
            printf(""\n\n                          JOGADOR 1 Faca a sua jogada: \n\n"");
            printf(""                                     >"");
            scanf("" %d"", &jogador1);
            
            if(jogador1 >= 1 && jogador1 <= 3){
            
                for( linha = 0; linha < 35; linha++){ 
                    printf( ""\n"" );
                }
                
                printf(""\n                          Para jogar PEDRA digite    >1<\n"");
                printf(""                          Para jogar PAPEL digite    >2<\n"");
                printf(""                          Para jogar TESOURA digite  >3<\n\n"");
                
                printf(""\n                          HUMANO X HUMANO, BOA SORTE!!"");
                printf(""\n\n                          JOGADOR 2 Faca a sua jogada: \n\n"");
                printf(""                                     >"");
                scanf("" %d"", &jogador2);
                
                if(jogador2 >= 1 && jogador2 <= 3) {
                    
                    printf(""\n                                  JO"");
                    sleep(1);
                    printf(""KEN"");
                    sleep(1);
                    printf(""PO!!! \n\n"");
                    sleep(1);
                
                    for( linha = 0; linha < 35; linha++){ 
                        printf( ""\n"" );
                    }
                    
                    switch(jogador1){ 
                    case 1:
                        printf(""                                 PEDRA x "");
                        break;
                    case 2:
                        printf(""                                 PAPEL x "");
                        break;
                    case 3:
                        printf(""                                TESOURA x "");
                        break;
                    }
                    
                    switch(jogador2){ 
                    case 1:
                        printf(""PEDRA \n\n"");
                        break;
                    case 2:
                        printf(""PAPEL \n\n"");
                        break;
                    case 3:
                        printf(""TESOURA \n\n"");
                        break;
                    }
                    
                    if ((jogador1 == 1 && jogador2 == 3) || (jogador1 == 2 && jogador2 == 1) || (jogador1 == 3 && jogador2 == 2)){ 
                
                        printf(""                               JOGADOR 1 VENCEU! \n\n"");
                        
                        pontosJogador1 = pontosJogador1 + 1;
                
                    }
                
                    if (jogador1 == jogador2){ 
                    
                        printf(""                                    EMPATE! \n\n"");
                        
                        empate++;
                    
                    }
                
                    if ((jogador2 == 1 && jogador1 == 3) || (jogador2 == 2 && jogador1 == 1) || (jogador2 == 3 && jogador1 == 2)){ 
                
                        printf(""                               JOGADOR 2 VENCEU! \n\n"");
                        
                        pontosJogador2 = pontosJogador2 + 1;
                
                    }
            
                } else { 
            
                    printf(""\n                        Voce nao digitou um numero valido. \n"");
            
                }
        
            } else { 
            
                printf(""\n                        Voce nao digitou um numero valido. \n"");
            
            }
    
        }
        
        if(escolhaJogo > 2){  
            
            printf(""\n              Voce nao digitou um numero valido. Reinicie o jogo. \n"");
            exit(0);
            
        }

        printf(""\n\n\n\n\n\n\n\n                          Para jogar novamente digite >1< \n"");
        printf(""                          Para estatisticas digite    >2< \n"");
        printf(""                          Para sair digite            >3< \n\n"");
        printf(""                                     >"");
        scanf("" %d"", &jogarNovamente);
        
        if(jogarNovamente == 1){ 
            
            for( linha = 0; linha < 35; linha++){ 
                    printf( ""\n"" );
                }
            
        }

        if(jogarNovamente == 2){ 
            
            for( linha = 0; linha < 35; linha++){ 
                    printf( ""\n"" );
            }
            
            totalJogadas = pontosJogador1 + pontosJogador2 + pontosComputador + empate;
            
            printf(""\n                                 ESTATISTICAS!\n\n"");
            printf(""                          Vitorias do Jogador 1:     >%d< \n"", pontosJogador1);
            
            if(pontosJogador2 > 0){
                
                printf(""                      Vitorias do Jogador 2:     >%d< \n\n"", pontosJogador2);
                printf(""                      Empates:                   >%d< \n\n"", empate);
                
                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;
                porcentagemJogador2 = ((float)pontosJogador2 / (float)totalJogadas) * 100;
                
                printf(""                  Porcentagem de vitorias do Jogador 1:     >%.1f< \n"", porcentagemJogador1);
                printf(""                  Porcentagem de vitorias do Jogador 2:     >%.1f< \n"", porcentagemJogador2);
            
            }
            
            if(pontosComputador > 0){
                
                printf(""                          Vitorias do Computador:    >%d< \n\n"", pontosComputador);
                printf(""                          Empates:                   >%d< \n\n"", empate);
                
                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;
                porcentagemComputador = ((float)pontosComputador / (float)totalJogadas) * 100;
                
                printf(""                  Porcentagem de vitorias do Jogador 1:     >%.1f< \n"", porcentagemJogador1);
                printf(""                  Porcentagem de vitorias do Computador:    >%.1f< \n"", porcentagemComputador);
                
            }
            
            if(pontosJogador2 == 0 && pontosComputador == 0){
                
                if(escolhaJogo == 1){
                    
                    printf(""                          Vitorias do Computador:    >%d< \n\n"", pontosComputador);
                    
                }
                
                if(escolhaJogo == 2){
                    
                    printf(""                          Vitorias do Jogador 2:     >%d< \n\n"", pontosJogador2);
                    
                }
                
                if(empate > 0){
                    
                        printf(""                          Empates:                   >%d< \n\n"", empate);
                        
                }
                
                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;
                printf(""                  Porcentagem de vitorias do Jogador 1:     >%.1f< \n\n"", porcentagemJogador1);
                
            }
            
            for( linha = 0; linha < 13; linha++){ 
                    printf( ""\n"" );
            }
            
            printf(""                          Para jogar novamente digite >1< \n"");
            printf(""                          Para sair digite            >2< \n\n"");
            printf(""                                     >"");
            scanf("" %d"", &jogarNovamente2);
            
            if(jogarNovamente2 == 1){ 
                
                for( linha = 0; linha < 35; linha++){ 
                
                    printf( ""\n"" );
                    
                }
                
            }
            
            if(jogarNovamente2 == 2){ 
                
                exit(0);
                
            }
            
            if(jogarNovamente2 >= 3){
                
                printf(""\n              Voce nao digitou um numero valido. Reinicie o jogo. \n"");
                exit(0);
                
            }
            
        }
        
        if(jogarNovamente == 3){
        
            exit(0);
            
        }
        
        if(jogarNovamente >= 4){
            
            printf(""\n              Voce nao digitou um numero valido. Reinicie o jogo. \n"");
            exit(0);
            
        }
         
    }
    
    return 0;
}
",51,1568,3438
"int main(int argc, char *argv[]) {
    char opcaoMenu;
    char opcaoJogarNovamnt;
    char opcaoJogador1;
    char opcaoJogador2;
    int opcaoJogador3;
    int opcaoComputador;
    char nomeJogador1[15];
    char nomeJogador2[15];
    char nomeJogador3[15];
    char nomeComputador[15];
    int empates = 0;
    float vitoriasJogador1 = 0;
    float vitoriasJogador2 = 0;
    float vitoriasJogador3 = 0;
    float vitoriasComputador = 0;
    float percentVitJog1;
    float percentVitJog2;
    float percentVitJog3;
    float percentVitComp;
    int totalPartidas = 0;
    
    system (""COLOR 0F"");
    system (""cls"");
    printf (""Bem vindo ao jogo JOKENPO!"");
    printf (""\n\nDigite 1 para o modo Humano X Humano."");
    printf (""\nDigite 2 para o modo Humano X Computador."");
    printf (""\nDigite 3 para sair do jogo."");
    printf (""\n\nEscolha o modo de jogar: "");
    opcaoMenu = getch();
    switch (opcaoMenu)
        {
        case '1':
            system(""cls"");
            system (""COLOR 0E"");
            printf (""Jogo Jokenpo: Modo Humano X Humano."");
            printf (""\n\nJogador 1 - Digite seu nome: "");
            scanf (""%s"", &nomeJogador1);
            printf (""\nJogador 2 - Digite seu nome: "");
            scanf (""%s"", &nomeJogador2);
            do
            {
                system(""cls"");
                printf (""Jogo Jokenpo - Modo Humano X Humano."");
                printf (""\n\nDigite 1 para PEDRA."");
                printf (""\nDigite 2 para PAPEL."");
                printf (""\nDigite 3 para TESOURA."");
                printf (""\n\n%s - Escolha o que vai jogar: "", nomeJogador1);
                opcaoJogador1 = getch();
                printf (""\n\n%s - Escolha o que vai jogar: "", nomeJogador2);
                opcaoJogador2 = getch();
                if (opcaoJogador1 == opcaoJogador2)
                {
                    printf (""\n\n%s e %s, voces EMPATARAM!"", nomeJogador1,nomeJogador2);
                    empates++;
                }else
                {
                    if (opcaoJogador1 == '1' && opcaoJogador2 == '3')
                    {
                        printf (""\n\nVitoria %s! Pedra quebra a tesoura."", nomeJogador1);
                        vitoriasJogador1++;                         
                    }else
                    {
                        if (opcaoJogador1 == '2' && opcaoJogador2 == '1')
                        {
                            printf (""\n\nVitoria %s! Papel embrulha a pedra."", nomeJogador1);
                            vitoriasJogador1++; 
                        }else
                        {
                            if (opcaoJogador1 == '3' && opcaoJogador2 == '2')
                            {
                                printf (""\n\nVitoria %s! Tesoura corta o papel."", nomeJogador1);
                                vitoriasJogador1++;
                            }else
                            {
                                if (opcaoJogador1 == '1' && opcaoJogador2 == '2')
                                {
                                    printf (""\n\nVitoria %s! Papel embrulha a pedra."", nomeJogador2);
                                    vitoriasJogador2++;
                                }else
                                {
                                    if (opcaoJogador1 == '2' && opcaoJogador2 == '3')
                                    {
                                        printf (""\n\nVitoria %s! Tesoura corta o papel."", nomeJogador2);
                                        vitoriasJogador2++;
                                    }else
                                    {
                                        printf (""\n\nVitoria %s! Pedra quebra a tesoura."", nomeJogador2);
                                        vitoriasJogador2++;
                                    }
                                }
                            }
                        }
                    }
                }   
                sleep(2);
                totalPartidas++;
                printf (""\n\n\nDeseja jogar novamente? S/N"");
                opcaoJogarNovamnt = getch();
            }
            while (opcaoJogarNovamnt == 's');
            break;
        case '2':
            system (""COLOR 0A"");
            system(""cls"");
            printf (""Jogo Jokenpo - Modo Humano X Computador."");
            printf (""\n\nJogador - Digite seu nome: "");
            scanf (""%s"", &nomeJogador3);
            printf (""\n%s - Digite um nome para o computador: "",nomeJogador3);
            scanf (""%s"", &nomeComputador);
            do
            {
                system(""cls"");
                printf (""Jogo Jokenpo - Modo Humano X Computador."");
                printf (""\n\nDigite 1 para PEDRA."");
                printf (""\nDigite 2 para PAPEL."");
                printf (""\nDigite 3 para TESOURA."");
                printf (""\n\n%s - Escolha o que vai jogar: "", nomeJogador3);
                scanf (""%d"", &opcaoJogador3);
                printf (""\n%s: Escolha o que vai jogar:"", nomeComputador);
                sleep (2);
                srand((unsigned)time(NULL));
                opcaoComputador = (rand() % 3 + 1);
                if (opcaoJogador3 == opcaoComputador)
                {
                    printf (""\n\n%s e %s, voces EMPATARAM!"", nomeJogador3,nomeComputador);
                    empates++;
                }else
                {
                    if (opcaoJogador3 == 1 && opcaoComputador == 3)
                    {
                        printf (""\n\nVitoria %s! Pedra quebra a tesoura."", nomeJogador3);
                        vitoriasJogador3++;                         
                    }else
                    {
                        if (opcaoJogador3 == 2 && opcaoComputador == 1)
                        {
                            printf (""\n\nVitoria %s! Papel embrulha a pedra."", nomeJogador3);
                            vitoriasJogador3++; 
                        }else
                        {
                            if (opcaoJogador3 == 3 && opcaoComputador == 2)
                            {
                                printf (""\n\nVitoria %s! Tesoura corta o papel."", nomeJogador3);
                                vitoriasJogador3++;
                            }else
                            {
                                if (opcaoJogador3 == 1 && opcaoComputador == 2)
                                {
                                printf (""\n\nVitoria %s! Papel embrulha a pedra."", nomeComputador);
                                vitoriasComputador++;
                                }else
                                {
                                    if (opcaoJogador3 == 2 && opcaoComputador == 3)
                                    {
                                        printf (""\n\nVitoria %s! Tesoura corta o papel."", nomeComputador);
                                        vitoriasComputador++;
                                    }else
                                    {
                                        printf (""\n\nVitoria %s! Pedra quebra a tesoura."", nomeComputador);
                                        vitoriasComputador++;
                                    }
                                }
                            }
                        }
                    }
                }
                sleep (2);
                totalPartidas++;
                printf (""\n\n\nDeseja jogar novamente? S/N"");
                opcaoJogarNovamnt = getch();
            }
            while (opcaoJogarNovamnt == 's');
            break;
        case '3':
            system (""COLOR 0F"");
            printf (""\n\nSaindo do jogo..."");
            return 0;
        default:
            system (""COLOR 0F"");
            printf (""\n\nOpcao invalida. Saindo do jogo..."");
            return 0;
        }
    system(""cls"");
    system (""COLOR 0F"");
    if (totalPartidas == 1 && empates == 1)
    {
        printf (""Jogo Jokenpo. Resultados: Modo Humano X Humano."");
        printf (""\n\nTotal de partidas: %d"", totalPartidas);
        printf (""\nTotal de empates: %d"", empates);
        printf (""\n\nNao houve ganhador."");
    }else
    {
        if (opcaoMenu == '1')
        {
            printf (""Jogo Jokenpo. Resultados: Modo Humano X Humano."");
            printf (""\n\nTotal de partidas: %d"", totalPartidas);            printf (""\nTotal de empates: %d"", empates);
            printf (""\n\n%s:\nPercentual de vitorias: %.1f"", nomeJogador1,percentVitJog1 = (vitoriasJogador1 / (totalPartidas - empates)) * 100);
            printf (""\n\n%s:\nPercentual de vitorias: %.1f\n\n"", nomeJogador2,percentVitJog2 = (vitoriasJogador2 / (totalPartidas - empates)) * 100);   
        }
        else
        {
            if (opcaoMenu == '2')
            printf (""Jogo Jokenpo. Resultados: Modo Humano X Computador."");
            printf (""\n\nTotal de partidas: %d"", totalPartidas);
            printf (""\nTotal de empates: %d"", empates);
            printf (""\n\n%s:\nPercentual de vitorias: %.1f"", nomeJogador3,percentVitJog3 = (vitoriasJogador3 / (totalPartidas - empates)) * 100);
            printf (""\n\n%s:\nPercentual de vitorias: %.1f\n\n"", nomeComputador,percentVitComp = (vitoriasComputador / (totalPartidas - empates)) * 100);
        }
    }
return 0;
}
",51,1569,2770
"#include ""mbmcs_MONOTONIC_TIMER.h""
#include ""mbmcs_stdio.h""


#ifdef __GNUC__
__attribute__ ((unused))
#endif
#ifdef DEBUG
static int debuglevel = 4;
#else
static const int debuglevel = 0;
#endif

#include ""dbms.h""

#if defined(_MULTIOS_DMSG_IS_UART)
#define EOL_CRLF ""\n\r""
#else
#define EOL_CRLF ""\n""
#endif



#define MONOTONIC_TIMER_OP_FORCE_CLEAR_PLS_BIT ((uint32_t)0x1)
#define MONOTONIC_TIMER_OP_FORCE_CLEAR_PLS_SHIFT (31)
#define MONOTONIC_TIMER_OP_FORCE_CLEAR_PLS_MASK (MONOTONIC_TIMER_OP_FORCE_CLEAR_PLS_BIT << MONOTONIC_TIMER_OP_FORCE_CLEAR_PLS_SHIFT)

#define MONOTONIC_TIMER_OP_COUNTER_LATCH_MASK_BIT ((uint32_t)0x1)
#define MONOTONIC_TIMER_OP_COUNTER_LATCH_MASK_SHIFT (30)
#define MONOTONIC_TIMER_OP_COUNTER_LATCH_MASK_MASK (MONOTONIC_TIMER_OP_COUNTER_LATCH_MASK_BIT << MONOTONIC_TIMER_OP_COUNTER_LATCH_MASK_BIT)


#define MONOTONIC_TIMER_OP(a) *((volatile unsigned int*)((intptr_t)(a) + 0x0))
#define MONOTONIC_TIMER_LSB(a) *((volatile unsigned int*)((intptr_t)(a) + 0x8))
#define MONOTONIC_TIMER_MSB(a) *((volatile unsigned int*)((intptr_t)(a) + 0xc))


extern void mbmcs_monotonic_timer_init(mbmcs_monotonic_timer_t *const, const uintptr_t)
    __attribute__ ((optimize(""Os"")));
extern uint64_t mbmcs_monotonic_timer_get_timer_counter( const mbmcs_monotonic_timer_t *const)
    __attribute__ ((optimize(""O2"")));


void  mbmcs_monotonic_timer_init(mbmcs_monotonic_timer_t *const self_p, const uintptr_t base_addr)
{
    self_p->base_addr = base_addr;

    return;
}

uint64_t mbmcs_monotonic_timer_get_timer_counter( const mbmcs_monotonic_timer_t *const self_p)
{
    volatile uint64_t retval64;
    volatile uint32_t reg32;
    reg32 = MONOTONIC_TIMER_OP(self_p->base_addr);
    reg32 |= MONOTONIC_TIMER_OP_COUNTER_LATCH_MASK_MASK;
    MONOTONIC_TIMER_OP(self_p->base_addr) = reg32;

    retval64 = MONOTONIC_TIMER_MSB(self_p->base_addr);
    
    retval64 <<= 32;
    retval64 |= MONOTONIC_TIMER_LSB(self_p->base_addr);

    reg32 = MONOTONIC_TIMER_OP(self_p->base_addr);
    reg32 &= ~MONOTONIC_TIMER_OP_COUNTER_LATCH_MASK_MASK;
    MONOTONIC_TIMER_OP(self_p->base_addr) = reg32;

    return retval64;
}
",52,1570,1046
"#include ""multios_sys_types.h""
#include ""multios_unistd.h""


#ifdef __GNUC__
__attribute__ ((unused))
#endif
#ifdef DEBUG
static int debuglevel = 4;
#else
static const int debuglevel = 0;
#endif

#include ""dbms.h""

#if defined(_MULTIOS_DMSG_IS_UART)
#define EOL_CRLF ""\n\r""
#else
#define EOL_CRLF ""\n""
#endif


#if defined(_MULTIOS_DMSG_IS_UART)
#define EOL_CRLF ""\n\r""
#else
#define EOL_CRLF ""\n""
#endif


#include ""mbmcs_platform.h""
#include ""mbmcs_time.h""
#include ""mbmcs_ATMEL_93C_SPI.h""

#define STATUS_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x0))
#define OP_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x0))
#define ADDR_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x4))
#define WRITE_DATA_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x8))
#define READ_DATA_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0xC))

#define STATUS_X8_ADDRBIT_BIT ((uint32_t)0x3f)
#define STATUS_X8_ADDRBIT_SHIFT (0)
#define STATUS_X8_ADDRBIT_MASK (STATUS_X8_ADDRBIT_BIT << STATUS_X8_ADDRBIT_SHIFT)

#define STATUS_X16_ADDRBIT_BIT ((uint32_t)0x1f)
#define STATUS_X16_ADDRBIT_SHIFT (0)
#define STATUS_X16_ADDRBIT_MASK (STATUS_X16_ADDRBIT_MASK << STATUS_X16_ADDRBIT_SHFT)


#define OP_START_BIT ((uint32_t)0x1)
#define OP_START_SHIFT (0)
#define OP_START_MASK (OP_START_BIT << OP_START_SHIFT)

#define OP_OPCODE_BIT ((uint32_t)0x3)
#define OP_OPCODE_SHIFT (30)
#define OP_OPCODE_MASK (OP_OPCODE_BIT << OP_OPCODE_SHIFT)
#define OP_SUBOP_CODE_BIT ((uint32_t)0x3)
#define OP_SUBOP_CODE_SHIFT (28)
#define OP_SUBOP_MASK (OP_SUBOP_CODE_BIT << OP_SUBOP_CODE_SHIFT)

#define STAT_READY_BIT ((uint32_t)0x1)
#define STAT_READY_SHIFT (0)
#define STAT_READY_MASK (STAT_READY_BIT << STAT_READY_SHIFT)

#define STAT_X16MODE_BIT ((uint32_t)0x1)
#define STAT_X16MODE_SHIFT (15)
#define STAT_X16MODE_MASK (STAT_X16MODE_BIT << STAT_X16MODE_SHIFT)
#define STAT_BUSY_BIT ((uint32_t)0x1)
#define STAT_BUSY_SHIFT (4)
#define STAT_BUSY_MASK (STAT_BUSY_BIT << STAT_BUSY_SHIFT)
#define STAT_EINVAL_BIT ((uint32_t)0x1)
#define STAT_EINVAL_SHIFT (3)
#define STAT_EINVAL_MASK (STAT_EINVAL_BIT << STAT_EINVAL_SHIFT)
#define STAT_ETIMEDOUT_BIT ((uint32_t)0x1)
#define STAT_ETIMEDOUT_SHIFT (2)
#define STAT_ETIMEDOUT_MASK (STAT_ETIMEDOUT_BIT << STAT_ETIMEDOUT_SHIFT) 
#define STAT_EINVAL_MASK (STAT_EINVAL_BIT << STAT_EINVAL_SHIFT)
#define STAT_DONE_BIT ((uint32_t)0x1)
#define STAT_DONE_SHIFT (1)
#define STAT_DONE_MASK (STAT_DONE_BIT << STAT_DONE_SHIFT)



#define ATMEL93C_ADDRMASK 0x7f

#define ATMEL93C_READMASK 0xffff 

#define ATMEL93C_WRITEMASK 0xffff 


extern int mbmcs_atmel_93c_init( mbmcs_atmel_93c_spi_t * const self_p, const intptr_t base_addr, const enum_mbmcs_atmel_93c_series_t model)
    __attribute__ ((optimize(""Os"")));
extern int mbmcs_atmel_93c_set_vcc_attribute( mbmcs_atmel_93c_spi_t * const self_p, uint8_t vcc_is_exceed_4p5)
    __attribute__ ((optimize(""Os"")));

extern int mbmcs_atmel_93c_destroy( mbmcs_atmel_93c_spi_t * const self_p)
    __attribute__ ((optimize(""Os"")));

extern int mbmcs_atmel_93c_readx8( const mbmcs_atmel_93c_spi_t * const self_p, const uint16_t addr, uint8_t *const d8_p)
    __attribute__ ((optimize(""O2"")));
extern int mbmcs_atmel_93c_writex8( const mbmcs_atmel_93c_spi_t * const self_p, const uint16_t addr, const uint8_t d8)
    __attribute__ ((optimize(""O2"")));

extern int mbmcs_atmel_93c_erasex8( const mbmcs_atmel_93c_spi_t * const self_p, const uint16_t addr)
    __attribute__ ((optimize(""O2"")));

extern int mbmcs_atmel_93c_write_enable( const mbmcs_atmel_93c_spi_t * const self_p)
    __attribute__ ((optimize(""O2"")));
extern int mbmcs_atmel_93c_write_disable( const mbmcs_atmel_93c_spi_t * const self_p)
    __attribute__ ((optimize(""O2"")));

static int atmel_93c_ready_wait_timeout(const uint32_t addr)
    __attribute__ ((optimize(""O2"")));


int mbmcs_atmel_93c_init( mbmcs_atmel_93c_spi_t * const self_p, const intptr_t base_addr, const enum_mbmcs_atmel_93c_series_t model)
{
    size_t n;
    uint32_t rd32;
    
    mbmcs_atmel_93c_api_attr_t attr;

    self_p->base_addr = base_addr;

    if(atmel_93c_ready_wait_timeout(self_p->base_addr)) {
    DBMS1( stderr, ""93c_init : module is not ready"" EOL_CRLF);
    return EAGAIN;
    } 

#if 1
    for( n=0; mbmcs_atmel_93c_bit_depth_list[n].model != ATMEL_93C_EOD; ++n) {
    if( mbmcs_atmel_93c_bit_depth_list[n].model == model) {
        break;
    }
    }

    if(mbmcs_atmel_93c_bit_depth_list[n].model != ATMEL_93C46) {
    return ENOTSUP;
    }

    if(mbmcs_atmel_93c_bit_depth_list[n].model == ATMEL_93C_EOD) {
    return ENOTSUP;
    }
    self_p->model = model;

    
    rd32 = mbmcs_platform_read_register32(self_p->base_addr);

    
    attr.flags = 0;
    attr.f.datamode_is_x16 = ( rd32 & STAT_X16MODE_MASK ) ? 1 : 0;
    self_p->attr = attr;
#endif

    return 0;
}

int mbmcs_atmel_93c_set_vcc_attribute( mbmcs_atmel_93c_spi_t * const self_p, const uint8_t vcc_is_over_4p5)
{
    self_p->attr.f.vcc_is_over_4p5 = (vcc_is_over_4p5) ? 1 : 0;

    return 0;
}

#if 0

int mbmcs_atmel_93c_set_interrupt_callback( mbmcs_atmel_93c_spi_t * const self_p, void (*func)(mbmcs_atmel_93c_intr_t*))
{
    if( NULL == func ) {
    self_p->attr.f.use_interrupt = 0;
    self_p->intr_callback_func = NULL;
    self_p->interrupted = 0;
    return 0;
    } 

    

    self_p->attr.f.use_interrupt = 1;
    self_p->intr_callback_func = func;
    self_p->interrupted = 0;

    return ENOTSUP;
}
#endif

int mbmcs_atmel_93c_readx8( const mbmcs_atmel_93c_spi_t * const self_p, const uint16_t addr, uint8_t *const d8_p)
{
    uint32_t reg32;

    if( self_p->attr.f.datamode_is_x16) {
    DBMS1( stderr, ""93c_readx8 : module invalid mode(valid x8)"" EOL_CRLF);
    return EACCES;
    }

    if(atmel_93c_ready_wait_timeout(self_p->base_addr)) {
    DBMS1( stderr, ""93c_readx8 : module is not ready"" EOL_CRLF);
    return EAGAIN;
    } 

    reg32 = STATUS_REG(self_p->base_addr);
    if(reg32 & STAT_BUSY_MASK) {
    DBMS1( stderr, ""93c_readx8 : is BUSY"" EOL_CRLF);
    return EBUSY;
    }

    ADDR_REG(self_p->base_addr) = addr;

    reg32 &= ~(OP_OPCODE_MASK | OP_SUBOP_MASK); 
    reg32 |= ((OP_OPCODE_BIT & 0x2) << OP_OPCODE_SHIFT) | OP_START_MASK;

    STATUS_REG(self_p->base_addr) = reg32;

    
    while(!((reg32 = STATUS_REG(self_p->base_addr)) & STAT_DONE_MASK));

    if(reg32 & STAT_EINVAL_MASK) {
    DBMS1( stderr, ""93c_readx8 : STAT_EINVAL"" EOL_CRLF);
    return EINVAL;
    }
    if(reg32 & STAT_ETIMEDOUT_MASK) {
    DBMS1( stderr, ""93c_readx8 : STAT_ETIMEDOUT"" EOL_CRLF);
    return ETIMEDOUT;
    }

    *d8_p = (0xff & READ_DATA_REG(self_p->base_addr));

    return 0;    
}

int mbmcs_atmel_93c_writex8( const mbmcs_atmel_93c_spi_t * const self_p, const uint16_t addr, const uint8_t d8)
{
    uint32_t reg32;

    if( self_p->attr.f.datamode_is_x16) {
    DBMS1( stderr, ""93c_writex8 : x16 access denaind"" EOL_CRLF);
    return EACCES;
    }

    if(atmel_93c_ready_wait_timeout(self_p->base_addr)) {
    DBMS1( stderr, ""93c_writex8 : module is not ready"" EOL_CRLF);
    return EAGAIN;
    } 

    reg32 = STATUS_REG(self_p->base_addr);
    if(reg32 & STAT_BUSY_MASK) {
    DBMS1( stderr, ""93c_writex8 : is BUSY"" EOL_CRLF);
    return EBUSY;
    }

    ADDR_REG(self_p->base_addr) = addr;
    WRITE_DATA_REG(self_p->base_addr) = 0xff & d8;

    reg32 &= ~(OP_OPCODE_MASK | OP_SUBOP_MASK); 
    reg32 |= ((OP_OPCODE_BIT & 0x1) << OP_OPCODE_SHIFT) | OP_START_MASK;

    STATUS_REG(self_p->base_addr) = reg32;

    
    DBMS3( stderr, ""93c_writex8 : pollog wait"" EOL_CRLF);
    while(!((reg32 = STATUS_REG(self_p->base_addr)) & STAT_DONE_MASK));

    if(reg32 & STAT_EINVAL_MASK) {
    DBMS1( stderr, ""93c_writex8 : STAT_EINVAL"" EOL_CRLF);
    return EINVAL;
    }
    if(reg32 & STAT_ETIMEDOUT_MASK) {
    DBMS1( stderr, ""93c_writex8 : STAT_EINVAL"" EOL_CRLF);
    return ETIMEDOUT;
    }

    return 0;  
}

int mbmcs_atmel_93c_erasex8( const mbmcs_atmel_93c_spi_t * const self_p, const uint16_t addr)
{
    uint32_t reg32;

    if(atmel_93c_ready_wait_timeout(self_p->base_addr)) {
    DBMS1( stderr, ""93c_erasex8 : module is not ready"" EOL_CRLF);
    return EAGAIN;
    } 

    reg32 = STATUS_REG(self_p->base_addr);
    if(reg32 & STAT_BUSY_MASK) {
    DBMS1( stderr, ""93c_erasex8 : is BUSY"" EOL_CRLF);
    return EBUSY;
    }
    ADDR_REG(self_p->base_addr) = addr;

    reg32 &= ~(OP_OPCODE_MASK | OP_SUBOP_MASK);
    reg32 |= ((OP_OPCODE_BIT & 0x3) << OP_OPCODE_SHIFT); 
    reg32 |= OP_START_MASK;

    STATUS_REG(self_p->base_addr) = reg32;

    
    DBMS3( stderr, ""93c_erasex8 : pollog wait"" EOL_CRLF);
    while(!((reg32 = STATUS_REG(self_p->base_addr)) & STAT_DONE_MASK));

    if(reg32 & STAT_EINVAL_MASK) {
    DBMS1( stderr, ""93c_erasex8 : STAT_EINVAL"" EOL_CRLF);
    return EINVAL;
    }
    if(reg32 & STAT_ETIMEDOUT_MASK) {
    DBMS1( stderr, ""93c_erasex8 : STAT_EINVAL"" EOL_CRLF);
    return ETIMEDOUT;
    }

    return 0;  
}

int mbmcs_atmel_93c_write_enable( const mbmcs_atmel_93c_spi_t * const self_p)
{
    uint32_t reg32;

    if(atmel_93c_ready_wait_timeout(self_p->base_addr)) {
    DBMS1( stderr, ""93c_write_enable : module is not ready"" EOL_CRLF);
    return EAGAIN;
    } 

    reg32 = STATUS_REG(self_p->base_addr);
    if(reg32 & STAT_BUSY_MASK) {
    DBMS3( stderr, ""93c_write_enable : is BUSY"" EOL_CRLF);
    return EBUSY;
    }

    ADDR_REG(self_p->base_addr) = 0;

    
    reg32 &= ~(OP_OPCODE_MASK | OP_SUBOP_MASK); 
    reg32 |= (OP_SUBOP_MASK & (0x3 << OP_SUBOP_CODE_SHIFT)) | OP_START_MASK;

    STATUS_REG(self_p->base_addr) = reg32;

    
    while(!((reg32 = STATUS_REG(self_p->base_addr)) & STAT_DONE_MASK));

    if(reg32 & STAT_EINVAL_MASK) {
    DBMS1( stderr, ""93c_write_enable : EINVAL"" EOL_CRLF);
    return EINVAL;
    }
    if(reg32 & STAT_ETIMEDOUT_MASK) {
    DBMS1( stderr, ""93c_write_enable : ETIMEDOUT"" EOL_CRLF);
    return ETIMEDOUT;
    }

    return 0;
}

static int atmel_93c_ready_wait_timeout(const uint32_t addr)
{
    const unsigned int timeout_msec=10;
    unsigned int cnt;
    uint32_t reg32;

    for(cnt=timeout_msec; cnt!=0; --cnt) {
        if(!((reg32 = STATUS_REG(addr)) & STAT_READY_MASK)) {
        break;
    }
    multios_msleep(1);
    }
    if( cnt==0 && !reg32 ) {
    return -1;
    } 

    return 0;
}


int mbmcs_atmel_93c_write_disable( const mbmcs_atmel_93c_spi_t * const self_p)
{
    uint32_t reg32;

    if(atmel_93c_ready_wait_timeout(self_p->base_addr)) {
    DBMS1( stderr, ""93c_write_disable : module is not ready"" EOL_CRLF);
    return EAGAIN;
    } 

    reg32 = STATUS_REG(self_p->base_addr);
    if(reg32 & STAT_BUSY_MASK) {
    DBMS3( stderr, ""93c_write_disable : is BUSY"" EOL_CRLF);
    return EBUSY;
    }

    ADDR_REG(self_p->base_addr) = 0;

    reg32 &= ~(OP_OPCODE_MASK | OP_SUBOP_MASK); 
    reg32 |= OP_START_MASK;

    STATUS_REG(self_p->base_addr) = reg32;

    
    while(!((reg32 = STATUS_REG(self_p->base_addr)) & STAT_DONE_MASK));



    if(reg32 & STAT_EINVAL_MASK) {
    DBMS1( stderr, ""93c_write_disable : EINVAL"" EOL_CRLF);
    return EINVAL;
    }

    if(reg32 & STAT_ETIMEDOUT_MASK) {
    DBMS1( stderr, ""93c_write_disable : ETIMEDOUT"" EOL_CRLF);
    return ETIMEDOUT;
    }

    return 0;
}
",52,1571,5480
"#include ""mddl_mallocater.h""
#include ""mddl_malloc.h""

#ifdef DEBUG
static int debuglevel = 2;
#else
static const int debuglevel = 0;
#endif
#include ""dbms.h""

#define EOL_CRLF ""\n\r""


int mddl_malloc_align(void **memptr, const size_t alignment,
             const size_t size)
{
    int result;
    const size_t a = (alignment == 0) ? sizeof(uint64_t) : alignment;
    void *mem = NULL;
    uint8_t *aligned_mem = NULL;

    DBMS5(""%s : execute"" EOL_CRLF, __func__);
    if ((a % 2) || (size == 0) || (NULL == memptr)) {
    result = errno = EINVAL;
    } else {
    const size_t total = size + sizeof(void *) + (a - 1);
    mem = malloc(total);
    if (NULL == mem) {
        result = errno;
    } else {
        uintptr_t offs;

        IFDBG5THEN {
        DBMS5(""%s : malloc = 0x%p total=%llu  alignment=%llu size=%llu"" EOL_CRLF,
            __func__, mem, (unsigned long long)total,(unsigned long long)alignment, (unsigned long long)size);
        }

        
        aligned_mem = ((uint8_t *) mem + sizeof(void *));
        offs = (uintptr_t) a - ((uintptr_t) aligned_mem & (a - 1));

        IFDBG5THEN {
        DBMS5(
          ""%s : a-1=0x%llx offs=0x%llu"" EOL_CRLF,
            __func__, (uintptr_t)a-1, offs);
        }

        aligned_mem += offs;

        IFDBG5THEN {
        DBMS5( ""%s : aligned_mem = 0x%p"" EOL_CRLF, __func__, aligned_mem);
        }

        
        ((void **) aligned_mem)[-1] = mem;

        *memptr = aligned_mem;
        result = 0;
    }
    }

    return result;
}


void *mddl_realloc_align(void *memblk, const size_t alignment,
                const size_t size)
{
    int result;
    void *mem;
    result = mddl_malloc_align(&mem, alignment, size);
    if (result) {
    return NULL;
    }
    memcpy(mem, memblk, size);
    mddl_mfree(memblk);
    return mem;
}


int mddl_mfree(void *memptr)
{
    
    mddl_free(((void **) memptr)[-1]);
    return 0;
}


void *mddl_mrealloc_align(void *memblock, const size_t alignment,
                 const size_t size)
{
    size_t a = (alignment == 0) ? sizeof(uint64_t) : alignment;
    int result;
    void *mem = NULL;
    uint8_t *aligned_mem = NULL;

    DBMS5( ""%s : execute"" EOL_CRLF, __func__);
    if (NULL == memblock) {
    void *memptr = NULL;
    result = mddl_malloc_align(&memptr, a, size);
    return (result == 0) ? memptr : NULL;
    } else if ((a % 2) || (size == 0)) {
    errno = EINVAL;
    return NULL;
    } else {
    mem =
        mddl_realloc(((void **) memblock)[-1],
            size + (a - 1) + sizeof(void *));
    if (NULL == mem) {
        return NULL;
    } else {
        aligned_mem = ((uint8_t *) mem + sizeof(void *));
        aligned_mem += ((uintptr_t) aligned_mem & (a - 1));
        ((void **) aligned_mem)[-1] = mem;
    }
    }

    return aligned_mem;
}


mddl_mem_alignment_partition_t mddl_mem_alignment_partition(int
                                  *const
                                  result_p,
                                  const
                                  void
                                  *const p,
                                  size_t
                                  size,
                                  size_t
                                  alignment)
{
    mddl_mem_alignment_partition_t part;
    uintptr_t a = (uintptr_t) p;
    const size_t align_mask = (alignment - 1);

    memset(&part, 0x0, sizeof(mddl_mem_alignment_partition_t));
    part.total_sz = size;
    part.alignment_sz = alignment;

    if (size < alignment) {
    part.foward_sz = size;
    } else {
    part.ext.f.size_is_multiple_alignment =
        (size & align_mask) ? 0 : 1;
    part.foward_sz = (a & align_mask);
    if (!part.foward_sz) {
        part.ext.f.is_aligned = 1;
    } else {
        part.foward_sz = alignment - part.foward_sz;
        size -= part.foward_sz;
        part.ext.f.is_aligned = 0;
    }

    if (size != 0) {
        part.bottom_sz = (size & align_mask);
        part.middle_sz = size - part.bottom_sz;
    }
    }

    if (NULL != result_p) {
    *result_p = 0;
    }

    return part;
}


void *mddl_malloc(const size_t size)
{
    return mddl_mallocater_alloc(size);
}


void mddl_free( void *const ptr)
{
    mddl_mallocater_free(ptr);
}



void *mddl_realloc( void *const ptr, const size_t size)
{
    return mddl_mallocater_realloc(ptr, size);
}

",52,1572,1628
"#include ""multios_lite_mallocater.h""


#include ""libmbmcs_libmultios_bridge.h""
#include ""mbmcs_stdio.h""
#include ""mbmcs_platform.h""
#include ""mbmcs_unistd.h""


#ifdef __GNUC__
__attribute__ ((unused))
#endif
#ifdef DEBUG
static int debuglevel = 4;
#else
static int debuglevel = 0;
#endif
#include ""dbms.h""

#if defined(_MULTIOS_DMSG_IS_UART)
#define EOL_CRLF ""\n\r""
#else
#define EOL_CRLF ""\n""
#endif


int64_t mbmcs_sysconf_pagesize(void)
{
    return XPAR_CPU_MICROBLAZE_I_DATA_SIZE;
}


int64_t mbmcs_sysconf_nprocessor_conf(void)
{
    return 1; 
}


int64_t mbmcs_sysconf_nprocessor_onln(void)
{
    return 1; 
}


int64_t mbmcs_sysconf_phys_pages(void)
{
    return 2 * 0xffff / XPAR_CPU_MICROBLAZE_I_DATA_SIZE;
}


int64_t mbmcs_sysconf_avphys_pages(void)
{
    return multios_lite_mallocater_avphys_with_obj(&_multios_lite_mallocater_heap_emulate_obj) / XPAR_CPU_MICROBLAZE_I_DATA_SIZE;

}
",52,1573,435
"#include ""mddl_stl_deque.h""
#include ""mddl_stl_list.h""
#include ""mddl_stl_slist.h""

#include ""mddl_stl_queue.h""


#ifdef DEBUG
static int debuglevel = 4;
#else
static const int debuglevel = 0;
#endif
#include ""dbms.h""

#define EOL_CRLF ""\n\r""


void __attribute__((weak)) *mddl_malloc(const size_t size)
{
    return malloc(size);
}

void __attribute__((weak)) mddl_free( void *const ptr )
{
    free(ptr);
}


typedef int(*front_func_t)( void *self_p, void *el_p, const size_t sizof_el);
typedef int(*back_func_t)( void *self_p, void *el_p, const size_t sizof_el);
typedef int(*push_func_t)(void *self_p, const void *el_p, const size_t sizof_el);
typedef int(*pop_func_t)( void *self_p);
typedef size_t(*get_pool_cnt_func_t)(void *self_p);
typedef int(*is_empty_func_t)(void *self_p);
typedef int(*clear_func_t)(void *self_p);
typedef int(*get_element_at_func_t)(void *self_p, size_t num, void *el_p, const size_t sizof_el);

typedef struct _mddl_stl_queue_ext {
    enum_mddl_stl_queue_implement_type_t implement_type;
    union {
    mddl_stl_deque_t deque;
    mddl_stl_slist_t slist;
    mddl_stl_list_t list;
    uint8_t ptr[1];
    } instance;

    size_t sizof_element;
    front_func_t front_func;
    back_func_t back_func;
    push_func_t push_func;
    pop_func_t pop_func;
    get_pool_cnt_func_t get_pool_cnt_func;
    is_empty_func_t is_empty_func;
    clear_func_t clear_func;
    get_element_at_func_t get_element_at_func;

    union {
    unsigned int flags;
    struct {
        unsigned int deque:1;
        unsigned int slist:1;
        unsigned int list:1;
    } f;
    } init;
} mddl_stl_queue_ext_t;

#define get_stl_deque_ext(s) (mddl_stl_queue_ext_t*)((s)->ext)
#define get_stl_const_deque_ext(s) (const mddl_stl_queue_ext_t*)((s)->ext)


int mddl_stl_queue_init(mddl_stl_queue_t *const self_p,
               const size_t sizof_element)
{
    return mddl_stl_queue_init_ex( self_p, sizof_element, MDDL_STL_QUEUE_TYPE_IS_DEFAULT, NULL);
}


int mddl_stl_queue_init_ex( mddl_stl_queue_t *const self_p, const size_t sizof_element, const enum_mddl_stl_queue_implement_type_t type, void *const attr_p)
{
    int result, status;
    mddl_stl_queue_ext_t * __restrict e = NULL;
    const enum_mddl_stl_queue_implement_type_t implement_type = ( type == MDDL_STL_QUEUE_TYPE_IS_DEFAULT ) ? MDDL_STL_QUEUE_TYPE_IS_SLIST : type;

    (void)attr_p;
    memset( self_p, 0x0, sizeof(mddl_stl_queue_t));

    if(!(sizof_element > 0 )) {
    return EINVAL;
    }

    if((implement_type >= MDDL_STL_QUEUE_TYPE_IS_OTHERS) || ( implement_type < MDDL_STL_QUEUE_TYPE_IS_DEFAULT )) {
    return EINVAL;
    }

    e = (mddl_stl_queue_ext_t*)mddl_malloc(sizeof(mddl_stl_queue_ext_t));
    if( NULL == e ) {
    return EAGAIN;
    }
    memset( e, 0x0, sizeof(mddl_stl_queue_ext_t));
    self_p->ext = e;

    self_p->sizof_element = e->sizof_element = sizof_element;

    switch(implement_type) {
    case MDDL_STL_QUEUE_TYPE_IS_SLIST:
    
    result = mddl_stl_slist_init( &e->instance.slist, sizof_element);
    if(result) {
        DBMS1( ""%s : mddl_stl_slist_init fail, streror:%s"" EOL_CRLF, __func__, strerror(result));
        status = result;
        goto out;
    }

    e->front_func = (front_func_t)mddl_stl_slist_front;
    e->push_func = (push_func_t)mddl_stl_slist_push;
        e->pop_func = (pop_func_t)mddl_stl_slist_pop;
        e->get_pool_cnt_func = (get_pool_cnt_func_t)mddl_stl_slist_get_pool_cnt;
    e->is_empty_func = (is_empty_func_t)mddl_stl_slist_is_empty;
    e->clear_func = (clear_func_t)mddl_stl_slist_clear;
    e->get_element_at_func = (get_element_at_func_t)mddl_stl_slist_get_element_at;

    e->init.f.slist = 1;
    break;
    case MDDL_STL_QUEUE_TYPE_IS_DEQUE:
    
    result = mddl_stl_deque_init( &e->instance.deque, sizof_element);
    if(result) {
        DBMS1( ""%s : mddl_stl_deque_init fail, streror:%s"" EOL_CRLF, __func__, strerror(result));
        status = result;
        goto out;
    }

    e->front_func = (front_func_t)mddl_stl_deque_front;
    e->push_func = (push_func_t)mddl_stl_deque_push_back;
        e->pop_func = (pop_func_t)mddl_stl_deque_pop_front;
        e->get_pool_cnt_func = (get_pool_cnt_func_t)mddl_stl_deque_get_pool_cnt;
    e->is_empty_func = (is_empty_func_t)mddl_stl_deque_is_empty;
    e->clear_func = (clear_func_t)mddl_stl_deque_clear;
    e->get_element_at_func = (get_element_at_func_t)mddl_stl_deque_get_element_at;
    
    e->init.f.deque = 1;
    break;
    case MDDL_STL_QUEUE_TYPE_IS_LIST:
    
    result = mddl_stl_list_init( &e->instance.list, sizof_element);
    if(result) {
        DBMS1( ""%s : mddl_stl_list_init fail, strerror:%s"" EOL_CRLF, __func__, strerror(result));
        status = result;
        goto out;
    }

    e->front_func = (front_func_t)mddl_stl_list_front;
    e->push_func = (push_func_t)mddl_stl_list_push_back;
        e->pop_func = (pop_func_t)mddl_stl_list_pop_front;
        e->get_pool_cnt_func = (get_pool_cnt_func_t)mddl_stl_list_get_pool_cnt;
    e->is_empty_func = (is_empty_func_t)mddl_stl_list_is_empty;
    e->clear_func = (clear_func_t)mddl_stl_list_clear;
    e->get_element_at_func = (get_element_at_func_t)mddl_stl_list_get_element_at;
    
    e->init.f.list = 1;
    break;
    default:
    status = ENOSYS;
    goto out;
    }

    status = 0;

out:    
    if(status) {
        mddl_stl_queue_destroy(self_p);
    } 
    return status;
}


int mddl_stl_queue_destroy(mddl_stl_queue_t *const self_p)
{
    mddl_stl_queue_ext_t *const e =
    (mddl_stl_queue_ext_t *) self_p->ext;
    int status, result;

    if( NULL == e ) {
    return 0;
    }

    if( e->init.f.deque ) {
    
    result = mddl_stl_deque_destroy( &e->instance.deque);
    if(result) {
        DBMS1(""%s : mddl_stl_deque_destroy fail, retval=0x%s"" EOL_CRLF, __func__, result);
        status = result;
        goto out;
    }
    e->init.f.deque = 0;
    }

    if( e->init.f.slist ) {
    
    result = mddl_stl_slist_destroy( &e->instance.slist);
    if(result) {
        DBMS1(""%s : mddl_stl_slist_destroy fail, retval=0x%s"" EOL_CRLF, __func__, result);
        status = result;
        goto out;
    }
    e->init.f.slist = 0;
    }

    if( e->init.f.list ) {
    
    result = mddl_stl_list_destroy( &e->instance.list);
    if(result) {
        DBMS1(""%s : mddl_stl_list_destroy fail, retval=0x%s"" EOL_CRLF, __func__, result);
        status = result;
        goto out;
    }
    e->init.f.list = 0;
    }
    
    status = e->init.flags;

out:
    if(!status) {
    mddl_free(e);
    self_p->ext = NULL;
    }
    return status;
}
    

int mddl_stl_queue_push(mddl_stl_queue_t *const self_p, const void *const el_p,
               const size_t sizof_element)
{
    mddl_stl_queue_ext_t *const e =
    (mddl_stl_queue_ext_t *) self_p->ext;

    return e->push_func(e->instance.ptr, el_p, sizof_element);
}


int mddl_stl_queue_pop(mddl_stl_queue_t *const self_p)
{
    mddl_stl_queue_ext_t *const e =
    (mddl_stl_queue_ext_t *) self_p->ext;

    return e->pop_func(e->instance.ptr);
}


int mddl_stl_queue_front(mddl_stl_queue_t *const self_p, void *const el_p,
                const size_t sizof_element)
{
    mddl_stl_queue_ext_t *const e =
    (mddl_stl_queue_ext_t *) self_p->ext;

    return e->front_func(e->instance.ptr, el_p, sizof_element);
}


int mddl_stl_queue_clear(mddl_stl_queue_t *const self_p)
{
    mddl_stl_queue_ext_t *const e =
    (mddl_stl_queue_ext_t *) self_p->ext;

    return e->clear_func(e->instance.ptr);
}


size_t mddl_stl_queue_get_pool_cnt(mddl_stl_queue_t *const self_p)
{
    mddl_stl_queue_ext_t *const e =
    (mddl_stl_queue_ext_t *) self_p->ext;

    return e->get_pool_cnt_func(e->instance.ptr);
}


int mddl_stl_queue_is_empty(mddl_stl_queue_t *const self_p)
{
    mddl_stl_queue_ext_t *const e =
    (mddl_stl_queue_ext_t *) self_p->ext;

    return e->is_empty_func(e->instance.ptr);
}


int mddl_stl_queue_get_element_at(mddl_stl_queue_t *const self_p,
                       const size_t num, void *const el_p,
                       const size_t sizof_element)
{
    mddl_stl_queue_ext_t *const e =
    (mddl_stl_queue_ext_t *) self_p->ext;

    return e->get_element_at_func(e->instance.ptr, num, el_p, sizof_element);
}



int mddl_stl_queue_back( mddl_stl_queue_t *const self_p, void *const el_p, const size_t sizof_element )
{
    mddl_stl_queue_ext_t *const e =
    (mddl_stl_queue_ext_t *) self_p->ext;

    return e->back_func(e->instance.ptr, el_p, sizof_element);
}


",52,1574,3822
"#if defined(WIN32) || 1

#define _CRT_SECURE_NO_WARNINGS
#if _MSC_VER >= 1400            
#pragma warning ( disable:4996 )
#pragma warning ( disable:4819 )
#endif
#endif




#include ""mddl_printf.h""

static int putch(int code)
{
    return fputc(code, stdout);
}


int
main(int ac, char **av)
{
    int a = 12345, b = 987654;
    int len;
    char C = 'C';
    const char *txt=""chat put acbde"";
    size_t n;
    char buf[128];

    double d[] = {
        0.0,
        42.0,
        1234567.89012345,
        0.000000000000018,
        555555.55555555555555555,
        -888888888888888.8888888,
        111111111111111111111111.2222222222
    };

    mddl_printf_init(putch);

    for(n=0;n<100;n++) {
        len = sprintf(buf, ""%% %d %c %d %s %d buf=%p\n"", a, (int)n, b, txt, a, buf);
    printf(""sprintf=%s"",buf);
    printf(""len=%llu\n"", (unsigned long long)len);

        len = mddl_printf(""%% %d %c %d %s %d buf=%p\n"", a, (int)n, b, txt, a, buf);
    mddl_printf(""len=%llu\n"", (unsigned long long)len);

    len = sprintf(buf, ""%f %f %f\n"", d[0], d[1], d[2]);
    printf(""float sprintf=%s"",buf);
    printf(""len=%d\n"", len);

        len = mddl_printf(""%f %f %f\n"", d[0], d[1], d[2]);
    printf(""len=%d\n"", len);
    }

    return 0;
}
",52,1575,627
"#include ""mbmcs_stdio.h""
#include ""mbmcs_STD_2STATE_SWITCH.h""


#ifdef __GNUC__
__attribute__ ((unused))
#endif
#ifdef DEBUG
static int debuglevel = 4;
#else
static const int debuglevel = 0;
#endif
#include ""dbms.h""

#if defined(_MULTIOS_DMSG_IS_UART)
#define EOL_CRLF ""\n\r""
#else
#define EOL_CRLF ""\n""
#endif



#define MBMCS_EXTTEND_MODULE_MEMMAP_ADDR 0xC0000000
#define MBMCS_MEMALIGN 4

#define SW_IF_OP_STAT_REG(a) *((volatile uint32_t*)((uintptr_t)(a) + 0x0))
#define SW_IF_MONOTONIC_TIMER64_LSB32_REG(a) *((volatile uint32_t*)((uintptr_t)(a) + 0x8))
#define SW_IF_MONOTONIC_TIMER64_MSB32_REG(a) *((volatile uint32_t*)((uintptr_t)(a) + 0xC))

#define SW_NEGATIVE_EGDE_DETECTIVE_BIT ((uint32_t)0x1)
#define SW_NEGATIVE_EGDE_DETECTIVE_SHIFT  (16)
#define SW_NEGATIVE_EGDE_DETECTIVE_MASK (uint32_t)(SW_NEGATIVE_EGDE_DETECTIVE_BIT << SW_NEGATIVE_EGDE_DETECTIVE_SHIFT)

#define SW_POSITIVE_EGDE_DETECTIVE_BIT ((uint32_t)0x1)
#define SW_POSITIVE_EGDE_DETECTIVE_SHIFT (17)
#define SW_POSITIVE_EDGE_DETECTIVE_MASK (uint32_t)(SW_POSITIVE_EGDE_DETECTIVE_BIT << SW_POSITIVE_EGDE_DETECTIVE_SHIFT)

#define SW_EDGE_DETECTIVE_MASK (uint32_t)(SW_NEGATIVE_EGDE_DETECTIVE_MASK | SW_POSITIVE_EDGE_DETECTIVE_MASK )

#define SW_EDGE_COUNTER_CLEAR_BIT ((uint32_t)0x1)
#define SW_EDGE_COUNTER_CLEAR_SHIFT (25)
#define SW_EDGE_COUNTER_CLEAR_MASK (uint32_t)(SW_EDGE_COUNTER_CLEAR_BIT << SW_EDGE_COUNTER_CLEAR_SHIFT)

#define SW_EDGE_COUNTER_ENABLE_BIT ((uint32_t)0x1)
#define SW_EDGE_COUNTER_ENABLE_SHIFT (24)
#define SW_EDGE_COUNTER_ENABLE_MASK (uint32_t)(SW_EDGE_COUNTER_ENABLE_BIT << SW_EDGE_COUNTER_ENABLE_SHIFT)

#define SW_EDGE_COUNTER_VALUE_BIT ((uint32_t)0xffff)
#define SW_EDGE_COUNTER_VALUE_SHIFT (0)
#define SW_EDGE_COUNTER_VALUE_MASK (uint32_t)(SW_EDGE_COUNTER_VALUE_BIT << SW_EDGE_COUNTER_VALUE_SHIFT)

#define SW_CURRENT_LEVEL_BIT ((uint32_t)0x1)
#define SW_CURRENT_LEVEL_SHIFT (27)
#define SW_CURRENT_LEVEL_MASK (uint32_t)(SW_CURRENT_LEVEL_BIT << SW_CURRENT_LEVEL_SHIFT)

#define SW_INITALIZED_BIT ((uint32_t)0x1)
#define SW_INITALIZED_SHIFT (26)
#define SW_INITALIZED_MASK (uint32_t)(SW_INITALIZED_BIT << SW_INITALIZED_SHIFT)

#define SW_SENS_ENABLE_NEGATIVE_EDGE_BIT ((uint32_t)0x1)
#define SW_SENS_ENABLE_NEGATIVE_EDGE_SHIFT (28)
#define SW_SENS_ENABLE_NEGATIVE_EDGE_MASK (uint32_t)(SW_SENS_ENABLE_NEGATIVE_EDGE_BIT << SW_SENS_ENABLE_NEGATIVE_EDGE_SHIFT)

#define SW_SENS_ENABLE_POSITIVE_EDGE_BIT ((uint32_t)0x1)
#define SW_SENS_ENABLE_POSITIVE_EDGE_SHIFT (29)
#define SW_SENS_ENABLE_POSITIVE_EDGE_MASK (uint32_t)(SW_SENS_ENABLE_POSITIVE_EDGE_BIT << SW_SENS_ENABLE_POSITIVE_EDGE_SHIFT)

#define SW_SENS_ENABLE_EDGE_MASK (uint32_t)(SW_SENS_ENABLE_NEGATIVE_EDGE_MASK | SW_SENS_ENABLE_POSITIVE_EDGE_MASK)

#define SW_IF_IRQ_ENABLE_BIT ((uint32_t)0x1)
#define SW_IF_IRQ_ENABLE_SHIFT (30)
#define SW_IF_IRQ_ENABLE_MASK (uint32_t)(SW_IF_IRQ_ENABLE_BIT << SW_IF_IRQ_ENABLE_SHIFT)

#define SW_IF_MODULE_ENABLE_BIT ((uint32_t)0x1)
#define SW_IF_MODULE_ENABLE_SHIFT (31)
#define SW_IF_MODULE_ENABLE_MASK (uint32_t)(SW_IF_MODULE_ENABLE_BIT << SW_IF_MODULE_ENABLE_SHIFT)

#define SW_IF_MASK (uint32_t)( SW_IF_MODULE_ENABLE_MASK | SW_IF_IRQ_ENABLE_MASK | \
      SW_EDGE_SENS_MASK | SW_EDGE_DETECTIVE_MASK )



extern int mbmcs_std_2state_switch_init(mbmcs_std_2state_switch_t * const self_p, const uintptr_t base_addr)
    __attribute__ ((optimize(""O2"")));
extern void mbmcs_std_2state_switch_sens_negative_enable(const mbmcs_std_2state_switch_t * const self_p, const uint8_t is_on)
    __attribute__ ((optimize(""O2"")));
extern void mbmcs_std_2state_switch_sens_positive_enable(const mbmcs_std_2state_switch_t * const self_p, const uint8_t is_on)
    __attribute__ ((optimize(""O2"")));
extern void mbmcs_std_2state_switch_irq_enable(const mbmcs_std_2state_switch_t * const self_p, const uint8_t is_on)
    __attribute__ ((optimize(""O2"")));
extern int mbmcs_std_2state_switch_get_flags(const mbmcs_std_2state_switch_t * const self_p, mbmcs_std_2state_switch_status_t * const stat_p)
    __attribute__ ((optimize(""O2"")));
extern void mbmcs_std_2state_switch_clear_detective_egde_flags(const mbmcs_std_2state_switch_t * const self_p)
    __attribute__ ((optimize(""O2"")));
extern uint32_t _mbmcs_std_2state_switch_get_registers(const mbmcs_std_2state_switch_t * const self_p)
    __attribute__ ((optimize(""O2"")));
extern void mbmcs_std_2state_switch_edge_counter_enable(const mbmcs_std_2state_switch_t * const self_p, const uint8_t is_true)
    __attribute__ ((optimize(""O2"")));
extern void mbmcs_std_2state_switch_edge_counter_clear(const mbmcs_std_2state_switch_t * const self_p)
    __attribute__ ((optimize(""O2"")));
extern uint16_t mbmcs_std_2state_switch_get_edge_counter_value(const mbmcs_std_2state_switch_t * const self_p)
    __attribute__ ((optimize(""O2"")));
extern uint64_t mbmcs_std_2state_switch_get_monotonic_timer(const mbmcs_std_2state_switch_t * const self_p)
    __attribute__ ((optimize(""O2"")));




int mbmcs_std_2state_switch_init(mbmcs_std_2state_switch_t * const self_p, const uintptr_t base_addr)
{
    if((base_addr < MBMCS_EXTTEND_MODULE_MEMMAP_ADDR) ||  ( base_addr % MBMCS_MEMALIGN )) {
    return EINVAL;
    }
    self_p->base_addr = base_addr;

    {
        uint32_t reg32 = SW_IF_MODULE_ENABLE_MASK;
        SW_IF_OP_STAT_REG(self_p->base_addr) = reg32;
#define SW_CURRENT_LEVEL_MASK (uint32_t)(SW_CURRENT_LEVEL_BIT << SW_CURRENT_LEVEL_SHIFT)
    }
    for(;;) {
        uint32_t reg32;
    reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);
        if( reg32 & SW_INITALIZED_MASK) {
            mbmcs_std_2state_switch_edge_counter_clear(self_p);
            return 0;
    }
    } 

    return EPERM;
}

 
void mbmcs_std_2state_switch_sens_negative_enable(const mbmcs_std_2state_switch_t * const self_p, const uint8_t is_true)
{
    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);

    reg32 = (is_true) ? (uint32_t)(reg32 | SW_SENS_ENABLE_NEGATIVE_EDGE_MASK) : (uint32_t)( reg32 & ~SW_SENS_ENABLE_NEGATIVE_EDGE_MASK );

    SW_IF_OP_STAT_REG(self_p->base_addr) = reg32;

    return;
}

 
void mbmcs_std_2state_switch_sens_positive_enable(const mbmcs_std_2state_switch_t * const self_p, const uint8_t is_true)
{
    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);

    reg32 = (is_true) ? (uint32_t)(reg32 | SW_SENS_ENABLE_POSITIVE_EDGE_MASK) : (uint32_t)( reg32 & ~SW_SENS_ENABLE_POSITIVE_EDGE_MASK);

    SW_IF_OP_STAT_REG(self_p->base_addr) = reg32;

    return;
}


void mbmcs_std_2state_switch_irq_enable(const mbmcs_std_2state_switch_t * const self_p, const uint8_t is_true)
{
    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);

    reg32 = (is_true) ? (reg32 | SW_IF_IRQ_ENABLE_MASK) : ( reg32 & ~SW_IF_IRQ_ENABLE_MASK);

    SW_IF_OP_STAT_REG(self_p->base_addr) = reg32;

    return;
}


int mbmcs_std_2state_switch_get_flags(const mbmcs_std_2state_switch_t * const self_p, mbmcs_std_2state_switch_status_t * const stat_p)
{
    if( NULL == stat_p ) {
    return EINVAL;  
    } else {    
    mbmcs_std_2state_switch_status_t stat = { 0 };
    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);

    DBMS5(stderr, ""mbmcs_std_2state_switch_get_flags : reg32=%08x"" EOL_CRLF, reg32);
    
    
#if 0
    stat.f.current_signal = (reg32 & SW_CURRENT_LEVEL_MASK) ? ~0 : 0;
#else
    if(reg32 & SW_CURRENT_LEVEL_MASK) {
        stat.f.current_signal = ~0;
    } else {
        stat.f.current_signal = 0;
    }
#endif
#if 0
    stat.f.positive_edge  = (reg32 & SW_POSITIVE_EDGE_DETECTIVE_MASK) ? 0x1 : 0;
    stat.f.negative_edge  = (reg32 & SW_NEGATIVE_EGDE_DETECTIVE_MASK) ? 0x1 : 0;
#else
    if((reg32 & SW_POSITIVE_EDGE_DETECTIVE_MASK)!=0) {
        stat.f.positive_edge =~0;
    } else {
        stat.f.positive_edge = 0;
    }
    if((reg32 & SW_NEGATIVE_EGDE_DETECTIVE_MASK)!=0) {
        stat.f.negative_edge = ~0;
    } else {
        stat.f.negative_edge = 0;
    }
#endif
    DBMS3( stderr, ""stat.f.current_signal=%d"" EOL_CRLF, stat.f.current_signal);
    DBMS3( stderr, ""stat.f.positive_edge=%d"" EOL_CRLF, stat.f.positive_edge);
    DBMS3( stderr, ""stat.f.negative_edge=%d"" EOL_CRLF, stat.f.negative_edge);

    *stat_p = stat;
    }

    return 0;
}

 
void mbmcs_std_2state_switch_clear_detective_egde_flags(const mbmcs_std_2state_switch_t * const self_p)
{
    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);

    reg32 &= ~SW_EDGE_DETECTIVE_MASK;

    SW_IF_OP_STAT_REG(self_p->base_addr) = reg32;

    return;
}


uint32_t _mbmcs_std_2state_switch_get_registers(const mbmcs_std_2state_switch_t * const self_p)
{
    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);

    return reg32;
}


void _mbmcs_std_2state_switch_dump_registers(const mbmcs_std_2state_switch_t * const self_p)
{
    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);

    DMSG( stderr, ""module enable:%x"" EOL_CRLF, (reg32 & SW_IF_MODULE_ENABLE_MASK ? 0x1 : 0));
    DMSG( stderr, ""irq_enable: %x"" EOL_CRLF, (reg32 & SW_IF_IRQ_ENABLE_MASK ? 0x1 : 0));
    DMSG( stderr, ""detective positive edge:%x"" EOL_CRLF, (reg32 & SW_POSITIVE_EDGE_DETECTIVE_MASK ? 0x1 : 0));
    DMSG( stderr, ""detective negative edge:%x"" EOL_CRLF, (reg32 & SW_NEGATIVE_EGDE_DETECTIVE_MASK ? 0x1 : 0));
    DMSG( stderr, ""current level:%x"" EOL_CRLF, (reg32 & SW_NEGATIVE_EGDE_DETECTIVE_MASK ? 0x1 : 0));
    DMSG( stderr, ""sensitive positive edge enable:%x"" EOL_CRLF,
      (reg32 & SW_SENS_ENABLE_POSITIVE_EDGE_MASK) ? 0x1 : 0);
    DMSG( stderr, ""sensitive negative edge enable:%x"" EOL_CRLF,
      (reg32 & SW_SENS_ENABLE_NEGATIVE_EDGE_MASK) ? 0x1 : 0);
    DMSG( stderr, ""edge counter enable:%x"" EOL_CRLF,
      (reg32 & SW_EDGE_COUNTER_ENABLE_MASK) ? 0x1 : 0);
    DMSG( stderr, ""egde counter value:%04x"" EOL_CRLF,
        (reg32 & (SW_EDGE_COUNTER_VALUE_MASK >> SW_EDGE_COUNTER_VALUE_SHIFT)));

    return;
}

void mbmcs_std_2state_switch_edge_counter_enable(const mbmcs_std_2state_switch_t * const self_p, const uint8_t is_true) {
    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);

    reg32 = (is_true) ? (reg32 | SW_EDGE_COUNTER_ENABLE_MASK) : ( reg32 & ~SW_EDGE_COUNTER_ENABLE_MASK);

    SW_IF_OP_STAT_REG(self_p->base_addr) = reg32;

    return;
}

void mbmcs_std_2state_switch_edge_counter_clear(const mbmcs_std_2state_switch_t * const self_p)
{
    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);

    reg32 |=  SW_EDGE_COUNTER_CLEAR_MASK;

    SW_IF_OP_STAT_REG(self_p->base_addr) = reg32;

    return;
}

uint16_t mbmcs_std_2state_switch_get_edge_counter_value(const mbmcs_std_2state_switch_t * const self_p)
{
    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);

    reg32 >>= SW_EDGE_COUNTER_VALUE_SHIFT;

    return (reg32 & SW_EDGE_COUNTER_VALUE_BIT);
}

uint64_t mbmcs_std_2state_switch_get_monotonic_timer(const mbmcs_std_2state_switch_t * const self_p)
{
    const uint64_t lsb32 = SW_IF_MONOTONIC_TIMER64_LSB32_REG(self_p->base_addr);
    const uint64_t msb32 = SW_IF_MONOTONIC_TIMER64_MSB32_REG(self_p->base_addr);

    return ((msb32 << 32) | lsb32);
}
",52,1576,5230
"#include ""mddl_vsprintf.h""
#include ""mddl_printf.h""

static int (*_this_out_method_cb)(int) = NULL;

void mddl_printf_init( int (*putchar_cb)(int))
{
    _this_out_method_cb = putchar_cb;
}


int mddl_printf(const char *const fmt, ...)
{
    int retval;
    va_list ap;    

    if( _this_out_method_cb == NULL ) {
    return -1;
    }

    va_start(ap, fmt); 
    retval = mddl_vsprintf_putchar( _this_out_method_cb, fmt, ap);
    va_end(ap);

    return retval;
}


",52,1577,202
"#include ""mbmcs_STD_TIMER.h""
#include ""mbmcs_stdio.h""


#ifdef __GNUC__
__attribute__ ((unused))
#endif
#ifdef DEBUG
static int debuglevel = 4;
#else
static const int debuglevel = 0;
#endif

#include ""dbms.h""

#if defined(_MULTIOS_DMSG_IS_UART)
#define EOL_CRLF ""\n\r""
#else
#define EOL_CRLF ""\n""
#endif

#define STD_TIMER_OP_FORCE_CLEAR_BIT ((uint32_t)0x1)
#define STD_TIMER_OP_FORCE_CLEAR_SHIFT (31)
#define STD_TIMER_OP_FORCE_CLEAR_MASK (STD_TIMER_OP_FORCE_CLEAR_BIT << STD_TIMER_OP_FORCE_CLEAR_SHIFT)

#define STD_TIMER_OP_PAUSE_BIT ((uint32_t)0x1)
#define STD_TIMER_OP_PAUSE_SHIFT (30)
#define STD_TIMER_OP_PAUSE_MASK (STD_TIMER_OP_PAUSE_BIT << STD_TIMER_OP_PAUSE_SHIFT)

#define STD_TIMER_OP_COUNTER_LATCH_MASK_BIT ((uint32_t)0x1)
#define STD_TIMER_OP_COUNTER_LATCH_MASK_SHIFT (29)
#define STD_TIMER_OP_COUNTER_LATCH_MASK_MASK (STD_TIMER_OP_COUNTER_LATCH_MASK_BIT << STD_TIMER_OP_COUNTER_LATCH_MASK_SHIFT)

#define STD_TIMER_OP(a) *((volatile unsigned int*)((intptr_t)(a) + 0x0))
#define STD_TIMER_LSB(a) *((volatile unsigned int*)((intptr_t)(a) + 0x8))
#define STD_TIMER_MSB(a) *((volatile unsigned int*)((intptr_t)(a) + 0xc))


extern void mbmcs_std_timer_init(mbmcs_std_timer_t *const self_p, const uintptr_t base_addr)
    __attribute__ ((optimize(""Os"")));
extern uint64_t mbmcs_std_timer_get_timer_counter( mbmcs_std_timer_t *const self_p)
    __attribute__ ((optimize(""O2"")));
extern void mbmcs_std_timer_force_reset(mbmcs_std_timer_t *const self_p)
    __attribute__ ((optimize(""Os"")));
extern void mbmcs_std_timer_pause(mbmcs_std_timer_t *const self_p)
    __attribute__ ((optimize(""Os"")));
extern void mbmcs_std_timer_unpause(mbmcs_std_timer_t *const self_p)
    __attribute__ ((optimize(""Os"")));
extern int mbmcs_std_timer_set_timer_counter( mbmcs_std_timer_t *const self_p, const uint64_t msec64)
    __attribute__ ((optimize(""O2"")));
extern int mbmcs_std_timer_set_timer_counter_and_unpause( mbmcs_std_timer_t *const self_p, const uint64_t msec64)
    __attribute__ ((optimize(""Os"")));


void  mbmcs_std_timer_init(mbmcs_std_timer_t *const self_p, const uintptr_t base_addr)
{
    self_p->base_addr = base_addr;

    return;
}


uint64_t mbmcs_std_timer_get_timer_counter( mbmcs_std_timer_t *const self_p)
{
    volatile uint64_t retval64;
    volatile uint32_t reg32;
    reg32 = STD_TIMER_OP(self_p->base_addr);
    reg32 |= STD_TIMER_OP_COUNTER_LATCH_MASK_MASK;
    STD_TIMER_OP(self_p->base_addr) = reg32;

    retval64 = STD_TIMER_MSB(self_p->base_addr);
    
    retval64 <<= 32;
    retval64 |= STD_TIMER_LSB(self_p->base_addr);

    reg32 = STD_TIMER_OP(self_p->base_addr);
    reg32 &= ~STD_TIMER_OP_COUNTER_LATCH_MASK_MASK;
    STD_TIMER_OP(self_p->base_addr) = reg32;

    return retval64;
}


void mbmcs_std_timer_force_reset(mbmcs_std_timer_t *const self_p)
{
    uint32_t d32;

    d32 = STD_TIMER_OP(self_p->base_addr);
    d32 |= STD_TIMER_OP_FORCE_CLEAR_MASK;
    STD_TIMER_OP(self_p->base_addr) = d32;

    return;
}


void mbmcs_std_timer_pause(mbmcs_std_timer_t *const self_p)
{
    uint32_t d32;

    d32 = STD_TIMER_OP(self_p->base_addr);
    d32 |= STD_TIMER_OP_PAUSE_MASK;
    STD_TIMER_OP(self_p->base_addr) = d32;

    return;
}


void mbmcs_std_timer_unpause(mbmcs_std_timer_t *const self_p)
{
    uint32_t d32;

    d32 = STD_TIMER_OP(self_p->base_addr);
    d32 &= ~STD_TIMER_OP_PAUSE_MASK;
    STD_TIMER_OP(self_p->base_addr) = d32;

    return;
}


int mbmcs_std_timer_set_timer_counter( mbmcs_std_timer_t *const self_p, const uint64_t msec64)
{
    uint64_t d64 = msec64;

    STD_TIMER_LSB(self_p->base_addr) = (uint32_t)(0xffffffff & d64);
    d64 >>= 32; 
    STD_TIMER_MSB(self_p->base_addr) = (uint32_t)d64;

    
    d64 = STD_TIMER_MSB(self_p->base_addr);
    d64 <<= 32;
    d64 |= (uint64_t)STD_TIMER_LSB(self_p->base_addr);

    return (msec64 == d64) ? 0 : EPERM;

}


int mbmcs_std_timer_set_timer_counter_and_unpause( mbmcs_std_timer_t *const self_p, const uint64_t msec64)
{
    int result;

    result = mbmcs_std_timer_set_timer_counter( self_p, msec64);
    if(result) {
    return result;
    }

    mbmcs_std_timer_unpause(self_p);

    return 0;
}



",52,1578,2041
"#include ""multios_stdlib.h""


#include ""mbmcs_def.h""
#include ""mbmcs_stdio.h""
#include ""mbmcs_stdintrc.h""


#ifdef __GNUC__
__attribute__ ((unused))
#endif
#ifdef DEBUG
static int debuglevel = 4;
#else
static const int debuglevel = 0;
#endif
#include ""dbms.h""

#if defined(_MULTIOS_DMSG_IS_UART)
#define EOL_CRLF ""\n\r""
#else
#define EOL_CRLF ""\n""
#endif



#define MBMCS_STDINTRC_ENABLE_OUTPUT ((uint32_t)(0x1))
#define MBMCS_STDINTRC_IRQ_MASK ((uint32_t)(0xfffffffe))


extern int mbmcs_stdintrc_init(mbmcs_stdintrc_t *const, const uintptr_t)
    __attribute__ ((optimize(""Os"")));
extern int mbmcs_stdintrc_enable_output( const mbmcs_stdintrc_t *const, const uintptr_t)
    __attribute__ ((optimize(""O2"")));
extern int mbmcs_stdintrc_disable_output( const mbmcs_stdintrc_t *const, const uintptr_t)
    __attribute__ ((optimize(""O2"")));
extern int mbmcs_stdintrc_get_irq_flag( const mbmcs_stdintrc_t * const, const uintptr_t, uint32_t *const)
    __attribute__ ((optimize(""O2"")));
extern int mbmcs_stdintrc_clear_irq_flag( const mbmcs_stdintrc_t * const, const uintptr_t, const uint32_t)
    __attribute__ ((optimize(""O2"")));

#define INTR_REG(a, o) *((volatile unsigned int*)((intptr_t)(a) + (o)))


int mbmcs_stdintrc_init(mbmcs_stdintrc_t * const self_p, const uintptr_t base_addr)
{
    char str[MULTIOS_XTOA_HEX32_BUFSZ];

    DBMS5( stderr, ""%s : base_addr=0x%s"" EOL_CRLF, __func__, 
    multios_u32toahex( base_addr, str, MULTIOS_XTOA_HEX32_BUFSZ, NULL));
    DBMS5( stderr, ""%s : MBMCS_MEMALIGN=%d"" EOL_CRLF, __func__, MBMCS_MEMALIGN);
    DBMS5( stderr, ""%s : MBMCS_EXTTEND_MODULE_MEMMAP_ADDR=0x%s"" EOL_CRLF, __func__, 
    multios_u32toahex( MBMCS_EXTTEND_MODULE_MEMMAP_ADDR, str, MULTIOS_XTOA_HEX32_BUFSZ, NULL));

    if((base_addr < MBMCS_EXTTEND_MODULE_MEMMAP_ADDR) || ( base_addr & (MBMCS_MEMALIGN-1))) {
    return EINVAL;
    }

    self_p->base_addr = base_addr;

    return 0;
}


int mbmcs_stdintrc_enable_output( const mbmcs_stdintrc_t *const self_p, const uintptr_t addr_offs)
{
    const uint32_t reg32 =  (MBMCS_STDINTRC_ENABLE_OUTPUT | MBMCS_STDINTRC_IRQ_MASK);


    if( addr_offs & (MBMCS_MEMALIGN-1) ) {
    return EINVAL;
    }

    INTR_REG(self_p->base_addr, addr_offs) = reg32;

    return 0;
}


int mbmcs_stdintrc_disable_output( const mbmcs_stdintrc_t *const self_p, const uintptr_t addr_offs)
{
    if( addr_offs & (MBMCS_MEMALIGN-1) ) {
    return EINVAL;
    }

    INTR_REG(self_p->base_addr, addr_offs) = ~MBMCS_STDINTRC_ENABLE_OUTPUT;

    return 0;
}


int mbmcs_stdintrc_get_irq_flag( const mbmcs_stdintrc_t * const self_p, const uintptr_t addr_offs, uint32_t *const bitflags_p)
{
    if( ( addr_offs & (MBMCS_MEMALIGN-1)) || ( NULL == bitflags_p ) ) {
    return EINVAL;
    }

    *bitflags_p = INTR_REG(self_p->base_addr, addr_offs);

    return 0;
}


int mbmcs_stdintrc_clear_irq_flag( const mbmcs_stdintrc_t * const self_p, const uintptr_t addr_offs, const uint32_t clrbitflags)
{
    uint32_t reg32;
    uint32_t intr_enable;

    if( addr_offs & (MBMCS_MEMALIGN-1) ) {
    return EINVAL;
    }

    reg32 = INTR_REG(self_p->base_addr, addr_offs);
    intr_enable = reg32 & MBMCS_STDINTRC_ENABLE_OUTPUT;
    reg32 &=  ~clrbitflags | intr_enable;
    INTR_REG(self_p->base_addr, addr_offs) = reg32;

    IFDBG5THEN {
    DBMS5( stderr, ""%s : clrbitflags = 0x%08s"" EOL_CRLF, __FUNCTION__, clrbitflags);
    DBMS5( stderr, ""%s : setdata = 0x%08x"" EOL_CRLF, __FUNCTION__, reg32);
    }

    return 0;
}
",52,1579,1616
"#include ""mbmcs_stdio.h""
#include ""mbmcs_WATCHDOG_TIMER.h""



#ifdef __GNUC__
__attribute__ ((unused))
#endif
#ifdef DEBUG
static int debuglevel = 4;
#else
static const int debuglevel = 0;
#endif
#include ""dbms.h""

#if defined(_MULTIOS_DMSG_IS_UART)
#define EOL_CRLF ""\n\r""
#else
#define EOL_CRLF ""\n""
#endif



#define WDT_OP_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x0))
#define WDT_OUNTER_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x4))

#define MBMCS_EXTTEND_MODULE_MEMMAP_ADDR 0xC0000000
#define MBMCS_MEMALIGN 4


#define WDT_MODULE_ENABLE_BIT ((uint32_t)0x1)
#define WDT_MODULE_ENABLE_SHIFT (31)
#define WDT_MODULE_ENABLE_MASK \
    ( WDT_MODULE_ENABLE_BIT << WDT_MODULE_ENABLE_SHIFT)
#define WDT_IRQ_ENABLE_BIT ((uint32_t)0x1)
#define WDT_IRQ_ENABLE_SHIFT (30)
#define WDT_IRQ_ENABLE_MASK \
    ( WDT_IRQ_ENABLE_BIT << WDT_IRQ_ENABLE_SHIFT)
#define WDT_TIMEDOUT_BIT ((uint32_t)0x1)
#define WDT_TIMEDOUT_SHIFT (29)
#define WDT_TIMEDOUT_MASK \
    ( WDT_TIMEDOUT_BIT << WDT_TIMEDOUT_SHIFT)
#define WDT_TIMER_THRESHED_BIT   ((uint32_t)0xffff)
#define WDT_TIMER_THRESHED_SHIFT (0)
#define WDT_TIMER_THRESHED_MASK \
    ( WDT_TIMER_THRESHED_BIT << WDT_TIMER_THRESHED_SHIFT)
#define WDT_IRQ_TIMER_THRESH_BIT ((uint32_t)0xfff)
#define WDT_IRQ_TIMER_THRESH_SHIFT (16)
#define WDT_IRQ_TIMER_THRESH_MASK \
    ( WDT_IRQ_TIMER_THRESH_BIT << WDT_IRQ_TIMER_THRESH_SHIFT)
#define WDT_IRQ_TIMER_LSB_MASK ((uint32_t)0xf)
#define WDT_IRQ_TIMER_LSB_SHIFT (4)



extern int mbmcs_watchdog_timer_init(mbmcs_watchdog_timer_t *const, uintptr_t)
    __attribute__ ((optimize(""Os"")));
extern void mbmcs_watchdog_timer_set_thresh(mbmcs_watchdog_timer_t const *const, const uint16_t)
    __attribute__ ((optimize(""O2"")));
extern void mbmcs_watchdog_timer_set_irq_thresh(mbmcs_watchdog_timer_t const *const, uint16_t)
    __attribute__ ((optimize(""O2"")));
extern void mbmcs_watchdog_timer_enable(mbmcs_watchdog_timer_t const *const,bool)
    __attribute__ ((optimize(""O2"")));
extern void mbmcs_watchdog_timer_irq_enable(mbmcs_watchdog_timer_t const *const, bool)
    __attribute__ ((optimize(""O2"")));
extern void mbmcs_watchdog_timer_interval_reset(mbmcs_watchdog_timer_t const *const)
    __attribute__ ((optimize(""O2"")));
extern void _mbmcs_watchdog_timer_dump_ctrl_reg(mbmcs_watchdog_timer_t const *const)
    __attribute__ ((optimize(""O2"")));

int mbmcs_watchdog_timer_init(mbmcs_watchdog_timer_t *const self_p, uintptr_t base_addr)
{
    DBMS5(stderr, ""%s : execute"" EOL_CRLF, __FUNCTION__);

    if((base_addr < MBMCS_EXTTEND_MODULE_MEMMAP_ADDR) ||  ( base_addr % MBMCS_MEMALIGN )) {
    return EINVAL;
    }

    self_p->base_addr = base_addr;

    
    WDT_OP_REG(self_p->base_addr) = 0x0;

    
    while(WDT_TIMEDOUT_MASK & WDT_OP_REG(self_p->base_addr));

    return 0;
}

void mbmcs_watchdog_timer_set_thresh(mbmcs_watchdog_timer_t const *const self_p, const uint16_t thresh)
{
    uint32_t reg32 = WDT_OP_REG(self_p->base_addr);

    reg32 &= ~WDT_TIMER_THRESHED_MASK;
    reg32 |= (WDT_TIMER_THRESHED_BIT & thresh);

    WDT_OP_REG(self_p->base_addr) = reg32;

    return;
}

void mbmcs_watchdog_timer_set_irq_thresh(mbmcs_watchdog_timer_t const *const self_p, uint16_t thresh)
{
    uint32_t reg32 = WDT_OP_REG(self_p->base_addr);
    const uint32_t irq_thresh =  (WDT_IRQ_TIMER_THRESH_BIT & ((uint32_t)thresh >> WDT_IRQ_TIMER_LSB_SHIFT));

    reg32 &= ~WDT_IRQ_TIMER_THRESH_MASK;
    reg32 |= (irq_thresh << WDT_IRQ_TIMER_THRESH_SHIFT);

    WDT_OP_REG(self_p->base_addr) = reg32;

    return;
}

void mbmcs_watchdog_timer_enable(mbmcs_watchdog_timer_t const *const self_p, const bool is_true)
{
    uint32_t reg32 = WDT_OP_REG(self_p->base_addr);

    reg32 &= ~WDT_MODULE_ENABLE_MASK;
    if(is_true==true) {
    reg32 |= WDT_MODULE_ENABLE_MASK;
    }

    WDT_OP_REG(self_p->base_addr) = reg32;

    return;
}

void mbmcs_watchdog_timer_irq_enable(mbmcs_watchdog_timer_t const *const self_p, const bool is_true)
{
    uint32_t reg32 = WDT_OP_REG(self_p->base_addr);

    reg32 &= ~WDT_IRQ_ENABLE_MASK;
    if(is_true==true) {
    reg32 |= WDT_IRQ_ENABLE_MASK;
    } 
    WDT_OP_REG(self_p->base_addr) = reg32;

    return;
}

void mbmcs_watchdog_timer_interval_reset(mbmcs_watchdog_timer_t const *const self_p)
{
    WDT_OUNTER_REG(self_p->base_addr) = 0;

    return;
}

void _mbmcs_watchdog_timer_dump_ctrl_reg(mbmcs_watchdog_timer_t const *const self_p)
{
    uint32_t reg32 = WDT_OP_REG(self_p->base_addr);

    xil_printf(""watchdog 0x%08x : 0x%08x"" EOL_CRLF, self_p->base_addr, reg32);
}
",52,1580,2158
"#include ""mbmcs_stdio.h""


#ifdef __GNUC__
__attribute__ ((unused))
#endif
#ifdef DEBUG
static int debuglevel = 4;
#else
static const int debuglevel = 0;
#endif

#include ""dbms.h""

#if defined(_MULTIOS_DMSG_IS_UART)
#define EOL_CRLF ""\n\r""
#else
#define EOL_CRLF ""\n""
#endif

#define MBMCS_EXTTEND_MODULE_MEMMAP_ADDR 0xC0000000
#define MBMCS_MEMALIGN 4



#include ""mbmcs_ALPSEC12_ROTARYENCODER.h""

#define ENCODER_CTRL_REG(a) *((volatile uint32_t*)((uintptr_t)(a) + 0x0))

#define ENCODER_RIGHT_SHIFT (0)
#define ENCODER_RIGHT_MASK (((uint32_t)0xff) << ENCODER_RIGHT_SHIFT)
#define ENCODER_LEFT_SHIFT (8)
#define ENCODER_LEFT_MASK (((uint32_t)0xff) << ENCODER_LEFT_SHIFT)
#define ENCODER_FUNCTION_ENABLE ((uint32_t)(0x1) << 31)
#define ENCODER_FUNCTION_IRQ_OUTPUT ((uint32_t)(0x1) << 30)


extern int mbmcs_alpsec12_rotaryencoder_init(mbmcs_alpsec12_rotaryencoder_t *const, const uintptr_t)
    __attribute__ ((optimize(""Os"")));
extern void mbmcs_alpsec12_rotaryencoder_get_count(const mbmcs_alpsec12_rotaryencoder_t *const, uint8_t *const, uint8_t *const)
    __attribute__ ((optimize(""O2"")));
extern void mbmcs_alpsec12_rotaryencoder_set_module_enable(const mbmcs_alpsec12_rotaryencoder_t *const, const uint8_t)
    __attribute__ ((optimize(""O2"")));
extern void mbmcs_alpsec12_rotaryencoder_set_module_irq_enable(const mbmcs_alpsec12_rotaryencoder_t *const, const uint8_t)
    __attribute__ ((optimize(""O2"")));
extern void mbmcs_alpsec12_rotaryencoder_clear_counter(const mbmcs_alpsec12_rotaryencoder_t *)
    __attribute__ ((optimize(""O2"")));


int mbmcs_alpsec12_rotaryencoder_init(mbmcs_alpsec12_rotaryencoder_t *const self_p, const uintptr_t base_addr)
{
    if((base_addr < MBMCS_EXTTEND_MODULE_MEMMAP_ADDR) ||  ( base_addr % MBMCS_MEMALIGN )) {
    return EINVAL;
    }
    self_p->base_addr = base_addr;
 
    return 0;
}


void mbmcs_alpsec12_rotaryencoder_get_count(const mbmcs_alpsec12_rotaryencoder_t *const self_p, uint8_t *const left_p, uint8_t *const right_p)
{
    const uint32_t reg = ENCODER_CTRL_REG(self_p->base_addr);

    if(0) {
    volatile uint8_t left = (uint8_t)(( ENCODER_LEFT_MASK & reg ) >> ENCODER_LEFT_SHIFT);
    volatile uint8_t right= (uint8_t)(( ENCODER_RIGHT_MASK & reg ) >> ENCODER_RIGHT_SHIFT);
    
    
    mbmcs_printf(""ENCODER reg = 0x%08x"" EOL_CRLF, reg);
    mbmcs_printf(""ENCODER_LEFT_MASK=0x%08x ENCODER_LEFT_SHIFT=0x%08x"" EOL_CRLF,
            ENCODER_LEFT_MASK, ENCODER_LEFT_SHIFT);
    mbmcs_printf(""left=%08x right=%02x"" EOL_CRLF, left, right);
    }

    if( NULL != left_p ) {
     *left_p = 0xff & (uint8_t)(( ENCODER_LEFT_MASK & reg ) >> ENCODER_LEFT_SHIFT);
    
    }

    if( NULL != right_p ) {
    *right_p = 0xff & (uint8_t)(( ENCODER_RIGHT_MASK & reg ) >> ENCODER_RIGHT_SHIFT);
    
    }

    return;
}


void mbmcs_alpsec12_rotaryencoder_set_module_enable(const mbmcs_alpsec12_rotaryencoder_t *const self_p, const uint8_t is_on)
{
    uint32_t reg = ENCODER_CTRL_REG(self_p->base_addr);

    if(is_on) {
    reg |= ENCODER_FUNCTION_ENABLE;
    } else {
    reg &= ~ENCODER_FUNCTION_ENABLE;
    }

    reg &= ~( ENCODER_LEFT_MASK | ENCODER_RIGHT_MASK );

    ENCODER_CTRL_REG(self_p->base_addr) = reg;

    return;
}


void mbmcs_alpsec12_rotaryencoder_set_module_irq_enable(const mbmcs_alpsec12_rotaryencoder_t *const self_p, const uint8_t is_on)
{
    uint32_t reg = ENCODER_CTRL_REG(self_p->base_addr);

    if(is_on) {
    reg |= ENCODER_FUNCTION_IRQ_OUTPUT;
    } else {
    reg &= ~ENCODER_FUNCTION_IRQ_OUTPUT;
    }

    ENCODER_CTRL_REG(self_p->base_addr) = reg;

    return;
}


void mbmcs_alpsec12_rotaryencoder_clear_counter(const mbmcs_alpsec12_rotaryencoder_t *const self_p)
{
    uint32_t reg = ENCODER_CTRL_REG(self_p->base_addr);

    reg &= ~( ENCODER_LEFT_MASK | ENCODER_RIGHT_MASK );

    ENCODER_CTRL_REG(self_p->base_addr) = reg;

    return;
}
",52,1581,1780
"#include ""libmbmcs_libmultios_bridge.h""


#include ""mbmcs_platform.h""
#include ""mbmcs_unistd.h""
#include ""mbmcs_time.h""


#ifdef __GNUC__
__attribute__ ((unused))
#endif
#ifdef DEBUG
static int debuglevel = 1;
#else
static const int debuglevel = 0;
#endif
#include ""dbms.h""

#if defined(_MULTIOS_DMSG_IS_UART)
#define EOL_CRLF ""\n\r""
#else
#define EOL_CRLF ""\n""
#endif


#if defined(__GNUC__)

extern void mbmcs_msleep( const unsigned int)
    __attribute__ ((optimize(""Os"")));
extern unsigned int mbmcs_sleep( const unsigned int)
    __attribute__ ((optimize(""Os"")));
extern int mbmcs_clock_gettime_clock_monotonic(mbmcs_timespec_t *const)
    __attribute__ ((optimize(""Os"")));

#endif 


void mbmcs_msleep( const unsigned int milisec )
{
#ifndef MBMCS_ENABLE_FIT1_JIFFIES_COUNTER
    DMSG(stderr,""mbmcs_msleep : FIT1_JIFFIES_COUNTER function is not enabled"" EOL_CRLF);
    abort();
#else
    const uint64_t mbmcs_jiffies = *mbmcs_jiffies_p;
    uint64_t endtime = mbmcs_jiffies + milisec;

    while ( endtime > *mbmcs_jiffies_p );

    return;
#endif
}


unsigned int mbmcs_sleep( const unsigned int seconds)
{
#ifndef MBMCS_ENABLE_FIT1_JIFFIES_COUNTER
    DMSG(stderr,""mbmcs_sleep : FIT1_JIFFIES_COUNTER function is not enabled"" EOL_CRLF);
    abort();
#else

    const uint64_t mbmcs_jiffies = *mbmcs_jiffies_p;
    uint64_t endtime = mbmcs_jiffies + ((uint64_t)seconds * 1000);

    while ( endtime > *mbmcs_jiffies_p );

    return 0;
#endif
}


int mbmcs_clock_gettime_clock_monotonic(mbmcs_timespec_t * const mts_p)
{
#ifndef MBMCS_ENABLE_FIT1_JIFFIES_COUNTER
    DBMS1(stderr,""mbmcs_clock_gettime_clock_monotonic : FIT1_JIFFIES_COUNTER function is not enabled"" EOL_CRLF);
    return EINVAL;
#else
    const uint64_t mbmcs_jiffies = *mbmcs_jiffies_p;
    mbmcs_timespec_t ts;

    if( NULL == mts_p ) {
    return  EFAULT;
    }

    ts.tv_sec = mbmcs_jiffies / HZ;
    ts.tv_nsec = (mbmcs_jiffies % HZ) * 1000 * 1000;

    *mts_p = ts;

    return 0;
#endif
}



",52,1582,892
"#include ""mbmcs_stdio.h""
#include ""mbmcs_YSM-430AXXA_35_7SEGLED.h""


#ifdef __GNUC__
__attribute__ ((unused))
#endif
#ifdef DEBUG
static int debuglevel = 4;
#else
static const int debuglevel = 0;
#endif

#include ""dbms.h""

#if defined(_MULTIOS_DMSG_IS_UART)
#define EOL_CRLF ""\n\r""
#else
#define EOL_CRLF ""\n""
#endif

#define MBMCS_EXTTEND_MODULE_MEMMAP_ADDR (0xC0000000)
#define MBMCS_MEMALIGN (4)


#define SEGLED_OP_AND_HEX_REG(a) *((volatile uint32_t*)((uintptr_t)(a) + 0x0))
#define SEGLED_ASCII_REG(a) *((volatile uint32_t*)((uintptr_t)(a) + 0x4))

#define SEG7X4DIGIT_MASK (0x0000ffff)
#define SEG7X4DOT_SHIFT  (16)
#define SEG7X4DOT_MASK   (((uint32_t)0xf) << SEG7X4DOT_SHIFT)
#define SEG7X4COLON_SHIFT (20)
#define SEG7X4COLON_MASK (((uint32_t)0x1) << SEG7X4COLON_SHIFT)
#define SEG7X4APOS_SHIFT (21)
#define SEG7X4APOS_MASK  (((uint32_t)0x1) << SEG7X4APOS_SHIFT)
#define SEG7X4TEST_SHIFT (30)
#define SEG7X4TEST_MASK  (((uint32_t)0x1) << SEG7X4TEST_SHIFT )
#define SEG7X4OFF_SHIFT (31)
#define SEG7X4OFF_MASK   (((uint32_t)0x1) << SEG7X4OFF_SHIFT )
#define SEG7X4SELASCII_SHIFT (29)
#define SEG7X4SELASCII_MASK (((uint32_t)0x1) << SEG7X4SELASCII_SHIFT )
#define SEG7X4ASCII_MASK (0xffffffff)


extern int mbmcs_ysm_430axxa_35_7seg4led_init(mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uintptr_t base_addr)
    __attribute__ ((optimize(""Os"")));
extern void mbmcs_ysm_430axxa_35_7seg4led_write_hex_digit(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint16_t data16)
    __attribute__ ((optimize(""O2"")));
extern void mbmcs_ysm_430axxa_35_7seg4led_write_dot(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t dots_bit)
    __attribute__ ((optimize(""O2"")));
extern void mbmcs_ysm_430axxa_35_7segled_write_colon(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)
    __attribute__ ((optimize(""O2"")));
extern void mbmcs_ysm_430axxa_35_7seg4led_write_apos(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)
    __attribute__ ((optimize(""O2"")));
extern int mbmcs_ysm_430axxa_35_7seg4led_test(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)
    __attribute__ ((optimize(""O2"")));
extern int mbmcs_ysm_430axxa_35_7seg4led_on(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)
    __attribute__ ((optimize(""O2"")));
extern void mbmcs_ysm_430axxa_35_7seg4led_ascii_mode(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)
    __attribute__ ((optimize(""O2"")));
extern int mbmcs_ysm_430axxa_35_7seg4led_write_ascii_digit(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const char * const str)
    __attribute__ ((optimize(""O2"")));
extern int mbmcs_ysm_430axxa_35_7seg4led_destroy(mbmcs_ysm_430axxa_35_7seg4led_t *const self_p)
    __attribute__ ((optimize(""O2"")));




int mbmcs_ysm_430axxa_35_7seg4led_init(mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uintptr_t base_addr)
{
    if((base_addr < MBMCS_EXTTEND_MODULE_MEMMAP_ADDR) ||  ( base_addr % MBMCS_MEMALIGN )) {
    return EINVAL;
    }
    self_p->base_addr = base_addr;
 
     return 0;
}


void mbmcs_ysm_430axxa_35_7seg4led_write_hex_digit(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint16_t data16)
{
    uint32_t reg32 = SEGLED_OP_AND_HEX_REG(self_p->base_addr);
    
    reg32 &= ~SEG7X4DIGIT_MASK;
    reg32 |= SEG7X4DIGIT_MASK & data16;

    SEGLED_OP_AND_HEX_REG(self_p->base_addr) = reg32;

    return ;
}


void mbmcs_ysm_430axxa_35_7seg4led_write_dot(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t dots_bit)
{
    uint32_t reg32 = SEGLED_OP_AND_HEX_REG(self_p->base_addr);
    
    reg32 &= ~SEG7X4DOT_MASK;
    reg32 |= (SEG7X4DOT_MASK & ((uint32_t)(dots_bit) << SEG7X4DOT_SHIFT));

    SEGLED_OP_AND_HEX_REG(self_p->base_addr) = reg32;

    return;
}


void mbmcs_ysm_430axxa_35_7segled_write_colon(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)
{
    uint32_t reg32 = SEGLED_OP_AND_HEX_REG(self_p->base_addr);
    
    reg32 &= ~SEG7X4COLON_MASK;
    reg32 |= (is_on) ? SEG7X4COLON_MASK : 0x0;

    SEGLED_OP_AND_HEX_REG(self_p->base_addr) = reg32;

    return;
}


void mbmcs_ysm_430axxa_35_7seg4led_write_apos(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)
{
    uint32_t reg32 = SEGLED_OP_AND_HEX_REG(self_p->base_addr);
    
    reg32 &= ~SEG7X4APOS_MASK;
    reg32 |= (is_on) ? SEG7X4APOS_MASK : 0x0;

    SEGLED_OP_AND_HEX_REG(self_p->base_addr) = reg32;

    return;
}


int mbmcs_ysm_430axxa_35_7seg4led_test(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)
{
    uint32_t reg32 = SEGLED_OP_AND_HEX_REG(self_p->base_addr);
    
    reg32 &= ~SEG7X4TEST_MASK;
    reg32 |= (is_on) ? SEG7X4TEST_MASK : 0x0;

    SEGLED_OP_AND_HEX_REG(self_p->base_addr) = reg32;

    return 0;
}


int mbmcs_ysm_430axxa_35_7seg4led_on(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)
{
    uint32_t reg32 = SEGLED_OP_AND_HEX_REG(self_p->base_addr);
    
    reg32 &= ~SEG7X4OFF_MASK;
    reg32 |= (is_on) ? 0x0 : SEG7X4OFF_MASK;

    SEGLED_OP_AND_HEX_REG(self_p->base_addr) = reg32;

    return 0;
}


void mbmcs_ysm_430axxa_35_7seg4led_ascii_mode(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)
{
    uint32_t reg32 = SEGLED_OP_AND_HEX_REG(self_p->base_addr);
    
    reg32 &= ~SEG7X4SELASCII_MASK;
    reg32 |= (is_on) ? SEG7X4SELASCII_MASK : 0x0;
    DBMS3( stderr, ""ASCII_MODE=0x%08x"" EOL_CRLF, reg32);

    SEGLED_OP_AND_HEX_REG(self_p->base_addr) = reg32;

    return;
}


int mbmcs_ysm_430axxa_35_7seg4led_write_ascii_digit(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const char * const str)
{
    uint32_t reg32 = 0;
    const size_t length = strlen(str);
    size_t n;

    if( !(length <= 4) ) {
    return EINVAL;
    }

    for( n=0; n<length; ++n) {
        reg32 <<= 8;
    reg32 |= 0xff & str[n];
    }

    SEGLED_ASCII_REG(self_p->base_addr) = reg32;

    return 0;
}


int mbmcs_ysm_430axxa_35_7seg4led_destroy(mbmcs_ysm_430axxa_35_7seg4led_t *const self_p)
{
    (void)self_p;

    return 0;
}

",52,1583,3232
"typedef struct
{
    short int vert,horiz;
}offsets;
offsets move[4];

typedef struct
{
    short int row,col;
}element;
element position;

element queue[1000];
int rear = -1;
int front = -1;
void queueFull(){
    fprintf(stderr, ""queue is full"");
    exit(EXIT_FAILURE);
}
void addq(element item){
    if(rear==100000-1){
        queueFull();
    }
    queue[++rear] = item;
}
element deleteq(){
    if(front==rear){
        fprintf(stderr, ""queue is empty"");
    }
    return queue[++front];
}
int bfs(char *maze,int *d,int n)
{
    printf(""haha\n"");
    int row,col,nr,nc,i,j;
    for(i=0;i<n;i++)
    {
        for(j=0;j<n;j++)
        {
            d[i*n+j]=401;
            if(maze[i*n+j]=='F')
            {
                d[i*n+j] = 0;
            }
        }
    }

    while(front!=rear){
        printf(""haha\n"");
        for(i=0;i<n;i++)
        {
            for(j=0;j<n;j++)
            {

                printf(""%3d "", d[i*n+j]);
            }
            printf(""\n"");
        }
        printf(""\n"");
        position = deleteq();
        row=position.row;
        col=position.col;
        if(maze[row*n+col] == 'F')
            return 1;
        for(i=0;i<4;i++)
        {
            nr=row+move[i].vert;
            nc=col+move[i].horiz;
            if(maze[nr*n+nc] != 'X' && d[nr*n+nc] > d[row*n+col]+1)
            {
                d[nr*n+nc]=  d[row*n+col]+1;
                position.row = nr;
                position.col = nc;
                addq(position);
            }
        }
    }

    return 0;
}



FILE *p1;

int main() {
    char a[1000]={};
    int x=0,i,j=1,n=0,row=0,col=0;
    char maze[n+2][n+2],mark[n+2][n+2];
    int num_maze[n+2][n+2];
    p1=fopen(""test.txt"",""r"");
    if(p1==NULL)
    {
        printf(""p1 error"");
    }
        fscanf(p1,""%d\n"",&n);
    printf(""n:%d\n"",n);
    for(i=0; i<n*n ;i++)
    {
        a[i]=fgetc(p1);
        printf(""%c "", a[i]);
        fgetc(p1);
        if(i%n==n-1){
            fgetc(p1);
            printf(""\n"");
        }

    }
    printf(""----------------\n"");
    for(i=0;i<n;i++)
    {
        for(j=0;j<n;j++)
        {

            printf(""%c "", a[i*n+j]);
        }
        printf(""\n"");
    }
    printf(""\n"");
    printf(""----------------\n"");
    char ans[n+2][n+2];
    for(i =0;i<n+2;i++)
    {
        for( j=0;j<n+2;j++)
        {
            if(i == 0  || i == n+1 || j == 0  || j == n+1 )
            {
                mark[i][j] = 'X';
                maze[i][j] = 'X';
            }
            else
            {
                mark[i][j] = a[x];
                maze[i][j] = a[x];
                x++;
                
                
                
            }
            
            
            
            
            printf(""%c "", maze[i][j]);
            ans[i][j]=maze[i][j];
        }
        
        printf(""\n"");
    }
    
    printf(""\n"");
    for(i=0;i<n+2;i++)
    {
        for(j=0;j<n+2;j++)
        {

            printf(""%c "", ans[i][j]);
        }
        printf(""\n"");
    }
    printf(""\n"");
    for(i=0; i<n+2 ;i++)
    {
        for( j=0;j<n+2;j++)
        {
            if(mark[i][j]== 'S')
            {

                mark[i][j] = '*';
                maze[i][j] = '*';
                position.row = i;
                position.col = j;
                row = position.row;
                col = position.col;
                addq(position);
                printf(""rear %d "",rear);
            }
        }
    }


    if(bfs(&maze[0][0],&num_maze[0][0],n+2)==1){
        for(i=0;i<n+2;i++)
        {
            for(j=0;j<n+2;j++)
            {

                printf(""%3d "", num_maze[i][j]);
            }
            printf(""\n"");
        }
    }
    else{
        printf(""not exit"");
    }








    return 0;
}
",53,1584,1486
"#define MALLOC(p,s)\
    if(!((p)=malloc(s))){\
        fprintf(stderr,""Insufficient memory"");\
        exit(EXIT_FAILURE);\
    }
typedef struct howto{
    int toplat;
    int tostat;
}howto;

int min;
howto fewstep(int now,int target,int* plat){
    min=-1;
    int i;
    howto ans;
    int sum;
    int toplat,tostat;
    int right,left;
    int pr,pl;
    for(i=0;i<20;i++){
        if(i-now<0){
            pr=i+1+19-now;
        }
        else{
            pr=i-now;
        }
        if(now-i<0){
            pl=i+1+19-now;
        }
        else{
            pl=now-i;
        }
        toplat= (pr<pl)? pr:-pl;
        if(target-plat[i]<0){
            right = (90-plat[i])+1+target-64;
        }
        else{
            right=target-plat[i];
        }
        if(plat[i]-target<0){
            left = plat[i]-64+1+90-target;
        }
        else{
            left=plat[i]-target;
        }
        tostat= (right<left)? right:-left;
        sum=abs(tostat)+abs(toplat);
        if(min==-1 || sum<min){
            min=sum;
            ans.toplat=toplat;
            ans.tostat=tostat;
        }
    }
    return ans;
}

typedef struct howto2{
    int toplat;
    int tostat;
    int toplat2;
    int tostat2;

}howto2;
howto2 fewstep2(int now,int target,int target2,int* plat){
    min=-1;
    int i,j;
    howto2 ans;
    int sum;
    int toplat,tostat;
    int right,left;
    int pr,pl;
    int sum2;
    int toplat2,tostat2;
    int right2,left2;
    int pr2,pl2;
    int temp;
    for(i=0;i<20;i++){
        if(i-now<0){
            pr=i+1+19-now;
        }
        else{
            pr=i-now;
        }
        if(now-i<0){
            pl=i+1+19-now;
        }
        else{
            pl=now-i;
        }
        toplat= (pr<pl)? pr:-pl;
        
        if(target-plat[i]<0){
            right = (90-plat[i])+1+target-64;
        }
        else{
            right=target-plat[i];
        }
        if(plat[i]-target<0){
            left = plat[i]-64+1+90-target;
        }
        else{
            left=plat[i]-target;
        }
        tostat= (right<left)? right:-left;
        
        sum=abs(tostat)+abs(toplat);
        
        temp=plat[i];
        plat[i]=target;
        

        for(j=0;j<20;j++){

            
            if(j-i<0){
                pr2=j+1+19-i;
            }
            else{
                pr2=j-i;
            }
            
            if(i-j<0){
                pl2=j+1+19-i;
            }
            else{
                pl2=i-j;
            }
            
            toplat2= (pr2<pl2)? pr2:-pl2;
            
            if(target2-plat[j]<0){
                right2 = (90-plat[j])+1+target2-64;
            }
            else{
                right2=target2-plat[j];
            }
            if(plat[j]-target2<0){
                left2 = plat[j]-64+1+90-target2;
            }
            else{

                left2=plat[j]-target2;
            }
            

            tostat2= (right2<left2)? right2:-left2;
            
            sum2=abs(tostat2)+abs(toplat2);
            
            
            if(min==-1 || sum+sum2<min){
                min=sum+sum2;
                ans.toplat=toplat;
                ans.tostat=tostat;
                ans.toplat2=toplat2;
                ans.tostat2=tostat2;
            }

        }
        plat[i]=temp;
    }
    return ans;
}
int main(){
    int i;
    int *plat=malloc(20*sizeof(int));
    int *plat2=malloc(20*sizeof(int));
    for(i=0;i<20;i++){
        plat[i]=64;
        plat2[i]=plat[i];
    }
    FILE* rptr;
    FILE* wfile;
    rptr=fopen(""test2-2.txt"",""r"");
    wfile=fopen(""output2-2.txt"",""w"");
    if(rptr==NULL || wfile==NULL){
        printf(""open failure\n"");
        return 1;
    }
    else{
        min = -1;
        int now=0;
        int now2=0;
        char target;
        char lasttarget;
        howto ans;
        howto2 ans2;
        int i;
        int count=1;
        char *command;
        char *command2;
        MALLOC(command,10000*sizeof(char));
        MALLOC(command2,10000*sizeof(char));
        target=fgetc(rptr);
        int totalstep=0;
        int totalstep2=0;
        int j1=0,j2=0;
        while(target!='\n' && target!=EOF){
            if(target==' '){
                target='@';
                
            }
            ans=fewstep(now,target,plat);
            now+=ans.toplat;
            plat[now]=target;
            for(i=0;i<abs(ans.toplat);i++){
                if(ans.toplat>0){
                    
                    command[j1++]='>';
                }
                else{
                    
                    command[j1++]='<';
                }
                totalstep++;
            }
            for(i=0;i<abs(ans.tostat);i++){
                if(ans.tostat>0){
                    
                    command[j1++]='+';
                }
                else{
                    
                    command[j1++]='-';
                }
                totalstep++;
            }
            
            command[j1++]='.';
            totalstep++;
            
            if(count==1){
                lasttarget=target;
                count++;
            }
            else if(count==2){
                count=1;
                ans2=fewstep2(now2,lasttarget,target,plat2);
                now2+=ans2.toplat;
                plat2[now2]=lasttarget;
                for(i=0;i<abs(ans2.toplat);i++){
                    if(ans2.toplat>0){
                        
                        command2[j2++]='>';
                    }
                    else{
                        
                        command2[j2++]='<';
                    }
                    totalstep2++;
                }
                for(i=0;i<abs(ans2.tostat);i++){
                    if(ans2.tostat>0){
                        
                        command2[j2++]='+';
                    }
                    else{
                        
                        command2[j2++]='-';
                    }
                    totalstep2++;
                }
                
                
                command2[j2++]='.';
                totalstep2++;
                now2+=ans2.toplat2;
                plat2[now2]=target;
                for(i=0;i<abs(ans2.toplat2);i++){
                    if(ans2.toplat2>0){
                        
                        command2[j2++]='>';
                    }
                    else{
                        
                        command2[j2++]='<';
                    }
                    totalstep2++;
                }
                for(i=0;i<abs(ans2.tostat2);i++){
                    if(ans2.tostat2>0){
                        
                        command2[j2++]='+';
                    }
                    else{
                        
                        command2[j2++]='-';
                    }
                    totalstep2++;
                }
                
                command2[j2++]='.';
                totalstep2++;
                
                
            }

            target=fgetc(rptr);
        }
        if(count==2){
            
            ans=fewstep(now2,target,plat2);
            now2+=ans.toplat;
            plat2[now2]=target;
            for(i=0;i<abs(ans.toplat);i++){
                if(ans.toplat>0){
                    
                    command2[j2++]='>';
                }
                else{
                    
                    command2[j2++]='<';
                }
                totalstep2++;
            }
            for(i=0;i<abs(ans.tostat);i++){
                if(ans.tostat>0){
                    
                    command2[j2++]='+';
                }
                else{
                    
                    command2[j2++]='-';
                }
                totalstep2++;
            }
            
            command2[j2++]='.';
            totalstep2++;
        }
        printf(""\ntotalstep1 %d \n"",totalstep );
        if(totalstep<=totalstep2){
            for(i=0;i<j1;i++){
                printf(""%c"",command[i]);
                fprintf(wfile,""%c"",command[i]);
            }
            
            fprintf(wfile,""\ntotalstep :%d\n"",totalstep );
        }
        else{
            for(i=0;i<j2;i++){
                printf(""%c"",command2[i]);
                fprintf(wfile,""%c"",command2[i]);
            }
            
            fprintf(wfile,""\ntotalstep :%d\n"",totalstep );
        }
    }
    fclose(rptr);
    fclose(wfile);
}
",53,1585,2775
"#define MAXLEN 14
#define MALLOC(p,s)\
    if(!((p)=malloc(s))){\
        fprintf(stderr,""Insufficient memory"");\
        exit(EXIT_FAILURE);\
    }
char* make1darr(int n){
    char *x;
    MALLOC(x,n*sizeof(*x));
    return x;
}
char*** make3darr(int rows, int cols,int hei){
    char ***x;
    MALLOC(x,rows*sizeof(**x));
    int i,j;
    for(i=0;i<rows;i++){
        MALLOC(x[i],cols*sizeof(**x));
        for(j=0;j<hei;j++){
            MALLOC(x[i][j],hei*sizeof(***x));
        }
    }
    return x;
}
int main(){
    FILE *ans;
    FILE *myans;
    char name[50];
    ans=fopen(""output_20201011.txt"",""r"");
    myans=fopen(""4108056029output.txt"",""r"");

    if(NULL==ans || NULL == myans){
        printf(""Open failure\n"");
        if(NULL == myans){
            printf(""my ans Open failure\n"");
        }
        if(NULL == ans){
            printf(""ans Open failure\n"");
        }
        return 1;
    }

    else{
        int nans,nmy,i;
        int ansmin,ansLimit,anspathnum;
        int min,Limit,pathnum;
        for(i=0;i<100;i++){
            fscanf(ans,""test %d starts now."",&nans);
            
            char y=fgetc(ans);
            
            fscanf(ans,""Shortest path: %d, Limit: %d, The number of different paths: %d"",&ansmin,&ansLimit,&anspathnum);
            
            y=fgetc(ans);
            
            y=fgetc(ans);
            

            fscanf(myans,""test %d starts now."",&nmy);
            

            char x =fgetc(myans);
            
            fscanf(myans,""Shortest path: %d, Limit: %d, The number of different paths: %d"",&min,&Limit,&pathnum);
            
            x=fgetc(myans);
            
            x=fgetc(myans);
            
            if(min!=ansmin){
                printf(""Shortest path error in test%d\n"",nmy);
                printf(""ans's min : %d   my min : %d\n\n"",ansmin,min );
            }
            if(pathnum!=anspathnum){
                printf(""pathnum error in test%d\n"",nmy);
                printf(""ans's  : %d   my  : %d\n\n"",anspathnum,pathnum );
            }
        }



    }
    fclose(ans);
    fclose(myans);

}
",53,1586,778
"typedef struct Treenode* nodepointer;
int max(int a,int b){
    if(a>b){
        return a;
    }
    else return b;
}
typedef struct Treenode{
    int sum;
    int ls;
    int rs;
    int max;
    nodepointer left;
    nodepointer right;
}node;
node* build(int l,int r,int* arr){
    node* ptr=(node*)malloc(sizeof(node));
    if(r==l){
        ptr->sum=arr[l];
        ptr->ls=arr[l];
        ptr->rs=arr[l];
        ptr->max=arr[l];
        return ptr;
    }
    else{
        int m=(l+r)/2;
        node* leftn=build(l,m,arr);
        node* rightn=build(m+1,r,arr);
        ptr->sum=leftn->sum+rightn->sum;
        ptr->ls=max(leftn->ls,leftn->sum+rightn->ls);
        ptr->rs=max(rightn->rs,rightn->sum+leftn->rs);
        ptr->max=max(max(rightn->max,leftn->max),leftn->rs+rightn->ls);
        ptr->left=leftn;
        ptr->right=rightn;
        return ptr;
    }
}
void modify(int x,int value,int l,int r,node* ptr){
    if(l==r){
        ptr->sum=value;
        ptr->ls=value;
        ptr->rs=value;
        ptr->max=value;
        return;
    }
    int m=(r+l)/2;
    if(x<=m){
        modify(x,value,l,m,ptr->left);
    }
    else{
        modify(x,value,m+1,r,ptr->right);
    }
    ptr->sum=ptr->left->sum+ptr->right->sum;
    ptr->ls=max(ptr->left->ls,ptr->left->sum+ptr->right->ls);
    ptr->rs=max(ptr->right->rs,ptr->right->sum+ptr->left->rs);
    ptr->max=max(max(ptr->right->max,ptr->left->max),ptr->left->rs+ptr->right->ls);
    return;
}
typedef struct imfor{
    int sum;
    int ls;
    int rs;
    int max;
}imfor;
imfor find(int a,int b,int l,int r,node* ptr){
    imfor im;
    if(a==l && b==r){
        im.sum=ptr->sum;
        im.ls=ptr->ls;
        im.rs=ptr->rs;
        im.max=ptr->max;
        return im;
    }
    int m=(l+r)/2;
    if(b<=m){
        im = find(a,b,l,m,ptr->left);
        return im;
    }
    if(a>m){
        im = find(a,b,m+1,r,ptr->right);
        return im;
    }
    else{
        imfor leftim=find(a,m,l,m,ptr->left);
        imfor rightim=find(m+1,b,m+1,r,ptr->right);
        im.sum=leftim.sum+rightim.sum;
        im.ls=max(leftim.ls,leftim.sum+rightim.ls);
        im.rs=max(rightim.rs,rightim.sum+leftim.rs);
        im.max=max(max(rightim.max,leftim.max),leftim.rs+rightim.ls);
        return im;
    }
}
int main(){
    FILE *rptr;
    FILE *wptr;
    rptr=fopen(""test3.txt"",""r"");
    wptr=fopen(""output1-1.txt"",""w"");
    if(rptr==NULL ||wptr==NULL){
        printf(""open error\n"");
        return 0;
    }
    int i,j;
    int t,n,m;
    fscanf(rptr,""%d\n"",&t);
    printf(""t: %d\n"",t);
    node* root;
    int* arr;
    for(i=0;i<t;i++){
        fscanf(rptr,""%d\n"",&n);
        printf(""n: %d\n"",n);
        arr=(int*)malloc((n+1)*sizeof(int));
        arr[0]=0;
        for(j=1;j<n;j++){
            fscanf(rptr,""%d "",&arr[j]);
        }
        fscanf(rptr,""%d\n"",&arr[n]);
        root=build(1,n,arr);
        fscanf(rptr,""%d\n"",&m);
        printf(""m: %d\n"",m);
        char c;
        int n1,n2;
        for(j=0;j<m;j++){
            fscanf(rptr,""%c "",&c);
            fscanf(rptr,""%d %d\n"",&n1,&n2);
            if(c=='M'){
                modify(n1,n2,1,n,root);
            }
            else if(c=='P'){
                imfor ans=find(n1,n2,1,n,root);
                fprintf(wptr,""%d\n"",ans.max);
            }
        }

    }
    fclose(wptr);
    fclose(rptr);
}
",53,1587,1409
"typedef struct all{
    int *ori;
    int *chan_to;
}All;
int at_where(char**,char*,int*);
int pass(All*,int*,int,int,int);
int main(){
    FILE* rptr;
    rptr=fopen(""test8.txt"",""r"");
    if(rptr==NULL){
        printf(""error\n"");
        return 0;
    }
    int n,i,j;
    fscanf(rptr,""%d\n"",&n);
    char* token;
    const char* delim = "" "";
    All* all=(All*)malloc(300*sizeof(All));
    int alln=0;
    char **obj=(char**)malloc(18000*sizeof(char*));
    int objn=0;
    int flyat,pigat;
    int* ori;
    int* chan_to;
    for(i=0;i<n;i++){
        char str[300];
        fgets(str,300,rptr);
        token = strtok(str,delim);
        int chan=0;
        ori=(int*)malloc(18000*sizeof(int));
        chan_to=(int*)malloc(18000*sizeof(int));
        int orin=0,chan_ton=0;
        int isthat=0;
        while( token != NULL ){
            if('Z'>=token[0] && token[0]>='A'){
                if(token[strlen(token)-1]=='\n') token[strlen(token)-1]='\0';
                int at=at_where(obj,token,&objn);
                if(chan==0){
                    ori[orin++]=at;
                }
                else if(chan==1){
                    chan_to[chan_ton++]=at;
                }
                if (strlen(token)==3 && strncmp(""FLY"",token,strlen(token))==0) flyat=at;
                else if (strlen(token)==4 && strncmp(""PIGS"",token,strlen(token))==0) pigat=at;

            }
            if((strlen(token)==3 && strncmp(""are"",token,strlen(token))==0)||\
                (strlen(token)==3 && strncmp(""can"",token,strlen(token))==0) && isthat==0 ||\
                (strlen(token)==4 && strncmp(""have"",token,strlen(token))==0)){
                chan=1;
            }
            if(strlen(token)==4 && strncmp(""that"",token,strlen(token))==0){
                isthat=1;
            }
            if(strlen(token)==3 && strncmp(""can"",token,strlen(token))==0 && isthat==1){
                isthat=0;
            }
            token=strtok(NULL,delim);
        }
        ori[orin]=-1;
        chan_to[chan_ton]=-1;
        all[alln].ori=ori;
        all[alln++].chan_to=chan_to;
    }
    int *test=(int*)malloc((objn+1)*sizeof(int));
    memset(test,0,objn+1);
    test[pigat]=1;
    int allcheck=pass(all,test,alln,flyat,pigat);
    while(allcheck!=0 && allcheck!=2){
        allcheck=pass(all,test,alln,flyat,pigat);
    }
    if(allcheck==2){
        printf(""All pigs can fly\n"");
    }
    else{
        for(i=0;i<objn;i++){
            for(j=0;j<objn;j++){
                test[j]=0;
                if(j==i) test[j]=1;
            }
            allcheck=pass(all,test,alln,flyat,pigat);
            while(allcheck!=0 && allcheck!=2){
                allcheck=pass(all,test,alln,flyat,pigat);
            }
            if(allcheck==2) {
                break;
            }
        }
        if(allcheck==2){
            printf(""Some pigs can fly\n"");
        }
        else{
            printf(""No pigs can fly\n"");
        }
    }
}
int pass(All all[300],int* test,int alln,int flyat,int pigat){
    int i,j,allcheck=0;
    for(i=0;i<alln;i++){
        int check=1;
        for(j=0;all[i].ori[j]!=-1;j++){
            if(test[all[i].ori[j]]==0) {
                check=0;
                break;
            }
        }
        if(check){
            for(j=0;all[i].chan_to[j]!=-1;j++){
                if(test[all[i].chan_to[j]]==0) allcheck=1;
                test[all[i].chan_to[j]]=1;
            }
        }
    }
    if(test[flyat]==1 && test[pigat]==1){
        return 2;
    }
    else {
        return allcheck;
    }
}
int at_where(char** obj,char* token,int* objn){
    int i,j,check=0;
    char *new=(char*)malloc(300*sizeof(char));
    for(i=0;i<strlen(token);i++){
        new[i]=token[i];
    }
    new[i]='\0';
    for(i=0;i<*objn;i++){
        if(strcmp(obj[i],token)==0 && strncmp(obj[i],token,strlen(token))==0){
            check=1;
            return i;
        }
    }
    if(!check){
        obj[(*objn)++]=new;
        return (*objn)-1;
    }
}
",53,1588,1540
"typedef struct List* listpointer;
typedef struct List{
    int data;
    listpointer pre;
    listpointer next;
}list;
listpointer first;
int main(){
    int i;
    listpointer last,plat;
    first=(listpointer)malloc(sizeof(list));
    first->data=64;
    last=first;
    for(i=1;i<20;i++){
        plat=(listpointer)malloc(sizeof(list));
        plat->data=64;
        plat->pre=last;
        last->next=plat;
        last=plat;
    }
    first->pre=plat;
    plat->next=first;
    FILE* rptr;
    FILE* wfile;
    rptr=fopen(""test2-1.txt"",""r"");
    wfile=fopen(""output2-1.txt"",""w"");
    if(rptr==NULL || wfile==NULL){
        printf(""open failure\n"");
        return 1;
    }
    else{
        char control;
        control=fgetc(rptr);
        while(control!='\n' && control!=EOF){
            switch (control) {
                case '+':
                    first->data = ((first->data)+1)%64 +64;
                    break;
                case '-':
                    first->data = (first->data)-1;
                    if(first->data<64){
                        first->data = first->data-64+91;
                    }
                    break;
                case '>':
                    first=first->next;
                    break;
                case '<':
                    first=first->pre;
                    break;
                case '.':
                    if(first->data==64){
                        printf("" "");
                        fprintf(wfile,"" "");
                    }
                    else{
                        printf(""%c"",first->data);
                        fprintf(wfile,""%c"",first->data);
                    }
            }
            control=fgetc(rptr);
        }
    }
    fclose(wfile);
    fclose(rptr);
}
",53,1589,530
"#define MAXLEN 14
#define MAX_STACK_SIZE 100000
#define MAX 455
#define MALLOC(p,s)\
    if(!((p)=malloc(s))){\
        fprintf(stderr,""Insufficient memory"");\
        exit(EXIT_FAILURE);\
    }
char* make1darr(int n){
    char *x;
    MALLOC(x,n*sizeof(*x));
    return x;
}
char*** make3darr(int rows, int cols,int hei){
    char ***x;
    MALLOC(x,rows*sizeof(**x));
    int i,j;
    for(i=0;i<rows;i++){
        MALLOC(x[i],cols*sizeof(**x));
        for(j=0;j<hei;j++){
            MALLOC(x[i][j],hei*sizeof(***x));
        }
    }
    return x;
}

int*** make3darrint(int rows, int cols,int hei){
    int ***x;
    MALLOC(x,rows*sizeof(**x));
    int i,j;
    for(i=0;i<rows;i++){
        MALLOC(x[i],cols*sizeof(**x));
        for(j=0;j<hei;j++){
            MALLOC(x[i][j],hei*sizeof(***x));
        }
    }
    return x;
}
typedef struct{
    short int row;
    short int col;
    short int hei;
    short int dir;
} element;

element stack[MAX_STACK_SIZE];
int top = -1;
void stackFull(){
    fprintf(stderr, ""å çå·²æ»¿ï¼ä¸è½åå å¥åç´ "");
    exit(EXIT_FAILURE);
}
void push(element item){
    if(top >=MAX_STACK_SIZE-1){
        stackFull();
    }
    stack [++top] = item;
}
element pop(){
    if(top==-1){
        fprintf(stderr, ""å çå·²ç©º"");
    }
    return stack[top--];
}

element stack2[MAX_STACK_SIZE];
int top2 = -1;
void push2(element item){
    if(top2 >=MAX_STACK_SIZE-1){
    }
    stack2 [++top2] = item;
}
element pop2(){
    
    return stack2[top2--];
}

element queue[MAX_STACK_SIZE];
int rear = -1;
int front = -1;
void queueFull(){
    fprintf(stderr, ""ä½åå·²æ»¿ï¼ä¸è½åå å¥åç´ "");
    exit(EXIT_FAILURE);
}
void addq(element item){
    if(rear==MAX_STACK_SIZE-1){
        queueFull();
    }
    queue[++rear] = item;
}
element deleteq(){
    if(front==rear){
        fprintf(stderr, ""ä½åå·²ç©º"");
    }
    return queue[++front];
}

typedef struct{
    short int vert;
    short int horiz;
    short int hei;
}offsets;
offsets move[6];


int min=10000;
int n;

int bfs(char*** maze,int*** d,int sr,int sc,int sh){
    rear=-1;front=-1;

    int arrive=0;
    element position;
    position.row = sr;
    position.col = sc;
    position.hei = sh;
    

    addq(position);
    int i,j,k;
    for(i=0;i<n/2+1;i++){
        for(j=0;j<n+2;j++){
            for(k=0;k<n+2;k++){
                d[i][j][k]=MAX;
            }
        }
    }
    d[sh][sr][sc]=0;
    

    int nr,nc,nh;
    int row,col,hei;
    while(rear!=front){
        
        position = deleteq();
        row = position.row;
        col = position.col;
        hei = position.hei;
        

        if(maze[hei][row][col]=='F'){
            
            if(min>d[hei][row][col]){
                min = d[hei][row][col];
            }
            
            arrive=1;
        }
        
        if(maze[hei][row][col]=='U' || maze[hei][row][col]=='D'){
            
            
            int upanddown=-1;
            if(maze[hei][row][col]=='U'){
                
                upanddown=1;
            }
            

            nr = row;
            nc = col;
            nh = hei+upanddown;
            
            
            if(nh>=0){
                if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]>d[hei][row][col]+1){
                    d[nh][nr][nc]=d[hei][row][col]+1;
                    if(maze[nh][nr][nc]=='T'){
                        d[nh][nr][nc]=d[nh][nr][nc]+2;
                    }
                    element nextposition;
                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;
                    addq(nextposition);
                }
            }

        }
        
        for(i=0;i<4;i++){
            nr = row+move[i].vert;
            nc = col+move[i].horiz;
            nh = hei+move[i].hei;

            if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]>d[hei][row][col]+1){
                d[nh][nr][nc]=d[hei][row][col]+1;
                if(maze[nh][nr][nc]=='T'){
                    d[nh][nr][nc]=d[nh][nr][nc]+2;
                }
                element nextposition;
                nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;
                addq(nextposition);
            }

        }
        

    }
    return arrive;
}

void path(char*** maze,char*** road,char*** mark,int*** d,int sr,int sc,int sh){
    top=-1;
    top2=-1;
    element position;
    position.row = sr;
    position.col = sc;
    position.hei = sh;
    position.dir = 0 ;
    push(position);
    

    int i,j,k;
    int nr,nc,nh;
    int row,col,hei,dir;
    int found=1;

    while(top>-1){
        position = pop();

        
        row = position.row;
        col = position.col;
        hei = position.hei;
        dir = position.dir;


        
        if(!found){
            
            while(top2>-1){
                element lastposition = pop2();
                int lr=lastposition.row;int lc=lastposition.col;int lh=lastposition.hei;int ld=lastposition.dir;

                

                if(lr+move[dir].vert==row && lc+move[dir].horiz==col && lh+move[dir].hei==hei ){
                    push2(lastposition);
                    break;
                }
                road[lh][lr][lc]=maze[lh][lr][lc];
                mark[lh][lr][lc]=maze[lh][lr][lc];
            }
        }
        road[hei][row][col]='*';
        mark[hei][row][col]='X';
        push2(position);
        if(maze[hei][row][col]=='F'){
            break;
        }

        

        found=0;
        for(i=0;i<4;i++){
            nr = row+move[i].vert;
            nc = col+move[i].horiz;
            nh = hei+move[i].hei;
            if ((mark[nh][nr][nc]!='X' && ((d[nh][nr][nc]==d[hei][row][col]+1)&& mark[nh][nr][nc]!='T') || (d[nh][nr][nc]==d[hei][row][col]+3 && mark[nh][nr][nc]=='T'))){
                
                found=1;
                element nextposition;
                nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;nextposition.dir=i;
                push(nextposition);
            }
        }
        if(maze[hei][row][col]=='U' || maze[hei][row][col]=='D'){
            int upanddown=-1;
            if(maze[hei][row][col]=='U'){
                upanddown=1;
            }
            nr = row;
            nc = col;
            nh = hei+upanddown;
            if(nh>=0){
                if ((mark[nh][nr][nc]!='X' && ((d[nh][nr][nc]==d[hei][row][col]+1)&& mark[nh][nr][nc]!='T') || (d[nh][nr][nc]==d[hei][row][col]+3 && mark[nh][nr][nc]=='T'))){

                    found=1;
                    element nextposition;
                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;
                    if(upanddown==1) nextposition.dir=4;
                    else nextposition.dir=5;
                    push(nextposition);
                }
            }


        }
        
    }
}

int main(){
    move[0].vert=-1;
    move[0].horiz=0;
    move[0].hei=0;
    move[1].vert=0;
    move[1].horiz=1;
    move[1].hei=0;
    move[2].vert=1;
    move[2].horiz=0;
    move[2].hei=0;
    move[3].vert=0;
    move[3].horiz=-1;
    move[3].hei=0;
    move[4].vert=0;
    move[4].horiz=0;
    move[4].hei=1;
    move[5].vert=0;
    move[5].horiz=0;
    move[5].hei=-1;
    
    char y;
    int i,j,k;

    FILE *pfile;
    char name[50];
    int control;
    for(control=1;control<=100;control++){
        min=100000;
        sprintf(name,""test%d.txt"",control);
        pfile = fopen(name,""r"");
        if(NULL==pfile){
            printf(""Open failure"");
            return 1;
        }
        else{
            printf(""reading %s\n"",name);
            
            char* bottom = make1darr(MAXLEN);
            n=0;
            char y;
            bottom[n]=fgetc(pfile);
            while(bottom[n]!='\n'){
                fgetc(pfile);
                bottom[++n]=fgetc(pfile);
                
            }
            char ***maze=make3darr(n/2+1,n+2,n+2);
            char ***road=make3darr(n/2+1,n+2,n+2);
            char ***mark=make3darr(n/2+1,n+2,n+2);
            int ***d=make3darrint(n/2+1,n+2,n+2);
            int len=0;
            int sr,sc,sh;
            for(i=0;i<n/2+1;i++){
                for(j=0;j<n+2;j++){
                    for(k=0;k<n+2;k++){
                        if(j==0 || k==0 || j==n+1 || k==n+1){
                            maze[i][j][k]='X';
                        }
                        else if(i==0 && j==1){
                            maze[i][j][k]=bottom[k-1];
                        }
                        else if(j > len && j <= n-len && k > len && k <= n-len){
                            fscanf(pfile,""%c "",&maze[i][j][k]);

                        }
                        else{
                            maze[i][j][k]='X';
                        }
                        if(maze[i][j][k]=='S'){
                            sh=i;
                            sr=j;
                            sc=k;
                        }
                        road[i][j][k]=maze[i][j][k];
                        mark[i][j][k]=maze[i][j][k];
                    }
                }
                len++;
            }
            FILE *wfile;
            sprintf(name,""4108056029test%d_ans.txt"",control);
            wfile = fopen(name,""w"");
            if( NULL == wfile ){
                printf( ""wfile open failure"" );
                return 1;
            }
            else{
                if(bfs(maze,d,sr,sc,sh)){
                    path(maze,road,mark,d,sr,sc,sh);
                    
                    fprintf(wfile,""Path length: %d\n"",min);
                    fprintf(wfile,""=====outMaze=====\n"");
                    for(i=0;i<n/2+1;i++){
                        for(j=i+1;j<n+2-i-1;j++){
                            for(k=i+1;k<n+2-i-1;k++){
                                fprintf(wfile,""%c "",road[i][j][k] );
                            }
                            fprintf(wfile,""\n"");
                        }
                        fprintf(wfile,""\n"");
                    }
                }
                else fprintf(wfile,""The maze does not have a path\n"" );
            }
            free(bottom);
            free(maze);
            free(mark);
            free(road);
            free(d);
        }
        fclose(pfile);

    }
}
",53,1590,3869
"typedef struct position{
    int row;
    int col;
    int mirror;
}position;
typedef struct Orien{
    int row;
    int col;
}Orien;
Orien orien[4];
void mark(char**,int**,int,int,int,int,int,int,int,int,int);

int n;
int main(){
    FILE* rptr;
    FILE* wptr;
    rptr=fopen(""test4.txt"",""r"");
    if(rptr==NULL){
        printf(""error\n"");
        return 0;
    }
    
    orien[0].row=1;
    orien[0].col=0;
    orien[1].row=0;
    orien[1].col=-1;
    orien[2].row=-1;
    orien[2].col=0;
    orien[3].row=0;
    orien[3].col=1;
    int v,z,g;
    fscanf(rptr,""%d %d %d\n"",&v,&z,&g);
    fscanf(rptr,""%d\n"",&n);
    int** see=(int**)malloc((n*4)*sizeof(int*));
    int i,j;
    for(i=0;i<n*4;i++){
        see[i]=(int*)malloc(4*sizeof(int));
        fscanf(rptr,""%d "",&see[i][0]);
        if(i<n){
            see[i][1]=1;
            see[i][2]=i+1;
            see[i][3]=0;
        }
        else if(i<2*n){
            see[i][1]=n;
            see[i][2]=i-n+1;
            see[i][3]=2;
        }
        else if(i<3*n){
            see[i][1]=i-2*n+1;
            see[i][2]=1;
            see[i][3]=3;
        }
        else{
            see[i][1]=i-n*3+1;
            see[i][2]=n;
            see[i][3]=1;
        }
    }
    char **ans=(char**)malloc((n+2)*sizeof(char*));
    for(i=0;i<n+2;i++){
        ans[i]=(char*)malloc((n+2)*sizeof(char));
        for(j=0;j<n+2;j++){
            if(i==0 || j==0 || i==n+1 || j==n+1){
                ans[i][j]='x';
            }
            else{
                fscanf(rptr,""%c"",&ans[i][j]);
            }
        }
        if(i!=0 &&i!=n+1){
            fgetc(rptr);
        }
    }
    mark(ans,see,0,v,z,g,see[0][0],1,1,0,0);
    free(see);
    free(ans);
    for(i=0;i<n+2;i++){
        free(ans[i]);
    }
    for(i=0;i<3;i++){
        free(see[i]);
    }
    fclose(rptr);
}

void mark(char** ans,int** see,int seen,int v,int z,int g,int monsta,int row,int col,int mirror,int dir){
    int i,j;
    char origin=ans[row][col];
    if(v<0||z<0||g<0||monsta<0 || monsta>see[seen][0]){
        return;
    }
    if(ans[row][col]=='x' && monsta!=0){
        return;
    }
    if(ans[row][col]=='x' && monsta==0){
        if(seen==4*n-1){
            
            for(i=0;i<n+2;i++){
                for(j=0;j<n+2;j++){
                    printf(""%c"",ans[i][j]);
                }
                printf(""\n"");
            }
            return;
        }
        mark(ans,see,seen+1,v,z,g,see[seen+1][0],see[seen+1][1],see[seen+1][2],0,see[seen+1][3]);
        return;
    }
    if(ans[row][col]=='\\'){
        mirror=1;
        switch (dir) {
            case 0: dir=3;break;      case 1: dir=2;break;     case 2: dir=1;break;    case 3: dir=0;break;
        }
    }
    else if(ans[row][col]=='/'){
        mirror=1;
        switch (dir) {
            case 0: dir=1;break;  case 1: dir=0;break;  case 2: dir=3;break;  case 3: dir=2;break;
        }
    }
    int nextrow=row+orien[dir].row,nextcol=col+orien[dir].col,nextmonsta=monsta;
    if(ans[row][col]=='Z'||ans[row][col]=='G'||ans[row][col]=='V'){
        if(ans[row][col]=='Z') nextmonsta--;
        if(mirror==1 && ans[row][col]=='G') nextmonsta--;
        else if(mirror==0 && ans[row][col]=='V') nextmonsta--;
        mark(ans,see,seen,v,z,g,nextmonsta,nextrow,nextcol,mirror,dir);
    }
    else if(ans[row][col]=='.'){
        ans[row][col]='Z';
        mark(ans,see,seen,v,z-1,g,monsta-1,nextrow,nextcol,mirror,dir);
        if(mirror==1){
            ans[row][col]='G';
            mark(ans,see,seen,v,z,g-1,monsta-1,nextrow,nextcol,mirror,dir);
            ans[row][col]='V';
            mark(ans,see,seen,v-1,z,g,monsta,nextrow,nextcol,mirror,dir);
        }
        else if(mirror==0){
            ans[row][col]='G';
            mark(ans,see,seen,v,z,g-1,monsta,nextrow,nextcol,mirror,dir);
            ans[row][col]='V';
            mark(ans,see,seen,v-1,z,g,monsta-1,nextrow,nextcol,mirror,dir);
        }
    }
    else mark(ans,see,seen,v,z,g,monsta,nextrow,nextcol,mirror,dir);
    ans[row][col]=origin;
    return;
}
",53,1591,1751
"#define MAXLEN 14
#define MALLOC(p,s)\
    if(!((p)=malloc(s))){\
        fprintf(stderr,""Insufficient memory"");\
        exit(EXIT_FAILURE);\
    }
char* make1darr(int n){
    char *x;
    MALLOC(x,n*sizeof(*x));
    return x;
}
char*** make3darr(int rows, int cols,int hei){
    char ***x;
    MALLOC(x,rows*sizeof(**x));
    int i,j;
    for(i=0;i<rows;i++){
        MALLOC(x[i],cols*sizeof(**x));
        for(j=0;j<hei;j++){
            MALLOC(x[i][j],hei*sizeof(***x));
        }
    }
    return x;
}
int main(){
    FILE *ans;
    FILE *myans;
    char name[50];
    ans=fopen(""output_20201011.txt"",""r"");
    myans=fopen(""4108056029output.txt"",""r"");

    if(NULL==ans || NULL == myans){
        printf(""Open failure\n"");
        if(NULL == myans){
            printf(""my ans Open failure\n"");
        }
        if(NULL == ans){
            printf(""ans Open failure\n"");
        }
        return 1;
    }

    else{
        int nans,nmy,i;
        int ansmin,ansLimit,anspathnum;
        int min,Limit,pathnum;
        for(i=0;i<100;i++){
            fscanf(ans,""test %d starts now."",&nans);
            
            char y=fgetc(ans);
            
            fscanf(ans,""Shortest path: %d, The number of different paths: %d"",&ansmin,&anspathnum);
            
            y=fgetc(ans);
            
            y=fgetc(ans);
            

            fscanf(myans,""test %d starts now."",&nmy);
            

            char x =fgetc(myans);
            
            fscanf(myans,""Shortest path: %d, The number of different paths: %d"",&min,&pathnum);
            
            x=fgetc(myans);
            
            x=fgetc(myans);
            
            if(min!=ansmin){
                printf(""Shortest path error in test%d\n"",nmy);
                printf(""ans's min : %d   my min : %d\n\n"",ansmin,min );
            }
            if(pathnum!=anspathnum){
                printf(""pathnum error in test%d\n"",nmy);
                printf(""ans's  : %d   my  : %d\n\n"",anspathnum,pathnum );
            }
        }



    }
    fclose(ans);
    fclose(myans);

}
",53,1592,759
"#define MAXLEN 14
#define MAX_STACK_SIZE 1000
#define MAX 455
#define MALLOC(p,s)\
    if(!((p)=malloc(s))){\
        fprintf(stderr,""Insufficient memory"");\
        exit(EXIT_FAILURE);\
    }
char* make1darr(int n){
    char *x;
    MALLOC(x,n*sizeof(*x));
    return x;
}
char*** make3darr(int rows, int cols,int hei){
    char ***x;
    MALLOC(x,rows*sizeof(**x));
    int i,j;
    for(i=0;i<rows;i++){
        MALLOC(x[i],cols*sizeof(**x));
        for(j=0;j<hei;j++){
            MALLOC(x[i][j],hei*sizeof(***x));
        }
    }
    return x;
}

int*** make3darrint(int rows, int cols,int hei){
    int ***x;
    MALLOC(x,rows*sizeof(**x));
    int i,j;
    for(i=0;i<rows;i++){
        MALLOC(x[i],cols*sizeof(**x));
        for(j=0;j<hei;j++){
            MALLOC(x[i][j],hei*sizeof(***x));
        }
    }
    return x;
}
typedef struct{
    short int row;
    short int col;
    short int hei;
    short int dir;
} element;
element queue[MAX_STACK_SIZE];
int rear = -1;
int front = -1;
void queueFull(){
    fprintf(stderr, ""ä½åå·²æ»¿ï¼ä¸è½åå å¥åç´ "");
    exit(EXIT_FAILURE);
}
void addq(element item){
    if(rear==MAX_STACK_SIZE-1){
        queueFull();
    }
    queue[++rear] = item;
}
element deleteq(){
    if(front==rear){
        fprintf(stderr, ""ä½åå·²ç©º"");
    }
    return queue[++front];
}

typedef struct{
    short int vert;
    short int horiz;
    short int hei;
}offsets;
offsets move[6];


int min;
int n;

int bfs(char*** maze,int*** d,int sr,int sc,int sh){
    rear=-1;front=-1;

    int arrive=0;
    element position;
    position.row = sr;
    position.col = sc;
    position.hei = sh;
    

    addq(position);
    int i,j,k;
    for(i=0;i<n/2+1;i++){
        for(j=0;j<n+2;j++){
            for(k=0;k<n+2;k++){
                d[i][j][k]=MAX;
            }
        }
    }
    d[sh][sr][sc]=0;
    

    int nr,nc,nh;
    int row,col,hei;
    while(rear!=front){
        
        position = deleteq();
        row = position.row;
        col = position.col;
        hei = position.hei;
        

        if(maze[hei][row][col]=='F'){
            
            if(min>d[hei][row][col]){
                min = d[hei][row][col];
            }
            min = d[hei][row][col];
            
            arrive=1;
        }
        
        if(maze[hei][row][col]=='U' || maze[hei][row][col]=='D'){
            int upanddown=-1;
            if(maze[hei][row][col]=='U'){
                
                upanddown=1;
            }
            

            nr = row;
            nc = col;
            nh = hei+upanddown;
            
            if(nh>=0){
                if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]>d[hei][row][col]+1){
                    d[nh][nr][nc]=d[hei][row][col]+1;
                    if(maze[nh][nr][nc]=='T'){
                        d[nh][nr][nc]=d[nh][nr][nc]+2;
                    }
                    element nextposition;
                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;
                    addq(nextposition);
                }
            }

        }
        
        for(i=0;i<4;i++){
            nr = row+move[i].vert;
            nc = col+move[i].horiz;
            nh = hei+move[i].hei;

            if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]>d[hei][row][col]+1){
                d[nh][nr][nc]=d[hei][row][col]+1;
                if(maze[nh][nr][nc]=='T'){
                    d[nh][nr][nc]=d[nh][nr][nc]+2;
                }
                element nextposition;
                nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;
                addq(nextposition);
            }

        }
        

    }
    return arrive;
}
int pathnum=0;

void dfs(char*** maze,char*** mark,char*** road,int row,int col,int hei,int count){

    int i,j,k;

    if(count>=(min+5)){
        return;
    }
    else{
        int i;
        int nh,nr,nc;
        for(i=0;i<4;i++){
            nr = row+move[i].vert;
            nc = col+move[i].horiz;
            nh = hei+move[i].hei;
            if(mark[nh][nr][nc]!='X'){
                mark[nh][nr][nc]='X';
                road[nh][nr][nc]='*';
                if(maze[nh][nr][nc]=='T'){
                    dfs(maze,mark,road,nr,nc,nh,count+3);
                }

                else{
                    dfs(maze,mark,road,nr,nc,nh,count+1);
                }
                mark[nh][nr][nc]=maze[nh][nr][nc];
                road[nh][nr][nc]=maze[nh][nr][nc];

            }
        }
        if(maze[hei][row][col]=='U'){
            if(mark[hei+1][row][col]!='X'){
                mark[hei+1][row][col]='X';
                road[hei+1][row][col]='*';
                if(maze[hei+1][row][col]=='T'){

                    dfs(maze,mark,road,row,col,hei+1,count+3);

                }
                else if(maze[hei+1][row][col]=='F'){
                    pathnum++;
                }
                else{
                    dfs(maze,mark,road,row,col,hei+1,count+1);
                }
                mark[hei+1][row][col]=maze[hei+1][row][col];
                road[hei+1][row][col]=maze[hei+1][row][col];
            }



        }
        else if(maze[hei][row][col]=='D' && hei>0){
            if(mark[hei-1][row][col]!='X'){

                mark[hei-1][row][col]='X';
                road[hei-1][row][col]='*';
                if(mark[hei-1][row][col]='T'){
                    dfs(maze,mark,road,row,col,hei-1,count+3);
                }
                else{

                    dfs(maze,mark,road,row,col,hei-1,count+1);
                }
                mark[hei-1][row][col]=maze[hei-1][row][col];
                road[hei-1][row][col]=maze[hei-1][row][col];
            }
        }

    }

}

int main(){
    move[0].vert=-1;
    move[0].horiz=0;
    move[0].hei=0;
    move[1].vert=0;
    move[1].horiz=1;
    move[1].hei=0;
    move[2].vert=1;
    move[2].horiz=0;
    move[2].hei=0;
    move[3].vert=0;
    move[3].horiz=-1;
    move[3].hei=0;
    move[4].vert=0;
    move[4].horiz=0;
    move[4].hei=1;
    move[5].vert=0;
    move[5].horiz=0;
    move[5].hei=-1;
    
    char y;
    int i,j,k;

    FILE *pfile;
    char name[50];
    int control;
    FILE *wfile;
    wfile = fopen( ""4108056029output.txt"",""w"" );
    if( NULL == wfile ){
        printf( ""wfile open failure"" );
        return 1;
    }
    else{
        for(control=1;control<=100;control++){
            min = 100000;
            sprintf(name,""test%d.txt"",control);
            pfile = fopen(name,""r"");
            if(NULL==pfile){
                printf(""Open failure"");
                return 1;
            }
            else{
                printf(""reading %s\n"",name);
                
                char* bottom = make1darr(MAXLEN);
                n=0;
                char y;
                bottom[n]=fgetc(pfile);
                while(bottom[n]!='\n'){
                    fgetc(pfile);
                    bottom[++n]=fgetc(pfile);
                    
                }
                char ***maze=make3darr(n/2+1,n+2,n+2);
                char ***road=make3darr(n/2+1,n+2,n+2);
                char ***mark=make3darr(n/2+1,n+2,n+2);
                int ***d=make3darrint(n/2+1,n+2,n+2);
                int len=0;
                int sr,sc,sh;
                for(i=0;i<n/2+1;i++){
                    for(j=0;j<n+2;j++){
                        for(k=0;k<n+2;k++){
                            if(j==0 || k==0 || j==n+1 || k==n+1){
                                maze[i][j][k]='X';
                            }
                            else if(i==0 && j==1){
                                maze[i][j][k]=bottom[k-1];
                            }
                            else if(j > len && j <= n-len && k > len && k <= n-len){
                                fscanf(pfile,""%c "",&maze[i][j][k]);

                            }
                            else{
                                maze[i][j][k]='X';
                            }
                            if(maze[i][j][k]=='S'){
                                sh=i;
                                sr=j;
                                sc=k;
                            }
                            road[i][j][k]=maze[i][j][k];
                            mark[i][j][k]=maze[i][j][k];
                        }
                    }
                    len++;
                }
                fprintf(wfile, ""test %d starts now.\n"",control );
                if(bfs(maze,d,sr,sc,sh)){
                    mark[sh][sr][sc]='X';
                    pathnum=0;
                    dfs(maze,mark,road,sr,sc,sh,0);
                    printf(""Sortest path : %d, Limit: %d, The number of different paths: %d\n\n"",min,min+5,pathnum);
                    fprintf(wfile,""Shortest path: %d, Limit: %d, The number of different paths: %d\n\n"",min,min+5,pathnum);
                }
                else fprintf(wfile,""The maze does not have a path\n"" );
                free(bottom);
                free(maze);
                free(mark);
                free(road);
                free(d);
            }
            fclose(pfile);

        }
    }
    fclose(wfile);
}
",53,1593,3415
"#define MAXLEN 14
#define MAX_STACK_SIZE 1000
#define MAX 455
#define MALLOC(p,s)\
    if(!((p)=malloc(s))){\
        fprintf(stderr,""Insufficient memory"");\
        exit(EXIT_FAILURE);\
    }
char* make1darr(int n){
    char *x;
    MALLOC(x,n*sizeof(*x));
    return x;
}
char*** make3darr(int rows, int cols,int hei){
    char ***x;
    MALLOC(x,rows*sizeof(**x));
    int i,j;
    for(i=0;i<rows;i++){
        MALLOC(x[i],cols*sizeof(**x));
        for(j=0;j<hei;j++){
            MALLOC(x[i][j],hei*sizeof(***x));
        }
    }
    return x;
}

int*** make3darrint(int rows, int cols,int hei){
    int ***x;
    MALLOC(x,rows*sizeof(**x));
    int i,j;
    for(i=0;i<rows;i++){
        MALLOC(x[i],cols*sizeof(**x));
        for(j=0;j<hei;j++){
            MALLOC(x[i][j],hei*sizeof(***x));
        }
    }
    return x;
}
typedef struct{
    short int row;
    short int col;
    short int hei;
    short int dir;
} element;
element queue[MAX_STACK_SIZE];
int rear = -1;
int front = -1;
void queueFull(){
    fprintf(stderr, ""ä½åå·²æ»¿ï¼ä¸è½åå å¥åç´ "");
    exit(EXIT_FAILURE);
}
void addq(element item){
    if(rear==MAX_STACK_SIZE-1){
        queueFull();
    }
    queue[++rear] = item;
}
element deleteq(){
    if(front==rear){
        fprintf(stderr, ""ä½åå·²ç©º"");
    }
    return queue[++front];
}

typedef struct{
    short int vert;
    short int horiz;
    short int hei;
}offsets;
offsets move[6];


int min;
int n;

int bfs(char*** maze,int*** d,int sr,int sc,int sh){
    rear=-1;front=-1;

    int arrive=0;
    element position;
    position.row = sr;
    position.col = sc;
    position.hei = sh;
    

    addq(position);
    int i,j,k;
    for(i=0;i<n/2+1;i++){
        for(j=0;j<n+2;j++){
            for(k=0;k<n+2;k++){
                d[i][j][k]=MAX;
            }
        }
    }
    d[sh][sr][sc]=0;
    

    int nr,nc,nh;
    int row,col,hei;
    while(rear!=front){
        
        position = deleteq();
        row = position.row;
        col = position.col;
        hei = position.hei;
        

        if(maze[hei][row][col]=='F'){
            
            if(min>d[hei][row][col]){
                min = d[hei][row][col];
            }
            min = d[hei][row][col];
            
            arrive=1;
        }
        
        if(maze[hei][row][col]=='U' || maze[hei][row][col]=='D'){
            int upanddown=-1;
            if(maze[hei][row][col]=='U'){
                
                upanddown=1;
            }
            

            nr = row;
            nc = col;
            nh = hei+upanddown;
            
            if(nh>=0){
                if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]>d[hei][row][col]+1){
                    d[nh][nr][nc]=d[hei][row][col]+1;
                    if(maze[nh][nr][nc]=='T'){
                        d[nh][nr][nc]=d[nh][nr][nc]+2;
                    }
                    element nextposition;
                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;
                    addq(nextposition);
                }
            }

        }
        
        for(i=0;i<4;i++){
            nr = row+move[i].vert;
            nc = col+move[i].horiz;
            nh = hei+move[i].hei;

            if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]>d[hei][row][col]+1){
                d[nh][nr][nc]=d[hei][row][col]+1;
                if(maze[nh][nr][nc]=='T'){
                    d[nh][nr][nc]=d[nh][nr][nc]+2;
                }
                element nextposition;
                nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;
                addq(nextposition);
            }

        }
        

    }
    return arrive;
}
int pathnum=0;

void dfs(char*** maze,char*** mark,char*** road,int row,int col,int hei,int count){

    int i,j,k;

    if(count>=(min+5)){
        return;
    }
    else{
        int i;
        int nh,nr,nc;
        for(i=0;i<4;i++){
            nr = row+move[i].vert;
            nc = col+move[i].horiz;
            nh = hei+move[i].hei;
            if(mark[nh][nr][nc]!='X'){
                mark[nh][nr][nc]='X';
                road[nh][nr][nc]='*';
                if(maze[nh][nr][nc]=='T'){
                    dfs(maze,mark,road,nr,nc,nh,count+3);
                }

                else{
                    dfs(maze,mark,road,nr,nc,nh,count+1);
                }
                mark[nh][nr][nc]=maze[nh][nr][nc];
                road[nh][nr][nc]=maze[nh][nr][nc];

            }
        }
        if(maze[hei][row][col]=='U'){
            if(mark[hei+1][row][col]!='X'){
                mark[hei+1][row][col]='X';
                road[hei+1][row][col]='*';
                if(maze[hei+1][row][col]=='T'){

                    dfs(maze,mark,road,row,col,hei+1,count+3);

                }
                else if(maze[hei+1][row][col]=='F'){
                    pathnum++;
                }
                else{
                    dfs(maze,mark,road,row,col,hei+1,count+1);
                }
                mark[hei+1][row][col]=maze[hei+1][row][col];
                road[hei+1][row][col]=maze[hei+1][row][col];
            }



        }
        else if(maze[hei][row][col]=='D' && hei>0){
            if(mark[hei-1][row][col]!='X'){

                mark[hei-1][row][col]='X';
                road[hei-1][row][col]='*';
                if(mark[hei-1][row][col]='T'){
                    dfs(maze,mark,road,row,col,hei-1,count+3);
                }
                else{

                    dfs(maze,mark,road,row,col,hei-1,count+1);
                }
                mark[hei-1][row][col]=maze[hei-1][row][col];
                road[hei-1][row][col]=maze[hei-1][row][col];
            }
        }

    }

}

int main(){
    move[0].vert=-1;
    move[0].horiz=0;
    move[0].hei=0;
    move[1].vert=0;
    move[1].horiz=1;
    move[1].hei=0;
    move[2].vert=1;
    move[2].horiz=0;
    move[2].hei=0;
    move[3].vert=0;
    move[3].horiz=-1;
    move[3].hei=0;
    move[4].vert=0;
    move[4].horiz=0;
    move[4].hei=1;
    move[5].vert=0;
    move[5].horiz=0;
    move[5].hei=-1;
    
    char y;
    int i,j,k;

    FILE *pfile;
    char name[50];
    int control;
    FILE *wfile;
    wfile = fopen( ""4108056029output.txt"",""w"" );
    if( NULL == wfile ){
        printf( ""wfile open failure"" );
        return 1;
    }
    else{
        for(control=58;control<=58;control++){
            min = 100000;
            sprintf(name,""test%d.txt"",control);
            pfile = fopen(name,""r"");
            if(NULL==pfile){
                printf(""Open failure"");
                return 1;
            }
            else{
                printf(""reading %s\n"",name);
                
                char* bottom = make1darr(MAXLEN);
                n=0;
                char y;
                bottom[n]=fgetc(pfile);
                while(bottom[n]!='\n'){
                    fgetc(pfile);
                    bottom[++n]=fgetc(pfile);
                    
                }
                char ***maze=make3darr(n/2+1,n+2,n+2);
                char ***road=make3darr(n/2+1,n+2,n+2);
                char ***mark=make3darr(n/2+1,n+2,n+2);
                int ***d=make3darrint(n/2+1,n+2,n+2);
                int len=0;
                int sr,sc,sh;
                for(i=0;i<n/2+1;i++){
                    for(j=0;j<n+2;j++){
                        for(k=0;k<n+2;k++){
                            if(j==0 || k==0 || j==n+1 || k==n+1){
                                maze[i][j][k]='X';
                            }
                            else if(i==0 && j==1){
                                maze[i][j][k]=bottom[k-1];
                            }
                            else if(j > len && j <= n-len && k > len && k <= n-len){
                                fscanf(pfile,""%c "",&maze[i][j][k]);

                            }
                            else{
                                maze[i][j][k]='X';
                            }
                            if(maze[i][j][k]=='S'){
                                sh=i;
                                sr=j;
                                sc=k;
                            }
                            road[i][j][k]=maze[i][j][k];
                            mark[i][j][k]=maze[i][j][k];
                        }
                    }
                    len++;
                }
                fprintf(wfile, ""test %d starts now.\n"",control );
                if(bfs(maze,d,sr,sc,sh)){
                    mark[sh][sr][sc]='X';
                    pathnum=0;
                    dfs(maze,mark,road,sr,sc,sh,0);
                    printf(""Sortest path : %d, Limit: %d, The number of different paths: %d\n\n"",min,min+5,pathnum);
                    fprintf(wfile,""Shortest path: %d, Limit: %d, The number of different paths: %d\n\n"",min,min+5,pathnum);
                }
                else fprintf(wfile,""The maze does not have a path\n"" );
                free(bottom);
                free(maze);
                free(mark);
                free(road);
                free(d);
            }
            fclose(pfile);

        }
    }
    fclose(wfile);
}
",53,1594,3415
"#define MAXLEN 14
#define MAX_STACK_SIZE 100000
#define MAX 455
#define MALLOC(p,s)\
    if(!((p)=malloc(s))){\
        fprintf(stderr,""Insufficient memory"");\
        exit(EXIT_FAILURE);\
    }
char* make1darr(int n){
    char *x;
    MALLOC(x,n*sizeof(*x));
    return x;
}
char*** make3darr(int rows, int cols,int hei){
    char ***x;
    MALLOC(x,rows*sizeof(**x));
    int i,j;
    for(i=0;i<rows;i++){
        MALLOC(x[i],cols*sizeof(**x));
        for(j=0;j<hei;j++){
            MALLOC(x[i][j],hei*sizeof(***x));
        }
    }
    return x;
}

int*** make3darrint(int rows, int cols,int hei){
    int ***x;
    MALLOC(x,rows*sizeof(**x));
    int i,j;
    for(i=0;i<rows;i++){
        MALLOC(x[i],cols*sizeof(**x));
        for(j=0;j<hei;j++){
            MALLOC(x[i][j],hei*sizeof(***x));
        }
    }
    return x;
}
typedef struct{
    short int row;
    short int col;
    short int hei;
    short int dir;
} element;

element stack[MAX_STACK_SIZE];
int top = -1;
void stackFull(){
    fprintf(stderr, ""å çå·²æ»¿ï¼ä¸è½åå å¥åç´ "");
    exit(EXIT_FAILURE);
}
void push(element item){
    if(top >=MAX_STACK_SIZE-1){
        stackFull();
    }
    stack [++top] = item;
}
element pop(){
    if(top==-1){
        fprintf(stderr, ""å çå·²ç©º"");
    }
    return stack[top--];
}

element stack2[MAX_STACK_SIZE];
int top2 = -1;
void push2(element item){
    if(top2 >=MAX_STACK_SIZE-1){
    }
    stack2 [++top2] = item;
}
element pop2(){
    
    return stack2[top2--];
}

element queue[MAX_STACK_SIZE];
int rear = -1;
int front = -1;
void queueFull(){
    fprintf(stderr, ""ä½åå·²æ»¿ï¼ä¸è½åå å¥åç´ "");
    exit(EXIT_FAILURE);
}
void addq(element item){
    if(rear==MAX_STACK_SIZE-1){
        queueFull();
    }
    queue[++rear] = item;
}
element deleteq(){
    if(front==rear){
        fprintf(stderr, ""ä½åå·²ç©º"");
    }
    return queue[++front];
}

typedef struct{
    short int vert;
    short int horiz;
    short int hei;
}offsets;
offsets move[6];


int pathnum=0;
int min=100000;
int step=0;
void path(char*** maze,char*** mark,char*** road,int sr,int sc,int sh,int n,int pnum){
    step=0;
    min=100000;
    pathnum=0;
    top=-1;
    int i,j,k;
    
    element position;
    int row,col,hei,dir;
    int nr,nc,nh;
    int countp=0;
    int found=1;
    int inproad=0;
    position.row = sr;
    position.col = sc;
    position.hei = sh;
    push(position);
    while(top>-1){
        
        position=pop();
        row = position.row;
        col = position.col;
        hei = position.hei;
        dir = position.dir;


        if(!found){
            
            while(top2>-1){
                element lastposition = pop2();
                int lr=lastposition.row;int lc=lastposition.col;int lh=lastposition.hei;int ld=lastposition.dir;
                
                
                if(lr+move[dir].vert==row && lc+move[dir].horiz==col && lh+move[dir].hei==hei ){

                    push2(lastposition);
                    break;
                }
                road[lh][lr][lc]=maze[lh][lr][lc];
                mark[lh][lr][lc]=maze[lh][lr][lc];
                if(maze[lh][lr][lc]=='T'){
                    step=step-3;
                }
                else step--;
                if(maze[lh][lr][lc]=='P'){
                    countp--;
                }
                
            }
        }
        mark[hei][row][col]='X';
        road[hei][row][col]='*';
        if(maze[hei][row][col]=='T'){
            step=step+3;
        }
        else step++;
        if(maze[hei][row][col]=='P'){
            inproad=1;
            countp++;
        }
        if(countp==pnum){
            inproad=0;
        }
        push2(position);

        printf(""now %d %d %d\n"",hei,row,col );
        
        road[hei][row][col]='@';
        printf(""road!! \n"");
        for(i=0;i<n/2+1;i++){
            for(j=i+1;j<n+2-i-1;j++){
                for(k=i+1;k<n+2-i-1;k++){
                    printf(""%c "",road[i][j][k] );
                }
                printf(""\n"");
            }
            printf(""\n"");
        }
        printf(""countp %d\n\n"",countp );
        printf(""mark!! \n"");
        for(i=0;i<n/2+1;i++){
            for(j=i+1;j<n+2-i-1;j++){
                for(k=i+1;k<n+2-i-1;k++){
                    printf(""%c "",mark[i][j][k] );
                }
                printf(""\n"");
            }
            printf(""\n"");
        }
        printf(""countp %d\n\n"",countp );
        printf(""step %d\n\n"",step );
        road[hei][row][col]='*';
        
        if(maze[hei][row][col]=='F' && countp==pnum){
            pathnum++;
            if(min>step){
                min=step;

            }
            printf(""finally------------------------------------------------\n"" );
            
            printf(""road!! \n"");
            for(i=0;i<n/2+1;i++){
                for(j=i+1;j<n+2-i-1;j++){
                    for(k=i+1;k<n+2-i-1;k++){
                        printf(""%c "",road[i][j][k] );
                    }
                    printf(""\n"");
                }
                printf(""\n"");
            }
            printf(""countp %d pnum %d\n"",countp,pnum );
            printf(""step %d\n\n"",step );
            printf(""pathnum %d\n"",pathnum );
            

            
        }
        
        found=0;
        for(i=0;i<4;i++){
            nr = row+move[i].vert;
            nc = col+move[i].horiz;
            nh = hei+move[i].hei;
            if(inproad){
                if(mark[nh][nr][nc]!='X' && maze[nh][nr][nc]=='P'){
                    found=1;
                    

                    element nextposition;
                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;nextposition.dir=i;
                    push(nextposition);
                }
            }
            else{
                if(mark[nh][nr][nc]!='X'){
                    found=1;
                    

                    element nextposition;
                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;nextposition.dir=i;
                    push(nextposition);
                }
            }

        }
        if(maze[hei][row][col]=='U' || maze[hei][row][col]=='P'){
            if(inproad){
                if(mark[nh][nr][nc]!='X' && maze[hei+1][row][col]=='P'){
                    found=1;
                    element nextposition;
                    nextposition.row=row;nextposition.col=col;nextposition.hei=hei+1;nextposition.dir=4;
                    push(nextposition);
                }
            }
            else{
                if(mark[hei+1][row][col]!='X'){
                    
                    found=1;
                    element nextposition;
                    nextposition.row=row;nextposition.col=col;nextposition.hei=hei+1;nextposition.dir=4;
                    push(nextposition);
                }
            }




        }
        if((maze[hei][row][col]=='D'  || maze[hei][row][col]=='P')&& hei>0){
            if(inproad){
                if(mark[nh][nr][nc]!='X' && maze[hei-1][row][col]=='P'){
                    found=1;
                    element nextposition;
                    nextposition.row=row;nextposition.col=col;nextposition.hei=hei-1;nextposition.dir=5;
                    push(nextposition);
                }
            }
            else{
                if(mark[hei-1][row][col]!='X'){
                    
                    found=1;
                    element nextposition;
                    nextposition.row=row;nextposition.col=col;nextposition.hei=hei-1;nextposition.dir=5;
                    push(nextposition);
                }
            }
        }
    }

}



int main(){
    move[0].vert=-1;
    move[0].horiz=0;
    move[0].hei=0;
    move[1].vert=0;
    move[1].horiz=1;
    move[1].hei=0;
    move[2].vert=1;
    move[2].horiz=0;
    move[2].hei=0;
    move[3].vert=0;
    move[3].horiz=-1;
    move[3].hei=0;
    move[4].vert=0;
    move[4].horiz=0;
    move[4].hei=1;
    move[5].vert=0;
    move[5].horiz=0;
    move[5].hei=-1;
    
    int n=0;
    char y;
    int i,j,k;

    FILE *pfile;
    char name[50];
    int control;
    for(control=2;control<=2;control++){
        sprintf(name,""test%d.txt"",control);
        pfile = fopen(name,""r"");
        if(NULL==pfile){
            printf(""Open failure"");
            return 1;
        }
        else{
            printf(""reading %s\n"",name);
            
            char* bottom = make1darr(MAXLEN);
            int n=0;
            char y;
            bottom[n]=fgetc(pfile);
            while(bottom[n]!='\n'){
                fgetc(pfile);
                bottom[++n]=fgetc(pfile);
                
            }
            char ***maze=make3darr(n/2+1,n+2,n+2);
            char ***road=make3darr(n/2+1,n+2,n+2);
            char ***mark=make3darr(n/2+1,n+2,n+2);
            int ***d=make3darrint(n/2+1,n+2,n+2);
            int len=0;
            int sr,sc,sh;
            int pnum=0;
            for(i=0;i<n/2+1;i++){
                for(j=0;j<n+2;j++){
                    for(k=0;k<n+2;k++){
                        if(j==0 || k==0 || j==n+1 || k==n+1){
                            maze[i][j][k]='X';
                        }
                        else if(i==0 && j==1){
                            maze[i][j][k]=bottom[k-1];
                        }
                        else if(j > len && j <= n-len && k > len && k <= n-len){
                            fscanf(pfile,""%c "",&maze[i][j][k]);

                        }
                        else{
                            maze[i][j][k]='X';
                        }
                        if(maze[i][j][k]=='S'){
                            sh=i;
                            sr=j;
                            sc=k;
                        }
                        if(maze[i][j][k]=='P'){
                            pnum++;
                        }
                        road[i][j][k]=maze[i][j][k];
                        mark[i][j][k]=maze[i][j][k];
                    }
                }
                len++;
            }
            
            FILE *wfile;
            wfile = fopen( ""4108056029output.txt"",""a"" );
            if( NULL == wfile ){
                printf( ""wfile open failure"" );
                return 1;
            }
            else{
                fprintf(wfile, ""test%d Starts now.\n"",control );

                
                if(1){
                    
                    mark[sh][sr][sc]='X';
                    pathnum=0;
                    path(maze,mark,road,sr,sc,sh,n,pnum);
                    printf(""Shortest path: %d, The number of different paths: %d\n\n"",min-1,pathnum);
                    fprintf(wfile,""Shortest path: %d, The number of different paths: %d\n\n"",min-1,pathnum);
                }
                else fprintf(wfile,""The maze does not have a path\n"" );
            }
            free(bottom);
            free(maze);
            free(mark);
            free(road);
            free(d);
        }
        fclose(pfile);

    }
}
",53,1595,3969
"#define MAXLEN 14
#define MALLOC(p,s)\
    if(!((p)=malloc(s))){\
        fprintf(stderr,""Insufficient memory"");\
        exit(EXIT_FAILURE);\
    }
char* make1darr(int n){
    char *x;
    MALLOC(x,n*sizeof(*x));
    return x;
}
char*** make3darr(int rows, int cols,int hei){
    char ***x;
    MALLOC(x,rows*sizeof(**x));
    int i,j;
    for(i=0;i<rows;i++){
        MALLOC(x[i],cols*sizeof(**x));
        for(j=0;j<hei;j++){
            MALLOC(x[i][j],hei*sizeof(***x));
        }
    }
    return x;
}
int main(){
    FILE *ans;
    FILE *myans;
    int control;
    char ansname[50],myansname[50];
    FILE *pfile;
    char name[50];

    for(control=1;control<=100;control++){
        sprintf(ansname,""test%d_ans.txt"",control);
        sprintf(myansname,""4108056029test%d_ans.txt"",control);
        sprintf(name,""test%d.txt"",control);
        pfile = fopen(name,""r"");
        ans=fopen(ansname,""r"");
        myans=fopen(myansname,""r"");
        if(NULL==ans || NULL == myans){
            printf(""Open failure\n"");
            if(NULL == myans){
                printf(""my ans Open failure\n"");
            }
            if(NULL == ans){
                printf(""ans Open failure\n"");

            }
            return 1;
        }

        else{
            int i,j,k;
            int nans,nmy;
            fscanf(ans,""%*[a-zA-Z] %*[a-zA-Z]: "");
            fscanf(ans,""%d"",&nans);
            printf(""%d: %d "",control,nans );
            fscanf(myans,""%*[a-zA-Z] %*[a-zA-Z]: "");
            fscanf(myans,""%d"",&nmy);
            printf(""%d\n"",nmy );
            if(nans!=nmy){
                printf(""path length error in test%d\n"",control);
                printf(""ans : %d   myans : %d\n\n"",nans,nmy );
            }

            fscanf(ans,""%*s"");
            
            
            fscanf(myans,""%*s"");
            
            char* ansb = make1darr(MAXLEN);
            char* myb = make1darr(MAXLEN);
            char* bottom = make1darr(MAXLEN);
            int n=0;
            char y;
            fgetc(ans);
            fgetc(myans);
            
            
            
            ansb[n]=fgetc(ans);
            myb[n]=fgetc(myans);
            bottom[n]=fgetc(pfile);
            
            while(ansb[n]!='\n' || myb[n]!='\n'){
                fgetc(ans);
                fgetc(myans);
                fgetc(pfile);
                ansb[++n]=fgetc(ans);
                myb[n]=fgetc(myans);
                bottom[n]=fgetc(pfile);
            }
            
            int len=0;
            char ansm[n/2+1][n][n],mym[n/2+1][n][n],maze[n/2+1][n][n];
            for(i=0;i<n/2+1;i++){
                for(j=0;j<n;j++){
                    for(k=0;k<n;k++){
                        if(i==0 && j==0){
                            
                            ansm[i][j][k]=ansb[k];
                            mym[i][j][k]=myb[k];
                            maze[i][j][k]=bottom[k];

                        }
                        else if(j >= len && j < n-len && k >= len && k < n-len){
                            

                            fscanf(ans,""%c "",&ansm[i][j][k]);
                            
                            fscanf(myans,""%c "",&mym[i][j][k]);
                            fscanf(pfile,""%c "",&maze[i][j][k]);

                        }
                        else{
                            
                            mym[i][j][k]='X';
                            ansm[i][j][k]='X';
                            maze[i][j][k]='X';
                        }

                    }
                }
                len++;
            }
            
            int check=0,counter=0;
            int hei[10],row[10],col[10];
            char ans[10],myans[10];
            for(i=0;i<n/2+1;i++){
                for(j=0;j<n;j++){
                    for(k=0;k<n;k++){
                        if(mym[i][j][k]!=ansm[i][j][k]){
                            
                            
                            row[counter]=j;
                            col[counter]=k;
                            hei[counter]=i;
                            ans[counter]=ansm[i][j][k];
                            myans[counter]=mym[i][j][k];
                            counter++;
                            check=1;
                        }
                    }
                    
                }
                
            }

            if(check){
                if((((row[0]+1==row[1]  || row[0]-1==row[1]) && (col[0]+1==col[1] ||  col[0]-1==col[1])) &&(ans[0]==myans[1]&&ans[1]==myans[0])&&counter==2)){
                    
                }
                else {

                    printf(""map error\n"");
                    for(i=0;i<counter;i++){
                        printf(""in %d %d %d\n"",hei[i],row[i],col[i]);
                        printf(""ans : %c  myans : %c\n"", ans[i],myans[i]);
                    }
                    printf(""\n----------myans & ans---------\n"" );
                    for(i=0;i<n/2+1;i++){
                        for(j=0;j<n;j++){
                            for(k=0;k<n;k++){
                                printf(""%c "",mym[i][j][k] );
                            }
                            printf(""    "");
                            for(k=0;k<n;k++){
                                printf(""%c "",ansm[i][j][k] );
                            }
                            printf(""    "");
                            for(k=0;k<n;k++){
                                printf(""%c "",maze[i][j][k] );
                            }
                            printf(""\n"");
                        }
                        printf(""\n"");
                    }

                }

            }
        }
        fclose(ans);
        fclose(myans);
    }

}
",53,1596,1882
"#define MAX_ALUMNO 60
#define MAX_CALIFICACIONES 4
#define MAX_ASISTENCIA 5

struct estudiante{
    int matricula;
    char nombre[MAX_ALUMNO];
    float calificaciones[MAX_CALIFICACIONES];
    int asistencias[MAX_ASISTENCIA];
} e5 = {345, ""Karla Ramirez"", {0.0, 0.0, 0.0, 0.0}, {0, 0, 0, 0, 0}};

struct estudiante e1, e2, e3;
struct estudiante e6;
struct estudiante e4 = { 123, ""Juan Carlos"", {0.0 , 0.0, 0.0, 0.0}, {0, 0, 0, 0, 0} };




int main(){
    int x1 = 1;
    int x2, x3, x4, x5 = 10;
    int numeros[] = {1, 2, 3, 4};
    x2 = x1; 

    printf(""Ingresa la matricula:"");
    scanf(""%d"", &e1.matricula);
    printf(""Ingresa el nombre:"");
    
    fflush(stdin);
    fgets(e1.nombre, MAX_ALUMNO, stdin);

    for (int i = 0; i < MAX_CALIFICACIONES; i++){
        printf(""Ingresa calificacion %d: "", i + 1);
        scanf(""%f"", &e1.calificaciones[i]);   
    }

    for (int i = 0; i < MAX_ASISTENCIA; i++){
        printf(""Ingresa asistencia del dÃ­a %d: "", i + 1);
        scanf(""%d"", &e1.asistencias[i]);   
    }
    

    printf(""\n\nDatos del alumno capturado:\n"");
    printf(""Matricula: %d\n"", e1.matricula);
    printf(""Nombre: %s\n"", e1.nombre);
    for (int i = 0; i < MAX_CALIFICACIONES; i++){
        printf(""CalifaciÃ³n %d: %f\n"", i+1, e1.calificaciones[i]);
    }
    for (int i = 0; i < MAX_ASISTENCIA; i++){
        printf(""Asistencias %d: %d\n"", i+1, e1.asistencias[i]);
    }

    char mensaje[] = ""hola"";
    mensaje = ""hola mundo"";
    strcpy(mensaje, ""hola mundo"");

    e2 = e1;
    
    e3.matricula = 456;
    
    strcpy(e3.nombre, ""Juan Carlos"");
    e3.calificaciones[0] = 10.0;
    e3.calificaciones[1] = 10.0;
    e3.calificaciones[2] = 10.0;
    e3.calificaciones[3] = 10.0;
    e3.asistencias[0] = 1;
    e3.asistencias[4] = 1;

    int x = 7;
    int *p_num;

    p_num = &x;
    *p_num = 10;
    printf(x);
    int arreglo_numeros = {1, 2, 3, 4};
    int *arreglo;
    arreglo = &arreglo_numeros;
    arreglo[0] = 5;
    *(arreglo + 0) = 5;

    struct estudiante *p_e1;
    p_e1 = &e1;

    p_e1->matricula = 567;
    strcpy(p_e1->nombre, ""Jose Garcia"");
    p_e1->calificaciones[0] = 10.0;
    p_e1->calificaciones[1] = 10.0;
    p_e1->calificaciones[2] = 10.0;
    p_e1->calificaciones[3] = 10.0;
    p_e1->asistencias[0] = 1;

    return 0;
}",54,1597,1118
"#define INI 1
#define FIN 1000

int generar_aleatorio(int inicio, int final);
int menu();
void jugar();


int main(void){
    srand(time(NULL));
    char respuesta = 'N';
    do {
        int op = menu();
        switch (op) {
        case 1: jugar();
            break;
        default:
            break;
        }
        printf(""Deseas continuar jugando? [S]i o [N]o \n"");
        fflush(stdin);
        scanf(""%c"", &respuesta);
    } while( respuesta == 'S');
    
    return 0;
}

int menu(){
    int opcion;
    system(""clear"");
    printf(""Juedo de adivina un nÃºmero.\n"");
    printf(""1. Jugar\n"");
    printf(""2. Salir\n"");
    printf(""Elije una opciÃ³n:"");
    scanf(""%d"", &opcion);
    return opcion;
}

int generar_aleatorio(int inicio, int final){
    return rand() % (final - inicio + 1) + inicio;
}

void jugar(){
    int alea = generar_aleatorio(INI, FIN);
    printf(""Adivina el nÃºmero entre %d - %d: "", INI, FIN);
    while(1) {
        int respuesta;
        
        scanf(""%d"", &respuesta);
        if( respuesta == alea){
            printf(""Felicidades!!! Adivinaste...\n"");
            printf(""Presione una tecla para continuar..."");
            fflush(stdin);
            getchar();
            break;
        } else {
            if( respuesta < alea){
                printf(""El valor es mÃ¡s grande\n"");
            } else {
                printf(""El valor es mÃ¡s pequeÃ±o\n"");
            }
        }
        printf(""Intenta de nuevo adivinar el nÃºmero entre %d - %d: "", INI, FIN);
    }
}",54,1598,533
"void suffle(int [][13]);
void deal( const int [][13], const char *[], const char *[]);
void hand( const int [][13]);

int main(){
    const char *suit[4] = {""Hearts"", ""Diamons"", ""Clubs"", ""Spades""};
    const char *face[13] = {""Ace"", ""Deuce"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"",
     ""Nine"", ""Ten"", ""Jack"", ""Queen"", ""King"" };

    int deck[4][13] = {0};

    srand(time (NULL));

    suffle(deck);
    deal(deck, face, suit);

    return 0;
}

void suffle(int wDeck[][13]){
    int card, row, column;

    for(card = 1; card <= 52; card++){
        row = rand() % 4;
        column = rand() % 13;

        while (wDeck[row][column] != 0){
            row = rand() % 4;
            column = rand() % 13;
        }

        wDeck[row][column] = card;
    }
}

void deal( const int wDeck[][13], const char *wFace[], const char *wSuit[]){
    int card, row, column;
    for ( card = 1; card <= 5; card++){
        for ( row = 0; row <= 3; row++){
            for ( column = 0; column <= 12; column++){
                if(wDeck[row][column] == card)
                    printf(""%5s of %-8s%c"", wFace[column], wSuit[row], (card % 2) == 0 ? '\n' : '\t');
            }
            
        }
        
    }
    
}

void hand( const int [][13]){

}",54,1599,494
"void leer_temperaturas(float **t, int f, int c);
void mostrar_temperaturas(float **t, int f, int c);

int main() {
    
    float **temperaturas = NULL;
    int tamanno_filas, frecuencia, tamanno_columnas;

    printf(""Ingrese la cantidad de dÃ­as que se registrarÃ¡n tempereraturas:"");
    scanf(""%d"", &tamanno_filas);
    printf(""Ingrese cada cuanta horas se registrarÃ¡n temperatural por dÃ­a"");
    scanf(""%d"", &frecuencia);
    tamanno_columnas = 24 / frecuencia; 

    temperaturas = (float **) malloc (tamanno_filas * sizeof(float *));
    if( temperaturas == NULL){
        printf(""No se reservo la memoria"");
        return -1;
    }

    for (int i = 0; i < tamanno_filas; i++) {
        temperaturas[i] = (float *) malloc (tamanno_columnas * sizeof(float));
        if(temperaturas[i] == NULL){
            printf(""No se reervÃ³ la memoria"");
            return -1;
        }
    }

    leer_temperaturas(temperaturas, tamanno_filas, tamanno_columnas);
    mostrar_temperaturas(temperaturas, tamanno_filas, tamanno_columnas);

    for (int i = 0; i < tamanno_columnas; i++){
        free(temperaturas[i]);
    }
    free(temperaturas);
    
    return 0;
}

void leer_temperaturas(float **t, int f, int c){
    for (int i = 0; i < f; i++){
        for (int j = 0; j < c; j++){
            printf(""Ingrese la temperatura %d del dia %d:"", j+1, i+1);
            scanf(""%f"", &t[i][j]);
        }
    }
}

void mostrar_temperaturas(float **t, int f, int c){
    for (int i = 0; i < f; i++){
        for (int j = 0; j < c; j++){
            printf(""%f\t"", t[i][j]);
        }
        printf(""\n"");
    }
    
}",54,1600,604
"void agregar_alumno(){
    printf(""Ingresa la matrÃ­cula:"");
    scanf(""%d"", &matricula);
    
    printf(""Ingresa el inical del nombre del alumno:"");
    scanf("" %c"", &inicial_nombre);
    printf(""Ingresa calificaciÃ³n 1:"");
    scanf(""%f"", &calificacion1);
    printf(""Ingresa calificaciÃ³n 2:"");
    scanf(""%f"", &calificacion2);
    printf(""Ingresa calificaciÃ³n 3:"");
    scanf(""%f"", &calificacion3);
    printf(""Ingresa calificaciÃ³n final:"");
    scanf(""%f"", &calificacionf);
}

void imprimir_menu(){
    printf(""Menu de opiones\n"");
    printf(""1. Agregar alumno\n"");
    printf(""2. Modificar calificaciones\n"");
    printf(""3. Imprimir datos del alumno\n"");
    printf(""4. Salir\n"");
    printf(""Ingresa una opciÃ³n: \n"");
}

int main () {
    srand(time(0));
    int opcion;
    while (opcion != 4) {
        imprimir_menu();
        scanf(""%d"", &opcion);
        switch (opcion) {
            case 1: agregar_alumno();
                break;
            case 2: menu_modificacion_calificaciones(&calificacion1, &calificacion2, &calificacion3, &calificacionf);
                break;
            case 3: imprimir_alumno();
                break;
            case 4:
                break;
            default:
                break;
        }

    }
    return 0;
}


float promedio(float c1, float c2, float c3, float cf){
    int potencia = pow(2,3);
    float prom = (((c1 + c2 + c3) / 3) + (cf)) /2;
    return prom;
}

float minimo(float c1, float c2, float c3, float cf){
    float min = c1; 
    if (c1 > c2) { 
        min = c2; 
    }
    if (min > c3){ 
        min = c3; 
    }
    if (min > cf) { 
        min = cf;
    }
    return min;
}

float maximo(float c1, float c2, float c3, float cf){
    float max = c1; 
    if (c1 < c2) { 
        max = c2; 
    }
    if (max < c3){ 
        max = c3; 
    }
    if (max < cf) { 
        max = cf;
    }
    return max;
}
",54,1601,738
"struct estudiant_{
    int id;
    int matricula;
    char name[60];
    float calificaciones[4];
    int asistencias[5];
};

typedef struct estudiant_ estudiante;

int main(){
    FILE *cfPtr;

    if((cfPtr = fopen(""estudiantes.dat"", ""rb+"")) == NULL){
        puts(""No se pudo abrir el archivo...\n"");
    } else {

        printf(""%s\t%s\t%s\n"", ""Id"", ""MatrÃ­cula"", ""Nombre"");
        while(!feof(cfPtr)){
            estudiante estudiante_recuperado = {0, 0, """", {0.0}, {-1}};

            int resultado = fread(&estudiante_recuperado, sizeof(estudiante), 1, cfPtr);

            if(resultado != 0 && estudiante_recuperado.id != 0 && estudiante_recuperado.matricula == 123){
                printf(""%d\t%d\t%s"", estudiante_recuperado.id, estudiante_recuperado.matricula, 
                estudiante_recuperado.name);
            }
        }

        fclose(cfPtr);
    }

    return 0;
}",54,1602,328
"void leer_calorias(int a[], int tam);
float promedio_calorias(int a[], int tam);

int main(){

    int *calorias = NULL;
    char respuesta;
    int posicion = 1;

    calorias = (int *) malloc ( posicion * sizeof(int));

    do {
        calorias = (int *) realloc (calorias, posicion);
        leer_calorias(calorias, posicion);
        posicion++;
        printf(""Desea agregar consumo de calorias de otro dÃ­a?"");
        fflush(stdin);
        respuesta = getchar();  
    } while(respuesta != 'n');

    printf(""El promedio de calorÃ­as consumidas en %d dÃ­as fue %.2f\n""
        , posicion - 1
        , promedio_calorias(calorias, posicion - 1));
        
    free(calorias);
    
    return 0;
}

void leer_calorias(int a[], int posicion){
    printf(""Ingrese las calorias consumidas en el dia: "");
    scanf(""%d"", &a[posicion - 1]);
}

float promedio_calorias(int a[], int tam){
    int suma = 0;
    for (int i = 0; i < tam; i++){
        suma += a[i];
    }
    return (suma/tam);
}",54,1603,380
"#define INICIO 1
#define FIN 1000

int aleatorio(int inicio, int fin);
void menu();
void jugar();

int main(void){
    srand(time(0));
    int opcion;

    while(1){
        menu();
        scanf(""%d"", &opcion);
        if(opcion == 1){
            jugar();
        } else 
            break;
    }
    return 0;
}

void jugar(){
    int respuesta;
    int numero = aleatorio(INICIO, FIN);
    int intentos = 1;
    system(""clear"");
    do {
        printf(""NÃºmero de intentos: %d\n"", intentos);
        printf(""Adiviana un nÃºmero entero entre [%d - %d]"", INICIO, FIN);
        scanf(""%d"", &respuesta );
        intentos++;
        if(respuesta > numero) {
            printf(""NÃºmero muy alto\n"");
        } else {
            if (respuesta < numero)
                printf(""Numero muy bajo\n"");
            else{
                printf(""Excelente!! Adivinaste el nÃºmero!!\n"");  
                fflush(stdin); 
                printf(""Presiona una tecla para continuar..."");
                getchar();
            }
        }
        
    } while (respuesta != numero );
}

void menu(){
    system(""clear"");
    printf(""1. Iniciar juego.\n"");
    printf(""2. Salir\n\n"");
    printf(""Ingres una opciÃ³n:"");
}

int aleatorio(int inicio, int fin){
    return rand() % (fin - inicio + 1) + inicio;
}",54,1604,442
"void fibonacci(int posicion){
    
    long int i;
    unsigned long int actual = 0, siguiente = 1, temporal;
    for(i =0; i < posicion; i++){
        printf(""%ld, "", actual);
        temporal = siguiente;
        siguiente = siguiente + actual;
        actual = temporal;
    }
}

int fibonacci_recursivo(int posicion){
    if (posicion == 0)
        return 0;
    if (posicion == 1)
        return 1;
    if (posicion == 2)
        return 1;
    else
        return fibonacci_recursivo(posicion - 1) + fibonacci_recursivo(posicion - 2);
}

int main(){
    printf(""fiboniacci iterativo:"");
    fibonacci(6);
    printf(""\n%d \n"", fibonacci_recursivo(5));
    return 0;
}",54,1605,237
"void leer_calorias(int a[], int tam);
float promedio_calorias(int a[], int tam);

int main(){
    
    int *calorias = NULL;
    int tamanno;

    printf(""Ingresa cantidad de dÃ­as en que se registrarÃ¡n las calorÃ­as:"");
    scanf(""%d"", &tamanno);

    calorias = (int *) malloc (tamanno * sizeof(int));
    if (calorias != NULL){
       leer_calorias(calorias, tamanno);
       printf(""El promedio de calorÃ­as consumidas en %d dÃ­as fue %.2f\n""
        , tamanno
        , promedio_calorias(calorias, tamanno));
        free(calorias);
    } else {
        printf(""No se pudo reservar la memoria\n"");
    }
    
    
    
    return 0;
}


void leer_calorias(int a[], int tam){
    for (int i = 0; i < tam; i++){
        printf(""Ingrese las calorias consumidas en el dia: "");
        scanf(""%d"", &a[i]);
    }
    
}

float promedio_calorias(int a[], int tam){
    int suma = 0;
    for (int i = 0; i < tam; i++){
        suma += a[i];
    }
    return (suma/tam);
}",54,1606,382
"#define true 1
#define false 0

int main(){
    float f;
    double d;
    long double ld;
    int i;
    long l;
    long long ll;
    char c = 97;
    short s;

    int array[10] = {1, 2, 3, 4, 5, 6, 7, 10};
    int *p_array = array;

    printf(""TamaÃ±o de c es: %lu, el tamaÃ±o de char es:  %lu\n"", sizeof c, sizeof(char));
    printf(""TamaÃ±o de i es: %lu, el tamaÃ±o de int es:  %lu\n"", sizeof i, sizeof(int));
    printf(""TamaÃ±o de s es: %lu, el tamaÃ±o de short es:  %lu\n"", sizeof s, sizeof(short));
    printf(""TamaÃ±o de l es: %lu, el tamaÃ±o de long es:  %lu\n"", sizeof l, sizeof(long));
    printf(""TamaÃ±o de ll es: %lu, el tamaÃ±o de long long es:  %lu\n"", sizeof l, sizeof(long long));
    printf(""TamaÃ±o de f es: %lu, el tamaÃ±o de float es:  %lu\n"", sizeof f, sizeof(float));
    printf(""TamaÃ±o de d es: %lu, el tamaÃ±o de double es:  %lu\n"", sizeof d, sizeof(double));
    printf(""TamaÃ±o de ld es: %lu, el tamaÃ±o de long double es:  %lu\n"", sizeof ld, sizeof(long double));
    
    printf(""TamaÃ±o del arreglo es %lu\n"", sizeof array);
    printf(""TamaÃ±o del size_t es %lu\n"", sizeof(size_t));
    printf(""TamaÃ±o del apuntador al arreglo es %lu\n"", sizeof p_array);
    printf(""*p_array %d\n"", *p_array);
    printf(""p_array %p\n"", p_array);


    return false;
}",54,1607,547
"struct estudiant_{
    int id;
    int matricula;
    char name[60];
    float calificaciones[4];
    int asistencias[5];
};

typedef struct estudiant_ estudiante;

int main(){
    FILE *cfPtr;

    if((cfPtr = fopen(""estudiantes.dat"", ""rb+"")) == NULL){
        puts(""No se pudo abrir el archivo...\n"");
    } else {
        estudiante estudiante_nuevo = {0, 0, """", {0.0}, {-1}};

        printf(""Ingrese id [1 - 100]:"");
        scanf(""%d"", &estudiante_nuevo.id);

        while( estudiante_nuevo.id != 0){
            printf(""Ingresar matricula:"");
            scanf(""%d"", &estudiante_nuevo.matricula);
            printf(""Ingresar nombre del estudiante:"");
            scanf(""%s"", estudiante_nuevo.name);
            
            fseek(cfPtr, (estudiante_nuevo.id - 1 ) * sizeof(estudiante), SEEK_SET);

            fwrite(&estudiante_nuevo, sizeof(estudiante), 1, cfPtr);

            printf(""Ingrese un id [1-100]"");
            scanf(""%d"", &estudiante_nuevo.id);
        }

        fclose(cfPtr);
    }

    return 0;
}",54,1608,382
"#define MAX_ALUMNO 60
#define MAX_CALIFICACIONES 4
#define MAX_ASISTENCIA 5

struct direccion{
    char calle[60];
    char numero_exterior[5];
    char numer_interior[5];
    char colonia[60];
    char municipio[60];
    char entidad[60];
    int cp;
};

typedef struct direccion mi_direccion;
typedef int mi_integercito;

struct estudiante{
    int matricula;
    char nombre[MAX_ALUMNO];
    mi_direccion direccion_estudiante;
    float calificaciones[MAX_CALIFICACIONES];
    int asistencias[MAX_ASISTENCIA];
};

typedef struct estudiante mi_estudiante;

struct estudiante e1;
mi_estudiante e2;
mi_integercito x1, x2, x3, x100;
int arreglo_x[100];

mi_estudiante lista_estudiantes[100];

int main(){

    e1.matricula = 123;
    strcpy(e1.nombre, ""Juan Carlos"");
    strcpy(e1.direccion_estudiante.calle, ""Vicente Guerrero"");
    strcpy(e1.direccion_estudiante.numer_interior, ""2A"");
    strcpy(e1.direccion_estudiante.numero_exterior, ""234"");
    strcpy(e1.direccion_estudiante.colonia, ""Centro Historico"");
    strcpy(e1.direccion_estudiante.municipio, ""Huajuapan"");
    strcpy(e1.direccion_estudiante.entidad,""Oaxaca"");
    e1.direccion_estudiante.cp = 67000;
    e1.calificaciones[0] = 10.0;
    e1.asistencias[0] = 1;

    printf(""Datos del estudiante:\n"");
    printf(""DirecciÃ³n, calle: %s"", e1.direccion_estudiante.calle);


    lista_estudiantes[0] = e1;

    return 0;
}",54,1609,582
"int es_primo(int numero);

int main(){
    int resultado, primo = 0, no_primo = 0;
    for(int numero = 1; numero <= 10000; numero++) {
        resultado = es_primo(numero);
        if(resultado == 1){
            
            primo++;
        } else {
            
            no_primo++;
        }
    } 

    printf(""Numero de primos %d, numero de no primos %d\n"", primo, no_primo);
    return 0;
}



int es_primo(int numero){
    for (int i = 2; i <= sqrt(numero); i++){
        if ( numero % i == 0){
            return 0;
        }
    }
    return 1;
}",54,1610,205
"void leer_calorias(int a[], int tam);
float promedio_calorias(int a[], int tam);

int main(){
    
    int *calorias = NULL;
    int tamanno;

    printf(""Ingresa cantidad de dÃ­as en que se registrarÃ¡n las calorÃ­as:"");
    scanf(""%d"", &tamanno);

    
    
    calorias = (int *) calloc (tamanno, sizeof(int));
    if (calorias != NULL){
       
       printf(""El promedio de calorÃ­as consumidas en %d dÃ­as fue %.2f\n""
        , tamanno
        , promedio_calorias(calorias, tamanno));
        free(calorias);
    } else {
        printf(""No se pudo reservar la memoria\n"");
    }
    
    
    
    return 0;
}


void leer_calorias(int a[], int tam){
    for (int i = 0; i < tam; i++){
        printf(""Ingrese las calorias consumidas en el dia: "");
        scanf(""%d"", &a[i]);
    }
    
}

float promedio_calorias(int a[], int tam){
    int suma = 0;
    for (int i = 0; i < tam; i++){
        suma += a[i];
    }
    return (suma/tam);
}",54,1611,373
"#define MAX 100
#define MAX_ASISTENCIA 5
#define MAX_CALIFICACIONES 4
#define MAX_NOMBRE 60
#define MAX_ALUMNOS 4
#define MAX_GRUPOS 3

struct estudiant_{
    int matricula;
    char nombre[MAX_NOMBRE];
    float calificaciones[MAX_CALIFICACIONES];
    int asistencias[MAX_ASISTENCIA];
};

typedef struct estudiant_ estudiante;


struc grup_{
    char id[];
    int semestre;
    int numero_estudiantes;
    estudiante lista_estudiantes[MAX_ALUMNOS];
}

typedef struct grup_ grupo;
grupo lista_grupos[MAX_GRUPOS];

void imprimir_menu();
void agregar_alumno();
void modificar_alumno();
void imprimir_alumno();
void imprimir_asistencias(const int posicion);
void imprimir_menu_calificaciones();
void menu_modificacion_calificaciones();
void imprimir_alumnos_en_tabla();
void imprimir_alumno_por_fila(int posicion);

int posicion_alumno();
void pase_asistencia();
float promedio(float *c);
float minimo(float *c);
float maximo(float *c);

int siguiente_alumno = 0;

int main(){
    int opcion;
    while (1) {
        imprimir_menu();
        scanf(""%d"", &opcion);
        switch (opcion) {
            case 1: agregar_alumno();
                break;
            case 2: modificar_alumno();
                break;
             case 3: menu_modificacion_calificaciones();
                 break;
            case 4: imprimir_alumno();
                 break;
            case 5: imprimir_alumnos_en_tabla();
                break;
            case 6: pase_asistencia();
                 break;
            case 7:
                return 0;
                break;
            default:
                break;
        }
    }
    return 0;
}

void imprimir_menu(){
    char mensaje[MAX] = ""SISTEMA DE CONTROL DE CALIFICACIONES"";
    system(""clear"");
    printf(""----------------------------------------------\n"");
    printf(""%s\n"", mensaje);
    printf(""----------------------------------------------\n"");
    printf(""Menu de opciones\n"");
    printf(""----------------------------------------------\n"");
    printf(""1. Agregar alumno\n"");
    printf(""2. Modificar alumno\n"");
    printf(""3. Modificar calificaciones\n"");
    printf(""4. Imprimir datos del alumno\n"");
    printf(""5. Lista de alumnos\n"");
    printf(""6. Pase de lista\n"");
    printf(""7. Salir\n"");
    printf(""Ingresa una opciÃ³n: \n"");
}

void agregar_alumno(){
    if(siguiente_alumno == MAX_ALUMNOS){
        printf(""No se puede agregar nuevo alumno, espacio insuficiente..."");
        puts(""Presiona cualquier tecla para continuar..."");
        fflush(stdin);
        getchar();
    } else {
        estudiante nuevo_alumno;
        printf(""Ingresa la matrÃ­cula:"");
        scanf(""%d"", &nuevo_alumno.matricula);
        fflush(stdin);
        printf(""Ingresa el nombre del alumno:"");
        fgets(nuevo_alumno.nombre, 60, stdin);
        nuevo_alumno.calificaciones[0] = 0.0;
        nuevo_alumno.calificaciones[1] = 0.0;
        nuevo_alumno.calificaciones[2] = 0.0;
        nuevo_alumno.calificaciones[3] = 0.0;
        puts(""Datos almacenado correctamente..."");
        puts(""Presiona cualquier tecla para continuar..."");
        fflush(stdin);
        getchar();
        lista_estudiantes[siguiente_alumno] = nuevo_alumno;
        siguiente_alumno++;
    } 
}

void modificar_alumno(){
    system(""clear"");
    puts(""\tMenu para cambio de nombre..."");
    int posicion = posicion_alumno();
    estudiante estudiante_seleccionado = lista_estudiantes[posicion];
    printf(""El nombre del alumno es: %s\n"", estudiante_seleccionado.nombre);
    printf(""Ingresa el nuevo nombre: "");
    fflush(stdin);
    fgets(estudiante_seleccionado.nombre, 60, stdin);
    lista_estudiantes[posicion] = estudiante_seleccionado;
}

int posicion_alumno(){
    int posicion;
    printf(""\nIngresa la posicion [1 -  %d]: "", MAX_ALUMNOS);
    scanf(""%d"", &posicion);
    posicion--;
    return posicion;
}

void imprimir_alumno(){
    int posicion = posicion_alumno();
    
    printf(""MatrÃ­cula: %d\n"", lista_estudiantes[posicion].matricula);
    printf(""Nombre del alumno: %s\n"", lista_estudiantes[posicion].nombre);
    printf(""CalificaciÃ³n 1: %.2f\n"", lista_estudiantes[posicion].calificaciones[0]); 
    printf(""CalificaciÃ³n 2: %.2f\n"", lista_estudiantes[posicion].calificaciones[1]); 
    printf(""CalificaciÃ³n 3: %.2f\n"", lista_estudiantes[posicion].calificaciones[2]); 
    printf(""CalificaciÃ³n f: %.2f\n"", lista_estudiantes[posicion].calificaciones[3]); 
    float prom = promedio(lista_estudiantes[posicion].calificaciones);
    printf(""Promedio : %.2f\n"", prom);
    float m;
    m = minimo(lista_estudiantes[posicion].calificaciones);
    printf(""CalificaciÃ³n mÃ­nima: %.2f\n"", m);
    m = maximo(lista_estudiantes[posicion].calificaciones);
    printf(""CalificaciÃ³n mÃ¡xima: %.2f\n"", m);
    imprimir_asistencias(posicion);
    fflush(stdin);
    getchar();
}

float promedio(float *c){
    float prom;
    float acumulador = 0.0;
    for (int i = 0; i < MAX_CALIFICACIONES - 1; i++)
    {
        acumulador += c[i];
    }
    prom = acumulador / MAX_CALIFICACIONES - 1;
    prom = (prom + c[MAX_CALIFICACIONES - 1]) / 2;
    return prom;
}

float minimo(float *c){
    float min = c[0];
    for (int i = 1; i < MAX_CALIFICACIONES; i++){
        if (min > c[i]){
            min = c[i];
        }
    }
    return min;
}

float maximo(float *c){
    float max = c[0];
    for (int i = 1; i < MAX_CALIFICACIONES; i++){
        if (max < c[i]){
            max = c[i];
        }
    }
    return max;
}

void imprimir_asistencias(const int posicion){
    printf(""Asistencias: "");
    for (int i = 0; i < MAX_ASISTENCIA-1; i++)
    {
        if (lista_estudiantes[posicion].asistencias[i] == 1)
            printf(""%s"", ""A, "");    
        else 
            printf(""%s"", ""F, "");         
    }
    (lista_estudiantes[posicion].asistencias[MAX_ASISTENCIA-1] == 1)?printf(""%s"", ""A""):printf(""%s"", ""F"");
    printf(""\n"");
}

void imprimir_menu_calificaciones(){
    printf(""1. Modificar calificaciÃ³n 1:\n"");
    printf(""2. Modificar calificaciÃ³n 2:\n"");
    printf(""3. Modificar calificaciÃ³n 3:\n"");
    printf(""4. Modificar calificaciÃ³n f:\n"");
    printf(""5. Salir:\n"");
    printf(""Ingresa una opciÃ³n:"");
}

void menu_modificacion_calificaciones(){
    int opt = 0;
    int posicion = posicion_alumno();
    while(opt != 5) {
        imprimir_menu_calificaciones();
        scanf(""%d"", &opt);
        if (opt < MAX_CALIFICACIONES + 1) {
            printf(""La calificaciÃ³n actual es: %f\n"", 
                lista_estudiantes[posicion].calificaciones[opt-1]);
            printf(""Ingresa nueva calificaciÃ³n %d:"", opt-1);
            scanf(""%f"", &lista_estudiantes[posicion].calificaciones[opt-1]);
        }
    }
}

void pase_asistencia(){
    int dia;
    printf(""Pase de asistencia...\n"");
    int posicion = posicion_alumno();
    printf(""Indicar dia de asistencia [1 - %d]: "", MAX_ASISTENCIA);
    scanf(""%d"", &dia);
    printf(""[0]=Falta o [1]=Asistencia: "");
    scanf(""%d"", &lista_estudiantes[posicion].asistencias[dia - 1]);
}

void imprimir_alumnos_en_tabla(){
    system(""clear"");
    printf(""----------------------------------------------\n"");
    printf(""Matricula\tNombre\t 1er\t2o\t3er\t Ord\n"");
    printf(""----------------------------------------------\n"");
    for (int i = 0; i < siguiente_alumno; i++){
        imprimir_alumno_por_fila(i);
    }
    puts(""Presione una tecla para continuar..."");
    fflush(stdin);
    getchar();
}

void imprimir_alumno_por_fila(int posicion){
    printf(""%d\t\t%s\t"", lista_estudiantes[posicion].matricula, lista_estudiantes[posicion].nombre);
    for (int i = 0; i < MAX_CALIFICACIONES; i++){
        printf(""%.2f\t"", lista_estudiantes[posicion].calificaciones[i]);
    }
    printf(""\n"");
}",54,1612,2851
"#define MAX 100
#define MAX_ASISTENCIA 5
#define MAX_CALIFICACIONES 4
#define MAX_NOMBRE 60
#define MAX_ALUMNOS 4

struct estudiant_{
    int matricula;
    char nombre[MAX_NOMBRE];
    float calificaciones[MAX_CALIFICACIONES];
    int asistencias[MAX_ASISTENCIA];
};

typedef struct estudiant_ estudiante;
estudiante lista_estudiantes[MAX_ALUMNOS];


void imprimir_menu();
void agregar_alumno();
void modificar_alumno();
void imprimir_alumno();
void imprimir_asistencias(const int posicion);
void imprimir_menu_calificaciones();
void menu_modificacion_calificaciones();
void imprimir_alumnos_en_tabla();
void imprimir_alumno_por_fila(int posicion);

int posicion_alumno();
void pase_asistencia();
float promedio(float *c);
float minimo(float *c);
float maximo(float *c);

int siguiente_alumno = 0;

int main(){
    int opcion;
    while (1) {
        imprimir_menu();
        scanf(""%d"", &opcion);
        switch (opcion) {
            case 1: agregar_alumno();
                break;
            case 2: modificar_alumno();
                break;
             case 3: menu_modificacion_calificaciones();
                 break;
            case 4: imprimir_alumno();
                 break;
            case 5: imprimir_alumnos_en_tabla();
                break;
            case 6: pase_asistencia();
                 break;
            case 7:
                return 0;
                break;
            default:
                break;
        }
    }
    return 0;
}

void imprimir_menu(){
    char mensaje[MAX] = ""SISTEMA DE CONTROL DE CALIFICACIONES"";
    system(""clear"");
    printf(""----------------------------------------------\n"");
    printf(""%s\n"", mensaje);
    printf(""----------------------------------------------\n"");
    printf(""Menu de opciones\n"");
    printf(""----------------------------------------------\n"");
    printf(""1. Agregar alumno\n"");
    printf(""2. Modificar alumno\n"");
    printf(""3. Modificar calificaciones\n"");
    printf(""4. Imprimir datos del alumno\n"");
    printf(""5. Lista de alumnos\n"");
    printf(""6. Pase de lista\n"");
    printf(""7. Salir\n"");
    printf(""Ingresa una opciÃ³n: \n"");
}

void agregar_alumno(){
    if(siguiente_alumno == MAX_ALUMNOS){
        printf(""No se puede agregar nuevo alumno, espacio insuficiente..."");
        puts(""Presiona cualquier tecla para continuar..."");
        fflush(stdin);
        getchar();
    } else {
        estudiante nuevo_alumno;
        printf(""Ingresa la matrÃ­cula:"");
        scanf(""%d"", &nuevo_alumno.matricula);
        fflush(stdin);
        printf(""Ingresa el nombre del alumno:"");
        fgets(nuevo_alumno.nombre, 60, stdin);
        nuevo_alumno.calificaciones[0] = 0.0;
        nuevo_alumno.calificaciones[1] = 0.0;
        nuevo_alumno.calificaciones[2] = 0.0;
        nuevo_alumno.calificaciones[3] = 0.0;
        puts(""Datos almacenado correctamente..."");
        puts(""Presiona cualquier tecla para continuar..."");
        fflush(stdin);
        getchar();
        lista_estudiantes[siguiente_alumno] = nuevo_alumno;
        siguiente_alumno++;
    } 
}

void modificar_alumno(){
    system(""clear"");
    puts(""\tMenu para cambio de nombre..."");
    int posicion = posicion_alumno();
    estudiante estudiante_seleccionado = lista_estudiantes[posicion];
    printf(""El nombre del alumno es: %s\n"", estudiante_seleccionado.nombre);
    printf(""Ingresa el nuevo nombre: "");
    fflush(stdin);
    fgets(estudiante_seleccionado.nombre, 60, stdin);
    lista_estudiantes[posicion] = estudiante_seleccionado;
}

int posicion_alumno(){
    int posicion;
    printf(""\nIngresa la posicion [1 -  %d]: "", MAX_ALUMNOS);
    scanf(""%d"", &posicion);
    posicion--;
    return posicion;
}

void imprimir_alumno(){
    int posicion = posicion_alumno();
    
    printf(""MatrÃ­cula: %d\n"", lista_estudiantes[posicion].matricula);
    printf(""Nombre del alumno: %s\n"", lista_estudiantes[posicion].nombre);
    printf(""CalificaciÃ³n 1: %.2f\n"", lista_estudiantes[posicion].calificaciones[0]); 
    printf(""CalificaciÃ³n 2: %.2f\n"", lista_estudiantes[posicion].calificaciones[1]); 
    printf(""CalificaciÃ³n 3: %.2f\n"", lista_estudiantes[posicion].calificaciones[2]); 
    printf(""CalificaciÃ³n f: %.2f\n"", lista_estudiantes[posicion].calificaciones[3]); 
    float prom = promedio(lista_estudiantes[posicion].calificaciones);
    printf(""Promedio : %.2f\n"", prom);
    float m;
    m = minimo(lista_estudiantes[posicion].calificaciones);
    printf(""CalificaciÃ³n mÃ­nima: %.2f\n"", m);
    m = maximo(lista_estudiantes[posicion].calificaciones);
    printf(""CalificaciÃ³n mÃ¡xima: %.2f\n"", m);
    imprimir_asistencias(posicion);
    fflush(stdin);
    getchar();
}

float promedio(float *c){
    float prom;
    float acumulador = 0.0;
    for (int i = 0; i < MAX_CALIFICACIONES - 1; i++)
    {
        acumulador += c[i];
    }
    prom = acumulador / MAX_CALIFICACIONES - 1;
    prom = (prom + c[MAX_CALIFICACIONES - 1]) / 2;
    return prom;
}

float minimo(float *c){
    float min = c[0];
    for (int i = 1; i < MAX_CALIFICACIONES; i++){
        if (min > c[i]){
            min = c[i];
        }
    }
    return min;
}

float maximo(float *c){
    float max = c[0];
    for (int i = 1; i < MAX_CALIFICACIONES; i++){
        if (max < c[i]){
            max = c[i];
        }
    }
    return max;
}

void imprimir_asistencias(const int posicion){
    printf(""Asistencias: "");
    for (int i = 0; i < MAX_ASISTENCIA-1; i++)
    {
        if (lista_estudiantes[posicion].asistencias[i] == 1)
            printf(""%s"", ""A, "");    
        else 
            printf(""%s"", ""F, "");         
    }
    (lista_estudiantes[posicion].asistencias[MAX_ASISTENCIA-1] == 1)?printf(""%s"", ""A""):printf(""%s"", ""F"");
    printf(""\n"");
}

void imprimir_menu_calificaciones(){
    printf(""1. Modificar calificaciÃ³n 1:\n"");
    printf(""2. Modificar calificaciÃ³n 2:\n"");
    printf(""3. Modificar calificaciÃ³n 3:\n"");
    printf(""4. Modificar calificaciÃ³n f:\n"");
    printf(""5. Salir:\n"");
    printf(""Ingresa una opciÃ³n:"");
}

void menu_modificacion_calificaciones(){
    int opt = 0;
    int posicion = posicion_alumno();
    while(opt != 5) {
        imprimir_menu_calificaciones();
        scanf(""%d"", &opt);
        if (opt < MAX_CALIFICACIONES + 1) {
            printf(""La calificaciÃ³n actual es: %f\n"", 
                lista_estudiantes[posicion].calificaciones[opt-1]);
            printf(""Ingresa nueva calificaciÃ³n %d:"", opt-1);
            scanf(""%f"", &lista_estudiantes[posicion].calificaciones[opt-1]);
        }
    }
}

void pase_asistencia(){
    int dia;
    printf(""Pase de asistencia...\n"");
    int posicion = posicion_alumno();
    printf(""Indicar dia de asistencia [1 - %d]: "", MAX_ASISTENCIA);
    scanf(""%d"", &dia);
    printf(""[0]=Falta o [1]=Asistencia: "");
    scanf(""%d"", &lista_estudiantes[posicion].asistencias[dia - 1]);
}

void imprimir_alumnos_en_tabla(){
    system(""clear"");
    printf(""----------------------------------------------\n"");
    printf(""Matricula\tNombre\t 1er\t2o\t3er\t Ord\n"");
    printf(""----------------------------------------------\n"");
    for (int i = 0; i < siguiente_alumno; i++){
        imprimir_alumno_por_fila(i);
    }
    puts(""Presione una tecla para continuar..."");
    fflush(stdin);
    getchar();
}

void imprimir_alumno_por_fila(int posicion){
    printf(""%d\t\t%s\t"", lista_estudiantes[posicion].matricula, lista_estudiantes[posicion].nombre);
    for (int i = 0; i < MAX_CALIFICACIONES; i++){
        printf(""%.2f\t"", lista_estudiantes[posicion].calificaciones[i]);
    }
    printf(""\n"");
}",54,1613,2788
"int main() {
    int i;
    printf(""Enter information of students:\n"");

    
    for (i=0;i<11;++i) {
        s[i].no = i+1;
        printf(""\nStudent 0%d\n"", s[i].no);
        printf(""Enter ID number : "");
        scanf(""%d"",&s[i].id);
        printf(""Enter name : "");
        scanf(""%s"",&s[i].name);
        printf(""Enter age : "");
        scanf(""%d"",&s[i].age);
        printf(""Enter address : "");
        scanf(""%s"",&s[i].address);
        printf(""Enter marks : "");
        scanf(""%f"",&s[i].marks);
    }
    printf(""\nDisplaying Information:\n"");

    
    for (i=0;i<11;i++){
        if(s[i].id%2==0){
            printf(""Name : "");
            puts(s[i].name);
        }
    }
    return 0;
}",55,1614,259
"struct customer{
    char name[30];
    int accNmbr,no;
    int balance;
}c[50];

void minimumAcc(int bal, char name[]){
    if(bal<200){
        printf(""%s\n"", name);
    }
}

void maximumAcc(int bal, char name[]){
    if(bal>1000){
        bal = bal + 100;
        printf(""Now %s's account balance is %d"", name, bal);
    }
}

int main(){
    int n,i,j;
    printf(""Enter the number of customers : "");
    scanf(""%d"",&n);
    
    for(i=0;i<n;i++){
        c[i].no = i+1;
        printf(""\nCustomer 0%d\n"",c[i].no);
        printf(""Enter name : "");
        scanf(""%s"",c[i].name);
        printf(""Enter Account Number : "");
        scanf(""%d"",&c[i].accNmbr);
        printf(""Enter balance : "");
        scanf(""%d"",&c[i].balance);
    }
    
    printf(""\nCustomers having balance less than Rs.200\n"");
    for(j=0;j<n;j++){
        minimumAcc(c[j].balance,c[j].name);
    }
    
    printf(""\nCustomers having balanace greater than Rs.1000 are increased acc balance..\n"");
    for(j=0;j<n;j++){
        maximumAcc(c[j].balance,c[j].name);
    }
    return 0;
}",55,1615,415
"typedef struct {
    char Name[20];
    int EmpNo;
    float salary;
    float OT;
}Emp;

int main(){
    Emp e[4];
    char array[1000];
    FILE *fp;
    int i;
    float amount[4];

    float total=0;
    fp=fopen(""data.txt"",""r"");

    while(!feof(fp)){

        fgets(array,500,fp);
        if(array[i]!='\n'){
            fscanf(fp,""%s\t\t%d\t\t%f\t\t%f"",&e[i].Name,&e[i].EmpNo,&e[i].salary,&e[i].OT);
        }
        i++;
    }

    fclose(fp);
     printf(""Employee No\tBasic salary\tOT Hours\tNet salary \n"");
    for(i=0;(sizeof(e)/sizeof(e[0]))>i;i++){
        amount[i]=e[i].salary+e[i].salary*0.35+e[i].OT*15;
        printf(""%d\t\t%.2f\t%.2f\t\t%.2f\n"",e[i].EmpNo,e[i].salary,e[i].OT,amount[i]);
    }


    for(i=0;(sizeof(amount)/sizeof(amount[0]))>i;i++){
        total=total+amount[i];
    }

    printf(""\nTotal Amount:%.2f"",total);

}",55,1616,404
"struct Date{
    int day;
    int month;
    int year;
    int no;
}d[2];

int main(){
    int i, j, key=0;

    for(i=0; i<2; i++){
        d[i].no = i+1;
        printf(""\nEnter 0%d\n"",d[i].no);
        printf(""Year : "");
        scanf(""%d"",&d[i].year);
        printf(""Month : "");
        scanf(""%d"",&d[i].month);
        printf(""Day : "");
        scanf(""%d"",&d[i].day);

        if(d[i].month >12 || d[i].month<=0 ){
            printf(""Invalide Month...\n"");

            if(d[i].day >30 || d[i].day<=0 ){
            printf(""Invalide Date...\n"");
            }

            i--;
        }else{
            if(d[i].day >30 || d[i].day<=0 ){
            printf(""Invalide Date...\n"");
            i--;
            }
        }


    }


    for(j=0; j<1; j++){
        if(d[j].day==d[j+1].day){
            if(d[j].month==d[j+1].month){
                if(d[j].year==d[j+1].year){
                    printf(""Dates are equal..\n"");
                }
                else{
                    key = 1;
                }
            }
            else{
                key = 1;
            }
        }
        else{
            key = 1;
        }
    }

    if(key==1){
        printf(""Dates are not equal.\n"");
    }
    return 0;
}",55,1617,455
"struct complex{
    float real;
    float imag;
}complex;

struct complex add(struct complex n1,struct complex n2);
struct complex subtract(struct complex n1,struct complex n2);
struct complex multiply(struct complex n1,struct complex n2);
int main()
{
    struct complex n1,n2,result,result1,result2;
    
    printf(""For 1st complex number \n"");
    printf(""Enter the real parts : "");
    scanf(""%f"",&n1.real);
    printf(""Enter the imaginary parts : "");
    scanf(""%f"",&n1.imag);
    printf(""\nFor 2nd complex number \n"");
    printf(""Enter the real parts : "");
    scanf(""%f"",&n2.real);
    printf(""Enter the imaginary parts : "");
    scanf(""%f"",&n2.imag);
    printf(""\n"");
    
    result=add(n1,n2);
    printf(""Sum value = %.1f + %.1fi\n"", result.real, result.imag);
    result1=subtract(n1,n2);
    printf(""Subtraction value = %.1f - %.1fi\n"", result1.real, result1.imag);
    result2=multiply(n1,n2);
    printf(""Multiply value = %.1f - %.1fi\n"", result2.real, result2.imag);
}
struct complex add(struct complex n1,struct  complex n2) {
   struct  complex temp;
    temp.real = n1.real + n2.real;
    temp.imag = n1.imag + n2.imag;
    return (temp);
}
struct complex subtract(struct complex n1, struct complex n2) {
    struct complex temp1;
    temp1.real = n1.real - n2.real;
    temp1.imag = n1.imag - n2.imag;
    return (temp1);
}
struct complex multiply(struct complex n1, struct complex n2) {
    struct complex temp2;
    temp2.real = n1.real * n2.real;
    temp2.imag = n1.imag * n2.imag;
    return (temp2);
}",55,1618,554
"int main()
{
    int quantity_of_product;
    float unit_price, revenue,discount;
    printf(""Enter quantity of product: "");
    scanf(""%d"",&quantity_of_product);
    printf(""\nEnter the unit price: "");
    scanf(""%f"",&unit_price);
    revenue=quantity_of_product*unit_price;
    if(quantity_of_product>120 &&quantity_of_product<160)
    {
        discount=revenue*15/100;
        printf(""\nDiscount : %f"",discount);
        printf(""\nAll payments : %f"",(revenue-discount));
        
    }
    else if(quantity_of_product>160)
    {
        discount=revenue*20/100;
        printf(""\nDiscount : %f"",discount);
        printf(""\nAll payments : %f"",(revenue-discount));
        
    }
    else{
        discount=revenue*0/100;
        printf(""\nDiscount : %f"",discount);
        printf(""\nAll payments : %f"",(revenue-discount));
    }
}",55,1619,296
"struct Marks {
    int ID_no;
    char name[30];
    float chem_marks, maths_marks, phy_marks;
};

int main() {
    
    struct Marks marks[5];
    int i;

    for(i=0;i<1;i++){
        printf(""Student %d\n"",i+1);
        printf(""Enter ID no. : "");
        scanf(""%d"",&marks[i].ID_no);
        printf(""Enter name : "");
        scanf(""%s"",&marks[i].name);
        printf(""Enter Chemistry marks : "");
        scanf(""%f"",&marks[i].chem_marks);
        printf(""Enter Maths marks : "");
        scanf(""%f"",&marks[i].maths_marks);
        printf(""Enter Physics marks : "");
        scanf(""%f"",&marks[i].phy_marks);
        
        printf(""\n"");
    }
    
    for(i=0;i<5;i++) {
        printf(""Student %d\n"",i+1);
        float percentage = (marks[i].chem_marks + marks[i].maths_marks + marks[i].phy_marks)/3.0;
        printf(""Percentage : %f\n"", percentage);
    }
  return 0;
}",55,1620,317
"struct student{
    char name[50],address[60];
    int no,id,age;
    float marks;
} s[10];

int main() {
    int i;
    printf(""Enter information of students:\n"");

    
    for (i=0;i<5;++i) {
        s[i].no = i+1;
        printf(""\nStudent 0%d\n"", s[i].no);
        printf(""Enter ID number : "");
        scanf(""%d"",&s[i].id);
        printf(""Enter name : "");
        scanf(""%s"",&s[i].name);
        printf(""Enter age : "");
        scanf(""%d"",&s[i].age);
        printf(""Enter address : "");
        scanf(""%s"",&s[i].address);
        printf(""Enter marks : "");
        scanf(""%f"",&s[i].marks);
    }
    printf(""Displaying Information:\n\n"");

    
    for (i=0;i<5;++i){
        printf(""\nStudent : %d\n"",i+1);
        printf(""ID number : %d\n"",s[i].id);
        printf(""Name : "");
        puts(s[i].name);
        printf(""Age : %d\n"",s[i].age);
        printf(""Address : "");
        puts(s[i].address);
        printf(""Marks: %.1f"",s[i].marks);
        printf(""\n"");
    }
    return 0;
}",55,1621,372
"int po(int, int);
int main(){
    int n1,n2;
    printf(""Enter the number 1 :\n"");
    scanf(""%d"",&n1);
    printf(""Enter the number 2 :\n"");
    scanf(""%d"",&n2);
    po(n1,n2);
}

int po(int n1, int n2){
    int i,sum=0;
    
    if(n1>n2){  
        for(i=n2;i<=n1;i++){
            
            sum = sum + i*i;
    }
        printf(""sum = %d"",sum);
        
    }
    else{
        for(i=n1;i<=n2;i++){
            
            sum= sum + i*i;         
        }
        printf(""sum = %d"",sum);
    }
}",55,1622,214
"struct student{
    char name[50],address[60];
    int no,id,age;
    float marks;
} s[10];

int main() {
    int i;
    printf(""Enter information of students:\n"");

    
    for (i=0;i<11;++i) {
        s[i].no = i+1;
        printf(""\nStudent 0%d\n"", s[i].no);
        printf(""Enter ID number : "");
        scanf(""%d"",&s[i].id);
        printf(""Enter name : "");
        scanf(""%s"",&s[i].name);
        printf(""Enter age : "");
        scanf(""%d"",&s[i].age);
        printf(""Enter address : "");
        scanf(""%s"",&s[i].address);
        printf(""Enter marks : "");
        scanf(""%f"",&s[i].marks);
    }
    printf(""\nDisplaying Information:\n"");

    
    for (i=0;i<11;i++){
        if(s[i].age==14){
            printf(""Name : "");
            puts(s[i].name);
        }
    }
    return 0;
}",55,1623,297
"int main(){
    int *a,n,i,j,temp;
    printf(""Enter size of array:"");
    scanf(""%d"",&n);

    a=calloc(sizeof(int),n);
    printf(""Enter %d Elements:\n"",n);

    for(i=0;i<n;i++){
        printf(""    element - %d : "",i);
        scanf(""%d"",a+i);
    }

    for(i=0;i<n-1;i++)
    {
        for(j=0;j<n-1;j++)
        {
            if(*(a+j)>*(a+j+1))
            {
                temp=*(a+j);
                *(a+j)=*(a+j+1);
                *(a+j+1)=temp;
            }
        }
    }
    printf(""After sorting array :\n"");
    for(i=0;i<n;i++){
        printf(""%d "",*(a+i));
    }
    return 0;           
}",55,1624,258
"struct Date{
    int day;
    int month;
    int year;
}d;

int main(){
    int flag =0;

    while(flag != 1){
        flag = 1;
        printf(""Year : "");
        scanf(""%d"",&d.year);
        printf(""Month : "");
        scanf(""%d"",&d.month);
        printf(""Day : "");
        scanf(""%d"",&d.day);

        if(d.month >12 || d.month<=0 ){
            printf(""Invalide Month...\n"");

            if(d.day >30 || d.day<=0 ){
            printf(""Invalide Date...\n"");

            flag =0;
            }

        }else{
            if(d.day >30 || d.day<=0 ){
            printf(""Invalide Date...\n"");
            flag =0;
            }
        }

    }

    d.day = d.day + 45;
    if(d.day>30 && d.day<60){
        d.day = d.day - 30;
        d.month = d.month + 1;
        if(d.month>12){
            d.month = d.month-12;
            d.year = d.year + 1;
        }
    }
    else if(d.day>60){
        d.day = d.day - 60;
        d.month = d.month + 2;
        if(d.month>12){
            d.month = d.month-12;
            d.year = d.year + 1;
        }
    }
    printf(""\nAdd 45 days...\n"");
    printf(""\nUpdated date is : %d %d %d"", d.year, d.month, d.day);

    return 0;
}",55,1625,465
"int main()
{
    int n;
    printf(""Enter the print World number: "");
    scanf(""%d"",&n);
    if(n==1)
    {
        printf(""ONE"");
    }
    else if(n==2)
    {
        printf(""TWO"");
    }
    else if(n==3)
    {
        printf(""THREE"");
    }
    else if(n==4)
    {
        printf(""FOUR"");
    }
    else if(n==5)
    {
        printf(""FIVE"");
    }
    else if(n==6)
    {
        printf(""SIX"");
    }
    else if(n==7)
    {
        printf(""SEVEN"");
    }
    else if(n==8)
    {
        printf(""EIGHT"");
    }
    else if(n==9)
    {
        printf(""NINE"");
    }
    else 
    {
        printf(""OTHERS"");
    }
}",55,1626,248
"typedef struct{
    int a,e,i,o,u,other;
}word;

int main()
{
    word W;
    char array[100];
    FILE * fp;
    int i=0;

    fp = fopen(""myword.txt"",""a"");
    printf(""Enter your word: "");
    gets(array);
    fprintf(fp,array);

    W.a = 0,W.e = 0,W.i = 0,W.o = 0,W.u = 0,W.other = 0;

    while(strlen(array)>i){

        if(array[i]=='a'||array[i]=='A'){
            W.a=W.a + 1;
        }

        if(array[i]=='e'||array[i]=='E'){
            W.e=W.e+1;
        }

        if(array[i]=='i'||array[i]=='I'){
            W.i=W.i+1;
        }

        if(array[i]=='o'||array[i]=='O'){
            W.o=W.o+1;
        }

        if(array[i]=='u'||array[i]=='U'){
            W.u=W.u+1;
        }

        if(array[i] !='a' && array[i] != 'e' && array[i] != 'i' && array[i] != 'o'&& array[i] != 'u' && array[i] != 'A' && array[i] != 'E' && array[i] != 'I' && array[i] != 'O' && array[i] != 'U' ){
            W.other=W.other+1;
        }
    i++;
    }
    fprintf(fp,""\t\t%d\t%d\t%d\t%d\t%d\t%d\t%d"",W.a,W.e,W.i,W.o,W.u,W.other,strlen(array));
    fclose(fp);

    fp=fopen(""myword.txt"",""a"");
    fprintf(fp,""\n"");
    fclose(fp);
}",55,1627,571
"#include ""binary_trees.h""


int scale(const binary_tree_t *tree)
{
    int ll = 1;
    int lr = 1;

    if (tree == NULL)
    {
        return (-1);
    }
    ll += scale((*tree).left);
    lr += scale((*tree).right);
    if (lr > ll)
    {
        return (lr);
    }
    return (ll);
}


void print_level(binary_tree_t *tree, int level, void (*func)(int))
{
    if (tree != NULL)
    {
        if (level == 0)
        {
            func((*tree).n);
        }
        else
        {
            print_level((*tree).left, level - 1, func);
            print_level((*tree).right, level - 1, func);
        }
    }
}


void binary_tree_levelorder(const binary_tree_t *tree, void (*func)(int))
{
    int level, height;

    if (tree != NULL && func != NULL)
    {
        height = scale(tree) + 1;

        for (level = 0; level < height; level++)
        {
            print_level((binary_tree_t *)tree, level, func);
        }
    }
}
",56,1628,336
"#include ""binary_trees.h""


int scale(const binary_tree_t *tree)
{
    int ll = 1;
    int lr = 1;

    if (tree == NULL)
    {
        return (-1);
    }
    ll += scale((*tree).left);
    lr += scale((*tree).right);
    if (lr > ll)
    {
        return (lr);
    }
    return (ll);
}


size_t binary_tree_height(const binary_tree_t *tree)
{
    if (tree == NULL)
    {
        return (0);
    }
    return (scale(tree));
}
",56,1629,169
"#include ""sort.h""


int swp_fwd(listint_t *current, listint_t **list)
{
    listint_t *moving = NULL;

    moving = current->next;

    moving->prev = current->prev;
    if (current->prev)
        current->prev->next = moving;
    else
        *list = current->next;

    current->next = moving->next;
    current->prev = moving;
    moving->next = current;
    if (current->next)
        current->next->prev = current;

    print_list(*list);
    return (1);
}


int swp_bck(listint_t *current, listint_t **list)
{
    listint_t *moving = NULL;

    moving = current->prev;

    moving->next = current->next;
    current->next->prev = moving;

    current->prev = moving->prev;
    current->next = moving;
    moving->prev = current;
    if (current->prev)
        current->prev->next = current;
    else
        *list = current;
    print_list(*list);
    return (1);
}


void cocktail_sort_list(listint_t **list)
{
    listint_t *current = NULL;
    int swapped = 1;

    if (list)
    {
        current = *list;
        while (swapped)
        {
            swapped = 0;
            while (current->next)
            {
                if (current->n > current->next->n)
                {
                    swapped = swp_fwd(current, list);
                    continue;
                }
                current = current->next;
            }
            if (!swapped)
                break;
            swapped = 0;
            while (current->prev)
            {
                if (current->n < current->prev->n)
                {
                    swapped = swp_bck(current, list);
                    continue;
                }
                current = current->prev;
            }
        }
    }
}",56,1630,525
"#include ""binary_trees.h""


int _pow(int x, int y)
{
    if (y < 0)
        return (-1);
    if (y == 0)
        return (1);
    if (y > 1)
    {
        y = _pow(x, y - 1);
    }
    else
    {
        return (x * y);
    }
    return (x * y);
}


int scale(const binary_tree_t *tree)
{
    int ll = 1;
    int lr = 1;

    if (tree == NULL)
    {
        return (-1);
    }
    ll += scale((*tree).left);
    lr += scale((*tree).right);
    if (lr > ll)
    {
        return (lr);
    }
    return (ll);
}


size_t tree_size(const binary_tree_t *tree)
{
    int count = 0;

    if (tree == NULL)
    {
        return (0);
    }
    count = 1 + tree_size((*tree).left) + tree_size((*tree).right);
    return (count);
}


int binary_tree_is_perfect(const binary_tree_t *tree)
{
    int height;
    int _nodes;

    if (tree == NULL)
        return (0);

    height = scale(tree);
    _nodes = tree_size(tree);
    if (_pow(2, height + 1) - 1 == _nodes)
        return (1);
    return (0);
}
",56,1631,405
"#include ""sort.h""


void counting_sort(int *array, size_t size)
{
    int max, position, *count = NULL, *order = NULL;
    size_t i;

    if (size < 2 || array == NULL)
        return;
    
    max = array[0];
    for (i = 0; i < size; i++)
        if (array[i] > max)
            max = array[i];
    
    count = malloc(sizeof(int) * (max + 1));
    for (i = 0; i <= (size_t)max; i++)
        count[i] = 0;
    
    for (i = 0; i < size; i++)
        count[array[i]] = count[array[i]] + 1;
    
    for (i = 1; i <= (size_t)max; i++)
        count[i] = count[i] + count[i - 1];
    print_array(count, (size_t)max + 1);
    
    order = malloc(sizeof(int) * size);
    for (i = 0; i < size; i++)
    {
        count[array[i]] = count[array[i]] - 1;
        position = count[array[i]];
        order[position] = array[i];
    }
    
    for (i = 0; i < size; i++)
        array[i] = order[i];
    free(count);
    free(order);
}",56,1632,374
"#include ""sort.h""

void selection_sort(int *array, size_t size)
{
    size_t boundary = 0, min_pos, i;
    int min, temp;

    while (boundary < size)
    {
        i = boundary;
        min = array[boundary];
        min_pos = boundary;
        while (i < size)
        {
            if (array[i] < min)
            {
                min = array[i];
                min_pos = i;
            }
            i++;
        }
        if (min_pos != boundary)
        {
            temp = array[boundary];
            array[boundary] = array[min_pos];
            array[min_pos] = temp;
            print_array(array, size);
        }
        boundary++;
    }
}
",56,1633,205
"#include ""sort.h""


void shell_sort(int *array, size_t size)
{
    size_t h = 1, i, n;
    int number;

    if (!size || !array)
        return;

    while (h < size)
        h = 3 * h + 1;

    h = (h - 1) / 3;

    while (h > 0)
    {
        for (i = h; i < size; i++)
        {
            number = array[i];
            for (n = i; n > h - 1 && array[n - h] > number; n = n - h)
            {
                array[n] = array[n - h];
            }
            array[n] = number;
        }
        h = h / 3;
        print_array(array, size);
    }
}",56,1634,218
"#include ""sort.h""


void insertion_sort_list(listint_t **list)
{
    listint_t *cur, *t, *t2;
    if (list == NULL || *list == NULL || (*list)->next == NULL)
        return;
    for (cur = *list; cur != NULL; cur = cur->next)
    {
        t = cur;
        for (t2 = t->prev; t2 != NULL && t2->n > t->n; t2 = t->prev)
        {
            if (t2->prev != NULL && t->next != NULL)
            {
                t2->prev->next = t;
                t->next->prev = t2;
                t2->next = t->next;
                t->prev = t2->prev;
                t->next = t2;
                t2->prev = t;
                print_list(*list);
                continue;
            }
            if (t2->prev == NULL)
            {
                t->prev = NULL;
                t2->next = t->next;
                t2->prev = t;
                if (t->next != NULL)
                    t->next->prev = t2;
                t->next = t2;
                *list = t;
                print_list(*list);
                continue;
            }
            if (t->next == NULL)
            {
                t->prev = t2->prev;
                t->next = t2;
                t2->next = NULL;
                t2->prev->next = t;
                t2->prev = t;
                print_list(*list);
                continue;
            }
        }
    }
}
",56,1635,408
"#include ""binary_trees.h""


size_t tree_size(const binary_tree_t *tree)
{
    int count = 0;

    if (tree == NULL)
    {
        return (0);
    }
    count = 1 + tree_size((*tree).left) + tree_size((*tree).right);
    return (count);
}


int is_complete(binary_tree_t *tree, int pos, int nodes)
{
    int left, right;

    if (tree == NULL)
    {
        return (1);
    }
    if (pos >= nodes)
    {
        return (0);
    }
    left = is_complete((*tree).left, 2 * pos + 1, nodes);
    right = is_complete((*tree).right, 2 * pos + 2, nodes);
    return (left * right);
}


int binary_tree_is_complete(const binary_tree_t *tree)
{
    int nodes, pos = 0;

    if (tree != NULL)
    {
        nodes = tree_size(tree);
        return (is_complete((binary_tree_t *)tree, pos, nodes));
    }
    return (0);
}
",56,1636,308
"#include ""binary_trees.h""


binary_tree_t *brother(binary_tree_t *node)
{
    binary_tree_t *parent = NULL;

    if (node == NULL)
    {
        return (NULL);
    }
    if ((*node).parent == NULL)
    {
        return (NULL);
    }
    parent = (*node).parent;
    if ((*parent).left != NULL && (*parent).right != NULL)
    {
        if (node == (*parent).left)
            return ((*parent).right);
        return ((*parent).left);
    }
    return (NULL);
}


binary_tree_t *binary_tree_uncle(binary_tree_t *node)
{

    if (node == NULL)
    {
        return (NULL);
    }
    if ((*node).parent == NULL)
    {
        return (NULL);
    }
    return (brother((*node).parent));
}
",56,1637,242
"#include ""sort.h""


listint_t *create_listint(const int *array, size_t size)
{
    listint_t *list;
    listint_t *node;
    int *tmp;

    list = NULL;
    while (size--)
    {
        node = malloc(sizeof(*node));
        if (!node)
            return (NULL);
        tmp = (int *)&node->n;
        *tmp = array[size];
        node->next = list;
        node->prev = NULL;
        list = node;
        if (list->next)
            list->next->prev = list;
    }
    return (list);
}


int main(void)
{
    listint_t *list;
    int array[] = {19, 48, 99, 71, 13, 52, 96, 73, 86, 7};
    size_t n = sizeof(array) / sizeof(array[0]);

    list = create_listint(array, n);
    if (!list)
        return (1);
    print_list(list);
    printf(""\n"");
    insertion_sort_list(&list);
    printf(""\n"");
    print_list(list);
    return (0);
}
",56,1638,323
"#include ""binary_trees.h""


size_t count_leaves(const binary_tree_t *tree)
{
    int count = 0;

    if (tree == NULL)
    {
        return (0);
    }
    if ((*tree).right == NULL && (*tree).left == NULL)
    {
        return (1);
    }
    count = count_leaves((*tree).right) + count_leaves((*tree).left);
    return (count);
}


size_t internal_nodes(const binary_tree_t *tree)
{
    int c = 0;

    if (tree == NULL)
    {
        return (0);
    }
    if ((*tree).right != NULL || (*tree).left != NULL)
    {
        c = 1 + internal_nodes((*tree).right) + internal_nodes((*tree).left);
    }
    return (c);
}


size_t tree_size(const binary_tree_t *tree)
{
    int count = 0;

    if (tree == NULL)
    {
        return (0);
    }
    count = 1 + tree_size((*tree).left) + tree_size((*tree).right);
    return (count);
}


int binary_tree_is_full(const binary_tree_t *tree)
{
    int _inodes = 0, _nodes = 0, _leaves = 0;

    if (tree == NULL)
    {
        return (0);
    }
    _nodes = tree_size(tree);
    _leaves = count_leaves(tree);
    _inodes = internal_nodes(tree);
    if (_inodes > 0)
    {
        if (_leaves != _inodes + 1)
        {
            return (0);
        }
        if (_nodes != 2 * _inodes + 1)
        {
            return (0);
        }
    }
    if (_inodes != (_nodes - 1) / 2)
    {

        return (0);
    }
    if (_leaves != (_nodes + 1) / 2)
    {
        return (0);
    }
    if (_nodes != 2 * _leaves - 1)
    {

        return (0);
    }
    if (_inodes != _leaves - 1)
    {
        return (0);
    }
    return (1);
}
",56,1639,611
"void Columna(int pibote)
{
    int j = 0;
    do{
        if(j >= 40 - pibote)
            printf(""A"");
        else
            printf("" "");
    ++j;
    }while(j <= 40);
}


int main()
{
    int contador1 = 0;
    int contador2 = 10;
    do
    {
        if(contador1 > 5)
            Columna(contador2);
        else
            Columna(contador1);
        --contador2;
        printf(""\n"");
        ++contador1;
    }while(contador1 < 11);
    return 0;
}",57,1640,180
"void Columnas();
void Filas();

int main()
{

    Filas(0, 10);
    return 0;

}

void Columnas(int contador, int pibote)
{
    if(contador <= 40){
        if(contador >= 40 - pibote)
            printf(""A"");
        else
            printf("" "");
        Columnas(++contador,pibote);
    }
}


void Filas(int contador, int contador2)
{
    printf(""\n"");
    if(contador < 11){
        if(contador > 5){
            Columnas(1,contador2);
            Filas(++contador, --contador2);
        }else{
            Columnas(1,contador);
            Filas(++contador,--contador2);
        }
    }
}
",57,1641,219
"void ft_putnbr(int );
void ft_putnbr(int numero){
    int negativo = 0;

    if(numero < 0){
        numero = numero*(-1);
        negativo = 1;
    }
    else
        negativo = 0;
    
    int longitud_N = 0; 
    for(int  i = numero; i > 0; i= i/10){
        ++longitud_N; 
    }

    if(negativo)
        longitud_N++;

    char string_intermedio[11] = "" ""; 

    for(int i = numero; i > 0; i = i/10){ 
        string_intermedio[longitud_N-1] = (i%10)+48;
        --longitud_N;
    }
    if(negativo)
        string_intermedio[0] = '-';


    printf(""%s"", string_intermedio); 
}

int main()
{
    ft_putnbr(-204);
    return 0;
}",57,1642,272
"void Columna(int pibote)
{
    int i = 1;
    while(i <= 34)
    {
        if(i >= 28){
            if(i >= (28 + pibote) && i <= 34 - pibote){
            printf("" "");
        }else{
            printf(""A"");
        }
        }else{
            printf("" "");
        }
        ++i;
    }
}


int main()
{
    int contador1 = 1;
    int contador2 = 7;
    while(contador1 < 8)
    {
        printf(""\n"");
            if(contador1 >= 4)
            Columna(contador2);
        else
            Columna(contador1);
        
        --contador2;
        ++contador1;
    }
}",57,1643,213
"int potencia(int, int);
 int potencia(int numero, int exponente){
    int resultado = 1;
    if(exponente == 0)
        return 1;
    else{
        for(int i = 1; i <= exponente; i++) resultado *= numero;
        return resultado;
    }
 }

int atoi(char *str);
int atoi(char *str){
    int longitud = 0;
    int Valores = 0;
    int Total = 0;
    for( longitud = 0; str[longitud] != '\0'; ++longitud);
    for(int i = 0; i < longitud; i++){
        Valores = ((int)(str[i]) - 48) * potencia(10, (longitud - i - 1));
        Total += Valores;
    }
    return Total;
}


int main(){

    char palabra[10] = ""23456"";
    int value = 0;
    value = atoi(palabra);
    printf(""%i"", value );
    return 0;
}",57,1644,272
"double Fac(int N)
{
    double Factorial = 1.0;
    int i = 1;
    while(i < N){Factorial *= ++i;}
    return Factorial;
}
double Exp(int numero, int exponente)
{
    double Total = 1;
    int i = 0;
    while(i < exponente)
    {
    Total *= numero;
    ++i;
    }
    return Total;
}


int main()
{
    int X = 0;
    int veces = 0;
    printf(""\nPrograma para calcular Cosh(x) mediante sumas de Taylor\nIngresa X:"");
    scanf(""%i"", &X);
    printf(""\nIngrse el numero de sumas: "");
    scanf(""%i"", &veces);
    double Suma_total = 0.0;
    int i=1;
    while(i <= veces){
        Suma_total += Exp(X,(i*2)) / Fac((i*2));
        ++i;
    }
    printf(""Cosh(%i) es igual a %lf"", X, (Suma_total + 1));

    return 0;
}",57,1645,298
"double Fac(int N)
{
    double Factorial = 1.0;
    int i = 1;
    do{Factorial *= ++i;}while(i < N);
    return Factorial;
}
double Exp(int numero, int exponente)
{
    double Total = 1;
    int i = 0;
    do{
    Total *= numero;
    ++i;
    }while(i < exponente);
    return Total;
}


int main()
{
    int X = 0;
    int veces = 0;
    printf(""\nPrograma para calcular Cos(x) mediante sumas de Taylor\nIngresa X:"");
    scanf(""%i"", &X);
    printf(""\nIngrse el numero de sumas: "");
    scanf(""%i"", &veces);
    double Suma_total = 0.0;
    int i=1;
    do{
        if(i%2 == 0)
            Suma_total += (Exp(X, i*2) / Fac(i*2));
        else
            Suma_total -= (Exp(X, i*2) / Fac(i*2));
        ++i;
    }while(i <= veces);
    printf(""cos(%i) es igual a %lf"", X, (Suma_total + 1.0));

    return 0;
}",57,1646,339
"void Columna(int pibote)
{
    for(int j = 1; j <= 20; ++j)
    {
        if(j >= (10 - pibote) && j <= (10 + pibote))
        printf(""Z"");
    else
        printf("" "");
    }
}

int main()
{
    int contador1 = 0;
    int contador2 = 7;
    for(contador1 = 1; contador1 < 8; ++contador1)
    {
    printf(""\n"");
    if(contador1 > 4)
        Columna(contador2 - 1);
    else
        Columna(contador1 - 1);
    --contador2;
    }
    return 0;

}

",57,1647,198
"double Fac(int N)
{
    double Factorial = 1.0;
    int i = 1;
    while(i < N){Factorial *= ++i;}
    return Factorial;
}
double Exp(int numero, int exponente)
{
    double Total = 1;
    int i = 0;
    while(i < exponente)
    {
    Total *= numero;
    ++i;
    }
    return Total;
}


int main()
{
    int X = 0;
    int veces = 0;
    printf(""\nPrograma para calcular Senh(x) mediante sumas de Taylor\nIngresa X:"");
    scanf(""%i"", &X);
    printf(""\nIngrse el numero de sumas: "");
    scanf(""%i"", &veces);
    double Suma_total = 0.0;
    int i=1;
    while(i <= veces){
        Suma_total += Exp(X,(i*2)+1) / Fac((i*2)+1);
        ++i;
    }
    printf(""senh(%i) es igual a %lf"", X, (Suma_total + X));

    return 0;
}",57,1648,301
"void ft_print_combn(int n);

void comb1(int *numeros,int a);
void comb2(int *numeros,int a, int b);
void comb3(int *numeros,int a, int b,int c);
void comb4(int *numeros,int a, int b,int c,int d);  
void comb5(int *numeros,int a, int b,int c,int d,int e);
void comb6(int *numeros,int a, int b,int c,int d,int e,int f);
void comb7(int *numeros,int a, int b,int c,int d,int e,int f,int g);
void comb8(int *numeros,int a, int b,int c,int d,int e,int f,int g, int h);
void comb9(int *numeros,int a, int b,int c,int d,int e,int f,int g, int h, int i);

int main()
{
    ft_print_combn (2);
    return 0;
}

void ft_print_combn(int n)
{
    int numeros[10]={ 0, 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9}; 

    int a =0, b =1, c =2,d =3, e =4, f =5, g =6, h =7, i =8;    
    
    if(n==1)
      comb1(numeros,a);
      else{
           if(n==2)
              comb2(numeros,a,b);
              else{
                   if(n==3)
                     comb3(numeros,a,b,c);                      
                     else{
                          if(n==4)
                            comb4(numeros,a,b,c,d);
                            else{
                                 if(n==5)
                                   comb5(numeros,a,b,c,d,e);
                                   else{
                                        if(n==6)
                                          comb6(numeros,a,b,c,d,e,f);
                                          else{
                                               if(n==7)
                                                  comb7(numeros,a,b,c,d,e,f,g);
                                                  else{
                                                       if(n==8)
                                                          comb8(numeros,a,b,c,d,e,f,g,h);
                                                          else{
                                                               if(n==9)
                                                                  comb9(numeros,a,b,c,d,e,f,g,h,i);
                                                                  else{
                                                                       printf(""Valor no procesable"");
                                                                      }
                                                              }
                                                      }
                                              }
                                       }
                                }
                         }
                  }
          }  
}

void comb1(int *numeros,int a)
{
  while(a<=9)
       {
        printf(""%i, "",numeros[a]); 
        a=a+1;
       }
}

void comb2(int *numeros,int a,int b)
{
  while(a<=8)
       {
        while(b<=9)
            {
              printf(""%i%i, "",numeros[a],numeros[b]);    
              b=b+1;
            }
        a=a+1;
        b=a+1;
       }
}

void comb3(int *numeros,int a,int b,int c)
{
  while(a<=7)
       {
        while(b<=8)
             {
              while(c<=9)
                  {
                    printf(""%i%i%i, "",numeros[a],numeros[b],numeros[c]);
                    c=c+1;
                  }
              b=b+1;
              c=b+1;
             }
        a=a+1;
        b=a+1;
        c=b+1;
       }
}

void comb4(int *numeros,int a,int b,int c, int d)
{
  while(a<=6)
       {
          while(b<=7)
               {
                while(c<=8)
                     {
                      while(d<=9)
                          {
                            printf(""%i%i%i%i, "",numeros[a],numeros[b],numeros[c],numeros[d]);
                            d=d+1;
                          }
                      c=c+1;
                      d=c+1;
                     }     
                b=b+1;
                c=b+1;
                d=c+1;
               } 
          a=a+1;
          b=a+1;
          c=b+1;
          d=c+1;
       }
}

void comb5(int *numeros,int a,int b,int c, int d,int e)
{
  while(a<=5)
       {
          while(b<=6)
               {
                while(c<=7)
                    {
                      while(d<=8)
                           {
                            while(e<=9)
                                {
                                  printf(""%i%i%i%i%i, "",numeros[a],numeros[b],numeros[c],numeros[d],numeros[e]);
                                  e=e+1;
                                }
                            d=d+1;
                            e=d+1;
                           }
                      c=c+1;
                      d=c+1;
                      e=d+1;
                    }
                b=b+1;
                c=b+1;
                d=c+1;
                e=d+1;
               } 
          a=a+1;
          b=a+1;
          c=b+1;
          d=c+1;
          e=d+1;
       }
}

void comb6(int *numeros,int a,int b,int c, int d,int e,int f)
{
  while(a<=4)
       {
          while(b<=5)
              {
                  while(c<=6)
                      {
                        while(d<=7)
                            {
                              while(e<=8)
                                   {
                                    while(f<=9)
                                        {
                                          printf(""%i%i%i%i%i%i, "",numeros[a],numeros[b],numeros[c],numeros[d],numeros[e],numeros[f]);
                                          f=f+1;
                                        }
                                    e=e+1;
                                    f=e+1;
                                   }
                              d=d+1;
                              e=d+1;
                              f=e+1;
                            }
                        c=c+1;
                        d=c+1;
                        e=d+1;
                        f=e+1;
                      } 
                  b=b+1;
                  c=b+1;
                  d=c+1;
                  e=d+1;
                  f=e+1;
              }
          a=a+1;
          b=a+1;
          c=b+1;
          d=c+1;
          e=d+1;
          f=e+1;
      }
}

void comb7(int *numeros,int a,int b,int c, int d,int e,int f,int g)
{
  while(a<=3)
       {
        while(b<=4)
            {
                while(c<=5)
                    {
                        while(d<=6)
                            {
                              while(e<=7)
                                  {
                                    while(f<=8)
                                         {
                                          while(g<=9)
                                              {
                                                printf(""%i%i%i%i%i%i%i, "",numeros[a],numeros[b],numeros[c],numeros[d],numeros[e],numeros[f],numeros[g]);
                                                g=g+1;
                                              }
                                          f=f+1;
                                          g=f+1;
                                         }
                                    e=e+1;
                                    f=e+1;
                                    g=f+1;
                                  }
                              d=d+1;
                              e=d+1;
                              f=e+1;
                              g=f+1;
                            } 
                        c=c+1;
                        d=c+1;
                        e=d+1;
                        f=e+1;
                        g=f+1;
                    }
                b=b+1;
                c=b+1;
                d=c+1;
                e=d+1;
                f=e+1;
                g=f+1;
            }
        a=a+1;
        b=a+1;
        c=b+1;
        d=c+1;
        e=d+1;
        f=e+1;
        g=f+1;
       }
}

void comb8(int *numeros,int a,int b,int c, int d,int e,int f,int g,int h)
{
  while(a<=2)
       {
        while(b<=3)
            {
              while(c<=4)
                  {
                      while(d<=5)
                          {
                              while(e<=6)
                                  {
                                    while(f<=7)
                                        {
                                          while(g<=8)
                                               {
                                                while(h<=9)
                                                    {
                                                      printf(""%i%i%i%i%i%i%i%i, "",numeros[a],numeros[b],numeros[c],numeros[d],numeros[e],numeros[f],numeros[g],numeros[h]);
                                                      h=h+1;
                                                    }
                                                g=g+1;
                                                h=g+1;
                                               }
                                          f=f+1;
                                          g=f+1;
                                          h=g+1;
                                        }
                                    e=e+1;
                                    f=e+1;
                                    g=f+1;
                                    h=g+1;
                                  } 
                              d=d+1;
                              e=d+1;
                              f=e+1;
                              g=f+1;
                              h=g+1;
                          }
                      c=c+1;
                      d=c+1;
                      e=d+1;
                      f=e+1;
                      g=f+1;
                      h=g+1;
                  }
              b=b+1;
              c=b+1;
              d=c+1;
              e=d+1;
              f=e+1;
              g=f+1;
              h=g+1;
            }
        a=a+1;
        b=a+1;
        c=b+1;
        d=c+1;
        e=d+1;
        f=e+1;
        g=f+1;
        h=g+1;
       }
}

void comb9(int *numeros,int a,int b,int c, int d,int e,int f,int g,int h,int i)
{
  while(a<=1)
       {
        while(b<=2)
            {
              while(c<=3)
                  {
                    while(d<=4)
                        {
                            while(e<=5)
                                {
                                    while(f<=6)
                                        {
                                          while(g<=7)
                                              {
                                                while(h<=8)
                                                     {
                                                      while(i<=9)
                                                          {
                                                            printf(""%i%i%i%i%i%i%i%i%i, "",numeros[a],numeros[b],numeros[c],numeros[d],numeros[e],numeros[f],numeros[g],numeros[h],numeros[i]);
                                                            i=i+1;
                                                          }
                                                      h=h+1;
                                                      i=h+1;
                                                     }
                                                g=g+1;
                                                h=g+1;
                                                i=h+1;
                                              }
                                          f=f+1;
                                          g=f+1;
                                          h=g+1;
                                          i=h+1;
                                        } 
                                    e=e+1;
                                    f=e+1;
                                    g=f+1;
                                    h=g+1;
                                    i=h+1;
                                }
                            d=d+1;
                            e=d+1;
                            f=e+1;
                            g=f+1;
                            h=g+1;
                            i=h+1;
                        }
                    c=c+1;
                    d=c+1;
                    e=d+1;
                    f=e+1;
                    g=f+1;
                    h=g+1;
                    i=h+1;
                  }
              b=b+1;
              c=b+1;
              d=c+1;
              e=d+1;
              f=e+1;
              g=f+1;
              h=g+1;
              i=h+1;
            }
        a=a+1;
        b=a+1;
        c=b+1;
        d=c+1;
        e=d+1;
        f=e+1;
        g=f+1;
        h=g+1;
        i=h+1;
       }
}",57,1649,3593
"int main()
{
    int Mayor = 0;
    int menor = 0;
    int Mayor_150 = 0;
    int negativos = 0;
    float promedio_P = 0.0;
    int contador = 0;
    int num_p = 0;
    while(contador < 10)
    {
     int numero = 0;

     printf(""\nIngrese por favor el numero: "");
     scanf(""%i"", &numero);
     if(numero != 0){
         if(numero > 150){
             ++Mayor_150;    
         }
         if(numero > Mayor){
             Mayor = numero;    
         }else if(numero < menor){
             menor = numero;    
         }

         if(numero > 0){
             ++num_p;
             promedio_P += numero; 
         }else{
             ++negativos;          
         }
         ++contador;
         }
     }
     printf(""\n***Fin del Ciclo***\n"");
     promedio_P = promedio_P / num_p;

     printf(""\nCantidad de numeros mayores a 150: %i"", Mayor_150);
     printf(""\nNumero mayor: %i  Numero menor: %i"", Mayor, menor);   
     printf(""\nCantidad de numeros negativos encontrador: %i"", negativos);
     printf(""\nPromedio positivos encontrados: %f"", promedio_P);
}

",57,1650,385
"void Columnas(int contador, int pibote);
void Filas(int contador);


int main()
{
        Filas(1);
        return 0;

}
void Columnas(int contador, int pibote){
        if(contador <= 19){
                if(contador == (1 + pibote) || contador == (19 - pibote))
                        printf(""Z"");
                else
                        printf("" "");
                Columnas(++contador, pibote);
        }

}

void Filas(int contador)
{
        if(contador < 11){
                Columnas(1, (10 - contador));
                printf(""\n"");
                Filas(++contador);
        }
}
",57,1651,190
"double Fac(double num) 
{
        if(num == 1)
                return 1;
        else
                return num * Fac(num - 1);
}

double Exp(int Exponente, double numero)
{
        if(Exponente == 1){
                return numero;
        }else{
                return numero * Exp(--Exponente, numero);
        }
}




void cos(int contador,int iteraciones, double suma, double X);


int main()
{
        double X;
    int  I;
        printf(""Programa para calcular cos(X) mediante sumas de taylor \nIngresa X: "");
        
    scanf(""%lf"", &X);
    
    cos(1,50,0,X); 
        return 0;
}

void cos(int contador, int iteraciones, double suma, double X)
{
    if(contador <= iteraciones){    
        if(contador%2 == 0){
            printf(""\n%i -> %lf / %0.0lf = %0.6lf"", contador, Exp(contador*2,X), Fac(contador * 2), Exp(contador*2,X) / Fac(contador * 2));

            suma = suma + (Exp(contador*2,X) / Fac(contador * 2));
            printf(""   Suma Actual: %lf"", suma);
            cos(++contador, iteraciones,suma,X);
        }else{
            printf(""\n%i -> %lf / %0.0lf = %0.6lf"", contador, Exp(contador*2,X), Fac(contador * 2), Exp(contador*2,X) / Fac(contador * 2));
            suma = suma - (Exp(contador*2,X) / Fac(contador * 2));
            printf(""  Suma Actual: %lf"", suma);
            cos(++contador, iteraciones,suma,X);
        }
    }else{
        printf(""\nCos(%lf) es igual a: %lf"", X, (suma + 1));
    }
}
",57,1652,543
"void mostrar(int X_1, int X_2, int contador);

int main()
{
    system(""cls""); 
    int contador = 0;
    int X_1 = 1;
    int X_2 = 80;
    for(contador =1; X_1 != 41; ++contador){
        if(contador <= 80){
            if(contador == X_1)
                printf(""X"");
            else if(contador == X_2)
                printf(""X"");
            else
                printf("" "");
         }else{
             sleep(0.4);
             system(""cls"");
             ++X_1;
         --X_2;
        contador = 1;
         }
    }
        return 0;
}
",57,1653,193
"int main()
{
    char letra;
    int i = 0;
    int j;
    do{
    switch (i){
            case 0: letra = 'P';break;
            case 1: letra = 'N';break;
            case 2: letra = 'L';break;
            case 3: letra = 'J';break;
            case 4: letra = 'H';break;
            case 5: letra = 'F';break;
            case 6: letra = 'D';break;
    }
    j = 0;
    do{
        if(j >= (1 + i) && j <= (13-i))
            printf(""%c"", letra);
        else
        printf("" "");
        ++j;
    }while(j <= 13);
        printf(""\n"");
        ++i;
    }while( i< 7);
    return 0; 
}",57,1654,229
"double Fac(int N)
{
    double Factorial = 1.0;
    int i = 1;
    while(i < N){Factorial *= ++i;}
    return Factorial;
}
double Exp(int numero, int exponente)
{
    double Total = 1;
    int i = 0;
    while(i < exponente)
    {
    Total *= numero;
    ++i;
    }
    return Total;
}


int main()
{
    int X = 0;
    int veces = 0;
    printf(""\nPrograma para calcular Euler elevado a X mediante sumas de Taylor\nIngresa X:"");
    scanf(""%i"", &X);
    printf(""\nIngrse el numero de sumas: "");
    scanf(""%i"", &veces);
    double Suma_total = 0.0;
    int i=1;
    while(i <= veces){
        Suma_total += (Exp(X,i) / Fac(i));
        ++i;
    }
    printf(""e^%i es igual a %lf"", X, (Suma_total + 1.0));

    return 0;
}",57,1655,297
"void Columna(int contador, int pibote);
void Filas(int contador);

int main()
{
        Filas(0);
        return 0;
}

void Columnas(int contador, int pibote){
    if(contador <= 46){
        if(contador >= (34 + pibote) && contador <= (46 - pibote))
            printf(""P"");
        else
            printf("" "");
        Columnas(++contador, pibote);
    }
}

void Filas(int contador)
{
    if(contador < 7){
        Columnas(0, contador);
        printf(""\n"");
        Filas(++contador);
    }
}
",57,1656,183
"double Fac(double num)
{
    if(num == 1)
        return 1;
    else
        return num * Fac(num - 1);
}

double Exp(int Exponente, double numero)
{
    if(Exponente == 1){
        return numero;
    }else{
        return numero * Exp(--Exponente, numero);
    }
}





void Senh(int contador, int iteraciones, double total, double X);


int main(){
    
    double X;
    printf(""Programa para calcular el senh(X) por medio de sumas de Taylor\nValor de X:"");
    scanf(""%lf"", &X);
    Senh(1,30,0,X);
    return 0;
}

void Senh(int contador, int iteraciones, double total, double X)
{
    if(contador <= iteraciones){
        total = total + Exp((contador*2)+1,X) / Fac((contador*2)+1);
        Senh(++contador,iteraciones,total,X);
    }else{
        printf(""\n**El Senh(%lf) es igual a: %lf"",X,total+X);

    }
}
",57,1657,309
"void Columnas(int contador, int pibote);
void Filas(int contador);


int main()
{
    Filas(1);
    return 0;

}
void Columnas(int contador, int pibote){
    if(contador <= 19){
        if(contador == (1 + pibote) || contador == (19 - pibote))
            printf(""Z"");
        else
            printf("" "");
        Columnas(++contador, pibote);
    }

}

void Filas(int contador)
{
    if(contador < 11){
        Columnas(1, (contador - 1));
        printf(""\n"");
        Filas(++contador);      
    }
}
",57,1658,189
"void Columna(int pibote)
{
    for(int i = 1; i <= 34; ++i)
    {
    if(i >= 28){
        if(i >= (28 + pibote) && i <= 34 - pibote){
        printf("" "");
        }else{
        printf(""A"");
        }
    }else{
        printf("" "");
    }
    }
}


int main()
{
    int contador1 = 1;
    int contador2 = 7;
    for(contador1 = 1; contador1 < 8; ++contador1)
    {
    printf(""\n"");
        if(contador1 >= 4)
        Columna(contador2);
    else
        Columna(contador1);
        --contador2;
    }
}

",57,1659,214
"void ft_eight_queens_puzzle_2(void);
int Mov_Queen(int [8][8], int, int);


int main(){
    ft_eight_queens_puzzle_2();
}

void ft_eight_queens_puzzle_2(void){
    int Tabla[8][8] = {{0,0,0,0,0,0,0,0},     
                       {0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0}}; 

    for(int Col_0 = 0; Col_0 < 8; Col_0++){  
        Tabla[Col_0][0] = 1; 

        for(int Col_1 = 0; Col_1 < 8; Col_1++){ 
            if(Mov_Queen(Tabla, Col_1, 1) == 0){
               Tabla[Col_1][1] = 1; 

               for (int Col_2 = 0; Col_2 < 8; Col_2++){ 
                   if(Mov_Queen(Tabla, Col_2, 2) == 0){
                        Tabla[Col_2][2] = 1; 

                        for (int Col_3 = 0; Col_3 < 8; Col_3++){ 
                            if(Mov_Queen(Tabla, Col_3, 3) == 0){
                                Tabla[Col_3][3] = 1; 

                                for (int Col_4 = 0; Col_4 < 8; Col_4++){  
                                    if(Mov_Queen(Tabla, Col_4, 4) == 0){
                                        Tabla[Col_4][4] = 1; 

                                        for (int Col_5 = 0; Col_5 < 8; Col_5++){ 
                                            if(Mov_Queen(Tabla, Col_5, 5) == 0){
                                                Tabla[Col_5][5] = 1; 

                                                for (int Col_6 = 0; Col_6 < 8; Col_6++){ 
                                                    if(Mov_Queen(Tabla, Col_6, 6) == 0){
                                                        Tabla[Col_6][6] = 1; 

                                                        for (int Col_7 = 0; Col_7 < 8; Col_7++) 
                                                        {
                                                            if(Mov_Queen(Tabla, Col_7, 7) == 0){
                                                                Tabla[Col_7][7] = 1; 
                                                                printf(""\n%i%i%i%i%i%i%i%i"", Col_0+1, Col_1+1, Col_2+1, Col_3+1, Col_4+1, Col_5+1, Col_6+1, Col_7+1);
                                                            }
                                                            Tabla[Col_7][7] = 0;  
                                                        }
                                                    }
                                                    Tabla[Col_6][6] = 0;
                                                }
                                            }
                                            Tabla[Col_5][5] = 0;
                                        }  
                                    } 
                                    Tabla[Col_4][4] = 0;
                                }
                            }
                            Tabla[Col_3][3] = 0;
                        }
                    }
                    Tabla[Col_2][2] = 0; 
                }
            }
            Tabla[Col_1][1] = 0;
        }
        Tabla[Col_0][0] = 0;
    }
    printf(""\n"");
}


int Mov_Queen(int Tabla[8][8], int fila, int columna){   
                                                         
    int fila_actual = 0; 
    int columna_actual = 0; 
    int estado = 0; 
    
    for(int i = columna + 1; i < 8; i++) 
        if(Tabla[fila][i] == 1)
            estado = 1;
    
    for(int i = columna - 1; i >= 0; i--) 
       if(Tabla[fila][i] == 1)
            estado = 1; 

    for(int i = fila - 1; i >= 0; i--) 
       if(Tabla[i][columna] == 1)
            estado = 1; 

    for(int i = fila + 1; i < 8; i++) 
       if(Tabla[i][columna] == 1)
            estado = 1;

    fila_actual = fila - 1;
    columna_actual = columna + 1;
    while(columna_actual < 8 && fila_actual >= 0){    
        if(Tabla[fila_actual][columna_actual] == 1)
            estado = 1;
        fila_actual--;
        columna_actual++;
    }

    fila_actual = fila - 1;
    columna_actual = columna - 1;
    while(columna_actual >= 0 && fila_actual >= 0){    
        if(Tabla[fila_actual][columna_actual] == 1)
            estado = 1;
        fila_actual--;
        columna_actual--;
    }

    fila_actual = fila + 1;
    columna_actual = columna - 1;
    while(columna_actual >= 0 && fila_actual < 8){    
        if(Tabla[fila_actual][columna_actual] == 1)
            estado = 1;
        fila_actual++;
        columna_actual--;
    }

    fila_actual = fila + 1;
    columna_actual = columna + 1;
    while(columna_actual < 8 && fila_actual < 8){    
        if(Tabla[fila_actual][columna_actual] == 1)
            estado = 1;
        fila_actual++;
        columna_actual++;
    }
    return estado;
}",57,1660,1725
"double Fac(int N)
{
    double Factorial = 1.0;
    int i = 1;
    do{Factorial *= ++i;}while(i < N);
    return Factorial;
}
double Exp(int numero, int exponente)
{
    double Total = 1;
    int i = 0;
    do{
    Total *= numero;
    ++i;
    }while(i < exponente);
    return Total;
}


int main()
{
    int X = 0;
    int veces = 0;
    printf(""\nPrograma para calcular Euler elevado a X mediante sumas de Taylor\nIngresa X:"");
    scanf(""%i"", &X);
    printf(""\nIngrse el numero de sumas: "");
    scanf(""%i"", &veces);
    double Suma_total = 0.0;
    int i=1;
    do{
        Suma_total += (Exp(X,i) / Fac(i));
        ++i;
    }while(i <= veces);
    printf(""e^%i es igual a %lf"", X, (Suma_total + 1.0));

    return 0;
}",57,1661,300
"void Columnas(int contador, int pibote);
void Filas(int contador1,int contador2);


int main()
{
    Filas(1,7);
    return 0;
}

void Columnas(int contador, int pibote)
{
    if(contador <= 20){
        if(contador >= (10 - pibote) && contador <= (10 + pibote))
            printf(""Z"");
        else
            printf("" "");
        Columnas(++contador, pibote);
    }

}

void Filas(int contador1, int contador2)
{
    printf(""\n"");
    if(contador1 < 8){
        if(contador1 > 4){
            Columnas(1, (contador2 - 1));
            Filas(++contador1, --contador2);
        }else{
            Columnas(1,( contador1 - 1));
            Filas(++contador1, --contador2);
        }
    }
}
",57,1662,260
"void comb(int, int, int, int *);
void comb(int i, int j,int k, int *datos){
    if( i <= 7){
        if(j <= 8){
            if(k <= 9 ){
                if(datos[i] != datos[j] && datos[i] != datos[k] && datos[j] != datos[k]){
                    if(datos[i] < datos[j] && datos[i] < datos[k] && datos[j] < datos[k]){
                        printf(""%i%i%i  "", datos[i], datos[j], datos[k]);
                    }               
                }
                comb(i, j, k+1, datos);
            }else
                comb(i, j+1, 2, datos);
        }else
           comb(i+1, 1, k, datos);
    }
}


void ft_print_comb(); 
void ft_print_comb(){
    int datos[10] = {0,1,2,3,4,5,6,7,8,9};
    comb(0, 1,2, datos);
    
}

int main(){
    ft_print_comb(); 
    return 0;
}",57,1663,305
"int longitud_N(int numero, int contador){
    if(numero > 0){
        longitud_N(numero/10, contador + 1);
    }else{
        return contador;
    }
}

void llenar_string(char *str, int numero, int longitud_N){
    if(numero > 0){
        str[longitud_N - 1] = (numero%10)+48;
        llenar_string(str, numero/10, longitud_N-1);
    }
}


void ft_putnbr(int );
void ft_putnbr(int numero){
    int longitud = longitud_N(numero, 0);
    int negativo = 0;
    char string_intermedio[11] = """";

    if(numero < 0){
        numero = numero*(-1);
        longitud++;
        llenar_string(string_intermedio, numero, longitud);
        string_intermedio[0] = '-';
    }else{
        llenar_string(string_intermedio, numero, longitud);
    }
    printf(""%s"", string_intermedio);
}

int main()
{
    ft_putnbr(123);
    return 0;
}",57,1664,319
"void Columna(int contador, int pibote, char letra_c);
void Filas(int contador);

int main()
{
    Filas(0);
    return 0;
}

void Columna(int contador, int pibote, char letra_A){
    if(contador <= 13){
        if(contador >= (1 + pibote) && contador <= (13 - pibote))
            printf(""%c"", letra_A);
        else
            printf("" "");
        Columna(++contador,pibote,letra_A);
    }
}

void Filas(int contador){
    if(contador < 7){
        switch (contador){
            case 0: Columna(1,contador,'P');break;
            case 1: Columna(1,contador,'N');break;
            case 2: Columna(1,contador,'L');break;
            case 3: Columna(1,contador,'J');break;
            case 4: Columna(1,contador,'H');break;
            case 5: Columna(1,contador,'F');break;
            case 6: Columna(1,contador,'D');break;
        }
        printf(""\n"");
        Filas(++contador);
    }
}




",57,1665,341
"void Multipli(int numero, int contador)
{
    if(contador <= 10){
        printf(""\n%i X %i = %i"", numero, contador, numero*contador);
        Multipli(numero, ++contador);
    }

}


void Tablas(int numero)
{
    if(numero <= 10){
        printf(""\n*** Tabla del %i ***"", numero);
        Multipli(numero, 1);
        Tablas(++numero);
    }else{
        printf(""\n***Fin del ciclo***"");
    }
}

int main()  
{
    printf(""\nEste programa Muestra todas las tablas de multiplicar de base 10\n"");
    Tablas(1);
    return 0;
}
",57,1666,199
"double Fac(int N)
{
    double Factorial = 1.0;
    int i = 1;
    while(i < N){Factorial *= ++i;}
    return Factorial;
}
double Exp(int numero, int exponente)
{
    double Total = 1;
    int i = 0;
    while(i < exponente)
    {
    Total *= numero;
    ++i;
    }
    return Total;
}


int main()
{
    int X = 0;
    int veces = 0;
    printf(""\nPrograma para calcular Cos(x) mediante sumas de Taylor\nIngresa X:"");
    scanf(""%i"", &X);
    printf(""\nIngrse el numero de sumas: "");
    scanf(""%i"", &veces);
    double Suma_total = 0.0;
    int i=1;
    while(i <= veces){
        if(i%2 == 0)
            Suma_total += (Exp(X, i*2) / Fac(i*2));
        else
            Suma_total -= (Exp(X, i*2) / Fac(i*2));
        ++i;
    }
    printf(""cos(%i) es igual a %lf"", X, (Suma_total + 1.0));

    return 0;
}",57,1667,336
"int factorial(int num)
{
    if(num == 1)
        return 1;
    else
        return num * factorial(num - 1);
}

int Suma(int numero, int sumatoria);



int main()
{
    int numero = 0;
    printf(""Programa calcula la suma de 0 hasta un numero N ingresado por el usuario\nIngresa un numero:"");
    scanf(""%i"",&numero);

    if(numero == 0)
        printf(""La suma de los factoriales de 0 es 1"");
    else
        printf(""La suma de los factoriales de %i es %i"",numero,Suma(numero,0));

    return 0;
}

int Suma(int numero, int Sumatoria)
{
    if(numero >= 1){
        Sumatoria += factorial(numero);
        Suma(--numero, Sumatoria);  
    }else{
        return Sumatoria + 1;
    }
}
",57,1668,263
"void Columnas(int contador, int pibote);
void Filas(int contador, int contador2);

int main()
{
    
    Filas(1, 7);
    return 0;
}

void Columnas(int contador, int pibote)
{
    if(contador <= 34){
        if(contador >= 28){
            if(contador >= (28 + pibote) && contador <= (34 - pibote))
                printf("" "");
            else
                printf(""A"");
            Columnas(++contador, pibote);
        }else{
            printf("" "");
            Columnas(++contador, pibote);
        }
    }
}


void Filas(int contador, int contador2)
{
    printf(""\n"");
    if(contador < 8){
        if(contador >= 4){
            Columnas(1,contador2);
            Filas(++contador,--contador2);

        }else{
            Columnas(1,contador);
            Filas(++contador, --contador2);
        }
    }
}


",57,1669,287
"double Fac(int N)
{
    double Factorial = 1.0;
    for(int i = 1;i < N; Factorial *= ++i);
    return Factorial;
}
double Exp(int numero, int exponente)
{
    double Total = 1;
    for(int i = 0; i < exponente; ++i)
    {
        Total *= numero;
    }
    return Total;
}


int main()
{
    int X = 0;
    int veces = 0;
    printf(""\nPrograma para calcular Senh(x) mediante sumas de Taylor\nIngresa X:"");
    scanf(""%i"", &X); 
    printf(""\nIngrse el numero de sumas: "");
    scanf(""%i"", &veces);
    double Suma_total = 0.0;
    for(int i = 1; i <= veces; ++i){
        Suma_total += Exp(X,(i*2)+1) / Fac((i*2)+1);
    }
    printf(""senh(%i) es igual a %lf"", X, (Suma_total + X));

    return 0;
}


",57,1670,296
"double Exp(int numero, int exponente)
{
    double Total = 1;
    int i = 0;
    while(i < exponente)
    {
    Total *= numero;
    ++i;
    }
    return Total;
}


int main()
{
    int X = 0;
    int veces = 0;
    printf(""\nPrograma para calcular ln(x) mediante sumas de Taylor\nIngresa X:"");
    scanf(""%i"", &X);
    printf(""\nIngrse el numero de sumas: "");
    scanf(""%i"", &veces);
    double Suma_total = 0.0;
    int i=1;
    while(i <= veces){
        if(i%2 == 0)
            Suma_total += Exp(X-1, i+1) / (i+1);
        else
            Suma_total -= Exp(X-1, i+1) / (i +1);
        ++i;
    }
    printf(""ln(%i) es igual a %lf"", X, (Suma_total + (X - 1)));

    return 0;
}",57,1671,284
"void ft_print_comb2(); 

void ft_print_comb2(){
    int x = 9;
    int m = 0;
    for(int i = 0; i<= 9; i++){
        if(i == 9)
            x = 8;
        for(int j = 0; j <= x; j++){
            for(int k = 0; k <= 9; k++){    
                if(j != 0)
                    m = 0;
                for(int l = m; l <= 9; l++){
                    if( i*10 + j != k*10+l){
                        printf(""%i%i %i%i, "", i,j,k,l);
                    }
                }
            }
        }
    }
}

int main(){
    ft_print_comb2(); 
    return 0;
}",57,1672,217
"double Fac(double num)
{
        if(num == 1)
                return 1;
        else
                return num * Fac(num - 1);
}

double Exp(int Exponente, double numero)
{
        if(Exponente == 1){
                return numero;
        }else{
                return numero * Exp(--Exponente, numero);
        }
}




void Sen(int contador, int iteraciones, double total, double X);


int main(){
        double X;
        printf(""Programa para calcular el sen(X) por medio de sumas de Taylor\nValor de X:"");
        scanf(""%lf"", &X);
        Sen(1,50,0,X);
        return 0;
}

void Sen(int contador, int iteraciones, double total, double X)
{
        if(contador <= iteraciones){
        if(contador%2 == 0){
            total = total + (Exp((contador*2)+1, X) / Fac((contador*2)+1));
            Sen(++contador, iteraciones,total,X);
        }else{
            total = total - (Exp((contador*2)+1, X) / Fac((contador*2)+1));
                        Sen(++contador, iteraciones,total,X);
        }
        }else{
                printf(""\n**El Sen(%lf) es igual a: %lf"",X,total+X);
        }
}
",57,1673,364
"int main()
{
    char letra;
    int i = 0;
    int j;
    while( i< 7){
    switch (i){
            case 0: letra = 'P';break;
            case 1: letra = 'N';break;
            case 2: letra = 'L';break;
            case 3: letra = 'J';break;
            case 4: letra = 'H';break;
            case 5: letra = 'F';break;
            case 6: letra = 'D';break;
    }
    j = 0;
    while(j <= 13){
        if(j >= (1 + i) && j <= (13-i))
            printf(""%c"", letra);
        else
        printf("" "");
        ++j;
    }
        printf(""\n"");
        ++i;
    }
    return 0; 
}",57,1674,225
"double Fac(int N)
{
    double Factorial = 1.0;
    int i = 1;
    do{Factorial *= ++i;}while(i < N);
    return Factorial;
}
double Exp(int numero, int exponente)
{
    double Total = 1;
    int i = 0;
    do{
    Total *= numero;
    ++i;
    }while(i < exponente);
    return Total;
}

int main()
{
    int X = 0;
    int veces = 0;
    printf(""\nPrograma para calcular Cosh(x) mediante sumas de Taylor\nIngresa X:"");
    scanf(""%i"", &X);
    printf(""\nIngrse el numero de sumas: "");
    scanf(""%i"", &veces);
    double Suma_total = 0.0;
    int i=1;
    {
        Suma_total += Exp(X,(i*2)) / Fac((i*2));
        ++i;
    }while(i <= veces);
    printf(""Cosh(%i) es igual a %lf"", X, (Suma_total + 1));

    return 0;
}",57,1675,299
"double Fac(int N)
{
    double Factorial = 1.0;
    for(int i = 1;i < N; Factorial *= ++i);
    return Factorial;
}
double Exp(int numero, int exponente)
{
    double Total = 1;
    for(int i = 0; i < exponente; ++i)
    {
    Total *= numero;
    }
    return Total;
}


int main()
{
    int X = 0;
    int veces = 0;
    printf(""\nPrograma para calcular Euler elevado a X mediante sumas de Taylor\nIngresa X:"");
    scanf(""%i"", &X);
    printf(""\nIngrse el numero de sumas"");
    scanf(""%i"", &veces);
    double Suma_total = 0.0;
    for(int i = 1; i <= veces; ++i){
        Suma_total += (Exp(X,i) / Fac(i));
    }
    printf(""e^%i es igual a %lf"", X, (Suma_total + 1.0));

    return 0;
}

",57,1676,289
"void Columna(int pibote)
{
    int j = 1;
    do
    {
        if(j >= (10 - pibote) && j <= (10 + pibote))
            printf(""Z"");
        else
            printf("" "");
        ++j;
    }while(j <= 20);
}

int main()
{
    int contador1 = 0;
    int contador2 = 7;
    do
    {
    printf(""\n"");
    if(contador1 > 4)
        Columna(contador2 - 1);
    else
        Columna(contador1 - 1);
    --contador2;
    ++contador1;
    }while(contador1 < 8);
    return 0;

}",57,1677,197
"int ft_strlen(char *);
int ft_strlen(char *dato){
    int i = 0;
    while(dato[i] != '\0')++i;
    return i;
}

char *ft_strrev (char *);
char *ft_strrev (char * str){
    int longitud = ft_strlen(str);
    char *string; 

    for(int i = 1; i <= longitud + 1; i++){
        if(i > longitud)
            string[longitud] = '\0';
        else
            string[i -1] = str[longitud - i];
    }
    return string;
}



int main(){
    char *palabra = ""casa"";
    palabra = ft_strrev(palabra);
    printf(""%s"", palabra);
    return 0;
}",57,1678,213
"int main()
{
    int Mayor = 0;
    int menor = 0; 
    int Mayor_150 = 0; 
    int negativos = 0;
    float promedio_P = 0.0; 
    int contador = 1; 
    int num_p = 0;  
    for(contador = 0; contador < 10;)
    {
     int numero = 0;
        
     printf(""\nIngrese por favor el numero: "");
     scanf(""%i"", &numero);
     if(numero != 0){
         if(numero > 150){
             ++Mayor_150;    
         }
         if(numero > Mayor){
             Mayor = numero;    
         }else if(numero < menor){
             menor = numero;    
         }

         if(numero > 0){
             ++num_p;
             promedio_P += numero; 
         }else{
             ++negativos;          
         }
         ++contador;
         }
     }
     printf(""\n***Fin del Ciclo***\n"");
     promedio_P = promedio_P / num_p;

     printf(""\nCantidad de numeros mayores a 150: %i"", Mayor_150);
     printf(""\nNumero mayor: %i  Numero menor: %i"", Mayor, menor);   
     printf(""\nCantidad de numeros negativos encontrador: %i"", negativos);
     printf(""\nPromedio positivos encontrados: %f"", promedio_P);
}

",57,1679,398
"double Exp(int numero, int exponente)
{
    double Total = 1;
    for(int i = 0; i < exponente; ++i)
    {
        Total *= numero;
    }
    return Total;
}


int main()
{
    int X = 0;
    int veces = 0;
    printf(""\nPrograma para calcular ln(x) mediante sumas de Taylor\nIngresa X:"");
    scanf(""%i"", &X); 
    printf(""\nIngrse el numero de sumas: "");
    scanf(""%i"", &veces);
    double Suma_total = 0.0;
    for(int i = 1; i <= veces; ++i){
       if(i%2 == 0)
      Suma_total += Exp(X-1, i+1) / (i+1);
       else
      Suma_total -= Exp(X-1, i+1) / (i +1);
    }
    printf(""ln(%i) es igual a %lf"", X, (Suma_total + (X - 1)));
    return 0;
}
",57,1680,278
"void Pedir_numeros(int Mayor, int menor, int Mayor_150, int negativos,int promedio_P, int contador, int num_p)
{
    int numero = 0;
    if(contador <= 10){
        printf(""\nIngrese por favor el numero: "");
        scanf(""%i"", &numero);
        if(numero != 0){
            if(numero > 150){
                ++Mayor_150;    
            }

            if(numero > Mayor){
                Mayor = numero;    
            }else if(numero < menor){   
                menor = numero;    
            }

            if(numero > 0){
                ++num_p;
                promedio_P += numero; 
            }else{
                ++negativos;          
            }
            Pedir_numeros(Mayor,menor,Mayor_150,negativos,promedio_P,++contador,num_p);
        }else{
            Pedir_numeros(Mayor,menor,Mayor_150,negativos,promedio_P,contador,num_p);
        }
    }else{
        printf(""\n***Fin del Ciclo***\n"");
        promedio_P = promedio_P / num_p;

        printf(""\nCantidad de numeros mayores a 150: %i"", Mayor_150);
        printf(""\nNumero mayor: %i  Numero menor: %i"", Mayor, menor);   
        printf(""\nCantidad de numeros negativos encontrador: %i"", negativos);
        printf(""\nPromedio positivos encontrados: %i"", promedio_P);
    }
}


int main()
{
    Pedir_numeros(0,0,0,0,0,1,0); 
    return 0;
}
",57,1681,467
"void mostrar(int X_1, int X_2, int contador);

int main()
{
    system(""cls""); 
    int contador = 1;
    int X_1 = 1;
    int X_2 = 80;
    do{
        if(contador <= 80){
            if(contador == X_1)
                printf(""X"");
            else if(contador == X_2)
                printf(""X"");
            else
                printf("" "");
         }else{
             sleep(0.4);
             system(""cls"");
             ++X_1;
             --X_2;
            contador = 1;
         }
    ++contador;
    }while(X_1 != 41);
    return 0;
}

",57,1682,193
"double Fac(int N)
{
    double Factorial = 1.0;
    int i = 1;
    do{Factorial *= ++i;}while(i < N);
    return Factorial;
}
double Exp(int numero, int exponente)
{
    double Total = 1;
    int i = 0;
    do{
    Total *= numero;
    ++i;
    }while(i < exponente);
    return Total;
}

int main()
{
    int X = 0;
    int veces = 0;
    printf(""\nPrograma para calcular sen(X) mediante sumas de Taylor\nIngresa X:"");
    scanf(""%i"", &X);
    printf(""\nIngrse el numero de sumas: "");
    scanf(""%i"", &veces);
    double Suma_total = 0.0;
    int i=1;
    do{
        if(i%2 == 0)
            Suma_total += Exp(X, (i*2)+1) / Fac((i*2)+1);
        else
            Suma_total -= Exp(X, (i*2)+1) / Fac((i*2)+1);
        ++i;
    }while(i <= veces);
    printf(""sen(%i) es igual a %lf"", X, (Suma_total + X));

    return 0;
}",57,1683,343
"double Fac(int N)
{
    double Factorial = 1.0;
    int i = 1;
    while(i < N){Factorial *= ++i;}
    return Factorial;
}
double Exp(int numero, int exponente)
{
    double Total = 1;
    int i = 0;
    while(i < exponente)
    {
    Total *= numero;
    ++i;
    }
    return Total;
}


int main()
{
    int X = 0;
    int veces = 0;
    printf(""\nPrograma para calcular sen(X) mediante sumas de Taylor\nIngresa X:"");
    scanf(""%i"", &X);
    printf(""\nIngrse el numero de sumas: "");
    scanf(""%i"", &veces);
    double Suma_total = 0.0;
    int i=1;
    while(i <= veces){
        if(i%2 == 0)
            Suma_total += Exp(X, (i*2)+1) / Fac((i*2)+1);
        else
            Suma_total -= Exp(X, (i*2)+1) / Fac((i*2)+1);
        ++i;
    }
    printf(""sen(%i) es igual a %lf"", X, (Suma_total + X));

    return 0;
}",57,1684,341
"double Fac(int N)
{
    double Factorial = 1.0;
    for(int i = 1;i < N; Factorial *= ++i);
    return Factorial;
}
double Exp(int numero, int exponente)
{
    double Total = 1;
    for(int i = 0; i < exponente; ++i)
    {
        Total *= numero;
    }
    return Total;
}


int main()
{
    int X = 0;
    int veces = 0;
    printf(""\nPrograma para calcular Cos(x) mediante sumas de Taylor\nIngresa X:"");
    scanf(""%i"", &X); 
    printf(""\nIngrse el numero de sumas: "");
    scanf(""%i"", &veces);
    double Suma_total = 0.0;
    for(int i = 1; i <= veces; ++i){
        if(i%2 == 0)
        Suma_total += (Exp(X, i*2) / Fac(i*2));
    else
        Suma_total -= (Exp(X, i*2) / Fac(i*2));
    }
    printf(""cos(%i) es igual a %lf"", X, (Suma_total + 1.0));

    return 0;
}


",57,1685,331
"double Fac(int N)
{
    double Factorial = 1.0;
    int i = 1;
    do{Factorial *= ++i;}while(i < N);
    return Factorial;
}
double Exp(int numero, int exponente)
{
    double Total = 1;
    int i = 0;
    do{
    Total *= numero;
    ++i;
    }while(i < exponente);
    return Total;
}


int main()
{
    int X = 0;
    int veces = 0;
    printf(""\nPrograma para calcular Senh(x) mediante sumas de Taylor\nIngresa X:"");
    scanf(""%i"", &X);
    printf(""\nIngrse el numero de sumas: "");
    scanf(""%i"", &veces);
    double Suma_total = 0.0;
    int i=1;
    do{
        Suma_total += Exp(X,(i*2)+1) / Fac((i*2)+1);
        ++i;
    }while(i <= veces);
    printf(""senh(%i) es igual a %lf"", X, (Suma_total + X));

    return 0;
}",57,1686,304
"double Fac(int N)
{
    double Factorial = 1.0;
    for(int i = 1;i < N; Factorial *= ++i);
    return Factorial;
}
double Exp(int numero, int exponente)
{
    double Total = 1;
    for(int i = 0; i < exponente; ++i)
    {
        Total *= numero;
    }
    return Total;
}


int main()
{
    int X = 0;
    int veces = 0;
    printf(""\nPrograma para calcular Cosh(x) mediante sumas de Taylor\nIngresa X:"");
    scanf(""%i"", &X);
    printf(""\nIngrse el numero de sumas: "");
    scanf(""%i"", &veces);
    double Suma_total = 0.0;
    for(int i = 1; i <= veces; ++i){
        Suma_total += Exp(X,(i*2)) / Fac((i*2));
    }
    printf(""Cosh(%i) es igual a %lf"", X, (Suma_total + 1));

    return 0;
}


",57,1687,292
"void Columna(int pibote)
{
    int j = 0;
    while(j <= 40){
        if(j >= 40 - pibote)
            printf(""A"");
        else
            printf("" "");
    ++j;
    }
}


int main()
{
    int contador1 = 0;
    int contador2 = 10;
    while(contador1 < 11)
    {
        if(contador1 > 5)
            Columna(contador2);
        else
            Columna(contador1);
        --contador2;
        printf(""\n"");
        ++contador1;
    }
    return 0;
}",57,1688,177
"int main()
{
    int Mayor = 0;
    int menor = 0;
    int Mayor_150 = 0;
    int negativos = 0;
    float promedio_P = 0.0;
    int contador = 0;
    int num_p = 0;
    do
    {
     int numero = 0;
     printf(""\nIngrese por favor el numero:"");
     scanf(""%i"", &numero);
     if(numero != 0){
         if(numero > 150){
             ++Mayor_150;    
         }
         if(numero > Mayor){
             Mayor = numero;    
         }else if(numero < menor){
             menor = numero;    
         }

         if(numero > 0){
             ++num_p;
             promedio_P += numero; 
         }else{
             ++negativos;          
         }
         ++contador;
         }
     }while(contador < 10);
     printf(""\n***Fin del Ciclo***\n"");
     promedio_P = promedio_P / num_p;

     printf(""\nCantidad de numeros mayores a 150: %i"", Mayor_150);
     printf(""\nNumero mayor: %i  Numero menor: %i"", Mayor, menor);   
     printf(""\nCantidad de numeros negativos encontrador: %i"", negativos);
     printf(""\nPromedio positivos encontrados: %f"", promedio_P);
}

",57,1689,385
"void mostrar(int X_1, int X_2, int contador);

int main()
{
    system(""cls""); 
    int contador = 1;
    int X_1 = 1;
    int X_2 = 80;
    while(X_1 != 41){
        if(contador <= 80){
            if(contador == X_1)
                printf(""X"");
            else if(contador == X_2)
                printf(""X"");
            else
                printf("" "");
         }else{
             sleep(0.4);
             system(""cls"");
             ++X_1;
             --X_2;
            contador = 1;
         }
    ++contador;
    }
    return 0;
}

",57,1690,191
"double Fac(int N)
{
    double Factorial = 1.0;
    for(int i = 1;i < N; Factorial *= ++i);
    return Factorial;
}
double Exp(int numero, int exponente)
{
    double Total = 1;
    for(int i = 0; i < exponente; ++i)
    {
        Total *= numero;
    }
    return Total;
}


int main()
{
    int X = 0;
    int veces = 0;
    printf(""\nPrograma para calcular sen(X) mediante sumas de Taylor\nIngresa X:"");
    scanf(""%i"", &X); 
    printf(""\nIngrse el numero de sumas: "");
    scanf(""%i"", &veces);
    double Suma_total = 0.0;
    for(int i = 1; i <= veces; ++i){
        if(i%2 == 0)
            Suma_total += Exp(X, (i*2)+1) / Fac((i*2)+1);
    else
        Suma_total -= Exp(X, (i*2)+1) / Fac((i*2)+1);
    }
    printf(""sen(%i) es igual a %lf"", X, (Suma_total + X));

    return 0;
}

",57,1691,335
"double Exp(int numero, int exponente)
{
    double Total = 1;
    int i = 0;
    do{
    Total *= numero;
    ++i;
    }while(i < exponente);
    return Total;
}

int main()
{
    int X = 0;
    int veces = 0;
    printf(""\nPrograma para calcular ln(x) mediante sumas de Taylor\nIngresa X:"");
    scanf(""%i"", &X);
    printf(""\nIngrse el numero de sumas: "");
    scanf(""%i"", &veces);
    double Suma_total = 0.0;
    int i=1;
    do{
        if(i%2 == 0)
            Suma_total += Exp(X-1, i+1) / (i+1);
        else
            Suma_total -= Exp(X-1, i+1) / (i +1);
        ++i;
    }while(i <= veces);
    printf(""ln(%i) es igual a %lf"", X, (Suma_total + (X - 1)));
    return 0;
}",57,1692,283
"# include ""crc32.h""

unsigned char frame[1546];  

unsigned char data[] = {0x64,0x62,0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,
                        0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,
                        0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,
                        0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,
                        0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,
                        0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,
                        0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,
                        0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,
                        0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,
                        0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,
                        0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,
                        0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,
                        0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,
                        0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,
                        0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,
                        0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,
                        0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,0x11,0x33,
                        0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,
                        0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,
                        0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,
                        0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,
                        0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,
                        0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,
                        0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,
                        0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,
                        0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,
                        0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,
                        0xd1,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3};
unsigned char sta_addr[6] = {0x11,0x33,0x55,0x44,0x22,0x55};  
unsigned char des_addr[6] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};  
unsigned short protocol = 1; 


void welcome()
{
    printf(""[INFO] Usage: frame sender process.\n"");
}

 
void output_octal(unsigned char *x,unsigned int len) {
    int i;
    for (i =0;i<len;i++) {
        printf(""%02x"",x[i]);
        if (i != len-1) printf("" "");
    }
    printf(""\n"");
}

 
int frame_construction(unsigned char *sta_addr, unsigned char *des_addr,
                        unsigned short protocol, unsigned char *payload,
                        unsigned int payload_len)
{   
    
    if(payload_len < 46){
        printf(""[Error] Payload length too low!\n"");
        exit(1);
    }else if(payload_len >1500){
        printf(""[Error] Payload length too long!\n"");
        exit(1);
    }

    memcpy(&frame[0],des_addr,6);
    memcpy(&frame[6],sta_addr,6);
    memcpy(&frame[12],&protocol,sizeof(protocol));
    memcpy(&frame[14],payload,payload_len);
    init_crc_table();
    unsigned int crc32_result = crc32(frame,14+payload_len);
    
    memcpy(&frame[14+payload_len],&crc32_result,sizeof(crc32_result));
        unsigned char crc32_result_[4];
    memcpy(crc32_result_,&crc32_result,sizeof(crc32_result));
    
    
    printf(""******Received frame information******\n"");
    printf(""Start address: %x\n"",sta_addr);
    printf(""Des address  : %x\n"",des_addr);
    printf(""protocol     : %x\n"",protocol);
    printf(""payload      : %x\n"",payload);
    printf(""CRC32        : "");
    output_octal(crc32_result_,4);
    printf(""**************************************\n"");
    
    return payload_len+6+6+sizeof(protocol)+sizeof(crc32_result);
}

 
int send_frame(unsigned char *frame, unsigned int frame_len){
    FILE *file = fopen(""pipe.bin"", ""wb+"");
    if(file == NULL)
    {
        printf(""[INFO] File open error!\n"");
        return 0;
    }
    fwrite(&frame_len,sizeof(frame_len),1,file);
    fwrite(frame, sizeof(char), frame_len, file);
    fclose(file);
    printf(""[INFO] Frame send success!\n"");
    return 0;
}

int main(){
    unsigned int length;
    
    welcome();
    




    
    
    length = frame_construction(sta_addr,des_addr,protocol,data,sizeof(data));
    printf(""Frame length: %d\n"",length);
    frame[length-10] = ~frame[length-10];
    send_frame(frame,length);

    return 0;
}
",58,1693,2357
"# include ""crc32.h""

unsigned char frame[2000];  
unsigned char sta_addr[6];
unsigned char des_addr[6];
unsigned short protocol;
unsigned char *payload;
unsigned int frame_len;
unsigned int payload_len;
unsigned char my_addr[6] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};  


void welcome()
{
    printf(""[INFO] Usage: frame receiver process.\n"");
    printf(""[INFO] My address  : "");
    output_octal(my_addr,6);
}

 
int addr_check(unsigned char des_addr[6]){
    int flag = 1;
    int i =0;
    for(i = 0;i<6;i++){
        if(des_addr[i] != my_addr[i]) flag = 0;
    }
    if(flag){
        printf(""[INFO] Address check success!\n"");
    }else {
        printf(""[Error] Address check error!\n"");
    }
    return flag;
}

 
int output_octal(unsigned char *x,unsigned int len) {
    int i;
    for (i =0;i<len;i++) {
        printf(""%02x"",x[i]);
        if (i != len-1) printf("" "");
        if(i %9 == 0 && i!=0) printf(""\n"");
    }
    printf(""\n"");
    return 0;
}

 
int receive_frame(){
    FILE *file = fopen(""pipe.bin"", ""r"");

    
    fread(&frame_len,sizeof(frame_len),1,file);
    printf(""[INFO] frame length: %d\n"",frame_len);
    if(frame_len < 64){  
        printf(""[Error] Payload length too low!\n"");
        exit(1);
    }else if(frame_len >1518){
        printf(""[Error] Payload length too long!\n"");
        exit(1);
    }

    
    fread(&frame,sizeof(char),frame_len,file);
    
    memcpy(&des_addr,&frame[0],6);
    memcpy(&sta_addr,&frame[6],6);
    memcpy(&protocol,&frame[12],sizeof(protocol));
    payload = &frame[14];    
    
    
    if(!addr_check(des_addr))   exit(1);

    
    init_crc_table();
    unsigned int crc32_temp = crc32(frame,frame_len-4);
    unsigned char crc32_result[4];
    memcpy(crc32_result,&crc32_temp,sizeof(crc32_temp));

    int i = 0;
    int flag_crc32 = 1;
    for(i = 3;i<sizeof(crc32_result);i--){
        if(crc32_result[i] != frame[frame_len-(4-i)]) flag_crc32 = 0;
    }
    if(flag_crc32){
        printf(""[INFO] CRC32 check success!\n"");
    }else {
        printf(""[Error] CRC32 check error!\n"");
        printf(""[Error] frame's CRC32 : "");
        printf(""%02x %02x %02x %02x\n"",frame[frame_len-4],frame[frame_len-3],frame[frame_len-2],frame[frame_len-1]);
        printf(""[Error] calculated CRC32 : "");
        output_octal(crc32_result,4);
        exit(1);
    }

    
    printf(""******Received frame information******\n"");
    printf(""Start address: "");
    output_octal(sta_addr,6);
    printf(""Des address  : "");
    output_octal(des_addr,6);
    printf(""protocol     : %d\n"",protocol);
    printf(""payload      : "");
    output_octal(payload,frame_len-6-6-2-4);
    printf(""CRC32        : "");
    output_octal(crc32_result,4);
    printf(""**************************************\n"");
    printf(""[INFO] Frame received success!\n"");
}

int main(){
    welcome();
    receive_frame();
}



",58,1694,1114
"#define BUFSIZE     1024*4

static unsigned int crc_table[256];
const static char * program_name = ""crc32"";

static void usage(void);
static void init_crc_table(void);
static unsigned int crc32(unsigned char * buffer, unsigned int size);
static int calc_img_crc(const char * in_file, unsigned int * img_crc);

static void usage(void)
{
    fprintf(stderr, ""Usage: %s input_file\n"", program_name);
}


static void init_crc_table(void)
{
    unsigned int c;
    unsigned int i, j;
    
    for (i = 0; i < 256; i++) {
        c = (unsigned int)i;
        for (j = 0; j < 8; j++) {
            if (c & 1)
                c = 0xedb88320L ^ (c >> 1);
            else
                c = c >> 1;
        }
        crc_table[i] = c;
    }
}



unsigned int crc32_table[256];
 
void make_crc32_table() {
    unsigned int c;
    int i = 0;
    int bit = 0;
    
    for(i = 0; i < 256; i++)
    {
        c  = (unsigned int)i;
        
        for(bit = 0; bit < 8; bit++)
        {
            if(c&1)
            {
                c = (c >> 1)^(0xEDB88320);
            }
            else
            {
                c =  c >> 1;
            }
            
        }
        crc32_table[i] = c;
    }
}
 
unsigned int crc32lql(unsigned char *string, unsigned int size) {
    make_crc32_table();
    unsigned int crc = 0xffffffff;
    while(size--)
        crc = (crc >> 8)^(crc32_table[(crc ^ *string++)&0xff]);
    return crc;
}


static unsigned int crc32(unsigned char *buffer, unsigned int size)
{
    unsigned int crc = 0xFFFFFFFF;
    unsigned int i;
    for (i = 0; i < size; i++) {
        crc = crc_table[(crc ^ buffer[i]) & 0xff] ^ (crc >> 8);
    }
    return crc ;
}

unsigned int crc32cyy(unsigned char *data,int len) {
    unsigned int crc = 0xFFFFFFFF;
    int i;
    for (i=0;i<len;i++) {
        crc = crc ^ data[i];
        int j;
        for (j=7;j>=0;j--) {
            crc = (crc >> 1) ^ (0xEDB88320 & (-(crc & 1)));
        }
    }
    return ~crc;
}











































unsigned char data[] = {0x64,0x62,0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,
                        0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,
                        0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,
                        0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,
                        0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,
                        0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,
                        0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,
                        0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,
                        0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,
                        0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,
                        0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,
                        0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,
                        0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,
                        0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,
                        0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,
                        0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,
                        0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,0x11,0x33,
                        0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,
                        0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,
                        0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,
                        0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,
                        0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,
                        0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,
                        0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,
                        0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,
                        0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,
                        0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,
                        0xd1,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3};
unsigned char sta_addr[] = {0x11,0x33,0x55,0x44,0x22,0x55};
unsigned char des_addr[] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};


int main(int argc, char **argv)
{
    
    
    

    
    
    
    

    
    
    
    
    
    

    

    
    
    
    
    
    
    
    

    printf(""%d"",sizeof(data)); 

    return 0;
}

",58,1695,2458
"unsigned short Checksum(unsigned char* buffer, unsigned short size){
    unsigned int sum = 0;
    unsigned short cksum;
    unsigned char lower,higher;
    unsigned short temp;
    while(size > 1){
        lower = buffer[size-1];
        higher = buffer[size - 2];
        temp = higher;
        temp = (temp << 8) + lower;
        printf(""%04x\n"",temp);
        sum += temp;
        size -= 2;
    }
    if(size == 1){  
        lower = buffer[size-1];
        higher = 0x00;
        temp = higher;
        temp = (temp << 8) + lower;
        sum += temp;
    }
    cksum = (sum >> 16) + (sum & 0xffff);
    cksum = ~cksum;
    printf(""%04x\n"",cksum);
    return cksum;
}

  int main(){
      unsigned char data[] = {0x47,0x00,0x87,0x00,0x00,0x00,0x00,0x00,0x14,0x00,0x4d,0x5f,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x00};
      unsigned short ck = Checksum(data,sizeof(data));
      printf(""%04x"",ck);
  }
",58,1696,419
"# include ""crc32.h""

unsigned char frame[2000];  
unsigned char sta_addr[6];
unsigned char des_addr[6];
unsigned short protocol;
unsigned char *payload;
unsigned int frame_len;
unsigned int payload_len;
unsigned char my_addr[6] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};  


void welcome()
{
    printf(""[INFO] Usage: frame receiver process.\n"");
    printf(""[INFO] My address  : "");
    output_octal(my_addr,6);
}

 
int addr_check(unsigned char des_addr[6]){
    int flag = 1;
    int i =0;
    for(i = 0;i<6;i++){
        if(des_addr[i] != my_addr[i]) flag = 0;
    }
    if(flag){
        printf(""[INFO] Address check success!\n"");
    }else {
        printf(""[Error] Address check error!\n"");
    }
    return flag;
}

 
int output_octal(unsigned char *x,unsigned int len) {
    int i;
    for (i =0;i<len;i++) {
        printf(""%02x"",x[i]);
        if (i != len-1) printf("" "");
        if(i %9 == 0 && i!=0) printf(""\n"");
    }
    printf(""\n"");
    return 0;
}

 
int receive_frame(){
    FILE *file = fopen(""pipe.bin"", ""r"");

    
    fread(&frame_len,sizeof(frame_len),1,file);
    printf(""[INFO] frame length: %d\n"",frame_len);
    if(frame_len < 64){  
        printf(""[Error] Payload length too low!\n"");
        exit(1);
    }else if(frame_len >1518){
        printf(""[Error] Payload length too long!\n"");
        exit(1);
    }

    
    fread(&frame,sizeof(char),frame_len,file);
    
    memcpy(&des_addr,&frame[0],6);
    memcpy(&sta_addr,&frame[6],6);
    memcpy(&protocol,&frame[12],sizeof(protocol));
    payload = &frame[14];    
    
    
    if(!addr_check(des_addr))   exit(1);

    
    init_crc_table();
    unsigned int crc32_temp = crc32(frame,frame_len-4);
    unsigned char crc32_result[4];
    memcpy(crc32_result,&crc32_temp,sizeof(crc32_temp));

    int i = 0;
    int flag_crc32 = 1;
    for(i = 3;i<sizeof(crc32_result);i--){
        if(crc32_result[i] != frame[frame_len-(4-i)]) flag_crc32 = 0;
    }
    if(flag_crc32){
        printf(""[INFO] CRC32 check success!\n"");
    }else {
        printf(""[Error] CRC32 check error!\n"");
        printf(""[Error] frame's CRC32 : "");
        printf(""%02x %02x %02x %02x\n"",frame[frame_len-4],frame[frame_len-3],frame[frame_len-2],frame[frame_len-1]);
        printf(""[Error] calculated CRC32 : "");
        output_octal(crc32_result,4);
        exit(1);
    }

    
    printf(""******Received frame information******\n"");
    printf(""Start address: "");
    output_octal(sta_addr,6);
    printf(""Des address  : "");
    output_octal(des_addr,6);
    printf(""protocol     : %d\n"",protocol);
    printf(""payload      : "");
    output_octal(payload,frame_len-6-6-2-4);
    printf(""CRC32        : "");
    output_octal(crc32_result,4);
    printf(""**************************************\n"");
    printf(""[INFO] Frame received success!\n"");
}

int main(){
    welcome();
    receive_frame();
}



",58,1697,1114
"# include ""crc32.h""

unsigned char frame[1546];  

unsigned char data[] = {0x64,0x62,0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,
                        0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,
                        0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,
                        0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,
                        0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,
                        0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,
                        0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,
                        0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,
                        0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,
                        0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,
                        0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,
                        0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,
                        0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,
                        0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,
                        0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,
                        0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,
                        0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,0x11,0x33,
                        0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,
                        0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,
                        0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,
                        0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,
                        0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,
                        0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,
                        0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,
                        0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,
                        0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,
                        0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,
                        0xd1,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3};
unsigned char sta_addr[6] = {0x11,0x33,0x55,0x44,0x22,0x55};  
unsigned char des_addr[6] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};  
unsigned short protocol = 1; 


void welcome()
{
    printf(""[INFO] Usage: frame sender process.\n"");
}

 
void output_octal(unsigned char *x,unsigned int len) {
    int i;
    for (i =0;i<len;i++) {
        printf(""%02x"",x[i]);
        if (i != len-1) printf("" "");
    }
    printf(""\n"");
}

 
int frame_construction(unsigned char *sta_addr, unsigned char *des_addr,
                        unsigned short protocol, unsigned char *payload,
                        unsigned int payload_len)
{   
    
    if(payload_len < 46){
        printf(""[Error] Payload length too low!\n"");
        exit(1);
    }else if(payload_len >1500){
        printf(""[Error] Payload length too long!\n"");
        exit(1);
    }

    memcpy(&frame[0],des_addr,6);
    memcpy(&frame[6],sta_addr,6);
    memcpy(&frame[12],&protocol,sizeof(protocol));
    memcpy(&frame[14],payload,payload_len);
    init_crc_table();
    unsigned int crc32_result = crc32(frame,14+payload_len);
    
    memcpy(&frame[14+payload_len],&crc32_result,sizeof(crc32_result));
        unsigned char crc32_result_[4];
    memcpy(crc32_result_,&crc32_result,sizeof(crc32_result));
    
    
    printf(""******Received frame information******\n"");
    printf(""Start address: %x\n"",sta_addr);
    printf(""Des address  : %x\n"",des_addr);
    printf(""protocol     : %x\n"",protocol);
    printf(""payload      : %x\n"",payload);
    printf(""CRC32        : "");
    output_octal(crc32_result_,4);
    printf(""**************************************\n"");
    
    return payload_len+6+6+sizeof(protocol)+sizeof(crc32_result);
}

 
int send_frame(unsigned char *frame, unsigned int frame_len){
    FILE *file = fopen(""pipe.bin"", ""wb+"");
    if(file == NULL)
    {
        printf(""[INFO] File open error!\n"");
        return 0;
    }
    fwrite(&frame_len,sizeof(frame_len),1,file);
    fwrite(frame, sizeof(char), frame_len, file);
    fclose(file);
    printf(""[INFO] Frame send success!\n"");
    return 0;
}

int main(){
    unsigned int length;
    
    welcome();
    




    
    
    length = frame_construction(sta_addr,des_addr,protocol,data,sizeof(data));
    printf(""Frame length: %d\n"",length);
    frame[length-10] = ~frame[length-10];
    send_frame(frame,length);

    return 0;
}
",58,1698,2357
"#include ""sender.h""

unsigned char frame[1546]; 
unsigned char data[] = ""Hello! This is a frame payload data. It's a computer project for quxiangjun 20186471. "";
unsigned char sta_addr[6] = {0x11, 0x33, 0x55, 0x44, 0x22, 0x55}; 
unsigned char des_addr[6] = {0x42, 0x23, 0x52, 0xb5, 0xa6, 0xc3}; 
unsigned short protocol = 1;


void welcome(){
    printf(""[INFO] Usage: frame sender process.\n"");
}

int main(){
    unsigned int length;

    welcome();

    
    length = frame_construction(frame, sta_addr, des_addr, protocol, data, sizeof(data));
    send_frame(frame, length);
    





    return 0;
}
",58,1699,254
"# include ""crc32.h""

unsigned char frame[1546];  

unsigned char data[] = {0x64,0x62,0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,
                        0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,
                        0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,
                        0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,
                        0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,
                        0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,
                        0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,
                        0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,
                        0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,
                        0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,
                        0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,
                        0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,
                        0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,
                        0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,
                        0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,
                        0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,
                        0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,0x11,0x33,
                        0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,
                        0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,
                        0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,
                        0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,
                        0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,
                        0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,
                        0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,
                        0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,
                        0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,
                        0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,
                        0xd1,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3};
unsigned char sta_addr[6] = {0x11,0x33,0x55,0x44,0x22,0x55};  
unsigned char des_addr[6] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};  
unsigned short protocol = 1; 


void welcome()
{
    printf(""[INFO] Usage: frame sender process.\n"");
}

 
void output_octal(unsigned char *x,unsigned int len) {
    int i;
    for (i =0;i<len;i++) {
        printf(""%02x"",x[i]);
        if (i != len-1) printf("" "");
    }
    printf(""\n"");
}

 
int frame_construction(unsigned char *sta_addr, unsigned char *des_addr,
                        unsigned short protocol, unsigned char *payload,
                        unsigned int payload_len)
{   
    
    if(payload_len < 46){
        printf(""[Error] Payload length too low!\n"");
        exit(1);
    }else if(payload_len >1500){
        printf(""[Error] Payload length too long!\n"");
        exit(1);
    }

    memcpy(&frame[0],des_addr,6);
    memcpy(&frame[6],sta_addr,6);
    memcpy(&frame[12],&protocol,sizeof(protocol));
    memcpy(&frame[14],payload,payload_len);
    init_crc_table();
    unsigned int crc32_result = crc32(frame,14+payload_len);
    
    memcpy(&frame[14+payload_len],&crc32_result,sizeof(crc32_result));
        unsigned char crc32_result_[4];
    memcpy(crc32_result_,&crc32_result,sizeof(crc32_result));
    
    
    printf(""******Received frame information******\n"");
    printf(""Start address: %x\n"",sta_addr);
    printf(""Des address  : %x\n"",des_addr);
    printf(""protocol     : %x\n"",protocol);
    printf(""payload      : %x\n"",payload);
    printf(""CRC32        : "");
    output_octal(crc32_result_,4);
    printf(""**************************************\n"");
    
    return payload_len+6+6+sizeof(protocol)+sizeof(crc32_result);
}

 
int send_frame(unsigned char *frame, unsigned int frame_len){
    FILE *file = fopen(""pipe.bin"", ""wb+"");
    if(file == NULL)
    {
        printf(""[INFO] File open error!\n"");
        return 0;
    }
    fwrite(&frame_len,sizeof(frame_len),1,file);
    fwrite(frame, sizeof(char), frame_len, file);
    fclose(file);
    printf(""[INFO] Frame send success!\n"");
    return 0;
}

int main(){
    unsigned int length;
    
    welcome();
    




    
    
    length = frame_construction(sta_addr,des_addr,protocol,data,sizeof(data));
    printf(""Frame length: %d\n"",length);
    frame[length-10] = ~frame[length-10];
    send_frame(frame,length);

    return 0;
}
",58,1700,2357
"# include ""crc32.h""

unsigned char frame[2000];  
unsigned char sta_addr[6];
unsigned char des_addr[6];
unsigned short protocol;
unsigned char *payload;
unsigned int frame_len;
unsigned int payload_len;
unsigned char my_addr[6] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};  


void welcome()
{
    printf(""[INFO] Usage: frame receiver process.\n"");
    printf(""[INFO] My address  : "");
    output_octal(my_addr,6);
}

 
int addr_check(unsigned char des_addr[6]){
    int flag = 1;
    int i =0;
    for(i = 0;i<6;i++){
        if(des_addr[i] != my_addr[i]) flag = 0;
    }
    if(flag){
        printf(""[INFO] Address check success!\n"");
    }else {
        printf(""[Error] Address check error!\n"");
    }
    return flag;
}

 
int output_octal(unsigned char *x,unsigned int len) {
    int i;
    for (i =0;i<len;i++) {
        printf(""%02x"",x[i]);
        if (i != len-1) printf("" "");
        if(i %9 == 0 && i!=0) printf(""\n"");
    }
    printf(""\n"");
    return 0;
}

 
int receive_frame(){
    FILE *file = fopen(""pipe.bin"", ""r"");

    
    fread(&frame_len,sizeof(frame_len),1,file);
    printf(""[INFO] frame length: %d\n"",frame_len);
    if(frame_len < 64){  
        printf(""[Error] Payload length too low!\n"");
        exit(1);
    }else if(frame_len >1518){
        printf(""[Error] Payload length too long!\n"");
        exit(1);
    }

    
    fread(&frame,sizeof(char),frame_len,file);
    
    memcpy(&des_addr,&frame[0],6);
    memcpy(&sta_addr,&frame[6],6);
    memcpy(&protocol,&frame[12],sizeof(protocol));
    payload = &frame[14];    
    
    
    if(!addr_check(des_addr))   exit(1);

    
    init_crc_table();
    unsigned int crc32_temp = crc32(frame,frame_len-4);
    unsigned char crc32_result[4];
    memcpy(crc32_result,&crc32_temp,sizeof(crc32_temp));

    int i = 0;
    int flag_crc32 = 1;
    for(i = 3;i<sizeof(crc32_result);i--){
        if(crc32_result[i] != frame[frame_len-(4-i)]) flag_crc32 = 0;
    }
    if(flag_crc32){
        printf(""[INFO] CRC32 check success!\n"");
    }else {
        printf(""[Error] CRC32 check error!\n"");
        printf(""[Error] frame's CRC32 : "");
        printf(""%02x %02x %02x %02x\n"",frame[frame_len-4],frame[frame_len-3],frame[frame_len-2],frame[frame_len-1]);
        printf(""[Error] calculated CRC32 : "");
        output_octal(crc32_result,4);
        exit(1);
    }

    
    printf(""******Received frame information******\n"");
    printf(""Start address: "");
    output_octal(sta_addr,6);
    printf(""Des address  : "");
    output_octal(des_addr,6);
    printf(""protocol     : %d\n"",protocol);
    printf(""payload      : "");
    output_octal(payload,frame_len-6-6-2-4);
    printf(""CRC32        : "");
    output_octal(crc32_result,4);
    printf(""**************************************\n"");
    printf(""[INFO] Frame received success!\n"");
}

int main(){
    welcome();
    receive_frame();
}



",58,1701,1114
"# include ""crc32.h""

unsigned char frame[2000];  
unsigned char sta_addr[6];
unsigned char des_addr[6];
unsigned short protocol;
unsigned char *payload;
unsigned int frame_len;
unsigned int payload_len;
unsigned char my_addr[6] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};  


void welcome()
{
    printf(""[INFO] Usage: frame receiver process.\n"");
    printf(""[INFO] My address  : "");
    output_octal(my_addr,6);
}

 
int addr_check(unsigned char des_addr[6]){
    int flag = 1;
    int i =0;
    for(i = 0;i<6;i++){
        if(des_addr[i] != my_addr[i]) flag = 0;
    }
    if(flag){
        printf(""[INFO] Address check success!\n"");
    }else {
        printf(""[Error] Address check error!\n"");
    }
    return flag;
}

 
int output_octal(unsigned char *x,unsigned int len) {
    int i;
    for (i =0;i<len;i++) {
        printf(""%02x"",x[i]);
        if (i != len-1) printf("" "");
        if(i %9 == 0 && i!=0) printf(""\n"");
    }
    printf(""\n"");
    return 0;
}

 
int receive_frame(){
    FILE *file = fopen(""pipe.bin"", ""r"");

    
    fread(&frame_len,sizeof(frame_len),1,file);
    printf(""[INFO] frame length: %d\n"",frame_len);
    if(frame_len < 64){  
        printf(""[Error] Payload length too low!\n"");
        exit(1);
    }else if(frame_len >1518){
        printf(""[Error] Payload length too long!\n"");
        exit(1);
    }

    
    fread(&frame,sizeof(char),frame_len,file);
    
    memcpy(&des_addr,&frame[0],6);
    memcpy(&sta_addr,&frame[6],6);
    memcpy(&protocol,&frame[12],sizeof(protocol));
    payload = &frame[14];    
    
    
    if(!addr_check(des_addr))   exit(1);

    
    init_crc_table();
    unsigned int crc32_temp = crc32(frame,frame_len-4);
    unsigned char crc32_result[4];
    memcpy(crc32_result,&crc32_temp,sizeof(crc32_temp));

    int i = 0;
    int flag_crc32 = 1;
    for(i = 3;i<sizeof(crc32_result);i--){
        if(crc32_result[i] != frame[frame_len-(4-i)]) flag_crc32 = 0;
    }
    if(flag_crc32){
        printf(""[INFO] CRC32 check success!\n"");
    }else {
        printf(""[Error] CRC32 check error!\n"");
        printf(""[Error] frame's CRC32 : "");
        printf(""%02x %02x %02x %02x\n"",frame[frame_len-4],frame[frame_len-3],frame[frame_len-2],frame[frame_len-1]);
        printf(""[Error] calculated CRC32 : "");
        output_octal(crc32_result,4);
        exit(1);
    }

    
    printf(""******Received frame information******\n"");
    printf(""Start address: "");
    output_octal(sta_addr,6);
    printf(""Des address  : "");
    output_octal(des_addr,6);
    printf(""protocol     : %d\n"",protocol);
    printf(""payload      : "");
    output_octal(payload,frame_len-6-6-2-4);
    printf(""CRC32        : "");
    output_octal(crc32_result,4);
    printf(""**************************************\n"");
    printf(""[INFO] Frame received success!\n"");
}

int main(){
    welcome();
    receive_frame();
}



",58,1702,1114
"#include ""crc16.h""
#include ""output_octal.h""

int fragmention(){
    
}


unsigned int datagram_construction(unsigned char datagram[65535],unsigned char Version,
                            unsigned char Differentialted_Services,unsigned short Identification,
                            unsigned short DF, unsigned short MF,
                            unsigned short Fragment_offset, unsigned char TTL, 
                            unsigned char Protocol,
                            unsigned char *Source_address, unsigned char *Destination_address,
                            unsigned char *Option,unsigned int Option_len,
                            unsigned *payload,unsigned short payload_len){
    
    if (payload_len > 65515){
        printf(""[Error] Payload length too long!\n"");
        exit(1);
    }
    
    
    unsigned char IHL = 5 + Option_len; 
    printf(""IHL%d\n"",IHL);

    
    unsigned char temp = 0x00;
    Version = Version << 4;  
    temp = temp | IHL; 
    temp = temp | Version; 
    memcpy(&datagram[0],&temp,1);

    memcpy(&datagram[1],&Differentialted_Services,1);

    
    unsigned short Total_length = payload_len + IHL*4; 
    memcpy(&datagram[2],&Total_length,2);
    memcpy(&datagram[4],&Identification,2);

    
    unsigned short temp2;
    short df = DF;
    df = df << 14;
    df = df & 0x4000;  
    short mf = MF;
    mf = mf << 13;
    mf = mf & 0x2000; 
    Fragment_offset = Fragment_offset & 0x1FFF; 
    temp2 = df | mf | Fragment_offset;
    memcpy(&datagram[6],&temp2,2);

    memcpy(&datagram[8],&TTL,1);
    memcpy(&datagram[9],&Protocol,1);
    memcpy(&datagram[12],Source_address,4);
    memcpy(&datagram[16],Destination_address,4);
    memcpy(&datagram[20],Option,Option_len*4);
    
    
    unsigned char Header[IHL * 4 - 2]; 
    memcpy(&Header[0],&datagram[0],10);
    memcpy(&Header[10],&datagram[12],8 + Option_len * 4);
    unsigned short Header_checksum = CRC16(Header,IHL * 4 - 2);
    memcpy(&datagram[10],&Header_checksum,2); 
    
    unsigned char crc16_result[2];
    memcpy(crc16_result, &Header_checksum, sizeof(Header_checksum));

    memcpy(&datagram[20 + Option_len*4],payload,payload_len);

     
    printf(""******Send datagrame information******\n"");
    printf(""Source address: "");
    output_octal(Source_address,4);
    printf(""Destinamtion address  : "");
    output_octal(Destination_address,4);
    printf(""payload      : %s\n"",payload);
    printf(""CRC16        : "");
    output_octal(crc16_result, 2);    
    printf(""payload length  : %d\n"", payload_len);
    printf(""Header length   : %d(row*4bytes)\n"", IHL);
    printf(""datagram length : %d\n"", Total_length);
    printf(""**************************************\n"");
    printf(""[INFO] datagram send success!\n"");
    return Total_length;
}

int send_datagram(){

}

",58,1703,962
"#define BUFSIZE     1024*4

static unsigned int crc_table[256];
const static char * program_name = ""crc32"";

static void usage(void);
static void init_crc_table(void);
static unsigned int crc32(unsigned char * buffer, unsigned int size);
static int calc_img_crc(const char * in_file, unsigned int * img_crc);

static void usage(void)
{
    fprintf(stderr, ""Usage: %s input_file\n"", program_name);
}


static void init_crc_table(void)
{
    unsigned int c;
    unsigned int i, j;
    
    for (i = 0; i < 256; i++) {
        c = (unsigned int)i;
        for (j = 0; j < 8; j++) {
            if (c & 1)
                c = 0xedb88320L ^ (c >> 1);
            else
                c = c >> 1;
        }
        crc_table[i] = c;
    }
}



unsigned int crc32_table[256];
 
void make_crc32_table() {
    unsigned int c;
    int i = 0;
    int bit = 0;
    
    for(i = 0; i < 256; i++)
    {
        c  = (unsigned int)i;
        
        for(bit = 0; bit < 8; bit++)
        {
            if(c&1)
            {
                c = (c >> 1)^(0xEDB88320);
            }
            else
            {
                c =  c >> 1;
            }
            
        }
        crc32_table[i] = c;
    }
}
 
unsigned int crc32lql(unsigned char *string, unsigned int size) {
    make_crc32_table();
    unsigned int crc = 0xffffffff;
    while(size--)
        crc = (crc >> 8)^(crc32_table[(crc ^ *string++)&0xff]);
    return crc;
}


static unsigned int crc32(unsigned char *buffer, unsigned int size)
{
    unsigned int crc = 0xFFFFFFFF;
    unsigned int i;
    for (i = 0; i < size; i++) {
        crc = crc_table[(crc ^ buffer[i]) & 0xff] ^ (crc >> 8);
    }
    return crc ;
}

unsigned int crc32cyy(unsigned char *data,int len) {
    unsigned int crc = 0xFFFFFFFF;
    int i;
    for (i=0;i<len;i++) {
        crc = crc ^ data[i];
        int j;
        for (j=7;j>=0;j--) {
            crc = (crc >> 1) ^ (0xEDB88320 & (-(crc & 1)));
        }
    }
    return ~crc;
}











































unsigned char data[] = {0x64,0x62,0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,
                        0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,
                        0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,
                        0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,
                        0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,
                        0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,
                        0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,
                        0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,
                        0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,
                        0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,
                        0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,
                        0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,
                        0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,
                        0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,
                        0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,
                        0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,
                        0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,0x11,0x33,
                        0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,
                        0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,
                        0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,
                        0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,
                        0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,
                        0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,
                        0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,
                        0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,
                        0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,
                        0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,
                        0xd1,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3};
unsigned char sta_addr[] = {0x11,0x33,0x55,0x44,0x22,0x55};
unsigned char des_addr[] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};


int main(int argc, char **argv)
{
    
    
    

    
    
    
    

    
    
    
    
    
    

    

    
    
    
    
    
    
    
    

    printf(""%d"",sizeof(data)); 

    return 0;
}

",58,1704,2458
"#define BUFSIZE     1024*4

static unsigned int crc_table[256];
const static char * program_name = ""crc32"";

static void usage(void);
static void init_crc_table(void);
static unsigned int crc32(unsigned char * buffer, unsigned int size);
static int calc_img_crc(const char * in_file, unsigned int * img_crc);

static void usage(void)
{
    fprintf(stderr, ""Usage: %s input_file\n"", program_name);
}


static void init_crc_table(void)
{
    unsigned int c;
    unsigned int i, j;
    
    for (i = 0; i < 256; i++) {
        c = (unsigned int)i;
        for (j = 0; j < 8; j++) {
            if (c & 1)
                c = 0xedb88320L ^ (c >> 1);
            else
                c = c >> 1;
        }
        crc_table[i] = c;
    }
}



unsigned int crc32_table[256];
 
void make_crc32_table() {
    unsigned int c;
    int i = 0;
    int bit = 0;
    
    for(i = 0; i < 256; i++)
    {
        c  = (unsigned int)i;
        
        for(bit = 0; bit < 8; bit++)
        {
            if(c&1)
            {
                c = (c >> 1)^(0xEDB88320);
            }
            else
            {
                c =  c >> 1;
            }
            
        }
        crc32_table[i] = c;
    }
}
 
unsigned int crc32lql(unsigned char *string, unsigned int size) {
    make_crc32_table();
    unsigned int crc = 0xffffffff;
    while(size--)
        crc = (crc >> 8)^(crc32_table[(crc ^ *string++)&0xff]);
    return crc;
}


static unsigned int crc32(unsigned char *buffer, unsigned int size)
{
    unsigned int crc = 0xFFFFFFFF;
    unsigned int i;
    for (i = 0; i < size; i++) {
        crc = crc_table[(crc ^ buffer[i]) & 0xff] ^ (crc >> 8);
    }
    return crc ;
}

unsigned int crc32cyy(unsigned char *data,int len) {
    unsigned int crc = 0xFFFFFFFF;
    int i;
    for (i=0;i<len;i++) {
        crc = crc ^ data[i];
        int j;
        for (j=7;j>=0;j--) {
            crc = (crc >> 1) ^ (0xEDB88320 & (-(crc & 1)));
        }
    }
    return ~crc;
}











































unsigned char data[] = {0x64,0x62,0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,
                        0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,
                        0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,
                        0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,
                        0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,
                        0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,
                        0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,
                        0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,
                        0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,
                        0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,
                        0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,
                        0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,
                        0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,
                        0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,
                        0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,
                        0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,
                        0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,0x11,0x33,
                        0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,
                        0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,
                        0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,
                        0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,
                        0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,
                        0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,
                        0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,
                        0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,
                        0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,
                        0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,
                        0xd1,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3};
unsigned char sta_addr[] = {0x11,0x33,0x55,0x44,0x22,0x55};
unsigned char des_addr[] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};


int main(int argc, char **argv)
{
    
    
    

    
    
    
    

    
    
    
    
    
    

    

    
    
    
    
    
    
    
    

    printf(""%d"",sizeof(data)); 

    return 0;
}

",58,1705,2458
"#include ""sender.h""

unsigned char frame[1546]; 
unsigned char data[] = ""Hello! This is a frame payload data. It's a computer project for quxiangjun 20186471. ""; 
unsigned char sta_addr[6] = {0x11, 0x33, 0x55, 0x44, 0x22, 0x55}; 
unsigned char des_addr[6] = {0x42, 0x23, 0x52, 0xb5, 0xa6, 0xc3}; 
unsigned short protocol = 1;


void welcome(){
    printf(""[INFO] Usage: frame sender process.\n"");
}

int main(){
    unsigned int length;

    welcome();




    
     
    length = frame_construction(frame,sta_addr,des_addr,protocol,data,sizeof(data));
    frame[length-10] = ~frame[length-10];    
    send_frame(frame,length);

    return 0;
}
",58,1706,273
"#include ""crc16.h""
#include ""output_octal.h""

int fragmention(){
    
}


unsigned int datagram_construction(unsigned char datagram[65535],unsigned char Version,
                            unsigned char Differentialted_Services,unsigned short Identification,
                            unsigned short DF, unsigned short MF,
                            unsigned short Fragment_offset, unsigned char TTL, 
                            unsigned char Protocol,
                            unsigned char *Source_address, unsigned char *Destination_address,
                            unsigned char *Option,unsigned int Option_len,
                            unsigned *payload,unsigned short payload_len){
    
    if (payload_len > 65515){
        printf(""[Error] Payload length too long!\n"");
        exit(1);
    }
    
    
    unsigned char IHL = 5 + Option_len; 
    printf(""IHL%d\n"",IHL);

    
    unsigned char temp = 0x00;
    Version = Version << 4;  
    temp = temp | IHL; 
    temp = temp | Version; 
    memcpy(&datagram[0],&temp,1);

    memcpy(&datagram[1],&Differentialted_Services,1);

    
    unsigned short Total_length = payload_len + IHL*4; 
    memcpy(&datagram[2],&Total_length,2);
    memcpy(&datagram[4],&Identification,2);

    
    unsigned short temp2;
    short df = DF;
    df = df << 14;
    df = df & 0x4000;  
    short mf = MF;
    mf = mf << 13;
    mf = mf & 0x2000; 
    Fragment_offset = Fragment_offset & 0x1FFF; 
    temp2 = df | mf | Fragment_offset;
    memcpy(&datagram[6],&temp2,2);

    memcpy(&datagram[8],&TTL,1);
    memcpy(&datagram[9],&Protocol,1);
    memcpy(&datagram[12],Source_address,4);
    memcpy(&datagram[16],Destination_address,4);
    memcpy(&datagram[20],Option,Option_len*4);
    
    
    unsigned char Header[IHL * 4 - 2]; 
    memcpy(&Header[0],&datagram[0],10);
    memcpy(&Header[10],&datagram[12],8 + Option_len * 4);
    unsigned short Header_checksum = CRC16(Header,IHL * 4 - 2);
    memcpy(&datagram[10],&Header_checksum,2); 
    
    unsigned char crc16_result[2];
    memcpy(crc16_result, &Header_checksum, sizeof(Header_checksum));

    memcpy(&datagram[20 + Option_len*4],payload,payload_len);

     
    printf(""******Send datagrame information******\n"");
    printf(""Source address: "");
    output_octal(Source_address,4);
    printf(""Destinamtion address  : "");
    output_octal(Destination_address,4);
    printf(""payload      : %s\n"",payload);
    printf(""CRC16        : "");
    output_octal(crc16_result, 2);    
    printf(""payload length  : %d\n"", payload_len);
    printf(""Header length   : %d(row*4bytes)\n"", IHL);
    printf(""datagram length : %d\n"", Total_length);
    printf(""**************************************\n"");
    printf(""[INFO] datagram send success!\n"");
    return Total_length;
}

int send_datagram(){

}

",58,1707,962
"#define STDIN 1
void main(int argc,char* argv[])
{
    
    int rval,sockid;
    
    sockid=socket(AF_INET,SOCK_STREAM,6);   
    if(sockid==-1)
    {
        perror(""SOCK-CRE-ERR:"");
        exit(1);
    }
    struct sockaddr_in s,c;
    
    system(""clear"");
    if(argc<2)
    {
        printf(""\nUSAGE : %s IP_ADDR PORT#\n"",argv[0]);
        exit(1);
    }
    s.sin_family=AF_INET;
    s.sin_port=htons(atoi(argv[2]));
    s.sin_addr.s_addr=inet_addr(argv[1]);
    
    rval=bind(sockid,(struct sockaddr*)&s,sizeof(s)); 
    if(rval==-1)  
    {   
        perror(""BIND-ERR:"");   
        close(sockid);   
        exit(1);  
    }   
    rval=listen(sockid,5);
    if(rval==-1)  
    {   
        perror(""LISTEN-ERR:"");   
        close(sockid);   
        exit(1);  
    }  
    fd_set rdfs,copy;
    FD_ZERO(&rdfs);
    FD_SET(STDIN,&rdfs);
    FD_SET(sockid,&rdfs);
    int maxfd=STDIN>=sockid?STDIN:sockid;
    maxfd=maxfd+1;
    char msg[100];
    struct timeval tm;
    int ret;


    while(1)
    {
        copy=rdfs;
        tm.tv_sec=5;
        tm.tv_usec=5000000;
        ret=select(maxfd,&copy,NULL,NULL,&tm);
        if(ret==-1)
        perror(""SEL-ERR"");
        if(ret==0)
        printf(""Timeout occured"");
        else
        {
            if(FD_ISSET(STDIN,&copy))
            {
                scanf(""%s"",msg);
                printf(""Message is:%s\n"",msg);
            }
            if(FD_ISSET(sockid,&copy))
            {
                int clen=sizeof(c);  
                int sid1=accept(sockid,(struct sockaddr*)&c,&clen); 
                if(sid1==-1)
                {
                    perror(""ACC-ERR"");
                    exit(0);
                }
                FD_SET(sid1,&rdfs);
                maxfd=maxfd>=sid1?maxfd:sid1;
                maxfd=maxfd+1;
                int k=recv(sid1,msg,sizeof(msg),0);
                msg[k]='\0';
                printf(""Message from client is:%s\n"",msg);
                close(sid1);
                FD_CLR(sid1,&rdfs);
            }
        }
     
    }
    close(sockid);          
}



",59,1708,817
"void main(int argc,char* argv[])
{
    int sockid,rval,clen;
    char buffer[20];
    struct sockaddr_in s,c;
    if(argc<3)
    {
        printf(""\nUSAGE : %s IP_ADDRESS PORT#\n"",argv[0]);
        exit(0);
    }
    sockid=socket(PF_INET,SOCK_DGRAM,17);
    if(sockid==-1)
    {
        perror(""SOCK-CRE-ERR:"");
        exit(1);
    }
    s.sin_family=PF_INET;
    s.sin_port=htons(atoi(argv[2]));
    s.sin_addr.s_addr=inet_addr(argv[1]);
    rval=bind(sockid,(struct sockaddr*)&s,sizeof(s));
    if(rval==-1)
    {
        perror(""BIND-ERR"");
        close(sockid);
        exit(1);
    }
    clen=sizeof(c);
    rval=recvfrom(sockid,buffer,sizeof(buffer),0,(struct sockaddr*)&c,&clen);
    if(rval==-1)
    {
        perror(""MSG-RCV-ERR:"");
    }
    else
    {
        printf(""\nRequest received\nRequest message is : %s\n"",buffer);
    }
    rval=sendto(sockid,buffer,sizeof(buffer),0,(struct sockaddr*)&c,sizeof(c));
    if(rval==-1)
    {
        perror(""MSG-SND-ERR:"");
    }
    else
    {
        printf(""\nResponse sent successfully\n"");
    }
    close(sockid);
}
",59,1709,454
"void main(int argc,char* argv[])
{
    struct sockaddr_in dnss;
    int sockid,rval;
    char sym[20],IP[20];
    int slen;
    system(""clear"");
    if(argc<3)
    {
        printf(""\nUSAGE : %s IP_ADDR PORT#\n"",argv[0]);
        exit(1);
    }
    sockid=socket(AF_INET,SOCK_DGRAM,0);
    if(sockid==-1)
    {
        perror(""SOCK-CRE-ERR:"");
        exit(1);
    }
    dnss.sin_family=AF_INET;
    dnss.sin_port=htons(atoi(argv[2]));
    dnss.sin_addr.s_addr=inet_addr(argv[1]);
    printf(""\nEnter the symbolic name of resource : "");
    scanf(""%s"",sym);
    rval=sendto(sockid,sym,sizeof(sym),0,(struct sockaddr*)&dnss,sizeof(dnss));
    if(rval==-1)
    {
        perror(""MSG-SND-ERR:"");
        close(sockid);
        exit(1);
    }
    printf(""\nWaiting to receive from DNS Server\n"");
    slen=sizeof(dnss);
    strncpy(IP,"" "",20);
    rval=recvfrom(sockid,IP,sizeof(IP),0,(struct sockaddr*)&dnss,&slen);
    if(rval==-1)
    {
        perror(""MSG-RCV-ERR:"");
        close(sockid);
        exit(1);
    }
    printf(""\nEquivalent IP adrress of %s is %s\n"",sym,IP);
    close(sockid);
}
",59,1710,467
"typedef struct msg
{
    long id;
    char txt[10];
}message;
void main()
{
    int mqid,pid,rval,msgid;
    system(""clear"");
    printf(""\nBasic operations on message queues\n"");
    printf(""\nPP : process id is %d\n"",getpid());
    mqid=msgget((key_t)80,IPC_CREAT|0666);
    if(mqid==-1)
    {
        perror(""PP : MQ-CRE-ERR"");
        exit(1);
    }
    system(""ipcs -q"");
    pid=fork();
    if(pid==-1)
    {
        perror(""PP : FRK-ERR"");
        msgctl(mqid,IPC_RMID,0);
        system(""ipcs -q"");
        exit(1);
    }   
    if(pid==0)
    {
        message m1;
        printf(""\nCP : In child process\tpid=%d\n"",getpid());
        printf(""\nCP : Parent process id\tppid=%d\n"",getppid());
        printf(""\nEnter the message : "");
        scanf(""%s"",m1.txt);
        rval=msgsnd(mqid,(message*)&m1,sizeof(m1),0);
        if(rval==-1)
        perror(""\nCP : Unable to send message\n"");
        else
        printf(""\nCP : message successfully sent\n"");
    }
    else
    {
        message m2;
        rval=msgrcv(mqid,(message*)&m2,sizeof(m2),msgid,0);
        if(rval==-1)
        perror(""\nPP : No message read\n"");
        else
        printf(""\n PP : Client message read from queue is %s\n"",m2.txt);
        rval=msgctl(mqid,IPC_RMID,0);
        system(""ipcs -q"");
    }
}
",59,1711,498
"void main(int argc,char*argv[])
{
    int sid,sid1,rval,itr,i;
    struct sockaddr_in s,c;
    char buffer[20];
    int clen; 
    system(""clear"");
    if(argc<3)
    {
        printf(""\nUSAGE : %s IP_ADDRESS PORT#\n"",argv[0]);
        exit(0);
    }
    printf(""\nEnter the number of clients to serve/ server iterations : "");
    scanf(""%d"",&itr);
    sid=socket(AF_INET,SOCK_STREAM,6);
    if(sid==-1)
    {
        perror(""SOCK-CRE-ERR:"");
        exit(1);
    }

    s.sin_family=AF_INET;
    s.sin_port=htons(atoi(argv[2]));
    s.sin_addr.s_addr=inet_addr(argv[1]);

    rval=bind(sid,(struct sockaddr*)&s,sizeof(s));
    if(rval==-1)
    {
        perror(""BIND-ERR:"");
        close(sid);
        exit(1);
    }
    rval=listen(sid,5);
    if(rval==-1)
    {
        perror(""LISTEN-ERR:"");
        close(sid);
        exit(1);
    }
    for(i=1;i<=itr;i++)
    {
        clen=sizeof(c);
        sid1=accept(sid,(struct sockaddr*)&c,&clen);
        rval=recv(sid1,buffer,sizeof(buffer),0);
        if(rval==-1)
        {
            perror(""MSG-RCV-ERR:"");
        }
        else
        {
            printf(""\nClient request is %s\n"",buffer);
        }
        rval=send(sid1,buffer,sizeof(buffer),0);
        if(rval==-1)
        {
            perror(""MSG-SND-ERR:"");
        }
        else    
        {
            printf(""\nResponse sent\n"");
        }
        close(sid1);
    }
    close(sid);
}
",59,1712,572
"void main(int argc,char*argv[])
{
    int sid,sid1,rval;
    struct sockaddr_in s,c;
    char buffer[20];
    int clen; 
    system(""clear"");
    if(argc<3)
    {
        printf(""\nUSAGE : %s IP_ADDRESS PORT#\n"",argv[0]);
        exit(0);
    }
    sid=socket(AF_INET,SOCK_STREAM,6);
    if(sid==-1)
    {
        perror(""SOCK-CRE-ERR:"");
        exit(1);
    }
    s.sin_family=AF_INET;
    s.sin_port=htons(atoi(argv[2]));
    s.sin_addr.s_addr=inet_addr(argv[1]);
    rval=bind(sid,(struct sockaddr*)&s,sizeof(s));
    if(rval==-1)    
    {
        perror(""BIND-ERR:"");
        close(sid);
        exit(1);
    }
    rval=listen(sid,5);
    if(rval==-1)
    {
        perror(""LISTEN-ERR:"");
        close(sid);
        exit(1);
    }
    clen=sizeof(c);
    sid1=accept(sid,(struct sockaddr*)&c,&clen);
    rval=recv(sid1,buffer,sizeof(buffer),0);
    if(rval==-1)
    {
        perror(""MSG-RCV-ERR:"");
    }
    else
    {
        printf(""\nClient request is %s\n"",buffer);
    }
    rval=send(sid1,buffer,sizeof(buffer),0);
    if(rval==-1)
    {
        perror(""MSG-SND-ERR:"");
    }
    else
    {
        printf(""\nResponse sent\n"");
    }
    close(sid);
    close(sid1);
}
",59,1713,516
"typedef struct msg
{
    long id;
    char txt[10];
}message;
void main()
{
    int mqid,rval,msgid;
    message m1;
    mqid=msgget((key_t)80,IPC_CREAT|0666);
    if(mqid==-1)
    {
        perror(""MQ-CRE-ERR"");
        exit(1);
    }
    system(""ipcs -q"");
    printf(""Enter the msgid : "");
    scanf(""%d"",&msgid);
    m1.id=msgid;
    printf(""Enter the message : "");
    scanf(""%s"",m1.txt);
    rval=msgsnd(mqid,(message*)&m1,sizeof(m1),0);
    if(rval==-1)
    perror(""\nMessage not sent\n"");
    else
    printf(""\nMessage Sent successfully\n"");
}
",59,1714,232
"void main(int argc,char*argv[])
{
    int sid,sid1,rval;
    struct sockaddr_in s,c;
    struct iovec iov[2];
    char b1[50],b2[50]; 
    int clen; 
    system(""clear"");
    if(argc<3)
    {
        printf(""\nUSAGE : %s IP_ADDRESS PORT#\n"",argv[0]);
        exit(0);
    }
    sid=socket(AF_INET,SOCK_STREAM,6);
    if(sid==-1)
    {
        perror(""SOCK-CRE-ERR:"");
        exit(1);
    }
    s.sin_family=AF_INET;
    s.sin_port=htons(atoi(argv[2]));
    s.sin_addr.s_addr=inet_addr(argv[1]);
    rval=bind(sid,(struct sockaddr*)&s,sizeof(s));
    if(rval==-1)    
    {
        perror(""BIND-ERR:"");
        close(sid);
        exit(1);
    }
    rval=listen(sid,5);
    if(rval==-1)
    {
        perror(""LISTEN-ERR:"");
        close(sid);
        exit(1);
    }
    clen=sizeof(c);
    sid1=accept(sid,(struct sockaddr*)&c,&clen);
    if(sid1<0)
    {
        printf(""Connection Failed"");
    }
    iov[0].iov_base=b1;  
    iov[0].iov_len=50;  
    iov[1].iov_base=b2; 
    iov[1].iov_len=50;  
    readv(sid1,&iov[0],2);  
    printf(""Client Message is %s \n %s\n"",b1,b2);  
    writev(sid1,&iov[0],2); 
    printf(""Response Sent\n"");
    close(sid);
    close(sid1);
}
",59,1715,548
"void main(int argc,char* argv[])
{
    struct sockaddr_in s,c; 
    int rval,sockid,slen;
    char m1[20],m2[20];
    system(""clear"");
    if(argc<3)
    {
        printf(""\nUSAGE : %s IP-Address Port#\n"",argv[0]);
        exit(1);
    }
    sockid=socket(PF_INET,SOCK_DGRAM,17);
    if(sockid==-1)
    {
        perror(""SOCK-CRE-ERR:"");
        exit(1);
    }
    s.sin_family=PF_INET;
    s.sin_port=htons(atoi(argv[2]));
    s.sin_addr.s_addr=inet_addr(argv[1]);
    c.sin_port=htons(5080);
    printf(""\nEnter the request message : "");
    scanf(""%s"",m1);
    slen=sizeof(s);
    rval=sendto(sockid,m1,sizeof(m1),0,(struct sockaddr*)&s,slen);
    if(rval==-1)
    {
        perror(""MSG-SEND-ERR:"");
        exit(1);
    }
    printf(""\nMessage sent successfully\n"");
    strncpy(m2,"" "",20);
    rval=recvfrom(sockid,m2,sizeof(m2),0,(struct sockaddr*)&s,&slen);
    if(rval==-1)
    {
        perror(""MSG-RCV-ERR:"");
        exit(1);
    }
    printf(""\nServer Response is : %s\n"",m2);
    close(sockid);
}
",59,1716,448
"void main(int argc,char* argv[])
{
    int sockid,rval,clen;
    char buffer[20],smsg[30];
    time_t t;
    struct sockaddr_in s,c;
    if(argc<3)
    {
        printf(""\nUSAGE : %s IP_ADDRESS PORT#\n"",argv[0]);
        exit(0);
    }
    sockid=socket(PF_INET,SOCK_DGRAM,17);
    if(sockid==-1)
    {
        perror(""SOCK-CRE-ERR:"");
        exit(1);
    }
    s.sin_family=PF_INET;
    s.sin_port=htons(atoi(argv[2]));
    s.sin_addr.s_addr=inet_addr(argv[1]);
    rval=bind(sockid,(struct sockaddr*)&s,sizeof(s));
    if(rval==-1)
    {
        perror(""BIND-ERR"");
        close(sockid);
        exit(1);
    }
    clen=sizeof(c);
    rval=recvfrom(sockid,buffer,sizeof(buffer),0,(struct sockaddr*)&c,&clen);
    if(rval==-1)
    {
        perror(""MSG-RCV-ERR:"");
    }   
    else
    {
        printf(""\nClient Request is : %s\n"",buffer);
    }
    t=time(0);
    strcpy(smsg,ctime(&t));
    rval=sendto(sockid,smsg,sizeof(smsg),0,(struct sockaddr*)&c,sizeof(c));
    if(rval==-1)
    {
        perror(""MSG-SND-ERR:"");
    }
    else
    {
        printf(""\nResponse sent successfully\n"");
    }
    close(sockid);
}
",59,1717,487
"int main() 
{ 
int sockfd; 
struct sockaddr_in serv_addr; 
time_t  now; 
char timestr[100]; 
char a[50],a1[50]; 
sockfd=socket(AF_INET,SOCK_STREAM,0); 
if(sockfd<0) 
{ 
printf(""\n Socket Failed""); 
exit(0); 
} 
serv_addr.sin_family=AF_INET; 
serv_addr.sin_addr.s_addr=inet_addr(""192.168.125.129""); 
serv_addr.sin_port=htons(13); 
if(connect(sockfd,(struct sockaddr *)&serv_addr,sizeof(serv_addr))<0) 
{ 
printf(""\n Connection Failed""); 
exit(0); 
} 
time(&now); 
sprintf(timestr,""%s"",ctime(&now)); 
printf(""%s"",timestr); 
 
 
 

 
close(sockfd); 
} 
",59,1718,272
"void main(int argc,char* argv[])
{
    int rval,sockid,itr,i;
    char msg[100];
    struct sockaddr_in lis;
    system(""clear"");
    if(argc<3)
    {
        printf(""\nUSAGE : %s IP_ADDR PORT#\n"",argv[0]);
        exit(1);
    }
    lis.sin_family=AF_INET;
    lis.sin_port=htons(atoi(argv[2]));
    lis.sin_addr.s_addr=inet_addr(argv[1]);
    sockid=socket(AF_INET,SOCK_DGRAM,0);
    if(sockid==-1)
    {
        perror(""SOCK-CRE-ERR:"");
        exit(1);
    }
    printf(""\nEnter the number of messages to be sent: "");
    scanf(""%d"",&itr);
    for(i=1;i<=itr;i++)
    {
        strncpy(msg,"" "",100);
        printf(""Enter the message %d : "",i);
        scanf(""%s"",msg);
        rval=sendto(sockid,msg,sizeof(msg),0,(struct sockaddr*)&lis,sizeof(lis));
        if(rval<=0)
        {
            perror(""MSG-SND-ERR:"");
            close(sockid);
            exit(1);
        }
        printf(""\nMessage sent successfully\n"");
        if(strcmp(msg,""EXIT"")==0)
        {
            close(sockid);
            exit(1);
        }
    }
    close(sockid);
}
",59,1719,421
"void main(int argc,char* argv[])
{
    int sockid,rval;
    char a1[50],a2[50],b1[50],b2[50];
    sockid=socket(AF_INET,SOCK_STREAM,0);
    if(sockid==-1)
    {
        perror(""SOCK-CRE-ERR"");
        exit(1);
    }
    struct sockaddr_in s;
    struct iovec iov[2]; 
    system(""clear"");
    if(argc<3)
    {
        printf(""\nUSAGE : %s IP_ADDR PORT#\n"",argv[0]);
        exit(0);
    }
    s.sin_family=AF_INET;
    s.sin_port=htons(atoi(argv[2]));
    s.sin_addr.s_addr=inet_addr(argv[1]);
    rval=connect(sockid,(struct sockaddr*)&s, sizeof(s));
    if(rval==-1)
    {
        perror(""CONN-ERR:"");
        close(sockid);
        exit(1);
    }
    printf(""\nEnter the first message : "");
    scanf(""%s"",a1);
    printf(""\nEnter the second message : "");
    scanf(""%s"",a2);
    iov[0].iov_base=a1;  
    iov[0].iov_len=50;  
    iov[1].iov_base=a2;  
    iov[1].iov_len=50;  
    writev(sockid,&iov[0],2); 
    printf(""Message sent successfully\n"");
    iov[0].iov_base=b1;  
    iov[0].iov_len=50;  
    iov[1].iov_base=b2;  
    iov[1].iov_len=50;  
    readv(sockid,&iov[0],2);  
    printf(""Server response is :  %s \n %s\n"",b1,b2); 

    close(sockid);
}
",59,1720,544
"typedef struct msg
{
    long id;
    char txt[10];
}message;
void main()
{
    int mqid,rval,msgid;
    message m2;
    mqid=msgget((key_t)80,IPC_CREAT|0666);
    if(mqid==-1)
    {
        perror(""MQ-CRE-ERR"");
        exit(1);
    }
    system(""ipcs -q"");
    printf(""\nEnter the msgid :"");
    scanf(""%d"",&msgid);
    rval=msgrcv(mqid,(message*)&m2,sizeof(m2),msgid,0);
    if(rval==-1)
    {
        perror(""No message read"");
        msgctl(mqid,IPC_RMID,0);
        system(""ipcs -q"");
        exit(1);
    }
    printf(""\nMessage entered : %s\n"",m2.txt);
    msgctl(mqid,IPC_RMID,0);
    system(""ipcs -q"");
}
",59,1721,270
"void main(int argc,char* argv[])
{
    struct sockaddr_in dnss,dnsc;
    int rval,sockid,flag=0,clen;
    char sym[20],IP[20],dnsFile[20],dnsName[20];
    FILE *fptr;
    system(""clear"");
    if(argc<3)
    {
        printf(""\nUSAGE : %s IP_ADDR PORT#\n"",argv[0]);
        exit(1);
    }
    dnss.sin_family=AF_INET;
    dnss.sin_port=htons(atoi(argv[2]));
    dnss.sin_addr.s_addr=inet_addr(argv[1]);
    sockid=socket(AF_INET,SOCK_DGRAM,0);
    if(sockid==-1)
    {
        perror(""SOCK-CRE-ERR:"");
        exit(1);
    }
    rval=bind(sockid,(struct sockaddr*)&dnss,sizeof(dnss));
    if(rval==-1)
    {
        perror(""BIND-ERR:"");
        close(sockid);
        exit(1);
    }
    printf(""\nDNS Server waiting for request\n"");
    printf(""\nEnter the DNS file name : "");
    scanf(""%s"",dnsFile);
    
    fptr=fopen(dnsFile,""r"");
    if(fptr==NULL)
    {
        perror(""FILE-OPEN-ERR:"");
        close(sockid);
        exit(1);
    }
    clen=sizeof(dnsc);
    rval=recvfrom(sockid,sym,sizeof(sym),0,(struct sockaddr*)&dnsc,&clen);
    if(rval==-1)
    {
        perror(""MSG-RCV-ERR:"");
        close(sockid);
        fclose(fptr);
        exit(1);
    }
    printf(""\nIP requested for %s\n"",sym);
    while((fscanf(fptr,""%s%s"",dnsName,IP) != EOF) )
    {
        if(strcmp(dnsName,sym)==0)
        {
            rval=sendto(sockid,IP,sizeof(IP),0,(struct
            sockaddr*)&dnsc,clen);
            if(rval==-1)
            {
                perror(""MSG-SND-ERR:"");
                fclose(fptr);
                close(sockid);
                exit(1);
            }
            flag=1;
        }
        printf(""\n flag value in loop is %d\n"",flag);
        if(flag==1) 
        break;
    }
    if(flag==0)
    {
        printf(""\n invalid domain name case\n"");
        rval=sendto(sockid,""NOT FOUND"",sizeof(""NOT FOUND""),0,(struct
        sockaddr*)&dnsc,clen);
        if(rval==-1)
        {
            perror(""MSG-SND-ERR:"");
            fclose(fptr);
            close(sockid);
            exit(1);
        }
    }
    fclose(fptr);
    close(sockid);
}
",59,1722,819
"void main(int argc,char* argv[])
{
    int shmid,rval,sval,csval;
    sem_t *sem_phore;
    system(""clear"");
    if(argc<3)
    {
        printf(""\nUSAGE : %s labelForSHM ByteSize\n"",argv[0]);
        exit(0);
    }
    shmid=shmget((key_t)atoi(argv[1]),atoi(argv[2]),IPC_CREAT|0666);
    if(shmid==-1)
    {
        perror(""SHM-CRE-ERR:"");
        exit(1);
    }
    sem_phore=(sem_t*)shmat(shmid,0,0);
    if(!sem_phore)
    {
        perror(""SHM-ATT-ERR:"");
        shmctl(shmid,IPC_RMID,0);
        exit(1);
    }
    printf(""\nEnter the initial value for the semaphore: "");
    scanf(""%d"",&sval);
    rval=sem_init(sem_phore,1,sval);
    if(rval==-1)
    {
        perror(""Unable to initialize semaphore:"");
        shmdt(sem_phore);
        shmctl(shmid,IPC_RMID,0);
        exit(1);
    }
    rval=sem_getvalue(sem_phore,&csval);
    if(rval==-1)
    {
        perror(""Unable to get value of the semaphore: "");
        shmdt(sem_phore);
        shmctl(shmid,IPC_RMID,0);
        exit(1);
    }
    printf(""\nInitialized value of semaphore is %d\n"",csval);
    rval=sem_wait(sem_phore);
    if(rval==-1)
    {
        perror(""WAIT-FAILURE:"");
        shmdt(sem_phore);
        shmctl(shmid,IPC_RMID,0);
        exit(1);
    }
    rval=sem_getvalue(sem_phore,&csval);
    if(rval==-1)
    {
        perror(""Unable to get semaphore value:"");
        shmdt(sem_phore);
        shmctl(shmid,IPC_RMID,0);
        exit(1);
    }
    printf(""\nSemaphore value after wait is %d\n"",csval);
    rval=sem_post(sem_phore);
    if(rval==-1)
    {
        perror(""Unable to get semaphore value:"");
        shmdt(sem_phore);
        shmctl(shmid,IPC_RMID,0);
        exit(1);
    }
    rval=sem_getvalue(sem_phore,&csval);
    if(rval==-1)
    {
        perror(""Unable to get semaphore value: "");
        shmdt(sem_phore);
        shmctl(shmid,IPC_RMID,0);
        exit(1);
    }
    printf(""\nSemaphore value after signal operation is %d\n"",csval);
    rval=sem_destroy(sem_phore);
    if(rval==-1)
    {
        perror(""SEM-DESTROY-ERR:"");
        shmdt(sem_phore);
        shmctl(shmid,IPC_RMID,0);
        exit(1);
    }
    rval=shmdt(sem_phore);
    if(rval==-1)
    {
        perror(""SHM-DETACH-ERR:"");
        shmdt(sem_phore);
        shmctl(shmid,IPC_RMID,0);
        exit(1);
    }
    rval=shmctl(shmid,IPC_RMID,0);
    if(rval==-1)
    {
        perror(""SHM-REM-ERR:"");
        shmdt(sem_phore);
        shmctl(shmid,IPC_RMID,0);
        exit(1);
    }
    system(""ipcs -m"");
}
",59,1723,1084
"void main() 
{
    fd_set readfd;
        char ch;
    FD_ZERO(&readfd);
    FD_SET(0,&readfd);
    struct timeval tm;
    tm.tv_sec=5;
    tm.tv_usec=3000000;
    
    int ret=select(1,&readfd,NULL,NULL,&tm);
    if(ret==-1)
    {
        printf(""SEL-ERR"");
        exit(0);
    }
    else if(ret==0)
    {
    printf(""Timeout Occured"");
    }
    else
    {   
        if(FD_ISSET(0,&readfd))
        {
            scanf(""%c"",&ch);
            printf(""The character is %c\n"",ch);
    
        }
    }   
}
",59,1724,215
"void main(int argc,char* argv[])
{
    fd_set rdfs;
    int rval,sockid;
    char buf1[3],buf2[30];
    sockid=socket(AF_INET,SOCK_STREAM,6);   
    if(sockid==-1)
    {
        perror(""SOCK-CRE-ERR:"");
        exit(1);
    }
    struct sockaddr_in s;
    struct timeval tv;
    system(""clear"");
    if(argc<2)
    {
        printf(""\nUSAGE : %s IP_ADDR PORT#\n"",argv[0]);
        exit(1);
    }
    s.sin_family=AF_INET;
    s.sin_port=htons(atoi(argv[2]));
    s.sin_addr.s_addr=inet_addr(argv[1]);
    
    
    rval=connect(sockid,(struct sockaddr *)&s,sizeof(s));
    if(rval==-1)    
    {
        perror(""CONNECT_ERR"");
        close(sockid);
        exit(1);
    }
    printf(""\n Enter the data to send:\t"");
    scanf(""%s"",buf1);
    send(sockid,(char *) buf1,sizeof(buf1),0);
    do
    {
        FD_ZERO(&rdfs);
        FD_SET(sockid,&rdfs);
        rval=select(sockid+1,&rdfs,NULL,NULL,NULL);
        printf(""\nrval of select = %d\n"",rval);
    }while(rval==-1);
    if(rval>0)
    {
        if(FD_ISSET(sockid,&rdfs))
        {
            rval=recv(sockid,(char *)buf2,sizeof(buf2),0);
            if(rval==0)
            printf(""\nNo response from server\n"");
            else
            printf(""\nServer Response is %s\n"",buf2);
        }
    }
    else
    perror(""SELECT_ERR"");
    close(sockid);
}
",59,1725,537
"void main(int argc,char*argv[])
{
    int sid,sid1,rval;
    time_t t=time(0);
    struct sockaddr_in s,c;
    char buffer[20],smsg[30];
    strcpy(smsg,ctime(&t));
    int clen; 
    system(""clear"");
    if(argc<3)
    {
        printf(""\nUSAGE : %s IP_ADDRESS PORT#\n"",argv[0]);
        exit(0);
    }
    sid=socket(AF_INET,SOCK_STREAM,6);
    if(sid==-1)
    {
        perror(""SOCK-CRE-ERR:"");
        exit(1);
    }

    s.sin_family=AF_INET;
    s.sin_port=htons(atoi(argv[2]));
    s.sin_addr.s_addr=inet_addr(argv[1]);

    rval=bind(sid,(struct sockaddr*)&s,sizeof(s));
    if(rval==-1)
    {
        perror(""BIND-ERR:"");
        close(sid);
        exit(1);
    }
    rval=listen(sid,5);
    if(rval==-1)
    {
        perror(""LISTEN-ERR:"");
        close(sid);
        exit(1);
    }
    clen=sizeof(c);
    sid1=accept(sid,(struct sockaddr*)&c,&clen);
    rval=recv(sid1,buffer,sizeof(buffer),0);
    if(rval==-1)
    {
        perror(""MSG-RCV-ERR:"");
    }
    else
    {
        printf(""\nClient request is %s\n"",buffer);
    }
    strcpy(smsg,ctime(&t));
    rval=send(sid1,smsg,sizeof(smsg),0);
    if(rval==-1)
    {
        perror(""MSG-SND-ERR:"");
    }
    else
    {
        printf(""\nResponse sent\n"");
    }
    close(sid);
    close(sid1);
}
",59,1726,562
"void main(int argc,char* argv[])
{
    struct sockaddr_in s,c; 
    int rval,sockid,slen;
    char m1[20],m2[20];
    system(""clear"");
    if(argc<3)
    {
        printf(""\nUSAGE : %s IP-Address Port#\n"",argv[0]);
        exit(1);
    }
    sockid=socket(PF_INET,SOCK_DGRAM,17);
    if(sockid==-1)
    {
        perror(""SOCK-CRE-ERR:"");
        exit(1);
    }
    s.sin_family=PF_INET;
    s.sin_port=htons(atoi(argv[2]));
    s.sin_addr.s_addr=inet_addr(argv[1]);
    c.sin_port=htons(5080);
    printf(""\nEnter the request message : "");
    scanf(""%s"",m1);
    slen=sizeof(s);
    rval=sendto(sockid,m1,sizeof(m1),0,(struct sockaddr*)&s,slen);
    if(rval==-1)
    {
        perror(""MSG-SEND-ERR:"");
        exit(1);
    }
    printf(""\nMessage sent successfully\n"");
    strncpy(m2,"" "",20);
    rval=recvfrom(sockid,m2,sizeof(m2),0,(struct sockaddr*)&s,&slen);
    if(rval==-1)
    {
        perror(""MSG-RCV-ERR:"");
        exit(1);
    }
    printf(""\nMessage received is : %s\n"",m2);
    close(sockid);
}
",59,1727,448
"void main(int argc,char* argv[])
{
    
    int rval,sockid;
    
    sockid=socket(AF_INET,SOCK_STREAM,6);   
    if(sockid==-1)
    {
        perror(""SOCK-CRE-ERR:"");
        exit(1);
    }
    struct sockaddr_in s,c;
    
    system(""clear"");
    if(argc<2)
    {
        printf(""\nUSAGE : %s IP_ADDR PORT#\n"",argv[0]);
        exit(1);
    }
    s.sin_family=AF_INET;
    s.sin_port=htons(atoi(argv[2]));
    s.sin_addr.s_addr=inet_addr(argv[1]);
    char msg[30];
    rval=connect(sockid,(struct sockaddr*)&s, sizeof(s)); 
    if(rval==-1)  
    {   
        perror(""CONN-ERR:"");   
        close(sockid);   
        exit(1);
    }
    printf(""\nEnter the request message : "");  
    scanf(""%s"",msg);  
    send(sockid,msg,sizeof(msg),0); 
    close(sockid);
}
",59,1728,325
"#define _CRT_SECURE_NO_WARNINGS



typedef struct polinom* pozicija;
struct polinom {
    int koeficijent;
    int eksponent;
    pozicija next;
};
int unosPrvi(pozicija);
int unosDrugi(pozicija);
int ispis(pozicija);
int zbroj(pozicija, pozicija, pozicija);
int umnozak(pozicija, pozicija, pozicija);
int main() {
    struct polinom Head1;
    struct polinom Head2;
    struct polinom HeadZ;
    struct polinom HeadM;
    Head1.next = NULL;
    Head2.next = NULL;
    HeadZ.next = NULL;
    HeadM.next = NULL;
    unosPrvi(&Head1);
    unosDrugi(&Head2);
    printf(""Ispis prvog polinoma:\n"");
    ispis(Head1.next);
    printf(""Ispis drugog polinoma:\n"");
    ispis(Head2.next);
    zbroj(&Head1, &Head2, &HeadZ);
    printf(""Ispis zbrojenog polinoma:\n"");
    ispis(HeadZ.next);
    umnozak(&Head1, &Head2, &HeadM);
    printf(""Ispis pomnozenih polinoma:\n"");
    ispis(HeadM.next);
    return 0;
}
int unosPrvi(pozicija p)
{
    FILE* fp = NULL;
    fp = fopen(""pol1.txt"", ""r"");
    if (fp == NULL)
    {
        printf(""Neuspjesno otvaranje datoteke!\n"");
        return 1;
    }
    while (!feof(fp))
    {
        pozicija q = NULL;
        q = (pozicija)malloc(sizeof(struct polinom));
        if (q == NULL)
        {
            printf(""Neuspjesna alokacija memorije!\n"");
            return 1;
        }
        pozicija pret, temp;
        temp = p->next;
        pret = p;
        fscanf(fp, ""%d %d"", &q->koeficijent, &q->eksponent);
        while (temp != NULL && temp->eksponent < q->eksponent)
        {
            pret = temp;
            temp = temp->next;
        }
        pret->next = q;
        if (temp != NULL)
            q->next = temp;
        else
            q->next = NULL;
    }
    return 0;
}
int unosDrugi(pozicija p)
{
    FILE* fp = NULL;
    fp = fopen(""pol2.txt"", ""r"");
    if (fp == NULL)
    {
        printf(""Neuspjesno otvaranje datoteke!\n"");
        return 1;
    }
    while (!feof(fp))
    {
        pozicija q = NULL;
        q = (pozicija)malloc(sizeof(struct polinom));
        if (q == NULL)
        {
            printf(""Neuspjesna alokacija memorije!\n"");
            return 1;
        }
        pozicija pret, temp;
        temp = p->next;
        pret = p;
        fscanf(fp, ""%d %d"", &q->koeficijent, &q->eksponent);
        while (temp != NULL && temp->eksponent < q->eksponent)
        {
            pret = temp;
            temp = temp->next;
        }
        pret->next = q;
        if (temp != NULL)
            q->next = temp;
        else
            q->next = NULL;
    }
    return 0;
    return 0;
}
int ispis(pozicija p)
{
    while (p != NULL)
    {
        printf(""Koeficijent je: %d Eksponent je: %d\n"", p->koeficijent, p->eksponent);
        p = p->next;
    }
    return 0;
}
int zbroj(pozicija p, pozicija q, pozicija r)
{
    while (p->next != NULL && q->next != NULL)
    {
        pozicija s = NULL;
        s = (pozicija)malloc(sizeof(struct polinom));
        if (s == NULL)
        {
            printf(""Neuspjesna alokacija memorije!\n"");
            return 1;
        }
        s->next = NULL;

        if (p->next->eksponent < q->next->eksponent)
        {
            s->eksponent = p->next->eksponent;
            s->koeficijent = p->next->koeficijent;
            p = p->next;
        }
        else if (p->next->eksponent > q->next->eksponent)
        {
            s->eksponent = q->next->eksponent;
            s->koeficijent = q->next->koeficijent;
            q = q->next;
        }
        else
        {
            s->eksponent = p->next->eksponent;
            s->koeficijent =(p->next->koeficijent + q->next->koeficijent);
            p = p->next;
            q = q->next;
        }
        r->next = s;
        r = s;
    }
    pozicija temp;
    if (p->next == NULL)
        temp = q->next;
    else
        temp = p->next;
    while (temp != NULL)
    {
        pozicija s = NULL;
        s = (pozicija)malloc(sizeof(struct polinom));
        if (s == NULL)
        {
            printf(""Neuspjesna alokacija memorije!\n"");
            return 1;
        }
        s->next = NULL;
        s->eksponent = temp->eksponent;
        s->koeficijent = temp->koeficijent;
        r->next = s;
        r = s;
        temp = temp->next;
    }
    return 0;
}
int umnozak(pozicija p, pozicija q, pozicija r)
{
    pozicija prvi = p->next;
    pozicija drugi = q->next;
    struct polinom P;
    pozicija s = NULL;
    s = (pozicija)malloc(sizeof(struct polinom));
    if (s == NULL)
    {
        printf(""Neuspjesna alokacija memorije!\n"");
        return 1;
    }
    s->next = NULL;
    P.next = s;
    while (prvi != NULL)
    {
        drugi = q->next;
        while (drugi != NULL)
        {

            s->koeficijent = prvi->koeficijent * drugi->koeficijent;
            s->eksponent = prvi->eksponent + drugi->eksponent;

            zbroj(&P, r, r);
            drugi = drugi->next;
        }
        prvi = prvi->next;
    }

    return 0;
}",60,1729,1872
"#include ""ShuffleIslands.h""
#include ""RandomGenerator.h""
#include ""NumberOfIslands.h""
int Shuffle(islandPointer startIsland, int numberOfIslands)
{
    islandPointer islandToChange = startIsland->next;
    islandPointer start = startIsland;
    islandPointer prevOfIslandToChange = startIsland;
    while(islandToChange->next)
    {
        prevOfIslandToChange = startIsland;
        islandToChange = startIsland->next;
        int randomIndex = GenerateRandom(start->next->index, numberOfIslands);
        islandPointer changeWithMe = start;
        islandPointer prevOfChangeWithMe = changeWithMe;
        islandPointer nextOfChangeWithMe = changeWithMe->next;
        while (changeWithMe->index != randomIndex)
        {
            prevOfChangeWithMe = changeWithMe;
            changeWithMe = changeWithMe->next;
            nextOfChangeWithMe = changeWithMe->next;
        }
        if (islandToChange->index != randomIndex)
        {
            if (islandToChange->next == changeWithMe)
            {
                prevOfIslandToChange->next = changeWithMe;
                prevOfChangeWithMe->next = changeWithMe->next;
                changeWithMe->next = islandToChange;
                islandToChange->next = nextOfChangeWithMe;
            }
            else if (changeWithMe->next == islandToChange)
            {
                prevOfChangeWithMe->next = islandToChange;
                prevOfIslandToChange->next = islandToChange->next;
                changeWithMe->next = islandToChange->next;
                islandToChange->next = changeWithMe;
            }
            else 
            {
                prevOfIslandToChange->next = changeWithMe;
                prevOfChangeWithMe->next = islandToChange;
                changeWithMe->next = islandToChange->next;
                islandToChange->next = nextOfChangeWithMe;
            }
        }
        startIsland = startIsland->next;
        if (!startIsland->next)
            break;
    }
    return 0;
}",60,1730,526
"#define _CRT_SECURE_NO_WARNINGS


#define MAX_NAME_OF_FILE 30

typedef struct treeNode* treePointer;
typedef struct stack* stackPointer;
struct treeNode
{
    char data;
    treePointer left;
    treePointer right;
};
struct stack
{
    stackPointer next;
    treePointer nextTree;
};
treePointer ReadFromFile(char*, treePointer, stackPointer);
int Push(stackPointer, char);
stackPointer AllocateMemoryForStackElement(stackPointer, char);
treePointer AllocateMemoryForTree(char);
treePointer Pop(stackPointer);
treePointer EditTree(treePointer, treePointer, treePointer);
int CreateTree(treePointer, stackPointer);
int WriteInFile(char *, treePointer);
int InOrderPrintInFile(FILE*, treePointer);
int main()
{
    stackPointer head = (stackPointer)malloc(sizeof(struct stack));
    head->next = NULL;
    treePointer root = NULL;
    char readFile[MAX_NAME_OF_FILE] = ""postfix.txt"";
    char writeFile[MAX_NAME_OF_FILE] = ""infix.txt"";
    root = ReadFromFile(readFile, root, head);
    WriteInFile(writeFile, root);
    return 0;
}
treePointer ReadFromFile(char* nameOfFile, treePointer root, stackPointer head)
{
    char sign;
    treePointer rightChild = NULL;
    treePointer leftChild = NULL;
    FILE* fp = NULL;
    fp = fopen(nameOfFile, ""r"");
    if (!fp)
    {
        printf(""Greska kod otvaranja datoteke!\n"");
        return fp;
    }
    while (!feof(fp))
    {
        fscanf(fp, ""%c "", &sign);
        if (sign == '+' || sign == '-' || sign == '*' || sign == '/')
        {
            root = AllocateMemoryForTree(sign);
            rightChild = Pop(head);
            leftChild = Pop(head);
            root = EditTree(root, rightChild, leftChild);
            CreateTree(root, head);
        }
        else
            Push(head, sign);
    }
    root = head->next->nextTree;
    fclose(fp);
    return root;
}
int Push(stackPointer head, char sign)
{
    stackPointer newStackElement = AllocateMemoryForStackElement(head, sign);
    newStackElement->next = head->next;
    head->next = newStackElement;
    return 0;
}
stackPointer AllocateMemoryForStackElement(stackPointer head, char sign)
{
    stackPointer newStackElement = (stackPointer)malloc(sizeof(struct stack));
    if (!newStackElement)
    {
        printf(""Neuspjesna alokacija memorije!\n"");
        return newStackElement;
    }
    newStackElement->next = NULL;
    newStackElement->nextTree = AllocateMemoryForTree(sign);
    return newStackElement;
}
treePointer AllocateMemoryForTree(char sign)
{
    treePointer newTreeNode = (treePointer)malloc(sizeof(struct treeNode));
    if (!newTreeNode)
    {
        printf(""Neuspjesna alokacija memorije!\n"");
        return newTreeNode;
    }
    newTreeNode->left = NULL;
    newTreeNode->right = NULL;
    newTreeNode->data = sign;
    return newTreeNode;
}
treePointer Pop(stackPointer head)
{
    stackPointer deletedStackElement = head->next;
    treePointer returnedTree = NULL;
    head->next = deletedStackElement->next;
    returnedTree = deletedStackElement->nextTree;
    free(deletedStackElement);
    return returnedTree;
}
treePointer EditTree(treePointer root, treePointer rightChild, treePointer leftChild)
{
    root->right = rightChild;
    root->left = leftChild;
    return root;
}
int CreateTree(treePointer root, stackPointer head)
{
    stackPointer nodeToAdd = (stackPointer)malloc(sizeof(struct stack));
    if (!nodeToAdd)
    {
        printf(""Neuspjesna alokacija memorije!\n"");
        return 1;
    }
    nodeToAdd->next = head->next;
    head->next = nodeToAdd;
    nodeToAdd->nextTree = root;
    return 0;
}
int WriteInFile(char* nameOfFile, treePointer root)
{
    FILE* fp = NULL;
    fp = fopen(nameOfFile, ""w"");
    if (!fp)
    {
        printf(""Greska kod otvaranja datoteke!\n"");
        return 1;
    }
    InOrderPrintInFile(fp, root);
    fclose(fp);
    return 0;
}
int InOrderPrintInFile(FILE* fp, treePointer root)
{
    if (root)
    {
        InOrderPrintInFile(fp, root->left);
        fprintf(fp, ""%c "", root->data);
        InOrderPrintInFile(fp, root->right);
    }
    return 0;
}",60,1731,1289
"#define _CRT_SECURE_NO_WARNINGS



typedef struct treeNode* treePointer;
struct treeNode
{
    int data;
    treePointer left;
    treePointer right;
};
treePointer AllocateMemory(int);
treePointer InsertElement(int, treePointer);
int InOrderPrint(treePointer);
int PostOrderPrint(treePointer);
int PreOrderPrint(treePointer);
treePointer DeleteElement(int, treePointer);
treePointer FindMin(treePointer);
treePointer FindElement(int, treePointer);
int main()
{
    treePointer root = NULL;
    root = InsertElement(2, root);
    root = InsertElement(4, root);
    root = InsertElement(9, root);
    root = InsertElement(1, root);
    root = InsertElement(11, root);
    root = InsertElement(7, root);
    root = DeleteElement(2, root);
    int choice = 0, element;
    treePointer temp = NULL;

    do
    {
        printf(""Odaberi:\n"");
        printf(""1 - unos novog elementa u stablo\n"");
        printf(""2 - ispis inorder stabla\n"");
        printf(""3 - ispis postorder stabla\n"");
        printf(""4 - ispis preorder stabla\n"");
        printf(""5 - trazenje elementa stabla\n"");
        printf(""6 - brisanje elementa iz stabla\n"");
        printf(""7 - izlaz\n"");

        scanf(""%d"", &choice);
        system(""cls"");
        switch (choice)
        {
        case 1:
            printf(""Unesi element koji zelis unijeti u stablo:\n"");
            scanf(""%d"", &element);
            root = InsertElement(element, root);
            break;
        case 2:
            InOrderPrint(root);
            break;
        case 3:
            PostOrderPrint(root);
            break;
        case 4:
            PreOrderPrint(root);
            break;
        case 5:
            printf(""Unesi element koji trazis u stablu:\n"");
            scanf(""%d"", &element);
            temp = FindElement(element, root);
            if (temp)
                printf(""Element %d se nalazi na adresi %d\n"", temp->data, temp);
            break;
        case 6:
            printf(""Unesi element koji brises iz stabla:\n"");
            scanf(""%d"", &element);
            root = DeleteElement(element, root);
        case 7:
            break;
        default:
            printf(""Pogresan unos!\n"");
        }
    } while (choice != '7');
    return 0;
}
treePointer AllocateMemory(int element)
{
    treePointer newNode = (treePointer)malloc(sizeof(struct treeNode));
    if (!newNode)
    {
        printf(""Problem s alokacijom memorije!\n"");
        return newNode;
    }
    newNode->data = element;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;

}
treePointer InsertElement(int element, treePointer root)
{
    if (!root)
        return AllocateMemory(element);
    else if (element < root->data)
        root->left = InsertElement(element, root->left);
    else if (element > root->data)
        root->right = InsertElement(element, root->right);
    return root;
}
int InOrderPrint(treePointer root)
{
    if (root)
    {
        InOrderPrint(root->left);
        printf(""%d\n"", root->data);
        InOrderPrint(root->right);
    }
    return 0;
}
int PostOrderPrint(treePointer root)
{
    if (root)
    {
        PostOrderPrint(root->left);
        PostOrderPrint(root->right);
        printf(""%d\n"", root->data);
    }
    return 0;
}
int PreOrderPrint(treePointer root)
{
    if (root)
    {
        printf(""%d\n"", root->data);
        PreOrderPrint(root->left);
        PreOrderPrint(root->right);
    }
    return 0;
}
treePointer DeleteElement(int element, treePointer root)
{
    treePointer temp;
    if (!root)
        return root;
    else if (element < root->data)
        root->left = DeleteElement(element, root->left);
    else if (element > root->data)
        root->right = DeleteElement(element, root->right);
    else
    {
        if (root->left && root->right)
        {
            temp = FindMin(root->right);
            root->data = temp->data;
            root->right = DeleteElement(temp->data, root->right);
        }
        else
        {
            temp = root;
            if (!root->left)
                root = root->right;
            else if (!root->right)
                root = root->left;
            free(temp);
        }
    }
    return root;
}
treePointer FindMin(treePointer root)
{
    while (root->left)
        root = root->left;
    return root;
}
treePointer FindElement(int element, treePointer root)
{
    if (!root)
        return root;
    else if (element < root->data)
        return FindElement(element, root->left);
    else if (element > root->data)
        return FindElement(element, root->right);
    else
        return root;
}",60,1732,1387
"#define _CRT_SECURE_NO_WARNINGS





typedef struct stog* pozicija;
struct stog {
    int el;
    pozicija next;
};
int push(pozicija head, int element);
int pop(pozicija head);
int dat(pozicija head);
int zbroj(pozicija head);
int razlika(pozicija head);
int umnozak(pozicija head);
int kvocijent(pozicija head);
int main()
{
    struct stog Head;
    Head.next = NULL;
    dat(&Head);
    printf(""Rezultat je %d\n"", Head.next->el);
    return 0;
}
int dat(pozicija head)
{
    FILE* fp = NULL;
    fp = fopen(""postfix.txt"", ""r"");
    char operacija[15];
    if (fp == NULL)
    {
        printf(""Neuspjesno otvaranje datoteke!\n"");
        return 1;
    }
    while (!feof(fp))
    {
        int br = 0;
        int procitani = sscanf(fp, ""%d"", &br);
        if (!procitani) {
            if (!strcmp(procitani, ""+""))
                zbroj(head);
            else if (!strcmp(procitani, ""-""))
                razlika(head);
            else if (!strcmp(procitani, ""*""))
                umnozak(head);
            else if (!strcmp(procitani, ""/""))
                kvocijent(head);
        }
        else
            push(head, procitani);
    }
    fclose(fp);
    return 0;

}
int push(pozicija head, int element)
{
    pozicija novi;
    novi = (pozicija)malloc(sizeof(struct stog));
    if (novi == NULL)
    {
        printf(""Neuspjesna alokacija memorije!\n"");
        return 1;
    }
    novi->el = element;
    novi->next = head->next;
    head->next = novi;

    return 0;
}
int pop(pozicija head)
{
    pozicija temp = NULL;
    int element;
    if (head == NULL)
        printf(""Stog je prazan!\n"");
    else {
        temp = head->next;
        element = temp->el;
        head->next = temp->next;
        free(temp);
    }
    return element;
}
int zbroj(pozicija head)
{
    int prviBroj = pop(head);
    int drugiBroj = pop(head);
    push(head, drugiBroj + prviBroj);
    return 0;
}
int razlika(pozicija head)
{
    int prviBroj = pop(head);
    int drugiBroj = pop(head);
    push(head, drugiBroj - prviBroj);
    return 0;
}
int umnozak(pozicija head)
{
    int prviBroj = pop(head);
    int drugiBroj = pop(head);
    push(head, drugiBroj * prviBroj);
    return 0;
}
int kvocijent(pozicija head)
{
    int prviBroj = pop(head);
    int drugiBroj = pop(head);
    push(head, drugiBroj / prviBroj);
    return 0;
}
",60,1733,903
"#define _CRT_SECURE_NO_WARNINGS






#define MAX_DIR_LENGTH 256

typedef struct dir* Position;
typedef struct stack* StackPosition;
typedef struct dir {
    char name[MAX_DIR_LENGTH];
    Position sibling;
    Position child;
}Dir;

typedef struct stack {
    Position data;
    StackPosition next;
} Stack;
Position AllocateMemoryForDirectory();
StackPosition AllocateMemoryForStack();
int PushStack(Position, StackPosition);
Position PopStack(StackPosition);
Position MakeDirectory(Position, char*);
Position ChangeDirectory(Position, StackPosition, char*);
Position ChangeToPreviousDirectory(StackPosition);
int PrintDirectory(Position);
int Path(Position, StackPosition);
int CommandPrompt(Position current, StackPosition stackHead);
void Remove(Position);
int main()
{
    Dir C;
    C.sibling = NULL;
    C.child = NULL;
    strcpy(C.name, ""C:"");

    Stack stackHead;
    stackHead.data = NULL;
    stackHead.next = NULL;

    PushStack(&C, &stackHead);
    CommandPrompt(&C, &stackHead);

    return 0;
}
Position PopStack(StackPosition stackHead)
{
    StackPosition tempStackElement = stackHead->next, prev = stackHead->next;
    if (!tempStackElement->next)
        return NULL;
    while (tempStackElement->next)
    {
        prev = tempStackElement;
        tempStackElement = tempStackElement->next;
    }
        Position directory = tempStackElement->data;
        prev->next = tempStackElement->next;
        free(tempStackElement);
        return directory;
}
int PushStack(Position current, StackPosition stackHead)
{
    StackPosition newStackElement;
    StackPosition tempStackElement = stackHead;
    if (newStackElement = AllocateMemoryForStack()) 
    {
        while (tempStackElement->next)
            tempStackElement = tempStackElement->next;
        newStackElement->next = tempStackElement->next;
        tempStackElement->next = newStackElement;
        newStackElement->data = current;
        return 0;
    }
    else
        return 1;
}
int PrintDirectory(Position current)
{
    if (!current->child)
        printf(""Directory is empty!\n"");
    else
    {
        current = current->child;
        while (current)
        {
            printf("" %s\n"", current->name);
            current = current->sibling;
        }
    }
    return 0;
}
Position ChangeToPreviousDirectory(StackPosition stackHead)
{
    return PopStack(stackHead);
}
Position ChangeDirectory(Position current, StackPosition stackHead, char* name)
{
    if (!current->child)
    {
        
        return current;
    }
    else
    {
        Position parent = current;
        Position finderOfWantedDirectory = current->child;
        while (finderOfWantedDirectory)
        {
            if (!strcmp(finderOfWantedDirectory->name, name))
            {
                PushStack(finderOfWantedDirectory, stackHead);
                return finderOfWantedDirectory;
            }
            finderOfWantedDirectory = finderOfWantedDirectory->sibling;
        }
        
        return parent;
    }
}
Position MakeDirectory(Position current, char* name)
{
    Position newDirectory;
    newDirectory = AllocateMemoryForDirectory();

    strcpy(newDirectory->name, name);
        if (!current->child)
        {
            current->child = newDirectory;
        }
        else
        {
            Position currentChild = current->child;
            while (currentChild->sibling)
                currentChild = currentChild->sibling;
            currentChild->sibling = newDirectory;
        }
        return current;
}
StackPosition AllocateMemoryForStack()
{
    StackPosition newStackElement = (StackPosition)malloc(sizeof(Dir));
    if (!newStackElement)
    {
        printf(""Can not allocate memory!\n"");
    }
    return newStackElement;
}
Position AllocateMemoryForDirectory()
{
    Position newDirectory = (Position)malloc(sizeof(Dir));
    if (!newDirectory)
    {
        printf(""Can not allocate memory!\n"");
    }
    newDirectory->child = NULL;
    newDirectory->sibling = NULL;
    return newDirectory;    
}
void Remove(Position current)
{
    if (!current)
        return;
    remove(current->sibling);
    remove(current->child);
    
}
int Path(Position current, StackPosition stackHead)
{
    char stringToPrint[MAX_DIR_LENGTH] = """";
    
    while (stackHead)
    {
            strcat(stringToPrint, stackHead->data->name);
            strcat(stringToPrint, ""\\"");
            stackHead = stackHead->next;
    }
    strcat(stringToPrint, "">"");
    printf(""%s "", stringToPrint);
    return 0;
}
int CommandPrompt(Position current, StackPosition stackHead)
{
    Position C = current;
    char userInput[MAX_DIR_LENGTH];
    char command[5];
    char directoryName[MAX_DIR_LENGTH];
    Path(current, stackHead->next);
    do {
        fgets(userInput, MAX_DIR_LENGTH, stdin);
        sscanf(userInput, ""%s %s"", command, directoryName);
        if (!strcmp(command, ""md""))
        {
            current = MakeDirectory(current, directoryName);
            Path(current, stackHead->next);
        }
        else if (!strcmp(command, ""cd""))
        {
            current = ChangeDirectory(current, stackHead, directoryName);
            Path(current, stackHead->next);
        }
        else if (!strcmp(command, ""cd..""))
        {
            if (current = ChangeToPreviousDirectory(stackHead) == NULL)
                current = C;
            Path(current, stackHead->next);
        }
        else if (!strcmp(command, ""dir""))
        {
            PrintDirectory(current);
            Path(current, stackHead->next);
        }
        else if (!strcmp(command, ""exit""))
            Remove(current);
        else
            printf(""That's not an option!"");
    } while (strcmp(command, ""exit""));
    return 0;
}",60,1734,1613
"#include ""functions.h""

pointerHash InitializeHashTable(int size)
{
    pointerHash table;
    table = (pointerHash)malloc(sizeof(HashTable));
    if (!table)
    {
        printf(""Problem with memory allocation!\n"");
        return table;
    }
    table->size = size;
    table->hashList = (position*)malloc(sizeof(position) * size);
    if (!table->hashList)
    {
        printf(""Problem with memory allocation!\n"");
        return table->hashList;
    }
    for (int i = 0; i < table->size; i++)
        table->hashList[i] = NULL;
    return table;
}
int CountKey(char* lastName)
{
    int lengthOfLastName = strlen(lastName);
    int sum = 0, i = 0;
    if (lengthOfLastName < LAST_NAME_LENGTH)
    {
        for (i = 0; i < lengthOfLastName; i++)
            sum += lastName[i];
    }
    else
    {
        for (i = 0; i < LAST_NAME_LENGTH; i++)
            sum += lastName[i];
    }
    return (sum % SIZE_OF_TABLE);
}
int InputStudentsFromFile(char* fileName, pointerHash hashTable)
{
    FILE* fp = NULL;
    fp = fopen(fileName, ""r"");
    if (!fp)
    {
        printf(""Can't open file!\n"");
        return fp;
    }
    char fileFirstName[MAX_STRING_LENGTH];
    char fileLastName[MAX_STRING_LENGTH];
    char fileRegistrationNumber[MAX_STRING_LENGTH];

    while (!feof(fp))
    {
        fscanf(fp, ""%s %s %s\n"", fileFirstName, fileLastName, fileRegistrationNumber);
        AddToHashTable(AllocateMemoryForStudent(fileFirstName, fileLastName, fileRegistrationNumber), hashTable);
    }
    fclose(fp);
    return 0;
}
position AllocateMemoryForStudent(char* firstName, char* lastName, char* registrationNumber)
{
    position newStudent = NULL;
    newStudent = (position)malloc(sizeof(ListElement));
    if (!newStudent)
    {
        printf(""Problem with memory allocation!\n"");
        return newStudent;
    }
    newStudent->next = NULL;
    strcpy(newStudent->firstName, firstName);
    strcpy(newStudent->lastName, lastName);
    strcpy(newStudent->registrationNumber, registrationNumber);
    return newStudent;
}
int AddToHashTable(position newStudent, pointerHash hashTable)
{
    int hashKey = CountKey(newStudent->lastName, hashTable->size);
    if (!hashTable->hashList[hashKey])
        hashTable->hashList[hashKey] = newStudent;
    else
    {
        position currentStudent = hashTable->hashList[hashKey];
        if (currentStudent && (strcmp(newStudent->lastName, currentStudent->lastName) < 0 || (strcmp(newStudent->lastName, currentStudent->lastName) == 0 && strcmp(newStudent->firstName, currentStudent->firstName) < 0)))
        {
            hashTable->hashList[hashKey] = newStudent;
            newStudent->next = currentStudent;
        }
        else 
        {
            while (currentStudent->next)
            {
                if (strcmp(newStudent->lastName, currentStudent->next->lastName) < 0 || (strcmp(newStudent->lastName, currentStudent->next->lastName) == 0 && strcmp(newStudent->firstName, currentStudent->next->firstName) < 0))
                {
                    newStudent->next = currentStudent->next;
                    currentStudent->next = newStudent;
                    break;
                }
                currentStudent = currentStudent->next;
            }
            if (!currentStudent->next)
            {
                newStudent->next = currentStudent->next;
                currentStudent->next = newStudent;
            }
        }
    }
    return 0;
}
int PrintHashTable(pointerHash hashTable)
{
    printf(""Hash table of students:\n\n"");
    for (int i = 0; i < hashTable->size; i++)
    {
        int printMeOnce = 1;
        position current = hashTable->hashList[i];
        while (current)
        {
            if (printMeOnce == 1)
            {
                printf(""Key:%d\n"", i);
                printMeOnce++;
            }
            printf(""%s %s\n\n"", current->firstName, current->lastName);
            current = current->next;
        }
    }
    return 0;
}
int FindStudent(char* lastName, char* firstName, pointerHash hashTable)
{
    int hashKey = CountKey(lastName);
    position currentStudent = hashTable->hashList[hashKey];
    int isFound = 0;
    while (currentStudent && !isFound)
    {
        if (strcmp(currentStudent->lastName, lastName) == 0 && strcmp(currentStudent->firstName, firstName) == 0)
        {
            printf(""Registration number for %s %s is:%s\n"", currentStudent->firstName, currentStudent->lastName, currentStudent->registrationNumber);
            isFound = 1;
        }
        currentStudent = currentStudent->next;
    }
    if (!isFound)
    {
        printf(""Student does not exist!\n"");
    }
    return 0;
}
",60,1735,1381
"#define _CRT_SECURE_NO_WARNINGS



#define MIN 10
#define MAX 100
typedef struct cvor* pozicija;
struct cvor {
    int el;
    pozicija next;
};
int stog(pozicija);
int red(pozicija);
int push(pozicija);
int pop(pozicija);
int pushR(pozicija);
int ispis(pozicija);
int main()
{
    srand(time(NULL));
    struct cvor HeadS;
    HeadS.next = NULL;
    struct cvor HeadR;
    HeadR.next = NULL;
    char c;
    while (1) {
        printf(""Unesi 1 za implementaciju stoga, a 2 za implementaciju reda, 0 za izlaz iz programa\n"");
        scanf("" %c"", &c);
        if (c == '1')
            stog(&HeadS);
        else if (c == '2')
            red(&HeadR);
        else if (c == '0')
            break;
        else
            printf(""Nisi unio ispravni broj!\n"");
    }


    return 0;
}
int stog(pozicija p)
{
    char c;
    while (1) {
        printf(""Unesi N za unos novog elementa stoga, M za micanje postojeceg elementa stoga, I za ispis elemenata stoga, X za izlaz\n"");
        scanf("" %c"", &c);
        if (c == 'N')
            push(p);
        else if (c == 'M')
            pop(p);
        else if (c == 'I')
            ispis(p->next);
        else if (c == 'X')
            break;
        else
            printf(""Nisi unio ispravno slovo!\n"");
    }
    return 0;
}
int red(pozicija p)
{
    char c;
    while (1) {
        printf(""Unesi N za unos novog elementa reda, M za micanje postojeceg elementa reda, I za ispis elemenata reda, X za izlaz\n"");
        scanf("" %c"", &c);
        if (c == 'N')
            pushR(p);
        else if (c == 'M')
            pop(p);
        else if (c == 'I')
            ispis(p->next);
        else if (c == 'X')
            break;
        else
            printf(""Nisi unio ispravno slovo!\n"");
    }
    return 0;
}
int ispis(pozicija p)
{
    while (p != NULL)
    {
        printf(""Element je: %d\n"", p->el);
        p = p->next;
    }
    return 0;
}
int push(pozicija p)
{ 
    pozicija q = NULL;
    q = (pozicija)malloc(sizeof(struct cvor));
    if (q == NULL)
    {
        printf(""Neuspjesna alokacija memorije!\n"");
        return 1;
    }
    int broj = (rand() % (MAX - MIN + 1)) + MIN;
    q->el = broj;
    q->next = p->next;
    p->next = q;

    return 0;
}
int pop(pozicija p)
{ 
    pozicija q = NULL;
    if (p->next == NULL)
        printf(""Nisi jos dodao niti jedan element!\n"");
    else
    {
        printf(""Skidamo element:%d\n"", p->next->el);
        q = p->next;
        p->next = q->next;
        free(q);
    }
    return 0;
}
int pushR(pozicija p)
{ 
    pozicija q = NULL;
    q = (pozicija)malloc(sizeof(struct cvor));
    if (q == NULL)
    {
        printf(""Neuspjesna alokacija memorije!\n"");
        return 1;
    }
     pozicija kraj = NULL;
    if (p->next == NULL)
        kraj = p;
    int broj = (rand() % (MAX - MIN + 1)) + MIN;
    q->el = broj;
    q->next = NULL;
    kraj->next = q;
    kraj = q;
    return 0;
}",60,1736,1136
"#include ""Stack.h""
#include ""AllocateMemory.h""
islandPointer PopStack(stackPointer stackHead)
{
    stackPointer tempStackElement = stackHead->next, prev = stackHead->next;
    if (!tempStackElement->next)
        return NULL;
    while (tempStackElement->next)
    {
        prev = tempStackElement;
        tempStackElement = tempStackElement->next;
    }
    islandPointer island = tempStackElement->data;
    prev->next = tempStackElement->next;
    free(tempStackElement);
    return island;
}
int PushStack(islandPointer current, stackPointer stackHead)
{
    stackPointer newStackElement;
    stackPointer tempStackElement = stackHead;
    if (newStackElement = AllocateMemoryForStack())
    {
        while (tempStackElement->next)
            tempStackElement = tempStackElement->next;
        newStackElement->next = tempStackElement->next;
        tempStackElement->next = newStackElement;
        newStackElement->data = current;
        return 0;
    }
    else
        return 1;
}
int CleanStack(stackPointer stackHead)
{
    stackPointer prev = stackHead->next, top = stackHead->next;
    stackHead = stackHead->next;
    while (top->next)
    {
        while (stackHead->next)
        {
            prev = stackHead;
            stackHead = stackHead->next;
        }
        free(stackHead);
        prev->next = NULL;
        stackHead = top->next;
        prev = top;
    }
    return 0;
}
stackPointer CreateStackHead()
{
    stackPointer stackHead = AllocateMemoryForStack();
    stackHead->data = NULL;
    stackHead->next = NULL;
    return stackHead;
}",60,1737,449
"#include ""Travels.h""
#include ""CoinCalculator.h""
#include ""Respawn.h""
#include ""Stack.h""
#include ""IslandType.h""
islandPointer TravelToLeftIsland(int* currentAmountOfCoins, int* numberOfFoundClues, islandPointer start, islandPointer currentIsland, stackPointer stackHead, int* flagForGameOver)
{
    islandPointer parentIsland = currentIsland;
    if (HaveEnoughCoins(*currentAmountOfCoins, currentIsland->leftNext->coins))
    {
        *currentAmountOfCoins = SpendCoins(*currentAmountOfCoins, currentIsland->leftNext->coins);
        currentIsland = currentIsland->leftNext;
        PushStack(currentIsland, stackHead);
        printf(""%s\n"", currentIsland->description);
        if (isClueIsland(currentIsland))
        {
            printf(""Trag je: %c\n"", currentIsland->clue);
            *numberOfFoundClues += 1;
        }
        else if (isDeathlyIsland(currentIsland, start))
        {
            if (HaveEnoughCoins(*currentAmountOfCoins, COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE))
            {
                char choice = RespawnPrint(*currentAmountOfCoins);
                system(""cls"");
                if (tolower(choice) == 'd')
                {
                    *currentAmountOfCoins = SpendCoins(*currentAmountOfCoins, COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE);
                    PrintCurrentPath(currentIsland, stackHead);
                    printf(""Status coina: %d\n"", *currentAmountOfCoins);
                    printf(""Uskrsnuo si!\n"");
                    currentIsland = TravelToPrevIsland(parentIsland, currentIsland, stackHead);
                }
                else
                {
                    currentIsland = TravelToStartIsland(start, currentIsland, stackHead);
                    *flagForGameOver = 1;
                }
            }
            else
            {
                currentIsland = TravelToStartIsland(start, currentIsland, stackHead);
                *flagForGameOver = 1;
            }
        }
        else
        {
            PrintCurrentPath(currentIsland, stackHead);
            currentIsland = TravelToPrevIsland(parentIsland, currentIsland, stackHead);
        }
    }
    else 
    {
        printf(""Nazalost presiromasan si za daljnja putovanja :(!\n"");
        *flagForGameOver = 1;
    }
    return currentIsland;
}
islandPointer TravelToRightIsland(int* currentAmountOfCoins, int* numberOfFoundClues, islandPointer start, islandPointer currentIsland, stackPointer stackHead, int* flagForGameOver)
{
    islandPointer parentIsland = currentIsland;
    if (HaveEnoughCoins(*currentAmountOfCoins, currentIsland->rightNext->coins))
    {
        *currentAmountOfCoins = SpendCoins(*currentAmountOfCoins, currentIsland->rightNext->coins);
        currentIsland = currentIsland->rightNext;
        PushStack(currentIsland, stackHead);
        printf(""%s\n"", currentIsland->description);
        if (isClueIsland(currentIsland))
        {
            printf(""Trag je: %c\n"", currentIsland->clue);
            *numberOfFoundClues += 1;
        }
        else if (isDeathlyIsland(currentIsland, start))
        {
            if (HaveEnoughCoins(*currentAmountOfCoins, COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE))
            {
                char choice = RespawnPrint(*currentAmountOfCoins);
                system(""cls"");
                if (tolower(choice) == 'd')
                {
                    *currentAmountOfCoins = SpendCoins(*currentAmountOfCoins, COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE);
                    PrintCurrentPath(currentIsland, stackHead);
                    printf(""Status coina: %d\n"", *currentAmountOfCoins);
                    printf(""Uskrsnuo si!\n"");
                    currentIsland = TravelToPrevIsland(parentIsland, currentIsland, stackHead);
                }
                else
                {
                    currentIsland = TravelToStartIsland(start, currentIsland, stackHead);
                    *flagForGameOver = 1;
                }
            }
            else
            {
                currentIsland = TravelToStartIsland(start, currentIsland, stackHead);
                *flagForGameOver = 1;
            }
        }
        else
        {
            PrintCurrentPath(currentIsland, stackHead);
            currentIsland = TravelToPrevIsland(parentIsland, currentIsland, stackHead);
        }
    }
    else 
    {
        printf(""Nazalost presiromasan si za daljnja putovanja :(!\n"");
        *flagForGameOver = 1;
    }
    return currentIsland;
}
islandPointer TravelToPrevIsland(islandPointer parentIsland, islandPointer currentIsland, stackPointer stackHead)
{
    printf(""Vracamo se na prethodni otok: %s kako bi nastavio svoje putovanje u drugom smjeru\n"", parentIsland->islandName);
    PopStack(stackHead);
    currentIsland = parentIsland;
    return currentIsland;
}
islandPointer TravelToStartIsland(islandPointer start, islandPointer currentIsland, stackPointer stackHead)
{
    currentIsland = start;
    CleanStack(stackHead);
    return currentIsland;
}",60,1738,1470
"#define _CRT_SECURE_NO_WARNINGS 



typedef struct lista* pozicija;
struct lista {
    int el;
    pozicija next;
};
int unija(pozicija, pozicija, pozicija);
int presjek(pozicija, pozicija, pozicija);
int unosPrvi(pozicija);
int unosDrugi(pozicija);
int ispis(pozicija);
int main()
{
    struct lista Head1;
    struct lista Head2;
    struct lista HeadU;
    struct lista HeadP;
    Head1.next = NULL;
    Head2.next = NULL;
    HeadU.next = NULL;
    HeadP.next = NULL;
    unosPrvi(&Head1);
    unosDrugi(&Head2);
    printf(""Prva lista:\n"");
    ispis(Head1.next);
    printf(""Druga lista:\n"");
    ispis(Head2.next);
    unija(&Head1, &Head2, &HeadU);
    printf(""Ispis unije listi:\n"");
    ispis(HeadU.next);
    presjek(&Head1, &Head2, &HeadP);
    printf(""Ispis presjeka listi:\n"");
    ispis(HeadP.next);

    return 0;
}
int unija(pozicija p, pozicija q, pozicija r)
{
    while (p->next != NULL && q->next != NULL)
    {
        pozicija s = NULL;
        s = (pozicija)malloc(sizeof(struct lista));
        if (s == NULL)
        {
            printf(""Neuspjesna alokacija memorije!\n"");
            return 1;
        }
        s->next = NULL;
        if (p->next->el == q->next->el) 
        {
            s->el = p->next->el;
            p = p->next;
            q = q->next;
        }
        else if(p->next->el < q->next->el) 
        {
            s->el = p->next->el;
            p = p->next;
        }
        else
        {
            s->el = q->next->el;
            q = q->next;
        }
        r->next = s;
        r = s;
    }
    if (p->next == NULL) 
    {
        while (q->next != NULL)
        {
            pozicija s = NULL;
            s = (pozicija)malloc(sizeof(struct lista));
            if (s == NULL)
            {
                printf(""Neuspjesna alokacija memorije!\n"");
                return 1;
            }
            s->next = NULL;
            s->el = q->next->el;
            q = q->next;
            r->next = s;
            r = s;
        }
        
    }
    else 
    {
        while (p->next != NULL)
        {
            pozicija s = NULL;
            s = (pozicija)malloc(sizeof(struct lista));
            if (s == NULL)
            {
                printf(""Neuspjesna alokacija memorije!\n"");
                return 1;
            }
            s->next = NULL;
            s->el = p->next->el;
            p = p->next;
            r->next = s;
            r = s;
        }
        
    }
    
    return 0;
}
int presjek(pozicija p, pozicija q, pozicija r)
{
    while (p->next != NULL && q->next != NULL) 
    {
        if (p->next->el == q->next->el)
        {
            pozicija s = NULL;
            s = (pozicija)malloc(sizeof(struct lista));
            if (s == NULL)
            {
                printf(""Neuspjesna alokacija memorije!\n"");
                return 1;
            }
            s->next = NULL;
            s->el = p->next->el;
            p = p->next;
            q = q->next;
            r->next = s;
            r = s;
        }
        else if (p->next->el < q->next->el) 
            p = p->next;
        else
            q = q->next;
    }
    return 0;
}
int unosPrvi(pozicija p)
{
    FILE* fp = NULL;
    fp = fopen(""lista1.txt"", ""r"");
    if (fp == NULL)
    {
        printf(""Neuspjesno otvaranje datoteke!\n"");
        return 1;
    }
    while (!feof(fp))
    {
        pozicija q = NULL;
        q = (pozicija)malloc(sizeof(struct lista));
        if (q == NULL)
        {
            printf(""Neuspjesna alokacija memorije!\n"");
            return 1;
        }
        
        pozicija pret, temp;
        temp = p->next;
        pret = p;
        fscanf(fp, ""%d\n"", &q->el);
        while (temp != NULL)
        {
            pret = temp;
            temp = temp->next;
        }
        pret->next = q;
        if (temp != NULL)
            q->next = temp;
        else
            q->next = NULL;
    }
    return 0;
}
int unosDrugi(pozicija p)
{
    FILE* fp = NULL;
    fp = fopen(""lista2.txt"", ""r"");
    if (fp == NULL)
    {
        printf(""Neuspjesno otvaranje datoteke!\n"");
        return 1;
    }
    while (!feof(fp))
    {
        pozicija q = NULL;
        q = (pozicija)malloc(sizeof(struct lista));
        if (q == NULL)
        {
            printf(""Neuspjesna alokacija memorije!\n"");
            return 1;
        }
        pozicija pret, temp;
        temp = p->next;
        pret = p;
        fscanf(fp, ""%d\n"", &q->el);
        while (temp != NULL)
        {
            pret = temp;
            temp = temp->next;
        }
        pret->next = q;
        if (temp != NULL)
            q->next = temp;
        else
            q->next = NULL;
    }
    return 0;
}
int ispis(pozicija p)
{
    while (p != NULL)
    {
        printf(""Element liste je: %d\n"", p->el);
        p = p->next;
    }
    return 0;
}",60,1739,1700
"int main(int argc,char* argv[]){
    int rank,size,*a=NULL,*c=NULL;
    float res,*b=NULL;
    if(argc<1){
        printf(""Enter m as command line argument"");
        exit(EXIT_FAILURE);
    }
    MPI_Init(&argc,&argv);
    int m=atoi(argv[1]);
    MPI_Comm_size(MPI_COMM_WORLD,&size);
    MPI_Comm_rank(MPI_COMM_WORLD,&rank);
    a=(int*)malloc(m*size*sizeof(int));
    b=(float*)malloc(size*sizeof(float));
    c=(int*)malloc(m*sizeof(int));
    if(rank==0){
        printf(""Enter %d numbers.\n"",m*size);
        for(int i=0;i<m*size;i++)
            scanf(""%d"",&a[i]);
    }
    MPI_Scatter(a,m,MPI_INT,c,m,MPI_INT,0,MPI_COMM_WORLD);
    res=0;
    for(int i=0;i<m;i++){
        res+=c[i];
    }
    res/=m;
    printf(""Process[%d]: Average is %f\n"",rank,res);
    MPI_Gather(&res,1,MPI_FLOAT,b,1,MPI_FLOAT,0,MPI_COMM_WORLD);
    if(rank==0){
        res=0;
        for(int i=0;i<size;i++) res+=b[i];
        res/=size;
        printf(""Process[%d]: The overall average is %f\n"",rank,res);
    }
    MPI_Finalize();
    return 0;
}",61,1740,461
"struct Node
{
    int data;
    struct Node* left;
    struct Node* right;
};
struct Node* BSTInsert(struct Node** root,int data)
{
    if(!*root)
    {
        struct Node* newNode=(struct Node*)malloc(sizeof(struct Node));
        newNode->data=data;
        newNode->left=NULL;
        newNode->right=NULL;
        return newNode;
    }
    else
    {
        if((*root)->data>data)
        {
            (*root)->left=BSTInsert(&((*root)->left),data);
        }
        else if((*root)->data<data)
        {
            (*root)->right=BSTInsert(&((*root)->right),data);
        }
        else
        {
            printf(""The element already exists in the BST\n"");
        }
    }
    return *root;
    
}
void inorder(struct Node* root)
{
    if(!root)
        return;
    inorder(root->left);
    printf(""%d "",root->data);
    inorder(root->right);
    return;
}
void preorder(struct Node* root)
{
    if(!root)
        return;
    printf(""%d "",root->data);
    preorder(root->left);
    preorder(root->right);
    return;
}
void postorder(struct Node* root)
{
    if(!root)
        return;
    postorder(root->left);
    postorder(root->right);
    printf(""%d "",root->data);
    return;
}
int main()
{
    int n;
    int k;
    struct Node* root=NULL;
    printf(""Please enter the number of nodes you want to insert\n"");
    scanf(""%d"",&n);
    printf(""Please enter the elements\n"");
    for(int i=0;i<n;i++)
    {
        scanf(""%d"",&k);
        root=BSTInsert(&root,k);
    }
    inorder(root);
    printf(""\n"");
    preorder(root);
    printf(""\n"");
    postorder(root);
    printf(""\n"");
    return 0;
}",61,1741,544
"t


int main(int argc,char* argv[]){
    int rank,size,num;
    char st[10];
    char res[10];
    MPI_Init(&argc,&argv);
    MPI_Comm_rank(MPI_COMM_WORLD,&rank);
    MPI_Comm_size(MPI_COMM_WORLD,&size);
    if(size!=4){
        printf(""\nUse 4 processes\n"");
        MPI_Abort(MPI_COMM_WORLD,EXIT_FAILURE);
    }
    if(rank==0){
        printf(""\nProcess[%d]: Sending numbers\n"",rank);
        num=1;
        MPI_Send(&num,1,MPI_INT,1,0,MPI_COMM_WORLD);
        num=2;
        MPI_Send(&num,1,MPI_INT,2,0,MPI_COMM_WORLD);
        num=3;
        MPI_Send(&num,1,MPI_INT,3,0,MPI_COMM_WORLD);
        
    }else{
        MPI_Recv(&num,1,MPI_INT,0,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);
        printf(""\nProcess[%d]: Received %d\n"",rank,num);
    }
    MPI_Finalize();
    return 0;
}",61,1742,361
"long fact(int a){
    if(a==0) return 1;
    return a*fact(a-1);
}

int main(int argc,char* argv[]){
    int rank,size,*a=NULL,c;
    long res,*b=NULL;
    MPI_Init(&argc,&argv);
    MPI_Comm_size(MPI_COMM_WORLD,&size);
    MPI_Comm_rank(MPI_COMM_WORLD,&rank);
    a=(int*)malloc(size*sizeof(int));
    b=(long*)malloc(size*sizeof(long));
    if(rank==0){
        printf(""Enter %d numbers.\n"",size);
        for(int i=0;i<size;i++)
            scanf(""%d"",&a[i]);
    }
    MPI_Scatter(a,1,MPI_INT,&c,1,MPI_INT,0,MPI_COMM_WORLD);
    res=fact(c);
    printf(""Process[%d]: Factorial of %d is %ld\n"",rank,c,res);
    MPI_Gather(&res,1,MPI_LONG,b,1,MPI_LONG,0,MPI_COMM_WORLD);
    if(rank==0){
        res=0;
        for(int i=0;i<size;i++) res+=b[i];
        printf(""Process[%d]: The sum of all factorials is %ld\n"",rank,res);
    }
    MPI_Finalize();
    return 0;
}",61,1743,396
"int power(int a,int b)
{
    int ans=1;
    for(int i=0;i<b;i++)
    {
        ans*=a;
    }
    return ans;
}
int main()
{
    int sieve[10000];
    for(int i=0;i<10001;i++)
    {
        sieve[i]=0;
    }
    sieve[1]=1;
    sieve[0]=1;
    int count=0;
    for(int i=2;i<10001;i++)
    {
        if(sieve[i]==0)
        {
            count+=1;
            for(int j=i*i;j<10001;j+=i)
            {
                sieve[j]=1;
            }
        }
    }
    int primes[count];
    int j=0;
    for(int i=0;i<10001;i++)
    {
        if(sieve[i]==0)
        {
            primes[j]=i;
            j+=1;
        }
    }
    
    int a[count];
    int b[count];
    int c,d;
    scanf(""%d %d"",&c,&d);
    int x,y;
    x=c;
    y=d;
    int count1=0;
    while(c>0)
    {
        int counts=0;
        while(c>0)
        {
            if(c%primes[count1]!=0)
            {
                a[count1]=counts;
                count1+=1;
                break;
            }
            else
            {
                c/=primes[count1];
                counts+=1;
            }
        }
        if(count1==count)
        {
            break;
        }
    }
    int count2=0;
    while(d>0)
    {
        int counts=0;
        while(d>0)
        {
            if(d%primes[count2]!=0)
            {
                b[count2]=counts;
                count2+=1;
                break;
            }
            else
            {
                d/=primes[count2];
                counts+=1;
            }
        }
        if(count2==count)
        {
            break;
        }
    }
    
    int pow;
    int gcd=1;
    for(int i=0;i<count;i++)
    {
        if(b[i]<a[i])
        {
            pow=b[i];
        }
        else
        {
            pow=a[i];
        }
        gcd*=(power(primes[i],pow));
    }
    printf(""The GCD is %d \n"",gcd);
    return 0;
}",61,1744,726
"int main(int argc,char* argv[]){
    int rank,size;
    char st[10];
    char res[10];
    MPI_Init(&argc,&argv);
    MPI_Comm_rank(MPI_COMM_WORLD,&rank);
    MPI_Comm_size(MPI_COMM_WORLD,&size);
    if(size!=2){
        printf(""\nUse 2 processes\n"");
        MPI_Abort(MPI_COMM_WORLD,EXIT_FAILURE);
    }
    if(rank==0){
        printf(""Enter string to toggle\n"");
        gets(st);
        printf(""\nProcess[%d]: Sending string %s\n"",rank,st);
        MPI_Ssend(st,9,MPI_CHAR,1,0,MPI_COMM_WORLD);
        MPI_Recv(res,9,MPI_CHAR,1,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);
        printf(""\nProcess[%d]: Received string %s\n"",rank,res);
    }else{
        MPI_Recv(st,9,MPI_CHAR,0,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);
        printf(""\nProcess[%d]: Received string %s\n"",rank,st);
    for(int i=0;i<strlen(st);i++){
        if(st[i]>='a'&&st[i]<='z') st[i]-=32;
        else if(st[i]>='A'&&st[i]<='Z') st[i]+=32;
    }
    printf(""\nProcess[%d]: Sending string %s\n"",rank,st);
        MPI_Ssend(st,9,MPI_CHAR,0,0,MPI_COMM_WORLD);
    }
    MPI_Finalize();
    return 0;
}",61,1745,494
"struct adjLNode
{
    int dest;
    struct adjLNode* next;

};
struct adjList
{
    struct adjLNode* head;
};
struct Graph
{
    int V;
    struct adjList* arr;
};
struct Graph* createGraph(int V)
{
    struct Graph* graph=(struct Graph*)malloc(sizeof(struct Graph));
    graph->V=V;
    graph->arr=(struct adjList*)malloc(V*sizeof(struct adjList));
    for(int i=0;i<V;i++)
    {
        graph->arr[i].head=NULL;
    }
    return graph;
}
void addEdge(struct Graph* graph,int src,int dst)
{
    struct adjLNode* newNode=(struct adjLNode*)malloc(sizeof(struct adjLNode));
    newNode->dest=dst;
    newNode->next=graph->arr[src].head;
    graph->arr[src].head=newNode;
    struct adjLNode* newNode2=(struct adjLNode*)malloc(sizeof(struct adjLNode));
    newNode2->dest=src;
    newNode2->next=graph->arr[dst].head;
    graph->arr[dst].head=newNode2;

}
void printGraph(struct Graph* graph)
{
    for(int i=0;i<graph->V;i++)
    {
        struct adjLNode* temp=graph->arr[i].head;
        printf(""The connected vertices to the vertex %d are- \n"",i);
        while(temp)
        {
            printf(""%d "",temp->dest);
            temp=temp->next;
        }
        printf(""\n"");
    }
}
int main()
{
    int V;
    printf(""Please enter the number of vertices to your graph\n"");
    scanf(""%d"",&V);
    struct Graph* graph=createGraph(V);
    int n;
    printf(""Please enter the number of Edges you want the graph to have\n"");
    scanf(""%d"",&n);
    for(int i=0;i<n;i++)
    {
        int src,dst;
        scanf(""%d %d"",&src,&dst);
        addEdge(graph,src,dst);
    }
    printGraph(graph);
    return 0;
}",61,1746,566
"int main(int argc, char* argv[])
{
    int rank,size;
    int res;
    int s;
    MPI_Init(&argc,&argv);
    MPI_Comm_size(MPI_COMM_WORLD,&size);
    MPI_Comm_rank(MPI_COMM_WORLD,&rank);
    char st[100];
    char st1[100];
    char* a=(char*)malloc(sizeof(char)*100);
    char* b=(char*)malloc(100*sizeof(char));
    char* c=(char*)malloc(199*sizeof(char));
    char* fst=(char*)malloc(sizeof(char)*200);
    if(rank==0)
    {
        scanf(""%s"",st);
        int k=strlen(st);
        if(k%size!=0)
        {
            printf(""String length should be divisible by the number of processes."");
            return 0;
        }
        s=k/size;
        scanf(""%s"",st1);
    }
    MPI_Bcast(&s,1,MPI_INT,0,MPI_COMM_WORLD);
    MPI_Scatter(st,s,MPI_CHAR,a,s,MPI_CHAR,0,MPI_COMM_WORLD);
    res=0;
    MPI_Scatter(st1,s,MPI_CHAR,b,s,MPI_CHAR,0,MPI_COMM_WORLD);
    for(int i=0;i<s;i++)
    {
        c[i*2]=a[i];
        c[i*2+1]=b[i];
    }
    MPI_Gather(c,2*s,MPI_CHAR,fst,2*s,MPI_CHAR,0,MPI_COMM_WORLD);
    if(rank==0)
    {
        printf(""%s\n"",fst);
    }   
    MPI_Finalize();
}   ",61,1747,502
"int main()
{
    char str[50],substr[50];
    int a,b,c,k=0,flag=0;
    clock_t t1,t2;

    printf(""\nEnter a string: "");
    scanf(""%[^\n]%*c"",str);

    printf(""\nEnter the substring to search: "");
    scanf(""%[^\n]%*c"",substr);

    t1=clock();
    int opcount=0;
    for (a=0;a<strlen(str);a++)
    {
        ++opcount;
        c=a;
        if (str[a]==substr[k])
        {
            for (b=0;b<=strlen(substr);b++)
            {
                ++opcount;
                if (b==strlen(substr))
                {
                    flag=1;
                    break;
                }
                if (str[c]==substr[b])
                    c++;             
                else if (str[c]!=substr[b])
                {
                    flag=0;
                    break;
                }             
            }
        }
        if ( flag==1 ) break;
    }
    t2=clock();
    printf(""\ntime taken is %ld\n"",(t2-t1));

    printf(""\nOpcount: %d"",opcount);
    if (flag==1)
        printf(""\nfound\n"");
    else 
        printf(""\nnot found\n"");
    
    return 0;

}
",61,1748,375
"int GCD(int a ,int b)
{
    int c;
    int opcount=0;
    if(b<a)
    {   
        a=a^b;
        b=a^b;
        a=a^b;
    }
    c=a;
    while(1)
    {
        opcount++;
        if(a%c==0 && b%c==0)
        {
            printf(""opcount: %d\n"",opcount);
            return c;
        }
        c-=1;
    }

}

int main()
{
    int a,b;
    scanf(""%d %d"",&a,&b);
    printf(""%d\n"",GCD(a,b));
    return 0;
}",61,1749,191
"#define FOR(i,a,b) for(ll i=a;i<b;i++)
typedef long long int ll;
struct Queue{
    int* arr;
    int front,rear;
    int cap,size;
};
struct Queue* createQueue(int cap)
{
    struct Queue* queue=(struct Queue*)malloc(sizeof(struct Queue));
    queue->front=-1;
    queue->rear=-1;
    queue->cap=cap;
    queue->size=0;
    queue->arr=(int*)malloc(cap*sizeof(int));
    return queue;
}
int isEmpty(struct Queue* queue)
{
    return (queue->size==0);
}
int isFull(struct Queue* queue)
{
    if (queue->size==queue->cap)
        return 1;
    return 0;
}
void enqueue(struct Queue* queue,int ele)
{
    if (isFull(queue))
    {
        
        return;
    }
    if (queue->front==-1)
    {
        queue->front=0;
    }
    queue->rear=(queue->rear+1)%queue->cap;
    queue->arr[queue->rear]=ele;
    queue->size++;
    
    return;
}
int dequeue(struct Queue* queue)
{
    if (isEmpty(queue))
        return -1;
    int ele=queue->arr[queue->front];
    if (queue->front==queue->rear)
    {
        queue->front=-1;
        queue->rear=-1;
    }
    queue->front=(queue->front+1)%queue->cap;
    queue->size--;
    return ele;
}
int** makeGraph(int v)
{
    int** graph=(int**)malloc(v*sizeof(int*));
    FOR(i,0,v)
    {
        graph[i]=(int*)malloc(v*sizeof(int));
    }
    FOR(i,0,v)
    {
        FOR(j,0,v)
        {
            graph[i][j]=0;
        }
    }
    int e;
    scanf(""%d"",&e);
    FOR(i,0,e)
    {
        int src, dest;
        scanf(""%d %d"",&src,&dest);
        graph[src][dest]=1;
        graph[dest][src]=1;
    }
    return graph;
}
void bfs(int** graph,int* visited,int v,int src)
{
    
    struct Queue* queue=createQueue(10000);
    enqueue(queue,src);
    int count=0;
    while(!isEmpty(queue))
    {
        
        int p=dequeue(queue);
        visited[p]=1;
        printf(""%d "",p);
        
        count+=1;
        FOR(i,0,v)
        {
            if(graph[p][i])
            {
                if(!visited[i])
                {
                    
                    enqueue(queue,i);
                }
            }
        }
    }
    return;
}
int main()
{
    int v;
    scanf(""%d"",&v);
    int** graph=makeGraph(v);
    int* visited=(int* )malloc(v*sizeof(int));\
    FOR(i,0,v)
        visited[i]=0;
    
    FOR(i,0,v)
    {
        if(!visited[i])
        {
            bfs(graph,visited,v,i);
            printf(""\n"");
        }
    }
    return 0;
}",61,1750,913
"#define FOR(i,a,b) for(ll i=a;i<b;i++)
typedef long long int ll;
ll** makeGraph(ll v)
{
    ll e;
    ll** graph=(ll**)malloc(v*sizeof(ll*));
    FOR(i,0,v)
    {
        graph[i]=malloc(v*sizeof(ll));
    }
    FOR(i,0,v)
    {
        FOR(j,0,v)
        {
            graph[i][j]=0;
        }
    }
    scanf(""%lld"",&e);
    ll src,dest;
    FOR(i,0,e)
    {
        scanf(""%lld %lld"",&src,&dest);
        graph[src][dest]=1;
        graph[dest][src]=1;
    }
    return graph;
}
void dfs(ll** graph, ll* visited, ll v, ll src)
{
    visited[src]=1;
    printf(""%lld "",src);
    
    FOR(i,0,v)
    {
        if(graph[src][i])
        {
            if(!visited[i])
            {
                dfs(graph,visited,v,i);
            }
        }
    }
    return;
}
int main()
{
    ll v;
    scanf(""%lld"",&v);
    ll** graph=makeGraph(v);
    ll* visited=(ll*)malloc(v*sizeof(ll));
    FOR(i,0,v)
    {
        visited[i]=0;
    }
    FOR(i,0,v)
    {
        if(!visited[i])
        {
            dfs(graph,visited,v,i);
            printf(""\n"");
        }
    }
    return 0;

}",61,1751,456
"int main(int argc, char* argv[])
{
    int rank, size;
    int k;
    int buff_size=MPI_BSEND_OVERHEAD+sizeof(int);
    char* buff=(char*)malloc(buff_size*sizeof(int));
    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD,&rank);
    MPI_Comm_size(MPI_COMM_WORLD,&size);
    int arr[7];
    if(size!=8)
    {
        printf(""\nUse 8 processes\n"");
        MPI_Abort(MPI_COMM_WORLD,EXIT_FAILURE);
    }
    if(rank==0)
    {
        MPI_Buffer_attach(buff,buff_size);
        printf(""Please enter 7 integers.\n"");
        for(int i=0;i<7;i++)
        {
            scanf(""%d"",&arr[i]);
        }
        printf(""Process[%d] sending the elements.\n"",rank);
        for(int i=1;i<8;i++)
        {
            MPI_Bsend(&arr[i-1],1,MPI_INT,i,0,MPI_COMM_WORLD);
        }
    }
    else
    {
        MPI_Recv(&k,1,MPI_INT,0,0,MPI_COMM_WORLD, MPI_STATUS_IGNORE);
        if(rank%2==0)
        {
            printf(""Process[%d] recieved: %d and the square is: %d \n"",rank, k,k*k);
        }
        else
        {
            printf(""Process[%d] recieved: %d and the cube is: %d \n"",rank, k,k*k*k);
        }
    }
    MPI_Buffer_detach(buff, &buff_size);
    MPI_Finalize();
}",61,1752,489
"typedef struct Node* nptr;
typedef struct Node
{
    nptr llink;
    nptr rlink;
    int ele;
}node;

nptr createNode()
{
    nptr temp = (nptr)malloc(sizeof(node));
    temp->llink = temp;
    temp->rlink = temp;
    return temp;
}

void insert(nptr list,int x)
{
    nptr temp = createNode();
    temp->ele = x;

    temp-> llink = list;
    temp-> rlink = list -> rlink;
    list -> rlink = temp;
    (temp -> rlink) -> llink = temp;
}

nptr getnum(char num[50])
{
    nptr head = createNode();

    for(int i = strlen(num) - 1 ; i >= 0 ; i--)
        insert(head, num[i] - '0');

    return head;
}

nptr add(nptr num1, nptr num2)
{
    nptr sum = createNode();
    nptr n1 = num1 -> llink;
    nptr n2 = num2 -> llink;

    int cin = 0;
    int s = 0;

    while(n1 != num1 && n2 != num2)
    {
        s = (n1 -> ele) + (n2 -> ele) + cin;

        if(s >= 10)
        { 
            cin = 1;
            insert(sum, s - 10);
        }
        else
        {
            cin = 0;
            insert(sum, s);
        }

        n1 = n1 -> llink;
        n2 = n2 -> llink;
    }
    
    while(n1 != num1)
    {
        s = (n1 -> ele) + cin;
        
        if(s > 9)
        { 
            cin = 1; 
            insert(sum, s - 10);
        }
        else 
        {
            cin = 0; 
            insert(sum, s);
        }
        
        n1 = n1 -> llink;
    }
    
    while(n2 != num2)
    {
        s = (n2 -> ele) + cin;
        
        if(s > 9)
        { 
            cin = 1; 
            insert(sum, s - 10);
        }
        else 
        {
            cin = 0; 
            insert(sum, s);
        }
        
        n2 = n2 -> llink;
    }

    return sum;
}

void disp(nptr list)
{
    nptr i = list -> rlink;
    
    while(i != list)
    {
        printf(""%d"", i -> ele);
        i = i -> rlink;
    }
    
    printf(""\n"");
}

int main()
{
    char num1[50],num2[50];
    
    printf(""Enter the first number: "");
    scanf(""%s"",num1);
    printf(""Enter the second number: "");
    scanf(""%s"",num2);

    nptr n1 = getnum(num1);
    nptr n2 = getnum(num2);
    
    
    
    
    nptr sum = add(n1,n2);
    
    printf(""The sum of the given numbers is "");
    disp(sum);
}",62,1753,860
"typedef struct Node* nptr;
typedef struct Node
{
    nptr llink;
    nptr rlink;
    int ele;
}node;

nptr createNode(int x)
{
    nptr temp=(nptr)malloc(sizeof(node));
    temp->ele=x;
    temp->llink=NULL;
    temp->rlink=NULL;
    return temp;
}

void insertst(nptr* start,nptr* end,int x)
{
    nptr temp=createNode(x);

    if(!*start)
    {
        *start=temp;
        *end=temp;
    }
    else
    {
        temp->rlink=*start;
        (*start)->llink=temp;
        *start=temp;
    }
}

void inserten(nptr* start,nptr* end,int x)
{
    nptr temp=createNode(x);
    
    if(!*end)
    {
        *start=temp; *end=temp; 
        return;
    }
    else
    {
        (*end)->rlink=temp;
        temp->llink=*end;
        *end=temp;
    }
}

int delst(nptr* start,nptr* end)
{
    if(!*start)
    {
        printf(""Underflow!!\n""); 
        return -99;
    }
    
    nptr temp; int x;
    temp=*start;
    x=temp->ele;
    
    if(!((*start)->rlink))
    {
        *end=*start=NULL;
        free(temp);
        return x;
    }
    
    *start=(*start)->rlink;
    (*start)->llink=NULL;

    free(temp);
    return x;
}

int delen(nptr* start,nptr* end)
{
    if(!*end)
    {
        printf(""Underflow!!\n""); 
        return -99;
    }
    
    nptr temp; int x;
    temp=*end;
    x=temp->ele;
    
    if(!((*end)->llink))
    {
        *end=*start=NULL;
        free(temp);
        return x;
    }
    
    *end=(*end)->llink;
    (*end)->rlink=NULL;
    
    free(temp);
    return x;
}

void disp(nptr front)
{
    printf(""NULL <--->"");
    for(nptr i=front;i;i=i->rlink)
        printf("" %d <---> "",i->ele);
    
    printf(""NULL \n"");
}

int main()
{
    printf(""1:Insert@start 2:Insert@end 3:Delete@start\n4:Delete@end 5:Display 6:Exit\n"");
    int i=1,ch,ele;
    
    nptr start=NULL,end=NULL;
    
    while(i)
    {
        printf(""Command: ""); 
        scanf(""%d"",&ch);
        
        switch(ch)
        {
            case 1:
                    printf(""Enter element to insert: "");
                    scanf(""%d"",&ele);
                    insertst(&start,&end,ele);
                    break;
            
            case 2:
                    printf(""Enter element to insert: "");
                    scanf(""%d"",&ele);
                    inserten(&start,&end,ele);
                    break;
            
            case 3:
                    ele=delst(&start,&end);
                    if(ele!=-99) 
                        printf(""Deleted %d\n"",ele);
                    break;
            
            case 4:
                    ele=delen(&start,&end);
                    if(ele!=-99) 
                        printf(""Deleted %d\n"",ele);
                    break;
            
            case 5:
                    disp(start);
                    break;
            
            case 6:
                    i=0; break;
        }

    }
}",62,1754,1022
"void postorder(node *t)     
{ 
    STACK s;
    node*curr;
    curr=t;
    s.tos=-1;

    do
    { 
        while (curr!=NULL) 
        { 
            if (curr->right!=NULL) 
                push(&s, curr->right); 
            
            push(&s, curr); 
            curr=curr->left; 
        } 
        
        curr = pop(&s); 
        
        if (curr->right!=NULL && s.s[s.tos]==curr->right) 
        { 
            pop(&s); 
            push(&s,curr);
            curr=curr->right;
        } 
        
        else 
        { 
            printf(""%d\t"",curr->data); 
            curr=NULL; 
        } 
    
    }while (s.tos!=-1); 
}",62,1755,227
"typedef struct node* nodePointer;
typedef struct node
{
    int data;
    nodePointer link;
}node;

typedef struct
{
    nodePointer front;
    nodePointer rear;
}queue;

void init(queue* q)
{
    q->front=NULL;
    q->rear=NULL;
}

void queueFull()
{
    fprintf(stderr,""Queue Full"");
    exit(EXIT_FAILURE);
}

int queueEmpty()
{
    return -1;
}

void insert(queue* q,int x)
{
    node* temp;

    if(q->front==NULL)
    {
        temp=(nodePointer)malloc(sizeof(node));
        temp->data=x;
        temp->link=NULL;
        q->front=temp;
        q->rear=temp;
    }

    else
    {
        temp=(nodePointer)malloc(sizeof(node));
        temp->data=x;
        temp->link=NULL;
        q->rear->link=temp;
        q->rear=temp;
    }
}

int deletee(queue* q)
{
    int temp;
    node* t;

    if(q->front==NULL)
        return queueEmpty();
    
    else if(q->front==q->rear)
    {
        temp=q->front->data;
        init(q);
    }
    
    else
    {
        temp=q->front->data;
        t=q->front;
        q->front=q->front->link;
        free(t);
    }
    
    return temp;
}

void display(queue* q)
{
    queue temp;
    init(&temp);
    int i;

    while(q->front!=NULL)
    {
        i=deletee(q);
        printf("" %d --> "",i);
        insert(&temp,i);
    }

    printf("" NULL\n"");

    
    *q=temp;
}

int main()
{
    queue q;
    int opt ,ele;

    printf(""\n1. Insert \n2. Delete \n3. Display \n4. Exit"");
    
    printf(""\nEnter option: "");
    scanf(""%d"",&opt);
    
    init(&q);
    
    while(opt!=4)
    {
        switch(opt)
        {
            case 1:
            {
                printf(""\nEnter element: "");
                scanf(""%d"",&ele);
                insert(&q,ele);
                break;
            }
            
            case 2:
            {
                printf(""\nYou have deleted %d"",deletee(&q));
                break;
            }
            
            case 3:
            {
                display(&q);
                break;
            }
        }
        printf(""\nEnter option: "");
        scanf(""%d"",&opt);
    }
    return 0;
}           ",62,1756,732
"typedef struct node* nptr;
typedef struct node
{
    nptr next;
    int data;
}node;

nptr reverse(nptr head)
{
    if (head -> next == NULL)
        return head; 

    nptr newList = reverse(head -> next);
    head -> next = NULL;

    nptr temp = newList;

    while(temp -> next != NULL)
        temp = temp -> next;

    temp -> next = head;

    return newList;
}

nptr reverse2(nptr head)
{
    if(head -> next == NULL)
        return head;

    nptr prev = NULL; 
    nptr curr = head;
    nptr after = head -> next;


    while(curr)
    {
        after = curr -> next;
        curr -> next = prev;
        
        prev = curr;
        curr = after;
    }

    return prev;
}

nptr createNode(int x)
{
    nptr temp = (nptr)malloc(sizeof(node));
    temp -> data = x;
    temp -> next = NULL;

    return temp;
}

void insertFront(nptr &head, int ele)
{
    nptr temp = createNode(ele);
    temp -> next = head;

    head = temp;
}

void insertRear(nptr &head, int ele)
{
    if (head == NULL)
    {
        head = createNode(ele);
        return;
    }

    nptr rear = head;
    
    while(rear -> next != NULL)
        rear = rear -> next;

    nptr temp = createNode(ele);
    rear -> next = temp;
}

int deleteFront(nptr &head)
{
    if (head == NULL)
        return -1;

    nptr temp = head;
    head = head -> next;

    int x = temp -> data;
    free(temp);
    return x;
}

int deleteRear(nptr &head)
{
    if (head == NULL)
        return -1;

    nptr rear2 = head;
    nptr rear = head -> next;

    while(rear -> next != NULL)
    {
        rear2 = rear2 -> next;
        rear = rear -> next;
    }

    rear2 -> next = rear2 -> next -> next;
    int x = rear -> data;

    free(rear);
    return x;
}

void display(nptr &head)
{
    nptr temp = head;

    while(temp != NULL)
    {
        printf(""%d --> "", temp -> data);
        temp = temp -> next;
    }

    printf(""NULL\n"");
}

int main()
{
    printf(""1. Insert Front   2. Insert Rear   3. Delete Front   4. Delete Rear   5. Display   6. Reverse 7. Reverse2   0. Exit\n"");
    int ch, ele;

    nptr head = NULL;

    do
    {
        printf(""Command: ""); scanf(""%d"", &ch);

        switch(ch)
        {
            case 1:     
                    printf(""Element: ""); scanf(""%d"", &ele);
                    insertFront(head, ele);
                    break;

            case 2:
                    printf(""Element: ""); scanf(""%d"", &ele);
                    insertRear(head, ele);
                    break;
            
            case 3: ele = deleteFront(head);
                    
                    if(ele == -1)
                        printf(""List empty!\n"");
                    else
                        printf(""%d removed\n"", ele);
                        
                    break;

            case 4: ele = deleteRear(head);
                    
                    if(ele == -1)
                        printf(""List empty!\n"");
                    else
                        printf(""%d removed\n"", ele);
                        
                    break;

            case 5: display(head);
                    break;

            case 6: head = reverse(head);
                    break; 
            
            case 7: head = reverse2(head);
                    break;
        }

    }while(ch != 0);
}",62,1757,1056
"typedef struct node* nodeptr;

typedef struct node
{
    int data;
    nodeptr link;
}node;



void add(nodeptr* head,int x)
{
    nodeptr temp=(nodeptr)malloc(sizeof(node));
    nodeptr t;

    temp->data=x;
    temp->link=NULL;

    if(!(*head))
        *head=temp;
    
    else
    {
        for(t=(*head);t->link;t=t->link);
        
        t->link=temp;
    }
}

nodeptr set_union(nodeptr a,nodeptr b)
{
    int i,flag=1;
    
    nodeptr c,at,bt;
    c=NULL;
    at=a;
    bt=b;

    for(;at;at=at->link)
        add(&c,at->data);

    at=a;

    for(;bt;bt=bt->link)
    {
        for(;at;at=at->link)          
            if(bt->data==at->data)
            {
                flag=0;
                break;
            }

        if(flag)                    
            add(&c,bt->data);                       
    
        flag=1;
        at=a;
    }
    
    return c;
}

nodeptr intersection(nodeptr a,nodeptr b)
{
    nodeptr c,at;
    at=a;
    c=NULL;

    for(;b;b=b->link)
    {
        for(;at;at=at->link)
            if(b->data==at->data)
            {
                add(&c,b->data);
                break;
            }

        at=a;
    }
    
    return c;
}

void display(nodeptr a)
{
    printf(""\n"");

    for(;a;a=a->link)
        printf(""%d --> "",a->data);

    printf(""NULL\n"");
}

int main()
{
    nodeptr a,b;
    int n,m,i,t;

    a=NULL;
    b=NULL;

    printf(""\nEnter number elements of first set: "");
    scanf(""%d"",&n);

    printf(""\nEnter elements: "");
    for(i=0;i<n;i++)
    {
        scanf(""%d"",&t);
        add(&a,t);
    }
    
    printf(""\nEnter number elements of second set: "");
    scanf(""%d"",&m);
    
    printf(""\nEnter elements: "");
    for(i=0;i<m;i++)
    {
        scanf(""%d"",&t);
        add(&b,t);
    }
    
    printf(""\nList one: "");
    display(a);
    printf(""\nList two: "");
    display(b);

    nodeptr u,in;
    
    u=set_union(a,b);
    in=intersection(a,b);
    
    printf(""\nUnion: "");
    display(u);
    printf(""\nIntersection: "");
    display(in);
}",62,1758,792
"#define MAX 40
typedef enum {True=1,False=0} Ans;
typedef struct 
{
    int arr[MAX];
    int front,rear;
}QUEUE;
void init(QUEUE* q)
{
    q->front=-1;
    q->rear=-1;
}
void add(int e,QUEUE* q)
{
    if(q->rear==MAX-1)
    {
        printf(""QUEUE FULL\n"");
        return;
    }
    q->rear+=1;
    q->arr[q->rear]=e;
}
int del(QUEUE* q)
{
    if(q->front==q->rear)
    {
        printf(""QUEUE EMPTY\n"");
        return -1;
    }
    q->front+=1;
    return q->arr[q->front];
}
Ans find(QUEUE* q,int e)
{
    QUEUE q1;
    QUEUE* nq=&q1;
    int num;
    Ans f=False;
    init(nq);
    while(q->front!=q->rear)
    {
        num=del(q);
        if(num==e)
        {
            f=True;
            add(num,nq);
        }
        else
            add(num,nq);
    }
    while(nq->front!=nq->rear)
    {
        add(del(nq),q);
    }
    return f;
}
void display(QUEUE* q)
{
    int i;
    for(i=q->front+1;i<=q->rear;i=i+1)
        printf(""%d\t"",q->arr[i]);
    printf(""\n"");
}
int main()
{
    QUEUE q;
    QUEUE* q1=&q;
    init(q1);
    add(1,q1);
    add(2,q1);
    add(3,q1);
    add(4,q1);
    add(5,q1);
    add(6,q1);
    add(7,q1);
    if(find(q1,9))
        printf(""Found\n"");
    else
        printf(""Not Found\n"");
    if(find(q1,5))
        printf(""Found\n"");
    else
        printf(""Not Found\n"");
    display(q1);
}",62,1759,610
"void main () {

    struct sockaddr_in seradd;
    int len = sizeof(seradd);

    seradd.sin_family = AF_INET;
    seradd.sin_port = 5555;
    seradd.sin_addr.s_addr = inet_addr(""172.16.57.152"");

    int fd = socket(AF_INET, SOCK_STREAM, 0);
    printf(""Socket fd: %d \n"", fd);

    if (connect(fd, (struct sockaddr*)&seradd, len) == -1) {
        printf(""Connect error! %d\n"" , errno);
        exit(0);
    } else {
        printf(""Connected\n"");
    }

    char c = 'a';

    write(fd, &c, 1);

    char msg[100];

    read(fd, msg, 100);

    printf(""Server: %s\n"", msg);

}",62,1760,256
"#define size 5

typedef struct
{
    char queue[size];
    int front;
    int rear;

}que;

void insertq(que* pq, int item)
{
    if ((pq->front == 0 && pq->rear == size - 1) || (pq->front == pq->rear + 1))
    {
        printf(""queue is full"");
        return;
    }

    else if (pq->rear ==  -1)
    {
        pq->rear++;
        pq->front++;
    }

    else if (pq->rear == size - 1 && pq->front > 0)
    {
        pq->rear = 0;
    }

    else
    {
        pq->rear++;
    }

    pq->queue[pq->rear] = item;
}

void display(que* pq)
{
    int i;
    printf(""\n"");

    if (pq->front ==  -1)
    {
        printf(""Queue is empty"");
        return;
    }

    if (pq->front > pq->rear)
    {
        for (i = pq->front; i < size; i++)
            printf(""%d "", pq->queue[i]);
        
        for (i = 0; i <= pq->rear; i++)
            printf(""%d "", pq->queue[i]);
    }

    else
    {
        for (i = pq->front; i <= pq->rear; i++)
            printf(""%d "", pq->queue[i]);
    }
}

void deleteq(que* pq)
{
    if (pq->front ==  -1)
        printf(""Queue is empty"");
    
    else if (pq->front == pq->rear)
    {
        printf(""\n%d deleted"", pq->queue[pq->front]);
        pq->front =  -1;
        pq->rear =  -1;
    }

    else if (pq->front == size-1) 
    {
        printf(""\n%d deleted"", pq->queue[pq->front]);
        pq->front = 0;
    }
    
    else
        printf(""\n%d deleted"", pq->queue[(pq->front)++]);

}

int main()
{
    int n, ch;
    que q;

    q.front = q.rear = -1;

    do
    {
        printf(""\nCircular Queue:\n1. Insert \n2. Delete\n3. Display\n0. Exit"");
        printf(""\nEnter Choice 0-3? : "");
        scanf(""%d"", &ch);

        switch (ch)
        {
            case 1:
                printf(""\nEnter number: "");
                scanf(""%d"", &n);
                insertq(&q, n);
                break;

            case 2:
                deleteq(&q);
                break;

            case 3:
                display(&q);
                break;
        }

    }while (ch != 0);
}",62,1761,786
"void insertNode(nptr root, int x, char path[])
{
    int i = 0;
    nptr parent = NULL, curr = root;

    while(curr && path[i])
    {
        parent = curr;

        if (path[i] == 'L')
            curr = parent -> lchild;
        else if (path[i] == 'R')
            curr = parent -> rchild;

        i++;
    }

    if (curr == NULL || path[i] == '\0')
    {
        if (path[i - 1] == 'R')
            parent -> rchild = createNode(x);
        else if (path[i - 1] == 'L')
            parent -> lchild = createNode(x);
    }
    else
        printf(""Path error!"");
}

nptr createBT()
{
    int x;    printf(""Insert Element: "");    scanf(""%d"", &x);

    if(x == -1)
        return NULL;

    nptr temp = createNode(x);
    temp -> lchild = createBT();
    temp -> rchild = createBT();
    return temp;
}",62,1762,285
"int main()
{
    int rowNum;
    printf(""Enter no. of rows:"");
    scanf(""%d"", &rowNum);

    int **table = calloc(rowNum, sizeof(int*));

    int total = 0;

    for(int i = 0 ; i < rowNum ; i++)
    {
        int colSize;
        printf(""Enter no. of columns of %dth row: "", i + 1);
        scanf(""%d"", &colSize);

        table[i] = calloc(colSize + 1, sizeof(int));

        table[i][0] = colSize;  

        printf(""Enter %d elements: "", colSize);
        for(int j = 1 ; j <= table[i][0] ; j++)
            scanf(""%d"", &table[i][j]);

        total += colSize;
    }

    int temp[total];
    int k = 0;

    for(int i = 1 ; i <= table[rowNum - 1][0] ; i++) 
        temp[k++] = table[rowNum - 1][i];

    for(int a = 0 ; a < rowNum - 1 ; a++)
    {
        int colSize = table[a][0];

        for(int i = 1 ; i <= colSize ; i++)
            temp[k++] = table[a][i];
    }

    for(int i = 0 ; i < rowNum - 1; i++)
        table[i][0] = 0;

    table[rowNum - 1] = malloc((total + 1) * sizeof(int));
    table[rowNum - 1][0] = total;

    for(int i = 1; i <= total; i++)
        table[rowNum - 1][i] = temp[i - 1];


    for(int i = 0 ; i < rowNum ; i++)
    {
        int colSize = table[i][0];

        if(colSize == 0)
        {
            printf(""NULL\n"");
            continue;
        }

        for(int j = 0 ; j <= colSize ; j++)
            printf(""%d\t"", table[i][j]);

        printf(""\n"");

        free(table[i]);
    }

    free(table);
}",62,1763,578
"#define size 5

typedef struct
{
    char* queue[size];
    int front;
    int rear;

}que;

void insertq(que* pq, char* item)
{
    if ((pq->front == 0 && pq->rear == size - 1) || (pq->front == pq->rear + 1))
    {
        printf(""queue is full"");
        return;
    }

    else if (pq->rear ==  -1)
    {
        pq->rear++;
        pq->front++;
    }

    else if (pq->rear == size - 1 && pq->front > 0)
    {
        pq->rear = 0;
    }

    else
    {
        pq->rear++;
    }

    pq->queue[pq->rear] = item;
}

void display(que* pq)
{
    int i;
    printf(""\n"");

    if (pq->front ==  -1)
    {
        printf(""Queue is empty"");
        return;
    }

    if (pq->front > pq->rear)
    {
        for (i = pq->front; i < size; i++)
            printf(""%s\n"", pq->queue[i]);
        
        for (i = 0; i <= pq->rear; i++)
            printf(""%s\n"", pq->queue[i]);
    }

    else
    {
        for (i = pq->front; i <= pq->rear; i++)
            printf(""%s\n"", pq->queue[i]);
    }
}

void deleteq(que* pq)
{
    if (pq->front ==  -1)
        printf(""Queue is empty"");
    
    else if (pq->front == pq->rear)
    {
        printf(""\n%s deleted"", pq->queue[pq->front]);
        pq->front =  -1;
        pq->rear =  -1;
    }

    else if (pq->front == size - 1) 
    {
        printf(""\n%s deleted"", pq->queue[pq->front]);
        pq->front = 0;
    }
    
    else
        printf(""\n%s deleted"", pq->queue[(pq->front)++]);

}

int main()
{
    int ch;
    que q;

    q.front = q.rear = -1;

    do
    {
        printf(""\nCircular Queue:\n1. Insert \n2. Delete\n3. Display\n0. Exit"");
        printf(""\nEnter Choice 0-3? : "");
        scanf(""%d"", &ch);

        switch (ch)
        {
            case 1:
                printf(""\nEnter String: "");
                
                char *n = malloc(30);
                scanf(""%s"", n);

                insertq(&q, n);
                break;

            case 2:
                deleteq(&q);
                break;

            case 3:
                display(&q);
                break;
        }

    }while (ch != 0);
}",62,1764,806
"typedef struct
{
    int c[20];
    int front;
    int rear;
}queue;
void enqueue(queue *q,int n)
{
    if (q->rear==20)
        printf(""Queue Full\n"");
    else
    {
        int i,j,t;
        q->c[(q->rear)++]=n;
        for (i=0;i<q->rear-1;i++)
        {
            for (j=0;j<q->rear-i-1;j++)
            {
                if (q->c[j]>q->c[j+1])
                {
                    t=q->c[j];
                    q->c[j]=q->c[j+1];
                    q->c[j+1]=t;
                }
            }
        }
    }
}
int dequeue(queue *q)
{
    if (q->front==q->rear)
    {
        printf(""Queue Empty"");
        return -1;
    }
    else
        return q->c[--(q->rear)];
}
void display(queue *q)
{
    int i;
    for (i=q->front;i<q->rear;i++)
        printf(""%d\t"",q->c[i]);
    printf(""\n"");
}
int main()
{
    int z=0,k,e;
    queue q;
    q.front=0;
    q.rear=0;
    while (z==0)
    {
        printf(""1. Enqueue \t4. Dequeue \t5. Display \t6. Exit\n"");
        scanf(""%d"",&k);
        switch(k)
        {
            case 1:
            {
                scanf(""%d"",&e);
                enqueue(&q,e);
                break;
            }
            case 2:
            {
                break;
            }
            case 3:
            {
                break;
            }
            case 4:
            {
                printf (""%d\n"",dequeue(&q));
                break;
            }
            case 5:
            {
                display(&q);
                break;
            }
            case 6:
            {
                z=1;
            }
        }
    }
}",62,1765,574
"#include ""charStack.h""



int toInt(char c)
{
    return c - '0';
}

int main()
{
    stack s;
    char exp[15];

    printf(""Enter exp: "");
    scanf(""%s"", exp);

    for(int i = 0 ; exp[i] != '\0' ; i++)
    {
        char token = exp[i];

        if (token >= '0' && token <= '9')
            push(&s, token);
        
        else
        {
            char b = pop(&s);
            char a = pop(&s);

            switch(token)
            {
                case '+':   push(&s, toInt(a) + toInt(b) + '0');
                            break;

                case '-':   push(&s, toInt(a) - toInt(b) + '0');
                            break;

                case '/':   push(&s, toInt(a) / toInt(b) + '0');
                            break;

                case '*':   push(&s, toInt(a) * toInt(b) + '0');
                            break;
            }

        }
    }

    printf(""Ans = %d \n"", toInt(pop(&s)));
}
",62,1766,321
"#define MAX 10

typedef struct node
{
    int data;
    struct node *left;
    struct node *right;
} node;

node* create()
{
    node *p;
    
    int x;
    printf(""Enter data(-1 for no data):"");
    scanf(""%d"", &x);

    if (x == -1)
        return NULL;

    p = (node*)malloc(sizeof(node));
    p->data = x;

    printf(""Enter left child of %d:\n"", x);
    p->left = create();

    printf(""Enter right child of %d:\n"", x);
    p->right = create();
    
    return p;
}

void inorder(node *t)
{
    if (t == NULL)
        return;

    inorder(t->left);
    printf(""%d "", t->data);
    inorder(t->right);
}

node* copy(node *t)
{
    node *p;

    if (t == NULL)
        return NULL;

    p = (node*)malloc(sizeof(node));
    p->data = t->data;

    p->left = copy(t->left);
    p->right = copy(t->right);

    return p;
}

int Equal(node* root1, node* root2)
{
    return  (root1 == NULL && root2 == NULL) || ((root1 && root2 && root1 -> data == root2 -> data)
            && Equal(root1->left, root2->left) && Equal(root1->right, root2->right));
}

int main()
{
    node *root, *c;
    root = create();
    c = copy(root);

    printf(""\nThe inorder traversal of copied tree is:\n"");
    inorder(c);

    printf(""\nThe inorder traversal of original tree is:\n"");
    inorder(root);

    if(Equal(root, c))
        printf(""\nEqual!\n"");
    else
        printf(""\nNot Equal!\n"");
    
    return 0;
}",62,1767,527
"Node* mergeTwoLLs(Node *head1, Node *head2) 
{
    Node* t1 = head1;
    Node* t2 = head2;
    
    Node* head;
    Node* tail;
    
    if(head1->data <= head2->data)
    {
        head = head1;
        tail = head1;
        t1 = t1->next;
    }   
    
    else 
    {
        head = head2;  
        tail = head2;
        t2 = t2->next;
    }
        
    while(t1 != NULL && t2 != NULL)    
        if(t1->data <= t2->data)
        {
            tail->next = t1;
            tail = t1;
            t1 = t1->next;
        }
        else
        {
            tail->next = t2;
            tail = t2;
            t2 = t2->next;
        }
    
    if(t1 == NULL)
        tail->next = t2;
    
    else
        tail->next = t1;
    
    return head;
}",62,1768,279
"node* mergeTwoLLs(node *head1, node *head2) 
{
    node* t1 = head1;
    node* t2 = head2;
    
    node* head;
    node* tail;
    
    if(head1->data <= head2->data)
    {
        head = head1;
        tail = head1;
        t1 = t1->next;
    }   
    else 
    {
        head = head2;  
        tail = head2;
        t2 = t2->next;
    }
        
    while(t1 != NULL && t2 != NULL)
        if(t1->data <= t2->data)
        {
            tail->next = t1;
            tail = t1;
            t1 = t1->next;
        }   
        else
        {
            tail->next = t2;
            tail = t2;
            t2 = t2->next;
        }
    
    if(t1 == NULL)
        tail->next = t2;
    
    else
        tail->next = t1;
    
    return head;
}",62,1769,277
"struct Node 
{ 
    int coeff; 
    int pow; 
    struct Node *next; 
}; 
            
 
void create_node(int x, int y, struct Node **temp) 
{ 
    struct Node *r, *z; 
    z = *temp; 

    if(z == NULL) 
    { 
        r =(struct Node*)malloc(sizeof(struct Node)); 
        r->coeff = x; 
        r->pow = y; 
        *temp = r; 
        r->next = (struct Node*)malloc(sizeof(struct Node)); 
        r = r->next; 
        r->next = NULL; 
    } 
    else
    { 
        r->coeff = x; 
        r->pow = y; 
        r->next = (struct Node*)malloc(sizeof(struct Node)); 
        r = r->next; 
        r->next = NULL; 
    } 
} 

void polyadd(struct Node *poly1, struct Node *poly2, struct Node *poly) 
{ 
    while(poly1->next && poly2->next) 
    { 
        
        
        if(poly1->pow > poly2->pow) 
        { 
            poly->pow = poly1->pow; 
            poly->coeff = poly1->coeff; 
            poly1 = poly1->next; 
        } 
        
        
        
        else if(poly1->pow < poly2->pow) 
        { 
            poly->pow = poly2->pow; 
            poly->coeff = poly2->coeff; 
            poly2 = poly2->next; 
        } 
        
        
        else
        { 
            poly->pow = poly1->pow; 
            poly->coeff = poly1->coeff+poly2->coeff; 
            poly1 = poly1->next; 
            poly2 = poly2->next; 
        } 
        
        
        poly->next = (struct Node *)malloc(sizeof(struct Node)); 
        poly = poly->next; 
        poly->next = NULL; 
    } 

    while(poly1->next || poly2->next) 
    { 
        if(poly1->next) 
        { 
            poly->pow = poly1->pow; 
            poly->coeff = poly1->coeff; 
            poly1 = poly1->next; 
        } 
        
        if(poly2->next) 
        { 
            poly->pow = poly2->pow; 
            poly->coeff = poly2->coeff; 
            poly2 = poly2->next; 
        }

        poly->next = (struct Node *)malloc(sizeof(struct Node)); 
        poly = poly->next; 
        poly->next = NULL; 
    } 
} 

 
void show(struct Node *node) 
{ 
    while(node->next != NULL) 
    { 
        printf(""%dx^%d"", node->coeff, node->pow); 
        node = node->next; 
    
        if(node->next != NULL) 
            printf("" + ""); 
    }

    printf(""\n""); 
} 
 
int main() 
{ 
    struct Node *poly1 = NULL, *poly2 = NULL, *poly = NULL; 
    
    int n , m, coeff, power;

    printf(""Enter no. of terms in the first polynomial: "");
    scanf(""%d"", &n);
    for(int i = 0 ; i < n ; i++)
    {
        printf(""Enter coeff and power of x : "");
        scanf(""%d %d"", &coeff, &power);
        create_node(coeff, power, &poly1); 

    }

    printf(""Enter no. of terms in the second polynomial: "");
    scanf(""%d"", &m);
    for(int i = 0 ; i < m ; i++)
    {
        printf(""Enter coeff and power of x : "");
        scanf(""%d %d"", &coeff, &power);
        create_node(coeff, power, &poly2); 

    }

    printf(""1st Number: "");     show(poly1); 
    printf(""2nd Number: "");     show(poly2); 
    
    poly = (struct Node *)malloc(sizeof(struct Node)); 
    
    polyadd(poly1, poly2, poly); 
     
    printf(""Added polynomial: ""); show(poly); 

    return 0; 
} 
",62,1770,1127
"int move(int n, char s, char d, char a)
{
    
    
    

    if (n == 1)
    {
        printf(""Move disk from %c to %c \n"", s, d);
        return 1;
    }

    else

    {
        int n1  = move(n - 1, s, a, d);
    
        int n2 = 1; 
        printf(""Move disk from %c to %c \n"", s, d);

        int n3 = move(n - 1, a, d, s);

        return n1 + n2 + n3;
    }
}


int main()
{
    int plates;
    char source = 'A', destin = 'C', aux = 'B';

    printf(""Enter number of plates on A:"");
    scanf(""%d"", &plates);

    printf(""No. of moves: %d \n"", move(plates, source, destin, aux));

    
}",62,1771,247
"typedef struct node* nptr;
typedef struct node
{
    int coeff, exp;
    nptr next;
}node;

nptr createNode(int c, int e)
{
    nptr temp = (nptr)malloc(sizeof(node));
    temp -> coeff = c;
    temp -> exp = e;
    temp -> next = NULL;

    return temp;
}

nptr insert(nptr head, int c, int e)
{
    if(head == NULL)
        return head = createNode(c, e);

    nptr temp = head;
    while(temp -> next != NULL)
        temp = temp -> next;

    temp -> next = createNode(c, e);
    return head;
}

void display(nptr head)
{
    while(head)
    {
        printf(""%dx^%d"", head -> coeff, head -> exp);
        if(head -> next)
            printf("" + "");

        head = head -> next;
    }

    printf(""\n"");
}

int getCoeff(nptr poly, int exp)
{
    while(poly)
    {
        if (poly -> exp == exp)
            return poly -> coeff;
    }

    return 0;
}

nptr add(nptr poly1, nptr poly2)
{
    nptr poly3, temp1 = poly1, temp2 = poly2;

    while(temp1)
    {
        if ( getCoeff(poly2, temp1 -> exp) )
            poly3 = insert(poly3,               temp1 -> coeff + getCoeff(poly2, poly1 -> exp),            poly1 -> exp);

        poly1 = poly1 -> next;
    }

    temp1 = poly1, temp2 = poly2;

    while(temp1)
    {
        if (getCoeff(poly3, temp1 -> exp) == 0)
            poly3 = insert(poly3, temp1 -> coeff, temp1 -> exp);

        temp1 = temp1 -> next;
    }

    while(temp2)
    {
        if (getCoeff(poly3, temp2 -> exp) == 0)
            poly3 = insert(poly3, temp2 -> coeff, temp2 -> exp);

        temp2 = temp2 -> next;
    }

    return poly3;

}

int main()
{
    nptr poly1  = NULL, poly2 = NULL, poly3 = NULL;
    
    int n, m;
    int coeff, exp;

    printf(""Enter terms in poly1: ""); 
    scanf(""%d"", &n);
    
    for(int i = 0 ; i < n ; i++)
    {
        printf(""Enter coeff and exp: ""); 
        scanf(""%d %d"", &coeff, &exp);
        poly1 = insert(poly1, coeff, exp);
    }

    printf(""Enter terms in poly2: ""); 
    scanf(""%d"", &m);
    
    for(int i = 0 ; i < m ; i++)
    {
        printf(""Enter coeff and exp: ""); 
        scanf(""%d %d"", &coeff, &exp);
        poly2 = insert(poly2, coeff, exp);
    }

    printf(""\n"");
    display(poly1);
    display(poly2);
    
    printf(""\n"");
    display(poly3 = add(poly1, poly2));
}",62,1772,857
"#include ""charStack.h""



void strrev(char *str)
{
    int i = strlen(str) - 1, j = 0;

    char ch;
    
    while (i > j)
    {
        ch = str[i];
        str[i] = str[j];
        str[j] = ch;
        
        i--;  j++;
    }
}

int isOperand(char ch)      
{ 
    return (ch >= 'a' && ch <= 'z');
} 

int prec(char ch)           
{ 
    if (ch == '+' || ch == '-')
        return 1; 

    if (ch == '*' || ch == '/')
        return 2; 

    if (ch == '^')
        return 3;  
    
    return -1; 
} 

int infixToPostfix(char* exp, char* ans) 
{ 
    int i, k = 0; 

    stack s;

    for (i = 0 ; exp[i] != '\0' ; i++) 
    { 
    
        if (isOperand(exp[i]))      
            ans[k++] = exp[i]; 
        
        else if (exp[i] == '(')     
            push(&s, exp[i]); 
        
        else if (exp[i] == ')')     
        { 
            while (!isEmpty(&s) && top(&s) != '(') 
                ans[k++] = pop(&s); 
            
            pop(&s);  
        } 
        
        else            
        { 
            while ( !isEmpty(&s) && prec(exp[i]) <= prec(top(&s)) ) 
                ans[k++] = pop(&s); 
            
            push(&s, exp[i]); 
        } 
    } 

    while (!isEmpty(&s))            
        ans[k++] = pop(&s); 

    ans[k- 1] = '\0';  
} 

int main() 
{ 
    char exp[100], ans[100];
    scanf(""%s"", exp);

    strrev(exp);

    for(int i = 0 ; i < strlen(exp) ; i++)
    {
        if (exp[i] == ')')
            exp[i] ='(';

        else if (exp[i] == '(')
            exp[i] =')';
    }

    infixToPostfix(exp, ans);

    strrev(ans);

    printf(""%s \n"", ans); 
} ",62,1773,658
"double add(double L[], int n)
{
    double sum = 0;

    for(int i = 0 ; i < n ; i++)
        sum += L[i];

    return sum;
}

int Lsearch(int arr[], int n, int x)
{
    for(int i = 0 ; i < n ; i++)
        if(arr[i] == x)
            return i + 1;

    return -1;
}

void multiply(int a[][10], int b[][10], int m, int n, int p, int q)
{
    int f[10][10], sum = 0;

    if(n != p)
    {
        printf(""Invalid Order\n"");
        return;
    }

    for(int c = 0 ; c < m ; c++)
        for(int d = 0 ; d < q ; d++)
        {
            for(int k = 0 ; k < p ; k++)
                sum += a[c][k] * b[k][d];

            f[c][d] = sum;
            sum = 0;
        }

    printf(""Product of matrices: \n"");

    for(int c = 0 ; c < m ; c++)
    {
        for(int d = 0 ; d < q ; d++)
            printf(""%d\t"", f[c][d]);

        printf(""\n"");
    }

    printf(""\n"");
}

int secLar(int a[], int n)
{
    int first, second;

    first = second = -99999;

    for(int i = 0; i < n ; i++)
        if(a[i] > first)
        {
            second = first;
            first = a[i];
        }
        else if(a[i] > second && a[i] < first)
            second = a[i];

    return second;
}

int main()
{
    int ch;

    do
    {
        printf(""1. Add array elements\n"");
        printf(""2. Linear Search\n"");
        printf(""3. Multiply Matrices\n"");
        printf(""4. Find second largest element in an array\n"");
        printf(""5. Exit\n\n"");
        printf(""Enter your choice: "");
        scanf(""%d"", &ch);

        int size1; double arr1[50];                         
        int size2, arr2[50], x;                             
        int m, n, p, q, first[10][10], second[10][10];      
        int size3, arr3[50];                                

        switch(ch)
        {
            case 1:
                    

                    printf(""Enter size: "");
                    scanf(""%d"", &size1);
                    
                    printf(""Enter elements: "");
                    for(int i = 0 ; i < size1 ; i++)
                        scanf(""%lf"", &arr1[i]);

                    printf(""Sum of elements is %lf \n\n"", add(arr1, size1));
                    break;

            case 2:
                    

                    printf(""Enter size: "");
                    scanf(""%d"", &size2);

                    printf(""Enter elements: "");
                    for(int i = 0 ; i < size2 ; i++)
                        scanf(""%d"", &arr2[i]);

                    printf(""Enter element to be searched: "");
                    scanf(""%d"", &x);

                    printf(""Element found at %dth position.\n\n"", Lsearch(arr2, size2, x));
                    break;

            case 3:
                    

                    printf(""Enter order of first matrice: "");
                    scanf(""%d %d"", &m, &n);
                    printf(""Enter elements: \n"");
                    for(int i = 0 ; i < m ; i++)
                        for(int j = 0 ; j < n ; j++)
                            scanf(""%d"", &first[i][j]);

                    printf(""Enter order of second matrice: "");
                    scanf(""%d %d"", &p, &q);
                    printf(""Enter elements: \n"");
                    for(int i = 0 ; i < p ; i++)
                        for(int j = 0 ; j < q ; j++)
                            scanf(""%d"", &second[i][j]);

                    multiply(first, second, m, n, p, q);
                    break;
            
            case 4: 
                    

                    printf(""Enter size: "");
                    scanf(""%d"", &size3);

                    printf(""Enter elements: "");
                    for(int i = 0 ; i < size3 ; i++)
                        scanf(""%d"", &arr3[i]);

                    printf(""Second largest element is %d.\n\n"", secLar(arr3, size3));
                    break;
            
            case 5: 
                    break;

            default:
                    printf(""Invalid input. Please try again!\n\n"");
        }

    }while(ch != 5);
}",62,1774,1280
"typedef struct
{
    int c[20];
    int front;
    int rear;
}queue;

void enqueue(queue *q,int n)
{
    if (q->rear==20)
        printf(""Queue Full\n"");
    
    else
    {
        int i,j,t;
        q->c[(q->rear)++]=n;
    
        for (i=0 ; i<q->rear-1 ; i++)                          
            for (j=0 ; j<q->rear-i-1 ; j++)
                if (q->c[j] < q->c[j+1])
                {
                    t=q->c[j];
                    q->c[j]=q->c[j+1];
                    q->c[j+1]=t;
                }
       
       
    }
}

int dequeue(queue *q)
{
    if (q->front==q->rear)
    {
        printf(""Queue Empty"");
        return -1;
    }

    else
        return q->c[--(q->rear)];
}

void display(queue *q)
{
    printf(""Cuurent queue: \n"");
    
    int i;
    for (i=q->front;i<q->rear;i++)
        printf(""%d\t"",q->c[i]);
    
    printf(""\n"");
}

int main()
{
    int z=0,k,e;
    queue q;
    q.front=0;
    q.rear=0;

    printf(""1. Enqueue \t2. Dequeue \t3. Display \t4. Exit\n"");


    while (z==0)
    {
        printf(""\nCommand: "");
        scanf(""%d"",&k);

        switch(k)
        {
            case 1:
                    printf(""Enter element : "");
                    scanf(""%d"",&e);
                    enqueue(&q,e);
                    break;

            case 2:
                    printf (""%d dequed. \n"", dequeue(&q));
                    break;
            
            case 3:
                    display(&q);
                    break;
            
            case 4:
                    z=1;
        }
    }
}",62,1775,575
"#define MAX 10

typedef struct
{
    int a[MAX];
    int tos1;
    int tos2;
}stack;

void push1(stack *s)
{
    if(s->tos2 - s->tos1 == 1)
        printf(""Array Full"");
    else
    {
        printf(""Push: "");
        int ele;
        scanf(""%d"", &ele);
        s->a[++(s->tos1)] = ele;
    }
}

void push2(stack *s)
{
    if(s->tos2 - s->tos1 == 1)
        printf(""Array Full"");
    else
    {
        printf(""Push: "");
        int ele;
        scanf(""%d"", &ele);
        s->a[--(s->tos2)] = ele;
    }
}

void pop1(stack *s)
{
    if (s->tos1 == -1)
        printf(""Underflow! \n"");
    else
        printf(""%d popped\n"", s->a[(s->tos1)--]);
}

void pop2(stack *s)
{
    if (s->tos2 == MAX)
        printf(""Underflow! \n"");
    else
        printf(""%d popped\n"", s->a[(s->tos2)++]);
}

void display(stack *s)
{
    printf(""\nStack 1: "");
    for(int i = 0 ; i <= s->tos1 ; i++)
        printf(""%d "", s->a[i]);

    printf(""\nStack 1: "");
    for(int i = MAX - 1 ; i >= s->tos2 ; i--)
        printf(""%d "", s->a[i]);

    printf(""\n"");


}

int main()
{
    stack s;
    s.tos2 = MAX;
    s.tos1 = -1;

    int z = 0, k;

    while (z == 0)
    {
        printf(""1. Push1   2. Push2   3. Pop1    4. Pop2    5. Display    6. Exit \n"");
        scanf(""%d"", &k);

        switch(k)
        {
            case 1: push1(&s); break;
            case 2: push2(&s); break;
            case 3: pop1(&s); break;
            case 4: pop2(&s); break;
            case 5: display(&s); break;
            case 6: z = 1;
        }
    }
}
",62,1776,644
"#define MAX 10
#define size 20


typedef struct node
{
    char data;
    struct node *left;
    struct node *right;
}node;

typedef struct
{
    node* s[MAX];
    int tos;
}STACK;

node* newNode(int v)
{
    node *temp = (node*)malloc(sizeof(node));
    temp->left = temp->right = NULL;
    temp->data = v;
    return temp;
}

typedef struct
{
    float a[size];
    int tos;
} STACKs;

void pushs(STACKs *s, float x)
{
    s->a[++(s->tos)] = x;
}

float pops(STACKs *s)
{
    return s->a[(s->tos)--];
}

void push(STACK *s, node* n)
{
    s->s[++(s->tos)] = n;
}

node* pop(STACK *s)
{
    return s->s[(s->tos)--];
}

void inorder(node* root)
{
    if (root == NULL)
        return;

    inorder(root->left);
    printf(""%c "", root->data);
    inorder(root->right);
}

float calcu(node *root)
{
    node* curr;
    curr = root;
    
    STACK s;
    STACKs expression;
    s.tos = -1;
    expression.tos = -1;
    
    char m;
    float p, q;
    
    do
    {
        while (curr != NULL)
        {
            if (curr->right != NULL)
                push(&s, curr->right);
    
            push(&s, curr);
            curr = curr->left;
        }
    
        curr = pop(&s);
    
        if (curr->right != NULL && s.s[s.tos] == curr->right)
        {
            pop(&s);
            push(&s, curr);
            curr = curr->right;
        }
        else
        {
            m = curr->data;

            switch (m)
            {
                case '*':   pushs(&expression, pops(&expression)*pops(&expression));
                            break;
                
                case '/':   pushs(&expression, pops(&expression) / pops(&expression));
                            break;
                
                case '-':   pushs(&expression, pops(&expression) - pops(&expression));
                            break;
        
                case '+':   pushs(&expression, pops(&expression) + pops(&expression));
                            break;
        
                case '$':   p = pops(&expression);
                            q = pops(&expression);
                            pushs(&expression, pow(p, q));
                            break;

                default:    pushs(&expression, (float)(m - '0'));
                            break;
            }
            curr = NULL;
        }
    }while (s.tos != -1);
    
    return expression.a[0];
}

int isOperator(char c)
{
    if (c == '+' || c == '-' || c == '*' || c == '/' || c == '^')
        return 1;
    else
        return 0;
}

node* constructTree(char postfix[])
{
    STACK st;
    st.tos = -1;
    node *t, *t1, *t2;
    
    int i, j;
    
    for (j = 0; postfix[j] != '\0'; j++);
    
    for (i = 0; i < j; i++)
    {
        if (!isOperator(postfix[i]))
        {
            t = newNode(postfix[i]);
            push(&st, t);
        }
        else
        {
            t = newNode(postfix[i]);
            t2 = pop(&st);
            t1 = pop(&st);

            t->right = t2;
            t->left = t1;

            push(&st, t);
        }
    }

    return t;
}

int main()
{
    char postfix[MAX];
    scanf("" %s"", postfix);
    node* r = constructTree(postfix);

    printf(""infix expression is \n"");
    inorder(r);

    printf(""\n%.2f"", calcu(r));
    return 0;
}",62,1777,1126
"void main () {
    int serverfd = socket(AF_INET, SOCK_DGRAM, 0);

    struct sockaddr_in seradd;
    seradd.sin_family = AF_INET;
    seradd.sin_port = 4000;
    seradd.sin_addr.s_addr = INADDR_ANY;

    bind(serverfd, (struct sockaddr *) &seradd, sizeof(seradd));

    while (1) {
        char buf[100];
        struct sockaddr_in cliadd;
        int len = sizeof(cliadd);

        recvfrom(serverfd, buf, 100, 0, (struct sockaddr*) &cliadd, &len);
        printf(""Client: %s\n"", buf);

        strcpy(buf, ""Got it bro"");

        sendto(serverfd, buf, 100, 0, (struct sockaddr*) &cliadd, len);
    }
}",62,1778,245
"typedef struct
{
    int c[20];
    int front;
    int rear;
}queue;
void enqueueright(queue *q,int n)
{
    if (q->rear==20)
        printf(""Side Full\n"");
    else
        q->c[(q->rear)++]=n;
}
void enqueueleft(queue *q,int n)
{
    if (q->front==0)
        printf(""Side Full\n"");
    else
        q->c[--(q->front)]=n;
}
int dequeueleft(queue *q)
{
    if (q->front==q->rear)
    {
        printf(""Queue Empty"");
        return -1;
    }
    else
        return q->c[(q->front)++];
}
int dequeueright(queue *q)
{
    if (q->front==q->rear)
    {
        printf(""Queue Empty"");
        return -1;
    }
    else
        return q->c[--(q->rear)];
}
void display(queue *q)
{
    int i;
    for (i=q->front;i<q->rear;i++)
        printf(""%d\t"",q->c[i]);
    printf(""\n"");
}
int main()
{
    int z=0,k,e;
    queue q;
    q.front=10;
    q.rear=10;
    while (z==0)
    {
        printf(""1. Enqueue Right\t2. Enqueue Left\t3. Dequeue Left\t4. Dequeue Right\t5. Display \t6. Exit\n"");
        scanf(""%d"",&k);
        switch(k)
        {
            case 1:
            {
                scanf(""%d"",&e);
                enqueueright(&q,e);
                break;
            }
            case 2:
            {
                scanf(""%d"",&e);
                enqueueleft(&q,e);
                break;
            }
            case 3:
            {
                printf (""%d\n"",dequeueleft(&q));
                break;
            }
            case 4:
            {
                printf (""%d\n"",dequeueright(&q));
                break;
            }
            case 5:
            {
                display(&q);
                break;
            }
            case 6:
            {
                z=1;
            }
        }
    }
}",62,1779,619
"typedef struct node* nptr;
typedef struct node
{
    int data;
    nptr next;
}node;

nptr createNode(int x)
{
    nptr temp = (nptr)malloc(sizeof(node));
    temp -> data = x;
    temp -> next = NULL;

    return temp;
}

void insertFront(nptr &head, int ele)
{
    nptr temp = createNode(ele);
    temp -> next = head;
    head = temp;
}

void insertAfter(nptr &head, int x, int key)
{
    nptr temp = head;

    while(temp != NULL)
    {
        if (temp -> data == key)
        {
            nptr newNode = createNode(x);
            newNode -> next = temp -> next;
            temp -> next = newNode;
            return;
        }
        
        temp = temp -> next;
    }

    printf(""Element wasn't found\n"");
}

void display(nptr head)
{
    nptr temp = head;

    while(temp != NULL)
    {
        printf(""%d --> "", temp -> data);
        temp = temp->next;
    }

    printf(""NULL\n"");
}

int main()
{
    nptr head = NULL;
    int ch, ele, key;

    printf(""0. Exit      1. Insert Front      2. Insert After      3. Display\n"");

    do
    {
        printf(""Command: "");
        scanf(""%d"", &ch);

        switch(ch)
        {
            case 1: printf(""Element: "");
                    scanf(""%d"", &ele);
                    insertFront(head, ele);
                    break;

            case 2: printf(""Element and key element to insert after: "");
                    scanf(""%d %d"", &ele, &key);
                    insertAfter(head, ele, key);
                    break;

            case 3: display(head);
        }

    }while(ch != 0);
}",62,1780,506
"#define MAX 100

typedef struct
{
    int q[100];
    int front;
    int rear;
}QUEUE;

int isEmpty(QUEUE* pq)
{
    if (pq->front == pq->rear)
        return 1;
    else
        return 0;
}

int isFull(QUEUE* pq)
{
    if (pq->rear == MAX - 1)
        return 1;
    else
        return 0;
}

void enqueue(QUEUE* pq, int x)
{
    if(isFull(pq) == 0)
        pq->q[(pq->rear)++] = x;
    else
        printf(""FULL"");
}

int dequeue(QUEUE* pq)
{
    if (isEmpty(pq) == 1)
        return -1;
    else
        return pq->q[(pq->front)++];
}

void display(QUEUE* pq)
{
    for(int i = pq->front ; i < pq->rear ; i++)
        printf(""%d "", pq->q[i]);

    printf(""\n"");

}

void reverse(QUEUE* q1, QUEUE* q2, int n)                                   
{
    if(n == 0)
        return;

    int x = dequeue(q1);
    reverse(q1, q2, n - 1);
    enqueue(q2, x);
}

int main()
{
    QUEUE q1, q2; q1.front = q1.rear = q2.front = q2.rear = 0;            

    int n;
    printf(""Enter no. of elements: "");
    scanf(""%d"", &n);
    
    printf(""Enter elements: "");

    for(int i = 0 ; i < n ; i++)
    {
        int a;
        scanf(""%d"", &a);
        enqueue(&q1, a);
    }


    

    printf(""QUEUE 1:"");    display(&q1);
    
    reverse(&q1, &q2,n);

    

    printf(""QUEUE 2:"");    display(&q2);
    
    return 0;
}



















",62,1781,596
"void main () {

    struct sockaddr_in cliadd, seradd;
    int sockaddr_len = sizeof(seradd);

    seradd.sin_family = AF_INET;
    seradd.sin_port = 1326;
    seradd.sin_addr.s_addr = inet_addr(""127.0.0.1"");

    int serverfd = socket(AF_INET, SOCK_STREAM, 0);

    if (serverfd == -1) {
        printf(""Can't create socket\n"");
        exit(0);
    }

    if (bind(serverfd, (struct sockaddr*) &seradd, sockaddr_len) == -1) {
        printf(""Can't bind\n"");
        exit(0);
    }

    if (listen(serverfd, 10) == -1) {
        printf(""Can't listen\n"");
        exit(0);
    }

    printf(""Waiting for connection!\n"");

    int clientfd = accept(serverfd, (struct sockaddr*)&cliadd, &sockaddr_len);

    printf(""Connection established!\n"");
    printf(""IP: %s\n"", inet_ntoa(cliadd.sin_addr));
    printf(""Port: %d\n"", cliadd.sin_port);

    int mat[100][100];
    int i = 0;

    while (1) {
        int arr[100];
        read(clientfd, arr, 100 * 4) / 4;
        int size = arr[0];

        if (size == 0) {
            break;
        }

        for (int j = 0 ; j <= size ; j++) {
            mat[i][j] = arr[j];
        }

        i++;

        printf(""Got line %d\n"", 1);
    }

    for (int ii = 0 ; ii < i ; ii++) {
        int size = mat[ii][0];

        for (int j = 1 ; j <= size ; j++) {
            printf(""%d "", mat[ii][j]);
        }

        printf(""\n"");
    }

    close(clientfd);
}",62,1782,558
"void reverse(int arr[], int size)
{
    int *start = arr , *end = arr + size - 1;

    for(int i = 0 ; i < size/2 ; i++)
    {
        int temp = *(start + i);
        *(start + i) = *(end - i);
        *(end - i) = temp;
    }
}

int main()
{
    int a[50], n;

    printf(""Enter number of elements: "");
    scanf(""%d"", &n);

    printf(""Enter elements: "");

    for(int i = 0 ; i < n ; i++)
        scanf(""%d"", &a[i]);

    reverse(a, n);

    for(int i = 0 ; i < n ; i++)
        printf(""%d  "", a[i]);

}",62,1783,210
"typedef struct
{
    int real;
    int imag;
} cNum;

cNum add(cNum a, cNum b)
{
    cNum temp;

    temp.real = a.real + b.real;
    temp.imag = a.imag + b.imag;

    return temp;
}

cNum subtract(cNum a, cNum b)
{
    cNum temp;

    temp.real = a.real - b.real;
    temp.imag = a.imag - b.imag;

    return temp;
}

cNum multiply(cNum a, cNum b)
{
    cNum temp;

    temp.real = a.real * b.real - a.imag * b.imag;
    temp.imag = a.imag * b.real + a.real * b.imag;

    return temp;
}

void display(cNum a)
{
    printf("" %d + %di \n"", a.real, a.imag);
}

int main()
{
    cNum a, b, c;

    
    printf(""Enter real and imaginary part of first number: "");
    scanf(""%d %d"", &a.real, &a.imag);

    printf(""Enter real and imaginary part of second number: "");
    scanf(""%d %d"", &b.real, &b.imag);

    printf(""Addition: "");
    display(add(a, b));

    printf(""Subtract: "");
    display(subtract(a, b));

    printf(""Multiply: "");
    display(multiply(a, b));

}


",62,1784,416
"int main()
{
    int rowNum;
    printf(""Enter no. of rows:"");
    scanf(""%d"", &rowNum);

    int **table = calloc(rowNum, sizeof(int*));

    for(int i = 0 ; i < rowNum ; i++)
    {
        int colSize;
        printf(""Enter no. of columns of %dth row: "", i + 1);
        scanf(""%d"", &colSize);

        table[i] = calloc(colSize + 1, sizeof(int));

        table[i][0] = colSize;  

        printf(""Enter %d elements: "", colSize);
        for(int j = 1 ; j <= table[i][0] ; j++)
            scanf(""%d"", &table[i][j]);
    }

    for(int i = 0 ; i < rowNum ; i++)
    {
        int colSize = table[i][0];

        for(int j = 1 ; j <= colSize ; j++)
            printf(""%d\t"", table[i][j]);

        printf(""\n"");

        free(table[i]);
    }

    free(table);
}",62,1785,290
"typedef struct
{
    char a[20][20];
    int tos;
}stack;

void push(stack *s, char a[])
{
    strcpy(s->a[(++s->tos)], a);
}

void pop(stack * s, char temp[])
{
    strcpy(temp, s->a[(s->tos)--]);
}

int alnum(char t)
{
    switch(t)
    {
        case '+':
        case '-':
        case '/':
        case '*':
        case '$':
                    return 0;
    }

    return 1;
}

int main()
{
    stack s;
    s.tos = -1;
    char pre[20], pos[20], t;

    printf(""Enter prefix: "");
    scanf(""%s"", pre);

    int i, j;

    int l = strlen(pre);

    for(int i = 0 ; i < l ; i++)
    {
        t = pre[i];
        char temp[2] = {t, '\0'};

        push(&s, temp);

        while (alnum(s.a[s.tos][0]) && alnum(s.a[(s.tos - 1)][0]) && s.tos != 0)
        {
            char temp1[20], temp2[20], temp3[20];
            pop(&s, temp1);
            pop(&s, temp2);
            pop(&s, temp3);

            strcat(temp2, temp1);
            strcat(temp2, temp3);
            push(&s, temp2);
        }
    }

    strcpy(pos, s.a[0]);

    printf(""Postfix expression is %s"", pos);
}
",62,1786,451
"int* bsearch(int* first, int size, int x)
{
    int* last = first + size - 1;

    while(first <= last)
    {
        int *mid = first + (last - first)/2;

        if(*mid == x)
            return mid;

        else if(*mid > x)
            last = mid - 1;

        else if(*mid < x)
            first = mid + 1;
    }

    return NULL;
}

int main()
{
    int arr[20];
    int n;
    int toSearch;

    printf(""Enter array size: "");
    scanf(""%d"", &n);

    printf(""Enter array elements in sorted order: "");
    for(int i = 0; i < n; i++)
        scanf(""%d"", &arr[i]);

    printf(""Enter element to be searched: "");
    scanf(""%d"", &toSearch);

    if(bsearch(arr, n, toSearch) != NULL)
    {
        int pos = bsearch(arr, n, toSearch) - arr + 1;
        printf(""Element found at %dth position. \n \n"", pos);
    }

    else
        printf(""Element not found \n\n"");

    printf(""Use of Double pointers. Enter a two numbers:"");
    int a, b;
    scanf(""%d %d"", &a, &b);
    
    int *p1 = &a;
    int **p2 = &p1;

    int *p3 = &b;
    int **p4 = &p3;


    printf(""Product = %d \n \n"", **p2 * **p4);

}",62,1787,419
"typedef struct node* nptr;
typedef struct node
{
    int data;
    nptr next;
}node;

nptr createNode(int x)
{
    nptr temp = (nptr)malloc(sizeof(node));
    temp -> data = x;
    temp -> next = NULL;

    return temp;
}

void insert(nptr &head, int ele)
{
    if (head == NULL)
    {
        head = createNode(ele);
        return;
    }

    else if (ele < head -> data)
    {
        nptr temp = createNode(ele);
        temp -> next = head;
        head = temp;
        return;
    }

    else
    {
        nptr prev = NULL, curr = head;

        while(curr != NULL && curr -> data <= ele)
        {
            prev = curr;
            curr = curr -> next;
        }

        nptr temp = createNode(ele);
        prev -> next = temp;
        temp -> next = curr;
    }
}

void display(nptr head)
{
    nptr temp = head;

    while(temp != NULL)
    {
        printf(""%d --> "", temp -> data);
        temp = temp->next;
    }

    printf(""NULL\n"");
}

int main()
{
    nptr head = NULL;
    int ch, ele;

    printf(""0. Exit      1. Insert      2. Display\n"");

    do
    {
        printf(""Command: "");
        scanf(""%d"", &ch);

        switch(ch)
        {
            case 1: printf(""Element: "");
                    scanf(""%d"", &ele);
                    insert(head, ele);
                    break;

            case 2: display(head);
        }

    }while(ch != 0);
}",62,1788,460
"nptr copy(nptr original)
{
    if (original == NULL)
        return NULL;

    temp = createNode(original -> data);
    temp -> lchild = copy(original -> lchild);
    temp -> rchild = copy(original -> rchild);
    return temp;
}

int searchBT(nptr root, int x)
{
    if(root == NULL)
        return 0;

    else if (root -> data  == x  ||  searchBT(root -> lchild, x)  ||   searchBT(root -> rchild, x) )
        return 1;
}

int height(nptr root)
{
    if (root == NULL)
        return 0;
    
    return max(height(root->right), height(root->left)) + 1;
}

int Equal( Nodeptr root1, Nodeptr root2)
{
    return  ((root1 == NULL && root2 == NULL) || (root1 && root2 && root1 -> data == root2 -> data)) 
            && Equal(root1->lchild, root2->lchild) 
            && Equal(root1->rchild, root2->rchild);
}

void getlevel(node* r, int level)
{
    if (level == 0)
        printf(""%d\t"", r -> data);
    
    else
    {
        getlevel(r->left, level-1);
        getlevel(r->right, level-1);
    } 
}

",62,1789,368
"typedef struct node* nptr;
typedef struct node
{
    int data;
    nptr next;
} node;

nptr createNode(int x)
{
    nptr temp = (nptr)malloc(sizeof(node));
    temp -> data = x;
    temp -> next = NULL;

    return temp;
}

void insertRear(nptr &head, int ele)
{
    if (head == NULL)
    {
        head = createNode(ele);
        return;
    }

    nptr rear = head;
    
    while(rear -> next != NULL)
        rear = rear -> next;

    nptr temp = createNode(ele);
    rear -> next = temp;
}

void display(nptr head)
{
    nptr temp = head;

    while (temp)
    {
        printf(""%d --> "", temp -> data);
        temp = temp -> next;
    }

    printf(""NULL\n"");
}

int elementFound(nptr head, int x)
{
    while(head)
        if(head -> data == x)
            return 1;
        else
            head = head -> next;

    return 0;
}

nptr listUnion(nptr head1, nptr head2)
{
    nptr head3 = NULL;;
    
    nptr temp = head1;
    while(temp)
    {
        insertRear(head3, temp -> data);
        temp = temp -> next;
    }

    temp = head2;
    while(temp)
    {
        if (elementFound(head3, temp -> data) == 0) 
            insertRear(head3, temp -> data);

        temp = temp -> next;
    }

    return head3;
}

int main()
{
    nptr head1 = NULL, head2 = NULL, head3 = NULL;
    int ele;

    printf(""Elements in list 1: \n"");
    while(1)
    {
        scanf(""%d"", &ele);
        
        if(ele == -1)
            break;
        
        insertRear(head1, ele);
    } 

    display(head1);

    printf(""Elements in list 2: \n"");
    while(1)
    {
        scanf(""%d"", &ele);
        
        if(ele == -1)
            break;
        
        insertRear(head2, ele);
    } 

    display(head2);  
    
    printf(""\nUnion: \n"");
    display(head3 = listUnion(head1, head2));
}",62,1790,647
"void Levelorder(Nodeptr root) 
{
    queue q;
    q.front = MAX/2;
    q.rear = MAX/2;

    InsertQ(&q, root);
    
    while (!QIsEmpty(&q)) 
    {
        Nodeptr temp = DeleteQ(&q);
        printf(""%d "", temp->data);
    
        if (temp->lchild) 
            InsertQ(q, temp->lchild);
        
        if (temp->rchild) 
            InsertQ(q, temp->rchild);
    }
}

void iterative_inorder(Nodeptr root)
{
    Nodeptr cur = root;
    int done = false;
    
    STACK s; s.top = -1;
    
    while (!done) 
    {
        while (cur != NULL) 
        {
            push(&s, cur);
            cur = cur -> lchild;
        }
        
        if (isEmptyStack(s) == 0) 
        {
            cur = pop(&s);
            printf(""%d "", cur -> data);
            cur = cur -> rchild;
        }
        else
            done = true;
    }
}

void iterative_preorder(nptr root)
{
    stack s; s.top = -1;
    nptr cur;

    push(&s, root);
    
    while (!IsEmpty(s)) 
    {
        cur = Pop(s);
        printf(""%d"", cur->data);
        
        if (cur -> rchild) 
            push(&s, cur -> rchild);
        
        if (cur -> lchild) 
            push(&s, cur -> lchild);
    }
}

void iterative_postorder(Nodeptr root)
{
    cur = root;
    for (; ;) 
    {
        while (cur != NULL) 
        { 
            s[++top].node = cur;
            s[top].flag = 1;
            cur = cur -> llink;
        }
        
        while (s[top].flag < 0) 
        {
            cur = s[top--].node;
            printf(â % dâ, curï info);
            if (stack_empty(top))
                return;

        }
        cur = s[top].node; 

        cur = cur -> rlink;
        s[top].flag = -1;
    }
}",62,1791,597
"typedef struct Node* nptr;
typedef struct Node
{
    nptr llink;
    nptr rlink;
    int ele;
}node;

nptr createNode()
{
    nptr temp=(nptr)malloc(sizeof(node));
    temp->llink=temp;
    temp->rlink=temp;
    return temp;
}

void insert(nptr list,int x)
{
    nptr temp=createNode();
    temp->ele=x;
    temp->llink=list;
    temp->rlink=list->rlink;
    list->rlink=temp;
    (temp->rlink)->llink=temp;
}

nptr getnum(char num[50])
{
    nptr head=createNode();

    for(int i=strlen(num)-1;i>=0;i--)
        insert(head,num[i]-'0');

    return head;
}

nptr add(nptr num1,nptr num2)
{
    nptr sum=createNode();
    nptr n1=num1->llink,n2=num2->llink;

    int cin=0;
    int s=0;

    while(n1!=num1&&n2!=num2)
    {
        s=n1->ele+n2->ele+cin;

        if(s>=10)
        { 
            cin=1;
            insert(sum, s-10);
        }
        else
        {
            cin=0;
            insert(sum,s);
        }
        n1=n1->llink;
        n2=n2->llink;
    }
    
    while(n1!=num1)
    {
        s=n1->ele+cin;
        
        if(s>9)
        { 
            cin=1; 
            insert(sum,s-10);
        }
        else 
        {
            cin=0; 
            insert(sum,s);
        }
        
        n1=n1->llink;
    }
    
    while(n2!=num2)
    {
        s=n2->ele+cin;
        
        if(s>9)
        { 
            cin=1; 
            insert(sum,s-10);
        }
        else 
        {
            cin=0; 
            insert(sum,s);
        }
        
        n2=n2->llink;
    }
    
    return sum;
}

void disp(nptr list)
{
    nptr i=list->rlink;
    
    while(i!=list)
    {
        printf(""%d"",i->ele);
        i=i->rlink;
    }
    
    printf(""\n"");
}

int main()
{
    char num1[50],num2[50];
    
    printf(""Enter the first number: "");
    scanf(""%s"",num1);
    printf(""Enter the second number: "");
    scanf(""%s"",num2);

    nptr n1=getnum(num1);
    nptr n2=getnum(num2);
    
    
    nptr sum=add(n1,n2);
    
    printf(""The sum of the given numbers is "");
    disp(sum);
}
",62,1792,825
"typedef struct node* nptr;
typedef struct node
{
    nptr next;
    int data;
}node;

nptr createNode(int x)
{
    nptr temp = (nptr)malloc(sizeof(node));
    temp -> data = x;
    temp -> next = NULL;

    return temp;
}

void push(nptr &head, int x)
{
    nptr temp = createNode(x);
    temp -> next = head;
    head = temp;
}

int pop(nptr &head)
{
    if (head == NULL)
        return -1;

    nptr rear2 = head;
    nptr rear = head -> next;

    while(rear -> next != NULL)
    {
        rear2 = rear2 -> next;
        rear = rear -> next;
    }

    rear2 -> next = NULL;
    int x = rear -> data;

    free(rear);
    return x;
}

void display(nptr &head)
{
    if (head == NULL)
    {   
        printf(""EMPTY\n"");
        return;
    }

    nptr curr = head;

    while(curr)
    {
        printf(""    %d \n"", curr -> data);
        curr = curr -> next;
    }
}

int main()
{
    printf(""1. Push    2. Pop    3. Display    0.Exit\n"");
    int ch, ele;

    nptr queue = NULL;

    do
    {
        printf(""Command: ""); scanf(""%d"", &ch);

        switch(ch)
        {
            case 1:     
                    printf(""Element: ""); scanf(""%d"", &ele);
                    push(queue, ele);
                    break;
            
            case 2:
                    ele = pop(queue);
                    
                    if(ele == -1)
                        printf(""Queue empty!\n"");
                    else
                        printf(""%d popped!\n"", ele);
                        
                    break;

            case 3:
                    display(queue);
        }

    }while(ch != 0);
}",62,1793,537
"#define MAX 100

typedef struct node
{
    int data;
    struct node *left;
    struct node *right;
}node;

typedef struct
{
    node* s[MAX];
    int tos;
}STACK;

void push(STACK *s, node* n)
{
    s->s[++(s->tos)] = n;
}

node* pop(STACK *s)
{
    return s->s[(s->tos)--];
}

typedef struct
{
    node* c[MAX];
    int front;
    int rear;
}queue;

void InsertQ(queue *q, node* n)
{
    if (q->rear == MAX)
        printf(""Side Full\n"");
    
    else
        q->c[(q->rear)++]=n;
}

int QIsEmpty(queue *q)
{
    if (q->front == q->rear)
        return 1;
    else
        return 0;
}

node* DeleteQ(queue *q)
{
    return q->c[(q->front)++];
}

node* create()
{
    node *p;
    int x;
    printf(""Enter data(-1 for no data):"");
    scanf(""%d"", &x);
    
    if (x == -1)
        return NULL;
    
    p = (node*)malloc(sizeof(node));
    p->data = x;
    
    printf(""Enter left child of %d:\n"", x);
    p->left = create();
    printf(""Enter right child of %d:\n"", x);
    p->right = create();
    
    return p;
}

void levelorder(node* root) 
{
    queue q;
    q.front = MAX/2;
    q.rear = MAX/2;

    InsertQ(&q, root);
    
    while (!QIsEmpty(&q)) 
    {
        node* temp = DeleteQ(&q);
        printf(""%d\t"", temp->data);
    
        if (temp->left) 
            InsertQ(&q, temp->left);
        
        if (temp->right) 
            InsertQ(&q, temp->right);
    }
}

void inorder(node *t)
{
    node* curr;
    curr = t;
    STACK s;
    s.tos = -1;
    
    push(&s, t);
    curr = curr->left;
    
    while (s.tos != -1 || curr != NULL)
    {
        while (curr != NULL)
        {
            push(&s, curr);
            curr = curr->left;
        }
    
        curr = pop(&s);
        printf(""%d\t"", curr->data);
        curr = curr->right;
    }
}

void preorder(node *t)
{
    node* curr;
    STACK s;
    
    s.tos = -1;
    
    push(&s, t);
    
    while (s.tos != -1)
    {
        curr = pop(&s);
        printf(""%d\t"", curr->data);
    
        if (curr->right)
            push(&s, curr->right);

        if (curr->left)
            push(&s, curr->left);
    }
}

void postorder(node *t)
{
    STACK s;
    node*curr;
    curr = t;
    s.tos = -1;
    
    do
    {
        while (curr != NULL)
        {
            if (curr->right != NULL)
                push(&s, curr->right);
    
            push(&s, curr);
            curr = curr->left;
        }
    
        curr = pop(&s);
    
        if (curr->right != NULL && s.s[s.tos] == curr->right)
        {
            pop(&s);
            push(&s, curr);
            curr = curr->right;
        }
        else
        {
            printf(""%d\t"", curr->data);
            curr = NULL;
        }
    
    }while (s.tos != -1);
}

int main()
{
    node *root;
    root = create();

    printf(""\nThe inorder traversal of tree is:\n"");
    inorder(root);

    printf(""\nThe postorder traversal of tree is:\n"");
    postorder(root);

    printf(""\nThe levelorder traversal of tree is:\n"");
    levelorder(root);

    printf(""\nThe preorder traversal of tree is:\n"");
    preorder(root);

    return 0;
}",62,1794,1165
"void multiply(int **arr1, int **arr2, int m, int n, int p, int q, int **product)
{
    int sum = 0;

    for(int c = 0 ; c < m ; c++)
        for(int d  = 0 ; d < q; d++)
        {
            for(int k = 0 ; k < p ; k++)
                sum += arr1[c][k] * arr2[k][d];

            product[c][d] = sum;
            sum = 0;
        }
}

int main()
{
    int m, n, p, q;

    printf(""Enter dimensions of first array:"");
    scanf(""%d %d"", &m, &n);

    int **arr1 = calloc(m, sizeof(int*));

    for(int i = 0 ; i < m ; i++)
        arr1[i] = calloc(n, sizeof(int));

    for(int i = 0 ; i < m; i++)
        for(int j = 0; j < n; j++)
            scanf(""%d"", &arr1[i][j]);

    printf(""Enter dimensions of second array:"");
    scanf(""%d %d"", &p, &q);

    int **arr2 = calloc(p, sizeof(int*));

    for(int i = 0 ; i < p ; i++)
        arr2[i] = calloc(q, sizeof(int));

    for(int i = 0 ; i < p; i++)
        for(int j = 0; j < q; j++)
            scanf(""%d"", &arr2[i][j]);

    if(n != p)
    {
        printf(""Invalid Order"");
        return 0;
    }

    else if (n == p)
    {
        int **product = calloc(m, sizeof(int*));

        for(int i = 0 ; i < m ; i++)
            product[i] = calloc(q, sizeof(int));

        multiply(arr1, arr2, m, n, p, q, product);

        printf(""Product: \n"");

        for(int i = 0 ; i < m ; i++)
        {
            for(int j = 0; j < q ; j++)
                printf(""%d \t"", product[i][j]);

            printf(""\n"");
        }

    }

}",62,1795,595
"#define MAX 10
#define true 1
#define false 0

typedef struct 
{
    char item[MAX];
    int top;
}stack;

void isFull()
{
    printf(""\nError! Stack is full!\n"");
}

int isEmpty()
{
    printf(""\nError ! Stack is empty!\n"")
}

void push(stack* ps, char x)
{
    if(ps->top == MAX - 1)
        isFull();
    else
        ps->item[++(ps->top)] = x;
}

char pop(stack* ps)
{
    if(ps->top > -1)
        return ps->item[(ps->top)--];
    else
    {
        isEmpty();  
        return '\0';
    }
}

void display(stack* ps)
{
    if(ps->top > -1)
    {
        for(int i = 0 ; i < ps->top ; i++)
            printf(""%d  "", ps->item[i]);
    }
}

int main()
{
    printf()
}

",62,1796,274
"typedef struct node* nptr;
typedef struct node
{
    int data;
    nptr next;
} node;

nptr createNode(int x)
{
    nptr temp = (nptr)malloc(sizeof(node));
    temp -> data = x;
    temp -> next = NULL;

    return temp;
}

void insertRear(nptr &head, int x)
{
    if (head == NULL)
    {
        head = createNode(x);
        return;
    }

    nptr temp = head;

    while (temp -> next != NULL)
        temp = temp -> next;

    temp -> next = createNode(x);
}

void display(nptr head)
{
    nptr temp = head;

    while (temp)
    {
        printf(""%d --> "", temp -> data);
        temp = temp -> next;
    }

    printf(""NULL\n"");
}

void removeDuplicate(nptr head)
{
    if (head == NULL || head -> next == NULL)
        return;

    nptr temp1 = head, temp2 = head -> next;

    if (temp1 -> data == temp2 -> data)
    {
        temp1 -> next = temp2 -> next;
        free(temp2);
    }
    else
        temp1 = temp1 -> next;

    removeDuplicate(temp1);
}

void removeDuplicate2(nptr head)
{
    if (head == NULL)
        printf(""Empty list\n"");

    nptr curr = head, dup = NULL;

    while(curr != NULL && curr -> next != NULL)
    {
        if (curr -> data == curr -> next -> data)
        {
            dup = curr -> next;
            curr -> next = dup -> next;
            free(dup);
        }
        else
            curr = curr -> next;
    }
}

int main()
{
    printf(""1. Insert Rear     2. Display     3. Remove Duplicates     0. Exit\n"");
    int ch, ele;

    nptr head = NULL;

    do
    {
        printf(""Command: ""); scanf(""%d"", &ch);

        switch(ch)
        {
            case 1:
                    
                    scanf(""%d"", &ele);
                    insertRear(head, ele);
                    break;

            case 2:
                    display(head);
                    break;

            case 3: 
                    removeDuplicate2(head);
        }

    }while(ch != 0);
}",62,1797,639
"#define MAX 40

typedef struct 
{
    int stack1[MAX];
    int stack2[MAX];
    int top1,top2;
}QUEUE;

void add(QUEUE* q, int ele)
{
    if(q->top1 == MAX)
    {
        printf(""QUEUE FULL \n"");
        return;
    }
    
    q->top1++;
    q->stack1[q->top1] = ele;
}

int del(QUEUE* q)
{
    if(q->top1 == -1 && q->top2 == -1)
    {
        printf(""QUEUE EMPTY\n"");
        return -1;
    }

    if(q->top2 == -1)
        while(q->top1 != -1)
            q->stack2[++(q->top2)] = q->stack1[(q->top1)--];
        
    return q->stack2[(q->top2)--];
}

int main()
{
    QUEUE q;

    q.top1 = -1;
    q.top2 = -1;

    int ch, n;

    do
    {
        printf(""\n\n1. Insert\n2. Delete\n0. Exit"");
        printf(""\nEnter Choice? : "");
        scanf(""%d"", &ch);

        switch (ch)
        {
            case 1:
                printf(""\nEnter number: "");
                scanf(""%d"", &n);
                add(&q, n);
                break;

            case 2:
                printf(""\n%d deleted \n"", del(&q));
                break;
        }

    }while (ch != 0);
    
    return 0;
}",62,1798,432
"typedef struct
{
    char *c[20];
    int front;
    int rear;
}queue;

void enqueueright(queue *q,char* n)
{
    if (q->rear == 20)
        printf(""Side Full\n"");
    else
        q->c[(q->rear)++]=n;
}

void enqueueleft(queue *q,char* n)
{
    if (q->front == 0)
        printf(""Side Full\n"");
    else
        q->c[--(q->front)]=n;
}

void dequeueleft(queue *q)
{
    if (q->front==q->rear)
        printf(""Queue Empty"");

    else
        printf(""\n%s deleted"", q->c[(q->front)++] );

}

void dequeueright(queue *q)
{
    if (q->front==q->rear)
        printf(""Queue Empty"");
    
    else
        printf(""\n%s deleted"", q->c[--(q->rear)] );
}

void display(queue *q)
{
    int i;

    for (i = q->front ; i<q->rear ; i++)
        printf(""%s\t"",q->c[i]);
    
    printf(""\n"");
}

int main()
{
    int z=0,k,e;
    queue q;

    q.front=10;
    q.rear=10;

    printf(""1. Enqueue Right\n2. Enqueue Left\n3. Dequeue Left\n4. Dequeue Right\n5. Display \n6. Exit\n"");
    
    while (z == 0)
    {
        printf(""\nCommand: "");
        scanf(""%d"",&k);
        switch(k)
        {
            case 1:
            {
                printf(""\nEnter String: "");
                char *n = malloc(30);
                scanf(""%s"", n);

                enqueueright(&q,n);
                break;
            }
            
            case 2:
            {
                printf(""\nEnter String: "");
                char *n = malloc(30);
                scanf(""%s"", n);

                enqueueleft(&q,n);
                break;
            }
            
            case 3:
            {
                dequeueleft(&q);
                break;
            }
            
            case 4:
            {
                
                printf (""\n:::::::::OPERATION NOT ALLOWED:::::::\n"");

                break;
            }
            
            case 5:
            {
                display(&q);
                break;
            }
            
            case 6:
            {
                z=1;
            }
        }
    }
}",62,1799,694
"#define PORT 1327

void main () {
    struct sockaddr_in serverAddress;
    struct sockaddr_in clientAddress;

    int sockaddr_len = sizeof(struct sockaddr_in);

    
    int serverfd = socket(AF_INET, SOCK_STREAM, 0);

    
    if (serverfd == -1) {
        printf(""Couldn't create socket! Exited.\n"");
        exit(0);
    } else {
        printf(""Socket created successfully!\n"");
    }

    serverAddress.sin_family = AF_INET;
    serverAddress.sin_addr.s_addr = inet_addr(""127.0.0.1"");
    serverAddress.sin_port = PORT;

    
    int status = bind(serverfd, (struct sockaddr*) &serverAddress, sockaddr_len);

    if (status == -1) {
        printf(""Couldn't bind socket! Exited.\n"");
        exit(0);
    } else {
        printf(""Socket binded successfully!\n"");
    }

    
    status = listen(serverfd, 5);

    if (status == -1) {
        printf(""Couldn't start listening! Exited.\n"");
        exit(0);
    } else {
        printf(""Server listening at port: PORT\n\n"");
    }


    while (1) {
        printf(""Server waiting for connection....\n"");

        
        int clientfd = accept(serverfd, (struct sockaddr*) &clientAddress, &sockaddr_len);

        if (clientfd == -1) {
            printf(""Couldn't accept connection request! Exited.\n"");
            exit(0);
        } else {
            char *clientIP = inet_ntoa(clientAddress.sin_addr);
            int clientPort = clientAddress.sin_port;
            printf(""Connection request accepted from "");
            printf(""%s : %d\n"", clientIP, clientPort);
        }

        char ch;

        read(clientfd, &ch, 1);
        ch++;
        write(clientfd, &ch, 1);

        close(clientfd);
        printf(""Connection closed\n"");
    }
}",62,1800,557
"typedef struct node* nptr;
typedef struct node
{
    int data;
    nptr left, right;
}node;

nptr createNode(int x)
{
    nptr temp = (nptr)malloc(sizeof(node));
    temp -> data = x;
    temp -> left = temp -> right = NULL;

    return temp;
}

nptr insertLeft(nptr head, int x)
{
    if (head == NULL)
        return createNode(x);

    else
    {
        nptr temp = createNode(x);
        temp -> right = head;
        head -> left = temp;

        return temp;
    }
}

nptr insertRight(nptr head, int x)
{
    if (head == NULL)
        return createNode(x);

    else
    {
        nptr curr = head;

        while(curr -> right != NULL)
            curr = curr -> right;
        
        nptr temp = createNode(x);
        curr -> right = temp;
        temp -> left = curr;

        return head;
    }
}

nptr deleteLeft(nptr head)
{
    if(head == NULL)
        return head;

    if(head -> left == NULL && head -> right == NULL)
    {
        printf(""%d deleted\n"", head -> data);
        free(head);
        return NULL;
    }

    nptr temp = head;
    head = head -> right;
    head -> left = NULL;
    
    printf(""%d deleted\n"", temp -> data);
    free(temp);

    return head;
}

nptr deleteRight(nptr head)
{
    if(head == NULL)
        return head;

    if(head -> left == NULL && head -> right == NULL)
    {
        printf(""%d deleted\n"", head -> data);
        free(head);
        return NULL;
    }

    nptr curr = head;

    while(curr -> right != NULL)
        curr = curr -> right;

    (curr -> left) -> right = NULL;

    printf(""%d deleted\n"", curr -> data);
    free(curr);
    return head;
}

void display(nptr head)
{
    printf(""                 "");
    
    if(head == NULL)
        printf(""EMPTY"");

    while(head)
    {
        printf("" %d "", head -> data);
        head = head -> right;
    }

    printf(""\n"");
}

int main()
{
    nptr head = NULL;
    printf(""1. insertLeft 2. insertRight 3. deleteLeft 4. deleteRight 5. display 6. exit\n"");

    int ch,  ele;

    do
    {
        printf(""Command: ""); scanf(""%d"", &ch);
        switch(ch)
        {
            case 1: 
                    scanf(""%d"", &ele);
                    head = insertLeft(head, ele);
                    break;

            case 2: 
                    scanf(""%d"", &ele);
                    head = insertRight(head, ele);
                    break;

            case 3: head = deleteLeft(head);
                    break;
            
            case 4: head = deleteRight(head);
                    break;

            case 5: display(head);
        }

    }while(ch != 6);
}",62,1801,841
"typedef struct node* nptr;
typedef struct node
{
    int data;
    nptr lchild, rchild;
}node;

nptr createNode(int x)
{
    nptr temp = (nptr)malloc(sizeof(node));
    temp->lchild = temp->rchild = NULL;
    temp->data = x;
    return temp;
}

nptr insertNode(nptr root, char path[])
{
    int i = 0;
    nptr parent = NULL, curr = root;

    while(curr && path[i])
    {
        parent = curr;

        if (path[i] == 'L')
            curr = parent -> lchild;
        else if (path[i] == 'R')
            curr = parent -> rchild;

        i++;
    }

    if (curr == NULL && path[i] == '\0')
    {
        printf(""Path Found! Enter element: "");
        int x; scanf(""%d"", &x);

        if (path[i - 1] == 'R')
            parent -> rchild = createNode(x);
        else if (path[i - 1] == 'L')
            parent -> lchild = createNode(x);
    }
    else
        printf(""Path error!"");

    return root;
}

void inorder(nptr root)
{
    if (root == NULL)
        return;
    
    inorder(root->lchild);
    printf(""%d "", root->data);
    inorder(root->rchild);
}

void preorder(nptr root)
{
    if (root == NULL)
        return;

    printf(""%d "", root->data);
    preorder(root->lchild);
    preorder(root->rchild);
}

void postorder(nptr root)
{
    if (root == NULL)
        return;

    postorder(root->lchild);
    postorder(root->rchild);
    printf(""%d "", root->data);
}

int main()
{
    printf(""Enter Value of Root: "");
    int key;
    scanf(""%d"", &key);

    nptr root = createNode(key);

    int ch;
    
    printf(""1. Insert node    2. In-Order    3. Pre-Order    4. Post-Order      5. Exit\n"");

    do
    {
        printf(""Command: "");
        scanf(""%d"", &ch);
        
        switch (ch)
        {
            case 1: char P[10];
                    printf(""Enter Path: "");
                    scanf(""%s"", P);
                    root = insertNode(root, P);
                    break;

            case 2: inorder(root);
                    printf(""\n"");
                    break;

            case 3: preorder(root);
                    printf(""\n"");
                    break;

            case 4: postorder(root);
                    printf(""\n"");
                    break;
        }

    }while(ch != 5);
}",62,1802,748
"#define CAPACITY 100

typedef struct
{
    char c[CAPACITY];
    int front;
    int rear;
}queue;

void enqueueright(queue *q,char n)
{
    if (q->rear == CAPACITY)
        printf(""Side Full\n"");
    
    else
        q->c[(q->rear)++]=n;
}

void enqueueleft(queue *q,char n)
{
    if (q->front==0)
        printf(""Side Full\n"");
    
    else
        q->c[--(q->front)]=n;
}

char dequeueleft(queue *q)
{
    if (q->front==q->rear)
    {
        printf(""Queue Empty"");
        return '\0';
    }
    
    else
        return q->c[(q->front)++];
}

char dequeueright(queue *q)
{
    if (q->front==q->rear)
    {
        printf(""Queue Empty"");
        return '\0';
    }
    
    else
        return q->c[--(q->rear)];
}

void display(queue *q)
{
    int i;

    for (i=q->front;i<q->rear;i++)
        printf(""%c "",q->c[i]);
    
    printf(""\n"");
}

int getSize(queue *q)
{
    return q->rear - q->front;
}

int main()
{
    queue q;
    q.front = CAPACITY/2;
    q.rear = CAPACITY/2;

    char word[20];
    int isPalin  = 1;          

    printf(""Enter word: "");
    scanf(""%s"", word);

    for(int i = 0 ; i < strlen(word) ; i++)
        enqueueright(&q, word[i]);


    for(int i = 0 ; i < strlen(word)/2 ; i++)
        if (dequeueleft(&q) != dequeueright(&q))
        {
            isPalin = 0;              
            break;
        }

    isPalin ? printf(""YES\n"") : printf(""NO\n"");
}",62,1803,574
"typedef struct node* nptr;
typedef struct node
{
    int data;
    nptr left, right;
}node;

nptr createNode(int x)
{
    nptr temp = (nptr)malloc(sizeof(node));
    temp -> data = x;
    temp -> left = temp -> right = NULL;

    return temp;
}

nptr insertLeft(nptr head, int x)
{
    if (head == NULL)
    {
        nptr temp = createNode(x);
        temp -> left = temp -> right = temp;
        return temp;
    }

    else
    {
        nptr temp = createNode(x);
        temp -> left = head -> left;
        temp -> right = head;

        head -> left = temp;
        (temp -> left) -> right = temp;

        return temp;
    }
}

nptr insertRight(nptr head, int x)
{
    if (head == NULL)
    {
        nptr temp = createNode(x);
        temp -> left = temp -> right = temp;
        return temp;
    }

    else
    {
        nptr curr = head;

        while(curr -> right != head)
            curr = curr -> right;
        
        nptr temp = createNode(x);

        temp -> left = head -> left;
        temp -> right = head;

        head -> left = temp;
        (temp -> left) -> right = temp;

        return head;
    }
}

nptr deleteLeft(nptr head)
{
    if(head == NULL)
        return head;

    if(head -> left == head && head -> right == head)
    {
        printf(""%d deleted\n"", head -> data);
        free(head);
        return NULL;
    }

    nptr temp = head;
    head = head -> right;
    head -> left = temp -> left;
    
    printf(""%d deleted\n"", temp -> data);
    free(temp);

    return head;
}

nptr deleteRight(nptr head)
{
    if(head == NULL)
        return head;

    if(head -> left == head && head -> right == head)
    {
        printf(""%d deleted\n"", head -> data);
        free(head);
        return NULL;
    }

    nptr curr = head;

    while(curr -> right != head)
        curr = curr -> right;

    (curr -> left) -> right = head;
    head -> left = curr -> left;

    printf(""%d deleted\n"", curr -> data);
    free(curr);
    return head;
}

void display(nptr head)
{
    nptr curr = head;
    printf(""                 "");
    
    if(curr == NULL)
        printf(""EMPTY"");

    while(curr -> right != head)
    {
        printf("" %d "", curr -> data);
        curr = curr -> right;
    }

    printf("" %d\n"", curr -> data);
}

int main()
{
    nptr head = NULL;
    printf(""1. insertLeft 2. insertRight 3. deleteLeft 4. deleteRight 5. display 6. exit\n"");

    int ch,  ele;

    do
    {
        printf(""Command: ""); scanf(""%d"", &ch);
        switch(ch)
        {
            case 1: 
                    scanf(""%d"", &ele);
                    head = insertLeft(head, ele);
                    break;

            case 2: 
                    scanf(""%d"", &ele);
                    head = insertRight(head, ele);
                    break;

            case 3: head = deleteLeft(head);
                    break;
            
            case 4: head = deleteRight(head);
                    break;

            case 5: display(head);
                    break;

            case 6: exit(0);
        }

    }while(ch != 6);
}",62,1804,987
"#define PORT 9734

void main() {
    
    int serverfd = socket(AF_INET, SOCK_STREAM, 0);

    
    if (serverfd == -1) {
        printf(""Couldn't create socket. Exiting!\n"");
        exit(0);
    } else {
        printf(""Socket created \n"");
    }

    
    struct sockaddr_in server_address;
    int len = sizeof(server_address);

    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = inet_addr(""127.0.0.1"");
    server_address.sin_port = PORT;

    
    int status = connect(serverfd, (struct sockaddr *)&server_address, len);
    
    
    if (status == -1) {
        printf(""Couldn't connect. Exiting!\n"");
        exit(0);
    } else {
        printf(""Connection established!\n\n"");
    }

    char time[100];

    read(serverfd, time, 100);
    printf(""Server Time: %s\n"", time);

    char processid[100];

    read(serverfd, processid, 100);
    printf(""Server proccess ID: %s\n"", processid);

    
    close(serverfd);
}",62,1805,352
"typedef struct node* nodeptr;

typedef struct node
{
    int data;
    nodeptr link;
}node;

void add(nodeptr* head,int x)
{
    nodeptr temp=malloc(sizeof(node));
    nodeptr t;

    temp->data=x;
    temp->link=NULL;

    if(!(*head))
        *head=temp;
    else
    {
        for(t=(*head);t->link;t=t->link);
        t->link=temp;
    }
}

void del(nodeptr a)
{
    nodeptr t;

    for(t=a->link;t;)
    {
        if(a->data==t->data)
        {
            a->link=t->link;
            free(t);
            t=a->link;
        }
        else
        {
            a=a->link;
            t=t->link;
        }
    }
}

void display(nodeptr a)
{
    printf(""\n"");

    for(;a;a=a->link)
        printf(""\t%d"",a->data);
}

int main()
{
    nodeptr a,b,u,in;
    int n,i,t;
    
    a=NULL;
    
    printf(""\nEnter number elements of list"");
    scanf(""%d"",&n);
    
    printf(""\nEnter elements"");
    for(i=0;i<n;i++)
    {
        scanf(""%d"",&t);
        add(&a,t);
    }
    
    display(a);
    del(a);
    display(a);
}",62,1806,414
"typedef struct node* nodeptr;
typedef struct node{
    int data;
    nodeptr link;
}node;


void add(nodeptr head,int x){
    nodeptr temp=malloc(sizeof(node));
    nodeptr t;
    temp->data=x;
    temp->link=head;
        for(t=head;t->link!=head;t=t->link);
        t->link=temp;
}
void init(nodeptr* head){
    nodeptr temp=malloc(sizeof(node));
    temp->data=-1;
    temp->link=temp;
    *head=temp;
}
void merge(nodeptr a,nodeptr b){
    nodeptr trail1,trail2,temp1,temp2,i;
    trail1=a;
    trail2=b;
    temp1=trail1->link;
    temp2=trail2->link;
    while(temp1!=a&&temp2!=b){
        if(temp1->data<temp2->data){
            trail1=trail1->link;
            temp1=temp1->link;
        }
        else if(temp1->data==temp2->data){
            trail2->link=temp2->link;
            temp2->link=temp1->link;
            temp1->link=temp2;
            temp2=trail2->link;
            trail1=trail1->link->link;
            temp1=temp1->link->link;
        }
        else{
            trail2->link=temp2->link;
            trail1->link=temp2;
            temp2->link=temp1;
            temp2=trail2->link;
            trail1=trail1->link;
        }
    }
    if(temp2!=b){
    trail1->link=temp2;
    for(i=temp2;i->link!=b;i=i->link);
    i->link=temp1;
    free(trail2);
}
}
void display(nodeptr a){
    nodeptr t=a;
    printf(""\n"");
    for(a=a->link;a!=t;a=a->link){
        printf(""\t%d"",a->data);
    }
}
int main(){
    nodeptr a,b,u,in;
    int n,m,i,t;
    init(&a);
    init(&b);
    printf(""\nEnter number elements of first list"");
    scanf(""%d"",&n);
    printf(""\nEnter elements"");
    for(i=0;i<n;i++){
        scanf(""%d"",&t);
        add(a,t);
    }
    printf(""\nEnter number elements of second list"");
    scanf(""%d"",&m);
    printf(""\nEnter elements"");
    for(i=0;i<m;i++){
        scanf(""%d"",&t);
        add(b,t);
    }
    display(a);
    display(b);
    merge(a,b);
    display(a);
}",62,1807,740
"#include ""charStack.h""




void strrev(char *str)
{
    int i = strlen(str) - 1, j = 0;

    char ch;
    
    while (i > j)
    {
        ch = str[i];
        str[i] = str[j];
        str[j] = ch;
        
        i--;  j++;
    }
    
}

int toInt(char c)
{
    return c - '0';
}

int main()
{
    stack s;
    char exp[15];

    printf(""Enter exp: "");
    scanf(""%s"", exp);

    strrev(exp);        
                        


    for(int i = 0 ; exp[i] != '\0' ; i++)
    {
        char token = exp[i];

        if (token >= '0' && token <= '9')
            push(&s, token);
        
        else
        {
            char a = pop(&s);                       
            char b = pop(&s);

            switch(token)
            {
                case '+':   push(&s, toInt(a) + toInt(b) + '0');
                            break;

                case '-':   push(&s, toInt(a) - toInt(b) + '0');
                            break;

                case '/':   push(&s, toInt(a) / toInt(b) + '0');
                            break;

                case '*':   push(&s, toInt(a) * toInt(b) + '0');
                            break;
            }

        }
    }

    printf(""Ans = %d \n"", toInt(pop(&s)));
}",62,1808,431
"#include ""charStack.h""



int isOperand(char ch)      
{ 
    return (ch >= 'a' && ch <= 'z');
} 

int prec(char ch)           
{ 
    if (ch == '+' || ch == '-')
        return 1; 

    if (ch == '*' || ch == '/')
        return 2; 

    if (ch == '^')
        return 3;  
    
    return -1; 
} 

int infixToPostfix(char* exp, char* ans) 
{ 
    int i, k = 0; 

    stack s;

    for (i = 0 ; exp[i] != '\0' ; i++) 
    { 
    
        if (isOperand(exp[i]))      
            ans[k++] = exp[i]; 
        
        else if (exp[i] == '(')     
            push(&s, exp[i]); 
        
        else if (exp[i] == ')')     
        { 
            while (!isEmpty(&s) && top(&s) != '(') 
                ans[k++] = pop(&s); 
            
            pop(&s);  
        } 
        
        else            
        { 
            while ( !isEmpty(&s) && prec(exp[i]) <= prec(top(&s)) ) 
                ans[k++] = pop(&s); 
            
            push(&s, exp[i]); 
        } 
    } 

    while (!isEmpty(&s))            
        ans[k++] = pop(&s); 

    ans[k- 1] = '\0';  
} 

int main() 
{ 
    char exp[100], ans[100];
    scanf(""%s"", exp);   
    
    infixToPostfix(exp, ans);

    printf(""%s \n"", ans); 
} ",62,1809,480
"typedef struct node* nptr;
typedef struct node
{
    nptr next;
    int data;
}node;

nptr createNode(int x)
{
    nptr temp = (nptr)malloc(sizeof(node));
    temp -> data = x;
    temp -> next = NULL;

    return temp;
}

void push(nptr &stack, int x)
{
    nptr temp = createNode(x);
    temp -> next = stack;
    stack = temp;
}

int pop(nptr &stack)
{
    if(stack == NULL)
        return -1;

    nptr temp = stack;
    stack = stack -> next;

    int x = temp -> data;
    free(temp);
    return x;
}

void display(nptr &stack)
{
    if (stack == NULL)
    {   
        printf(""EMPTY\n"");
        return;
    }

    nptr curr = stack;

    while(curr)
    {
        printf(""    %d \n"", curr -> data);
        curr = curr -> next;
    }
}

int main()
{
    printf(""1. Push    2. Pop    3. Display    0.Exit\n"");
    int ch, ele;

    nptr stack = NULL;

    do
    {
        printf(""Command: ""); scanf(""%d"", &ch);

        switch(ch)
        {
            case 1:     
                    printf(""Element: ""); scanf(""%d"", &ele);
                    push(stack, ele);
                    break;
            
            case 2:
                    ele = pop(stack);
                    
                    if(ele == -1)
                        printf(""Stack empty!\n"");
                    else
                        printf(""%d popped!\n"", ele);
                        
                    break;

            case 3:
                    display(stack);
        }

    }while(ch != 0);
}",62,1810,487
"int selectionSort(int x[], int n);
int main()
{
    int z,res;
    printf(""enter the no.of elements:"");
    scanf(""%d"",&z);
    int arr[z];
    int i;
    printf(""the elements are:\n"");
    for(i=0;i<z;i++)
    {
        scanf(""%d"",&arr[i]);
    }
    res = selectionSort(arr,z); 
    return 0;
}
int selectionSort(int x[], int n)
{
    int i,j,temp,flag = 0;
    for(i=0;i<n;i++)
    {
        for(j=i+1;j<n;j++)
        {
            if(x[i] > x[j])
            {
                temp = x[j];
                x[j] = x[i];
                x[i] = temp;
                flag = 1;
            }
        }
        if(flag == 0)
        {
            break;
        }
    }
    printf(""sorted array:\n"");
    for(i=0;i<n;i++)
    {
        printf(""%d\n"",x[i]);
    }
}
",63,1811,307
"int gateOperation();
int main()
{
    int k,n;
    scanf(""%d"", &n);
    scanf(""%d"", &k);
    gateOperation(n,k);
    return 0;
}
int gateOperation(int n, int k)
{
    int i,j;
    int maxAND = 0;
    int maxOR = 0;
    int maxEXP = 0;
    for(i=1;i<=n;i++)
    {
        for(j=i+1;j<=n;j++)
        {
            if(((i & j) > maxAND) && ((i & j) < k))
            {
                maxAND = i & j;
            }
            if(((i | j) > maxOR) && ((i | j) < k))
            {
                maxOR = i | j;
            }
            if(((i ^ j) > maxEXP) && ((i ^ j) < k))
            {
                maxEXP = i ^ j;
            }
        }
    }
    printf(""%d \n%d\n%d"", maxAND, maxOR, maxEXP);
}
",63,1812,284
"int power();
int main()
{
    int n;
    int count = 0;
    printf(""enter a number:"");
    scanf(""%d"",&n);
    int temp = n;
    while(temp!=0)
    {
        count++;
        temp/=10;
    }
    printf(""count:%d\n"",count);
    int rem = 0, sum = 0;
    int t = n;
    int i;
    while(t!=0)
    {
        int mul=1;
        rem = t%10;
        for(i=1;i<=count;i++)
        {
            mul = mul*rem;
        }
        printf(""Power of %d is : %d\n"",rem,mul);
        sum = sum+mul;
        t = t/10;   
    }
    if(sum == n)
    {
        printf(""ARMSTRONG NUMBER"");
    }
    else
    printf(""NOT ARMSTRONG NUMBER"");
    return 0;
}
",63,1813,255
"void display_nodes();
int length();
struct node
{
    int data;
    struct node*ptr;
};
int main()
{
    int choice;
    printf(""Press 1 for Creation or else Press 0 for Termination:"");
    scanf(""%d"",&choice);
    struct node*head,*temp;
    head = temp = NULL;
    struct node*newnode;
    while(choice!=0)
    {
        newnode = (struct node*) malloc (sizeof(struct node));
        printf(""Enter the Data:"");
        scanf(""%d"",&newnode->data);
        newnode->ptr = NULL;
        
        if(head == NULL)
        {
            head = temp = newnode;
        }
        else
        {
            temp->ptr = newnode;
            temp = newnode;
        }
        printf(""Do you want ot enter more?(1/0)"");
        scanf(""%d"",&choice);
    }
    temp = head;
    display_nodes(temp);
    length(temp);
    getch();
}
void display_nodes(struct node*temp1)
{
    printf(""The elements are:"");
    if(temp1 == 0)
    {
        printf(""NO DATA"");
    }
    else
    while(temp1!=NULL)
    {
        printf(""%d\t"",temp1->data);
        temp1 = temp1->ptr;
    }
}
int length(struct node*temp2)
{
    int count = 0;
    printf(""\nThe Length Of The Linked List is:"");
    while(temp2!=NULL)
    {
        count++;
        temp2 = temp2->ptr;
    }
    printf(""%d"",count);
}

",63,1814,427
"int main()
{
    int l,n,i;
    scanf(""%d"",&l);
    scanf(""%d"",&n);
    for(i=l;i<=n;i++)
    {
        if(i==1)
     {
        printf(""One\n"");
     }
    else if(i==2)
     {
        printf(""Two\n"");
     }
    else if(i==3)
     {
        printf(""Three\n"");
     }
    else if(i==4)
     {
        printf(""Four\n"");
     }
    else if(i==5)
     {
        printf(""Five\n"");
     }
    else if(i==6)
     {
        printf(""Six\n"");
     }
    else if(i==7)
     {
        printf(""Seven\n"");
     }
    else if(i==8)
     {
        printf(""Eight\n"");
     }
    else if(i==9)
     {
        printf(""Nine\n"");
     }
     else if(i%2==0)
     {
        printf(""even\n"");
     }
     else
     printf(""odd\n"");
    }
    return 0;
}
",63,1815,311
"void display_node();
void reverse_node();
struct node
{
    int data;
    struct node*ptr;
};
int main()
{
    int choice;
    printf(""PRESS 1 FOR CREATION OR ELSE PRESS 0 FOR TERMINATION:"");
    scanf(""%d"",&choice);
    struct node*head,*temp;
    head = temp = NULL;
    struct node*newnode;
    while(choice!=0)
    {
        newnode = (struct node*) malloc (sizeof(struct node));
        printf(""Enter the data:"");
        scanf(""%d"",&newnode->data);
        newnode->ptr = NULL;
        
        if(head == NULL)
        {
            head = temp = newnode;
        }
        else
        {
            temp->ptr = newnode;
            temp = newnode;
        }
        printf(""DO YOU WANT TO ENTER MORE?(1/0)"");
        scanf(""%d"",&choice);
    }
    temp = head;
    display_node(temp);
    reverse_node(head,temp);
    getch();    
}
void display_node(struct node*temp1)
{
    printf(""THE ELEMENTS ARE:"");
    while(temp1!=NULL)
    {
        printf(""%d\t"",temp1->data);
        temp1 = temp1->ptr;
    }
}
void reverse_node(struct node*head1, struct node*temp1)
{
    struct node*prevnode;
    if(head1!=NULL)
    {
        prevnode = head1;
        temp1 = head1->ptr;
        head1 = head1->ptr;
        prevnode->ptr = NULL;
    }
    while(head1!=NULL)
    {
        head1 = head1->ptr;
        temp1->ptr = prevnode;
        prevnode = temp1;
        temp1 = head1;
    }
    head1 = prevnode;
    printf(""\nAFTER REVERSE OPERATION:"");
    while(head1!=NULL)
    {
        printf(""%d\t"",head1->data);
        head1 = head1->ptr;
    }
    return;
}
",63,1816,543
"int checkPrime(int n);
int main()
{
    int l,u,check,temp,i;
    printf(""enter l and u:\n"");
    scanf(""%d%d"",&l,&u);
    if(l>u)
    {
        temp = l;
        l = u;
        u = temp;
    }
    for(i = l;i <= u;i++)
    {
        if(i == 1 || i == 0)
        continue;
        check = 0;
        check = checkPrime(i);
        if(check == 0)
        {
           printf(""%d\n"",i);
        } 
    }
    return 0;
}
int checkPrime(int n)
{
    int flag = 0,j;
    for (j = 2;j <= n/2; j++)
    {
        if(n%j == 0)
        {
           flag = 1;
           break;
        }
    }
    return flag;
}
",63,1817,254
"int main()
{
    system(""cls"");
    int a[100];
    int n,i,j,k;
    printf(""Enter the no. of elements:"");
    scanf(""%d"",&n);
    for(i=0;i<n;i++)
    {
        scanf(""%d"",&a[i]);
    }
    for(i=0;i<n;i++)
    {
        for(j=i+1;j<n;j++)
        {
            if(a[i] == a[j])
            {
                for(k=j;k<n;k++)
                {
                    a[k] = a[k+1];
                }
                n--;
                j--;
            }
        }
    }
    for(i=0;i<n;i++)
    {
        printf(""%d\t"",a[i]);
    }
    getch();
}
",63,1818,230
"struct node
{
    int data;
    struct node*link;
};
int main()
{
    int choice = 1;
    struct node*head,*temp;
    head = temp = NULL;
    struct node*newnode;
    while(choice)
    {
        newnode = (struct node*) malloc(sizeof(struct node));
        printf(""Enter the element in the node:"");
        scanf(""%d"",&newnode->data);
        newnode->link = NULL;
        if(head == NULL)
        {
            head = temp = newnode;
        }
        else
        {
            temp->link = newnode;
            temp = newnode;
        }
        printf(""Do you want to enter more nodes?(0/1)"");
        scanf(""%d"",&choice);
    }
    temp = head;
    int count = 0;
    printf(""THE ELEMENTS PRESENT IN THE NODE ARE\n"");
    while(temp!=NULL)
    {
        count++;
        printf(""%d\t"",temp->data);
        temp = temp->link;
    }
    printf(""\nCount : %d"",count);
    return 0;
}
",63,1819,291
"void display_node();
struct node
{
    int data;
    struct node*link;
};
int main()
{
    int choice = 1;
    struct node*head,*temp;
    head = temp = NULL;
    struct node*newnode;
    while(choice!=0)
    {
        newnode = (struct node*) malloc (sizeof(struct node));
        printf(""Enter the data:"");
        scanf(""%d"",&newnode->data);
        newnode->link = NULL;
        
        if(head == NULL)
        {
            head = temp = newnode;
        }
        else
        {
            temp->link = newnode;
            temp = newnode;
        }
        printf(""Do you want to enter more node?(1/0)"");
        scanf(""%d"",&choice);
    }
    temp = head;
    display_node(temp);
    getch();
}
void display_node(struct node*temp1)
{
    printf(""The Elements are:"");
    while(temp1!=NULL)
    {
        printf(""%d\t"",temp1->data);
        temp1 = temp1->link;
    }
}
",63,1820,290
"void display_node();
void insert_at_begin();
struct node
{
    int data;
    struct node*ptr;
};
int main()
{
    int choice;
    printf(""Enter 1 for Creation or 0 for Termination:"");
    scanf(""%d"",&choice);
    struct node*head,*temp;
    head = temp = NULL;
    struct node*newnode;
    while(choice!=0)
    {
        newnode = (struct node*) malloc (sizeof(struct node));
        printf(""Enter the data:"");
        scanf(""%d"",&newnode->data);
        newnode->ptr = NULL;
        
        if(head == NULL)
        {
            head = temp = newnode;
        }
        else
        {
            temp->ptr = newnode;
            temp = newnode;
        }
        printf(""DO you want to enter more?(1/0)"");
        scanf(""%d"",&choice);
    }
    temp = head;
    display_node(temp);
    insert_at_begin(head,temp);
    getch();    
}
void display_node(struct node*temp1)
{
    printf(""The elements are:"");
    while(temp1!=NULL)
    {
        printf(""%d\t"",temp1->data);
        temp1 = temp1->ptr;
    }
}
void insert_at_begin(struct node*head1,struct node*temp1)
{
    struct node*tempo;
    tempo = (struct node*) malloc (sizeof(struct node));
    printf(""\nEnter the data:\n"");
    scanf(""%d"",&tempo->data);
    tempo->ptr = temp1;
    head1 = temp1 = tempo;
    printf(""After Insertion:"");
    while(temp1!=NULL)
    {
        printf(""%d\t"",temp1->data);
        temp1 = temp1->ptr;
    }
}
",63,1821,471
"void display_node();
void insert_at_N_position();
struct node
{
    int data;
    struct node*ptr;
};
int main()
{
    int choice;
    printf(""Enter 1 for Creation or 0 for Termination:"");
    scanf(""%d"",&choice);
    struct node*head,*temp;
    head = temp = NULL;
    struct node*newnode;
    while(choice!=0)
    {
        newnode = (struct node*) malloc (sizeof(struct node));
        printf(""Enter the data:"");
        scanf(""%d"",&newnode->data);
        newnode->ptr = NULL;
        
        if(head == NULL)
        {
            head = temp = newnode;
        }
        else
        {
            temp->ptr = newnode;
            temp = newnode;
        }
        printf(""Do you want to enter more?(1/0)"");
        scanf(""%d"",&choice);
    }
    temp = head;
    display_node(temp);
    insert_at_N_position(head,temp);
    getch();
}
void display_node(struct node*temp1)
{
    printf(""The Elements are:"");
    while(temp1!=NULL)
    {
        printf(""%d\t"",temp1->data);
        temp1 = temp1->ptr;
    }
}
void insert_at_N_position(struct node*head1, struct node*temp1)
{
    int pos,i;
    printf(""\nAt what position you want to insert?\n"");
    scanf(""%d"",&pos);
    struct node*tempo;
    tempo = (struct node*) malloc (sizeof(struct node));
    printf(""Enter the data:"");
    scanf(""%d"",&tempo->data);
    if(pos == 0)
    {
        printf(""After Insertion, the List is:\n"");
        while(temp1!=NULL)
        {
            printf(""%d\t"",temp1->data);
            temp1 = temp1->ptr;
        }
        printf(""\nSORRY!!! NO ADDITIONAL NODE IS INSERTED :("");
        return;
    }
    if(pos == 1)
    {
        tempo->ptr = temp1;
        head1 = temp1 = tempo;
        printf(""After Insertion, The List is:\n"");
        while(temp1!=NULL)
        {
            printf(""%d\t"",temp1->data);
            temp1 = temp1->ptr;
        }
        return;
    }
    for(i=1;i<pos-1;i++)
    {
        temp1 = temp1->ptr;
    }
    tempo->ptr = temp1->ptr;
    temp1->ptr = tempo;
    temp1 = head1;
    printf(""After Insertion, The List is:\n"");
    while(temp1!=NULL)
    {
        printf(""%d\t"",temp1->data);
        temp1 = temp1->ptr;
    }
}
",63,1822,736
"void display_nodes();
void delete_at_end();
struct node
{
    int data;
    struct node*ptr;
};
int main()
{
    int choice;
    printf(""Enter 1 for Creation or Enter 0 for Termination:"");
    scanf(""%d"",&choice);
    struct node*head,*temp;
    head = temp = NULL;
    struct node*newnode;
    while(choice!=0)
    {
        newnode = (struct node*) malloc (sizeof(struct node));
        printf(""Enter the Data:"");
        scanf(""%d"",&newnode->data);
        newnode->ptr = NULL;
        
        if(head == NULL)
        {
            head = temp = newnode;
        }
        else
        {
            temp->ptr = newnode;
            temp = newnode;
        }
        printf(""Do you want to more?(1/0)"");
        scanf(""%d"",&choice);
    }
    temp = head;
    display_nodes(temp);
    delete_at_end(head,temp);
    getch();
}
void display_nodes(struct node*temp1)
{
    printf(""The Elements are:"");
    while(temp1!=NULL)
    {
        printf(""%d\t"",temp1->data);
        temp1 = temp1->ptr;
    }
}
void delete_at_end(struct node*head1, struct node*temp1)
{
    struct node*prevnode;
    while(temp1->ptr!=NULL)
    {
        prevnode = temp1;
        temp1 = temp1->ptr;
    }
    prevnode->ptr = NULL;
    free(temp1);
    prevnode = head1;
    printf(""\nAfter Deletion:"");
    while(prevnode!=NULL)
    {
        printf(""%d\t"",prevnode->data);
        prevnode = prevnode->ptr;
    }
}
",63,1823,474
"struct node
{
    int data;
    struct node*link;
};
int insert_at_end(struct node*temp1)
{
    struct node*tempo;
    tempo = (struct node*) malloc (sizeof(struct node));
    printf(""Enter the data:"");
    scanf(""%d"",&tempo->data);
    tempo->link = NULL;
    temp1->link = tempo;
}
int main()
{
    int choice = 1;
    struct node*head,*temp;
    head = NULL;
    struct node*newnode;
    while(choice)
    {
        newnode = (struct node*) malloc (sizeof(struct node));
        printf(""Enter the element in the node:"");
        scanf(""%d"",&newnode->data);
        newnode->link = NULL;
        if(head == NULL)
        {
            head = temp = newnode;
        }   
        else
        {
            temp->link = newnode;
            temp = newnode;
        }
        printf(""DO YOU WANT TO ENTER MORE NODES?(0/1)"");
        scanf(""%d"",&choice);
    }
    insert_at_end(temp);
    temp = head;
    int count = 0;
    printf(""THE ENTERED ELEMENTS IN THE NODE ARE\n"");
    while(temp!=NULL)
    {
        count++;
        printf(""%d\t"",temp->data);
        temp = temp->link; 
    }
    printf(""\nCount : %d"",count);
    return 0;
}

",63,1824,388
"int selectionSort(int x[], int n);
int main()
{
    int z,res;
    printf(""enter the no.of elements:"");
    scanf(""%d"",&z);
    int arr[z];
    int i;
    printf(""the elements are:\n"");
    for(i=0;i<z;i++)
    {
        scanf(""%d"",&arr[i]);
    }
    res = selectionSort(arr,z); 
    return 0;
}
int selectionSort(int x[], int n)              
{                                              
    int i,j,temp;                              
    for(i=0;i<n;i++)                           
    {
        for(j=i+1;j<n;j++)
        {
            if(x[i] > x[j])
            {
                temp = x[j];
                x[j] = x[i];
                x[i] = temp;
            }
        }
    }
    printf(""sorted array:\n"");
    for(i=0;i<n;i++)
    {
        printf(""%d\n"",x[i]);
    }
}
",63,1825,284
"int main()
{
    int n;
    printf(""enter the no. of coins:"");
    scanf(""%d"",&n);
    int coins[n-1];
    int i,count,j;
    printf(""The coins are:\n"");
    for(i=0;i<n-1;i++)
    {
        scanf(""%d"",&coins[i]);
    }
    for(i=0;i<n-1;i++)
    {                                        
        count = 0;
        for(j=0;j<n-1;j++)
        {
            if(coins[i] == coins[j])
            {
                count+=1;;
            }
        }
        printf(""Mising coin is:"");
        if(count%2==1)
        {
            printf(""%d"",coins[i]);
            return 0;
        }
    }
    return 0;
}
",63,1826,231
"struct node
{
    int data;
    struct node*link;
};
int add_at_beginning(struct node**temp1)
{
    struct node*tempo;
    tempo = (struct node*) malloc (sizeof(struct node));
    printf(""Enter the element:"");
    scanf(""%d"",&tempo->data);
    tempo->link = *temp1;
    *temp1 = tempo;
}
int main()
{
    int choice = 1;
    struct node*head,*temp;
    head = temp = NULL;
    struct node*newnode;
    while(choice)
    {
        newnode = (struct node*) malloc(sizeof(struct node));
        printf(""Enter the element in the node:"");
        scanf(""%d"",&newnode->data);
        newnode->link = NULL;
        if(head == NULL)
        {
            head = temp = newnode;
        }
        else
        {
            temp->link = newnode;
            temp = newnode;
        }
        printf(""Do you want to enter more nodes?(0/1)"");
        scanf(""%d"",&choice);
    }
    temp = head;
    add_at_beginning(&temp);
    int count = 0;
    printf(""THE ELEMENTS PRESENT IN THE NODE ARE\n"");
    while(temp!=NULL)
    {
        count++;
        printf(""%d\t"",temp->data);
        temp = temp->link;
    }
    printf(""\nCount : %d"",count);
    return 0;
}
",63,1827,384
"int bubbleSort(int x[],int y);
int main()
{
    int n;
    printf(""enter the no. of elements:"");
    scanf(""%d"",&n);
    int arr[n];
    int i;
    printf(""enter the elements:"");
    for(i=0;i<n;i++)
    {
        scanf(""%d"",&arr[i]);
    }
    bubbleSort(arr,n);
    return 0;
}
int bubbleSort(int x[],int y)
{
    int i,j,temp;
    for(i=0;i<y;i++)
    {
        for(j=0;j<y-i-1;j++)
        {
            if(x[j] > x[j+1])
            {
                temp = x[j];
                x[j] = x[j+1];
                x[j+1] = temp;
            }
        }
    }
    printf(""sorted array:\n"");
    for(i=0;i<y;i++)
    {
        printf(""%d\n"",x[i]);
    }
}
",63,1828,281
"int main()
{
    int n;
    scanf(""%d"",&n);
    int a[50], b[50];
    printf(""The elements are\n"");
    int i,j;
    for(i=0;i<n;i++)
    {
        scanf(""%d"",&a[i]);
        b[i] = -1;
    }
    for(i=0;i<n;i++)
    {
        int count = 1;
        for(j=i+1;j<n;j++)
        {
            if(a[i] == a[j])
            {
                count++;
                b[j] = 0;
            }
        }
        if(b[i]!=0)
        {
            b[i] = count;
        }
    }
    printf(""Frequencies are:\n"");
    for(i=0;i<n;i++)
    {
        if(b[i]!=0)
        {
            printf(""%d occurence is : %d\n"", a[i],b[i]);
        }
    }
    return 0;
}
",63,1829,280
"int power();
int main()
{
    int n;
    int count = 0;
    printf(""enter a number:"");
    scanf(""%d"",&n);
    int temp = n;
    while(temp!=0)
    {
        count++;
        temp/=10;
    }
    printf(""count:%d\n"",count);
    int rem = 0, sum = 0;
    int t = n;
    int i;
    while(t!=0)
    {
        int mul=1;
        rem = t%10;
        for(i=1;i<=count;i++)
        {
            mul = mul*rem;
        }
        printf(""Power of %d is : %d\n"",rem,mul);
        sum = sum+mul;
        t = t/10;   
    }
    if(sum == n)
    {
        printf(""ARMSTRONG NUMBER"");
    }
    else
    printf(""NOT ARMSTRONG NUMBER"");
    return 0;
}
",63,1830,255
"void display_node();
void delete_at_start();
struct node
{
    int data;
    struct node*ptr;
};
int main()
{
    int choice = 1;
    struct node*head,*temp;
    head = temp = NULL;
    struct node*newnode;
    while(choice!=0)
    {
        newnode = (struct node*) malloc (sizeof(struct node));
        printf(""Enter the data:"");
        scanf(""%d"",&newnode->data);
        newnode->ptr = NULL;
        
        if(head == NULL)
        {
            head = temp = newnode;
        }
        else
        {
            temp->ptr = newnode;
            temp = newnode;
        }
        printf(""Do you want to enter more nodes?(1/0)"");
        scanf(""%d"",&choice);
    }
    temp = head;
    display_node(temp);
    delete_at_start(head,temp);
    getch();
}
void display_node(struct node*temp1)
{
    printf(""The Elements are:"");
    while(temp1!=NULL)
    {
        printf(""%d\t"",temp1->data);
        temp1 = temp1->ptr;
    }
}
void delete_at_start(struct node*head1, struct node*temp1)
{
    head1 = head1->ptr;
    free(temp1);
    printf(""\nAfter Deletion:"");
    while(head1!=NULL)
    {
        printf(""%d\t"",head1->data);
        head1 = head1->ptr;
    }
}
",63,1831,400
"void display_nodes();
void delete_at_N_position();
struct node
{
    int data;
    struct node*ptr;
};
int main()
{
    int choice;
    printf(""Enter 1 for Creation or Enter 0 for Termination:"");
    scanf(""%d"",&choice);
    struct node*head,*temp;
    head = temp = NULL;
    struct node*newnode;
    while(choice!=0)
    {
        newnode = (struct node*) malloc (sizeof(struct node));
        printf(""Enter the Data:"");
        scanf(""%d"",&newnode->data);
        newnode->ptr = NULL;
        
        if(head == NULL)
        {
            head = temp = newnode;
        }
        else
        {
            temp->ptr = newnode;
            temp = newnode;
        }
        printf(""Do you want to more?(1/0)"");
        scanf(""%d"",&choice);
    }
    temp = head;
    display_nodes(temp);
    delete_at_N_position(head,temp);
    getch();
}
void display_nodes(struct node*temp1)
{
    printf(""The Elements are:"");
    while(temp1!=NULL)
    {
        printf(""%d\t"",temp1->data);
        temp1 = temp1->ptr;
    }
}
void delete_at_N_position(struct node*head1, struct node*temp1)
{
    int pos;
    printf(""\nAt what position you want to delete the data?\n"");
    scanf(""%d"",&pos);
    int i;
    if(pos<=0)
    {
        printf(""After Deletion:"");
        while(temp1!=NULL)
        {
            printf(""%d\t"",temp1->data);
            temp1 = temp1->ptr;
        }
        printf(""\nSORRY!!! NO NODE DELETED :("");
        return;
    }
    if(pos == 1)
    {
        head1 = head1->ptr;
        free(temp1);
        printf(""\nAfter Deletion:"");
        while(head1!=NULL)
        {
            printf(""%d\t"",head1->data);
            head1 = head1->ptr;
        }
        return;
    }
    for(i = 1;i < pos-1;i++)
    {
        temp1 = temp1->ptr;
    }
    struct node*prevnode;
    prevnode = temp1;
    temp1 = temp1->ptr;
    prevnode->ptr = temp1->ptr;
    free(temp1);
    prevnode = head1;
    printf(""\nAfter Deletion:"");
    while(prevnode!=NULL)
    {
        printf(""%d\t"",prevnode->data);
        prevnode = prevnode->ptr;
    }
}
",63,1832,707
"int main()
{
    int low,high,i,temp,flag;
    printf(""enter the lower number:"");
    scanf(""%d"",&low);
    printf(""enter the higher number:"");
    scanf(""%d"",&high);
    if(low>high)
    {
        temp = low;
        low = high;
        high = temp;
    }
    while(low<high)
    {
        flag = 0;
        if(low<=1)
        {
            low++;
            continue;
        }
        for(i = 2;i <= low/2; i++)
        {
            if(low%i == 0)
            {
                flag = 1;
                break;
            }
        }
        if(flag == 0)
        printf(""%d\n"", low);
        low++;
    }
}
",63,1833,210
"#define MAX 999
int fibonnaciSeries();
int primeSeries();
int main()
{
    int n;
    scanf(""%d"",&n);
    if(n%2 == 1)
    {
        fibonnaciSeries(n/2 + 1);
    }
    else
    primeSeries(n/2);
}
int fibonnaciSeries(int x)
{
    int a=0,b=1,temp;
    int i;
    for(i=1;i<=x;i++)
    {
        temp = a+b;
        a = b;
        b = temp;
    }
    printf(""%d"",a);
}
int primeSeries(int y)
{
    int i,j,flag,count = 0;
    for(i=2;i<=MAX;i++)
    {
        flag = 0;
        for(j=2;j<i;j++)
        {
            if(i%j == 0)
            {
                flag = 1;
                break;
            }
        }
        if(flag == 0)
        {
            if(++count == y)
            {
                printf(""%d"",i);
            }
        }
    }
}
",63,1834,305
"#define TRACE_LEVEL SCP_TRACE_LEVEL


#include ""ssh/ssh.h""
#include ""scp/scp_server.h""
#include ""scp/scp_server_misc.h""
#include ""path.h""
#include ""debug.h""


#if (SCP_SERVER_SUPPORT == ENABLED)




void scpServerGetDefaultSettings(ScpServerSettings *settings)
{
   
   settings->sshServerContext = NULL;

   
   settings->numSessions = 0;
   settings->sessions = NULL;

   
   settings->rootDir = NULL;

   
   settings->checkUserCallback = NULL;
   
   settings->getFilePermCallback = NULL;
}




error_t scpServerInit(ScpServerContext *context,
   const ScpServerSettings *settings)
{
   uint_t i;

   
   TRACE_INFO(""Initializing SCP server...\r\n"");

   
   if(context == NULL || settings == NULL)
      return ERROR_INVALID_PARAMETER;

   
   if(settings->sessions == NULL || settings->numSessions < 1 ||
      settings->numSessions > SCP_SERVER_MAX_SESSIONS)
   {
      return ERROR_INVALID_PARAMETER;
   }

   
   if(settings->rootDir == NULL ||
      osStrlen(settings->rootDir) > SCP_SERVER_MAX_ROOT_DIR_LEN)
   {
      return ERROR_INVALID_PARAMETER;
   }

   
   osMemset(context, 0, sizeof(ScpServerContext));

   
   context->sshServerContext = settings->sshServerContext;
   context->numSessions = settings->numSessions;
   context->sessions = settings->sessions;
   context->checkUserCallback = settings->checkUserCallback;
   context->getFilePermCallback = settings->getFilePermCallback;

   
   osStrcpy(context->rootDir, settings->rootDir);

   
   pathCanonicalize(context->rootDir);
   pathRemoveSlash(context->rootDir);

   
   for(i = 0; i < context->numSessions; i++)
   {
      
      osMemset(&context->sessions[i], 0, sizeof(ScpServerSession));
   }

   
   if(!osCreateEvent(&context->event))
   {
      
      scpServerDeinit(context);
   }

   
   return NO_ERROR;
}




error_t scpServerStart(ScpServerContext *context)
{
   error_t error;
   OsTask *task;

   
   if(context == NULL)
      return ERROR_INVALID_PARAMETER;

   
   TRACE_INFO(""Starting SCP server...\r\n"");

   
   if(context->running)
      return ERROR_ALREADY_RUNNING;

   
   error = sshServerRegisterChannelRequestCallback(context->sshServerContext,
      scpServerChannelRequestCallback, context);

   
   if(!error)
   {
      
      context->stop = FALSE;
      context->running = TRUE;

      
      task = osCreateTask(""SCP Server"", scpServerTask, context,
         SCP_SERVER_STACK_SIZE, SCP_SERVER_PRIORITY);
      
      if(task == OS_INVALID_HANDLE)
      {
         error = ERROR_OUT_OF_RESOURCES;
      }
   }

   
   if(error)
   {
      
      context->running = FALSE;

      
      sshServerUnregisterChannelRequestCallback(context->sshServerContext,
         scpServerChannelRequestCallback);
   }

   
   return error;
}




error_t scpServerStop(ScpServerContext *context)
{
   uint_t i;

   
   if(context == NULL)
      return ERROR_INVALID_PARAMETER;

   
   TRACE_INFO(""Stopping SCP server...\r\n"");

   
   if(context->running)
   {
      
      sshServerUnregisterChannelRequestCallback(context->sshServerContext,
         scpServerChannelRequestCallback);

      
      context->stop = TRUE;
      
      osSetEvent(&context->event);

      
      while(context->running)
      {
         osDelayTask(1);
      }

      
      for(i = 0; i < context->numSessions; i++)
      {
         
         if(context->sessions[i].state != SCP_SERVER_SESSION_STATE_CLOSED)
         {
            
            scpServerCloseSession(&context->sessions[i]);
         }
      }
   }

   
   return NO_ERROR;
}




error_t scpServerSetRootDir(ScpServerSession *session, const char_t *rootDir)
{
   ScpServerContext *context;

   
   if(session == NULL || rootDir == NULL)
      return ERROR_INVALID_PARAMETER;

   
   context = session->context;

   
   pathCopy(session->rootDir, context->rootDir, SCP_SERVER_MAX_ROOT_DIR_LEN);
   pathCombine(session->rootDir, rootDir, SCP_SERVER_MAX_ROOT_DIR_LEN);

   
   pathCanonicalize(session->rootDir);
   pathRemoveSlash(session->rootDir);

   
   pathCopy(session->homeDir, session->rootDir, SCP_SERVER_MAX_HOME_DIR_LEN);

   
   return NO_ERROR;
}




error_t scpServerSetHomeDir(ScpServerSession *session, const char_t *homeDir)
{
   ScpServerContext *context;

   
   if(session == NULL || homeDir == NULL)
      return ERROR_INVALID_PARAMETER;

   
   context = session->context;

   
   pathCopy(session->homeDir, context->rootDir, SCP_SERVER_MAX_HOME_DIR_LEN);
   pathCombine(session->homeDir, homeDir, SCP_SERVER_MAX_HOME_DIR_LEN);

   
   pathCanonicalize(session->homeDir);
   pathRemoveSlash(session->homeDir);

   
   return NO_ERROR;
}




void scpServerTask(void *param)
{
   error_t error;
   uint_t i;
   systime_t timeout;
   ScpServerContext *context;
   ScpServerSession *session;

   
   context = (ScpServerContext *) param;

#if (NET_RTOS_SUPPORT == ENABLED)
   
   osEnterTask();

   
   while(1)
   {
#endif
      
      timeout = SCP_SERVER_TICK_INTERVAL;

      
      osMemset(context->eventDesc, 0, sizeof(context->eventDesc));

      
      for(i = 0; i < context->numSessions; i++)
      {
         
         session = &context->sessions[i];

         
         if(session->state != SCP_SERVER_SESSION_STATE_CLOSED)
         {
            
            scpServerRegisterSessionEvents(session, &context->eventDesc[i]);

            
            if(context->eventDesc[i].eventFlags != 0)
            {
               
               timeout = 0;
            }
         }
      }

      
      error = sshPollChannels(context->eventDesc, context->numSessions,
         &context->event, timeout);

      
      if(error == NO_ERROR || error == ERROR_TIMEOUT)
      {
         
         if(context->stop)
         {
            
            context->running = FALSE;
            
            osDeleteTask(NULL);
         }

         
         for(i = 0; i < context->numSessions; i++)
         {
            
            session = &context->sessions[i];

            
            if(session->state != SCP_SERVER_SESSION_STATE_CLOSED)
            {
               
               if(context->eventDesc[i].eventFlags != 0)
               {
                  
                  scpServerProcessSessionEvents(session);
               }
            }
         }
      }

      
      scpServerTick(context);

#if (NET_RTOS_SUPPORT == ENABLED)
   }
#endif
}




void scpServerDeinit(ScpServerContext *context)
{
   
   if(context != NULL)
   {
      
      osDeleteEvent(&context->event);

      
      osMemset(context, 0, sizeof(ScpServerContext));
   }
}

#endif
",64,1835,2204
"#define TRACE_LEVEL STP_TRACE_LEVEL


#include ""stp/stp.h""
#include ""stp/stp_operation.h""
#include ""stp/stp_procedures.h""
#include ""stp/stp_conditions.h""
#include ""stp/stp_misc.h""
#include ""debug.h""


#if (STP_SUPPORT == ENABLED)




void stpReceivedConfigBpdu(StpBridgePort *port, const StpBpdu *bpdu)
{
   bool_t rootBridge;
   StpBridgeContext *context;

   
   context = port->context;

   
   if(port->state != STP_PORT_STATE_DISABLED && port->macOperState)
   {
      
      
      if(stpSupersedesPortInfo(port, bpdu))
      {
         
         rootBridge = stpRootBridge(context);

         
         stpRecordConfigInfo(port, bpdu);
         
         stpConfigUpdate(context);
         
         stpPortStateSelection(context);

         
         
         if(rootBridge && !stpRootBridge(context))
         {
            
            stpStopTimer(&context->helloTimer);

            
            if(context->topologyChangeDetected)
            {
               
               
               
               stpStopTimer(&context->topologyChangeTimer);
               stpTransmitTcnBpdu(context);
               stpStartTimer(&context->tcnTimer, 0);
            }
         }

         
         if(stpRootPort(port))
         {
            
            
            stpRecordConfigTimeoutValues(context, bpdu);
            stpConfigBpduGeneration(context);

            
            if((bpdu->flags & STP_BPDU_FLAG_TC_ACK) != 0)
            {
               
               stpTopologyChangeAcked(context);
            }
         }
      }
      else
      {
         
         
         
         
         if(stpDesignatedPort(port))
         {
            stpReplyToConfigBpdu(port);
         }
      }
   }
}




void stpReceivedTcnBpdu(StpBridgePort *port, const StpBpdu *bpdu)
{
   
   if(port->state != STP_PORT_STATE_DISABLED && port->macOperState)
   {
      
      
      if(stpDesignatedPort(port))
      {
         
         stpTopologyChangeDetection(port->context);
         
         stpAckTopologyChange(port);
      }
   }
}




void stpHelloTimerExpiry(StpBridgeContext *context)
{
   
   
   stpConfigBpduGeneration(context);
   stpStartTimer(&context->helloTimer, 0);
}




void stpMessageAgeTimerExpiry(StpBridgePort *port)
{
   bool_t rootBridge;
   StpBridgeContext *context;

   
   context = port->context;

   
   rootBridge = stpRootBridge(context);

   
   
   stpBecomeDesignatedPort(port);

   
   stpConfigUpdate(context);
   
   stpPortStateSelection(context);

   
   if(!rootBridge && stpRootBridge(context))
   {
      
      
      
      context->maxAge = context->bridgeMaxAge;
      context->helloTime = context->bridgeHelloTime;
      context->forwardDelay = context->bridgeForwardDelay;

      
      stpTopologyChangeDetection(context);
      
      stpStopTimer(&context->tcnTimer);

      
      
      stpConfigBpduGeneration(context);
      stpStartTimer(&context->helloTimer, 0);
   }
}




void stpForwardDelayTimerExpiry(StpBridgePort *port)
{
   StpBridgeContext *context;

   
   context = port->context;

   
   if(port->state == STP_PORT_STATE_LISTENING)
   {
      
      
      stpUpdatePortState(port, STP_PORT_STATE_LEARNING);

      
      stpStartTimer(&port->forwardDelayTimer, 0);
   }
   else if(port->state == STP_PORT_STATE_LEARNING)
   {
      
      
      stpUpdatePortState(port, STP_PORT_STATE_FORWARDING);

      
      
      
      if(stpDesignatedBridge(context) && port->changeDetectionEnabled)
      {
         
         stpTopologyChangeDetection(context);
      }
   }
   else
   {
      
   }
}




void stpTcnTimerExpiry(StpBridgeContext *context)
{
   
   stpTransmitTcnBpdu(context);
   
   stpStartTimer(&context->tcnTimer, 0);
}




void stpTopologyChangeTimerExpiry(StpBridgeContext *context)
{
   
   context->topologyChangeDetected = FALSE;
   
   stpUpdateTopologyChange(context, FALSE);
}




void stpHoldTimerExpiry(StpBridgePort *port)
{
   
   
   
   if(port->configPending)
   {
      stpTransmitConfigBpdu(port);
   }
}

#endif
",64,1836,1410
"#define TRACE_LEVEL TLS_TRACE_LEVEL


#include ""tls.h""
#include ""tls_misc.h""
#include ""tls13_key_material.h""
#include ""tls13_ticket.h""
#include ""debug.h""


#if (TLS_SUPPORT == ENABLED && TLS_MAX_VERSION >= TLS_VERSION_1_3)




bool_t tls13IsTicketValid(TlsContext *context)
{
   bool_t valid = FALSE;

   
   if(tlsGetHashAlgo(context->ticketHashAlgo) != NULL)
   {
      
      if(context->ticketPskLen > 0)
      {
         
         if(context->entity == TLS_CONNECTION_END_CLIENT)
         {
            
            if(context->ticket != NULL && context->ticketLen > 0)
            {
               valid = TRUE;
            }
         }
         else
         {
            valid = TRUE;
         }
      }
   }

   
   return valid;
}




error_t tls13SaveSessionTicket(const TlsContext *context,
   TlsSessionState *session)
{
   const HashAlgo *hashAlgo;

   
   if(context->version != TLS_VERSION_1_3)
      return ERROR_INVALID_VERSION;

   
   if(context->ticket == NULL || context->ticketLen == 0)
      return ERROR_INVALID_TICKET;

   
   if(context->cipherSuite.identifier == 0 ||
      context->cipherSuite.prfHashAlgo == NULL)
   {
      return ERROR_INVALID_SESSION;
   }

   
   hashAlgo = context->cipherSuite.prfHashAlgo;

   
   session->ticket = tlsAllocMem(context->ticketLen);
   
   if(session->ticket == NULL)
      return ERROR_OUT_OF_MEMORY;

   
   session->timestamp = osGetSystemTime();

   
   session->version = context->version;
   session->cipherSuite = context->cipherSuite.identifier;
   session->ticketTimestamp = context->ticketTimestamp;
   session->ticketLifetime = context->ticketLifetime;
   session->ticketAgeAdd = context->ticketAgeAdd;
   session->maxEarlyDataSize = context->maxEarlyDataSize;

   
   osMemcpy(session->ticket, context->ticket, context->ticketLen);
   session->ticketLen = context->ticketLen;

   
   
   if(hashAlgo == tlsGetHashAlgo(TLS_HASH_ALGO_SHA256))
   {
      session->ticketHashAlgo = TLS_HASH_ALGO_SHA256;
   }
   else if(hashAlgo == tlsGetHashAlgo(TLS_HASH_ALGO_SHA384))
   {
      session->ticketHashAlgo = TLS_HASH_ALGO_SHA384;
   }
   else
   {
      session->ticketHashAlgo = TLS_HASH_ALGO_NONE;
   }

   
   osMemcpy(session->secret, context->ticketPsk, hashAlgo->digestSize);

#if (TLS_ALPN_SUPPORT == ENABLED)
   
   if(context->selectedProtocol != NULL)
   {
      size_t n;

      
      n = osStrlen(context->selectedProtocol);

      
      session->ticketAlpn = tlsAllocMem(n + 1);
      
      if(session->ticketAlpn == NULL)
         return ERROR_OUT_OF_MEMORY;

      
      osStrcpy(session->ticketAlpn, context->selectedProtocol);
   }
#endif

   
   return NO_ERROR;
}




error_t tls13RestoreSessionTicket(TlsContext *context,
   const TlsSessionState *session)
{
   systime_t serverTicketAge;

   
   if(session->version != TLS_VERSION_1_3)
      return ERROR_INVALID_VERSION;

   
   if(session->ticket == NULL || session->ticketLen == 0)
      return ERROR_INVALID_TICKET;

   
   if(session->cipherSuite == 0 ||
      session->ticketHashAlgo == TLS_HASH_ALGO_NONE)
   {
      return ERROR_INVALID_SESSION;
   }

   
   serverTicketAge = osGetSystemTime() - session->ticketTimestamp;

   
   if(serverTicketAge >= (session->ticketLifetime * 1000))
      return ERROR_TICKET_EXPIRED;

   
   context->version = session->version;
   context->ticketCipherSuite = session->cipherSuite;
   context->ticketHashAlgo = session->ticketHashAlgo;
   context->ticketTimestamp = session->ticketTimestamp;
   context->ticketLifetime = session->ticketLifetime;
   context->ticketAgeAdd = session->ticketAgeAdd;
   context->maxEarlyDataSize = session->maxEarlyDataSize;
   context->sessionIdLen = 0;

   
   if(context->ticket != NULL)
   {
      osMemset(context->ticket, 0, context->ticketLen);
      tlsFreeMem(context->ticket);
      context->ticket = NULL;
      context->ticketLen = 0;
   }

   
   context->ticket = tlsAllocMem(session->ticketLen);
   
   if(context->ticket == NULL)
      return ERROR_OUT_OF_MEMORY;

   
   osMemcpy(context->ticket, session->ticket, session->ticketLen);
   context->ticketLen = session->ticketLen;

   
   
   if(session->ticketHashAlgo == TLS_HASH_ALGO_SHA256)
   {
      context->ticketPskLen = SHA256_DIGEST_SIZE;
   }
   else if(session->ticketHashAlgo == TLS_HASH_ALGO_SHA384)
   {
      context->ticketPskLen = SHA384_DIGEST_SIZE;
   }
   else
   {
      context->ticketPskLen = 0;
   }

   
   osMemcpy(context->ticketPsk, session->secret, context->ticketPskLen);

#if (TLS_ALPN_SUPPORT == ENABLED)
   
   if(context->ticketAlpn != NULL)
   {
      tlsFreeMem(context->ticketAlpn);
      context->ticketAlpn = NULL;
   }

   
   if(session->ticketAlpn != NULL)
   {
      size_t n;

      
      n = osStrlen(session->ticketAlpn);

      
      context->ticketAlpn = tlsAllocMem(n + 1);
      
      if(context->ticketAlpn == NULL)
         return ERROR_OUT_OF_MEMORY;

      
      osStrcpy(context->ticketAlpn, session->ticketAlpn);
   }
#endif

   
   return NO_ERROR;
}




error_t tls13GenerateTicket(TlsContext *context,
   const Tls13NewSessionTicket *message, uint8_t *ticket, size_t *length)
{
#if (TLS_TICKET_SUPPORT == ENABLED)
   error_t error;
   size_t n;
   Tls13PlaintextSessionState *state;
   const HashAlgo *hashAlgo;

   
   state = (Tls13PlaintextSessionState *) ticket;

   
   state->version = context->version;
   state->cipherSuite = context->cipherSuite.identifier;
   state->ticketTimestamp = osGetSystemTime();
   state->ticketLifetime = ntohl(message->ticketLifetime);
   state->ticketAgeAdd = ntohl(message->ticketAgeAdd);
   osMemcpy(state->ticketNonce, message->ticketNonce, message->ticketNonceLen);
   osMemset(state->ticketPsk, 0, TLS_MAX_HKDF_DIGEST_SIZE);

   
   hashAlgo = context->cipherSuite.prfHashAlgo;
   
   if(hashAlgo == NULL)
      return ERROR_FAILURE;

   
   error = tls13HkdfExpandLabel(hashAlgo, context->resumptionMasterSecret,
      hashAlgo->digestSize, ""resumption"", message->ticketNonce,
      message->ticketNonceLen, state->ticketPsk, hashAlgo->digestSize);
   
   if(error)
      return error;

   
   state->ticketPskLen = hashAlgo->digestSize;

   
   n = sizeof(Tls13PlaintextSessionState);

   
   if(context->ticketEncryptCallback == NULL)
      return ERROR_FAILURE;

   
   error = context->ticketEncryptCallback(context, (uint8_t *) state, n,
      ticket, length, context->ticketParam);
   
   if(error)
      return error;

   
   return NO_ERROR;
#else
   
   return ERROR_NOT_IMPLEMENTED;
#endif
}




error_t tls13VerifyTicket(TlsContext *context, const uint8_t *ticket,
   size_t length, uint32_t obfuscatedTicketAge)
{
#if (TLS_TICKET_SUPPORT == ENABLED)
   error_t error;
   systime_t serverTicketAge;
   Tls13PlaintextSessionState *state;
   const HashAlgo *hashAlgo;
#if (TLS13_EARLY_DATA_SUPPORT == ENABLED)
   systime_t delta;
   systime_t clientTicketAge;
#endif

   
   if(context->ticketDecryptCallback == NULL)
      return ERROR_DECRYPTION_FAILED;

   
   if(length == 0)
      return ERROR_DECRYPTION_FAILED;

   
   state = tlsAllocMem(length);
   
   if(state == NULL)
      return ERROR_OUT_OF_MEMORY;

   
   do
   {
      
      error = context->ticketDecryptCallback(context, ticket, length,
         (uint8_t *) state, &length, context->ticketParam);
      
      if(error)
         break;

      
      if(length != sizeof(Tls13PlaintextSessionState))
      {
         
         error = ERROR_INVALID_TICKET;
         break;
      }

      
      if(state->version != TLS_VERSION_1_3)
      {
         
         error = ERROR_INVALID_TICKET;
         break;
      }

      
      serverTicketAge = osGetSystemTime() - state->ticketTimestamp;

      
      if(serverTicketAge >= (state->ticketLifetime * 1000))
      {
         
         error = ERROR_INVALID_TICKET;
         break;
      }

#if (TLS13_EARLY_DATA_SUPPORT == ENABLED)
      
      
      clientTicketAge = obfuscatedTicketAge - state->ticketAgeAdd;

      
      
      if(clientTicketAge < serverTicketAge)
      {
         delta = serverTicketAge - clientTicketAge;
      }
      else
      {
         delta = clientTicketAge - serverTicketAge;
      }

      
      
      
      if(delta >= TLS13_TICKET_AGE_TOLERANCE)
      {
         
         
         
         context->earlyDataRejected = TRUE;
      }
#endif

      
      
      error = tlsSelectCipherSuite(context, state->cipherSuite);
      
      if(error)
         break;

      
      hashAlgo = context->cipherSuite.prfHashAlgo;
      
      if(hashAlgo == NULL)
      {
         
         error = ERROR_INVALID_TICKET;
         break;
      }

      
      if(state->ticketPskLen != hashAlgo->digestSize)
      {
         
         error = ERROR_INVALID_TICKET;
         break;
      }

      
      osMemcpy(context->ticketPsk, state->ticketPsk, state->ticketPskLen);
      context->ticketPskLen = state->ticketPskLen;

      
      if(hashAlgo == tlsGetHashAlgo(TLS_HASH_ALGO_SHA256))
      {
         context->ticketHashAlgo = TLS_HASH_ALGO_SHA256;
      }
      else if(hashAlgo == tlsGetHashAlgo(TLS_HASH_ALGO_SHA384))
      {
         context->ticketHashAlgo = TLS_HASH_ALGO_SHA384;
      }
      else
      {
         context->ticketHashAlgo = TLS_HASH_ALGO_NONE;
      }

      
   } while(0);

   
   osMemset(state, 0, length);
   tlsFreeMem(state);

   
   return error;
#else
   
   return ERROR_DECRYPTION_FAILED;
#endif
}

#endif
",64,1837,3504
"#define TRACE_LEVEL TRACE_LEVEL_OFF






#include ""os_port.h""
#include ""os_port_posix.h""
#include ""debug.h""


typedef void *(*PthreadTaskCode) (void *param);




void osInitKernel(void)
{
   
}




void osStartKernel(void)
{
   
}




OsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,
   void *param, size_t stackSize, int_t priority)
{
   int_t ret;
   pthread_t thread;

   
   ret = pthread_create(&thread, NULL, (PthreadTaskCode) taskCode, param);

   
   if(ret == 0)
      return (OsTask *) thread;
   else
      return NULL;
}




void osDeleteTask(OsTask *task)
{
   
   if(task == NULL)
   {
      
      pthread_exit(NULL);
   }
}




void osDelayTask(systime_t delay)
{
   
   usleep(delay * 1000);
}




void osSwitchTask(void)
{
   
}




void osSuspendAllTasks(void)
{
   
}




void osResumeAllTasks(void)
{
   
}




bool_t osCreateEvent(OsEvent *event)
{
   int_t ret;

   
   ret = sem_init(event, 0, 0);

   
   if(ret == 0)
      return TRUE;
   else
      return FALSE;
}




void osDeleteEvent(OsEvent *event)
{
   
   sem_destroy(event);
}




void osSetEvent(OsEvent *event)
{
   int_t ret;
   int_t value;

   
   ret = sem_getvalue(event, &value);

   
   if(ret == 0 && value == 0)
   {
      
      sem_post(event);
   }
}




void osResetEvent(OsEvent *event)
{
   int_t ret;

   
   do
   {
      
      ret = sem_trywait(event);

      
   } while(ret == 0);
}




bool_t osWaitForEvent(OsEvent *event, systime_t timeout)
{
   int_t ret;
   struct timespec ts;

   
   
   if(timeout == 0)
   {
      
      ret = sem_trywait(event);
   }
   else if(timeout == INFINITE_DELAY)
   {
      
      ret = sem_wait(event);
   }
   else
   {
      
      clock_gettime(CLOCK_REALTIME, &ts);

      
      ts.tv_sec += timeout / 1000;
      ts.tv_nsec += (timeout % 1000) * 1000000;

      
      if(ts.tv_nsec >= 1000000000)
      {
         ts.tv_sec += 1;
         ts.tv_nsec -= 1000000000;
      }

      
      ret = sem_timedwait(event, &ts);
   }

   
   if(ret == 0)
   {
      
      do
      {
         
         ret = sem_trywait(event);

         
      } while(ret == 0);

      
      return TRUE;
   }
   else
   {
      
      return FALSE;
   }
}




bool_t osSetEventFromIsr(OsEvent *event)
{
   
   return FALSE;
}




bool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)
{
   int_t ret;

   
   ret = sem_init(semaphore, 0, count);

   
   if(ret == 0)
      return TRUE;
   else
      return FALSE;
}




void osDeleteSemaphore(OsSemaphore *semaphore)
{
   
   sem_destroy(semaphore);
}




bool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)
{
   int_t ret;
   struct timespec ts;

   
   if(timeout == 0)
   {
      
      ret = sem_trywait(semaphore);
   }
   else if(timeout == INFINITE_DELAY)
   {
      
      ret = sem_wait(semaphore);
   }
   else
   {
      
      clock_gettime(CLOCK_REALTIME, &ts);

      
      ts.tv_sec += timeout / 1000;
      ts.tv_nsec += (timeout % 1000) * 1000000;

      
      if(ts.tv_nsec >= 1000000000)
      {
         ts.tv_sec += 1;
         ts.tv_nsec -= 1000000000;
      }

      
      ret = sem_timedwait(semaphore, &ts);
   }

   
   if(ret == 0)
      return TRUE;
   else
      return FALSE;
}




void osReleaseSemaphore(OsSemaphore *semaphore)
{
   
   sem_post(semaphore);
}




bool_t osCreateMutex(OsMutex *mutex)
{
   int_t ret;

   
   ret = pthread_mutex_init(mutex, NULL);

   
   if(ret == 0)
      return TRUE;
   else
      return FALSE;
}




void osDeleteMutex(OsMutex *mutex)
{
   
   pthread_mutex_destroy(mutex);
}




void osAcquireMutex(OsMutex *mutex)
{
   
   pthread_mutex_lock(mutex);
}




void osReleaseMutex(OsMutex *mutex)
{
   
   pthread_mutex_unlock(mutex);
}




systime_t osGetSystemTime(void)
{
   struct timeval tv;

   
   gettimeofday(&tv, NULL);

   
   return (tv.tv_sec * 1000) + (tv.tv_usec / 1000);
}




void *osAllocMem(size_t size)
{
   
   return malloc(size);
}




void osFreeMem(void *p)
{
   
   free(p);
}
",64,1838,1773
"#define TRACE_LEVEL SFTP_TRACE_LEVEL


#include ""ssh/ssh.h""
#include ""sftp/sftp_server.h""
#include ""sftp/sftp_server_directory.h""
#include ""sftp/sftp_server_misc.h""
#include ""path.h""
#include ""debug.h""


#if (SFTP_SERVER_SUPPORT == ENABLED)




error_t sftpServerCreateDir(SftpServerSession *session,
   const SshString *path, const SftpFileAttrs *attributes)
{
   error_t error;
   uint_t perm;
   SftpServerContext *context;

   
   context = session->context;

   
   error = sftpServerGetPath(session, path, context->path,
      SFTP_SERVER_MAX_PATH_LEN);
   
   if(error)
      return error;

   
   perm = sftpServerGetFilePermissions(session, context->path);
   
   if((perm & SFTP_FILE_PERM_WRITE) == 0)
      return ERROR_ACCESS_DENIED;

   
   error = fsCreateDir(context->path);

   
   return error;
}




error_t sftpServerRemoveDir(SftpServerSession *session,
   const SshString *path)
{
   error_t error;
   uint_t perm;
   SftpServerContext *context;

   
   context = session->context;

   
   error = sftpServerGetPath(session, path, context->path,
      SFTP_SERVER_MAX_PATH_LEN);
   
   if(error)
      return error;

   
   perm = sftpServerGetFilePermissions(session, context->path);
   
   if((perm & SFTP_FILE_PERM_WRITE) == 0)
      return ERROR_ACCESS_DENIED;

   
   error = fsRemoveDir(context->path);

   
   return error;
}




error_t sftpServerOpenDir(SftpServerSession *session,
   const SshString *path, uint32_t *handle)
{
   error_t error;
   uint_t i;
   uint_t perm;
   SftpServerContext *context;
   SftpFileObject *fileObject;

   
   context = session->context;

   
   error = sftpServerGetPath(session, path, context->path,
      SFTP_SERVER_MAX_PATH_LEN);
   
   if(error)
      return error;

   
   perm = sftpServerGetFilePermissions(session, context->path);
   
   if((perm & SFTP_FILE_PERM_READ) == 0)
      return ERROR_ACCESS_DENIED;

   
   for(i = 0; i < context->numFileObjects; i++)
   {
      
      fileObject = &context->fileObjects[i];

      
      if(fileObject->type == SSH_FILEXFER_TYPE_INVALID)
      {
         break;
      }
   }

   
   if(i < context->numFileObjects)
   {
      
      fileObject->dir = fsOpenDir(context->path);

      
      if(fileObject->dir != NULL)
      {
         
         fileObject->type = SSH_FILEXFER_TYPE_DIRECTORY;
         fileObject->session = session;
         fileObject->size = 0;
         fileObject->offset = 0;
         fileObject->file = NULL;

         
         osStrcpy(fileObject->path, context->path);

         
         fileObject->handle = sftpServerGenerateHandle(session);

         
         
         *handle = fileObject->handle;

         
         error = NO_ERROR;
      }
      else
      {
         
         error = ERROR_OPEN_FAILED;
      }
   }
   else
   {
      
      error = ERROR_OUT_OF_RESOURCES;
   }

   
   return error;
}




error_t sftpServerReadDir(SftpServerSession *session,
   const SshBinaryString *handle, SftpName *name)
{
   error_t error;
   uint_t perm;
   FsDirEntry dirEntry;
   SftpServerContext *context;
   SftpFileObject *fileObject;

   
   error = NO_ERROR;

   
   context = session->context;

   
   osMemset(name, 0, sizeof(SftpName));

   
   
   fileObject = sftpServerFindDir(session, handle);
   
   if(fileObject == NULL)
      return ERROR_INVALID_HANDLE;

   
   while(!error)
   {
      
      error = fsReadDir(fileObject->dir, &dirEntry);

      
      if(!error)
      {
         
         pathCopy(context->path, fileObject->path, SFTP_SERVER_MAX_PATH_LEN);
         pathCombine(context->path, dirEntry.name, SFTP_SERVER_MAX_PATH_LEN);
         pathCanonicalize(context->path);

         
         perm = sftpServerGetFilePermissions(session, context->path);

         
         if((perm & SFTP_FILE_PERM_READ) != 0)
         {
            
            osStrcpy(context->path, dirEntry.name);

            
            name->filename.value = context->path;
            name->filename.length = osStrlen(context->path);

            
            if((dirEntry.attributes & FS_FILE_ATTR_DIRECTORY) != 0)
            {
               name->attributes.type = SSH_FILEXFER_TYPE_DIRECTORY;
            }
            else
            {
               name->attributes.type = SSH_FILEXFER_TYPE_REGULAR;
            }

            
            name->attributes.size = dirEntry.size;

            
            if((dirEntry.attributes & FS_FILE_ATTR_READ_ONLY) != 0)
            {
               name->attributes.permissions = SFTP_MODE_IRUSR;
            }
            else
            {
               name->attributes.permissions = SFTP_MODE_IRUSR | SFTP_MODE_IWUSR;
            }

            
            name->attributes.mtime = dirEntry.modified;
            name->attributes.atime = dirEntry.modified;

            
            if((dirEntry.attributes & FS_FILE_ATTR_READ_ONLY) != 0)
            {
               name->attributes.bits |= SSH_FILEXFER_ATTR_FLAGS_READONLY;
            }

            if((dirEntry.attributes & FS_FILE_ATTR_SYSTEM) != 0)
            {
               name->attributes.bits |= SSH_FILEXFER_ATTR_FLAGS_SYSTEM;
            }

            if((dirEntry.attributes & FS_FILE_ATTR_HIDDEN) != 0)
            {
               name->attributes.bits |= SSH_FILEXFER_ATTR_FLAGS_HIDDEN;
            }

            if((dirEntry.attributes & FS_FILE_ATTR_ARCHIVE) != 0)
            {
               name->attributes.bits |= SSH_FILEXFER_ATTR_FLAGS_ARCHIVE;
            }

            
            name->attributes.flags = SSH_FILEXFER_ATTR_SIZE |
               SSH_FILEXFER_ATTR_PERMISSIONS | SSH_FILEXFER_ATTR_ACMODTIME;

            
            break;
         }
      }
   }

   
   return error;
}




error_t sftpServerCloseDir(SftpServerSession *session,
   const SshBinaryString *handle)
{
   error_t error;
   SftpFileObject *fileObject;

   
   
   fileObject = sftpServerFindDir(session, handle);

   
   if(fileObject != NULL)
   {
      
      fsCloseDir(fileObject->dir);
      fileObject->dir = NULL;

      
      fileObject->type = SSH_FILEXFER_TYPE_INVALID;

      
      error = NO_ERROR;
   }
   else
   {
      
      error = ERROR_INVALID_HANDLE;
   }

   
   return error;
}




SftpFileObject *sftpServerFindDir(SftpServerSession *session,
   const SshBinaryString *handle)
{
   uint_t i;
   SftpServerContext *context;
   SftpFileObject *fileObject;

   
   context = session->context;

   
   if(handle->length == sizeof(uint32_t))
   {
      
      for(i = 0; i < context->numFileObjects; i++)
      {
         
         fileObject = &context->fileObjects[i];

         
         if(fileObject->type == SSH_FILEXFER_TYPE_DIRECTORY &&
            fileObject->session == session &&
            fileObject->handle == LOAD32BE(handle->value))
         {
            
            return fileObject;
         }
      }
   }

   
   return NULL;
}

#endif
",64,1839,2331
"#define TRACE_LEVEL TRACE_LEVEL_OFF





#include ""os_port.h""
#include ""os_port_embos.h""
#include ""debug.h""


void osIdleTaskHook(void);


static OS_TASK *tcbTable[OS_PORT_MAX_TASKS];
static void *stkTable[OS_PORT_MAX_TASKS];




void osInitKernel(void)
{
   
   osMemset(tcbTable, 0, sizeof(tcbTable));
   osMemset(stkTable, 0, sizeof(stkTable));

   
   OS_IncDI();
   
   OS_InitKern();
   
   OS_InitHW();
}




void osStartKernel(void)
{
   
   OS_Start();
}




bool_t osCreateStaticTask(OsTask *task, const char_t *name, OsTaskCode taskCode,
   void *param, void *stack, size_t stackSize, int_t priority)
{
   
   OS_CreateTaskEx(task, name, priority, taskCode,
      stack, stackSize * sizeof(uint_t), 1, param);

   
   return TRUE;
}




OsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,
   void *param, size_t stackSize, int_t priority)
{
   uint_t i;
   OS_TASK *task;
   void *stack;

   
   osSuspendAllTasks();

   
   for(i = 0; i < OS_PORT_MAX_TASKS; i++)
   {
      
      if(tcbTable[i] == NULL)
         break;
   }

   
   if(i < OS_PORT_MAX_TASKS)
   {
      
      task = osAllocMem(sizeof(OS_TASK));

      
      if(task != NULL)
      {
         
         stack = osAllocMem(stackSize * sizeof(uint_t));

         
         if(stack != NULL)
         {
            
            OS_CreateTaskEx(task, name, priority, taskCode,
               stack, stackSize * sizeof(uint_t), 1, param);

            
            tcbTable[i] = task;
            
            stkTable[i] = stack;
         }
         else
         {
            osFreeMem(task);
            
            task = NULL;
         }
      }
   }
   else
   {
      
      task = NULL;
   }

   
   osResumeAllTasks();

   
   return task;
}




void osDeleteTask(OsTask *task)
{
   
   OS_TerminateTask(task);
}




void osDelayTask(systime_t delay)
{
   
   OS_Delay(OS_MS_TO_SYSTICKS(delay));
}




void osSwitchTask(void)
{
   
}




void osSuspendAllTasks(void)
{
   
   if(OS_IsRunning())
   {
      
      OS_SuspendAllTasks();
   }
}




void osResumeAllTasks(void)
{
   
   if(OS_IsRunning())
   {
      
      OS_ResumeAllSuspendedTasks();
   }
}




bool_t osCreateEvent(OsEvent *event)
{
   
   OS_EVENT_Create(event);

   
   return TRUE;
}




void osDeleteEvent(OsEvent *event)
{
   
   if(OS_IsRunning())
   {
      
      OS_EVENT_Delete(event);
   }
}




void osSetEvent(OsEvent *event)
{
   
   OS_EVENT_Set(event);
}




void osResetEvent(OsEvent *event)
{
   
   OS_EVENT_Reset(event);
}




bool_t osWaitForEvent(OsEvent *event, systime_t timeout)
{
   bool_t ret;

   
   
   if(timeout == 0)
   {
      
      ret = OS_EVENT_Get(event);
   }
   else if(timeout == INFINITE_DELAY)
   {
      
      OS_EVENT_Wait(event);
      ret = TRUE;
   }
   else
   {
      
      ret = !OS_EVENT_WaitTimed(event, OS_MS_TO_SYSTICKS(timeout));
   }

   
   return ret;
}




bool_t osSetEventFromIsr(OsEvent *event)
{
   
   OS_EVENT_Set(event);

   
   return FALSE;
}




bool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)
{
   
   OS_CreateCSema(semaphore, count);

   
   return TRUE;
}




void osDeleteSemaphore(OsSemaphore *semaphore)
{
   
   if(OS_IsRunning())
   {
      
      OS_DeleteCSema(semaphore);
   }
}




bool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)
{
   bool_t ret;

   
   if(timeout == 0)
   {
      
      ret = OS_CSemaRequest(semaphore);
   }
   else if(timeout == INFINITE_DELAY)
   {
      
      OS_WaitCSema(semaphore);
      ret = TRUE;
   }
   else
   {
      
      ret = OS_WaitCSemaTimed(semaphore, OS_MS_TO_SYSTICKS(timeout));
   }

   
   return ret;
}




void osReleaseSemaphore(OsSemaphore *semaphore)
{
   
   OS_SignalCSema(semaphore);
}




bool_t osCreateMutex(OsMutex *mutex)
{
   
   OS_CreateRSema(mutex);

   
   return TRUE;
}




void osDeleteMutex(OsMutex *mutex)
{
   
   if(OS_IsRunning())
   {
      
      OS_DeleteRSema(mutex);
   }
}




void osAcquireMutex(OsMutex *mutex)
{
   
   OS_Use(mutex);
}




void osReleaseMutex(OsMutex *mutex)
{
   
   OS_Unuse(mutex);
}




systime_t osGetSystemTime(void)
{
   systime_t time;

   
   time = OS_GetTime32();

   
   return OS_SYSTICKS_TO_MS(time);
}




void *osAllocMem(size_t size)
{
   void *p;

   
   p = OS_malloc(size);

   
   TRACE_DEBUG(""Allocating %"" PRIuSIZE "" bytes at 0x%08"" PRIXPTR ""\r\n"", size, (uintptr_t) p);

   
   return p;
}




void osFreeMem(void *p)
{
   
   if(p != NULL)
   {
      
      TRACE_DEBUG(""Freeing memory at 0x%08"" PRIXPTR ""\r\n"", (uintptr_t) p);

      
      OS_free(p);
   }
}
",64,1840,1955
"#define TRACE_LEVEL TLS_TRACE_LEVEL


#include ""tls.h""
#include ""tls_handshake.h""
#include ""tls_client_fsm.h""
#include ""tls_server_fsm.h""
#include ""tls_common.h""
#include ""tls_transcript_hash.h""
#include ""tls_record.h""
#include ""tls13_server_misc.h""
#include ""dtls_record.h""
#include ""debug.h""


#if (TLS_SUPPORT == ENABLED)




error_t tlsInitHandshake(TlsContext *context)
{
   
   if(context->txBuffer == NULL)
   {
      
      context->txBuffer = tlsAllocMem(context->txBufferSize);

      
      if(context->txBuffer == NULL)
         return ERROR_OUT_OF_MEMORY;

      
      osMemset(context->txBuffer, 0, context->txBufferSize);
   }

   
   if(context->rxBuffer == NULL)
   {
      
      context->rxBuffer = tlsAllocMem(context->rxBufferSize);

      
      if(context->rxBuffer == NULL)
         return ERROR_OUT_OF_MEMORY;

      
      osMemset(context->rxBuffer, 0, context->rxBufferSize);
   }

#if (TLS_MAX_VERSION >= TLS_VERSION_1_3 && TLS_MIN_VERSION <= TLS_VERSION_1_3)
   
   if(context->entity == TLS_CONNECTION_END_SERVER)
   {
      
      context->earlyDataRejected = TRUE;
   }
#endif

   
   
   context->state = TLS_STATE_CLIENT_HELLO;

   
   return NO_ERROR;
}




error_t tlsPerformHandshake(TlsContext *context)
{
   error_t error;

#if (TLS_CLIENT_SUPPORT == ENABLED)
   
   if(context->entity == TLS_CONNECTION_END_CLIENT)
   {
      
      error = tlsPerformClientHandshake(context);
   }
   else
#endif
#if (TLS_SERVER_SUPPORT == ENABLED)
   
   if(context->entity == TLS_CONNECTION_END_SERVER)
   {
      
      error = tlsPerformServerHandshake(context);
   }
   else
#endif
   
   {
      
      error = ERROR_INVALID_PARAMETER;
   }

   
   return error;
}




error_t tlsSendHandshakeMessage(TlsContext *context, const void *data,
   size_t length, TlsMessageType type)
{
   error_t error;

#if (DTLS_SUPPORT == ENABLED)
   
   if(context->transportProtocol == TLS_TRANSPORT_PROTOCOL_DATAGRAM)
   {
      DtlsHandshake *message;

      
      message = (DtlsHandshake *) data;

      
      osMemmove(message->data, data, length);

      
      message->msgType = type;
      
      STORE24BE(length, message->length);
      
      message->msgSeq = htons(context->txMsgSeq);
      
      STORE24BE(0, message->fragOffset);
      
      STORE24BE(length, message->fragLength);

      
      
      context->txMsgSeq++;

      
      length += sizeof(DtlsHandshake);
   }
   else
#endif
   
   {
      TlsHandshake *message;

      
      message = (TlsHandshake *) data;

      
      osMemmove(message->data, data, length);

      
      message->msgType = type;
      
      STORE24BE(length, message->length);

      
      length += sizeof(TlsHandshake);
   }

   
   
   
   if(type != TLS_TYPE_HELLO_REQUEST)
   {
      tlsUpdateTranscriptHash(context, data, length);
   }

#if (DTLS_SUPPORT == ENABLED)
   
   if(context->transportProtocol == TLS_TRANSPORT_PROTOCOL_DATAGRAM)
   {
      
      error = dtlsWriteProtocolData(context, data, length, TLS_TYPE_HANDSHAKE);
   }
   else
#endif
   
   {
      
      error = tlsWriteProtocolData(context, data, length, TLS_TYPE_HANDSHAKE);
   }

   
   return error;
}




error_t tlsReceiveHandshakeMessage(TlsContext *context)
{
   error_t error;
   size_t length;
   uint8_t *data;
   TlsContentType contentType;

#if (DTLS_SUPPORT == ENABLED)
   
   if(context->transportProtocol == TLS_TRANSPORT_PROTOCOL_DATAGRAM)
   {
      
      error = dtlsReadProtocolData(context, &data, &length, &contentType);
   }
   else
#endif
   
   {
      
      error = tlsReadProtocolData(context, &data, &length, &contentType);
   }

   
   if(!error)
   {
      
      context->rxBufferPos += length;
      
      context->rxBufferLen -= length;

      
      if(contentType == TLS_TYPE_HANDSHAKE)
      {
         
         error = tlsParseHandshakeMessage(context, data, length);
      }
      
      else if(contentType == TLS_TYPE_CHANGE_CIPHER_SPEC)
      {
         
         
         
         error = tlsParseChangeCipherSpec(context, (TlsChangeCipherSpec *) data,
            length);
      }
      
      else if(contentType == TLS_TYPE_ALERT)
      {
         
         error = tlsParseAlert(context, (TlsAlert *) data, length);
      }
#if (TLS_MAX_VERSION >= TLS_VERSION_1_3 && TLS_MIN_VERSION <= TLS_VERSION_1_3)
      
      else if(contentType == TLS_TYPE_APPLICATION_DATA)
      {
#if (TLS_SERVER_SUPPORT == ENABLED)
         
         if(context->entity == TLS_CONNECTION_END_SERVER)
         {
            
            error = tls13ProcessEarlyData(context, data, length);
         }
         else
#endif
         {
            
            
            error = ERROR_UNEXPECTED_MESSAGE;
         }
      }
#endif
      
      else
      {
         
         error = ERROR_UNEXPECTED_MESSAGE;
      }
   }

   
   return error;
}




error_t tlsParseHandshakeMessage(TlsContext *context, const uint8_t *message,
   size_t length)
{
   error_t error;
   uint8_t msgType;
   size_t n;
   const void *p;

#if (DTLS_SUPPORT == ENABLED)
   
   if(context->transportProtocol == TLS_TRANSPORT_PROTOCOL_DATAGRAM)
   {
      
      msgType = ((DtlsHandshake *) message)->msgType;
      
      p = message + sizeof(DtlsHandshake);
      
      n = length - sizeof(DtlsHandshake);
   }
   else
#endif
   
   {
      
      msgType = ((TlsHandshake *) message)->msgType;
      
      p = message + sizeof(TlsHandshake);
      
      n = length - sizeof(TlsHandshake);
   }

#if (TLS_MAX_KEY_UPDATE_MESSAGES > 0)
   
   if(msgType != TLS_TYPE_KEY_UPDATE)
      context->keyUpdateCount = 0;
#endif

#if (TLS_CLIENT_SUPPORT == ENABLED)
   
   if(context->entity == TLS_CONNECTION_END_CLIENT)
   {
      
      error = tlsParseServerHandshakeMessage(context, msgType, p, n);

      
      tlsUpdateTranscriptHash(context, message, length);
   }
   else
#endif
#if (TLS_SERVER_SUPPORT == ENABLED)
   
   if(context->entity == TLS_CONNECTION_END_SERVER)
   {
      
      if(msgType == TLS_TYPE_CLIENT_KEY_EXCHANGE)
      {
         tlsUpdateTranscriptHash(context, message, length);
      }

      
      error = tlsParseClientHandshakeMessage(context, msgType, p, n);

      
      if(msgType != TLS_TYPE_CLIENT_KEY_EXCHANGE)
      {
         tlsUpdateTranscriptHash(context, message, length);
      }
   }
   else
#endif
   
   {
      
      error = ERROR_FAILURE;
   }

   
   return error;
}

#endif
",64,1841,2333
"#define TRACE_LEVEL SCP_TRACE_LEVEL


#include ""ssh/ssh.h""
#include ""scp/scp_server.h""
#include ""scp/scp_server_file.h""
#include ""scp/scp_server_directory.h""
#include ""scp/scp_server_misc.h""
#include ""path.h""
#include ""debug.h""


#if (SCP_SERVER_SUPPORT == ENABLED)




error_t scpServerCreateDir(ScpServerSession *session, const char_t *name)
{
   error_t error;
   uint_t perm;

   
   pathCombine(session->path, name, SCP_SERVER_MAX_PATH_LEN);
   pathCanonicalize(session->path);
   pathRemoveSlash(session->path);

   
   if(!fsDirExists(session->path))
   {
      
      perm = scpServerGetFilePermissions(session, session->path);

      
      if((perm & SCP_FILE_PERM_WRITE) != 0)
      {
         
         error = fsCreateDir(session->path);

         
         if(error)
         {
            
            error = ERROR_DIRECTORY_NOT_FOUND;
         }
      }
      else
      {
         
         error = ERROR_ACCESS_DENIED;
      }
   }
   else
   {
      
      error = NO_ERROR;
   }

   
   if(!error)
   {
      
      session->dirLevel++;
   }

   
   return error;
}




error_t scpServerOpenDir(ScpServerSession *session)
{
   error_t error;
   uint_t perm;

   
   perm = scpServerGetFilePermissions(session, session->path);

   
   if((perm & SCP_FILE_PERM_READ) != 0)
   {
      
      session->dir[session->dirLevel] = fsOpenDir(session->path);

      
      if(session->dir[session->dirLevel] != NULL)
      {
         
         
         session->fileMode = SCP_MODE_IRWXU | SCP_MODE_IRWXG | SCP_MODE_IRWXO;

         
         error = NO_ERROR;
      }
      else
      {
         
         error = ERROR_DIRECTORY_NOT_FOUND;
      }
   }
   else
   {
      
      error = ERROR_ACCESS_DENIED;
   }

   
   return error;
}




void scpServerGetNextDirEntry(ScpServerSession *session)
{
   error_t error;
   uint_t perm;
   FsDirEntry dirEntry;

   
   while(1)
   {
      
      error = fsReadDir(session->dir[session->dirLevel], &dirEntry);

      
      if(!error)
      {
         
         if(!osStrcmp(dirEntry.name, ""."") || !osStrcmp(dirEntry.name, ""..""))
         {
            
         }
         else
         {
            
            pathCombine(session->path, dirEntry.name, SCP_SERVER_MAX_PATH_LEN);
            pathCanonicalize(session->path);

            
            perm = scpServerGetFilePermissions(session, session->path);

            
            if((perm & SCP_FILE_PERM_LIST) != 0)
            {
               
               if((dirEntry.attributes & FS_FILE_ATTR_DIRECTORY) != 0)
               {
                  
                  if((session->dirLevel + 1) < SCP_SERVER_MAX_RECURSION_LEVEL)
                  {
                     
                     session->dirLevel++;

                     
                     error = scpServerOpenDir(session);

                     
                     if(error)
                     {
                        
                        session->dirLevel--;
                     }
                  }
                  else
                  {
                     
                     error = ERROR_OPEN_FAILED;
                  }
               }
               else
               {
                  
                  error = scpServerOpenFileForReading(session);
               }

               
               if(!error)
               {
                  break;
               }
            }

            
            pathRemoveFilename(session->path);
            pathRemoveSlash(session->path);
         }
      }
      else
      {
         
         break;
      }
   }

   
   if(error)
   {
      
      fsCloseDir(session->dir[session->dirLevel]);
      session->dir[session->dirLevel] = NULL;

      
      if(session->dirLevel > 0)
      {
         pathRemoveFilename(session->path);
         pathRemoveSlash(session->path);
      }
   }

   
   session->state = SCP_SERVER_SESSION_STATE_READ_COMMAND;
}

#endif
",64,1842,1269
"#include ""debug.h""




void debugDisplayArray(FILE *stream,
   const char_t *prepend, const void *data, size_t length)
{
   uint_t i;

   
   for(i = 0; i < length; i++)
   {
      
      if((i % 16) == 0)
      {
         TRACE_PRINTF(""%s"", prepend);
      }

      
      TRACE_PRINTF(""%02"" PRIX8 "" "", *((const uint8_t *) data + i));

      
      if((i % 16) == 15 || i == (length - 1))
      {
         TRACE_PRINTF(""\r\n"");
      }
   }
}
",64,1843,191
"#define TRACE_LEVEL SSH_TRACE_LEVEL


#include ""ssh/ssh.h""
#include ""ssh/ssh_signature.h""
#include ""ssh/ssh_exchange_hash.h""
#include ""ssh/ssh_misc.h""
#include ""debug.h""


#if (SSH_SUPPORT == ENABLED)




error_t sshInitExchangeHash(SshConnection *connection)
{
   error_t error;
   const HashAlgo *hashAlgo;

   
   error = NO_ERROR;

#if (SSH_SHA1_SUPPORT == ENABLED)
   
   if(sshCompareAlgo(connection->kexAlgo, ""diffie-hellman-group1-sha1"") ||
      sshCompareAlgo(connection->kexAlgo, ""diffie-hellman-group14-sha1"") ||
      sshCompareAlgo(connection->kexAlgo, ""diffie-hellman-group-exchange-sha1""))
   {
      
      hashAlgo = SHA1_HASH_ALGO;
   }
   else
#endif
#if (SSH_SHA256_SUPPORT == ENABLED)
   
   if(sshCompareAlgo(connection->kexAlgo, ""diffie-hellman-group14-sha256"") ||
      sshCompareAlgo(connection->kexAlgo, ""diffie-hellman-group-exchange-sha256"") ||
      sshCompareAlgo(connection->kexAlgo, ""ecdh-sha2-nistp256"") ||
      sshCompareAlgo(connection->kexAlgo, ""curve25519-sha256"") ||
      sshCompareAlgo(connection->kexAlgo, ""curve25519-sha256@libssh.org""))
   {
      
      hashAlgo = SHA256_HASH_ALGO;
   }
   else
#endif
#if (SSH_SHA384_SUPPORT == ENABLED)
   
   if(sshCompareAlgo(connection->kexAlgo, ""ecdh-sha2-nistp384""))
   {
      
      hashAlgo = SHA384_HASH_ALGO;
   }
   else
#endif
#if (SSH_SHA512_SUPPORT == ENABLED)
   
   if(sshCompareAlgo(connection->kexAlgo, ""diffie-hellman-group15-sha512"") ||
      sshCompareAlgo(connection->kexAlgo, ""diffie-hellman-group16-sha512"") ||
      sshCompareAlgo(connection->kexAlgo, ""ecdh-sha2-nistp521"") ||
      sshCompareAlgo(connection->kexAlgo, ""curve448-sha512""))
   {
      
      hashAlgo = SHA512_HASH_ALGO;
   }
   else
#endif
   
   {
      
      hashAlgo = NULL;
   }

   
   if(hashAlgo != NULL)
   {
      
      
      connection->hashAlgo = hashAlgo;

      
      hashAlgo->init(connection->hashContext);
   }
   else
   {
      
      error = ERROR_UNSUPPORTED_KEY_EXCH_METHOD;
   }

   
   return error;
}




error_t sshUpdateExchangeHash(SshConnection *connection, const void *data,
   size_t length)
{
   error_t error;
   uint8_t temp[4];

   
   error = NO_ERROR;

   
   if(connection->hashAlgo != NULL)
   {
      
      STORE32BE(length, temp);

      
      connection->hashAlgo->update(connection->hashContext, temp, sizeof(temp));
      
      connection->hashAlgo->update(connection->hashContext, data, length);
   }
   else
   {
      
      error = ERROR_FAILURE;
   }

   
   return error;
}




error_t sshFinalizeExchangeHash(SshConnection *connection, uint8_t *digest,
   size_t *digestLen)
{
   error_t error;

   
   error = NO_ERROR;

   
   if(connection->hashAlgo != NULL)
   {
      
      connection->hashAlgo->final(connection->hashContext, digest);
      
      *digestLen = connection->hashAlgo->digestSize;
   }
   else
   {
      
      error = ERROR_FAILURE;
   }

   
   return error;
}




error_t sshGenerateExchangeHashSignature(SshConnection *connection, uint8_t *p,
   size_t *written)
{
   error_t error;
   SshHostKey *hostKey;

   
   error = sshFinalizeExchangeHash(connection, connection->h,
      &connection->hLen);

   
   if(!error)
   {
      
      if(!connection->newKeysSent)
      {
         
         
         
         
         osMemcpy(connection->sessionId, connection->h, connection->hLen);
         connection->sessionIdLen = connection->hLen;
      }

      
      hostKey = sshGetHostKey(connection);

      
      if(hostKey != NULL)
      {
         
         error = sshGenerateSignature(connection, connection->serverHostKeyAlgo,
            hostKey, connection->h, connection->hLen, p, written);
      }
      else
      {
         
         error = ERROR_INVALID_KEY;
      }
   }

   
   return error;
}




error_t sshVerifyExchangeHashSignature(SshConnection *connection,
   const SshBinaryString *serverHostKey, const SshBinaryString *signature)
{
   error_t error;
   SshString serverHostKeyAlgo;

   
   error = sshFinalizeExchangeHash(connection, connection->h,
      &connection->hLen);

   
   if(!error)
   {
      
      if(!connection->newKeysSent)
      {
         
         
         
         
         osMemcpy(connection->sessionId, connection->h, connection->hLen);
         connection->sessionIdLen = connection->hLen;
      }

      
      serverHostKeyAlgo.value = connection->serverHostKeyAlgo;
      serverHostKeyAlgo.length = osStrlen(connection->serverHostKeyAlgo);

      
      error = sshVerifySignature(connection, &serverHostKeyAlgo, serverHostKey,
         connection->h, connection->hLen, signature);
   }

   
   return error;
}

#endif
",64,1844,1725
"#define TRACE_LEVEL TRACE_LEVEL_OFF




#include ""os_port.h""
#include ""os_port_cmsis_rtos2.h""
#include ""debug.h""




void osInitKernel(void)
{
   
   osKernelInitialize();
}




void osStartKernel(void)
{
   
   osKernelStart();
}




OsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,
   void *param, size_t stackSize, int_t priority)
{
   osThreadId_t threadId;
   osThreadAttr_t threadAttr;

   
   threadAttr.name = name;
   threadAttr.attr_bits = 0;
   threadAttr.cb_mem = NULL;
   threadAttr.cb_size = 0;
   threadAttr.stack_mem = NULL;
   threadAttr.stack_size = stackSize * sizeof(uint_t);
   threadAttr.priority = (osPriority_t) priority;
   threadAttr.tz_module = 0;
   threadAttr.reserved = 0;

   
   threadId = osThreadNew(taskCode, param, &threadAttr);
   
   return (OsTask *) threadId;
}




void osDeleteTask(OsTask *task)
{
   
   if(task == NULL)
      osThreadExit();
   else
      osThreadTerminate((osThreadId_t) task);
}




void osDelayTask(systime_t delay)
{
   
   osDelay(OS_MS_TO_SYSTICKS(delay));
}




void osSwitchTask(void)
{
   
   osThreadYield();
}




void osSuspendAllTasks(void)
{
   
   if(osKernelGetState() != osKernelInactive)
   {
      
      osKernelLock();
   }
}




void osResumeAllTasks(void)
{
   
   if(osKernelGetState() != osKernelInactive)
   {
      
      osKernelUnlock();
   }
}




bool_t osCreateEvent(OsEvent *event)
{
   osEventFlagsAttr_t eventFlagsAttr;

   
   eventFlagsAttr.name = NULL;
   eventFlagsAttr.attr_bits = 0;

#if defined(os_CMSIS_RTX)
   eventFlagsAttr.cb_mem = &event->cb;
   eventFlagsAttr.cb_size = sizeof(os_event_flags_t);
#elif defined(osRtxVersionKernel)
   eventFlagsAttr.cb_mem = &event->cb;
   eventFlagsAttr.cb_size = sizeof(osRtxEventFlags_t);
#else
   eventFlagsAttr.cb_mem = NULL;
   eventFlagsAttr.cb_size = 0;
#endif

   
   event->id = osEventFlagsNew(&eventFlagsAttr);

   
   if(event->id != NULL)
      return TRUE;
   else
      return FALSE;
}




void osDeleteEvent(OsEvent *event)
{
   
   if(event->id != NULL)
   {
      
      osEventFlagsDelete(event->id);
   }
}




void osSetEvent(OsEvent *event)
{
   
   osEventFlagsSet(event->id, 1);
}




void osResetEvent(OsEvent *event)
{
   
   osEventFlagsClear(event->id, 1);
}




bool_t osWaitForEvent(OsEvent *event, systime_t timeout)
{
   uint32_t flags;

   
   
   if(timeout == INFINITE_DELAY)
   {
      
      flags = osEventFlagsWait(event->id, 1, osFlagsWaitAny, osWaitForever);
   }
   else
   {
      
      flags = osEventFlagsWait(event->id, 1, osFlagsWaitAny,
         OS_MS_TO_SYSTICKS(timeout));
   }

   
   if(flags == 1)
      return TRUE;
   else
      return FALSE;
}




bool_t osSetEventFromIsr(OsEvent *event)
{
   
   osEventFlagsSet(event->id, 1);

   
   return FALSE;
}




bool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)
{
   osSemaphoreAttr_t semaphoreAttr;

   
   semaphoreAttr.name = NULL;
   semaphoreAttr.attr_bits = 0;

#if defined(os_CMSIS_RTX)
   semaphoreAttr.cb_mem = &semaphore->cb;
   semaphoreAttr.cb_size = sizeof(os_semaphore_t);
#elif defined(osRtxVersionKernel)
   semaphoreAttr.cb_mem = &semaphore->cb;
   semaphoreAttr.cb_size = sizeof(osRtxSemaphore_t);
#else
   semaphoreAttr.cb_mem = NULL;
   semaphoreAttr.cb_size = 0;
#endif

   
   semaphore->id = osSemaphoreNew(count, count, &semaphoreAttr);

   
   if(semaphore->id != NULL)
      return TRUE;
   else
      return FALSE;
}




void osDeleteSemaphore(OsSemaphore *semaphore)
{
   
   if(semaphore->id != NULL)
   {
      
      osSemaphoreDelete(semaphore->id);
   }
}




bool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)
{
   osStatus_t status;

   
   if(timeout == INFINITE_DELAY)
   {
      
      status = osSemaphoreAcquire(semaphore->id, osWaitForever);
   }
   else
   {
      
      status = osSemaphoreAcquire(semaphore->id, OS_MS_TO_SYSTICKS(timeout));
   }

   
   if(status == osOK)
      return TRUE;
   else
      return FALSE;
}




void osReleaseSemaphore(OsSemaphore *semaphore)
{
   
   osSemaphoreRelease(semaphore->id);
}




bool_t osCreateMutex(OsMutex *mutex)
{
   osMutexAttr_t mutexAttr;

   
   mutexAttr.name = NULL;
   mutexAttr.attr_bits = 0;

#if defined(os_CMSIS_RTX)
   mutexAttr.cb_mem = &mutex->cb;
   mutexAttr.cb_size = sizeof(os_mutex_t);
#elif defined(osRtxVersionKernel)
   mutexAttr.cb_mem = &mutex->cb;
   mutexAttr.cb_size = sizeof(osRtxMutex_t);
#else
   mutexAttr.cb_mem = NULL;
   mutexAttr.cb_size = 0;
#endif

   
   mutex->id = osMutexNew(&mutexAttr);

   
   if(mutex->id != NULL)
      return TRUE;
   else
      return FALSE;
}




void osDeleteMutex(OsMutex *mutex)
{
   
   if(mutex->id != NULL)
   {
      
      osMutexDelete(mutex->id);
   }
}




void osAcquireMutex(OsMutex *mutex)
{
   
   osMutexAcquire(mutex->id, osWaitForever);
}




void osReleaseMutex(OsMutex *mutex)
{
   
   osMutexRelease(mutex->id);
}




systime_t osGetSystemTime(void)
{
   systime_t time;

   
   time = osKernelGetTickCount();

   
   return OS_SYSTICKS_TO_MS(time);
}




void *osAllocMem(size_t size)
{
   void *p;

   
   osSuspendAllTasks();
   
   p = malloc(size);
   
   osResumeAllTasks();

   
   TRACE_DEBUG(""Allocating %u bytes at 0x%08X\r\n"", size, (uint_t) p);

   
   return p;
}




void osFreeMem(void *p)
{
   
   if(p != NULL)
   {
      
      TRACE_DEBUG(""Freeing memory at 0x%08X\r\n"", (uint_t) p);

      
      osSuspendAllTasks();
      
      free(p);
      
      osResumeAllTasks();
   }
}
",64,1845,2288
"#define TRACE_LEVEL TRACE_LEVEL_OFF




#include ""os_port.h""
#include ""os_port_none.h""
#include ""debug.h""


#if defined(__linux__) || defined(__FreeBSD__)
   
#elif defined(_WIN32)
   
#endif


systime_t systemTicks = 0;




void osInitKernel(void)
{
   
   systemTicks = 0;
}




void osStartKernel(void)
{
}




OsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,
   void *param, size_t stackSize, int_t priority)
{
   
   return (OsTask *) (-1);
}




void osDeleteTask(OsTask *task)
{
}




void osDelayTask(systime_t delay)
{
}




void osSwitchTask(void)
{
}




void osSuspendAllTasks(void)
{
}




void osResumeAllTasks(void)
{
}




bool_t osCreateEvent(OsEvent *event)
{
   
   *event = FALSE;
   
   return TRUE;
}




void osDeleteEvent(OsEvent *event)
{
}




void osSetEvent(OsEvent *event)
{
   
   *event = TRUE;
}




void osResetEvent(OsEvent *event)
{
   
   *event = FALSE;
}




bool_t osWaitForEvent(OsEvent *event, systime_t timeout)
{
   
   if(*event)
   {
      
      *event = FALSE;
      
      return TRUE;
   }
   else
   {
      
      return FALSE;
   }
}




bool_t osSetEventFromIsr(OsEvent *event)
{
   
   *event = TRUE;
   
   return FALSE;
}




bool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)
{
   
   *semaphore = count;
   
   return TRUE;
}




void osDeleteSemaphore(OsSemaphore *semaphore)
{
}




bool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)
{
   
   if(*semaphore > 0)
   {
      
      *semaphore -= 1;
      
      return TRUE;
   }
   else
   {
      
      return FALSE;
   }
}




void osReleaseSemaphore(OsSemaphore *semaphore)
{
   
   *semaphore += 1;
}




bool_t osCreateMutex(OsMutex *mutex)
{
   
   return TRUE;
}




void osDeleteMutex(OsMutex *mutex)
{
}




void osAcquireMutex(OsMutex *mutex)
{
}




void osReleaseMutex(OsMutex *mutex)
{
}




systime_t osGetSystemTime(void)
{
   systime_t time;

#if defined(__linux__) || defined(__FreeBSD__)
   struct timeval tv;
   
   gettimeofday(&tv, NULL);
   
   time = (tv.tv_sec * 1000) + (tv.tv_usec / 1000);
#elif defined(_WIN32)
   
   time = GetTickCount();
#else
   
   time = systemTicks;
#endif

   
   return OS_SYSTICKS_TO_MS(time);
}




void *osAllocMem(size_t size)
{
   void *p;

   
   p = malloc(size);

   
   TRACE_DEBUG(""Allocating %"" PRIuSIZE "" bytes at 0x%08"" PRIXPTR ""\r\n"", size, (uintptr_t) p);

   
   return p;
}




void osFreeMem(void *p)
{
   
   if(p != NULL)
   {
      
      TRACE_DEBUG(""Freeing memory at 0x%08"" PRIXPTR ""\r\n"", (uintptr_t) p);

      
      free(p);
   }
}
",64,1846,1159
"#define TRACE_LEVEL TRACE_LEVEL_OFF





#include ""os_port.h""
#include ""os_port_chibios.h""
#include ""debug.h""


static OsTask taskTable[OS_PORT_MAX_TASKS];
static uint_t *waTable[OS_PORT_MAX_TASKS];




void osInitKernel(void)
{
   
   osMemset(taskTable, 0, sizeof(taskTable));
   osMemset(waTable, 0, sizeof(waTable));

   
   chSysInit();
}




void osStartKernel(void)
{
   
   chThdExit(MSG_OK);
}




bool_t osCreateStaticTask(OsTask *task, const char_t *name, OsTaskCode taskCode,
   void *param, void *stack, size_t stackSize, int_t priority)
{
   
   stackSize *= sizeof(uint_t);

   
   task->tp = chThdCreateStatic(stack, stackSize,
      priority, (tfunc_t) taskCode, param);

   
   if(task->tp != NULL)
      return TRUE;
   else
      return FALSE;
}




OsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,
   void *param, size_t stackSize, int_t priority)
{
   uint_t i;
   void *wa;
   OsTask *task = NULL;

   
   stackSize *= sizeof(uint_t);

   
   wa = osAllocMem(THD_WORKING_AREA_SIZE(stackSize));

   
   if(wa != NULL)
   {
      
      chSysLock();

      
      for(i = 0; i < OS_PORT_MAX_TASKS; i++)
      {
         
         if(taskTable[i].tp == NULL)
            break;
      }

      
      if(i < OS_PORT_MAX_TASKS)
      {
         
         taskTable[i].tp = chThdCreateI(wa, THD_WORKING_AREA_SIZE(stackSize),
            priority, (tfunc_t) taskCode, param);

         
         if(taskTable[i].tp != NULL)
         {
            
            chSchWakeupS(taskTable[i].tp, MSG_OK);

            
            task = &taskTable[i];
            
            waTable[i] = wa;

            
            chSysUnlock();
         }
         else
         {
            
            chSysUnlock();
            
            osFreeMem(wa);
         }
      }
      else
      {
         
         chSysUnlock();
         
         osFreeMem(wa);
      }
   }

   
   return task;
}




void osDeleteTask(OsTask *task)
{
   
   if(task == NULL)
      chThdExit(MSG_OK);
   else
      chThdTerminate(task->tp);
}




void osDelayTask(systime_t delay)
{
   
   chThdSleep(OS_MS_TO_SYSTICKS(delay));
}




void osSwitchTask(void)
{
   
   chThdYield();
}




void osSuspendAllTasks(void)
{
   
   chSysLock();
}




void osResumeAllTasks(void)
{
   
   chSysUnlock();
}




bool_t osCreateEvent(OsEvent *event)
{
   
   chBSemObjectInit(event, TRUE);

   
   return TRUE;
}




void osDeleteEvent(OsEvent *event)
{
   
}




void osSetEvent(OsEvent *event)
{
   
   chBSemSignal(event);
}




void osResetEvent(OsEvent *event)
{
   
   chBSemReset(event, TRUE);
}




bool_t osWaitForEvent(OsEvent *event, systime_t timeout)
{
   msg_t msg;

   
   
   if(timeout == 0)
   {
      
      msg = chBSemWaitTimeout(event, TIME_IMMEDIATE);
   }
   else if(timeout == INFINITE_DELAY)
   {
      
      msg = chBSemWaitTimeout(event, TIME_INFINITE);
   }
   else
   {
      
      msg = chBSemWaitTimeout(event, OS_MS_TO_SYSTICKS(timeout));
   }

   
   if(msg == MSG_OK)
      return TRUE;
   else
      return FALSE;
}




bool_t osSetEventFromIsr(OsEvent *event)
{
   
   chBSemSignalI(event);

   
   return FALSE;
}




bool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)
{
   
   chSemObjectInit(semaphore, count);

   
   return TRUE;
}




void osDeleteSemaphore(OsSemaphore *semaphore)
{
   
}




bool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)
{
   msg_t msg;

   
   if(timeout == 0)
   {
      
      msg = chSemWaitTimeout(semaphore, TIME_IMMEDIATE);
   }
   else if(timeout == INFINITE_DELAY)
   {
      
      msg = chSemWaitTimeout(semaphore, TIME_INFINITE);
   }
   else
   {
      
      msg = chSemWaitTimeout(semaphore, OS_MS_TO_SYSTICKS(timeout));
   }

   
   if(msg == MSG_OK)
      return TRUE;
   else
      return FALSE;
}




void osReleaseSemaphore(OsSemaphore *semaphore)
{
   
   chSemSignal(semaphore);
}




bool_t osCreateMutex(OsMutex *mutex)
{
   
   chMtxObjectInit(mutex);

   
   return TRUE;
}




void osDeleteMutex(OsMutex *mutex)
{
   
}




void osAcquireMutex(OsMutex *mutex)
{
   
   chMtxLock(mutex);
}




void osReleaseMutex(OsMutex *mutex)
{
   
#if (CH_KERNEL_MAJOR < 3)
   chMtxUnlock();
#else
   chMtxUnlock(mutex);
#endif
}




systime_t osGetSystemTime(void)
{
   systime_t time;

   
   time = chVTGetSystemTime();

   
   return OS_SYSTICKS_TO_MS(time);
}




void *osAllocMem(size_t size)
{
   void *p;

   
   p = chHeapAlloc(NULL, size);

   
   TRACE_DEBUG(""Allocating %"" PRIuSIZE "" bytes at 0x%08"" PRIXPTR ""\r\n"", size, (uintptr_t) p);

   
   return p;
}




void osFreeMem(void *p)
{
   
   if(p != NULL)
   {
      
      TRACE_DEBUG(""Freeing memory at 0x%08"" PRIXPTR ""\r\n"", (uintptr_t) p);

      
      chHeapFree(p);
   }
}




void osIdleLoopHook(void)
{
   uint_t i;

   
   for(i = 0; i < OS_PORT_MAX_TASKS; i++)
   {
      
      if(taskTable[i].tp != NULL)
      {
         
         if(chThdTerminatedX(taskTable[i].tp))
         {
            
            osFreeMem(waTable[i]);

            
            waTable[i] = NULL;
            taskTable[i].tp = NULL;
         }
      }
   }
}
",64,1847,2141
"#define TRACE_LEVEL SSH_TRACE_LEVEL


#include ""ssh/ssh.h""
#include ""ssh/ssh_algorithms.h""
#include ""ssh/ssh_transport.h""
#include ""ssh/ssh_auth.h""
#include ""ssh/ssh_auth_public_key.h""
#include ""ssh/ssh_packet.h""
#include ""ssh/ssh_signature.h""
#include ""ssh/ssh_misc.h""
#include ""debug.h""


#if (SSH_SUPPORT == ENABLED && SSH_PUBLIC_KEY_AUTH_SUPPORT == ENABLED)




error_t sshSendUserAuthPkOk(SshConnection *connection,
   const SshString *publicKeyAlgo, const SshBinaryString *publicKey)
{
#if (SSH_SERVER_SUPPORT == ENABLED)
   error_t error;
   size_t length;
   uint8_t *message;

   
   message = connection->buffer + SSH_PACKET_HEADER_SIZE;

   
   error = sshFormatUserAuthPkOk(connection, publicKeyAlgo, publicKey, message,
      &length);

   
   if(!error)
   {
      
      TRACE_INFO(""Sending SSH_MSG_USERAUTH_PK_OK message (%"" PRIuSIZE "" bytes)...\r\n"", length);
      TRACE_VERBOSE_ARRAY(""  "", message, length);

      
      error = sshSendPacket(connection, message, length);
   }

   
   return error;
#else
   
   return ERROR_NOT_IMPLEMENTED;
#endif
}




error_t sshFormatPublicKeyAuthParams(SshConnection *connection,
   const uint8_t *message, size_t messageLen, uint8_t *p, size_t *written)
{
#if (SSH_CLIENT_SUPPORT == ENABLED)
   error_t error;
   size_t n;
   SshHostKey *hostKey;
   const char_t *publicKeyAlgo;

   
   *written = 0;

   
   error = sshFormatString(""publickey"", p, &n);
   
   if(error)
      return error;

   
   p += n;
   *written += n;

   
   p[0] = connection->publicKeyOk ? TRUE : FALSE;

   
   p += sizeof(uint8_t);
   *written += sizeof(uint8_t);

   
   hostKey = sshGetHostKey(connection);
   
   if(hostKey == NULL)
      return ERROR_INVALID_KEY;

   
   publicKeyAlgo = sshSelectPublicKeyAlgo(hostKey->keyFormatId);
   
   if(publicKeyAlgo == NULL)
      return ERROR_INVALID_KEY;

   
   error = sshFormatString(publicKeyAlgo, p, &n);
   
   if(error)
      return error;

   
   p += n;
   *written += n;

   
   error = sshFormatHostKey(connection, p + sizeof(uint32_t), &n);
   
   if(error)
      return error;

   
   STORE32BE(n, p);

   
   p += sizeof(uint32_t) + n;
   *written += sizeof(uint32_t) + n;

   
   
   if(connection->publicKeyOk)
   {
      
      messageLen += *written;

      
      error = sshGenerateSignature(connection, publicKeyAlgo, hostKey,
         message, messageLen, p + sizeof(uint32_t), &n);
      
      if(error)
         return error;

      
      STORE32BE(n, p);

      
      *written += sizeof(uint32_t) + n;
   }

   
   return NO_ERROR;
#else
   
   return ERROR_NOT_IMPLEMENTED;
#endif
}




error_t sshFormatUserAuthPkOk(SshConnection *connection,
   const SshString *publicKeyAlgo, const SshBinaryString *publicKey,
   uint8_t *p, size_t *length)
{
#if (SSH_SERVER_SUPPORT == ENABLED)
   error_t error;
   size_t n;

   
   *length = 0;

   
   p[0] = SSH_MSG_USERAUTH_PK_OK;

   
   p += sizeof(uint8_t);
   *length += sizeof(uint8_t);

   
   error = sshFormatBinaryString(publicKeyAlgo->value, publicKeyAlgo->length,
      p, &n);
   
   if(error)
      return error;

   
   p += n;
   *length += n;

   
   error = sshFormatBinaryString(publicKey->value, publicKey->length, p, &n);
   
   if(error)
      return error;

   
   *length += n;

   
   return NO_ERROR;
#else
   
   return ERROR_NOT_IMPLEMENTED;
#endif
}




error_t sshParsePublicKeyAuthParams(SshConnection *connection,
   const SshString *userName, const uint8_t *message, const uint8_t *p,
   size_t length)
{
#if (SSH_SERVER_SUPPORT == ENABLED)
   error_t error;
   size_t messageLen;
   SshBoolean flag;
   SshString publicKeyAlgo;
   SshBinaryString publicKey;
   SshBinaryString signature;
   SshContext *context;

   
   context = connection->context;

   
   if(length < sizeof(uint8_t))
      return ERROR_INVALID_MESSAGE;

   
   flag = p[0];

   
   p += sizeof(uint8_t);
   length -= sizeof(uint8_t);

   
   error = sshParseString(p, length, &publicKeyAlgo);
   
   if(error)
      return error;

   
   p += sizeof(uint32_t) + publicKeyAlgo.length;
   length -= sizeof(uint32_t) + publicKeyAlgo.length;

   
   error = sshParseBinaryString(p, length, &publicKey);
   
   if(error)
      return error;

   
   p += sizeof(uint32_t) + publicKey.length;
   length -= sizeof(uint32_t) + publicKey.length;

   
   messageLen = p - message;

   
   if(flag)
   {
      
      error = sshParseBinaryString(p, length, &signature);
      
      if(error)
         return error;

      
      p += sizeof(uint32_t) + signature.length;
      length -= sizeof(uint32_t) + signature.length;
   }
   else
   {
      
      signature.value = NULL;
      signature.length = 0;
   }

   
   if(length != 0)
      return ERROR_INVALID_MESSAGE;

   
   
   error = sshCheckHostKey(&publicKeyAlgo, &publicKey);

   
   if(!error)
   {
      
      if(userName->length <= SSH_MAX_USERNAME_LEN &&
         context->publicKeyAuthCallback != NULL)
      {
         
         osMemcpy(connection->user, userName->value, userName->length);
         
         connection->user[userName->length] = '\0';

         
         error = context->publicKeyAuthCallback(connection, connection->user,
            publicKey.value, publicKey.length);
      }
      else
      {
         
         error = ERROR_INVALID_KEY;
      }
   }

   
   if(!error)
   {
      
      if(flag)
      {
         
         
         error = sshVerifySignature(connection, &publicKeyAlgo, &publicKey,
            message, messageLen, &signature);
      }
   }

   
   if(!error)
   {
      
      if(flag)
      {
         
         
         error = sshSendUserAuthSuccess(connection);
      }
      else
      {
         
         if(connection->authAttempts <= SSH_MAX_AUTH_ATTEMPTS)
         {
            
            error = sshSendUserAuthPkOk(connection, &publicKeyAlgo, &publicKey);
         }
         else
         {
            
            
            error = sshSendDisconnect(connection, SSH_DISCONNECT_BY_APPLICATION,
               ""Too many authentication attempts"");
         }
      }
   }
   else
   {
      
      
      error = sshRejectAuthRequest(connection);
   }

   
   return error;
#else
   
   return ERROR_NOT_IMPLEMENTED;
#endif
}




error_t sshParseUserAuthPkOk(SshConnection *connection,
   const uint8_t *message, size_t length)
{
#if (SSH_CLIENT_SUPPORT == ENABLED)
   error_t error;
   const uint8_t *p;
   SshString publicKeyAlgo;
   SshBinaryString publicKey;

   
   TRACE_INFO(""SSH_MSG_USERAUTH_PK_OK message received (%"" PRIuSIZE "" bytes)...\r\n"", length);
   TRACE_VERBOSE_ARRAY(""  "", message, length);

   
   if(connection->context->mode != SSH_OPERATION_MODE_CLIENT)
      return ERROR_UNEXPECTED_MESSAGE;

   
   if(connection->state != SSH_CONN_STATE_USER_AUTH_REPLY)
      return ERROR_UNEXPECTED_MESSAGE;

   
   if(length < sizeof(uint8_t))
      return ERROR_INVALID_MESSAGE;

   
   p = message + sizeof(uint8_t);
   
   length -= sizeof(uint8_t);

   
   error = sshParseString(p, length, &publicKeyAlgo);
   
   if(error)
      return error;

   
   p += sizeof(uint32_t) + publicKeyAlgo.length;
   length -= sizeof(uint32_t) + publicKeyAlgo.length;

   
   error = sshParseBinaryString(p, length, &publicKey);
   
   if(error)
      return error;

   
   p += sizeof(uint32_t) + publicKey.length;
   length -= sizeof(uint32_t) + publicKey.length;

   
   if(length != 0)
      return ERROR_INVALID_MESSAGE;

   
   if(connection->publicKeyOk)
      return ERROR_UNEXPECTED_MESSAGE;

   
   error = sshCheckHostKey(&publicKeyAlgo, &publicKey);
   
   if(error)
      return error;

   
   connection->publicKeyOk = TRUE;

   
   
   connection->state = SSH_CONN_STATE_USER_AUTH_REQUEST;

   
   return NO_ERROR;
#else
   
   return ERROR_UNEXPECTED_MESSAGE;
#endif
}

#endif
",64,1848,2865
"#define TRACE_LEVEL RSTP_TRACE_LEVEL


#include ""rstp/rstp.h""
#include ""rstp/rstp_fsm.h""
#include ""rstp/rstp_misc.h""
#include ""debug.h""


#if (RSTP_SUPPORT == ENABLED)




void rstpFsmInit(RstpBridgeContext *context)
{
   uint_t i;
   RstpBridgePort *port;

   
   
   
   context->bridgePriority.rootBridgeId = context->bridgeId;
   context->bridgePriority.rootPathCost = 0;
   context->bridgePriority.designatedBridgeId = context->bridgeId;
   context->bridgePriority.designatedPortId = 0;
   context->bridgePriority.bridgePortId = 0;

   
   
   context->bridgeTimes.forwardDelay = context->params.bridgeForwardDelay;
   context->bridgeTimes.helloTime = context->params.bridgeHelloTime;
   context->bridgeTimes.maxAge = context->params.bridgeMaxAge;
   context->bridgeTimes.messageAge = 0;

   
   context->rootPriority = context->bridgePriority;
   
   context->rootTimes = context->bridgeTimes;

   
   context->ageingTime = context->params.ageingTime;
   
   context->rapidAgeingWhile = 0;

   
   rstpUpdateAgeingTime(context, context->params.ageingTime);

   
   osMemset(&context->bpdu, 0, sizeof(RstpBpdu));

   
   for(i = 0; i < context->numPorts; i++)
   {
      
      port = &context->ports[i];

      
      
      
      port->designatedTimes = context->rootTimes;
      port->designatedTimes.helloTime = context->bridgeTimes.helloTime;

      
      memset(&port->msgPriority, 0, sizeof(RstpPriority));
      memset(&port->msgTimes, 0, sizeof(RstpTimes));

      
      port->disputed = FALSE;
      port->rcvdInfo = RSTP_RCVD_INFO_OTHER;
      port->rcvdTc = FALSE;
      port->rcvdTcAck = FALSE;
      port->rcvdTcn = FALSE;
      port->tcProp = FALSE;
      port->updtInfo = FALSE;
   }

   
   
   rstpPrsInit(context);

   
   for(i = 0; i < context->numPorts; i++)
   {
      
      port = &context->ports[i];

      
      rstpPtiInit(port);
      
      rstpPrxInit(port);
      
      rstpPpmInit(port);
      
      rstpBdmInit(port);
      
      rstpPtxInit(port);
      
      rstpPimInit(port);
      
      rstpPrtInit(port);
      
      rstpPstInit(port);
      
      rstpTcmInit(port);
   }

   
   rstpFsm(context);
}




void rstpFsm(RstpBridgeContext *context)
{
   uint_t i;
   RstpBridgePort *port;

   
   
   do
   {
      
      context->busy = FALSE;

      
      
      rstpPrsFsm(context);

      
      
      for(i = 0; i < context->numPorts; i++)
      {
         
         port = &context->ports[i];

         
         rstpPtiFsm(port);
         
         rstpPrxFsm(port);
         
         rstpPpmFsm(port);
         
         rstpBdmFsm(port);
         
         rstpPimFsm(port);
         
         rstpPrtFsm(port);
         
         rstpPstFsm(port);
         
         rstpTcmFsm(port);

         
         
         if(port->fdbFlush)
         {
            
            rstpRemoveFdbEntries(port);
         }
      }

      
      if(!context->busy)
      {
         
         for(i = 0; i < context->numPorts; i++)
         {
            
            port = &context->ports[i];

            
            rstpPtxFsm(port);
         }
      }

      
      
   } while(context->busy);
}




void rstpFsmError(RstpBridgeContext *context)
{
   
   TRACE_ERROR(""RSTP finite state machine error!\r\n"");
}

#endif
",64,1849,1231
"#define TRACE_LEVEL SFTP_TRACE_LEVEL


#include ""ssh/ssh.h""
#include ""sftp/sftp_server.h""
#include ""sftp/sftp_server_misc.h""
#include ""path.h""
#include ""debug.h""


#if (SFTP_SERVER_SUPPORT == ENABLED)




void sftpServerGetDefaultSettings(SftpServerSettings *settings)
{
   
   settings->sshServerContext = NULL;

   
   settings->numSessions = 0;
   settings->sessions = NULL;

   
   settings->numFileObjects = 0;
   settings->fileObjects = NULL;

   
   settings->rootDir = NULL;

   
   settings->checkUserCallback = NULL;
   
   settings->getFilePermCallback = NULL;
}




error_t sftpServerInit(SftpServerContext *context,
   const SftpServerSettings *settings)
{
   uint_t i;

   
   TRACE_INFO(""Initializing SFTP server...\r\n"");

   
   if(context == NULL || settings == NULL)
      return ERROR_INVALID_PARAMETER;

   
   if(settings->sessions == NULL || settings->numSessions < 1 ||
      settings->numSessions > SFTP_SERVER_MAX_SESSIONS)
   {
      return ERROR_INVALID_PARAMETER;
   }

   
   if(settings->fileObjects == NULL || settings->numFileObjects < 1)
   {
      return ERROR_INVALID_PARAMETER;
   }

   
   if(settings->rootDir == NULL ||
      osStrlen(settings->rootDir) > SFTP_SERVER_MAX_ROOT_DIR_LEN)
   {
      return ERROR_INVALID_PARAMETER;
   }

   
   osMemset(context, 0, sizeof(SftpServerContext));

   
   context->sshServerContext = settings->sshServerContext;
   context->numSessions = settings->numSessions;
   context->sessions = settings->sessions;
   context->numFileObjects = settings->numFileObjects;
   context->fileObjects = settings->fileObjects;
   context->checkUserCallback = settings->checkUserCallback;
   context->getFilePermCallback = settings->getFilePermCallback;

   
   osStrcpy(context->rootDir, settings->rootDir);

   
   pathCanonicalize(context->rootDir);
   pathRemoveSlash(context->rootDir);

   
   for(i = 0; i < context->numSessions; i++)
   {
      
      osMemset(&context->sessions[i], 0, sizeof(SftpServerSession));
   }

   
   for(i = 0; i < context->numFileObjects; i++)
   {
      
      osMemset(&context->fileObjects[i], 0, sizeof(SftpFileObject));
   }

   
   if(!osCreateEvent(&context->event))
   {
      
      sftpServerDeinit(context);
   }

   
   return NO_ERROR;
}




error_t sftpServerStart(SftpServerContext *context)
{
   error_t error;
   OsTask *task;

   
   if(context == NULL)
      return ERROR_INVALID_PARAMETER;

   
   TRACE_INFO(""Starting SFTP server...\r\n"");

   
   if(context->running)
      return ERROR_ALREADY_RUNNING;

   
   error = sshServerRegisterChannelRequestCallback(context->sshServerContext,
      sftpServerChannelRequestCallback, context);

   
   if(!error)
   {
      
      context->stop = FALSE;
      context->running = TRUE;

      
      task = osCreateTask(""SFTP Server"", sftpServerTask, context,
         SFTP_SERVER_STACK_SIZE, SFTP_SERVER_PRIORITY);
      
      if(task == OS_INVALID_HANDLE)
      {
         error = ERROR_OUT_OF_RESOURCES;
      }
   }

   
   if(error)
   {
      
      context->running = FALSE;

      
      sshServerUnregisterChannelRequestCallback(context->sshServerContext,
         sftpServerChannelRequestCallback);
   }

   
   return error;
}




error_t sftpServerStop(SftpServerContext *context)
{
   uint_t i;

   
   if(context == NULL)
      return ERROR_INVALID_PARAMETER;

   
   TRACE_INFO(""Stopping SFTP server...\r\n"");

   
   if(context->running)
   {
      
      sshServerUnregisterChannelRequestCallback(context->sshServerContext,
         sftpServerChannelRequestCallback);

      
      context->stop = TRUE;
      
      osSetEvent(&context->event);

      
      while(context->running)
      {
         osDelayTask(1);
      }

      
      for(i = 0; i < context->numSessions; i++)
      {
         
         if(context->sessions[i].state != SFTP_SERVER_SESSION_STATE_CLOSED)
         {
            
            sftpServerCloseSession(&context->sessions[i]);
         }
      }
   }

   
   return NO_ERROR;
}




error_t sftpServerSetRootDir(SftpServerSession *session, const char_t *rootDir)
{
   SftpServerContext *context;

   
   if(session == NULL || rootDir == NULL)
      return ERROR_INVALID_PARAMETER;

   
   context = session->context;

   
   pathCopy(session->rootDir, context->rootDir, SFTP_SERVER_MAX_ROOT_DIR_LEN);
   pathCombine(session->rootDir, rootDir, SFTP_SERVER_MAX_ROOT_DIR_LEN);

   
   pathCanonicalize(session->rootDir);
   pathRemoveSlash(session->rootDir);

   
   pathCopy(session->homeDir, session->rootDir, SFTP_SERVER_MAX_HOME_DIR_LEN);

   
   return NO_ERROR;
}




error_t sftpServerSetHomeDir(SftpServerSession *session, const char_t *homeDir)
{
   SftpServerContext *context;

   
   if(session == NULL || homeDir == NULL)
      return ERROR_INVALID_PARAMETER;

   
   context = session->context;

   
   pathCopy(session->homeDir, context->rootDir, SFTP_SERVER_MAX_HOME_DIR_LEN);
   pathCombine(session->homeDir, homeDir, SFTP_SERVER_MAX_HOME_DIR_LEN);

   
   pathCanonicalize(session->homeDir);
   pathRemoveSlash(session->homeDir);

   
   return NO_ERROR;
}




void sftpServerTask(void *param)
{
   error_t error;
   uint_t i;
   systime_t timeout;
   SftpServerContext *context;
   SftpServerSession *session;

   
   context = (SftpServerContext *) param;

#if (NET_RTOS_SUPPORT == ENABLED)
   
   osEnterTask();

   
   while(1)
   {
#endif
      
      timeout = SFTP_SERVER_TICK_INTERVAL;

      
      osMemset(context->eventDesc, 0, sizeof(context->eventDesc));

      
      for(i = 0; i < context->numSessions; i++)
      {
         
         session = &context->sessions[i];

         
         if(session->state != SFTP_SERVER_SESSION_STATE_CLOSED)
         {
            
            sftpServerRegisterSessionEvents(session, &context->eventDesc[i]);

            
            if(context->eventDesc[i].eventFlags != 0)
            {
               
               timeout = 0;
            }
         }
      }

      
      error = sshPollChannels(context->eventDesc, context->numSessions,
         &context->event, timeout);

      
      if(error == NO_ERROR || error == ERROR_TIMEOUT)
      {
         
         if(context->stop)
         {
            
            context->running = FALSE;
            
            osDeleteTask(NULL);
         }

         
         for(i = 0; i < context->numSessions; i++)
         {
            
            session = &context->sessions[i];

            
            if(session->state != SFTP_SERVER_SESSION_STATE_CLOSED)
            {
               
               if(context->eventDesc[i].eventFlags != 0)
               {
                  
                  sftpServerProcessSessionEvents(session);
               }
            }
         }
      }

      
      sftpServerTick(context);

#if (NET_RTOS_SUPPORT == ENABLED)
   }
#endif
}




void sftpServerDeinit(SftpServerContext *context)
{
   
   if(context != NULL)
   {
      
      osDeleteEvent(&context->event);

      
      osMemset(context, 0, sizeof(SftpServerContext));
   }
}

#endif
",64,1850,2347
"#define TRACE_LEVEL STP_TRACE_LEVEL


#include ""stp/stp.h""
#include ""stp/stp_operation.h""
#include ""stp/stp_bpdu.h""
#include ""stp/stp_misc.h""
#include ""debug.h""


#if (STP_SUPPORT == ENABLED)


const MacAddr STP_BRIDGE_GROUP_ADDR = {{{0x01, 0x80, 0xC2, 0x00, 0x00, 0x00}}};


const StpParamName stpProtocolVersions[] =
{
   {STP_PROTOCOL_VERSION, ""STP""}
};


const StpParamName stpBpduTypes[] =
{
   {STP_BPDU_TYPE_CONFIG, ""CONFIG""},
   {STP_BPDU_TYPE_TCN,    ""TCN""}
};




void stpProcessLlcFrame(NetInterface *interface, EthHeader *ethHeader,
   const uint8_t *data, size_t length, NetRxAncillary *ancillary, void *param)
{
   const LlcHeader *llcHeader;
   const StpBpdu *bpdu;
   StpBridgeContext *context;
   StpBridgePort *port;

   
   context = (StpBridgeContext *) param;

   
   
   if(!macCompAddr(&ethHeader->destAddr, &STP_BRIDGE_GROUP_ADDR))
      return;

   
   if(length < sizeof(LlcHeader))
      return;

   
   llcHeader = (LlcHeader *) data;

   
   
   
   if(llcHeader->dsap != STP_LLC_DSAP || llcHeader->ssap != STP_LLC_SSAP ||
      llcHeader->control != STP_LLC_CTRL)
   {
      return;
   }

   
   if(ancillary->port < 1 || ancillary->port > context->numPorts)
      return;

   
   port = &context->ports[ancillary->port - 1];

   
   bpdu = (StpBpdu *) (data + sizeof(LlcHeader));

   
   length -= sizeof(LlcHeader);

   
   stpProcessBpdu(port, bpdu, length);
}




error_t stpProcessBpdu(StpBridgePort *port, const StpBpdu *bpdu,
   size_t length)
{
   
   TRACE_INFO(""Port %"" PRIu8 "": BPDU received (%"" PRIuSIZE "" bytes)...\r\n"",
      port->portIndex, length);

   
   stpDumpBpdu(bpdu, length);

   
   if(length < STP_MIN_BPDU_SIZE)
      return ERROR_INVALID_LENGTH;

   
   if(ntohs(bpdu->protocolId) != STP_PROTOCOL_ID)
      return ERROR_INVALID_LENGTH;

   
   if(bpdu->bpduType == STP_BPDU_TYPE_CONFIG)
   {
      
      if(length < STP_CONFIG_BPDU_SIZE)
         return ERROR_INVALID_LENGTH;

      
      if(ntohs(bpdu->messageAge) >= ntohs(bpdu->maxAge))
         return ERROR_INVALID_PACKET;

      
      stpReceivedConfigBpdu(port, bpdu);
   }
   else if(bpdu->bpduType == STP_BPDU_TYPE_TCN)
   {
      
      stpReceivedTcnBpdu(port, bpdu);
   }
   else
   {
      
      return ERROR_INVALID_TYPE;
   }

   
   return NO_ERROR;
}




error_t stpSendBpdu(StpBridgePort *port, const StpBpdu *bpdu,
   size_t length)
{
   error_t error;
   size_t offset;
   LlcHeader *llcHeader;
   NetBuffer *buffer;
   NetTxAncillary ancillary;
   StpBridgeContext *context;

   
   TRACE_INFO(""Port %"" PRIu8 "": Sending BPDU (%"" PRIuSIZE "" bytes)...\r\n"",
      port->portIndex, length);

   
   stpDumpBpdu(bpdu, length);

   
   context = port->context;

   
   buffer = ethAllocBuffer(sizeof(LlcHeader), &offset);

   
   if(buffer != NULL)
   {
      
      llcHeader = netBufferAt(buffer, offset);

      
      
      
      llcHeader->dsap = STP_LLC_DSAP;
      llcHeader->ssap = STP_LLC_SSAP;
      llcHeader->control = STP_LLC_CTRL;

      
      error = netBufferAppend(buffer, bpdu, length);

      
      if(!error)
      {
         
         length += sizeof(LlcHeader);

         
         ancillary = NET_DEFAULT_TX_ANCILLARY;
         
         ancillary.srcMacAddr = port->macAddr;
         
         ancillary.port = port->portIndex;

         
         
         error = ethSendFrame(context->interface, &STP_BRIDGE_GROUP_ADDR,
            length, buffer, offset, &ancillary);
      }

      
      netBufferFree(buffer);
   }
   else
   {
      
      error = ERROR_OUT_OF_MEMORY;
   }

   
   return error;
}




error_t stpDumpBpdu(const StpBpdu *bpdu, size_t length)
{
#if (STP_TRACE_LEVEL >= TRACE_LEVEL_DEBUG)
   uint32_t t;

   
   if(length < STP_MIN_BPDU_SIZE)
      return ERROR_INVALID_LENGTH;

   
   TRACE_DEBUG(""  Protocol Identifier = %"" PRIu16 ""\r\n"",
      ntohs(bpdu->protocolId));

   
   TRACE_DEBUG(""  Protocol Version Identifier = %"" PRIu8 "" (%s)\r\n"",
      bpdu->protocolVersionId, stpGetParamName(bpdu->protocolVersionId,
      stpProtocolVersions, arraysize(stpProtocolVersions)));

   
   TRACE_DEBUG(""  BPDU Type = 0x%02"" PRIX8 "" (%s)\r\n"", bpdu->bpduType,
      stpGetParamName(bpdu->bpduType, stpBpduTypes, arraysize(stpBpduTypes)));

   
   if(length >= STP_CONFIG_BPDU_SIZE)
   {
      
      stpDumpFlags(bpdu->flags);

      
      TRACE_DEBUG(""  Root Identifier = %"" PRIu16 "" / %s\r\n"",
         ntohs(bpdu->rootId.priority), macAddrToString(&bpdu->rootId.addr, NULL));

      
      TRACE_DEBUG(""  Root Path Cost = %"" PRIu32 ""\r\n"", ntohl(bpdu->rootPathCost));

      
      TRACE_DEBUG(""  Bridge Identifier = %"" PRIu16 "" / %s\r\n"",
         ntohs(bpdu->bridgeId.priority), macAddrToString(&bpdu->bridgeId.addr, NULL));

      
      TRACE_DEBUG(""  Port Identifier = 0x%04"" PRIX16 ""\r\n"", ntohs(bpdu->portId));

      
      t = ntohs(bpdu->messageAge) * 1000 / 256;
      TRACE_DEBUG(""  Message Age = %"" PRIu32 "".%03"" PRIu32 ""\r\n"", t / 1000, t % 1000);

      
      t = ntohs(bpdu->maxAge) * 1000 / 256;
      TRACE_DEBUG(""  Max Age = %"" PRIu32 "".%03"" PRIu32 ""\r\n"", t / 1000, t % 1000);

      
      t = ntohs(bpdu->helloTime) * 1000 / 256;
      TRACE_DEBUG(""  Hello Time = %"" PRIu32 "".%03"" PRIu32 ""\r\n"", t / 1000, t % 1000);

      
      t = ntohs(bpdu->forwardDelay) * 1000 / 256;
      TRACE_DEBUG(""  Forward Delay = %"" PRIu32 "".%03"" PRIu32 ""\r\n"", t / 1000, t % 1000);
   }
#endif

   
   return NO_ERROR;
}




void stpDumpFlags(uint8_t flags)
{
   
   TRACE_DEBUG(""  Flags = 0x%02"" PRIX8, flags);

   
   if(flags != 0)
   {
      
      TRACE_DEBUG("" ("");

      
      while(flags != 0)
      {
         if((flags & STP_BPDU_FLAG_TC_ACK) != 0)
         {
            
            TRACE_DEBUG(""TcAck"");
            
            flags &= ~STP_BPDU_FLAG_TC_ACK;
         }
         else if((flags & STP_BPDU_FLAG_TC) != 0)
         {
            
            TRACE_DEBUG(""Tc"");
            
            flags &= ~STP_BPDU_FLAG_TC;
         }

         
         if(flags != 0)
         {
            TRACE_DEBUG("", "");
         }
      }

      
      TRACE_DEBUG("")"");
   }

   
   TRACE_DEBUG(""\r\n"");
}

#endif
",64,1851,2606
"#define TRACE_LEVEL TLS_TRACE_LEVEL



#include ""tls.h""
#include ""tls_record.h""
#include ""tls_record_encryption.h""
#include ""tls_misc.h""
#include ""ssl_misc.h""
#include ""cipher_mode/cbc.h""
#include ""aead/ccm.h""
#include ""aead/gcm.h""
#include ""aead/chacha20_poly1305.h""
#include ""debug.h""


#if (TLS_SUPPORT == ENABLED)




error_t tlsEncryptRecord(TlsContext *context,
   TlsEncryptionEngine *encryptionEngine, void *record)
{
   error_t error;

#if (TLS_CCM_CIPHER_SUPPORT == ENABLED || TLS_CCM_8_CIPHER_SUPPORT == ENABLED || \
   TLS_GCM_CIPHER_SUPPORT == ENABLED || TLS_CHACHA20_POLY1305_SUPPORT == ENABLED)
   
   if(encryptionEngine->cipherMode == CIPHER_MODE_CCM ||
      encryptionEngine->cipherMode == CIPHER_MODE_GCM ||
      encryptionEngine->cipherMode == CIPHER_MODE_CHACHA20_POLY1305)
   {
      
      error = tlsEncryptAeadRecord(context, encryptionEngine, record);
   }
   else
#endif
#if (TLS_CBC_CIPHER_SUPPORT == ENABLED)
   
   if(encryptionEngine->cipherMode == CIPHER_MODE_CBC)
   {
      
      error = tlsAppendMessageAuthCode(context, encryptionEngine, record);

      
      if(!error)
      {
         
         error = tlsEncryptCbcRecord(context, encryptionEngine, record);
      }
   }
   else
#endif
#if (TLS_STREAM_CIPHER_SUPPORT == ENABLED)
   
   if(encryptionEngine->cipherMode == CIPHER_MODE_STREAM)
   {
      
      error = tlsAppendMessageAuthCode(context, encryptionEngine, record);

      
      if(!error)
      {
         
         error = tlsEncryptStreamRecord(context, encryptionEngine, record);
      }
   }
   else
#endif
#if (TLS_NULL_CIPHER_SUPPORT == ENABLED)
   
   if(encryptionEngine->cipherMode == CIPHER_MODE_NULL)
   {
      
      error = tlsAppendMessageAuthCode(context, encryptionEngine, record);
   }
   else
#endif
   
   {
      
      error = ERROR_UNSUPPORTED_CIPHER_MODE;
   }

   
   return error;
}




error_t tlsEncryptAeadRecord(TlsContext *context,
   TlsEncryptionEngine *encryptionEngine, void *record)
{
#if (TLS_CCM_CIPHER_SUPPORT == ENABLED || TLS_CCM_8_CIPHER_SUPPORT == ENABLED || \
   TLS_GCM_CIPHER_SUPPORT == ENABLED || TLS_CHACHA20_POLY1305_SUPPORT == ENABLED)
   error_t error;
   size_t length;
   size_t aadLen;
   size_t nonceLen;
   uint8_t *tag;
   uint8_t *data;
   uint8_t aad[13];
   uint8_t nonce[12];

   
   length = tlsGetRecordLength(context, record);
   
   data = tlsGetRecordData(context, record);

   
   TRACE_DEBUG(""Record to be encrypted (%"" PRIuSIZE "" bytes):\r\n"", length);
   TRACE_DEBUG_ARRAY(""  "", record, length + sizeof(TlsRecord));

   
   if(encryptionEngine->version == TLS_VERSION_1_3)
   {
      
      
      data[length++] = tlsGetRecordType(context, record);

      
      
      tlsSetRecordType(context, record, TLS_TYPE_APPLICATION_DATA);

      
      tlsSetRecordLength(context, record, length +
         encryptionEngine->authTagLen);
   }

   
   tlsFormatAad(context, encryptionEngine, record, aad, &aadLen);

   
   if(encryptionEngine->recordIvLen != 0)
   {
      
      osMemmove(data + encryptionEngine->recordIvLen, data, length);

      
      
      error = context->prngAlgo->read(context->prngContext, data,
         encryptionEngine->recordIvLen);
      
      if(error)
         return error;
   }

   
   tlsFormatNonce(context, encryptionEngine, record, data, nonce,
      &nonceLen);

   
   data += encryptionEngine->recordIvLen;
   
   tag = data + length;

#if (TLS_CCM_CIPHER_SUPPORT == ENABLED || TLS_CCM_8_CIPHER_SUPPORT == ENABLED)
   
   if(encryptionEngine->cipherMode == CIPHER_MODE_CCM)
   {
      
      error = ccmEncrypt(encryptionEngine->cipherAlgo,
         encryptionEngine->cipherContext, nonce, nonceLen, aad, aadLen,
         data, data, length, tag, encryptionEngine->authTagLen);
   }
   else
#endif
#if (TLS_GCM_CIPHER_SUPPORT == ENABLED)
   
   if(encryptionEngine->cipherMode == CIPHER_MODE_GCM)
   {
      
      error = gcmEncrypt(encryptionEngine->gcmContext, nonce, nonceLen,
         aad, aadLen, data, data, length, tag, encryptionEngine->authTagLen);
   }
   else
#endif
#if (TLS_CHACHA20_POLY1305_SUPPORT == ENABLED)
   
   if(encryptionEngine->cipherMode == CIPHER_MODE_CHACHA20_POLY1305)
   {
      
      error = chacha20Poly1305Encrypt(encryptionEngine->encKey,
         encryptionEngine->encKeyLen, nonce, nonceLen, aad, aadLen,
         data, data, length, tag, encryptionEngine->authTagLen);
   }
   else
#endif
   
   {
      
      error = ERROR_UNSUPPORTED_CIPHER_MODE;
   }

   
   if(error)
      return error;

   
   length += encryptionEngine->recordIvLen + encryptionEngine->authTagLen;
   
   tlsSetRecordLength(context, record, length);

   
   tlsIncSequenceNumber(&encryptionEngine->seqNum);

   
   TRACE_DEBUG(""Encrypted record (%"" PRIuSIZE "" bytes):\r\n"", length);
   TRACE_DEBUG_ARRAY(""  "", record, length + sizeof(TlsRecord));

   
   return NO_ERROR;
#else
   
   return ERROR_UNSUPPORTED_CIPHER_MODE;
#endif
}




error_t tlsEncryptCbcRecord(TlsContext *context,
   TlsEncryptionEngine *encryptionEngine, void *record)
{
#if (TLS_CBC_CIPHER_SUPPORT == ENABLED)
   error_t error;
   size_t i;
   size_t length;
   size_t paddingLen;
   uint8_t *data;
   const CipherAlgo *cipherAlgo;

   
   cipherAlgo = encryptionEngine->cipherAlgo;

   
   length = tlsGetRecordLength(context, record);
   
   data = tlsGetRecordData(context, record);

   
   TRACE_DEBUG(""Record to be encrypted (%"" PRIuSIZE "" bytes):\r\n"", length);
   TRACE_DEBUG_ARRAY(""  "", record, length + sizeof(TlsRecord));

#if (TLS_MAX_VERSION >= TLS_VERSION_1_1 && TLS_MIN_VERSION <= TLS_VERSION_1_2)
   
   if(encryptionEngine->version >= TLS_VERSION_1_1)
   {
      
      osMemmove(data + encryptionEngine->recordIvLen, data, length);

      
      error = context->prngAlgo->read(context->prngContext, data,
         encryptionEngine->recordIvLen);
      
      if(error)
         return error;

      
      length += encryptionEngine->recordIvLen;
   }
#endif

   
   paddingLen = (length + 1) % cipherAlgo->blockSize;

   
   
   if(paddingLen > 0)
      paddingLen = cipherAlgo->blockSize - paddingLen;

   
   for(i = 0; i <= paddingLen; i++)
   {
      data[length + i] = (uint8_t) paddingLen;
   }

   
   length += paddingLen + 1;
   
   tlsSetRecordLength(context, record, length);

   
   TRACE_DEBUG(""Record with padding (%"" PRIuSIZE "" bytes):\r\n"", length);
   TRACE_DEBUG_ARRAY(""  "", record, length + sizeof(TlsRecord));

   
   error = cbcEncrypt(cipherAlgo, encryptionEngine->cipherContext,
      encryptionEngine->iv, data, data, length);
   
   if(error)
      return error;

   
   TRACE_DEBUG(""Encrypted record (%"" PRIuSIZE "" bytes):\r\n"", length);
   TRACE_DEBUG_ARRAY(""  "", record, length + sizeof(TlsRecord));

   
   return NO_ERROR;
#else
   
   return ERROR_UNSUPPORTED_CIPHER_MODE;
#endif
}




error_t tlsEncryptStreamRecord(TlsContext *context,
   TlsEncryptionEngine *encryptionEngine, void *record)
{
#if (TLS_STREAM_CIPHER_SUPPORT == ENABLED)
   size_t length;
   uint8_t *data;

   
   length = tlsGetRecordLength(context, record);
   
   data = tlsGetRecordData(context, record);

   
   TRACE_DEBUG(""Record to be encrypted (%"" PRIuSIZE "" bytes):\r\n"", length);
   TRACE_DEBUG_ARRAY(""  "", record, length + sizeof(TlsRecord));

   
   encryptionEngine->cipherAlgo->encryptStream(
      encryptionEngine->cipherContext, data, data, length);

   
   TRACE_DEBUG(""Encrypted record (%"" PRIuSIZE "" bytes):\r\n"", length);
   TRACE_DEBUG_ARRAY(""  "", record, length + sizeof(TlsRecord));

   
   return NO_ERROR;
#else
   
   return ERROR_UNSUPPORTED_CIPHER_MODE;
#endif
}




error_t tlsAppendMessageAuthCode(TlsContext *context,
   TlsEncryptionEngine *encryptionEngine, void *record)
{
   error_t error;
   size_t length;
   uint8_t *data;

   
   length = tlsGetRecordLength(context, record);
   
   data = tlsGetRecordData(context, record);

#if (TLS_MAX_VERSION >= SSL_VERSION_3_0 && TLS_MIN_VERSION <= SSL_VERSION_3_0)
   
   if(encryptionEngine->version == SSL_VERSION_3_0)
   {
      
      error = sslComputeMac(encryptionEngine, record, data, length,
         data + length);
   }
   else
#endif
#if (TLS_MAX_VERSION >= TLS_VERSION_1_0 && TLS_MIN_VERSION <= TLS_VERSION_1_2)
   
   if(encryptionEngine->version >= TLS_VERSION_1_0 &&
      encryptionEngine->version <= TLS_VERSION_1_2)
   {
      
      error = tlsComputeMac(context, encryptionEngine, record, data,
         length, data + length);
   }
   else
#endif
#if (TLS_MAX_VERSION >= TLS_VERSION_1_3 && TLS_MIN_VERSION <= TLS_VERSION_1_3)
   
   if(encryptionEngine->version == TLS_VERSION_1_3)
   {
      
      
      data[length++] = tlsGetRecordType(context, record);

      
      
      tlsSetRecordType(context, record, TLS_TYPE_APPLICATION_DATA);

      
      tlsSetRecordLength(context, record, length +
         encryptionEngine->hashAlgo->digestSize);

      
      error = tls13ComputeMac(context, encryptionEngine, record, data,
         length, data + length);
   }
   else
#endif
   
   {
      
      error = ERROR_INVALID_VERSION;
   }

   
   if(error)
      return error;

   
   TRACE_DEBUG(""Write sequence number:\r\n"");
   TRACE_DEBUG_ARRAY(""  "", &encryptionEngine->seqNum, sizeof(TlsSequenceNumber));
   TRACE_DEBUG(""Computed MAC:\r\n"");
   TRACE_DEBUG_ARRAY(""  "", data + length, encryptionEngine->hashAlgo->digestSize);

   
   length += encryptionEngine->hashAlgo->digestSize;
   
   tlsSetRecordLength(context, record, length);

   
   tlsIncSequenceNumber(&encryptionEngine->seqNum);

   
   return NO_ERROR;
}




error_t tlsComputeMac(TlsContext *context, TlsEncryptionEngine *encryptionEngine,
   void *record, const uint8_t *data, size_t dataLen, uint8_t *mac)
{
   HmacContext *hmacContext;

   
   hmacContext = encryptionEngine->hmacContext;

   
   hmacInit(hmacContext, encryptionEngine->hashAlgo,
      encryptionEngine->macKey, encryptionEngine->macKeyLen);

#if (DTLS_SUPPORT == ENABLED)
   
   if(context->transportProtocol == TLS_TRANSPORT_PROTOCOL_DATAGRAM)
   {
      const DtlsRecord *dtlsRecord;

      
      dtlsRecord = (DtlsRecord *) record;

      
      
      hmacUpdate(hmacContext, (void *) &dtlsRecord->epoch, 2);
      hmacUpdate(hmacContext, &dtlsRecord->seqNum, 6);

      
      hmacUpdate(hmacContext, &dtlsRecord->type, 3);
      hmacUpdate(hmacContext, (void *) &dtlsRecord->length, 2);
      hmacUpdate(hmacContext, data, dataLen);
   }
   else
#endif
   
   {
      const TlsRecord *tlsRecord;

      
      tlsRecord = (TlsRecord *) record;

      
      hmacUpdate(hmacContext, &encryptionEngine->seqNum,
         sizeof(TlsSequenceNumber));

      
      hmacUpdate(hmacContext, tlsRecord, sizeof(TlsRecord));
      hmacUpdate(hmacContext, data, dataLen);
   }

   
   hmacFinal(hmacContext, mac);

   
   return NO_ERROR;
}

#endif
",64,1852,3939
"#include ""path.h""




bool_t pathIsAbsolute(const char_t *path)
{
   
   if(path[0] == '/' || path[0] == '\\')
      return TRUE;
   else
      return FALSE;
}




bool_t pathIsRelative(const char_t *path)
{
   
   if(path[0] == '/' || path[0] == '\\')
      return FALSE;
   else
      return TRUE;
}




const char_t *pathGetFilename(const char_t *path)
{
   size_t n;

   
   n = osStrlen(path);

   
   while(n > 0)
   {
      
      if(path[n - 1] != '/' && path[n - 1] != '\\')
         break;

      
      n--;
   }

   
   while(n > 0)
   {
      
      if(path[n - 1] == '/' || path[n - 1] == '\\')
         break;

      
      n--;
   }

   
   return path + n;
}




void pathRemoveFilename(char_t *path)
{
   char_t *p;

   
   p = (char_t *) pathGetFilename(path);
   *p = '\0';
}




void pathCopy(char_t *dest, const char_t *src, size_t maxLen)
{
   size_t n;

   
   n = osStrlen(src);
   
   n = MIN(n, maxLen);

   
   osStrncpy(dest, src, n);
   
   dest[n] = '\0';
}




void pathCanonicalize(char_t *path)
{
   size_t i;
   size_t j;
   size_t k;

   
   i = 0;
   k = 0;

   
   while(path[i] != '\0')
   {
      
      if(path[i] == '/' || path[i] == '\\')
      {
         path[k++] = '/';
         while(path[i] == '/' || path[i] == '\\') i++;
      }
      else
      {
         path[k++] = path[i++];
      }
   }

   
   path[k] = '\0';

   
   i = 0;
   j = 0;
   k = 0;

   
   do
   {
      
      if(path[i] == '/' || path[i] == '\0')
      {
         
         if((i - j) == 1 && !osStrncmp(path + j, ""."", 1))
         {
            
            if(k == 0)
            {
               if(path[i] == '\0')
               {
                  path[k++] = '.';
               }
               else if(path[i] == '/' && path[i + 1] == '\0')
               {
                  path[k++] = '.';
                  path[k++] = '/';
               }
            }
            else if(k > 1)
            {
               
               if(path[i] == '\0')
                  k--;
            }
         }
         
         else if((i - j) == 2 && !osStrncmp(path + j, "".."", 2))
         {
            
            if(k == 0)
            {
               path[k++] = '.';
               path[k++] = '.';

               
               if(path[i] == '/')
                  path[k++] = '/';
            }
            else if(k > 1)
            {
               
               for(j = 1; j < k; j++)
               {
                  if(path[k - j - 1] == '/')
                     break;
               }

               
               if(j < k)
               {
                  if(!osStrncmp(path + k - j, "".."", 2))
                  {
                     path[k++] = '.';
                     path[k++] = '.';
                  }
                  else
                  {
                     k = k - j - 1;
                  }

                  
                  if(k == 0 && path[0] == '/')
                     path[k++] = '/';
                  else if(path[i] == '/')
                     path[k++] = '/';
               }
               
               else
               {
                  if(k == 3 && !osStrncmp(path, "".."", 2))
                  {
                     path[k++] = '.';
                     path[k++] = '.';

                     
                     if(path[i] == '/')
                        path[k++] = '/';
                  }
                  else if(path[i] == '\0')
                  {
                     k = 0;
                     path[k++] = '.';
                  }
                  else if(path[i] == '/' && path[i + 1] == '\0')
                  {
                     k = 0;
                     path[k++] = '.';
                     path[k++] = '/';
                  }
                  else
                  {
                     k = 0;
                  }
               }
            }
         }
         else
         {
            
            osMemmove(path + k, path + j, i - j);
            
            k += i - j;

            
            if(path[i] == '/')
               path[k++] = '/';
         }

         
         while(path[i] == '/') i++;
         j = i;
      }
   } while(path[i++] != '\0');

   
   path[k] = '\0';
}




void pathAddSlash(char_t *path, size_t maxLen)
{
   size_t n;

   
   n = osStrlen(path);

   
   if(!n)
   {
      
      if(maxLen >= 1)
         osStrcpy(path, ""/"");
   }
   else if(path[n - 1] != '/' && path[n - 1] != '\\')
   {
      
      if(maxLen >= (n + 1))
         osStrcat(path, ""/"");
   }
}




void pathRemoveSlash(char_t *path)
{
   char_t *end;

   
   if(pathIsAbsolute(path))
      path++;

   
   for(end = NULL; *path != '\0'; path++)
   {
      if(*path != '/' && *path != '\\')
         end = NULL;
      else if(!end)
         end = path;
   }

   
   if(end)
      *end = '\0';
}




void pathCombine(char_t *path, const char_t *more, size_t maxLen)
{
   size_t n1;
   size_t n2;

   
   if(*path != '\0')
      pathAddSlash(path, maxLen);

   
   while(*more == '/' || *more == '\\') more++;

   
   n1 = osStrlen(path);
   
   n2 = osStrlen(more);

   
   if(n1 < maxLen)
   {
      
      n2 = MIN(n2, maxLen - n1);
      
      osStrncpy(path + n1, more, n2);
      
      path[n1 + n2] = '\0';
   }
}




bool_t pathMatch(const char_t *path, const char_t *pattern)
{
   size_t i = 0;
   size_t j = 0;

   
   while(pattern[j] != '\0')
   {
      
      if(pattern[j] == '?')
      {
         
         if(path[i] == '\0')
         {
            return FALSE;
         }
         else
         {
            
            i++;
            
            j++;
         }
      }
      else if(pattern[j] == '*')
      {
         
         if(path[i] == '\0')
         {
            
            j++;
         }
         else if(pathMatch(path + i, pattern + j + 1))
         {
            return TRUE;
         }
         else
         {
            
            i++;
         }
      }
      else
      {
         
         if(osTolower(path[i]) != osTolower(pattern[j]))
         {
            return FALSE;
         }
         else
         {
            
            i++;
            
            j++;
         }
      }
   }

   
   if(path[i] == '\0' && pattern[j] == '\0')
      return TRUE;
   else
      return FALSE;
}
",64,1853,2277
"#define TRACE_LEVEL SNMP_TRACE_LEVEL


#include ""core/net.h""
#include ""mibs/mib_common.h""
#include ""mibs/rstp_mib_module.h""
#include ""mibs/rstp_mib_impl.h""
#include ""core/crypto.h""
#include ""encoding/asn1.h""
#include ""encoding/oid.h""
#include ""debug.h""


#if (RSTP_MIB_SUPPORT == ENABLED)




RstpMibBase rstpMibBase;




const MibObject rstpMibObjects[] =
{
   
   {
      ""dot1dStpVersion"",
      {43, 6, 1, 2, 1, 17, 2, 16},
      8,
      ASN1_CLASS_UNIVERSAL,
      ASN1_TYPE_INTEGER,
      MIB_ACCESS_READ_WRITE,
      NULL,
      NULL,
      sizeof(int32_t),
      rstpMibSetDot1dStpVersion,
      rstpMibGetDot1dStpVersion,
      NULL
   },
   
   {
      ""dot1dStpTxHoldCount"",
      {43, 6, 1, 2, 1, 17, 2, 17},
      8,
      ASN1_CLASS_UNIVERSAL,
      ASN1_TYPE_INTEGER,
      MIB_ACCESS_READ_WRITE,
      NULL,
      NULL,
      sizeof(int32_t),
      rstpMibSetDot1dStpTxHoldCount,
      rstpMibGetDot1dStpTxHoldCount,
      NULL
   },
   
   {
      ""dot1dStpPortProtocolMigration"",
      {43, 6, 1, 2, 1, 17, 2, 19, 1, 1},
      10,
      ASN1_CLASS_UNIVERSAL,
      ASN1_TYPE_INTEGER,
      MIB_ACCESS_READ_WRITE,
      NULL,
      NULL,
      sizeof(int32_t),
      rstpMibSetDot1dStpExtPortEntry,
      rstpMibGetDot1dStpExtPortEntry,
      rstpMibGetNextDot1dStpExtPortEntry
   },
   
   {
      ""dot1dStpPortAdminEdgePort"",
      {43, 6, 1, 2, 1, 17, 2, 19, 1, 2},
      10,
      ASN1_CLASS_UNIVERSAL,
      ASN1_TYPE_INTEGER,
      MIB_ACCESS_READ_WRITE,
      NULL,
      NULL,
      sizeof(int32_t),
      rstpMibSetDot1dStpExtPortEntry,
      rstpMibGetDot1dStpExtPortEntry,
      rstpMibGetNextDot1dStpExtPortEntry
   },
   
   {
      ""dot1dStpPortOperEdgePort"",
      {43, 6, 1, 2, 1, 17, 2, 19, 1, 3},
      10,
      ASN1_CLASS_UNIVERSAL,
      ASN1_TYPE_INTEGER,
      MIB_ACCESS_READ_ONLY,
      NULL,
      NULL,
      sizeof(int32_t),
      NULL,
      rstpMibGetDot1dStpExtPortEntry,
      rstpMibGetNextDot1dStpExtPortEntry
   },
   
   {
      ""dot1dStpPortAdminPointToPoint"",
      {43, 6, 1, 2, 1, 17, 2, 19, 1, 4},
      10,
      ASN1_CLASS_UNIVERSAL,
      ASN1_TYPE_INTEGER,
      MIB_ACCESS_READ_WRITE,
      NULL,
      NULL,
      sizeof(int32_t),
      rstpMibSetDot1dStpExtPortEntry,
      rstpMibGetDot1dStpExtPortEntry,
      rstpMibGetNextDot1dStpExtPortEntry
   },
   
   {
      ""dot1dStpPortOperPointToPoint"",
      {43, 6, 1, 2, 1, 17, 2, 19, 1, 5},
      10,
      ASN1_CLASS_UNIVERSAL,
      ASN1_TYPE_INTEGER,
      MIB_ACCESS_READ_ONLY,
      NULL,
      NULL,
      sizeof(int32_t),
      NULL,
      rstpMibGetDot1dStpExtPortEntry,
      rstpMibGetNextDot1dStpExtPortEntry
   },
   
   {
      ""dot1dStpPortAdminPathCost"",
      {43, 6, 1, 2, 1, 17, 2, 19, 1, 6},
      10,
      ASN1_CLASS_UNIVERSAL,
      ASN1_TYPE_INTEGER,
      MIB_ACCESS_READ_WRITE,
      NULL,
      NULL,
      sizeof(int32_t),
      rstpMibSetDot1dStpExtPortEntry,
      rstpMibGetDot1dStpExtPortEntry,
      rstpMibGetNextDot1dStpExtPortEntry
   }
};




const MibModule rstpMibModule =
{
   ""RSTP-MIB"",
   {43, 6, 1, 2, 1, 129, 6},
   7,
   rstpMibObjects,
   arraysize(rstpMibObjects),
   rstpMibInit,
   NULL,
   NULL,
   NULL,
   NULL
};

#endif
",64,1854,1596
"#define TRACE_LEVEL TLS_TRACE_LEVEL


#include ""tls.h""
#include ""tls_handshake.h""
#include ""tls_server.h""
#include ""tls_server_fsm.h""
#include ""tls_common.h""
#include ""tls_cache.h""
#include ""tls_record.h""
#include ""tls_misc.h""
#include ""tls13_server.h""
#include ""tls13_common.h""
#include ""tls13_key_material.h""
#include ""debug.h""


#if (TLS_SUPPORT == ENABLED && TLS_SERVER_SUPPORT == ENABLED)




error_t tlsPerformServerHandshake(TlsContext *context)
{
   error_t error;

   
   error = NO_ERROR;

   
   while(!error)
   {
      
      if(context->transportProtocol == TLS_TRANSPORT_PROTOCOL_STREAM)
      {
         
         if(context->state != TLS_STATE_INIT &&
            context->state != TLS_STATE_CLOSED)
         {
            
            error = tlsWriteProtocolData(context, NULL, 0, TLS_TYPE_NONE);
            
            if(error)
               break;
         }
      }

      
      if(context->state == TLS_STATE_APPLICATION_DATA)
      {
         
         
         break;
      }

      
      
      switch(context->state)
      {
      
      case TLS_STATE_INIT:
         
         error = tlsInitHandshake(context);
         break;

      
      case TLS_STATE_SERVER_HELLO:
      case TLS_STATE_SERVER_HELLO_2:
         
         
         error = tlsSendServerHello(context);
         break;

      
      case TLS_STATE_SERVER_CERTIFICATE:
         
         
         
         error = tlsSendCertificate(context);
         break;

      
      case TLS_STATE_CERTIFICATE_REQUEST:
         
         
         
         error = tlsSendCertificateRequest(context);
         break;

      
      case TLS_STATE_SERVER_CHANGE_CIPHER_SPEC:
      case TLS_STATE_SERVER_CHANGE_CIPHER_SPEC_2:
         
         
         
         error = tlsSendChangeCipherSpec(context);
         break;

      
      case TLS_STATE_SERVER_FINISHED:
         
         
         
         error = tlsSendFinished(context);
         break;

#if (DTLS_SUPPORT == ENABLED)
      
      case TLS_STATE_HELLO_VERIFY_REQUEST:
         
         
         error = dtlsSendHelloVerifyRequest(context);
         break;
#endif

#if (TLS_MAX_VERSION >= SSL_VERSION_3_0 && TLS_MIN_VERSION <= TLS_VERSION_1_2)
      
      case TLS_STATE_SERVER_KEY_EXCHANGE:
         
         
         
         error = tlsSendServerKeyExchange(context);
         break;

      
      case TLS_STATE_SERVER_HELLO_DONE:
         
         
         error = tlsSendServerHelloDone(context);
         break;
#endif

#if (TLS_MAX_VERSION >= TLS_VERSION_1_3 && TLS_MIN_VERSION <= TLS_VERSION_1_3)
      
      case TLS_STATE_HELLO_RETRY_REQUEST:
         
         
         
         error = tls13SendHelloRetryRequest(context);
         break;

      
      case TLS_STATE_HANDSHAKE_TRAFFIC_KEYS:
         
         error = tls13GenerateHandshakeTrafficKeys(context);
         break;

      
      case TLS_STATE_ENCRYPTED_EXTENSIONS:
         
         
         
         error = tls13SendEncryptedExtensions(context);
         break;

      
      case TLS_STATE_SERVER_CERTIFICATE_VERIFY:
         
         
         
         error = tlsSendCertificateVerify(context);
         break;

      
      case TLS_STATE_SERVER_APP_TRAFFIC_KEYS:
         
         error = tls13GenerateServerAppTrafficKeys(context);
         break;

      
      case TLS_STATE_CLIENT_APP_TRAFFIC_KEYS:
         
         error = tls13GenerateClientAppTrafficKeys(context);
         break;

      
      case TLS_STATE_NEW_SESSION_TICKET:
         
         
         error = tls13SendNewSessionTicket(context);
         break;

      
      case TLS_STATE_KEY_UPDATE:
         
         
         error = tls13SendKeyUpdate(context);
         break;
#endif

      
      case TLS_STATE_CLIENT_HELLO:
      case TLS_STATE_CLIENT_HELLO_2:
      case TLS_STATE_CLIENT_CERTIFICATE:
      case TLS_STATE_CLIENT_KEY_EXCHANGE:
      case TLS_STATE_CLIENT_CERTIFICATE_VERIFY:
      case TLS_STATE_CLIENT_CHANGE_CIPHER_SPEC:
      case TLS_STATE_CLIENT_FINISHED:
         
         error = tlsReceiveHandshakeMessage(context);
         break;

      
      case TLS_STATE_CLOSING:
         
         context->state = TLS_STATE_CLOSED;
         break;

      
      case TLS_STATE_CLOSED:
         
         TRACE_WARNING(""TLS handshake failure!\r\n"");
         
         error = ERROR_HANDSHAKE_FAILED;
         break;

      
      default:
         
         error = ERROR_UNEXPECTED_STATE;
         break;
      }
   }

   
   if(!error)
   {
#if (TLS_MAX_VERSION >= SSL_VERSION_3_0 && TLS_MIN_VERSION <= TLS_VERSION_1_2)
      
      if(context->version <= TLS_VERSION_1_2)
      {
         
         tlsSaveToCache(context);
      }
#endif
   }
   else
   {
      
      tlsProcessError(context, error);
   }

   
   return error;
}




error_t tlsParseClientHandshakeMessage(TlsContext *context, uint8_t msgType,
   const void *message, size_t length)
{
   error_t error;

   
   switch(msgType)
   {
   
   case TLS_TYPE_CLIENT_HELLO:
      
      
      error = tlsParseClientHello(context, message, length);
      break;

   
   case TLS_TYPE_CERTIFICATE:
      
      
      
      error = tlsParseCertificate(context, message, length);
      break;

   
   case TLS_TYPE_CERTIFICATE_VERIFY:
      
      
      
      
      error = tlsParseCertificateVerify(context, message, length);
      break;

   
   case TLS_TYPE_FINISHED:
      
      
      
      error = tlsParseFinished(context, message, length);
      break;

#if (TLS_MAX_VERSION >= SSL_VERSION_3_0 && TLS_MIN_VERSION <= TLS_VERSION_1_2)
   
   case TLS_TYPE_CLIENT_KEY_EXCHANGE:
      
      
      
      error = tlsParseClientKeyExchange(context, message, length);
      break;
#endif

#if (TLS_MAX_VERSION >= TLS_VERSION_1_3 && TLS_MIN_VERSION <= TLS_VERSION_1_3)
   
   case TLS_TYPE_KEY_UPDATE:
      
      
      
      error = tls13ParseKeyUpdate(context, message, length);
      break;
#endif

   
   default:
      
      error = ERROR_UNEXPECTED_MESSAGE;
      break;
   }

   
   return error;
}

#endif
",64,1855,2076
"#define TRACE_LEVEL ACME_TRACE_LEVEL


#include ""acme/acme_client.h""
#include ""acme/acme_client_auth.h""
#include ""acme/acme_client_challenge.h""
#include ""acme/acme_client_jose.h""
#include ""acme/acme_client_misc.h""
#include ""jansson.h""
#include ""debug.h""


#if (ACME_CLIENT_SUPPORT == ENABLED)




error_t acmeClientSendAuthorizationRequest(AcmeClientContext *context,
   AcmeAuthorization *authorization)
{
   error_t error;

   
   error = NO_ERROR;

   
   while(!error)
   {
      
      if(context->requestState == ACME_REQ_STATE_INIT)
      {
         
         TRACE_DEBUG(""\r\n"");
         TRACE_DEBUG(""###############################################################################\r\n"");
         TRACE_DEBUG(""## GET AUTHORIZATION ##########################################################\r\n"");
         TRACE_DEBUG(""###############################################################################\r\n"");
         TRACE_DEBUG(""\r\n"");

         
         context->requestState = ACME_REQ_STATE_FORMAT_BODY;
      }
      else if(context->requestState == ACME_REQ_STATE_FORMAT_BODY)
      {
         
         error = acmeFormatAuthorizationRequest(context, authorization);

         
         if(!error)
         {
            
            context->requestState = ACME_REQ_STATE_FORMAT_HEADER;
         }
      }
      else if(context->requestState == ACME_REQ_STATE_FORMAT_HEADER)
      {
         
         
         
         
         error = acmeClientFormatRequestHeader(context, ""POST"",
            authorization->url);

         
         if(!error)
         {
            
            context->requestState = ACME_REQ_STATE_SEND_HEADER;
         }
      }
      else if(context->requestState == ACME_REQ_STATE_SEND_HEADER ||
         context->requestState == ACME_REQ_STATE_SEND_BODY ||
         context->requestState == ACME_REQ_STATE_RECEIVE_HEADER ||
         context->requestState == ACME_REQ_STATE_PARSE_HEADER ||
         context->requestState == ACME_REQ_STATE_RECEIVE_BODY ||
         context->requestState == ACME_REQ_STATE_CLOSE_BODY)
      {
         
         error = acmeClientSendRequest(context);
      }
      else if(context->requestState == ACME_REQ_STATE_PARSE_BODY)
      {
         
         error = acmeClientParseAuthorizationResponse(context, authorization);

         
         context->requestState = ACME_REQ_STATE_INIT;
         break;
      }
      else
      {
         
         error = ERROR_WRONG_STATE;
      }
   }

   
   return error;
}




error_t acmeFormatAuthorizationRequest(AcmeClientContext *context,
   const AcmeAuthorization *authorization)
{
   error_t error;
   size_t n;
   char_t *protected;
   const char_t *payload;

   
   payload = """";

   
   protected = context->buffer;

   
   error = acmeClientFormatJwsProtectedHeader(&context->accountKey,
      context->account.url, context->nonce, authorization->url, protected, &n);

   
   if(!error)
   {
      
      error = jwsCreate(context->prngAlgo, context->prngContext, protected,
         payload, context->accountKey.alg, context->accountKey.crv,
         context->accountKey.privateKey, context->buffer, &context->bufferLen);
   }

   
   return error;
}




error_t acmeClientParseAuthorizationResponse(AcmeClientContext *context,
   AcmeAuthorization *authorization)
{
   error_t error;
   uint_t i;
   uint_t n;
   const char_t *status;
   const char_t *value;
   const char_t *type;
   const char_t *url;
   const char_t *token;
   json_t *rootObj;
   json_t *statusObj;
   json_t *identifierObj;
   json_t *valueObj;
   json_t *wildcardObj;
   json_t *arrayObj;
   json_t *challengeObj;
   json_t *typeObj;
   json_t *urlObj;
   json_t *tokenObj;
   AcmeChallenge *challenge;
   AcmeChallengeType challengeType;

   
   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))
      return ERROR_UNEXPECTED_STATUS;

   
   
   if(context->nonce[0] == '\0')
      return ERROR_INVALID_RESPONSE;

   
   if(osStrcasecmp(context->contentType, ""application/json""))
      return ERROR_INVALID_RESPONSE;

   
   if(context->bufferLen >= ACME_CLIENT_BUFFER_SIZE)
      return ERROR_RESPONSE_TOO_LARGE;

   
   error = ERROR_INVALID_RESPONSE;

   
   rootObj = json_loads(context->buffer, 0, NULL);

   
   do
   {
      
      if(!json_is_object(rootObj))
         break;

      
      statusObj = json_object_get(rootObj, ""status"");

      
      if(!json_is_string(statusObj))
         break;

      
      status = json_string_value(statusObj);
      
      authorization->status = acmeClientParseAuthorizationStatus(status);

      
      identifierObj = json_object_get(rootObj, ""identifier"");

      
      if(!json_is_object(identifierObj))
         break;

      
      valueObj = json_object_get(identifierObj, ""value"");

      
      if(!json_is_string(valueObj))
         break;

      
      value = json_string_value(valueObj);

      
      if(osStrlen(value) > ACME_CLIENT_MAX_URL_LEN)
         break;

      
      wildcardObj = json_object_get(rootObj, ""wildcard"");

      
      if(json_is_boolean(wildcardObj))
      {
         
         authorization->wildcard = json_boolean_value(wildcardObj);
      }

      
      challengeType = acmeClientGetChallengeType(context, value,
         authorization->wildcard);

      
      if(authorization->status == ACME_AUTH_STATUS_PENDING)
      {
         
         arrayObj = json_object_get(rootObj, ""challenges"");

         
         if(!json_is_array(arrayObj))
            break;

         
         n = json_array_size(arrayObj);

         
         for(i = 0; i < n; i++)
         {
            
            challengeObj = json_array_get(arrayObj, i);

            
            if(!json_is_object(challengeObj))
               break;

            
            typeObj = json_object_get(challengeObj, ""type"");
            urlObj = json_object_get(challengeObj, ""url"");
            statusObj = json_object_get(challengeObj, ""status"");

            
            if(!json_is_string(typeObj) ||
               !json_is_string(urlObj) ||
               !json_is_string(statusObj))
            {
               break;
            }

            
            type = json_string_value(typeObj);
            url = json_string_value(urlObj);
            status = json_string_value(statusObj);

            
            if(acmeClientParseChallengeType(type) == challengeType)
            {
               
               tokenObj = json_object_get(challengeObj, ""token"");

               
               if(!json_is_string(tokenObj))
                  break;

               
               token = json_string_value(tokenObj);

               
               if(osStrlen(url) <= ACME_CLIENT_MAX_URL_LEN &&
                  osStrlen(token) <= ACME_CLIENT_MAX_URL_LEN &&
                  osStrlen(value) <= ACME_CLIENT_MAX_NAME_LEN)
               {
                  
                  challenge = &context->challenges[context->numChallenges];

                  
                  challenge->status = acmeClientParseChallengeStatus(status);
                  
                  osStrcpy(challenge->url, url);
                  
                  osStrcpy(challenge->token, token);

                  
                  osStrcpy(challenge->identifier, value);
                  challenge->wildcard = authorization->wildcard;

                  
                  challenge->type = challengeType;

                  
                  
                  error = acmeClientGenerateKeyAuthorization(context, challenge);

                  
                  if(!error)
                  {
                     
                     if(challenge->type == ACME_CHALLENGE_TYPE_DNS_01)
                     {
                        
                        
                        error = acmeClientDigestKeyAuthorization(context,
                           challenge);
                     }
                     else if(challenge->type == ACME_CHALLENGE_TYPE_TLS_ALPN_01)
                     {
                        
                        
                        error = acmeClientGenerateTlsAlpnCert(context, challenge);
                     }
                     else
                     {
                        
                     }
                  }

                  
                  if(!error)
                  {
                     
                     context->numChallenges++;
                  }

                  
                  break;
               }
            }
         }
      }
      else
      {
         
         
         error = NO_ERROR;
      }

      
   } while(0);

   
   json_decref(rootObj);

   
   return error;
}




AcmeAuthStatus acmeClientParseAuthorizationStatus(const char_t *label)
{
   AcmeAuthStatus status;

   
   if(!osStrcmp(label, ""pending""))
   {
      
      status = ACME_AUTH_STATUS_PENDING;
   }
   else if(!osStrcmp(label, ""valid""))
   {
      
      
      status = ACME_AUTH_STATUS_VALID;
   }
   else if(!osStrcmp(label, ""invalid""))
   {
      
      
      
      status = ACME_AUTH_STATUS_INVALID;
   }
   else if(!osStrcmp(label, ""expired""))
   {
      
      status = ACME_AUTH_STATUS_EXPIRED;
   }
   else if(!osStrcmp(label, ""deactivated""))
   {
      
      status = ACME_AUTH_STATUS_DEACTIVATED;
   }
   else if(!osStrcmp(label, ""revoked""))
   {
      
      status = ACME_AUTH_STATUS_REVOKED;
   }
   else
   {
      
      status = ACME_AUTH_STATUS_INVALID;
   }

   
   return status;
}

#endif
",64,1856,2907
"#define TRACE_LEVEL SSH_TRACE_LEVEL


#include ""ssh/ssh.h""
#include ""ssh/ssh_transport.h""
#include ""ssh/ssh_auth.h""
#include ""ssh/ssh_auth_password.h""
#include ""ssh/ssh_misc.h""
#include ""debug.h""


#if (SSH_SUPPORT == ENABLED && SSH_PASSWORD_AUTH_SUPPORT == ENABLED)




error_t sshFormatPasswordAuthParams(SshConnection *connection, uint8_t *p,
   size_t *written)
{
#if (SSH_CLIENT_SUPPORT == ENABLED)
   error_t error;
   size_t n;

   
   *written = 0;

   
   error = sshFormatString(""password"", p, &n);
   
   if(error)
      return error;

   
   p += n;
   *written += n;

   
   p[0] = FALSE;

   
   p += sizeof(uint8_t);
   *written += sizeof(uint8_t);

   
   error = sshFormatString(connection->context->password, p, &n);
   
   if(error)
      return error;

   
   *written += n;

   
   return NO_ERROR;
#else
   
   return ERROR_NOT_IMPLEMENTED;
#endif
}




error_t sshParsePasswordAuthParams(SshConnection *connection,
   const SshString *userName, const uint8_t *p, size_t length)
{
#if (SSH_SERVER_SUPPORT == ENABLED)
   error_t error;
   SshBoolean flag;
   SshString oldPassword;
   SshString newPassword;
   SshAccessStatus status;
   SshContext *context;

   
   context = connection->context;

   
   if(length < sizeof(uint8_t))
      return ERROR_INVALID_MESSAGE;

   
   flag = p[0];

   
   p += sizeof(uint8_t);
   length -= sizeof(uint8_t);

   
   error = sshParseString(p, length, &oldPassword);
   
   if(error)
      return error;

   
   p += sizeof(uint32_t) + oldPassword.length;
   length -= sizeof(uint32_t) + oldPassword.length;

   
   if(flag)
   {
      
      error = sshParseString(p, length, &newPassword);
      
      if(error)
         return error;

      
      p += sizeof(uint32_t) + newPassword.length;
      length -= sizeof(uint32_t) + newPassword.length;
   }
   else
   {
      
      newPassword.value = NULL;
      newPassword.length = 0;
   }

   
   if(length != 0)
      return ERROR_INVALID_MESSAGE;

   
   if(userName->length <= SSH_MAX_USERNAME_LEN)
   {
      
      osMemcpy(connection->user, userName->value, userName->length);
      
      connection->user[userName->length] = '\0';

      
      if(context->passwordAuthCallback != NULL)
      {
         
         status = context->passwordAuthCallback(connection, connection->user,
            oldPassword.value, oldPassword.length);
      }
      else
      {
         
         status = SSH_ACCESS_DENIED;
      }
   }
   else
   {
      
      status = SSH_ACCESS_DENIED;
   }

   
   if(status == SSH_ACCESS_ALLOWED)
   {
      
      
      error = sshSendUserAuthSuccess(connection);
   }
   else
   {
      
      
      error = sshRejectAuthRequest(connection);
   }

   
   return error;
#else
   
   return ERROR_NOT_IMPLEMENTED;
#endif
}




error_t sshParseUserAuthPasswdChangeReq(SshConnection *connection,
   const uint8_t *message, size_t length)
{
#if (SSH_CLIENT_SUPPORT == ENABLED)
   error_t error;
   const uint8_t *p;
   SshString prompt;
   SshString languageTag;

   
   TRACE_INFO(""SSH_USERAUTH_PASSWD_CHANGEREQ message received (%"" PRIuSIZE "" bytes)...\r\n"", length);
   TRACE_VERBOSE_ARRAY(""  "", message, length);

   
   if(connection->context->mode != SSH_OPERATION_MODE_CLIENT)
      return ERROR_UNEXPECTED_MESSAGE;

   
   if(connection->state != SSH_CONN_STATE_USER_AUTH_REPLY)
      return ERROR_UNEXPECTED_MESSAGE;

   
   if(length < sizeof(uint8_t))
      return ERROR_INVALID_MESSAGE;

   
   p = message + sizeof(uint8_t);
   
   length -= sizeof(uint8_t);

   
   error = sshParseString(p, length, &prompt);
   
   if(error)
      return error;

   
   p += sizeof(uint32_t) + prompt.length;
   length -= sizeof(uint32_t) + prompt.length;

   
   error = sshParseString(p, length, &languageTag);
   
   if(error)
      return error;

   
   p += sizeof(uint32_t) + languageTag.length;
   length -= sizeof(uint32_t) + languageTag.length;

   
   if(length != 0)
      return ERROR_INVALID_MESSAGE;

   
   
   return ERROR_AUTHENTICATION_FAILED;
#else
   
   return ERROR_UNEXPECTED_MESSAGE;
#endif
}

#endif
",64,1857,1523
"#define TRACE_LEVEL RSTP_TRACE_LEVEL


#include ""rstp/rstp.h""
#include ""rstp/rstp_fsm.h""
#include ""rstp/rstp_bdm.h""
#include ""rstp/rstp_conditions.h""
#include ""rstp/rstp_misc.h""
#include ""debug.h""


#if (RSTP_SUPPORT == ENABLED)


const RstpParamName rstpBdmStates[] =
{
   {RSTP_BDM_STATE_EDGE,     ""EDGE""},
   {RSTP_BDM_STATE_NOT_EDGE, ""NOT_EDGE""}
};




void rstpBdmInit(RstpBridgePort *port)
{
   
   if(rstpAdminEdge(port))
   {
      rstpBdmChangeState(port, RSTP_BDM_STATE_EDGE);
   }
   else
   {
      rstpBdmChangeState(port, RSTP_BDM_STATE_NOT_EDGE);
   }
}




void rstpBdmFsm(RstpBridgePort *port)
{
   
   
   switch(port->bdmState)
   {
   
   case RSTP_BDM_STATE_EDGE:
      
      if((!port->portEnabled && !rstpAdminEdge(port)) || !port->operEdge)
      {
         
         rstpBdmChangeState(port, RSTP_BDM_STATE_NOT_EDGE);
      }

      break;

   
   case RSTP_BDM_STATE_NOT_EDGE:
      
      if((!port->portEnabled && rstpAdminEdge(port)) ||
         (port->edgeDelayWhile == 0 && rstpAutoEdge(port) &&
         port->sendRstp && port->proposing))
      {
         
         rstpBdmChangeState(port, RSTP_BDM_STATE_EDGE);
      }

      break;

   
   default:
      
      rstpFsmError(port->context);
      break;
   }
}




void rstpBdmChangeState(RstpBridgePort *port, RstpBdmState newState)
{
   
   TRACE_VERBOSE(""Port %"" PRIu8 "": BDM state machine %s -> %s\r\n"",
      port->portIndex,
      rstpGetParamName(port->bdmState, rstpBdmStates, arraysize(rstpBdmStates)),
      rstpGetParamName(newState, rstpBdmStates, arraysize(rstpBdmStates)));

   
   port->bdmState = newState;

   
   
   switch(port->bdmState)
   {
   
   case RSTP_BDM_STATE_EDGE:
      
      port->operEdge = TRUE;
      break;

   
   case RSTP_BDM_STATE_NOT_EDGE:
      
      port->operEdge = FALSE;
      break;

   
   default:
      
      break;
   }

   
   port->context->busy = TRUE;
}

#endif
",64,1858,845
"#define TRACE_LEVEL SCP_TRACE_LEVEL


#include ""ssh/ssh.h""
#include ""ssh/ssh_connection.h""
#include ""ssh/ssh_request.h""
#include ""ssh/ssh_misc.h""
#include ""scp/scp_client.h""
#include ""scp/scp_client_misc.h""
#include ""debug.h""


#if (SCP_CLIENT_SUPPORT == ENABLED)




void scpClientChangeState(ScpClientContext *context,
   ScpClientState newState)
{
   
   context->state = newState;

   
   context->timestamp = osGetSystemTime();
}




error_t scpClientOpenConnection(ScpClientContext *context)
{
   error_t error;
   Socket *socket;
   SshConnection *connection;

   
   error = sshInit(&context->sshContext, &context->sshConnection, 1,
      &context->sshChannel, 1);
   
   if(error)
      return error;

   
   error = sshSetOperationMode(&context->sshContext, SSH_OPERATION_MODE_CLIENT);
   
   if(error)
      return error;

   
   if(context->sshInitCallback != NULL)
   {
      
      error = context->sshInitCallback(context, &context->sshContext);
      
      if(error)
         return error;
   }

   
   socket = socketOpen(SOCKET_TYPE_STREAM, SOCKET_IP_PROTO_TCP);

   
   if(socket != NULL)
   {
      
      socketBindToInterface(socket, context->interface);
      
      socketSetTimeout(socket, context->timeout);

      
      connection = sshOpenConnection(&context->sshContext, socket);

      
      if(connection == NULL)
      {
         
         socketClose(socket);
         
         error = ERROR_OPEN_FAILED;
      }
   }
   else
   {
      
      error = ERROR_OPEN_FAILED;
   }

   
   return error;
}




error_t scpClientEstablishConnection(ScpClientContext *context)
{
   error_t error;

   
   if(context->sshConnection.state < SSH_CONN_STATE_OPEN)
   {
      
      error = scpClientProcessEvents(context);
   }
   else if(context->sshConnection.state == SSH_CONN_STATE_OPEN)
   {
      
      scpClientChangeState(context, SCP_CLIENT_STATE_CONNECTED);
      
      error = NO_ERROR;
   }
   else
   {
      
      error = ERROR_WRONG_STATE;
   }

   
   return error;
}




void scpClientCloseConnection(ScpClientContext *context)
{
   
   if(context->sshConnection.state != SSH_CONN_STATE_CLOSED)
   {
      
      sshCloseConnection(&context->sshConnection);
   }

   
   sshDeinit(&context->sshContext);
}




error_t scpClientSendDirective(ScpClientContext *context,
   const ScpDirective *directive)
{
   error_t error;
   size_t n;

   
   error = NO_ERROR;

   
   while(!error)
   {
      
      if(context->bufferLen == 0)
      {
         
         n = scpFormatDirective(directive, context->buffer);

         
         context->bufferLen = n;
         context->bufferPos = 0;
      }
      else if(context->bufferPos < context->bufferLen)
      {
         
         error = sshWriteChannel(&context->sshChannel,
            context->buffer + context->bufferPos,
            context->bufferLen - context->bufferPos, &n, 0);

         
         if(error == NO_ERROR || error == ERROR_TIMEOUT)
         {
            
            context->bufferPos += n;
         }
      }
      else
      {
         
         context->bufferLen = 0;
         context->bufferPos = 0;

         
         break;
      }

      
      if(error == ERROR_WOULD_BLOCK || error == ERROR_TIMEOUT)
      {
         
         error = scpClientProcessEvents(context);
      }
   }

   
   return error;
}




error_t scpClientReceiveDirective(ScpClientContext *context,
   ScpDirective *directive)
{
   error_t error;
   size_t n;
   uint8_t opcode;

   
   error = NO_ERROR;

   
   while(!error)
   {
      
      if(context->bufferLen == 0)
      {
         
         error = sshReadChannel(&context->sshChannel, context->buffer, 1,
            &n, 0);

         
         if(!error)
         {
            
            context->bufferLen += n;
         }
      }
      else if(context->bufferLen < SCP_CLIENT_BUFFER_SIZE)
      {
         
         opcode = context->buffer[0];

         
         if(opcode == SCP_OPCODE_OK ||
            opcode == SCP_OPCODE_END)
         {
            
            error = scpParseDirective(context->buffer, directive);

            
            context->bufferLen = 0;
            context->bufferPos = 0;

            
            break;
         }
         else if(opcode == SCP_OPCODE_WARNING ||
            opcode == SCP_OPCODE_ERROR ||
            opcode == SCP_OPCODE_FILE ||
            opcode == SCP_OPCODE_DIR ||
            opcode == SCP_OPCODE_TIME)
         {
            
            n = SCP_CLIENT_BUFFER_SIZE - context->bufferLen;

            
            error = sshReadChannel(&context->sshChannel, context->buffer +
               context->bufferLen, n, &n, SSH_FLAG_BREAK_CRLF);

            
            if(!error)
            {
               
               context->bufferLen += n;

               
               if(context->bufferLen > 0 &&
                  context->buffer[context->bufferLen - 1] == '\n')
               {
                  
                  context->buffer[context->bufferLen - 1] = '\0';

                  
                  error = scpParseDirective(context->buffer, directive);

                  
                  context->bufferLen = 0;
                  context->bufferPos = 0;

                  
                  break;
               }
               else
               {
                  
                  error = ERROR_WOULD_BLOCK;
               }
            }
         }
         else
         {
            
            error = ERROR_INVALID_COMMAND;
         }
      }
      else
      {
         
         error = ERROR_BUFFER_OVERFLOW;
      }

      
      if(error == ERROR_WOULD_BLOCK || error == ERROR_TIMEOUT)
      {
         
         error = scpClientProcessEvents(context);
      }
   }

   
   return error;
}




error_t scpClientProcessEvents(ScpClientContext *context)
{
   error_t error;
   uint_t i;
   SshContext *sshContext;
   SshConnection *connection;

   
   sshContext = &context->sshContext;

   
   osMemset(sshContext->eventDesc, 0, sizeof(sshContext->eventDesc));

   
   for(i = 0; i < sshContext->numConnections; i++)
   {
      
      connection = &sshContext->connections[i];

      
      if(connection->state != SSH_CONN_STATE_CLOSED)
      {
         
         sshRegisterConnectionEvents(sshContext, connection, &sshContext->eventDesc[i]);
      }
   }

   
   error = socketPoll(sshContext->eventDesc, sshContext->numConnections,
      &sshContext->event, context->timeout);

   
   if(!error)
   {
      
      for(i = 0; i < sshContext->numConnections && !error; i++)
      {
         
         connection = &sshContext->connections[i];

         
         if(connection->state != SSH_CONN_STATE_CLOSED)
         {
            
            if(sshContext->eventDesc[i].eventFlags != 0)
            {
               
               error = sshProcessConnectionEvents(sshContext, connection);
            }
         }
      }
   }

   
   if(error == ERROR_WOULD_BLOCK || error == ERROR_TIMEOUT)
   {
      
      error = scpClientCheckTimeout(context);
   }

   
   return error;
}




error_t scpClientCheckTimeout(ScpClientContext *context)
{
   error_t error;
   systime_t time;

   
   time = osGetSystemTime();

   
   if(timeCompare(time, context->timestamp + context->timeout) >= 0)
   {
      
      error = ERROR_TIMEOUT;
   }
   else
   {
#if (NET_RTOS_SUPPORT == ENABLED)
      
      error = NO_ERROR;
#else
      
      error = ERROR_WOULD_BLOCK;
#endif
   }

   
   return error;
}

#endif
",64,1859,2399
"#include ""date_time.h""

#if defined(_WIN32)
   
#endif


static const char days[8][10] =
{
   """",
   ""Monday"",
   ""Tuesday"",
   ""Wednesday"",
   ""Thursday"",
   ""Friday"",
   ""Saturday"",
   ""Sunday""
};


static const char months[13][10] =
{
   """",
   ""January"",
   ""February"",
   ""March"",
   ""April"",
   ""May"",
   ""June"",
   ""July"",
   ""August"",
   ""September"",
   ""October"",
   ""November"",
   ""December""
};




const char_t *formatSystemTime(systime_t time, char_t *str)
{
   uint16_t hours;
   uint8_t minutes;
   uint8_t seconds;
   uint16_t milliseconds;
   static char_t buffer[24];

   
   milliseconds = time % 1000;
   time /= 1000;
   
   seconds = time % 60;
   time /= 60;
   
   minutes = time % 60;
   time /= 60;
   
   hours = time;

   
   if(!str)
      str = buffer;

   
   if(hours > 0)
   {
      osSprintf(str, ""%"" PRIu16 ""h %02"" PRIu8 ""min %02"" PRIu8 ""s %03"" PRIu16 ""ms"",
         hours, minutes, seconds, milliseconds);
   }
   else if(minutes > 0)
   {
      osSprintf(str, ""%"" PRIu8 ""min %02"" PRIu8 ""s %03"" PRIu16 ""ms"",
         minutes, seconds, milliseconds);
   }
   else if(seconds > 0)
   {
      osSprintf(str, ""%"" PRIu8 ""s %03"" PRIu16 ""ms"", seconds, milliseconds);
   }
   else
   {
      osSprintf(str, ""%"" PRIu16 ""ms"", milliseconds);
   }

   
   return str;
}




const char_t *formatDate(const DateTime *date, char_t *str)
{
   static char_t buffer[40];

   
   if(!str)
      str = buffer;

   
   if(date->dayOfWeek)
   {
      osSprintf(str, ""%s, %s %"" PRIu8 "", %"" PRIu16 "" %02"" PRIu8 "":%02"" PRIu8 "":%02"" PRIu8,
         days[MIN(date->dayOfWeek, 7)], months[MIN(date->month, 12)], date->day,
         date->year, date->hours, date->minutes, date->seconds);
   }
   else
   {
      osSprintf(str, ""%s %"" PRIu8 "", %"" PRIu16 "" %02"" PRIu8 "":%02"" PRIu8 "":%02"" PRIu8,
         months[MIN(date->month, 12)], date->day, date->year,
         date->hours, date->minutes, date->seconds);
   }

   
   return str;
}




void getCurrentDate(DateTime *date)
{
   
   time_t time = getCurrentUnixTime();

   
   convertUnixTimeToDate(time, date);
}




__weak time_t getCurrentUnixTime(void)
{
#if defined(_WIN32)
   
   return time(NULL);
#else
   
   return 0;
#endif
}




void convertUnixTimeToDate(time_t t, DateTime *date)
{
   uint32_t a;
   uint32_t b;
   uint32_t c;
   uint32_t d;
   uint32_t e;
   uint32_t f;

   
   if(t < 1)
      t = 0;

   
   date->milliseconds = 0;

   
   date->seconds = t % 60;
   t /= 60;
   date->minutes = t % 60;
   t /= 60;
   date->hours = t % 24;
   t /= 24;

   
   a = (uint32_t) ((4 * t + 102032) / 146097 + 15);
   b = (uint32_t) (t + 2442113 + a - (a / 4));
   c = (20 * b - 2442) / 7305;
   d = b - 365 * c - (c / 4);
   e = d * 1000 / 30601;
   f = d - e * 30 - e * 601 / 1000;

   
   if(e <= 13)
   {
      c -= 4716;
      e -= 1;
   }
   else
   {
      c -= 4715;
      e -= 13;
   }

   
   date->year = c;
   date->month = e;
   date->day = f;

   
   date->dayOfWeek = computeDayOfWeek(c, e, f);
}




time_t convertDateToUnixTime(const DateTime *date)
{
   uint_t y;
   uint_t m;
   uint_t d;
   uint32_t t;

   
   y = date->year;
   
   m = date->month;
   
   d = date->day;

   
   if(m <= 2)
   {
      m += 12;
      y -= 1;
   }

   
   t = (365 * y) + (y / 4) - (y / 100) + (y / 400);
   
   t += (30 * m) + (3 * (m + 1) / 5) + d;
   
   t -= 719561;
   
   t *= 86400;
   
   t += (3600 * date->hours) + (60 * date->minutes) + date->seconds;

   
   return t;
}




int_t compareDateTime(const DateTime *date1, const DateTime *date2)
{
   int_t res;

   
   if(date1->year < date2->year)
      res = -1;
   else if(date1->year > date2->year)
      res = 1;
   else if(date1->month < date2->month)
      res = -1;
   else if(date1->month > date2->month)
      res = 1;
   else if(date1->day < date2->day)
      res = -1;
   else if(date1->day > date2->day)
      res = 1;
   else if(date1->hours < date2->hours)
      res = -1;
   else if(date1->hours > date2->hours)
      res = 1;
   else if(date1->minutes < date2->minutes)
      res = -1;
   else if(date1->minutes > date2->minutes)
      res = 1;
   else if(date1->seconds < date2->seconds)
      res = -1;
   else if(date1->seconds > date2->seconds)
      res = 1;
   else if(date1->milliseconds < date2->milliseconds)
      res = -1;
   else if(date1->milliseconds > date2->milliseconds)
      res = 1;
   else
      res = 0;

   
   return res;
}




uint8_t computeDayOfWeek(uint16_t y, uint8_t m, uint8_t d)
{
   uint_t h;
   uint_t j;
   uint_t k;

   
   if(m <= 2)
   {
      m += 12;
      y -= 1;
   }

   
   j = y / 100;
   
   k = y % 100;

   
   h = d + (26 * (m + 1) / 10) + k + (k / 4) + (5 * j) + (j / 4);

   
   return ((h + 5) % 7) + 1;
}
",64,1860,2241
"#define TRACE_LEVEL RSTP_TRACE_LEVEL


#include ""rstp/rstp.h""
#include ""rstp/rstp_fsm.h""
#include ""rstp/rstp_prx.h""
#include ""rstp/rstp_procedures.h""
#include ""rstp/rstp_conditions.h""
#include ""rstp/rstp_misc.h""
#include ""debug.h""


#if (RSTP_SUPPORT == ENABLED)


const RstpParamName rstpPrxStates[] =
{
   {RSTP_PRX_STATE_DISCARD, ""DISCARD""},
   {RSTP_PRX_STATE_RECEIVE, ""RECEIVE""}
};




void rstpPrxInit(RstpBridgePort *port)
{
   
   rstpPrxChangeState(port, RSTP_PRX_STATE_DISCARD);
}




void rstpPrxFsm(RstpBridgePort *port)
{
   
   if((port->rcvdBpdu || port->edgeDelayWhile != rstpMigrateTime(port->context)) &&
      !port->portEnabled)
   {
      
      
      rstpPrxChangeState(port, RSTP_PRX_STATE_DISCARD);
   }
   else
   {
      
      
      switch(port->prxState)
      {
      
      case RSTP_PRX_STATE_DISCARD:
         
         if(port->rcvdBpdu && port->portEnabled)
         {
            
            rstpPrxChangeState(port, RSTP_PRX_STATE_RECEIVE);
         }

         break;

      
      case RSTP_PRX_STATE_RECEIVE:
         
         if(port->rcvdBpdu && port->portEnabled && !port->rcvdMsg)
         {
            
            rstpPrxChangeState(port, RSTP_PRX_STATE_RECEIVE);
         }

         break;

      
      default:
         
         rstpFsmError(port->context);
         break;
      }
   }
}




void rstpPrxChangeState(RstpBridgePort *port, RstpPrxState newState)
{
   
   TRACE_VERBOSE(""Port %"" PRIu8 "": PRX state machine %s -> %s\r\n"",
      port->portIndex,
      rstpGetParamName(port->prxState, rstpPrxStates, arraysize(rstpPrxStates)),
      rstpGetParamName(newState, rstpPrxStates, arraysize(rstpPrxStates)));

   
   port->prxState = newState;

   
   
   switch(port->prxState)
   {
   
   case RSTP_PRX_STATE_DISCARD:
      
      port->rcvdBpdu = FALSE;
      port->rcvdRstp = FALSE;
      port->rcvdStp = FALSE;
      port->rcvdMsg = FALSE;

      
      port->edgeDelayWhile = rstpMigrateTime(port->context);
      break;

   
   case RSTP_PRX_STATE_RECEIVE:
      
      
      rstpUpdtBpduVersion(port);
      port->operEdge = FALSE;
      port->rcvdBpdu = FALSE;

      
      
      port->rcvdMsg = TRUE;

      
      port->edgeDelayWhile = rstpMigrateTime(port->context);
      break;

   
   default:
      
      break;
   }

   
   port->context->busy = TRUE;
}

#endif
",64,1861,982
"#define TRACE_LEVEL SCP_TRACE_LEVEL


#include ""ssh/ssh.h""
#include ""ssh/ssh_misc.h""
#include ""scp/scp_common.h""
#include ""debug.h""




size_t scpFormatDirective(const ScpDirective *directive, char_t *buffer)
{
   size_t n;

   
   n = 0;

   
   buffer[n++] = directive->opcode;

   
   if(directive->opcode == SCP_OPCODE_OK)
   {
      
      TRACE_DEBUG(""Sending SCP success directive...\r\n"");
   }
   else if(directive->opcode == SCP_OPCODE_WARNING ||
      directive->opcode == SCP_OPCODE_ERROR)
   {
      
      n += osSprintf(buffer + n, ""%s\n"", directive->message);

      
      TRACE_DEBUG(""Sending SCP error directive...\r\n"");
   }
   else if(directive->opcode == SCP_OPCODE_FILE ||
      directive->opcode == SCP_OPCODE_DIR)
   {
      
      
      n += osSprintf(buffer + n, ""%04"" PRIo32 "" %"" PRIu64 "" %s\n"",
         directive->mode, directive->size, directive->filename);

      
      TRACE_DEBUG(""Sending SCP '%c' directive...\r\n"", directive->opcode);
   }
   else if(directive->opcode == SCP_OPCODE_END)
   {
      
      buffer[n++] = '\n';

      
      TRACE_DEBUG(""Sending SCP '%c' directive...\r\n"", directive->opcode);
   }
   else if(directive->opcode == SCP_OPCODE_TIME)
   {
      
      
      n += osSprintf(buffer + n, ""%"" PRIu32 "" 0 %"" PRIu32 "" 0\n"",
         directive->mtime, directive->atime);

      
      TRACE_DEBUG(""Sending SCP '%c' directive...\r\n"", directive->opcode);
   }
   else
   {
      
   }

   
   return n;
}




error_t scpParseDirective(const char_t *buffer, ScpDirective *directive)
{
   error_t error;
   char_t *p;

   
   error = NO_ERROR;

   
   osMemset(directive, 0, sizeof(ScpDirective));

   
   directive->opcode = (ScpOpcode) buffer[0];

   
   if(directive->opcode == SCP_OPCODE_OK)
   {
      
      TRACE_DEBUG(""SCP success directive received...\r\n"");
   }
   else if(directive->opcode == SCP_OPCODE_WARNING ||
      directive->opcode == SCP_OPCODE_ERROR)
   {
      
      TRACE_DEBUG(""SCP error directive received...\r\n"");

      
      directive->message = (char_t *) buffer + 1;
   }
   else if(directive->opcode == SCP_OPCODE_FILE ||
      directive->opcode == SCP_OPCODE_DIR)
   {
      
      TRACE_DEBUG(""SCP '%c' directive received...\r\n"", directive->opcode);

      
      do
      {
         
         directive->mode = osStrtoul(buffer + 1, &p, 8);

         
         if(!osIsblank(*p))
         {
            error = ERROR_INVALID_SYNTAX;
            break;
         }

         
         while(osIsblank(*p))
         {
            p++;
         }

         
         directive->size = osStrtoull(p, &p, 10);

         
         if(!osIsblank(*p))
         {
            error = ERROR_INVALID_SYNTAX;
            break;
         }

         
         while(osIsblank(*p))
         {
            p++;
         }

         
         directive->filename = p;

         
      } while(0);
   }
   else if(directive->opcode == SCP_OPCODE_END)
   {
      
      TRACE_DEBUG(""SCP '%c' directive received...\r\n"", directive->opcode);
   }
   else if(directive->opcode == SCP_OPCODE_TIME)
   {
      
      TRACE_DEBUG(""SCP '%c' directive received...\r\n"", directive->opcode);

      
      do
      {
         
         directive->mtime = osStrtoul(buffer + 1, &p, 10);

         
         if(!osIsblank(*p))
         {
            error = ERROR_INVALID_SYNTAX;
            break;
         }

         
         osStrtoul(p, &p, 10);

         
         if(!osIsblank(*p))
         {
            error = ERROR_INVALID_SYNTAX;
            break;
         }

         
         directive->atime = osStrtoul(p, &p, 10);

         
         if(!osIsblank(*p))
         {
            error = ERROR_INVALID_SYNTAX;
            break;
         }

         
         osStrtoul(p, &p, 10);

         
         if(*p != '\0')
         {
            error = ERROR_INVALID_SYNTAX;
            break;
         }

         
      } while(0);
   }
   else
   {
      
      TRACE_WARNING(""SCP unknown directive received...\r\n"");

      
      error = ERROR_INVALID_COMMAND;
   }

   
   return error;
}
",64,1862,1483
"#define TRACE_LEVEL TRACE_LEVEL_OFF





#include ""os_port.h""
#include ""os_port_rtx.h""
#include ""debug.h""


static bool_t running = FALSE;
static OsTask taskTable[OS_PORT_MAX_TASKS];




void osInitKernel(void)
{
   
   running = FALSE;
   
   osMemset(taskTable, 0, sizeof(taskTable));
}




void osStartKernel(OsInitTaskCode task)
{
   
   running = TRUE;
   
   os_sys_init(task);
}




bool_t osCreateStaticTask(OsTask *task, const char_t *name, OsTaskCode taskCode,
   void *param, void *stack, size_t stackSize, int_t priority)
{
   
   task->tid = os_tsk_create_user_ex(taskCode, priority, stack,
      stackSize * sizeof(uint_t), param);

   
   if(task->tid != 0)
      return TRUE;
   else
      return FALSE;
}




OsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,
   void *param, size_t stackSize, int_t priority)
{
   uint_t i;
   OsTask *task = NULL;

   
   osSuspendAllTasks();

   
   for(i = 0; i < OS_PORT_MAX_TASKS; i++)
   {
      
      if(!taskTable[i].tid)
         break;
   }

   
   if(i < OS_PORT_MAX_TASKS)
   {
      
      taskTable[i].tid = os_tsk_create_ex(taskCode, priority, param);

      
      if(taskTable[i].tid != 0)
         task = &taskTable[i];
   }

   
   osResumeAllTasks();

   
   return task;
}




void osDeleteTask(OsTask *task)
{
   uint_t i;
   OS_TID tid;

   
   if(task == NULL)
      tid = os_tsk_self();
   else
      tid = task->tid;

   
   osSuspendAllTasks();

   
   for(i = 0; i < OS_PORT_MAX_TASKS; i++)
   {
      
      if(taskTable[i].tid == tid)
      {
         
         taskTable[i].tid = 0;
      }
   }

   
   osResumeAllTasks();

   
   if(task == NULL)
   {
      
      os_tsk_delete_self();
   }
   else
   {
      
      os_tsk_delete(tid);
   }
}




void osDelayTask(systime_t delay)
{
   uint16_t n;

   
   delay = OS_MS_TO_SYSTICKS(delay);

   
   while(delay > 0)
   {
      
      n = MIN(delay, 0xFFFE);
      
      os_dly_wait(n);
      
      delay -= n;
   }
}




void osSwitchTask(void)
{
   
   os_tsk_pass();
}




void osSuspendAllTasks(void)
{
   
   if(running)
   {
      
      tsk_lock();
   }
}




void osResumeAllTasks(void)
{
   
   if(running)
   {
      
      tsk_unlock();
   }
}




bool_t osCreateEvent(OsEvent *event)
{
   
   os_sem_init(event, 0);

   
   return TRUE;
}




void osDeleteEvent(OsEvent *event)
{
   
}




void osSetEvent(OsEvent *event)
{
   
   os_sem_send(event);
}




void osResetEvent(OsEvent *event)
{
   OS_RESULT res;

   
   do
   {
      
      res = os_sem_wait(event, 0);

      
   } while(res == OS_R_OK);
}




bool_t osWaitForEvent(OsEvent *event, systime_t timeout)
{
   uint16_t n;
   OS_RESULT res;

   
   
   if(timeout == INFINITE_DELAY)
   {
      
      res = os_sem_wait(event, 0xFFFF);
   }
   else
   {
      
      timeout = OS_MS_TO_SYSTICKS(timeout);

      
      do
      {
         
         n = MIN(timeout, 0xFFFE);
         
         res = os_sem_wait(event, n);
         
         timeout -= n;

         
      } while(res == OS_R_TMO && timeout > 0);
   }

   
   if(res == OS_R_OK || res == OS_R_SEM)
   {
      
      do
      {
         
         res = os_sem_wait(event, 0);

         
      } while(res == OS_R_OK);

      
      return TRUE;
   }
   else
   {
      
      return FALSE;
   }
}




bool_t osSetEventFromIsr(OsEvent *event)
{
   
   isr_sem_send(event);

   
   return FALSE;
}




bool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)
{
   
   os_sem_init(semaphore, count);

   
   return TRUE;
}




void osDeleteSemaphore(OsSemaphore *semaphore)
{
   
}




bool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)
{
   uint16_t n;
   OS_RESULT res;

   
   if(timeout == INFINITE_DELAY)
   {
      
      res = os_sem_wait(semaphore, 0xFFFF);
   }
   else
   {
      
      timeout = OS_MS_TO_SYSTICKS(timeout);

      
      do
      {
         
         n = MIN(timeout, 0xFFFE);
         
         res = os_sem_wait(semaphore, n);
         
         timeout -= n;

         
      } while(res == OS_R_TMO && timeout > 0);
   }

   
   if(res == OS_R_OK || res == OS_R_SEM)
      return TRUE;
   else
      return FALSE;
}




void osReleaseSemaphore(OsSemaphore *semaphore)
{
   
   os_sem_send(semaphore);
}




bool_t osCreateMutex(OsMutex *mutex)
{
   
   os_mut_init(mutex);

   
   return TRUE;
}




void osDeleteMutex(OsMutex *mutex)
{
   
}




void osAcquireMutex(OsMutex *mutex)
{
   
   os_mut_wait(mutex, 0xFFFF);
}




void osReleaseMutex(OsMutex *mutex)
{
   
   os_mut_release(mutex);
}




systime_t osGetSystemTime(void)
{
   systime_t time;

   
   time = os_time_get();

   
   return OS_SYSTICKS_TO_MS(time);
}




void *osAllocMem(size_t size)
{
   void *p;

   
   osSuspendAllTasks();
   
   p = malloc(size);
   
   osResumeAllTasks();

   
   TRACE_DEBUG(""Allocating %u bytes at 0x%08X\r\n"", size, (uint_t) p);

   
   return p;
}




void osFreeMem(void *p)
{
   
   if(p != NULL)
   {
      
      TRACE_DEBUG(""Freeing memory at 0x%08X\r\n"", (uint_t) p);

      
      osSuspendAllTasks();
      
      free(p);
      
      osResumeAllTasks();
   }
}
",64,1863,2200
"#define TRACE_LEVEL TLS_TRACE_LEVEL



#include ""tls.h""
#include ""tls_handshake.h""
#include ""tls_misc.h""
#include ""tls13_common.h""
#include ""tls13_key_material.h""
#include ""debug.h""


#if (TLS_SUPPORT == ENABLED && TLS_MAX_VERSION >= TLS_VERSION_1_3)




error_t tls13SendKeyUpdate(TlsContext *context)
{
   error_t error;
   size_t length;
   uint8_t *appTrafficSecret;
   Tls13KeyUpdate *message;
   const HashAlgo *hash;

   
   appTrafficSecret = NULL;

   
   message = (Tls13KeyUpdate *) (context->txBuffer + context->txBufferLen);

   
   error = tls13FormatKeyUpdate(context, message, &length);

   
   if(!error)
   {
      
      TRACE_INFO(""Sending KeyUpdate message (%"" PRIuSIZE "" bytes)...\r\n"", length);
      TRACE_DEBUG_ARRAY(""  "", message, length);

      
      error = tlsSendHandshakeMessage(context, message, length,
         TLS_TYPE_KEY_UPDATE);
   }

   
   if(error == NO_ERROR || error == ERROR_WOULD_BLOCK || error == ERROR_TIMEOUT)
   {
      
      hash = context->cipherSuite.prfHashAlgo;

      
      if(hash != NULL)
      {
         
         if(context->entity == TLS_CONNECTION_END_CLIENT)
            appTrafficSecret = context->clientAppTrafficSecret;
         else
            appTrafficSecret = context->serverAppTrafficSecret;

         
         error = tls13HkdfExpandLabel(hash, appTrafficSecret, hash->digestSize,
            ""traffic upd"", NULL, 0, appTrafficSecret, hash->digestSize);
      }
      else
      {
         
         error = ERROR_FAILURE;
      }
   }

   
   if(!error)
   {
      
      tlsFreeEncryptionEngine(&context->encryptionEngine);

      
      
      error = tlsInitEncryptionEngine(context, &context->encryptionEngine,
         context->entity, appTrafficSecret);
   }

   
   if(!error)
   {
      
      
      context->state = TLS_STATE_APPLICATION_DATA;
   }

   
   return error;
}




error_t tls13FormatKeyUpdate(TlsContext *context, Tls13KeyUpdate *message,
   size_t *length)
{
   
   
   message->requestUpdate = TLS_KEY_UPDATE_NOT_REQUESTED;

   
   *length = sizeof(Tls13KeyUpdate);

   
   return NO_ERROR;
}




error_t tls13ParseKeyUpdate(TlsContext *context, const Tls13KeyUpdate *message,
   size_t length)
{
   error_t error;
   uint8_t *appTrafficSecret;
   TlsConnectionEnd entity;
   const HashAlgo *hash;

   
   TRACE_INFO(""KeyUpdate message received (%"" PRIuSIZE "" bytes)...\r\n"", length);
   TRACE_DEBUG_ARRAY(""  "", message, length);

   
   if(context->version != TLS_VERSION_1_3)
      return ERROR_UNEXPECTED_MESSAGE;

   
   if(length != sizeof(Tls13KeyUpdate))
      return ERROR_DECODING_FAILED;

   
   if(message->requestUpdate != TLS_KEY_UPDATE_NOT_REQUESTED &&
      message->requestUpdate != TLS_KEY_UPDATE_REQUESTED)
   {
      
      
      return ERROR_ILLEGAL_PARAMETER;
   }

   
   
   if(context->state != TLS_STATE_APPLICATION_DATA &&
      context->state != TLS_STATE_CLOSING)
   {
      
      return ERROR_UNEXPECTED_MESSAGE;
   }

#if (TLS_MAX_KEY_UPDATE_MESSAGES > 0)
   
   context->keyUpdateCount++;

   
   if(context->keyUpdateCount > TLS_MAX_KEY_UPDATE_MESSAGES)
      return ERROR_UNEXPECTED_MESSAGE;
#endif

   
   hash = context->cipherSuite.prfHashAlgo;
   
   if(hash == NULL)
      return ERROR_FAILURE;

   
   if(context->entity == TLS_CONNECTION_END_CLIENT)
   {
      entity = TLS_CONNECTION_END_SERVER;
      appTrafficSecret = context->serverAppTrafficSecret;
   }
   else
   {
      entity = TLS_CONNECTION_END_CLIENT;
      appTrafficSecret = context->clientAppTrafficSecret;
   }

   
   error = tls13HkdfExpandLabel(hash, appTrafficSecret, hash->digestSize,
      ""traffic upd"", NULL, 0, appTrafficSecret, hash->digestSize);
   
   if(error)
      return error;

   
   
   if(context->rxBufferLen != 0)
      return ERROR_UNEXPECTED_MESSAGE;

   
   tlsFreeEncryptionEngine(&context->decryptionEngine);

   
   
   error = tlsInitEncryptionEngine(context, &context->decryptionEngine,
      entity, appTrafficSecret);
   
   if(error)
      return error;

   
   if(message->requestUpdate == TLS_KEY_UPDATE_REQUESTED &&
      context->state == TLS_STATE_APPLICATION_DATA)
   {
#if (TLS_MAX_KEY_UPDATE_MESSAGES > 0)
      if(context->keyUpdateCount == 1)
#endif
      {
         
         
         
         context->state = TLS_STATE_KEY_UPDATE;
      }
   }

   
   return NO_ERROR;
}

#endif
",64,1864,1561
"#define TRACE_LEVEL ACME_TRACE_LEVEL


#include ""acme/acme_client.h""
#include ""acme/acme_client_nonce.h""
#include ""acme/acme_client_misc.h""
#include ""debug.h""


#if (ACME_CLIENT_SUPPORT == ENABLED)




error_t acmeClientSendNewNonceRequest(AcmeClientContext *context)
{
   error_t error;

   
   error = NO_ERROR;

   
   while(!error)
   {
      
      if(context->requestState == ACME_REQ_STATE_INIT)
      {
         
         TRACE_DEBUG(""\r\n"");
         TRACE_DEBUG(""################################################################################\r\n"");
         TRACE_DEBUG(""## GET NEW NONCE ###############################################################\r\n"");
         TRACE_DEBUG(""################################################################################\r\n"");
         TRACE_DEBUG(""\r\n"");

         
         if(context->nonce[0] != '\0')
         {
            
            break;
         }
         else
         {
            
            context->requestState = ACME_REQ_STATE_FORMAT_HEADER;
         }
      }
      else if(context->requestState == ACME_REQ_STATE_FORMAT_HEADER)
      {
         
         
         error = acmeClientFormatRequestHeader(context, ""HEAD"",
            context->directory.newNonce);

         
         if(!error)
         {
            
            context->requestState = ACME_REQ_STATE_SEND_HEADER;
         }
      }
      else if(context->requestState == ACME_REQ_STATE_SEND_HEADER ||
         context->requestState == ACME_REQ_STATE_RECEIVE_HEADER ||
         context->requestState == ACME_REQ_STATE_PARSE_HEADER ||
         context->requestState == ACME_REQ_STATE_RECEIVE_BODY ||
         context->requestState == ACME_REQ_STATE_CLOSE_BODY)
      {
         
         error = acmeClientSendRequest(context);
      }
      else if(context->requestState == ACME_REQ_STATE_PARSE_BODY)
      {
         
         error = acmeClientParseNewNonceResponse(context);

         
         context->requestState = ACME_REQ_STATE_INIT;
         break;
      }
      else
      {
         
         error = ERROR_WRONG_STATE;
      }
   }

   
   return error;
}




error_t acmeClientParseNewNonceResponse(AcmeClientContext *context)
{
   
   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))
      return ERROR_UNEXPECTED_STATUS;

   
   
   if(context->nonce[0] == '\0')
      return ERROR_INVALID_RESPONSE;

   
   return NO_ERROR;
}

#endif
",64,1865,770
"#define TRACE_LEVEL SNMP_TRACE_LEVEL


#include ""core/net.h""
#include ""mibs/mib_common.h""
#include ""mibs/bridge_mib_module.h""
#include ""mibs/bridge_mib_impl.h""
#include ""mibs/bridge_mib_impl_tp.h""
#include ""core/crypto.h""
#include ""encoding/asn1.h""
#include ""encoding/oid.h""
#include ""stp/stp.h""
#include ""stp/stp_mgmt.h""
#include ""rstp/rstp.h""
#include ""rstp/rstp_mgmt.h""
#include ""debug.h""


#if (BRIDGE_MIB_SUPPORT == ENABLED)




error_t bridgeMibGetDot1dTpLearnedEntryDiscards(const MibObject *object, const uint8_t *oid,
   size_t oidLen, MibVariant *value, size_t *valueLen)
{
   
   
   
   value->counter32 = 0;

   
   return NO_ERROR;
}




error_t bridgeMibSetDot1dTpAgingTime(const MibObject *object, const uint8_t *oid,
   size_t oidLen, const MibVariant *value, size_t valueLen, bool_t commit)
{
#if (BRIDGE_MIB_SET_SUPPORT == ENABLED)
   error_t error;

   
   if(value->integer >= 0)
   {
#if (STP_SUPPORT == ENABLED)
      
      if(bridgeMibBase.stpBridgeContext != NULL)
      {
         
         
         error = stpMgmtSetAgeingTime(bridgeMibBase.stpBridgeContext,
            value->integer, commit);
      }
      else
#endif
#if (RSTP_SUPPORT == ENABLED)
      
      if(bridgeMibBase.rstpBridgeContext != NULL)
      {
         
         
         error = rstpMgmtSetAgeingTime(bridgeMibBase.rstpBridgeContext,
            value->integer, commit);
      }
      else
#endif
      
      {
         
         error = ERROR_WRITE_FAILED;
      }
   }
   else
   {
      
      error = ERROR_WRONG_VALUE;
   }

   
   return error;
#else
   
   return ERROR_WRITE_FAILED;
#endif
}




error_t bridgeMibGetDot1dTpAgingTime(const MibObject *object, const uint8_t *oid,
   size_t oidLen, MibVariant *value, size_t *valueLen)
{
   error_t error;
   uint_t ageingTime;

   
   ageingTime = 0;

#if (STP_SUPPORT == ENABLED)
   
   if(bridgeMibBase.stpBridgeContext != NULL)
   {
      
      
      error = stpMgmtGetAgeingTime(bridgeMibBase.stpBridgeContext,
         &ageingTime);
   }
   else
#endif
#if (RSTP_SUPPORT == ENABLED)
   
   if(bridgeMibBase.rstpBridgeContext != NULL)
   {
      
      
      error = rstpMgmtGetAgeingTime(bridgeMibBase.rstpBridgeContext,
         &ageingTime);
   }
   else
#endif
   
   {
      
      error = ERROR_READ_FAILED;
   }

   
   if(!error)
   {
      
      value->integer = ageingTime;
   }

   
   return error;
}




error_t bridgeMibGetDot1dTpFdbEntry(const MibObject *object, const uint8_t *oid,
   size_t oidLen, MibVariant *value, size_t *valueLen)
{
   error_t error;
   uint_t i;
   size_t n;
   SwitchFdbEntry entry;
   MacAddr dot1dTpFdbAddress;
   NetInterface *interface;

   
   if(bridgeMibBase.interface == NULL)
      return ERROR_READ_FAILED;

   
   interface = bridgeMibBase.interface;

   
   n = object->oidLen;

   
   error = mibDecodeMacAddr(oid, oidLen, &n, &dot1dTpFdbAddress);
   
   if(error)
      return error;

   
   if(n != oidLen)
      return ERROR_INSTANCE_NOT_FOUND;

   
   for(i = 0; !error; i++)
   {
      
      error = interface->switchDriver->getDynamicFdbEntry(interface, i, &entry);

      
      if(error == NO_ERROR)
      {
         
         if(macCompAddr(&entry.macAddr, &dot1dTpFdbAddress))
            break;
      }
      else if(error == ERROR_INVALID_ENTRY)
      {
         
         error = NO_ERROR;
      }
      else
      {
         
      }
   }

   
   if(error)
      return ERROR_INSTANCE_NOT_FOUND;

   
   if(!strcmp(object->name, ""dot1dTpFdbAddress""))
   {
      
      if(*valueLen >= sizeof(MacAddr))
      {
         
         
         macCopyAddr(value->octetString, &entry.macAddr);

         
         *valueLen = sizeof(MacAddr);
      }
      else
      {
         
         error = ERROR_BUFFER_OVERFLOW;
      }
   }
   
   else if(!strcmp(object->name, ""dot1dTpFdbPort""))
   {
      
      
      
      value->integer = entry.srcPort;
   }
   
   else if(!strcmp(object->name, ""dot1dTpFdbStatus""))
   {
      
      value->integer = BRIDGE_MIB_FDB_STATUS_LEARNED;
   }
   
   else
   {
      
      error = ERROR_OBJECT_NOT_FOUND;
   }

   
   return error;
}




error_t bridgeMibGetNextDot1dTpFdbEntry(const MibObject *object, const uint8_t *oid,
   size_t oidLen, uint8_t *nextOid, size_t *nextOidLen)
{
   error_t error;
   uint_t i;
   size_t n;
   MacAddr macAddr;
   SwitchFdbEntry entry;
   NetInterface *interface;

   
   macAddr = MAC_UNSPECIFIED_ADDR;

   
   if(bridgeMibBase.interface == NULL)
      return ERROR_OBJECT_NOT_FOUND;

   
   interface = bridgeMibBase.interface;

   
   if(*nextOidLen < object->oidLen)
      return ERROR_BUFFER_OVERFLOW;

   
   osMemcpy(nextOid, object->oid, object->oidLen);

   
   error = NO_ERROR;

   
   for(i = 0; !error; i++)
   {
      
      error = interface->switchDriver->getDynamicFdbEntry(interface, i, &entry);

      
      if(error == NO_ERROR)
      {
         
         n = object->oidLen;

         
         error = mibEncodeMacAddr(nextOid, *nextOidLen, &n, &entry.macAddr);
         
         if(error)
            return error;

         
         
         if(oidComp(nextOid, n, oid, oidLen) > 0)
         {
            
            
            if(mibCompMacAddr(&macAddr, &MAC_UNSPECIFIED_ADDR) == 0 ||
               mibCompMacAddr(&entry.macAddr, &macAddr) < 0)
            {
               macAddr = entry.macAddr;
            }
         }
      }
      else if(error == ERROR_INVALID_ENTRY)
      {
         
         error = NO_ERROR;
      }
      else
      {
         
      }
   }

   
   
   if(mibCompMacAddr(&macAddr, &MAC_UNSPECIFIED_ADDR) == 0)
      return ERROR_OBJECT_NOT_FOUND;

   
   n = object->oidLen;

   
   error = mibEncodeMacAddr(nextOid, *nextOidLen, &n, &macAddr);
   
   if(error)
      return error;

   
   *nextOidLen = n;
   
   return NO_ERROR;
}




error_t bridgeMibGetDot1dTpPortEntry(const MibObject *object, const uint8_t *oid,
   size_t oidLen, MibVariant *value, size_t *valueLen)
{
   error_t error;
   size_t n;
   uint16_t dot1dTpPort;

   
   n = object->oidLen;

   
   error = mibDecodePort(oid, oidLen, &n, &dot1dTpPort);
   
   if(error)
      return error;

   
   if(n != oidLen)
      return ERROR_INSTANCE_NOT_FOUND;

   
   if(bridgeMibGetPortIndex(dot1dTpPort) == 0)
      return ERROR_INSTANCE_NOT_FOUND;

   
   if(!strcmp(object->name, ""dot1dTpPort""))
   {
      
      
      value->integer = dot1dTpPort;
   }
   
   else if(!strcmp(object->name, ""dot1dTpPortMaxInfo""))
   {
      
      
      value->integer = ETH_MTU;
   }
   
   else if(!strcmp(object->name, ""dot1dTpPortInFrames""))
   {
      
      
      value->counter32 = 0;
   }
   
   else if(!strcmp(object->name, ""dot1dTpPortOutFrames""))
   {
      
      
      value->counter32 = 0;
   }
   
   else if(!strcmp(object->name, ""dot1dTpPortInDiscards""))
   {
      
      
      value->counter32 = 0;
   }
   
   else
   {
      
      error = ERROR_OBJECT_NOT_FOUND;
   }

   
   return error;
}




error_t bridgeMibGetNextDot1dTpPortEntry(const MibObject *object, const uint8_t *oid,
   size_t oidLen, uint8_t *nextOid, size_t *nextOidLen)
{
   error_t error;
   uint_t i;
   size_t n;
   uint_t numPorts;
   uint16_t portNum;
   uint16_t curPortNum;

   
   portNum = 0;

   
   if(*nextOidLen < object->oidLen)
      return ERROR_BUFFER_OVERFLOW;

   
   osMemcpy(nextOid, object->oid, object->oidLen);

   
   numPorts = bridgeMibGetNumPorts();

   
   for(i = 1; i <= numPorts; i++)
   {
      
      curPortNum = bridgeMibGetPortNum(i);

      
      n = object->oidLen;

      
      error = mibEncodeIndex(nextOid, *nextOidLen, &n, curPortNum);
      
      if(error)
         return error;

      
      
      if(oidComp(nextOid, n, oid, oidLen) > 0)
      {
         
         
         if(portNum == 0 || curPortNum < portNum)
         {
            portNum = curPortNum;
         }
      }
   }

   
   
   if(portNum == 0)
      return ERROR_OBJECT_NOT_FOUND;

   
   n = object->oidLen;

   
   error = mibEncodeIndex(nextOid, *nextOidLen, &n, portNum);
   
   if(error)
      return error;

   
   *nextOidLen = n;
   
   return NO_ERROR;
}

#endif
",64,1866,3245
"#define TRACE_LEVEL SHELL_TRACE_LEVEL


#include ""ssh/ssh.h""
#include ""shell/shell_server.h""
#include ""shell/shell_server_pty.h""
#include ""shell/shell_server_misc.h""
#include ""debug.h""


#if (SHELL_SERVER_SUPPORT == ENABLED)




void shellServerGetDefaultSettings(ShellServerSettings *settings)
{
   
   settings->sshServerContext = NULL;

   
   settings->numSessions = 0;
   settings->sessions = NULL;

   
   settings->checkUserCallback = NULL;
   
   settings->commandLineCallback = NULL;
}




error_t shellServerInit(ShellServerContext *context,
   const ShellServerSettings *settings)
{
   uint_t i;

   
   TRACE_INFO(""Initializing shell server...\r\n"");

   
   if(context == NULL || settings == NULL)
      return ERROR_INVALID_PARAMETER;

   
   if(settings->sessions == NULL || settings->numSessions < 1 ||
      settings->numSessions > SHELL_SERVER_MAX_SESSIONS)
   {
      return ERROR_INVALID_PARAMETER;
   }

   
   osMemset(context, 0, sizeof(ShellServerContext));

   
   context->sshServerContext = settings->sshServerContext;
   context->numSessions = settings->numSessions;
   context->sessions = settings->sessions;
   context->checkUserCallback = settings->checkUserCallback;
   context->commandLineCallback = settings->commandLineCallback;

   
   for(i = 0; i < context->numSessions; i++)
   {
      
      osMemset(&context->sessions[i], 0, sizeof(ShellServerSession));

      
      if(!osCreateEvent(&context->sessions[i].startEvent))
         return ERROR_OUT_OF_RESOURCES;

      
      if(!osCreateEvent(&context->sessions[i].event))
         return ERROR_OUT_OF_RESOURCES;
   }

   
   if(!osCreateEvent(&context->event))
      return ERROR_OUT_OF_RESOURCES;

   
   return NO_ERROR;
}




error_t shellServerStart(ShellServerContext *context)
{
   error_t error;
   uint_t i;
   OsTask *task;

   
   if(context == NULL)
      return ERROR_INVALID_PARAMETER;

   
   TRACE_INFO(""Starting shell server...\r\n"");

   
   if(context->running)
      return ERROR_ALREADY_RUNNING;

   
   error = sshServerRegisterChannelRequestCallback(context->sshServerContext,
      shellServerChannelRequestCallback, context);
   
   if(error)
      return error;

   
   for(i = 0; i < context->numSessions; i++)
   {
      
      task = osCreateTask(""Shell Session"", shellServerTask,
         &context->sessions[i], SHELL_SERVER_STACK_SIZE,
         SHELL_SERVER_PRIORITY);

      
      if(task == NULL)
         return ERROR_OUT_OF_RESOURCES;
   }

   
   return NO_ERROR;
}




error_t shellServerSetBanner(ShellServerSession *session,
   const char_t *banner)
{
   size_t n;

   
   if(session == NULL || banner == NULL)
      return ERROR_INVALID_PARAMETER;

   
   n = osStrlen(banner);

   
   if(n > SHELL_SERVER_BUFFER_SIZE)
      return ERROR_INVALID_LENGTH;

   
   osStrncpy(session->buffer, banner, n);

   
   session->bufferLen = n;
   session->bufferPos = 0;

   
   return NO_ERROR;
}




error_t shellServerSetPrompt(ShellServerSession *session,
   const char_t *prompt)
{
   
   if(session == NULL || prompt == NULL)
      return ERROR_INVALID_PARAMETER;

   
   if(osStrlen(prompt) > SHELL_SERVER_MAX_PROMPT_LEN)
      return ERROR_INVALID_LENGTH;

   
   osStrcpy(session->prompt, prompt);
   
   session->promptLen = osStrlen(prompt);

   
   return NO_ERROR;
}




error_t shellServerSetTimeout(ShellServerSession *session, systime_t timeout)
{
   error_t error;

   
   if(session != NULL)
   {
      
      error = sshSetChannelTimeout(session->channel, timeout);
   }
   else
   {
      
      error = ERROR_INVALID_PARAMETER;
   }

   
   return error;
}




error_t shellServerWriteStream(ShellServerSession *session, const void *data,
   size_t length, size_t *written, uint_t flags)
{
   error_t error;

   
   if(session != NULL)
   {
      
      error = sshWriteChannel(session->channel, data, length, written, flags);
   }
   else
   {
      
      error = ERROR_INVALID_PARAMETER;
   }

   
   return error;
}




error_t shellServerReadStream(ShellServerSession *session, void *data,
   size_t size, size_t *received, uint_t flags)
{
   error_t error;

   
   if(session != NULL)
   {
      
      error = sshReadChannel(session->channel, data, size, received, flags);
   }
   else
   {
      
      error = ERROR_INVALID_PARAMETER;
   }

   
   return error;
}




void shellServerTask(void *param)
{
   error_t error;
   SshChannel *channel;
   ShellServerSession *session;

   
   session = (ShellServerSession *) param;

   
   TRACE_INFO(""Starting shell task...\r\n"");

   
   error = NO_ERROR;

   
   while(1)
   {
      
      osWaitForEvent(&session->startEvent, INFINITE_DELAY);

      
      TRACE_INFO(""Starting shell session...\r\n"");

      
      channel = session->channel;

      
      if(session->state == SHELL_SERVER_SESSION_STATE_OPEN)
      {
         
         sshSetChannelTimeout(channel, INFINITE_DELAY);

         
         if(session->bufferLen > 0)
         {
            
            error = sshWriteChannel(channel, session->buffer,
               session->bufferLen, NULL, 0);
         }

         
         if(!error)
         {
            
            error = sshWriteChannel(channel, session->prompt,
               osStrlen(session->prompt), NULL, 0);
         }

         
         session->bufferLen = 0;
         session->bufferPos = 0;
         session->escSeqLen = 0;

         
         while(!error)
         {
            SshChannelEventDesc eventDesc[1];

            
            eventDesc[0].channel = channel;
            eventDesc[0].eventMask = SSH_CHANNEL_EVENT_RX_READY;
            eventDesc[0].eventFlags = 0;

            
            error = sshPollChannels(eventDesc, 1, &session->event,
               SHELL_SERVER_TICK_INTERVAL);

            
            if(error == NO_ERROR || error == ERROR_TIMEOUT)
            {
               
               if(session->windowResize)
               {
                  
                  error = shellServerProcessWindowResize(session);
               }

               
               if(eventDesc[0].eventFlags != 0)
               {
                  
                  error = shellServerProcessChar(session);
               }
               else
               {
                  
                  error = NO_ERROR;
               }
            }
            else
            {
               
               break;
            }
         }
      }
      else if(session->state == SHELL_SERVER_SESSION_STATE_EXEC)
      {
         
         session->buffer[session->bufferLen] = '\0';
         
         error = shellServerProcessCommandLine(session, session->buffer);
      }
      else
      {
         
      }

      
      sshCloseChannel(channel);

      
      session->state = SHELL_SERVER_SESSION_STATE_CLOSED;

      
      TRACE_INFO(""Shell session terminated...\r\n"");
   }
}

#endif
",64,1867,2221
"#define TRACE_LEVEL TLS_TRACE_LEVEL



#include ""core/crypto.h""
#include ""tls.h""
#include ""ssl_misc.h""
#include ""debug.h""


#if (TLS_SUPPORT == ENABLED && TLS_MIN_VERSION <= SSL_VERSION_3_0)


const uint8_t sslPad1[48] =
{
   0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
   0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
   0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36
};


const uint8_t sslPad2[48] =
{
   0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
   0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
   0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C
};




error_t sslExpandKey(const uint8_t *secret, size_t secretLen,
   const uint8_t *random, size_t randomLen, uint8_t *output, size_t outputLen)
{
   uint_t i;
   size_t n;
   char_t pad[16];
   Md5Context *md5Context;
   Sha1Context *sha1Context;

   
   if(outputLen > (sizeof(pad) * MD5_DIGEST_SIZE))
      return ERROR_INVALID_LENGTH;

   
   md5Context = tlsAllocMem(sizeof(Md5Context));
   
   if(md5Context == NULL)
   {
      
      return ERROR_OUT_OF_MEMORY;
   }

   
   sha1Context = tlsAllocMem(sizeof(Sha1Context));
   
   if(sha1Context == NULL)
   {
      
      tlsFreeMem(md5Context);
      
      return ERROR_OUT_OF_MEMORY;
   }

   
   for(i = 0; outputLen > 0; i++)
   {
      
      osMemset(pad, 'A' + i, i + 1);

      
      sha1Init(sha1Context);
      sha1Update(sha1Context, pad, i + 1);
      sha1Update(sha1Context, secret, secretLen);
      sha1Update(sha1Context, random, randomLen);
      sha1Final(sha1Context, NULL);

      
      md5Init(md5Context);
      md5Update(md5Context, secret, secretLen);
      md5Update(md5Context, sha1Context->digest, SHA1_DIGEST_SIZE);
      md5Final(md5Context, NULL);

      
      n = MIN(outputLen, MD5_DIGEST_SIZE);
      
      osMemcpy(output, md5Context->digest, n);

      
      output += n;
      
      outputLen -= n;
   }

   
   tlsFreeMem(md5Context);
   tlsFreeMem(sha1Context);

   
   return NO_ERROR;
}




error_t sslComputeMac(TlsEncryptionEngine *encryptionEngine,
   const TlsRecord *record, const uint8_t *data, size_t dataLen, uint8_t *mac)
{
   size_t padLen;
   const HashAlgo *hashAlgo;
   HashContext *hashContext;

   
   hashAlgo = encryptionEngine->hashAlgo;
   
   hashContext = (HashContext *) encryptionEngine->hmacContext->hashContext;

   
   if(hashAlgo == MD5_HASH_ALGO)
   {
      
      padLen = 48;
   }
   else if(hashAlgo == SHA1_HASH_ALGO)
   {
      
      padLen = 40;
   }
   else
   {
      
      return ERROR_INVALID_PARAMETER;
   }

   
   hashAlgo->init(hashContext);
   hashAlgo->update(hashContext, encryptionEngine->macKey, encryptionEngine->macKeyLen);
   hashAlgo->update(hashContext, sslPad1, padLen);
   hashAlgo->update(hashContext, &encryptionEngine->seqNum, sizeof(TlsSequenceNumber));
   hashAlgo->update(hashContext, &record->type, sizeof(record->type));
   hashAlgo->update(hashContext, (void *) &record->length, sizeof(record->length));
   hashAlgo->update(hashContext, data, dataLen);
   hashAlgo->final(hashContext, mac);

   
   hashAlgo->init(hashContext);
   hashAlgo->update(hashContext, encryptionEngine->macKey, encryptionEngine->macKeyLen);
   hashAlgo->update(hashContext, sslPad2, padLen);
   hashAlgo->update(hashContext, mac, hashAlgo->digestSize);
   hashAlgo->final(hashContext, mac);

   
   return NO_ERROR;
}




uint32_t sslVerifyPadding(TlsEncryptionEngine *decryptionEngine,
   const uint8_t *data, size_t dataLen, size_t *paddingLen)
{
   size_t i;
   size_t n;
   uint8_t b;
   uint8_t mask;
   uint32_t c;
   uint32_t bad;
   uint32_t bad1;
   uint32_t bad2;

   
   n = data[dataLen - 1];

   
   bad = CRYPTO_TEST_GTE_32(n, dataLen);

   
   
   bad |= CRYPTO_TEST_GTE_32(n, decryptionEngine->cipherAlgo->blockSize);

   
   
   for(bad1 = 0, i = 1; i < dataLen && i < 256; i++)
   {
      
      b = data[dataLen - 1 - i];

      
      c = CRYPTO_TEST_LTE_32(i, n);
      mask = CRYPTO_SELECT_8(b, n, c);
      bad1 |= CRYPTO_TEST_NEQ_8(b, mask);
   }

   
   
   for(bad2 = 0, i = 1; i < dataLen && i < 256; i++)
   {
      
      b = data[dataLen - 1 - i];

      
      c = CRYPTO_TEST_LTE_32(i, n);
      mask = CRYPTO_SELECT_8(b, 0, c);
      bad2 |= CRYPTO_TEST_NEQ_8(b, mask);
   }

   
   bad |= bad1 & bad2;

   
   *paddingLen = CRYPTO_SELECT_32(n, 0, bad);

   
   return bad;
}




uint32_t sslVerifyMac(TlsEncryptionEngine *decryptionEngine,
   const TlsRecord *record, const uint8_t *data, size_t dataLen,
   size_t maxDataLen, const uint8_t *mac)
{
   size_t i;
   size_t j;
   size_t n;
   size_t padLen;
   size_t headerLen;
   size_t paddingLen;
   size_t blockSizeMask;
   uint8_t b;
   uint32_t c;
   uint64_t bitLen;
   const HashAlgo *hashAlgo;
   HashContext *hashContext;
   uint8_t temp1[SHA1_DIGEST_SIZE];
   uint8_t temp2[SHA1_DIGEST_SIZE];

   
   hashAlgo = decryptionEngine->hashAlgo;
   
   hashContext = (HashContext *) decryptionEngine->hmacContext->hashContext;

   
   if(hashAlgo == MD5_HASH_ALGO)
   {
      
      padLen = 48;
   }
   else if(hashAlgo == SHA1_HASH_ALGO)
   {
      
      padLen = 40;
   }
   else
   {
      
      return 1;
   }

   
   blockSizeMask = hashAlgo->blockSize - 1;

   
   
   headerLen = decryptionEngine->macKeyLen + padLen + 11;

   
   paddingLen = (headerLen + dataLen + hashAlgo->minPadSize - 1) & blockSizeMask;
   paddingLen = hashAlgo->blockSize - paddingLen;

   
   bitLen = (headerLen + dataLen) << 3;

   
   if(hashAlgo->bigEndian)
   {
      
      bitLen = swapInt64(bitLen);
   }

   
   n = headerLen + maxDataLen + hashAlgo->minPadSize;
   n = (n + hashAlgo->blockSize - 1) & ~blockSizeMask;
   n -= headerLen;

   
   hashAlgo->init(hashContext);
   hashAlgo->update(hashContext, decryptionEngine->macKey, decryptionEngine->macKeyLen);
   hashAlgo->update(hashContext, sslPad1, padLen);
   hashAlgo->update(hashContext, &decryptionEngine->seqNum, sizeof(TlsSequenceNumber));
   hashAlgo->update(hashContext, &record->type, sizeof(record->type));
   hashAlgo->update(hashContext, (void *) &record->length, sizeof(record->length));

   
   i = 0;

   
   
   if(maxDataLen > 255)
   {
      
      hashAlgo->update(hashContext, data, maxDataLen - 255);
      i += maxDataLen - 255;
   }

   
   while(i < n)
   {
      
      b = 0;

      
      c = CRYPTO_TEST_LT_32(i, dataLen);
      b = CRYPTO_SELECT_8(b, data[i], c);

      c = CRYPTO_TEST_EQ_32(i, dataLen);
      b = CRYPTO_SELECT_8(b, 0x80, c);

      j = dataLen + paddingLen;
      c = CRYPTO_TEST_GTE_32(i, j);
      j += 8;
      c &= CRYPTO_TEST_LT_32(i, j);
      b = CRYPTO_SELECT_8(b, bitLen & 0xFF, c);
      bitLen = CRYPTO_SELECT_64(bitLen, bitLen >> 8, c);

      
      hashAlgo->update(hashContext, &b, sizeof(uint8_t));

      
      i++;

      
      if(((i + headerLen) & blockSizeMask) == 0)
      {
         
         hashAlgo->finalRaw(hashContext, temp1);

         
         c = CRYPTO_TEST_EQ_32(i, dataLen + paddingLen + 8);

         
         
         for(j = 0; j < hashAlgo->digestSize; j++)
         {
            temp2[j] = CRYPTO_SELECT_8(temp2[j], temp1[j], c);
         }
      }
   }

   
   hashAlgo->init(hashContext);
   hashAlgo->update(hashContext, decryptionEngine->macKey, decryptionEngine->macKeyLen);
   hashAlgo->update(hashContext, sslPad2, padLen);
   hashAlgo->update(hashContext, temp2, hashAlgo->digestSize);
   hashAlgo->final(hashContext, temp1);

   
   TRACE_DEBUG(""Read sequence number:\r\n"");
   TRACE_DEBUG_ARRAY(""  "", &decryptionEngine->seqNum, sizeof(TlsSequenceNumber));
   TRACE_DEBUG(""Computed MAC:\r\n"");
   TRACE_DEBUG_ARRAY(""  "", temp1, hashAlgo->digestSize);

   
   
   for(b = 0, i = 0; i < hashAlgo->digestSize; i++)
   {
      b |= mac[i] ^ temp1[i];
   }

   
   return CRYPTO_TEST_NEQ_8(b, 0);
}

#endif
",64,1868,3606
"#define TRACE_LEVEL TLS_TRACE_LEVEL



#include ""tls.h""
#include ""tls_ffdhe.h""
#include ""debug.h""


#if (TLS_SUPPORT == ENABLED && TLS_FFDHE_SUPPORT == ENABLED)

#if (TLS_FFDHE2048_SUPPORT == ENABLED)



const TlsFfdheGroup ffdhe2048Group =
{
   
   ""ffdhe2048"",
   
   {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xAD, 0xF8, 0x54, 0x58, 0xA2, 0xBB, 0x4A, 0x9A,
    0xAF, 0xDC, 0x56, 0x20, 0x27, 0x3D, 0x3C, 0xF1, 0xD8, 0xB9, 0xC5, 0x83, 0xCE, 0x2D, 0x36, 0x95,
    0xA9, 0xE1, 0x36, 0x41, 0x14, 0x64, 0x33, 0xFB, 0xCC, 0x93, 0x9D, 0xCE, 0x24, 0x9B, 0x3E, 0xF9,
    0x7D, 0x2F, 0xE3, 0x63, 0x63, 0x0C, 0x75, 0xD8, 0xF6, 0x81, 0xB2, 0x02, 0xAE, 0xC4, 0x61, 0x7A,
    0xD3, 0xDF, 0x1E, 0xD5, 0xD5, 0xFD, 0x65, 0x61, 0x24, 0x33, 0xF5, 0x1F, 0x5F, 0x06, 0x6E, 0xD0,
    0x85, 0x63, 0x65, 0x55, 0x3D, 0xED, 0x1A, 0xF3, 0xB5, 0x57, 0x13, 0x5E, 0x7F, 0x57, 0xC9, 0x35,
    0x98, 0x4F, 0x0C, 0x70, 0xE0, 0xE6, 0x8B, 0x77, 0xE2, 0xA6, 0x89, 0xDA, 0xF3, 0xEF, 0xE8, 0x72,
    0x1D, 0xF1, 0x58, 0xA1, 0x36, 0xAD, 0xE7, 0x35, 0x30, 0xAC, 0xCA, 0x4F, 0x48, 0x3A, 0x79, 0x7A,
    0xBC, 0x0A, 0xB1, 0x82, 0xB3, 0x24, 0xFB, 0x61, 0xD1, 0x08, 0xA9, 0x4B, 0xB2, 0xC8, 0xE3, 0xFB,
    0xB9, 0x6A, 0xDA, 0xB7, 0x60, 0xD7, 0xF4, 0x68, 0x1D, 0x4F, 0x42, 0xA3, 0xDE, 0x39, 0x4D, 0xF4,
    0xAE, 0x56, 0xED, 0xE7, 0x63, 0x72, 0xBB, 0x19, 0x0B, 0x07, 0xA7, 0xC8, 0xEE, 0x0A, 0x6D, 0x70,
    0x9E, 0x02, 0xFC, 0xE1, 0xCD, 0xF7, 0xE2, 0xEC, 0xC0, 0x34, 0x04, 0xCD, 0x28, 0x34, 0x2F, 0x61,
    0x91, 0x72, 0xFE, 0x9C, 0xE9, 0x85, 0x83, 0xFF, 0x8E, 0x4F, 0x12, 0x32, 0xEE, 0xF2, 0x81, 0x83,
    0xC3, 0xFE, 0x3B, 0x1B, 0x4C, 0x6F, 0xAD, 0x73, 0x3B, 0xB5, 0xFC, 0xBC, 0x2E, 0xC2, 0x20, 0x05,
    0xC5, 0x8E, 0xF1, 0x83, 0x7D, 0x16, 0x83, 0xB2, 0xC6, 0xF3, 0x4A, 0x26, 0xC1, 0xB2, 0xEF, 0xFA,
    0x88, 0x6B, 0x42, 0x38, 0x61, 0x28, 0x5C, 0x97, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
   256,
   
   2
};

#endif
#if (TLS_FFDHE3072_SUPPORT == ENABLED)



const TlsFfdheGroup ffdhe3072Group =
{
   
   ""ffdhe3072"",
   
   {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xAD, 0xF8, 0x54, 0x58, 0xA2, 0xBB, 0x4A, 0x9A,
    0xAF, 0xDC, 0x56, 0x20, 0x27, 0x3D, 0x3C, 0xF1, 0xD8, 0xB9, 0xC5, 0x83, 0xCE, 0x2D, 0x36, 0x95,
    0xA9, 0xE1, 0x36, 0x41, 0x14, 0x64, 0x33, 0xFB, 0xCC, 0x93, 0x9D, 0xCE, 0x24, 0x9B, 0x3E, 0xF9,
    0x7D, 0x2F, 0xE3, 0x63, 0x63, 0x0C, 0x75, 0xD8, 0xF6, 0x81, 0xB2, 0x02, 0xAE, 0xC4, 0x61, 0x7A,
    0xD3, 0xDF, 0x1E, 0xD5, 0xD5, 0xFD, 0x65, 0x61, 0x24, 0x33, 0xF5, 0x1F, 0x5F, 0x06, 0x6E, 0xD0,
    0x85, 0x63, 0x65, 0x55, 0x3D, 0xED, 0x1A, 0xF3, 0xB5, 0x57, 0x13, 0x5E, 0x7F, 0x57, 0xC9, 0x35,
    0x98, 0x4F, 0x0C, 0x70, 0xE0, 0xE6, 0x8B, 0x77, 0xE2, 0xA6, 0x89, 0xDA, 0xF3, 0xEF, 0xE8, 0x72,
    0x1D, 0xF1, 0x58, 0xA1, 0x36, 0xAD, 0xE7, 0x35, 0x30, 0xAC, 0xCA, 0x4F, 0x48, 0x3A, 0x79, 0x7A,
    0xBC, 0x0A, 0xB1, 0x82, 0xB3, 0x24, 0xFB, 0x61, 0xD1, 0x08, 0xA9, 0x4B, 0xB2, 0xC8, 0xE3, 0xFB,
    0xB9, 0x6A, 0xDA, 0xB7, 0x60, 0xD7, 0xF4, 0x68, 0x1D, 0x4F, 0x42, 0xA3, 0xDE, 0x39, 0x4D, 0xF4,
    0xAE, 0x56, 0xED, 0xE7, 0x63, 0x72, 0xBB, 0x19, 0x0B, 0x07, 0xA7, 0xC8, 0xEE, 0x0A, 0x6D, 0x70,
    0x9E, 0x02, 0xFC, 0xE1, 0xCD, 0xF7, 0xE2, 0xEC, 0xC0, 0x34, 0x04, 0xCD, 0x28, 0x34, 0x2F, 0x61,
    0x91, 0x72, 0xFE, 0x9C, 0xE9, 0x85, 0x83, 0xFF, 0x8E, 0x4F, 0x12, 0x32, 0xEE, 0xF2, 0x81, 0x83,
    0xC3, 0xFE, 0x3B, 0x1B, 0x4C, 0x6F, 0xAD, 0x73, 0x3B, 0xB5, 0xFC, 0xBC, 0x2E, 0xC2, 0x20, 0x05,
    0xC5, 0x8E, 0xF1, 0x83, 0x7D, 0x16, 0x83, 0xB2, 0xC6, 0xF3, 0x4A, 0x26, 0xC1, 0xB2, 0xEF, 0xFA,
    0x88, 0x6B, 0x42, 0x38, 0x61, 0x1F, 0xCF, 0xDC, 0xDE, 0x35, 0x5B, 0x3B, 0x65, 0x19, 0x03, 0x5B,
    0xBC, 0x34, 0xF4, 0xDE, 0xF9, 0x9C, 0x02, 0x38, 0x61, 0xB4, 0x6F, 0xC9, 0xD6, 0xE6, 0xC9, 0x07,
    0x7A, 0xD9, 0x1D, 0x26, 0x91, 0xF7, 0xF7, 0xEE, 0x59, 0x8C, 0xB0, 0xFA, 0xC1, 0x86, 0xD9, 0x1C,
    0xAE, 0xFE, 0x13, 0x09, 0x85, 0x13, 0x92, 0x70, 0xB4, 0x13, 0x0C, 0x93, 0xBC, 0x43, 0x79, 0x44,
    0xF4, 0xFD, 0x44, 0x52, 0xE2, 0xD7, 0x4D, 0xD3, 0x64, 0xF2, 0xE2, 0x1E, 0x71, 0xF5, 0x4B, 0xFF,
    0x5C, 0xAE, 0x82, 0xAB, 0x9C, 0x9D, 0xF6, 0x9E, 0xE8, 0x6D, 0x2B, 0xC5, 0x22, 0x36, 0x3A, 0x0D,
    0xAB, 0xC5, 0x21, 0x97, 0x9B, 0x0D, 0xEA, 0xDA, 0x1D, 0xBF, 0x9A, 0x42, 0xD5, 0xC4, 0x48, 0x4E,
    0x0A, 0xBC, 0xD0, 0x6B, 0xFA, 0x53, 0xDD, 0xEF, 0x3C, 0x1B, 0x20, 0xEE, 0x3F, 0xD5, 0x9D, 0x7C,
    0x25, 0xE4, 0x1D, 0x2B, 0x66, 0xC6, 0x2E, 0x37, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
   384,
   
   2
};

#endif
#if (TLS_FFDHE4096_SUPPORT == ENABLED)



const TlsFfdheGroup ffdhe4096Group =
{
   
   ""ffdhe4096"",
   
   {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xAD, 0xF8, 0x54, 0x58, 0xA2, 0xBB, 0x4A, 0x9A,
    0xAF, 0xDC, 0x56, 0x20, 0x27, 0x3D, 0x3C, 0xF1, 0xD8, 0xB9, 0xC5, 0x83, 0xCE, 0x2D, 0x36, 0x95,
    0xA9, 0xE1, 0x36, 0x41, 0x14, 0x64, 0x33, 0xFB, 0xCC, 0x93, 0x9D, 0xCE, 0x24, 0x9B, 0x3E, 0xF9,
    0x7D, 0x2F, 0xE3, 0x63, 0x63, 0x0C, 0x75, 0xD8, 0xF6, 0x81, 0xB2, 0x02, 0xAE, 0xC4, 0x61, 0x7A,
    0xD3, 0xDF, 0x1E, 0xD5, 0xD5, 0xFD, 0x65, 0x61, 0x24, 0x33, 0xF5, 0x1F, 0x5F, 0x06, 0x6E, 0xD0,
    0x85, 0x63, 0x65, 0x55, 0x3D, 0xED, 0x1A, 0xF3, 0xB5, 0x57, 0x13, 0x5E, 0x7F, 0x57, 0xC9, 0x35,
    0x98, 0x4F, 0x0C, 0x70, 0xE0, 0xE6, 0x8B, 0x77, 0xE2, 0xA6, 0x89, 0xDA, 0xF3, 0xEF, 0xE8, 0x72,
    0x1D, 0xF1, 0x58, 0xA1, 0x36, 0xAD, 0xE7, 0x35, 0x30, 0xAC, 0xCA, 0x4F, 0x48, 0x3A, 0x79, 0x7A,
    0xBC, 0x0A, 0xB1, 0x82, 0xB3, 0x24, 0xFB, 0x61, 0xD1, 0x08, 0xA9, 0x4B, 0xB2, 0xC8, 0xE3, 0xFB,
    0xB9, 0x6A, 0xDA, 0xB7, 0x60, 0xD7, 0xF4, 0x68, 0x1D, 0x4F, 0x42, 0xA3, 0xDE, 0x39, 0x4D, 0xF4,
    0xAE, 0x56, 0xED, 0xE7, 0x63, 0x72, 0xBB, 0x19, 0x0B, 0x07, 0xA7, 0xC8, 0xEE, 0x0A, 0x6D, 0x70,
    0x9E, 0x02, 0xFC, 0xE1, 0xCD, 0xF7, 0xE2, 0xEC, 0xC0, 0x34, 0x04, 0xCD, 0x28, 0x34, 0x2F, 0x61,
    0x91, 0x72, 0xFE, 0x9C, 0xE9, 0x85, 0x83, 0xFF, 0x8E, 0x4F, 0x12, 0x32, 0xEE, 0xF2, 0x81, 0x83,
    0xC3, 0xFE, 0x3B, 0x1B, 0x4C, 0x6F, 0xAD, 0x73, 0x3B, 0xB5, 0xFC, 0xBC, 0x2E, 0xC2, 0x20, 0x05,
    0xC5, 0x8E, 0xF1, 0x83, 0x7D, 0x16, 0x83, 0xB2, 0xC6, 0xF3, 0x4A, 0x26, 0xC1, 0xB2, 0xEF, 0xFA,
    0x88, 0x6B, 0x42, 0x38, 0x61, 0x1F, 0xCF, 0xDC, 0xDE, 0x35, 0x5B, 0x3B, 0x65, 0x19, 0x03, 0x5B,
    0xBC, 0x34, 0xF4, 0xDE, 0xF9, 0x9C, 0x02, 0x38, 0x61, 0xB4, 0x6F, 0xC9, 0xD6, 0xE6, 0xC9, 0x07,
    0x7A, 0xD9, 0x1D, 0x26, 0x91, 0xF7, 0xF7, 0xEE, 0x59, 0x8C, 0xB0, 0xFA, 0xC1, 0x86, 0xD9, 0x1C,
    0xAE, 0xFE, 0x13, 0x09, 0x85, 0x13, 0x92, 0x70, 0xB4, 0x13, 0x0C, 0x93, 0xBC, 0x43, 0x79, 0x44,
    0xF4, 0xFD, 0x44, 0x52, 0xE2, 0xD7, 0x4D, 0xD3, 0x64, 0xF2, 0xE2, 0x1E, 0x71, 0xF5, 0x4B, 0xFF,
    0x5C, 0xAE, 0x82, 0xAB, 0x9C, 0x9D, 0xF6, 0x9E, 0xE8, 0x6D, 0x2B, 0xC5, 0x22, 0x36, 0x3A, 0x0D,
    0xAB, 0xC5, 0x21, 0x97, 0x9B, 0x0D, 0xEA, 0xDA, 0x1D, 0xBF, 0x9A, 0x42, 0xD5, 0xC4, 0x48, 0x4E,
    0x0A, 0xBC, 0xD0, 0x6B, 0xFA, 0x53, 0xDD, 0xEF, 0x3C, 0x1B, 0x20, 0xEE, 0x3F, 0xD5, 0x9D, 0x7C,
    0x25, 0xE4, 0x1D, 0x2B, 0x66, 0x9E, 0x1E, 0xF1, 0x6E, 0x6F, 0x52, 0xC3, 0x16, 0x4D, 0xF4, 0xFB,
    0x79, 0x30, 0xE9, 0xE4, 0xE5, 0x88, 0x57, 0xB6, 0xAC, 0x7D, 0x5F, 0x42, 0xD6, 0x9F, 0x6D, 0x18,
    0x77, 0x63, 0xCF, 0x1D, 0x55, 0x03, 0x40, 0x04, 0x87, 0xF5, 0x5B, 0xA5, 0x7E, 0x31, 0xCC, 0x7A,
    0x71, 0x35, 0xC8, 0x86, 0xEF, 0xB4, 0x31, 0x8A, 0xED, 0x6A, 0x1E, 0x01, 0x2D, 0x9E, 0x68, 0x32,
    0xA9, 0x07, 0x60, 0x0A, 0x91, 0x81, 0x30, 0xC4, 0x6D, 0xC7, 0x78, 0xF9, 0x71, 0xAD, 0x00, 0x38,
    0x09, 0x29, 0x99, 0xA3, 0x33, 0xCB, 0x8B, 0x7A, 0x1A, 0x1D, 0xB9, 0x3D, 0x71, 0x40, 0x00, 0x3C,
    0x2A, 0x4E, 0xCE, 0xA9, 0xF9, 0x8D, 0x0A, 0xCC, 0x0A, 0x82, 0x91, 0xCD, 0xCE, 0xC9, 0x7D, 0xCF,
    0x8E, 0xC9, 0xB5, 0x5A, 0x7F, 0x88, 0xA4, 0x6B, 0x4D, 0xB5, 0xA8, 0x51, 0xF4, 0x41, 0x82, 0xE1,
    0xC6, 0x8A, 0x00, 0x7E, 0x5E, 0x65, 0x5F, 0x6A, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
   512,
   
   2
};

#endif




error_t tlsSelectFfdheGroup(TlsContext *context,
   const TlsSupportedGroupList *groupList)
{
   error_t error;
   uint_t i;
   uint_t j;
   uint_t n;
   uint16_t namedGroup;
   bool_t ffdheGroupFound;

   
   error = ERROR_HANDSHAKE_FAILED;

   
   ffdheGroupFound = FALSE;

   
   context->namedGroup = TLS_GROUP_NONE;

   
   if(groupList != NULL)
   {
      
      n = ntohs(groupList->length) / sizeof(uint16_t);

      
      if(context->numSupportedGroups > 0)
      {
         
         for(i = 0; i < context->numSupportedGroups; i++)
         {
            
            for(j = 0; j < n; j++)
            {
               
               namedGroup = ntohs(groupList->value[j]);

               
               
               if(namedGroup >= TLS_GROUP_FFDHE2048 &&
                  namedGroup <= TLS_GROUP_FFDHE_MAX)
               {
                  
                  ffdheGroupFound = TRUE;
               }

               
               
               if(context->supportedGroups[i] == namedGroup)
               {
                  
                  if(tlsGetFfdheGroup(context, namedGroup) != NULL)
                  {
                     
                     if(context->namedGroup == TLS_GROUP_NONE)
                     {
                        context->namedGroup = namedGroup;
                     }
                  }
               }
            }
         }
      }
      else
      {
         
         
         for(j = 0; j < n; j++)
         {
            
            namedGroup = ntohs(groupList->value[j]);

            
            
            if(namedGroup >= TLS_GROUP_FFDHE2048 &&
               namedGroup <= TLS_GROUP_FFDHE_MAX)
            {
               
               ffdheGroupFound = TRUE;
            }

            
            if(tlsGetFfdheGroup(context, namedGroup) != NULL)
            {
               
               if(context->namedGroup == TLS_GROUP_NONE)
               {
                  context->namedGroup = namedGroup;
               }
            }
         }
      }
   }

   
   
   
   if(!ffdheGroupFound)
   {
      
      if(tlsGetFfdheGroup(context, TLS_GROUP_FFDHE2048) != NULL)
      {
         
         context->namedGroup = TLS_GROUP_FFDHE2048;
      }
      else if(tlsGetFfdheGroup(context, TLS_GROUP_FFDHE3072) != NULL)
      {
         
         context->namedGroup = TLS_GROUP_FFDHE3072;
      }
      else if(tlsGetFfdheGroup(context, TLS_GROUP_FFDHE4096) != NULL)
      {
         
         context->namedGroup = TLS_GROUP_FFDHE4096;
      }
      else
      {
         
         context->namedGroup = TLS_GROUP_NONE;
      }
   }

   
   if(context->namedGroup != TLS_GROUP_NONE)
   {
      error = NO_ERROR;
   }

   
   return error;
}




const TlsFfdheGroup *tlsGetFfdheGroup(TlsContext *context, uint16_t namedGroup)
{
   uint_t i;
   const TlsFfdheGroup *ffdheGroup;

   
   switch(namedGroup)
   {
#if (TLS_FFDHE2048_SUPPORT == ENABLED)
   
   case TLS_GROUP_FFDHE2048:
      ffdheGroup = &ffdhe2048Group;
      break;
#endif
#if (TLS_FFDHE3072_SUPPORT == ENABLED)
   
   case TLS_GROUP_FFDHE3072:
      ffdheGroup = &ffdhe3072Group;
      break;
#endif
#if (TLS_FFDHE4096_SUPPORT == ENABLED)
   
   case TLS_GROUP_FFDHE4096:
      ffdheGroup = &ffdhe4096Group;
      break;
#endif
   
   default:
      ffdheGroup = NULL;
      break;
   }

   
   if(context->numSupportedGroups > 0)
   {
      
      for(i = 0; i < context->numSupportedGroups; i++)
      {
         
         if(context->supportedGroups[i] == namedGroup)
            break;
      }

      
      if(i >= context->numSupportedGroups)
         ffdheGroup = NULL;
   }

   
   return ffdheGroup;
}




error_t tlsLoadFfdheParameters(DhParameters *params,
   const TlsFfdheGroup *ffdheGroup)
{
   error_t error;

   
   if(ffdheGroup != NULL)
   {
      
      error = mpiImport(&params->p, ffdheGroup->p, ffdheGroup->pLen,
         MPI_FORMAT_BIG_ENDIAN);

      
      if(!error)
      {
         
         error = mpiSetValue(&params->g, ffdheGroup->g);
      }
   }
   else
   {
      
      error = ERROR_FAILURE;
   }

   
   return error;
}

#endif
",64,1869,8517
"#define TRACE_LEVEL TLS_TRACE_LEVEL



#include ""tls.h""
#include ""tls_server_misc.h""
#include ""tls_transcript_hash.h""
#include ""tls_ffdhe.h""
#include ""tls_misc.h""
#include ""tls13_server_extensions.h""
#include ""tls13_server_misc.h""
#include ""debug.h""


#if (TLS_SUPPORT == ENABLED && TLS_SERVER_SUPPORT == ENABLED && \
   TLS_MAX_VERSION >= TLS_VERSION_1_3)




error_t tls13NegotiateCipherSuite(TlsContext *context, const void *clientHello,
   size_t clientHelloLen, const TlsCipherSuites *cipherSuites,
   TlsHelloExtensions *extensions)
{
   error_t error;

   
   
   context->keyExchMethod = TLS_KEY_EXCH_NONE;

   
   
   
   error = tls13ParseClientPreSharedKeyExtension(context, clientHello,
      clientHelloLen, extensions->identityList, extensions->binderList);
   
   if(error)
      return error;

   
   if(context->selectedIdentity >= 0)
   {
      
      error = tlsNegotiateCipherSuite(context, context->cipherSuite.prfHashAlgo,
         cipherSuites, extensions);

      
      if(!error)
      {
         
         context->keyExchMethod = TLS13_KEY_EXCH_PSK;
      }
      else
      {
         
         context->keyExchMethod = TLS_KEY_EXCH_NONE;
         context->selectedIdentity = -1;
      }
   }

   
   if(context->keyExchMethod == TLS_KEY_EXCH_NONE)
   {
      
      error = tlsNegotiateCipherSuite(context, NULL, cipherSuites, extensions);
      
      if(error)
         return ERROR_HANDSHAKE_FAILED;
   }

   
   
   
   if(context->state != TLS_STATE_CLIENT_HELLO_2)
   {
      
      error = tlsInitTranscriptHash(context);
      
      if(error)
         return error;
   }

   
   
   error = tls13ParseClientEarlyDataExtension(context,
      extensions->earlyDataIndication);
   
   if(error)
      return error;

   
   error = tls13ParseClientKeyShareExtension(context, extensions->keyShareList);
   
   if(error)
      return error;

   
   if(extensions->keyShareList != NULL && context->namedGroup == TLS_GROUP_NONE)
   {
      
      error = tls13SelectGroup(context, extensions->supportedGroupList);
      
      if(error)
         return error;

      
      context->state = TLS_STATE_HELLO_RETRY_REQUEST;
   }
   else
   {
      
      if(context->keyExchMethod == TLS13_KEY_EXCH_DHE ||
         context->keyExchMethod == TLS13_KEY_EXCH_ECDHE)
      {
         
      }
      else if(context->keyExchMethod == TLS13_KEY_EXCH_PSK ||
         context->keyExchMethod == TLS13_KEY_EXCH_PSK_DHE ||
         context->keyExchMethod == TLS13_KEY_EXCH_PSK_ECDHE)
      {
         
         
         error = tls13ParsePskKeModesExtension(context,
            extensions->pskKeModeList);
         
         if(error)
            return error;

         
         
         error = tls13VerifyPskBinder(context, clientHello, clientHelloLen,
            extensions->identityList, extensions->binderList,
            context->selectedIdentity);
         
         if(error)
            return error;
      }
      else
      {
         
         
         return ERROR_HANDSHAKE_FAILED;
      }
   }

   
   return NO_ERROR;
}




error_t tls13SelectGroup(TlsContext *context,
   const TlsSupportedGroupList *groupList)
{
   error_t error;

   
   error = ERROR_HANDSHAKE_FAILED;

   
   context->namedGroup = TLS_GROUP_NONE;

#if (TLS13_DHE_KE_SUPPORT == ENABLED || TLS13_ECDHE_KE_SUPPORT == ENABLED || \
   TLS13_PSK_DHE_KE_SUPPORT == ENABLED || TLS13_PSK_ECDHE_KE_SUPPORT == ENABLED)
   
   if(groupList != NULL)
   {
      uint_t i;
      uint_t j;
      uint_t n;
      uint16_t namedGroup;

      
      n = ntohs(groupList->length) / sizeof(uint16_t);

      
      if(context->numSupportedGroups > 0)
      {
         
         for(i = 0; i < context->numSupportedGroups && error; i++)
         {
            
            for(j = 0; j < n && error; j++)
            {
               
               namedGroup = ntohs(groupList->value[j]);

               
               
               if(context->supportedGroups[i] == namedGroup)
               {
                  
                  if(tls13IsGroupSupported(context, namedGroup))
                  {
                     
                     context->namedGroup = namedGroup;
                     error = NO_ERROR;
                  }
               }
            }
         }
      }
      else
      {
         
         
         for(j = 0; j < n && error; j++)
         {
            
            namedGroup = ntohs(groupList->value[j]);

            
            if(tls13IsGroupSupported(context, namedGroup))
            {
               
               context->namedGroup = namedGroup;
               error = NO_ERROR;
            }
         }
      }
   }
#endif

   
   return error;
}




error_t tls13VerifyPskBinder(TlsContext *context, const void *clientHello,
   size_t clientHelloLen, const Tls13PskIdentityList *identityList,
   const Tls13PskBinderList *binderList, int_t selectedIdentity)
{
#if (TLS13_PSK_KE_SUPPORT == ENABLED || TLS13_PSK_DHE_KE_SUPPORT == ENABLED || \
   TLS13_PSK_ECDHE_KE_SUPPORT == ENABLED)
   error_t error;
   int_t i;
   size_t n;
   const uint8_t *p;
   const Tls13PskIdentity *identity;
   const Tls13PskBinder *binder;
   uint8_t calculatedBinder[TLS_MAX_HKDF_DIGEST_SIZE];

   
   identity = NULL;
   binder = NULL;

   
   if(identityList == NULL || binderList == NULL)
      return ERROR_FAILURE;

   
   if(selectedIdentity < 0)
      return ERROR_FAILURE;

   
   
   p = identityList->value;
   n = ntohs(identityList->length);

   
   for(i = 0; i <= selectedIdentity && n > 0; i++)
   {
      
      identity = (Tls13PskIdentity *) p;

      
      if(n < sizeof(TlsPskIdentity))
         return ERROR_DECODING_FAILED;
      if(n < (sizeof(TlsPskIdentity) + ntohs(identity->length)))
         return ERROR_DECODING_FAILED;

      
      p += sizeof(TlsPskIdentity) + ntohs(identity->length);
      n -= sizeof(TlsPskIdentity) + ntohs(identity->length);

      
      if(n < sizeof(uint32_t))
         return ERROR_DECODING_FAILED;

      
      p += sizeof(uint32_t);
      n -= sizeof(uint32_t);
   }

   
   if(selectedIdentity >= i)
      return ERROR_FAILURE;

   
   
   p = binderList->value;
   n = ntohs(binderList->length);

   
   for(i = 0; i <= selectedIdentity && n > 0; i++)
   {
      
      binder = (Tls13PskBinder *) p;

      
      if(n < sizeof(Tls13PskBinder))
         return ERROR_DECODING_FAILED;
      if(n < (sizeof(Tls13PskBinder) + binder->length))
         return ERROR_DECODING_FAILED;

      
      p += sizeof(Tls13PskBinder) + binder->length;
      n -= sizeof(Tls13PskBinder) + binder->length;
   }

   
   if(selectedIdentity >= i)
      return ERROR_FAILURE;

   
   if(binder->length > TLS_MAX_HKDF_DIGEST_SIZE)
      return ERROR_DECRYPTION_FAILED;

   
   
   n = (uint8_t *) binderList - (uint8_t *) clientHello;

   
   error = tls13ComputePskBinder(context, clientHello, clientHelloLen,
      n, identity, calculatedBinder, binder->length);
   
   if(error)
      return ERROR_DECRYPTION_FAILED;

   
   TRACE_DEBUG(""PSK binder:\r\n"");
   TRACE_DEBUG_ARRAY(""  "", binder->value, binder->length);
   TRACE_DEBUG(""Calculated PSK binder:\r\n"");
   TRACE_DEBUG_ARRAY(""  "", calculatedBinder, binder->length);

   
   
   if(osMemcmp(calculatedBinder, binder->value, binder->length))
   {
      
      return ERROR_DECRYPTION_FAILED;
   }

   
   return NO_ERROR;
#else
   
   return ERROR_NOT_IMPLEMENTED;
#endif
}




error_t tls13ProcessEarlyData(TlsContext *context, const uint8_t *data,
   size_t length)
{
   
   if(context->version != TLS_VERSION_1_3)
      return ERROR_UNEXPECTED_MESSAGE;

   
   if(context->state != TLS_STATE_CLIENT_HELLO_2)
      return ERROR_UNEXPECTED_MESSAGE;

   
   
   if(!context->earlyDataExtReceived)
      return ERROR_UNEXPECTED_MESSAGE;

   
   context->earlyDataLen += length;

   
   
   if(context->earlyDataLen > context->maxEarlyDataSize)
      return ERROR_BAD_RECORD_MAC;

   
   TRACE_INFO(""Discarding early data (%"" PRIuSIZE "" bytes)...\r\n"", length);

   
   return NO_ERROR;
}

#endif
",64,1870,2924
"#define TRACE_LEVEL ACME_DNS_TRACE_LEVEL


#include ""dns_api/acme_dns_client.h""
#include ""dns_api/acme_dns_client_misc.h""
#include ""jansson.h""
#include ""debug.h""


#if (ACME_DNS_CLIENT_SUPPORT == ENABLED)




error_t acmeDnsClientFormatRegisterRequest(AcmeDnsClientContext *context)
{
   bool_t defaultPort;

   
   httpClientCreateRequest(&context->httpClientContext);
   httpClientSetMethod(&context->httpClientContext, ""POST"");
   httpClientSetUri(&context->httpClientContext, ""/register"");

#if (ACME_DNS_CLIENT_TLS_SUPPORT == ENABLED)
   
   if(context->tlsInitCallback != NULL)
   {
      
      defaultPort = (context->serverPort == HTTPS_PORT) ? TRUE : FALSE;
   }
   else
#endif
   
   {
      
      defaultPort = (context->serverPort == HTTP_PORT) ? TRUE : FALSE;
   }

   
   
   if(defaultPort)
   {
      
      
      httpClientAddHeaderField(&context->httpClientContext, ""Host"",
         context->serverName);
   }
   else
   {
      
      httpClientFormatHeaderField(&context->httpClientContext,
         ""Host"", ""%s:%"" PRIu16, context->serverName, context->serverPort);
   }

   
   httpClientAddHeaderField(&context->httpClientContext, ""User-Agent"",
      ""Mozilla/5.0"");

   httpClientAddHeaderField(&context->httpClientContext, ""Content-Type"",
      ""application/json"");

   
   httpClientSetContentLength(&context->httpClientContext, 0);

   
   return NO_ERROR;
}




error_t acmeDnsClientParseRegisterResponse(AcmeDnsClientContext *context)
{
   error_t error;
   const char_t *username;
   const char_t *password;
   const char_t *subDomain;
   const char_t *fullDomain;
   json_t *rootObj;
   json_t *usernameObj;
   json_t *passwordObj;
   json_t *subDomainObj;
   json_t *fullDomainObj;

   
   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))
      return ERROR_UNEXPECTED_STATUS;

   
   if(context->bufferLen >= ACME_DNS_CLIENT_BUFFER_SIZE)
      return ERROR_RESPONSE_TOO_LARGE;

   
   error = ERROR_INVALID_RESPONSE;

   
   context->username[0] = '\0';
   context->password[0] = '\0';
   context->subDomain[0] = '\0';
   context->fullDomain[0] = '\0';

   
   rootObj = json_loads(context->buffer, 0, NULL);

   
   if(json_is_object(rootObj))
   {
      
      
      usernameObj = json_object_get(rootObj, ""username"");
      passwordObj = json_object_get(rootObj, ""password"");
      subDomainObj = json_object_get(rootObj, ""subdomain"");
      fullDomainObj = json_object_get(rootObj, ""fulldomain"");

      
      if(json_is_string(usernameObj) &&
         json_is_string(passwordObj) &&
         json_is_string(subDomainObj) &&
         json_is_string(fullDomainObj))
      {
         
         username = json_string_value(usernameObj);
         password = json_string_value(passwordObj);
         subDomain = json_string_value(subDomainObj);
         fullDomain = json_string_value(fullDomainObj);

         
         if(osStrlen(username) <= ACME_DNS_CLIENT_MAX_USERNAME_LEN &&
            osStrlen(password) <= ACME_DNS_CLIENT_MAX_PASSWORD_LEN &&
            osStrlen(subDomain) <= ACME_DNS_CLIENT_MAX_SUB_DOMAIN_LEN &&
            osStrlen(fullDomain) <= ACME_DNS_CLIENT_MAX_FULL_DOMAIN_LEN)
         {
            
            osStrcpy(context->username, username);
            osStrcpy(context->password, password);
            osStrcpy(context->subDomain, subDomain);
            osStrcpy(context->fullDomain, fullDomain);

            
            error = NO_ERROR;
         }
      }
   }

   
   json_decref(rootObj);

   
   return error;
}




error_t acmeDnsClientFormatUpdateRequest(AcmeDnsClientContext *context,
   const char_t *txt)
{
   bool_t defaultPort;

   
   if(osStrlen(txt) != ACME_DNS_TXT_RECORD_LEN)
      return ERROR_INVALID_LENGTH;

   
   httpClientCreateRequest(&context->httpClientContext);
   httpClientSetMethod(&context->httpClientContext, ""POST"");
   httpClientSetUri(&context->httpClientContext, ""/update"");

#if (ACME_DNS_CLIENT_TLS_SUPPORT == ENABLED)
   
   if(context->tlsInitCallback != NULL)
   {
      
      defaultPort = (context->serverPort == HTTPS_PORT) ? TRUE : FALSE;
   }
   else
#endif
   
   {
      
      defaultPort = (context->serverPort == HTTP_PORT) ? TRUE : FALSE;
   }

   
   
   if(defaultPort)
   {
      
      
      httpClientAddHeaderField(&context->httpClientContext, ""Host"",
         context->serverName);
   }
   else
   {
      
      httpClientFormatHeaderField(&context->httpClientContext,
         ""Host"", ""%s:%"" PRIu16, context->serverName, context->serverPort);
   }

   
   httpClientAddHeaderField(&context->httpClientContext, ""User-Agent"",
      ""Mozilla/5.0"");

   httpClientAddHeaderField(&context->httpClientContext, ""X-Api-User"",
      context->username);

   httpClientAddHeaderField(&context->httpClientContext, ""X-Api-Key"",
      context->password);

   httpClientAddHeaderField(&context->httpClientContext, ""Content-Type"",
      ""application/json"");

   
   context->bufferLen = osSprintf(context->buffer,
      ""{\""subdomain\"":\""%s\"",\""txt\"":\""%s\""}"", context->subDomain, txt);

   
   httpClientSetContentLength(&context->httpClientContext, context->bufferLen);

   
   return NO_ERROR;
}




error_t acmeDnsClientParseUpdateResponse(AcmeDnsClientContext *context)
{
   
   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))
      return ERROR_UNEXPECTED_STATUS;

   
   if(context->bufferLen >= ACME_DNS_CLIENT_BUFFER_SIZE)
      return ERROR_RESPONSE_TOO_LARGE;

   
   return NO_ERROR;
}

#endif
",64,1871,1849
"#define TRACE_LEVEL SHELL_TRACE_LEVEL


#include ""ssh/ssh.h""
#include ""ssh/ssh_connection.h""
#include ""ssh/ssh_request.h""
#include ""ssh/ssh_misc.h""
#include ""shell/shell_client.h""
#include ""shell/shell_client_misc.h""
#include ""debug.h""


#if (SHELL_CLIENT_SUPPORT == ENABLED)




void shellClientChangeState(ShellClientContext *context,
   ShellClientState newState)
{
   
   context->state = newState;

   
   context->timestamp = osGetSystemTime();
}




error_t shellClientChannelRequestCallback(SshChannel *channel,
   const SshString *type, const uint8_t *data, size_t length,
   void *param)
{
   error_t error;
   ShellClientContext *context;

   
   TRACE_INFO(""Shell client: SSH channel request callback...\r\n"");

   
   context = (ShellClientContext *) param;

   
   if(sshCompareString(type, ""exit-status""))
   {
      SshExitStatusReqParams requestParams;

      
      
      
      error = sshParseExitStatusReqParams(data, length, &requestParams);

      
      if(!error)
      {
         
         if(channel == &context->sshChannel)
         {
            
            context->exitStatus = requestParams.exitStatus;
         }
         else
         {
            
            error = ERROR_UNKNOWN_REQUEST;
         }
      }
   }
   else
   {
      
      error = ERROR_UNKNOWN_REQUEST;
   }

   
   return error;
}




error_t shellClientOpenConnection(ShellClientContext *context)
{
   error_t error;
   Socket *socket;
   SshConnection *connection;

   
   error = sshInit(&context->sshContext, &context->sshConnection, 1,
      &context->sshChannel, 1);
   
   if(error)
      return error;

   
   error = sshSetOperationMode(&context->sshContext, SSH_OPERATION_MODE_CLIENT);
   
   if(error)
      return error;

   
   error = sshRegisterChannelRequestCallback(&context->sshContext,
      shellClientChannelRequestCallback, context);
   
   if(error)
      return error;

   
   if(context->sshInitCallback != NULL)
   {
      
      error = context->sshInitCallback(context, &context->sshContext);
      
      if(error)
         return error;
   }

   
   socket = socketOpen(SOCKET_TYPE_STREAM, SOCKET_IP_PROTO_TCP);

   
   if(socket != NULL)
   {
      
      socketBindToInterface(socket, context->interface);
      
      socketSetTimeout(socket, context->timeout);

      
      connection = sshOpenConnection(&context->sshContext, socket);

      
      if(connection == NULL)
      {
         
         socketClose(socket);
         
         error = ERROR_OPEN_FAILED;
      }
   }
   else
   {
      
      error = ERROR_OPEN_FAILED;
   }

   
   return error;
}




error_t shellClientEstablishConnection(ShellClientContext *context)
{
   error_t error;

   
   if(context->sshConnection.state < SSH_CONN_STATE_OPEN)
   {
      
      error = shellClientProcessEvents(context);
   }
   else if(context->sshConnection.state == SSH_CONN_STATE_OPEN)
   {
      
      shellClientChangeState(context, SHELL_CLIENT_STATE_CONNECTED);
      
      error = NO_ERROR;
   }
   else
   {
      
      error = ERROR_WRONG_STATE;
   }

   
   return error;
}




void shellClientCloseConnection(ShellClientContext *context)
{
   
   if(context->sshConnection.state != SSH_CONN_STATE_CLOSED)
   {
      
      sshCloseConnection(&context->sshConnection);
   }

   
   sshDeinit(&context->sshContext);
}




error_t shellClientProcessEvents(ShellClientContext *context)
{
   error_t error;
   uint_t i;
   SshContext *sshContext;
   SshConnection *connection;

   
   sshContext = &context->sshContext;

   
   osMemset(sshContext->eventDesc, 0, sizeof(sshContext->eventDesc));

   
   for(i = 0; i < sshContext->numConnections; i++)
   {
      
      connection = &sshContext->connections[i];

      
      if(connection->state != SSH_CONN_STATE_CLOSED)
      {
         
         sshRegisterConnectionEvents(sshContext, connection, &sshContext->eventDesc[i]);
      }
   }

   
   error = socketPoll(sshContext->eventDesc, sshContext->numConnections,
      &sshContext->event, context->timeout);

   
   if(!error)
   {
      
      for(i = 0; i < sshContext->numConnections && !error; i++)
      {
         
         connection = &sshContext->connections[i];

         
         if(connection->state != SSH_CONN_STATE_CLOSED)
         {
            
            if(sshContext->eventDesc[i].eventFlags != 0)
            {
               
               error = sshProcessConnectionEvents(sshContext, connection);
            }
         }
      }
   }

   
   if(error == ERROR_WOULD_BLOCK || error == ERROR_TIMEOUT)
   {
      
      error = shellClientCheckTimeout(context);
   }

   
   return error;
}




error_t shellClientCheckTimeout(ShellClientContext *context)
{
   error_t error;
   systime_t time;

   
   time = osGetSystemTime();

   
   if(timeCompare(time, context->timestamp + context->timeout) >= 0)
   {
      
      error = ERROR_TIMEOUT;
   }
   else
   {
#if (NET_RTOS_SUPPORT == ENABLED)
      
      error = NO_ERROR;
#else
      
      error = ERROR_WOULD_BLOCK;
#endif
   }

   
   return error;
}

#endif
",64,1872,1669
"#define TRACE_LEVEL SSH_TRACE_LEVEL


#include ""ssh/ssh.h""
#include ""ssh/ssh_modp_groups.h""
#include ""ssh/ssh_misc.h""
#include ""debug.h""


#if (SSH_DH_SUPPORT == ENABLED)




const SshDhGroup sshDhGroup1 =
{
   
   ""diffie-hellman-group1"",
   
   {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,
    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1, 0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,
    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,
    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45, 0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,
    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,
    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE6, 0x53, 0x81, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
   128,
   
   2
};




const SshDhGroup sshDhGroup14 =
{
   
   ""diffie-hellman-group14"",
   
   {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,
    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1, 0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,
    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,
    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45, 0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,
    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,
    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D, 0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,
    0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A, 0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,
    0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96, 0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,
    0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D, 0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,
    0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C, 0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,
    0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03, 0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,
    0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9, 0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,
    0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5, 0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,
    0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAC, 0xAA, 0x68, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
   256,
   
   2
};




const SshDhGroup sshDhGroup15 =
{
   
   ""diffie-hellman-group15"",
   
   {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,
    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1, 0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,
    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,
    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45, 0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,
    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,
    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D, 0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,
    0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A, 0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,
    0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96, 0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,
    0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D, 0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,
    0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C, 0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,
    0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03, 0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,
    0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9, 0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,
    0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5, 0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,
    0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAA, 0xC4, 0x2D, 0xAD, 0x33, 0x17, 0x0D, 0x04, 0x50, 0x7A, 0x33,
    0xA8, 0x55, 0x21, 0xAB, 0xDF, 0x1C, 0xBA, 0x64, 0xEC, 0xFB, 0x85, 0x04, 0x58, 0xDB, 0xEF, 0x0A,
    0x8A, 0xEA, 0x71, 0x57, 0x5D, 0x06, 0x0C, 0x7D, 0xB3, 0x97, 0x0F, 0x85, 0xA6, 0xE1, 0xE4, 0xC7,
    0xAB, 0xF5, 0xAE, 0x8C, 0xDB, 0x09, 0x33, 0xD7, 0x1E, 0x8C, 0x94, 0xE0, 0x4A, 0x25, 0x61, 0x9D,
    0xCE, 0xE3, 0xD2, 0x26, 0x1A, 0xD2, 0xEE, 0x6B, 0xF1, 0x2F, 0xFA, 0x06, 0xD9, 0x8A, 0x08, 0x64,
    0xD8, 0x76, 0x02, 0x73, 0x3E, 0xC8, 0x6A, 0x64, 0x52, 0x1F, 0x2B, 0x18, 0x17, 0x7B, 0x20, 0x0C,
    0xBB, 0xE1, 0x17, 0x57, 0x7A, 0x61, 0x5D, 0x6C, 0x77, 0x09, 0x88, 0xC0, 0xBA, 0xD9, 0x46, 0xE2,
    0x08, 0xE2, 0x4F, 0xA0, 0x74, 0xE5, 0xAB, 0x31, 0x43, 0xDB, 0x5B, 0xFC, 0xE0, 0xFD, 0x10, 0x8E,
    0x4B, 0x82, 0xD1, 0x20, 0xA9, 0x3A, 0xD2, 0xCA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
   384,
   
   2
};




const SshDhGroup sshDhGroup16 =
{
   
   ""diffie-hellman-group16"",
   
   {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,
    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1, 0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,
    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,
    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45, 0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,
    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,
    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D, 0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,
    0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A, 0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,
    0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96, 0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,
    0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D, 0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,
    0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C, 0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,
    0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03, 0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,
    0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9, 0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,
    0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5, 0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,
    0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAA, 0xC4, 0x2D, 0xAD, 0x33, 0x17, 0x0D, 0x04, 0x50, 0x7A, 0x33,
    0xA8, 0x55, 0x21, 0xAB, 0xDF, 0x1C, 0xBA, 0x64, 0xEC, 0xFB, 0x85, 0x04, 0x58, 0xDB, 0xEF, 0x0A,
    0x8A, 0xEA, 0x71, 0x57, 0x5D, 0x06, 0x0C, 0x7D, 0xB3, 0x97, 0x0F, 0x85, 0xA6, 0xE1, 0xE4, 0xC7,
    0xAB, 0xF5, 0xAE, 0x8C, 0xDB, 0x09, 0x33, 0xD7, 0x1E, 0x8C, 0x94, 0xE0, 0x4A, 0x25, 0x61, 0x9D,
    0xCE, 0xE3, 0xD2, 0x26, 0x1A, 0xD2, 0xEE, 0x6B, 0xF1, 0x2F, 0xFA, 0x06, 0xD9, 0x8A, 0x08, 0x64,
    0xD8, 0x76, 0x02, 0x73, 0x3E, 0xC8, 0x6A, 0x64, 0x52, 0x1F, 0x2B, 0x18, 0x17, 0x7B, 0x20, 0x0C,
    0xBB, 0xE1, 0x17, 0x57, 0x7A, 0x61, 0x5D, 0x6C, 0x77, 0x09, 0x88, 0xC0, 0xBA, 0xD9, 0x46, 0xE2,
    0x08, 0xE2, 0x4F, 0xA0, 0x74, 0xE5, 0xAB, 0x31, 0x43, 0xDB, 0x5B, 0xFC, 0xE0, 0xFD, 0x10, 0x8E,
    0x4B, 0x82, 0xD1, 0x20, 0xA9, 0x21, 0x08, 0x01, 0x1A, 0x72, 0x3C, 0x12, 0xA7, 0x87, 0xE6, 0xD7,
    0x88, 0x71, 0x9A, 0x10, 0xBD, 0xBA, 0x5B, 0x26, 0x99, 0xC3, 0x27, 0x18, 0x6A, 0xF4, 0xE2, 0x3C,
    0x1A, 0x94, 0x68, 0x34, 0xB6, 0x15, 0x0B, 0xDA, 0x25, 0x83, 0xE9, 0xCA, 0x2A, 0xD4, 0x4C, 0xE8,
    0xDB, 0xBB, 0xC2, 0xDB, 0x04, 0xDE, 0x8E, 0xF9, 0x2E, 0x8E, 0xFC, 0x14, 0x1F, 0xBE, 0xCA, 0xA6,
    0x28, 0x7C, 0x59, 0x47, 0x4E, 0x6B, 0xC0, 0x5D, 0x99, 0xB2, 0x96, 0x4F, 0xA0, 0x90, 0xC3, 0xA2,
    0x23, 0x3B, 0xA1, 0x86, 0x51, 0x5B, 0xE7, 0xED, 0x1F, 0x61, 0x29, 0x70, 0xCE, 0xE2, 0xD7, 0xAF,
    0xB8, 0x1B, 0xDD, 0x76, 0x21, 0x70, 0x48, 0x1C, 0xD0, 0x06, 0x91, 0x27, 0xD5, 0xB0, 0x5A, 0xA9,
    0x93, 0xB4, 0xEA, 0x98, 0x8D, 0x8F, 0xDD, 0xC1, 0x86, 0xFF, 0xB7, 0xDC, 0x90, 0xA6, 0xC0, 0x8F,
    0x4D, 0xF4, 0x35, 0xC9, 0x34, 0x06, 0x31, 0x99, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
   512,
   
   2
};




const SshDhGroup *sshGetDhGroup(const char_t *kexAlgo)
{
   const SshDhGroup *dhGroup;

#if (SSH_MAX_DH_MODULUS_SIZE >= 1024 && SSH_MIN_DH_MODULUS_SIZE <= 1024)
   
   if(sshCompareAlgo(kexAlgo, ""diffie-hellman-group1-sha1""))
   {
      dhGroup = &sshDhGroup1;
   }
   else
#endif
#if (SSH_MAX_DH_MODULUS_SIZE >= 2048 && SSH_MIN_DH_MODULUS_SIZE <= 2048)
   
   if(sshCompareAlgo(kexAlgo, ""diffie-hellman-group14-sha1"") ||
      sshCompareAlgo(kexAlgo, ""diffie-hellman-group14-sha256""))
   {
      dhGroup = &sshDhGroup14;
   }
   else
#endif
#if (SSH_MAX_DH_MODULUS_SIZE >= 3072 && SSH_MIN_DH_MODULUS_SIZE <= 3072)
   
   if(sshCompareAlgo(kexAlgo, ""diffie-hellman-group15-sha512""))
   {
      dhGroup = &sshDhGroup15;
   }
   else
#endif
#if (SSH_MAX_DH_MODULUS_SIZE >= 4096 && SSH_MIN_DH_MODULUS_SIZE <= 4096)
   
   if(sshCompareAlgo(kexAlgo, ""diffie-hellman-group16-sha512""))
   {
      dhGroup = &sshDhGroup16;
   }
   else
#endif
   
   {
      dhGroup = NULL;
   }

   
   return dhGroup;
}

#endif
",64,1873,8337
"#define TRACE_LEVEL TLS_TRACE_LEVEL



#include ""tls.h""
#include ""tls_ticket.h""
#include ""debug.h""


#if (TLS_SUPPORT == ENABLED && TLS_TICKET_SUPPORT == ENABLED)




error_t tlsInitTicketContext(TlsTicketContext *ticketContext)
{
   
   if(ticketContext == NULL)
      return ERROR_INVALID_PARAMETER;

   
   osMemset(ticketContext, 0, sizeof(TlsTicketContext));

   
   if(!osCreateMutex(&ticketContext->mutex))
   {
      
      return ERROR_OUT_OF_RESOURCES;
   }

   
   return NO_ERROR;
}




error_t tlsEncryptTicket(TlsContext *context, const uint8_t *plaintext,
   size_t plaintextLen, uint8_t *ciphertext, size_t *ciphertextLen, void *param)
{
   error_t error;
   uint8_t *iv;
   uint8_t *data;
   uint8_t *tag;
   systime_t time;
   TlsTicketContext *ticketContext;
   TlsTicketEncryptionState *state;

   
   if(context == NULL || param == NULL)
      return ERROR_INVALID_PARAMETER;
   if(plaintext == NULL || ciphertext == NULL || ciphertextLen == NULL)
      return ERROR_INVALID_PARAMETER;

   
   error = NO_ERROR;

   
   iv = NULL;
   data = NULL;
   tag = NULL;

   
   ticketContext = (TlsTicketContext *) param;

   
   osAcquireMutex(&ticketContext->mutex);

   
   tlsCheckTicketKeyLifetime(&ticketContext->encryptionState);
   tlsCheckTicketKeyLifetime(&ticketContext->prevEncryptionState);

   
   state = &ticketContext->encryptionState;

   
   if(state->valid)
   {
      
      time = osGetSystemTime();

      
      if((time - state->timestamp) >= TLS_TICKET_LIFETIME)
      {
         
         ticketContext->prevEncryptionState = ticketContext->encryptionState;
         ticketContext->encryptionState.valid = FALSE;
      }
   }

   
   if(!state->valid)
   {
      
      error = tlsGenerateTicketKeys(ticketContext, context->prngAlgo,
         context->prngContext);
   }

   
   if(!error)
   {
      
      iv = ciphertext + TLS_TICKET_KEY_NAME_SIZE;
      
      data = iv + TLS_TICKET_IV_SIZE;
      
      tag = data + plaintextLen;

      
      osMemmove(data, plaintext, plaintextLen);
      
      osMemcpy(ciphertext, state->keyName, TLS_TICKET_KEY_NAME_SIZE);

      
      error = context->prngAlgo->read(context->prngContext, iv,
         TLS_TICKET_IV_SIZE);
   }

   
   if(!error)
   {
      
      error = aesInit(&ticketContext->aesContext, state->key,
         TLS_TICKET_KEY_SIZE);
   }

   
   if(!error)
   {
      
      error = gcmInit(&ticketContext->gcmContext, AES_CIPHER_ALGO,
         &ticketContext->aesContext);
   }

   
   if(!error)
   {
      
      *ciphertextLen = plaintextLen + TLS_TICKET_KEY_NAME_SIZE +
         TLS_TICKET_IV_SIZE + TLS_TICKET_TAG_SIZE;

      
      error = gcmEncrypt(&ticketContext->gcmContext, iv, TLS_TICKET_IV_SIZE,
         state->keyName, TLS_TICKET_KEY_NAME_SIZE, data, data, plaintextLen,
         tag, TLS_TICKET_TAG_SIZE);
   }

   
   osReleaseMutex(&ticketContext->mutex);

   
   return error;
}




error_t tlsDecryptTicket(TlsContext *context, const uint8_t *ciphertext,
   size_t ciphertextLen, uint8_t *plaintext, size_t *plaintextLen, void *param)
{
   error_t error;
   const uint8_t *iv;
   const uint8_t *data;
   const uint8_t *tag;
   TlsTicketContext *ticketContext;
   TlsTicketEncryptionState *state;

   
   if(context == NULL || param == NULL)
      return ERROR_INVALID_PARAMETER;
   if(ciphertext == NULL || plaintext == NULL || plaintextLen == NULL)
      return ERROR_INVALID_PARAMETER;

   
   if(ciphertextLen < (TLS_TICKET_KEY_NAME_SIZE + TLS_TICKET_IV_SIZE +
      TLS_TICKET_TAG_SIZE))
   {
      
      return ERROR_DECRYPTION_FAILED;
   }

   
   error = NO_ERROR;

   
   iv = NULL;
   data = NULL;
   tag = NULL;
   state = NULL;

   
   ticketContext = (TlsTicketContext *) param;

   
   osAcquireMutex(&ticketContext->mutex);

   
   tlsCheckTicketKeyLifetime(&ticketContext->encryptionState);
   tlsCheckTicketKeyLifetime(&ticketContext->prevEncryptionState);

   
   if(tlsCompareTicketKeyName(ciphertext, ciphertextLen,
      &ticketContext->encryptionState))
   {
      
      state = &ticketContext->encryptionState;
   }
   else if(tlsCompareTicketKeyName(ciphertext, ciphertextLen,
      &ticketContext->prevEncryptionState))
   {
      
      state = &ticketContext->prevEncryptionState;
   }
   else
   {
      
      error = ERROR_DECRYPTION_FAILED;
   }

   
   if(!error)
   {
      
      iv = ciphertext + TLS_TICKET_KEY_NAME_SIZE;
      
      data = iv + TLS_TICKET_IV_SIZE;
      
      tag = ciphertext + ciphertextLen - TLS_TICKET_TAG_SIZE;

      
      *plaintextLen = ciphertextLen - TLS_TICKET_KEY_NAME_SIZE -
         TLS_TICKET_IV_SIZE - TLS_TICKET_TAG_SIZE;

      
      error = aesInit(&ticketContext->aesContext, state->key,
         TLS_TICKET_KEY_SIZE);
   }

   
   if(!error)
   {
      
      error = gcmInit(&ticketContext->gcmContext, AES_CIPHER_ALGO,
         &ticketContext->aesContext);
   }

   
   if(!error)
   {
      
      error = gcmDecrypt(&ticketContext->gcmContext, iv, TLS_TICKET_IV_SIZE,
         state->keyName, TLS_TICKET_KEY_NAME_SIZE, data, plaintext,
         *plaintextLen, tag, TLS_TICKET_TAG_SIZE);
   }

   
   osReleaseMutex(&ticketContext->mutex);

   
   return error;
}




error_t tlsGenerateTicketKeys(TlsTicketContext *ticketContext,
   const PrngAlgo *prngAlgo, void *prngContext)
{
   error_t error;
   TlsTicketEncryptionState *state;

   
   state = &ticketContext->encryptionState;

   
   state->valid = FALSE;

   
   
   error = prngAlgo->read(prngContext, state->keyName,
      TLS_TICKET_KEY_NAME_SIZE);
   
   if(error)
      return error;

   
   error = prngAlgo->read(prngContext, state->key, TLS_TICKET_KEY_SIZE);
   
   if(error)
      return error;

   
   state->timestamp = osGetSystemTime();
   
   state->valid = TRUE;

   
   return NO_ERROR;
}




void tlsCheckTicketKeyLifetime(TlsTicketEncryptionState *state)
{
   systime_t time;

   
   time = osGetSystemTime();

   
   if(state->valid)
   {
      
      if((time - state->timestamp) >= (2 * TLS_TICKET_LIFETIME))
      {
         
         osMemset(state, 0, sizeof(TlsTicketEncryptionState));
      }
   }
}




bool_t tlsCompareTicketKeyName(const uint8_t *ticket, size_t ticketLen,
   const TlsTicketEncryptionState *state)
{
   bool_t res;

   
   res = FALSE;

   
   if(state->valid)
   {
      
      
      if(ticketLen >= TLS_TICKET_KEY_NAME_SIZE)
      {
         
         if(osMemcmp(ticket, state->keyName, TLS_TICKET_KEY_NAME_SIZE) == 0)
         {
            
            res = TRUE;
         }
      }
   }

   
   return res;
}




void tlsFreeTicketContext(TlsTicketContext *ticketContext)
{
   
   if(ticketContext != NULL)
   {
      
      osDeleteMutex(&ticketContext->mutex);

      
      osMemset(ticketContext, 0, sizeof(TlsTicketContext));
   }
}

#endif
",64,1874,2567
"#define TRACE_LEVEL RSTP_TRACE_LEVEL


#include ""rstp/rstp.h""
#include ""rstp/rstp_fsm.h""
#include ""rstp/rstp_bpdu.h""
#include ""rstp/rstp_conditions.h""
#include ""rstp/rstp_misc.h""
#include ""debug.h""


#if (RSTP_SUPPORT == ENABLED)


const MacAddr RSTP_BRIDGE_GROUP_ADDR = {{{0x01, 0x80, 0xC2, 0x00, 0x00, 0x00}}};


const RstpParamName rstpProtocolVersions[] =
{
   {STP_PROTOCOL_VERSION,  ""STP""},
   {RSTP_PROTOCOL_VERSION, ""RSTP""}
};


const RstpParamName rstpBpduTypes[] =
{
   {RSTP_BPDU_TYPE_CONFIG, ""CONFIG""},
   {RSTP_BPDU_TYPE_TCN,    ""TCN""},
   {RSTP_BPDU_TYPE_RST,    ""RST""}
};




void rstpProcessLlcFrame(NetInterface *interface, EthHeader *ethHeader,
   const uint8_t *data, size_t length, NetRxAncillary *ancillary, void *param)
{
   const LlcHeader *llcHeader;
   const RstpBpdu *bpdu;
   RstpBridgeContext *context;
   RstpBridgePort *port;

   
   context = (RstpBridgeContext *) param;

   
   
   
   if(!macCompAddr(&ethHeader->destAddr, &RSTP_BRIDGE_GROUP_ADDR))
      return;

   
   if(length < sizeof(LlcHeader))
      return;

   
   llcHeader = (LlcHeader *) data;

   
   
   
   if(llcHeader->dsap != STP_LLC_DSAP || llcHeader->ssap != STP_LLC_SSAP ||
      llcHeader->control != STP_LLC_CTRL)
   {
      return;
   }

   
   if(ancillary->port < 1 || ancillary->port > context->numPorts)
      return;

   
   port = &context->ports[ancillary->port - 1];

   
   bpdu = (RstpBpdu *) (data + sizeof(LlcHeader));

   
   length -= sizeof(LlcHeader);

   
   rstpProcessBpdu(port, bpdu, length);
}




error_t rstpProcessBpdu(RstpBridgePort *port, const RstpBpdu *bpdu,
   size_t length)
{
   error_t error;
   uint8_t bpduType;
   RstpBridgeContext *context;

   
   TRACE_INFO(""Port %"" PRIu8 "": BPDU received (%"" PRIuSIZE "" bytes)...\r\n"",
      port->portIndex, length);

   
   rstpDumpBpdu(bpdu, length);

   
   context = port->context;

   
   if(length < STP_MIN_BPDU_SIZE)
      return ERROR_INVALID_LENGTH;

   
   if(ntohs(bpdu->protocolId) != STP_PROTOCOL_ID)
      return ERROR_INVALID_LENGTH;

   
   bpduType = bpdu->bpduType;

   
   if(bpduType == RSTP_BPDU_TYPE_CONFIG)
   {
      
      error = rstpValidateConfigBpdu(port, bpdu, length);
      
      if(error)
         return error;

      
      
      length = RSTP_CONFIG_BPDU_SIZE;
   }
   else if(bpduType == RSTP_BPDU_TYPE_TCN)
   {
      
      
      length = RSTP_TCN_BPDU_SIZE;
   }
   else if(bpduType == RSTP_BPDU_TYPE_RST)
   {
      
      
      if(stpVersion(context))
         return ERROR_INVALID_VERSION;

      
      if(length < RSTP_RST_BPDU_SIZE)
         return ERROR_INVALID_LENGTH;

      
      
      length = RSTP_RST_BPDU_SIZE;

      
      if((bpdu->flags & RSTP_BPDU_FLAG_PORT_ROLE) ==
         RSTP_BPDU_FLAG_PORT_ROLE_UNKNOWN)
      {
         
         
         
         bpduType = RSTP_BPDU_TYPE_CONFIG;

         
         error = rstpValidateConfigBpdu(port, bpdu, length);
         
         if(error)
            return error;

         
         
         length = RSTP_CONFIG_BPDU_SIZE;
      }
   }
   else
   {
      
      return ERROR_INVALID_TYPE;
   }

   
   osMemcpy(&context->bpdu, bpdu, length);

   
   context->bpdu.bpduType = bpduType;

   
   
   if(bpduType == RSTP_BPDU_TYPE_CONFIG)
   {
      
      
      
      context->bpdu.flags &= RSTP_BPDU_FLAG_TC_ACK | RSTP_BPDU_FLAG_TC;
   }
   else if(bpduType == RSTP_BPDU_TYPE_RST)
   {
      
      context->bpdu.flags &= ~RSTP_BPDU_FLAG_TC_ACK;
   }
   else
   {
      
      context->bpdu.flags = 0;
   }

   
   
   port->rcvdBpdu = TRUE;

   
   rstpFsm(context);

   
   osMemset(&context->bpdu, 0, sizeof(RstpBpdu));

   
   return NO_ERROR;
}




error_t rstpValidateConfigBpdu(RstpBridgePort *port, const RstpBpdu *bpdu,
   size_t length)
{
   RstpBridgeContext *context;

   
   context = port->context;

   
   if(length < RSTP_CONFIG_BPDU_SIZE)
      return ERROR_INVALID_LENGTH;

   
   if(ntohs(bpdu->messageAge) >= ntohs(bpdu->maxAge))
      return ERROR_INVALID_PACKET;

   
   
   if(rstpCompareBridgeAddr(&bpdu->bridgeId.addr, &context->bridgeId.addr) == 0 &&
      rstpComparePortNum(ntohs(bpdu->portId), port->portId) == 0)
   {
      return ERROR_WRONG_IDENTIFIER;
   }

   
   return NO_ERROR;
}




error_t rstpSendBpdu(RstpBridgePort *port, const RstpBpdu *bpdu,
   size_t length)
{
   error_t error;
   size_t offset;
   LlcHeader *llcHeader;
   NetBuffer *buffer;
   NetTxAncillary ancillary;
   RstpBridgeContext *context;

   
   TRACE_INFO(""Port %"" PRIu8 "": Sending BPDU (%"" PRIuSIZE "" bytes)...\r\n"",
      port->portIndex, length);

   
   rstpDumpBpdu(bpdu, length);

   
   context = port->context;

   
   buffer = ethAllocBuffer(sizeof(LlcHeader), &offset);

   
   if(buffer != NULL)
   {
      
      llcHeader = netBufferAt(buffer, offset);

      
      
      
      llcHeader->dsap = STP_LLC_DSAP;
      llcHeader->ssap = STP_LLC_SSAP;
      llcHeader->control = STP_LLC_CTRL;

      
      error = netBufferAppend(buffer, bpdu, length);

      
      if(!error)
      {
         
         length += sizeof(LlcHeader);

         
         ancillary = NET_DEFAULT_TX_ANCILLARY;
         
         ancillary.srcMacAddr = port->macAddr;
         
         ancillary.port = port->portIndex;

         
         
         error = ethSendFrame(context->interface, &RSTP_BRIDGE_GROUP_ADDR,
            length, buffer, offset, &ancillary);
      }

      
      netBufferFree(buffer);
   }
   else
   {
      
      error = ERROR_OUT_OF_MEMORY;
   }

   
   return error;
}




error_t rstpDumpBpdu(const RstpBpdu *bpdu, size_t length)
{
#if (RSTP_TRACE_LEVEL >= TRACE_LEVEL_DEBUG)
   uint32_t t;

   
   if(length < STP_MIN_BPDU_SIZE)
      return ERROR_INVALID_LENGTH;

   
   TRACE_DEBUG(""  Protocol Identifier = %"" PRIu16 ""\r\n"",
      ntohs(bpdu->protocolId));

   
   TRACE_DEBUG(""  Protocol Version Identifier = %"" PRIu8 "" (%s)\r\n"",
      bpdu->protocolVersionId, rstpGetParamName(bpdu->protocolVersionId,
      rstpProtocolVersions, arraysize(rstpProtocolVersions)));

   
   TRACE_DEBUG(""  BPDU Type = 0x%02"" PRIX8 "" (%s)\r\n"", bpdu->bpduType,
      rstpGetParamName(bpdu->bpduType, rstpBpduTypes, arraysize(rstpBpduTypes)));

   
   if(length >= RSTP_CONFIG_BPDU_SIZE)
   {
      
      rstpDumpFlags(bpdu->flags);

      
      TRACE_DEBUG(""  Root Identifier = %"" PRIu16 "" / %s\r\n"",
         ntohs(bpdu->rootId.priority), macAddrToString(&bpdu->rootId.addr, NULL));

      
      TRACE_DEBUG(""  Root Path Cost = %"" PRIu32 ""\r\n"", ntohl(bpdu->rootPathCost));

      
      TRACE_DEBUG(""  Bridge Identifier = %"" PRIu16 "" / %s\r\n"",
         ntohs(bpdu->bridgeId.priority), macAddrToString(&bpdu->bridgeId.addr, NULL));

      
      TRACE_DEBUG(""  Port Identifier = 0x%04"" PRIX16 ""\r\n"", ntohs(bpdu->portId));

      
      t = ntohs(bpdu->messageAge) * 1000 / 256;
      TRACE_DEBUG(""  Message Age = %"" PRIu32 "".%03"" PRIu32 ""\r\n"", t / 1000, t % 1000);

      
      t = ntohs(bpdu->maxAge) * 1000 / 256;
      TRACE_DEBUG(""  Max Age = %"" PRIu32 "".%03"" PRIu32 ""\r\n"", t / 1000, t % 1000);

      
      t = ntohs(bpdu->helloTime) * 1000 / 256;
      TRACE_DEBUG(""  Hello Time = %"" PRIu32 "".%03"" PRIu32 ""\r\n"", t / 1000, t % 1000);

      
      t = ntohs(bpdu->forwardDelay) * 1000 / 256;
      TRACE_DEBUG(""  Forward Delay = %"" PRIu32 "".%03"" PRIu32 ""\r\n"", t / 1000, t % 1000);
   }

   
   if(length >= RSTP_RST_BPDU_SIZE)
   {
      
      TRACE_DEBUG(""  Version 1 Length = %"" PRIu8 ""\r\n"", bpdu->version1Length);
   }
#endif

   
   return NO_ERROR;
}




void rstpDumpFlags(uint8_t flags)
{
   uint8_t role;

   
   TRACE_DEBUG(""  Flags = 0x%02"" PRIX8, flags);

   
   if(flags != 0)
   {
      
      TRACE_DEBUG("" ("");

      
      while(flags != 0)
      {
         if((flags & RSTP_BPDU_FLAG_TC_ACK) != 0)
         {
            
            TRACE_DEBUG(""TcAck"");
            
            flags &= ~RSTP_BPDU_FLAG_TC_ACK;
         }
         else if((flags & RSTP_BPDU_FLAG_AGREEMENT) != 0)
         {
            
            TRACE_DEBUG(""Agreement"");
            
            flags &= ~RSTP_BPDU_FLAG_AGREEMENT;
         }
         else if((flags & RSTP_BPDU_FLAG_FORWARDING) != 0)
         {
            
            TRACE_DEBUG(""Forwarding"");
            
            flags &= ~RSTP_BPDU_FLAG_FORWARDING;
         }
         else if((flags & RSTP_BPDU_FLAG_LEARNING) != 0)
         {
            
            TRACE_DEBUG(""Learning"");
            
            flags &= ~RSTP_BPDU_FLAG_LEARNING;
         }
         else if((flags & RSTP_BPDU_FLAG_PORT_ROLE) != 0)
         {
            
            role = flags & RSTP_BPDU_FLAG_PORT_ROLE;

            
            if(role == RSTP_BPDU_FLAG_PORT_ROLE_ALT_BACKUP)
            {
               TRACE_DEBUG(""AltBackupRole"");
            }
            else if(role == RSTP_BPDU_FLAG_PORT_ROLE_ROOT)
            {
               TRACE_DEBUG(""RootRole"");
            }
            else if(role == RSTP_BPDU_FLAG_PORT_ROLE_DESIGNATED)
            {
               TRACE_DEBUG(""DesignatedRole"");
            }

            
            flags &= ~RSTP_BPDU_FLAG_PORT_ROLE;
         }
         else if((flags & RSTP_BPDU_FLAG_PROPOSAL) != 0)
         {
            
            TRACE_DEBUG(""Proposal"");
            
            flags &= ~RSTP_BPDU_FLAG_PROPOSAL;
         }
         else if((flags & RSTP_BPDU_FLAG_TC) != 0)
         {
            
            TRACE_DEBUG(""Tc"");
            
            flags &= ~RSTP_BPDU_FLAG_TC;
         }

         
         if(flags != 0)
         {
            TRACE_DEBUG("", "");
         }
      }

      
      TRACE_DEBUG("")"");
   }

   
   TRACE_DEBUG(""\r\n"");
}

#endif
",64,1875,4021
"#include ""str.h""




char_t *strDuplicate(const char_t *s)
{
   uint_t n;
   char_t *p;

   
   p = NULL;

   
   if(s != NULL)
   {
      
      n = osStrlen(s) + 1;

      
      p = osAllocMem(n);

      
      if(p != NULL)
      {
         
         osMemcpy(p, s, n);
      }
   }

   
   return p;
}




char_t *strTrimWhitespace(char_t *s)
{
   char_t *end;
   char_t *result;

   
   while(isspace((uint8_t) *s))
   {
      s++;
   }

   
   result = s;

   
   
   for(end = NULL; *s != '\0'; s++)
   {
      if(!isspace((uint8_t) *s))
         end = NULL;
      else if(!end)
         end = s;
   }

   
   if(end)
      *end = '\0';

   
   
   return result;
}




void strRemoveTrailingSpace(char_t *s)
{
   char_t *end;

   
   
   for(end = NULL; *s != '\0'; s++)
   {
      if(!isspace((uint8_t) *s))
         end = NULL;
      else if(!end)
         end = s;
   }

   
   if(end)
      *end = '\0';
}




void strReplaceChar(char_t *s, char_t oldChar, char_t newChar)
{
   
   while(*s != '\0')
   {
      
      if(*s == oldChar)
         *s = newChar;

      
      s++;
   }
}




error_t strSafeCopy(char_t *dest, const char_t *src, size_t destSize)
{
   size_t n;

   
   if(dest == NULL || src == NULL || destSize < 1)
      return ERROR_INVALID_PARAMETER;

   
   n = osStrlen(src);
   
   n = MIN(n, destSize - 1);

   
   osStrncpy(dest, src, n);
   
   dest[n] = '\0';

   
   return NO_ERROR;
}
",64,1876,637
"#define TRACE_LEVEL TRACE_LEVEL_OFF




#include ""os_port.h""
#include ""os_port_sys_bios.h""
#include ""debug.h""


static bool_t running = FALSE;




void osInitKernel(void)
{
   
   running = FALSE;
}




void osStartKernel(void)
{
   
   running = TRUE;
   
   BIOS_start();
}




OsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,
   void *param, size_t stackSize, int_t priority)
{
   Error_Block eb;
   Task_Params taskParams;
   Task_Handle task;

   
   Error_init(&eb);

   
   Task_Params_init(&taskParams);
   taskParams.arg0 = (UArg) param;
   taskParams.stackSize = stackSize * sizeof(uint_t);
   taskParams.priority = priority;

   
   task = Task_create((Task_FuncPtr) taskCode, &taskParams, &eb);

   
   return task;
}




void osDeleteTask(OsTask *task)
{
   
   Task_delete(&task);
}




void osDelayTask(systime_t delay)
{
   
   Task_sleep(OS_MS_TO_SYSTICKS(delay));
}




void osSwitchTask(void)
{
   
   Task_yield();
}




void osSuspendAllTasks(void)
{
   
   if(running)
   {
      
      Task_disable();
   }
}




void osResumeAllTasks(void)
{
   
   if(running)
   {
      
      Task_enable();
   }
}




bool_t osCreateEvent(OsEvent *event)
{
   
   event->handle = Event_create(NULL, NULL);

   
   if(event->handle != NULL)
      return TRUE;
   else
      return FALSE;
}




void osDeleteEvent(OsEvent *event)
{
   
   if(event->handle != NULL)
   {
      
      Event_delete(&event->handle);
   }
}




void osSetEvent(OsEvent *event)
{
   
   Event_post(event->handle, Event_Id_00);
}




void osResetEvent(OsEvent *event)
{
   
   Event_pend(event->handle, Event_Id_00, Event_Id_NONE, BIOS_NO_WAIT);
}




bool_t osWaitForEvent(OsEvent *event, systime_t timeout)
{
   Bool ret;

   
   if(timeout == 0)
   {
      
      ret = Event_pend(event->handle, Event_Id_00,
         Event_Id_NONE, BIOS_NO_WAIT);
   }
   else if(timeout == INFINITE_DELAY)
   {
      
      ret = Event_pend(event->handle, Event_Id_00,
         Event_Id_NONE, BIOS_WAIT_FOREVER);
   }
   else
   {
      
      ret = Event_pend(event->handle, Event_Id_00,
         Event_Id_NONE, OS_MS_TO_SYSTICKS(timeout));
   }

   
   return ret;
}




bool_t osSetEventFromIsr(OsEvent *event)
{
   
   Event_post(event->handle, Event_Id_00);

   
   return FALSE;
}




bool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)
{
   Semaphore_Params semaphoreParams;

   
   Semaphore_Params_init(&semaphoreParams);
   semaphoreParams.mode = Semaphore_Mode_COUNTING;

   
   semaphore->handle = Semaphore_create(count, &semaphoreParams, NULL);

   
   if(semaphore->handle != NULL)
      return TRUE;
   else
      return FALSE;
}




void osDeleteSemaphore(OsSemaphore *semaphore)
{
   
   if(semaphore->handle != NULL)
   {
      
      Semaphore_delete(&semaphore->handle);
   }
}




bool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)
{
   Bool ret;

   
   if(timeout == 0)
   {
      
      ret = Semaphore_pend(semaphore->handle, BIOS_NO_WAIT);
   }
   else if(timeout == INFINITE_DELAY)
   {
      
      ret = Semaphore_pend(semaphore->handle, BIOS_WAIT_FOREVER);
   }
   else
   {
      
      ret = Semaphore_pend(semaphore->handle, OS_MS_TO_SYSTICKS(timeout));
   }

   
   return ret;
}




void osReleaseSemaphore(OsSemaphore *semaphore)
{
   
   Semaphore_post(semaphore->handle);
}




bool_t osCreateMutex(OsMutex *mutex)
{
   Semaphore_Params semaphoreParams;

   
   Semaphore_Params_init(&semaphoreParams);
   semaphoreParams.mode = Semaphore_Mode_BINARY_PRIORITY;

   
   mutex->handle = Semaphore_create(1, &semaphoreParams, NULL);

   
   if(mutex->handle != NULL)
      return TRUE;
   else
      return FALSE;
}




void osDeleteMutex(OsMutex *mutex)
{
   
   if(mutex->handle != NULL)
   {
      
      Semaphore_delete(&mutex->handle);
   }
}




void osAcquireMutex(OsMutex *mutex)
{
   
   Semaphore_pend(mutex->handle, BIOS_WAIT_FOREVER);
}




void osReleaseMutex(OsMutex *mutex)
{
   
   Semaphore_post(mutex->handle);
}




systime_t osGetSystemTime(void)
{
   systime_t time;

   
   time = Clock_getTicks();

   
   return OS_SYSTICKS_TO_MS(time);
}




void *osAllocMem(size_t size)
{
   void *p;

   
   osSuspendAllTasks();
   
   p = malloc(size);
   
   osResumeAllTasks();

   
   TRACE_DEBUG(""Allocating %"" PRIuSIZE "" bytes at 0x%08"" PRIXPTR ""\r\n"", size, (uintptr_t) p);

   
   return p;
}




void osFreeMem(void *p)
{
   
   if(p != NULL)
   {
      
      TRACE_DEBUG(""Freeing memory at 0x%08"" PRIXPTR ""\r\n"", (uintptr_t) p);

      
      osSuspendAllTasks();
      
      free(p);
      
      osResumeAllTasks();
   }
}
",64,1877,1909
"#define TRACE_LEVEL SSH_TRACE_LEVEL


#include ""ssh/ssh.h""
#include ""ssh/ssh_misc.h""
#include ""ssh/ssh_server.h""
#include ""ssh/ssh_server_misc.h""
#include ""debug.h""


#if (SSH_SUPPORT == ENABLED && SSH_SERVER_SUPPORT == ENABLED)




void sshServerGetDefaultSettings(SshServerSettings *settings)
{
   
   settings->interface = NULL;

   
   settings->port = SSH_PORT;

   
   settings->numConnections = 0;
   settings->connections = NULL;

   
   settings->numChannels = 0;
   settings->channels = NULL;

   
   settings->prngAlgo = NULL;
   settings->prngContext = NULL;

   
   settings->passwordAuthCallback = NULL;
   
   settings->publicKeyAuthCallback = NULL;
}




error_t sshServerInit(SshServerContext *context,
   const SshServerSettings *settings)
{
   error_t error;

   
   TRACE_INFO(""Initializing SSH server...\r\n"");

   
   if(context == NULL || settings == NULL)
      return ERROR_INVALID_PARAMETER;

   
   if(settings->numConnections < 1 ||
      settings->numConnections > SSH_MAX_CONNECTIONS)
   {
      return ERROR_INVALID_PARAMETER;
   }

   
   if(settings->numChannels < settings->numConnections)
      return ERROR_INVALID_PARAMETER;

   
   error = sshInit(&context->sshContext, settings->connections,
      settings->numConnections, settings->channels, settings->numChannels);
   
   if(error)
      return error;

   
   context->interface = settings->interface;
   context->port = settings->port;

   
   do
   {
      
      error = sshSetOperationMode(&context->sshContext,
         SSH_OPERATION_MODE_SERVER);
      
      if(error)
         break;

      
      error = sshSetPrng(&context->sshContext, settings->prngAlgo,
         settings->prngContext);
      
      if(error)
         break;

      
      if(settings->passwordAuthCallback != NULL)
      {
         
         error = sshRegisterPasswordAuthCallback(&context->sshContext,
            settings->passwordAuthCallback);
         
         if(error)
            break;
      }

      
      if(settings->publicKeyAuthCallback != NULL)
      {
         
         error = sshRegisterPublicKeyAuthCallback(&context->sshContext,
            settings->publicKeyAuthCallback);
         
         if(error)
            break;
      }

      
   } while(0);

   
   if(error)
   {
      
      sshServerDeinit(context);
   }

   
   return error;
}




error_t sshServerRegisterGlobalRequestCallback(SshServerContext *context,
   SshGlobalReqCallback callback, void *param)
{
   
   return sshRegisterGlobalRequestCallback(&context->sshContext, callback,
      param);
}




error_t sshServerUnregisterGlobalRequestCallback(SshServerContext *context,
   SshGlobalReqCallback callback)
{
   
   return sshUnregisterGlobalRequestCallback(&context->sshContext, callback);
}




error_t sshServerRegisterChannelRequestCallback(SshServerContext *context,
   SshChannelReqCallback callback, void *param)
{
   
   return sshRegisterChannelRequestCallback(&context->sshContext, callback,
      param);
}




error_t sshServerUnregisterChannelRequestCallback(SshServerContext *context,
   SshChannelReqCallback callback)
{
   
   return sshUnregisterChannelRequestCallback(&context->sshContext, callback);
}




error_t sshServerLoadHostKey(SshServerContext *context, const char_t *publicKey,
   size_t publicKeyLen, const char_t *privateKey, size_t privateKeyLen)
{
   error_t error;

   
   if(!context->running)
   {
      
      error = sshLoadHostKey(&context->sshContext, publicKey, publicKeyLen,
         privateKey, privateKeyLen);
   }
   else
   {
      
      error = ERROR_WRONG_STATE;
   }

   
   return error;
}




error_t sshServerUnloadAllHostKeys(SshServerContext *context)
{
   error_t error;

   
   if(!context->running)
   {
      
      error = sshUnloadAllHostKeys(&context->sshContext);
   }
   else
   {
      
      error = ERROR_WRONG_STATE;
   }

   
   return error;
}




error_t sshServerStart(SshServerContext *context)
{
   error_t error;
   OsTask *task;

   
   if(context == NULL)
      return ERROR_INVALID_PARAMETER;

   
   TRACE_INFO(""Starting SSH server...\r\n"");

   
   if(context->running)
      return ERROR_ALREADY_RUNNING;

   
   do
   {
      
      context->socket = socketOpen(SOCKET_TYPE_STREAM, SOCKET_IP_PROTO_TCP);

      
      if(context->socket == NULL)
      {
         
         error = ERROR_OPEN_FAILED;
         
         break;
      }

      
      error = socketSetTimeout(context->socket, 0);
      
      if(error)
         break;

      
      error = socketBindToInterface(context->socket, context->interface);
      
      if(error)
         break;

      
      error = socketBind(context->socket, &IP_ADDR_ANY, context->port);
      
      if(error)
         break;

      
      error = socketListen(context->socket, 0);
      
      if(error)
         break;

      
      context->stop = FALSE;
      context->running = TRUE;

      
      task = osCreateTask(""SSH Server"", (OsTaskCode) sshServerTask, context,
         SSH_SERVER_STACK_SIZE, SSH_SERVER_PRIORITY);
      
      if(task == OS_INVALID_HANDLE)
      {
         
         error = ERROR_OUT_OF_RESOURCES;
         break;
      }

      
   } while(0);

   
   if(error)
   {
      
      context->running = FALSE;
      
      socketClose(context->socket);
   }

   
   return error;
}




error_t sshServerStop(SshServerContext *context)
{
   uint_t i;

   
   if(context == NULL)
      return ERROR_INVALID_PARAMETER;

   
   TRACE_INFO(""Stopping SSH server...\r\n"");

   
   if(context->running)
   {
      
      context->stop = TRUE;
      
      sshNotifyEvent(&context->sshContext);

      
      while(context->running)
      {
         osDelayTask(1);
      }

      
      for(i = 0; i < context->sshContext.numConnections; i++)
      {
         
         if(context->sshContext.connections[i].state != SSH_CONN_STATE_CLOSED)
         {
            
            sshCloseConnection(&context->sshContext.connections[i]);
         }
      }

      
      socketClose(context->socket);
      context->socket = NULL;
   }

   
   return NO_ERROR;
}




void sshServerTask(SshServerContext *context)
{
   error_t error;
   uint_t i;
   SshContext *sshContext;
   SshConnection *connection;

   
   sshContext = &context->sshContext;

#if (NET_RTOS_SUPPORT == ENABLED)
   
   osEnterTask();

   
   while(1)
   {
#endif
      
      osMemset(sshContext->eventDesc, 0, sizeof(sshContext->eventDesc));

      
      for(i = 0; i < sshContext->numConnections; i++)
      {
         
         connection = &sshContext->connections[i];

         
         if(connection->state != SSH_CONN_STATE_CLOSED)
         {
            
            sshRegisterConnectionEvents(sshContext, connection,
               &sshContext->eventDesc[i]);
         }
      }

      
      sshContext->eventDesc[i].socket = context->socket;
      sshContext->eventDesc[i].eventMask = SOCKET_EVENT_ACCEPT;

      
      error = socketPoll(sshContext->eventDesc, sshContext->numConnections + 1,
         &sshContext->event, SSH_SERVER_TICK_INTERVAL);

      
      if(error == NO_ERROR || error == ERROR_TIMEOUT)
      {
         
         if(context->stop)
         {
            
            context->running = FALSE;
            
            osDeleteTask(NULL);
         }

         
         for(i = 0; i < sshContext->numConnections; i++)
         {
            
            connection = &sshContext->connections[i];

            
            if(connection->state != SSH_CONN_STATE_CLOSED)
            {
               
               if(sshContext->eventDesc[i].eventFlags != 0)
               {
                  
                  error = sshProcessConnectionEvents(sshContext, connection);

                  
                  if(error != NO_ERROR && error != ERROR_TIMEOUT)
                  {
                     
                     sshCloseConnection(connection);
                  }
               }
            }
         }

         
         if(sshContext->eventDesc[i].eventFlags != 0)
         {
            
            sshServerAcceptConnection(context);
         }
      }

      
      sshServerTick(context);

#if (NET_RTOS_SUPPORT == ENABLED)
   }
#endif
}




void sshServerDeinit(SshServerContext *context)
{
   
   if(context != NULL)
   {
      
      socketClose(context->socket);

      
      sshDeinit(&context->sshContext);

      
      osMemset(context, 0, sizeof(SshServerContext));
   }
}

#endif
",64,1878,2661
"#define TRACE_LEVEL RSTP_TRACE_LEVEL


#include ""rstp/rstp.h""
#include ""rstp/rstp_fsm.h""
#include ""rstp/rstp_ptx.h""
#include ""rstp/rstp_procedures.h""
#include ""rstp/rstp_conditions.h""
#include ""rstp/rstp_misc.h""
#include ""debug.h""


#if (RSTP_SUPPORT == ENABLED)


const RstpParamName rstpPtxStates[] =
{
   {RSTP_PTX_STATE_TRANSMIT_INIT,     ""TRANSMIT_INIT""},
   {RSTP_PTX_STATE_TRANSMIT_PERIODIC, ""TRANSMIT_PERIODIC""},
   {RSTP_PTX_STATE_TRANSMIT_CONFIG,   ""TRANSMIT_CONFIG""},
   {RSTP_PTX_STATE_TRANSMIT_TCN,      ""TRANSMIT_TCN""},
   {RSTP_PTX_STATE_TRANSMIT_RSTP,     ""TRANSMIT_RSTP""},
   {RSTP_PTX_STATE_IDLE,              ""IDLE""}
};




void rstpPtxInit(RstpBridgePort *port)
{
   
   rstpPtxChangeState(port, RSTP_PTX_STATE_TRANSMIT_INIT);
}




void rstpPtxFsm(RstpBridgePort *port)
{
   RstpBridgeContext *context;

   
   context = port->context;

   
   if(!port->portEnabled)
   {
      
      
      rstpPtxChangeState(port, RSTP_PTX_STATE_TRANSMIT_INIT);
   }
   else
   {
      
      
      switch(port->ptxState)
      {
      
      
      case RSTP_PTX_STATE_TRANSMIT_INIT:
      case RSTP_PTX_STATE_TRANSMIT_PERIODIC:
      case RSTP_PTX_STATE_TRANSMIT_CONFIG:
      case RSTP_PTX_STATE_TRANSMIT_TCN:
      case RSTP_PTX_STATE_TRANSMIT_RSTP:
         
         rstpPtxChangeState(port, RSTP_PTX_STATE_IDLE);
         break;

      
      case RSTP_PTX_STATE_IDLE:
         
         if(port->selected && !port->updtInfo)
         {
            
            
            if(port->helloWhen == 0)
            {
               
               rstpPtxChangeState(port, RSTP_PTX_STATE_TRANSMIT_PERIODIC);
            }
            else
            {
               
               if(port->newInfo)
               {
                  
                  if(port->txCount < rstpTxHoldCount(context))
                  {
                     
                     if(port->sendRstp)
                     {
                        
                        rstpPtxChangeState(port, RSTP_PTX_STATE_TRANSMIT_RSTP);
                     }
                     else
                     {
                        
                        if(port->role == STP_PORT_ROLE_ROOT)
                        {
                           
                           rstpPtxChangeState(port, RSTP_PTX_STATE_TRANSMIT_TCN);
                        }
                        else if(port->role == STP_PORT_ROLE_DESIGNATED)
                        {
                           
                           rstpPtxChangeState(port, RSTP_PTX_STATE_TRANSMIT_CONFIG);
                        }
                        else
                        {
                           
                        }
                     }
                  }
               }
            }
         }

         break;

      
      default:
         
         rstpFsmError(port->context);
         break;
      }
   }
}




void rstpPtxChangeState(RstpBridgePort *port, RstpPtxState newState)
{
   
   if(port->ptxState != newState)
   {
      
      TRACE_VERBOSE(""Port %"" PRIu8 "": PTX state machine %s -> %s\r\n"",
         port->portIndex,
         rstpGetParamName(port->ptxState, rstpPtxStates, arraysize(rstpPtxStates)),
         rstpGetParamName(newState, rstpPtxStates, arraysize(rstpPtxStates)));
   }

   
   port->ptxState = newState;

   
   
   switch(port->ptxState)
   {
   
   case RSTP_PTX_STATE_TRANSMIT_INIT:
      
      port->newInfo = TRUE;
      port->txCount = 0;
      break;

   
   case RSTP_PTX_STATE_TRANSMIT_PERIODIC:
      
      if(port->role == STP_PORT_ROLE_DESIGNATED)
      {
         
         port->newInfo = TRUE;
      }
      else if(port->role == STP_PORT_ROLE_ROOT)
      {
         
         if(port->tcWhile != 0)
         {
            
            port->newInfo = TRUE;
         }
      }
      else
      {
         
      }

      break;

   
   case RSTP_PTX_STATE_TRANSMIT_CONFIG:
      
      port->newInfo = FALSE;
      rstpTxConfig(port);
      port->txCount++;
      port->tcAck = FALSE;
      break;

   
   case RSTP_PTX_STATE_TRANSMIT_TCN:
      
      port->newInfo = FALSE;
      rstpTxTcn(port);
      port->txCount++;
      break;

   
   case RSTP_PTX_STATE_TRANSMIT_RSTP:
      
      port->newInfo = FALSE;
      rstpTxRstp(port);
      port->txCount++;
      port->tcAck = FALSE;
      break;

   
   case RSTP_PTX_STATE_IDLE:
      
      port->helloWhen = rstpHelloTime(port);
      break;

   
   default:
      
      break;
   }

   
   if(port->portEnabled)
   {
      
      port->context->busy = TRUE;
   }
}

#endif
",64,1879,1688
"#define TRACE_LEVEL SNMP_TRACE_LEVEL


#include ""core/net.h""
#include ""mibs/mib_common.h""
#include ""mibs/bridge_mib_module.h""
#include ""mibs/bridge_mib_impl.h""
#include ""core/crypto.h""
#include ""encoding/asn1.h""
#include ""encoding/oid.h""
#include ""stp/stp.h""
#include ""stp/stp_mgmt.h""
#include ""stp/stp_misc.h""
#include ""rstp/rstp.h""
#include ""rstp/rstp_mgmt.h""
#include ""rstp/rstp_misc.h""
#include ""debug.h""


#if (BRIDGE_MIB_SUPPORT == ENABLED)




error_t bridgeMibInit(void)
{
   
   TRACE_INFO(""Initializing Bridge MIB base...\r\n"");

   
   memset(&bridgeMibBase, 0, sizeof(bridgeMibBase));

   
   bridgeMibBase.dot1dBaseType = BRIDGE_MIB_BASE_TYPE_TRANSPARENT_ONLY;
   
   bridgeMibBase.dot1dStpProtocolSpecification = BRIDGE_MIB_PROTOCOL_SPEC_IEEE802_1D;

   
   return NO_ERROR;
}




error_t bridgeMibSetStpBridgeContext(StpBridgeContext *context)
{
#if (STP_SUPPORT == ENABLED)
   
   if(context != NULL)
   {
      bridgeMibBase.stpBridgeContext = context;
      bridgeMibBase.interface = context->interface;
   }
   else
   {
      bridgeMibBase.stpBridgeContext = NULL;
      bridgeMibBase.interface = NULL;
   }

   
   return NO_ERROR;
#else
   
   return ERROR_NOT_IMPLEMENTED;
#endif
}




error_t bridgeMibSetRstpBridgeContext(RstpBridgeContext *context)
{
#if (RSTP_SUPPORT == ENABLED)
   
   if(context != NULL)
   {
      bridgeMibBase.rstpBridgeContext = context;
      bridgeMibBase.interface = context->interface;
   }
   else
   {
      bridgeMibBase.rstpBridgeContext = NULL;
      bridgeMibBase.interface = NULL;
   }

   
   return NO_ERROR;
#else
   
   return ERROR_NOT_IMPLEMENTED;
#endif
}




uint_t bridgeMibGetNumPorts(void)
{
   uint_t numPorts;

   
   numPorts = 0;

#if (STP_SUPPORT == ENABLED)
   
   if(bridgeMibBase.stpBridgeContext != NULL)
   {
      numPorts = bridgeMibBase.stpBridgeContext->numPorts;
   }
   else
#endif
#if (RSTP_SUPPORT == ENABLED)
   
   if(bridgeMibBase.rstpBridgeContext != NULL)
   {
      numPorts = bridgeMibBase.rstpBridgeContext->numPorts;
   }
   else
#endif
   
   {
      
   }

   
   return numPorts;
}




uint_t bridgeMibGetPortIndex(uint16_t portNum)
{
   uint_t portIndex;

   
   portIndex = 0;

#if (STP_SUPPORT == ENABLED)
   
   if(bridgeMibBase.stpBridgeContext != NULL)
   {
      StpBridgePort *port;

      
      port = stpGetBridgePort(bridgeMibBase.stpBridgeContext, portNum);

      
      if(port != NULL)
      {
         
         portIndex = port->portIndex;
      }
   }
   else
#endif
#if (RSTP_SUPPORT == ENABLED)
   
   if(bridgeMibBase.rstpBridgeContext != NULL)
   {
      RstpBridgePort *port;

      
      port = rstpGetBridgePort(bridgeMibBase.rstpBridgeContext, portNum);

      
      if(port != NULL)
      {
         
         portIndex = port->portIndex;
      }
   }
   else
#endif
   
   {
      
   }

   
   return portIndex;
}




uint16_t bridgeMibGetPortNum(uint16_t portIndex)
{
   uint_t portNum;

   
   portNum = 0;

#if (STP_SUPPORT == ENABLED)
   
   if(bridgeMibBase.stpBridgeContext != NULL)
   {
      
      if(portIndex >= 1 && portIndex <= bridgeMibBase.stpBridgeContext->numPorts)
      {
         StpBridgePort *port;

         
         port = &bridgeMibBase.stpBridgeContext->ports[portIndex - 1];
         
         portNum = port->portId & STP_PORT_NUM_MASK;
      }
   }
   else
#endif
#if (RSTP_SUPPORT == ENABLED)
   
   if(bridgeMibBase.rstpBridgeContext != NULL)
   {
      
      if(portIndex >= 1 && portIndex <= bridgeMibBase.rstpBridgeContext->numPorts)
      {
         RstpBridgePort *port;

         
         port = &bridgeMibBase.rstpBridgeContext->ports[portIndex - 1];
         
         portNum = port->portId & RSTP_PORT_NUM_MASK;
      }
   }
   else
#endif
   
   {
      
   }

   
   return portNum;
}

#endif
",64,1880,1556
"#include ""os_port.h""
#include ""resource_manager.h""
#include ""debug.h""


extern const uint8_t res[];


error_t resGetData(const char_t *path, const uint8_t **data, size_t *length)
{
   bool_t found;
   bool_t match;
   uint_t n;
   uint_t dirLength;
   ResEntry *resEntry;

   
   ResHeader *resHeader = (ResHeader *) res;

   
   if(resHeader->totalSize < sizeof(ResHeader))
      return ERROR_INVALID_RESOURCE;

   
   dirLength = resHeader->rootEntry.dataLength;
   
   resEntry = (ResEntry *) (res + resHeader->rootEntry.dataStart);

   
   for(found = FALSE; !found && path[0] != '\0'; path += n + 1)
   {
      
      for(n = 0; path[n] != '\\' && path[n] != '/' && path[n] != '\0'; n++);

      if(n == 0 && path[n] != '\0')
      {
         path++;
         for(n = 0; path[n] != '\\' && path[n] != '/' && path[n] != '\0'; n++);
      }

      
      for(match = FALSE; !match && dirLength > 0; )
      {
         
         if(dirLength < sizeof(ResEntry))
            return ERROR_INVALID_RESOURCE;
         
         if(dirLength < (sizeof(ResEntry) + resEntry->nameLength))
            return ERROR_INVALID_RESOURCE;

         
         if(resEntry->nameLength == n && !strncasecmp(resEntry->name, path, n))
         {
            
            if(resEntry->type == RES_TYPE_DIR)
            {
               
               dirLength = resEntry->dataLength;
               
               resEntry = (ResEntry *) (res + resEntry->dataStart);
            }
            else
            {
               
               if(path[n] != '\0')
                  return ERROR_NOT_FOUND;

               
               found = TRUE;
            }
            
            match = TRUE;
         }
         else
         {
            
            dirLength -= sizeof(ResEntry) + resEntry->nameLength;
            
            resEntry = (ResEntry *) ((uint8_t *) resEntry + sizeof(ResEntry) + resEntry->nameLength);
         }
      }

      
      if(!match)
         return ERROR_NOT_FOUND;
   }

   
   if(!found)
      return ERROR_NOT_FOUND;
   
   if(resEntry->type != RES_TYPE_FILE)
      return ERROR_NOT_FOUND;

   
   *data = res + resEntry->dataStart;
   
   *length = resEntry->dataLength;

   
   return NO_ERROR;
}


error_t resSearchFile(const char_t *path, DirEntry *dirEntry)
{
   bool_t found;
   bool_t match;
   uint_t n;
   uint_t length;
   ResEntry *resEntry;

   
   ResHeader *resHeader = (ResHeader *) res;

   
   if(resHeader->totalSize < sizeof(ResHeader))
      return ERROR_INVALID_RESOURCE;

   
   length = resHeader->rootEntry.dataLength;
   
   resEntry = (ResEntry *) (res + resHeader->rootEntry.dataStart);

   
   for(found = FALSE; !found && path[0] != '\0'; path += n + 1)
   {
      
      for(n = 0; path[n] != '\\' && path[n] != '/' && path[n] != '\0'; n++);

      if(n == 0 && path[n] != '\0')
      {
         path++;
         for(n = 0; path[n] != '\\' && path[n] != '/' && path[n] != '\0'; n++);
      }

      
      for(match = FALSE; !match && length > 0; )
      {
         
         if(length < sizeof(ResEntry))
            return ERROR_INVALID_RESOURCE;
         
         if(length < (sizeof(ResEntry) + resEntry->nameLength))
            return ERROR_INVALID_RESOURCE;

         
         if(resEntry->nameLength == n && !strncasecmp(resEntry->name, path, n))
         {
            
            if(resEntry->type == RES_TYPE_DIR)
            {
               
               length = resEntry->dataLength;
               
               resEntry = (ResEntry *) (res + resEntry->dataStart);
            }
            else
            {
               
               if(path[n] != '\0')
                  return ERROR_INVALID_PATH;

               
               found = TRUE;
            }
            
            match = TRUE;
         }
         else
         {
            
            length -= sizeof(ResEntry) + resEntry->nameLength;
            
            resEntry = (ResEntry *) ((uint8_t *) resEntry + sizeof(ResEntry) + resEntry->nameLength);
         }
      }

      
      if(!match)
         return ERROR_NOT_FOUND;
   }

   
   if(!found)
      return ERROR_NOT_FOUND;

   
   dirEntry->type = resEntry->type;
   dirEntry->volume = 0;
   dirEntry->dataStart = resEntry->dataStart;
   dirEntry->dataLength = resEntry->dataLength;
   dirEntry->nameLength = 0; 
   
   
   
   

   
   return NO_ERROR;
}

#if 0

error_t resOpenFile(FsFile *file, const DirEntry *dirEntry, uint_t mode)
{
   file->mode = mode;
   file->offset = 0;
   file->start = dirEntry->dataStart;
   file->size = dirEntry->dataLength;

   return NO_ERROR;
}


error_t resSeekFile(FsFile *file, uint32_t *position)
{
   return ERROR_NOT_IMPLEMENTED;
}


uint_t resReadFile(FsFile *file, void *data, size_t length)
{
   length = MIN(length, file->size - file->offset);
   osMemcpy(data, res + file->start + file->offset, length);
   file->offset += length;
   return length;
}

FILE *fopen(const char_t *filename, const char_t *mode)
{
   error_t error;
   DirEntry dirEntry;
   FsFile *file;

   error = resSearchFile(filename, &dirEntry);
   if(error)
      return NULL;

   file = osAllocMem(sizeof(FsFile));
   if(!file)
      return NULL;

   error = resOpenFile(file, &dirEntry, MODE_BINARY);
   if(error)
   {
      osFreeMem(file);
      return NULL;
   }

   return (FILE *) file;
}


size_t fread(void *ptr, size_t size, size_t count, FILE *stream)
{
   uint_t n;

   n = resReadFile((FsFile *) stream, ptr, size * count);

   return n / size;
}


int_t fclose(FILE * stream)
{
   osFreeMem(stream);
   
   return 0;
}


uint_t fileGetSize(FILE *stream)
{
   uint_t n;
   n = ((FsFile *) stream)->size;
   return n;
}

#endif
",64,1881,1940
"#define TRACE_LEVEL TLS_TRACE_LEVEL



#include ""tls.h""
#include ""tls_handshake.h""
#include ""tls_client.h""
#include ""tls_common.h""
#include ""tls_transcript_hash.h""
#include ""tls_record.h""
#include ""tls_misc.h""
#include ""tls13_client_misc.h""
#include ""tls13_key_material.h""
#include ""tls13_ticket.h""
#include ""debug.h""


#if (TLS_SUPPORT == ENABLED && TLS_CLIENT_SUPPORT == ENABLED && \
   TLS_MAX_VERSION >= TLS_VERSION_1_3)




bool_t tls13IsHelloRetryRequest(const TlsServerHello *message, size_t length)
{
   bool_t res;

   
   res = FALSE;

   
   if(length >= sizeof(TlsServerHello))
   {
      
      
      if(!osMemcmp(&message->random, tls13HelloRetryRequestRandom,
         sizeof(tls13HelloRetryRequestRandom)))
      {
         
         res = TRUE;
      }
   }

   
   return res;
}




error_t tls13ComputePskBinders(TlsContext *context, const void *clientHello,
   size_t clientHelloLen, const Tls13PskIdentityList *identityList,
   Tls13PskBinderList *binderList)
{
   error_t error;
   size_t n;
   size_t m;
   size_t truncatedClientHelloLen;
   uint8_t *q;
   const uint8_t *p;
   Tls13PskBinder *binder;
   const Tls13PskIdentity *identity;

   
   error = NO_ERROR;

#if (TLS13_PSK_KE_SUPPORT == ENABLED || TLS13_PSK_DHE_KE_SUPPORT == ENABLED || \
   TLS13_PSK_ECDHE_KE_SUPPORT == ENABLED)
   
   if(identityList != NULL && binderList != NULL)
   {
      
      
      p = identityList->value;
      n = ntohs(identityList->length);

      
      
      q = binderList->value;
      m = ntohs(binderList->length);

      
      
      truncatedClientHelloLen = (uint8_t *) binderList - (uint8_t *) clientHello;

      
      while(n > 0)
      {
         
         identity = (Tls13PskIdentity *) p;

         
         if(n < sizeof(TlsPskIdentity))
            return ERROR_DECODING_FAILED;
         if(n < (sizeof(TlsPskIdentity) + ntohs(identity->length)))
            return ERROR_DECODING_FAILED;

         
         p += sizeof(TlsPskIdentity) + ntohs(identity->length);
         n -= sizeof(TlsPskIdentity) + ntohs(identity->length);

         
         if(n < sizeof(uint32_t))
            return ERROR_DECODING_FAILED;

         
         p += sizeof(uint32_t);
         n -= sizeof(uint32_t);

         
         binder = (Tls13PskBinder *) q;

         
         if(m < sizeof(Tls13PskBinder))
            return ERROR_DECODING_FAILED;
         if(m < (sizeof(Tls13PskBinder) + binder->length))
            return ERROR_DECODING_FAILED;

         
         q += sizeof(Tls13PskBinder) + binder->length;
         m -= sizeof(Tls13PskBinder) + binder->length;

         
         error = tls13ComputePskBinder(context, clientHello, clientHelloLen,
            truncatedClientHelloLen, identity, binder->value, binder->length);
         
         if(error)
            break;
      }
   }
#endif

   
   return error;
}




error_t tls13SendEarlyData(TlsContext *context, const void *data,
   size_t length, size_t *written)
{
#if (TLS13_EARLY_DATA_SUPPORT == ENABLED)
   error_t error;
   size_t n;

   
   *written = 0;

   
   if(tls13IsPskValid(context))
   {
      
      if(context->pskCipherSuite == 0)
         return ERROR_END_OF_STREAM;
   }
   else if(tls13IsTicketValid(context))
   {
      
      if(context->ticketCipherSuite == 0)
         return ERROR_END_OF_STREAM;
   }
   else
   {
      
      return ERROR_END_OF_STREAM;
   }

   
   error = NO_ERROR;

   
   while(!error)
   {
      
      if(context->transportProtocol == TLS_TRANSPORT_PROTOCOL_STREAM)
      {
         
         if(context->state != TLS_STATE_INIT &&
            context->state != TLS_STATE_CLOSED)
         {
            
            error = tlsWriteProtocolData(context, NULL, 0, TLS_TYPE_NONE);
            
            if(error)
               break;
         }
      }

      
      
      if(context->state == TLS_STATE_INIT)
      {
         
         error = tlsInitHandshake(context);
      }
      else if(context->state == TLS_STATE_CLIENT_HELLO)
      {
         
         
         
         context->earlyDataEnabled = TRUE;

         
         
         error = tlsSendClientHello(context);
      }
      else if(context->state == TLS_STATE_SERVER_HELLO)
      {
         
         error = tlsInitTranscriptHash(context);

#if (TLS13_MIDDLEBOX_COMPAT_SUPPORT == ENABLED)
         
         
         context->state = TLS_STATE_CLIENT_CHANGE_CIPHER_SPEC;
#else
         
         context->state = TLS_STATE_CLIENT_HELLO_2;
#endif
      }
      else if(context->state == TLS_STATE_CLIENT_CHANGE_CIPHER_SPEC)
      {
         
         error = tlsSendChangeCipherSpec(context);
      }
      else if(context->state == TLS_STATE_CLIENT_HELLO_2)
      {
         
         error = tls13GenerateEarlyTrafficKeys(context);
      }
      else if(context->state == TLS_STATE_EARLY_DATA)
      {
         
         if(*written < length &&
            context->earlyDataLen < context->maxEarlyDataSize)
         {
            
            n = MIN(context->txBufferMaxLen, length - *written);
            n = MIN(n, context->maxEarlyDataSize - context->earlyDataLen);

            
            n = MIN(n, TLS_MAX_RECORD_LENGTH);

            
            TRACE_INFO(""Sending early data (%"" PRIuSIZE "" bytes)...\r\n"", n);

            
            error = tlsWriteProtocolData(context, data, n,
               TLS_TYPE_APPLICATION_DATA);

            
            if(!error)
            {
               
               data = (uint8_t *) data + n;
               
               *written += n;

               
               context->earlyDataLen += n;
            }
         }
         else
         {
            
            break;
         }
      }
      else
      {
         
         error = ERROR_UNEXPECTED_STATE;
      }
   }

   
   if(error == NO_ERROR && length != 0 && *written == 0)
   {
      error = ERROR_END_OF_STREAM;
   }

   
   return error;
#else
   
   return ERROR_NOT_IMPLEMENTED;
#endif
}

#endif
",64,1882,2129
"#define TRACE_LEVEL RSTP_TRACE_LEVEL


#include ""rstp/rstp.h""
#include ""rstp/rstp_fsm.h""
#include ""rstp/rstp_ppm.h""
#include ""rstp/rstp_conditions.h""
#include ""rstp/rstp_misc.h""
#include ""debug.h""


#if (RSTP_SUPPORT == ENABLED)


const RstpParamName rstpPpmStates[] =
{
   {RSTP_PPM_STATE_CHECKING_RSTP, ""CHECKING_RSTP""},
   {RSTP_PPM_STATE_SELECTING_STP, ""SELECTING_STP""},
   {RSTP_PPM_STATE_SENSING,       ""SENSING""}
};




void rstpPpmInit(RstpBridgePort *port)
{
   
   rstpPpmChangeState(port, RSTP_PPM_STATE_CHECKING_RSTP);
}




void rstpPpmFsm(RstpBridgePort *port)
{
   
   
   switch(port->ppmState)
   {
   
   case RSTP_PPM_STATE_CHECKING_RSTP:
      
      if(port->mdelayWhile == 0)
      {
         
         rstpPpmChangeState(port, RSTP_PPM_STATE_SENSING);
      }
      else if(port->mdelayWhile != rstpMigrateTime(port->context) &&
         !port->portEnabled)
      {
         
         rstpPpmChangeState(port, RSTP_PPM_STATE_CHECKING_RSTP);
      }
      else
      {
         
      }

      break;

   
   case RSTP_PPM_STATE_SELECTING_STP:
      
      if(port->mdelayWhile == 0 || !port->portEnabled || port->mcheck)
      {
         
         rstpPpmChangeState(port, RSTP_PPM_STATE_SENSING);
      }

      break;

   
   case RSTP_PPM_STATE_SENSING:
      
      if(port->sendRstp && port->rcvdStp)
      {
         
         rstpPpmChangeState(port, RSTP_PPM_STATE_SELECTING_STP);
      }
      else if(!port->portEnabled || port->mcheck ||
         (rstpVersion(port->context) && !port->sendRstp && port->rcvdRstp))
      {
         
         rstpPpmChangeState(port, RSTP_PPM_STATE_CHECKING_RSTP);
      }
      else
      {
         
      }

      break;

   
   default:
      
      rstpFsmError(port->context);
      break;
   }
}




void rstpPpmChangeState(RstpBridgePort *port, RstpPpmState newState)
{
   
   TRACE_VERBOSE(""Port %"" PRIu8 "": PPM state machine %s -> %s\r\n"",
      port->portIndex,
      rstpGetParamName(port->ppmState, rstpPpmStates, arraysize(rstpPpmStates)),
      rstpGetParamName(newState, rstpPpmStates, arraysize(rstpPpmStates)));

   
   port->ppmState = newState;

   
   
   switch(port->ppmState)
   {
   
   case RSTP_PPM_STATE_CHECKING_RSTP:
      
      port->mcheck = FALSE;

      
      
      
      port->sendRstp = rstpVersion(port->context);

      
      port->mdelayWhile = rstpMigrateTime(port->context);
      break;

   
   case RSTP_PPM_STATE_SELECTING_STP:
      
      port->sendRstp = FALSE;

      
      port->mdelayWhile = rstpMigrateTime(port->context);
      break;

   
   case RSTP_PPM_STATE_SENSING:
      
      port->rcvdRstp = FALSE;
      port->rcvdStp = FALSE;
      break;

   
   default:
      
      break;
   }

   
   port->context->busy = TRUE;
}

#endif
",64,1883,1185
"#define TRACE_LEVEL RSTP_TRACE_LEVEL


#include ""rstp/rstp.h""
#include ""rstp/rstp_fsm.h""
#include ""rstp/rstp_pst.h""
#include ""rstp/rstp_procedures.h""
#include ""rstp/rstp_misc.h""
#include ""debug.h""


#if (RSTP_SUPPORT == ENABLED)


const RstpParamName rstpPstStates[] =
{
   {RSTP_PST_STATE_DISCARDING, ""DISCARDING""},
   {RSTP_PST_STATE_LEARNING,   ""LEARNING""},
   {RSTP_PST_STATE_FORWARDING, ""FORWARDING""}
};




void rstpPstInit(RstpBridgePort *port)
{
   
   rstpPstChangeState(port, RSTP_PST_STATE_DISCARDING);
}




void rstpPstFsm(RstpBridgePort *port)
{
   
   
   switch(port->pstState)
   {
   
   case RSTP_PST_STATE_DISCARDING:
      
      if(port->learn)
      {
         
         rstpPstChangeState(port, RSTP_PST_STATE_LEARNING);
      }

      break;

   
   case RSTP_PST_STATE_LEARNING:
      
      if(port->forward)
      {
         
         rstpPstChangeState(port, RSTP_PST_STATE_FORWARDING);
      }
      else if(!port->learn)
      {
         
         rstpPstChangeState(port, RSTP_PST_STATE_DISCARDING);
      }
      else
      {
         
      }

      break;

   
   case RSTP_PST_STATE_FORWARDING:
      
      if(!port->forward)
      {
         
         rstpPstChangeState(port, RSTP_PST_STATE_DISCARDING);
      }

      break;

   
   default:
      
      rstpFsmError(port->context);
      break;
   }
}




void rstpPstChangeState(RstpBridgePort *port, RstpPstState newState)
{
   
   TRACE_VERBOSE(""Port %"" PRIu8 "": PST state machine %s -> %s\r\n"",
      port->portIndex,
      rstpGetParamName(port->pstState, rstpPstStates, arraysize(rstpPstStates)),
      rstpGetParamName(newState, rstpPstStates, arraysize(rstpPstStates)));

   
   port->pstState = newState;

   
   
   switch(port->pstState)
   {
   
   case RSTP_PST_STATE_DISCARDING:
      
      rstpDisableLearning(port);
      port->learning = FALSE;
      rstpDisableForwarding(port);
      port->forwarding = FALSE;
      break;

   
   case RSTP_PST_STATE_LEARNING:
      
      rstpEnableLearning(port);
      port->learning = TRUE;
      break;

   
   case RSTP_PST_STATE_FORWARDING:
      
      rstpEnableForwarding(port);
      port->forwarding = TRUE;
      break;

   
   default:
      
      break;
   }

   
   port->context->busy = TRUE;
}

#endif
",64,1884,967
"#define TRACE_LEVEL RSTP_TRACE_LEVEL


#include ""rstp/rstp.h""
#include ""rstp/rstp_conditions.h""
#include ""debug.h""


#if (RSTP_SUPPORT == ENABLED)




uint_t rstpAdminEdge(RstpBridgePort *port)
{
   
   return port->params.adminEdgePort;
}




uint_t rstpAutoEdge(RstpBridgePort *port)
{
   
   return port->params.autoEdgePort;
}




bool_t rstpAllSynced(RstpBridgeContext *context)
{
   uint_t i;
   bool_t res;
   RstpBridgePort *port;

   
   res = TRUE;

   
   
   
   
   for(i = 0; i < context->numPorts; i++)
   {
      
      port = &context->ports[i];

      
      if(!port->selected)
      {
         res = FALSE;
      }
      else if(port->role != port->selectedRole)
      {
         res = FALSE;
      }
      else if(port->updtInfo)
      {
         res = FALSE;
      }
      else if(!port->synced && port->role != STP_PORT_ROLE_ROOT)
      {
         res = FALSE;
      }
      else
      {
         
      }
   }

   
   return res;
}




uint_t rstpEdgeDelay(RstpBridgePort *port)
{
   uint_t value;

   
   
   if(port->operPointToPointMac)
   {
      value = rstpMigrateTime(port->context);
   }
   else
   {
      value = rstpMaxAge(port);
   }

   
   return value;
}




uint_t rstpForwardDelay(RstpBridgePort *port)
{
   uint_t value;

   
   
   if(port->sendRstp)
   {
      value = rstpHelloTime(port);
   }
   else
   {
      value = rstpFwdDelay(port);
   }

   
   return value;
}




uint_t rstpFwdDelay(RstpBridgePort *port)
{
   
   return port->designatedTimes.forwardDelay;
}




uint_t rstpHelloTime(RstpBridgePort *port)
{
   
   return port->designatedTimes.helloTime;
}




uint_t rstpMaxAge(RstpBridgePort *port)
{
   
   return port->designatedTimes.maxAge;
}




uint_t rstpMigrateTime(RstpBridgeContext *context)
{
   
   return context->params.migrateTime;
}




bool_t rstpReRooted(RstpBridgePort *port)
{
   uint_t i;
   bool_t res;
   RstpBridgeContext *context;

   
   res = TRUE;

   
   context = port->context;

   
   for(i = 0; i < context->numPorts; i++)
   {
      
      if(&context->ports[i] != port && context->ports[i].rrWhile != 0)
      {
         res = FALSE;
      }
   }

   
   
   return res;
}




bool_t rstpVersion(RstpBridgeContext *context)
{
   bool_t res;

   
   if(context->params.forceProtocolVersion >= RSTP_PROTOCOL_VERSION)
   {
      
      res = TRUE;
   }
   else
   {
      
      res = FALSE;
   }

   
   return res;
}




bool_t stpVersion(RstpBridgeContext *context)
{
   
   return !rstpVersion(context);
}




uint_t rstpTxHoldCount(RstpBridgeContext *context)
{
   
   return context->params.transmitHoldCount;
}

#endif
",64,1885,1094
"#define TRACE_LEVEL RSTP_TRACE_LEVEL


#include ""rstp/rstp.h""
#include ""rstp/rstp_fsm.h""
#include ""rstp/rstp_pti.h""
#include ""rstp/rstp_misc.h""
#include ""debug.h""


#if (RSTP_SUPPORT == ENABLED)


const RstpParamName rstpPtiStates[] =
{
   {RSTP_PTI_STATE_ONE_SECOND, ""ONE_SECOND""},
   {RSTP_PTI_STATE_TICK,       ""TICK""}
};




void rstpPtiInit(RstpBridgePort *port)
{
   
   
   rstpPtiChangeState(port, RSTP_PTI_STATE_ONE_SECOND);
}




void rstpPtiFsm(RstpBridgePort *port)
{
   
   
   switch(port->ptiState)
   {
   
   case RSTP_PTI_STATE_ONE_SECOND:
      
      if(port->tick)
      {
         rstpPtiChangeState(port, RSTP_PTI_STATE_TICK);
      }

      break;

   
   case RSTP_PTI_STATE_TICK:
      
      
      rstpPtiChangeState(port, RSTP_PTI_STATE_ONE_SECOND);
      break;

   
   default:
      
      rstpFsmError(port->context);
      break;
   }
}




void rstpPtiChangeState(RstpBridgePort *port, RstpPtiState newState)
{
   
   TRACE_VERBOSE(""Port %"" PRIu8 "": PTI state machine %s -> %s\r\n"",
      port->portIndex,
      rstpGetParamName(port->ptiState, rstpPtiStates, arraysize(rstpPtiStates)),
      rstpGetParamName(newState, rstpPtiStates, arraysize(rstpPtiStates)));

   
   port->ptiState = newState;

   
   
   switch(port->ptiState)
   {
   
   case RSTP_PTI_STATE_ONE_SECOND:
      
      port->tick = FALSE;
      break;

   
   case RSTP_PTI_STATE_TICK:
      
      rstpDecrementTimer(&port->helloWhen);
      rstpDecrementTimer(&port->tcWhile);
      rstpDecrementTimer(&port->fdWhile);
      rstpDecrementTimer(&port->rcvdInfoWhile);
      rstpDecrementTimer(&port->rrWhile);
      rstpDecrementTimer(&port->rbWhile);
      rstpDecrementTimer(&port->mdelayWhile);
      rstpDecrementTimer(&port->edgeDelayWhile);
      rstpDecrementTimer(&port->txCount);
      break;

   
   default:
      
      break;
   }

   
   port->context->busy = TRUE;
}

#endif
",64,1886,844
"#define TRACE_LEVEL RSTP_TRACE_LEVEL


#include ""rstp/rstp.h""
#include ""rstp/rstp_fsm.h""
#include ""rstp/rstp_pim.h""
#include ""rstp/rstp_procedures.h""
#include ""rstp/rstp_misc.h""
#include ""debug.h""


#if (RSTP_SUPPORT == ENABLED)


const RstpParamName rstpPimStates[] =
{
   {RSTP_PIM_STATE_DISABLED,            ""DISABLED""},
   {RSTP_PIM_STATE_AGED,                ""AGED""},
   {RSTP_PIM_STATE_UPDATE,              ""UPDATE""},
   {RSTP_PIM_STATE_SUPERIOR_DESIGNATED, ""SUPERIOR_DESIGNATED""},
   {RSTP_PIM_STATE_REPEATED_DESIGNATED, ""REPEATED_DESIGNATED""},
   {RSTP_PIM_STATE_INFERIOR_DESIGNATED, ""INFERIOR_DESIGNATED""},
   {RSTP_PIM_STATE_NOT_DESIGNATED,      ""NOT_DESIGNATED""},
   {RSTP_PIM_STATE_OTHER,               ""OTHER""},
   {RSTP_PIM_STATE_CURRENT,             ""CURRENT""},
   {RSTP_PIM_STATE_RECEIVE,             ""RECEIVE""}
};




void rstpPimInit(RstpBridgePort *port)
{
   
   rstpPimChangeState(port, RSTP_PIM_STATE_DISABLED);
}




void rstpPimFsm(RstpBridgePort *port)
{
   
   if(!port->portEnabled && port->infoIs != RSTP_INFO_IS_DISABLED)
   {
      
      
      rstpPimChangeState(port, RSTP_PIM_STATE_DISABLED);
   }
   else
   {
      
      
      switch(port->pimState)
      {
      
      case RSTP_PIM_STATE_DISABLED:
         
         if(port->rcvdMsg)
         {
            
            rstpPimChangeState(port, RSTP_PIM_STATE_DISABLED);
         }
         else if(port->portEnabled)
         {
            
            rstpPimChangeState(port, RSTP_PIM_STATE_AGED);
         }
         else
         {
            
         }

         break;

      
      case RSTP_PIM_STATE_AGED:
         
         if(port->selected && port->updtInfo)
         {
            
            rstpPimChangeState(port, RSTP_PIM_STATE_UPDATE);
         }

         break;

      
      
      case RSTP_PIM_STATE_UPDATE:
      case RSTP_PIM_STATE_SUPERIOR_DESIGNATED:
      case RSTP_PIM_STATE_REPEATED_DESIGNATED:
      case RSTP_PIM_STATE_INFERIOR_DESIGNATED:
      case RSTP_PIM_STATE_NOT_DESIGNATED:
      case RSTP_PIM_STATE_OTHER:
         
         rstpPimChangeState(port, RSTP_PIM_STATE_CURRENT);
         break;

      
      case RSTP_PIM_STATE_CURRENT:
         
         if(port->selected && port->updtInfo)
         {
            
            rstpPimChangeState(port, RSTP_PIM_STATE_UPDATE);
         }
         else if(port->infoIs == RSTP_INFO_IS_RECEIVED &&
            port->rcvdInfoWhile == 0 && !port->updtInfo && !port->rcvdMsg)
         {
            
            rstpPimChangeState(port, RSTP_PIM_STATE_AGED);
         }
         else if(port->rcvdMsg && !port->updtInfo)
         {
            
            rstpPimChangeState(port, RSTP_PIM_STATE_RECEIVE);
         }
         else
         {
            
         }

         break;

      
      case RSTP_PIM_STATE_RECEIVE:
         
         if(port->rcvdInfo == RSTP_RCVD_INFO_SUPERIOR_DESIGNATED)
         {
            
            rstpPimChangeState(port, RSTP_PIM_STATE_SUPERIOR_DESIGNATED);
         }
         else if(port->rcvdInfo == RSTP_RCVD_INFO_REPEATED_DESIGNATED)
         {
            
            rstpPimChangeState(port, RSTP_PIM_STATE_REPEATED_DESIGNATED);
         }
         else if(port->rcvdInfo == RSTP_RCVD_INFO_INFERIOR_DESIGNATED)
         {
            
            rstpPimChangeState(port, RSTP_PIM_STATE_INFERIOR_DESIGNATED);
         }
         else if(port->rcvdInfo == RSTP_RCVD_INFO_INFERIOR_ROOT_ALTERNATE)
         {
            
            rstpPimChangeState(port, RSTP_PIM_STATE_NOT_DESIGNATED);
         }
         else if(port->rcvdInfo == RSTP_RCVD_INFO_OTHER)
         {
            
            rstpPimChangeState(port, RSTP_PIM_STATE_OTHER);
         }
         else
         {
            
         }

         break;

      
      default:
         
         rstpFsmError(port->context);
         break;
      }
   }
}




void rstpPimChangeState(RstpBridgePort *port, RstpPimState newState)
{
   
   TRACE_VERBOSE(""Port %"" PRIu8 "": PIM state machine %s -> %s\r\n"",
      port->portIndex,
      rstpGetParamName(port->pimState, rstpPimStates, arraysize(rstpPimStates)),
      rstpGetParamName(newState, rstpPimStates, arraysize(rstpPimStates)));

   
   port->pimState = newState;

   
   
   switch(port->pimState)
   {
   
   case RSTP_PIM_STATE_DISABLED:
      
      port->rcvdMsg = FALSE;
      port->proposing = FALSE;
      port->proposed = FALSE;
      port->agree = FALSE;
      port->agreed = FALSE;
      port->rcvdInfoWhile = 0;
      port->infoIs = RSTP_INFO_IS_DISABLED;
      port->reselect = TRUE;
      port->selected = FALSE;
      break;

   
   case RSTP_PIM_STATE_AGED:
      
      port->infoIs = RSTP_INFO_IS_AGED;
      port->reselect = TRUE;
      port->selected = FALSE;
      break;

   
   case RSTP_PIM_STATE_UPDATE:
      port->proposing = FALSE;
      port->proposed = FALSE;

      
      port->agreed = port->agreed &&
         rstpBetterOrSameInfo(port, RSTP_INFO_IS_MINE);

#if defined(RSTP_PIM_WORKAROUND_1)
      
      if(port->forward)
      {
         port->agreed = port->sendRstp;
      }
#endif

      port->synced = port->synced && port->agreed;
      port->portPriority = port->designatedPriority;
      port->portTimes = port->designatedTimes;
      port->updtInfo = FALSE;
      port->infoIs = RSTP_INFO_IS_MINE;
      port->newInfo = TRUE;
      break;

   
   case RSTP_PIM_STATE_SUPERIOR_DESIGNATED:
      port->agreed = FALSE;
      port->proposing = FALSE;
      rstpRecordProposal(port);
      rstpSetTcFlags(port);

      
      port->agree = port->agree &&
         rstpBetterOrSameInfo(port, RSTP_INFO_IS_RECEIVED);

      rstpRecordPriority(port);
      rstpRecordTimes(port);
      rstpUpdtRcvdInfoWhile(port);
      port->infoIs = RSTP_INFO_IS_RECEIVED;
      port->reselect = TRUE;
      port->selected = FALSE;
      port->rcvdMsg = FALSE;
      break;

   
   case RSTP_PIM_STATE_REPEATED_DESIGNATED:
      rstpRecordProposal(port);
      rstpSetTcFlags(port);
      rstpUpdtRcvdInfoWhile(port);
      port->rcvdMsg = FALSE;
      break;

   
   case RSTP_PIM_STATE_INFERIOR_DESIGNATED:
      rstpRecordDispute(port);
      port->rcvdMsg = FALSE;
      break;

   
   case RSTP_PIM_STATE_NOT_DESIGNATED:
      rstpRecordAgreement(port);
      rstpSetTcFlags(port);
      port->rcvdMsg = FALSE;
      break;

   
   case RSTP_PIM_STATE_OTHER:
      port->rcvdMsg = FALSE;
      break;

   
   case RSTP_PIM_STATE_CURRENT:
      
      break;

   
   case RSTP_PIM_STATE_RECEIVE:
      port->rcvdInfo = rstpRcvInfo(port);
      break;

   
   default:
      
      break;
   }

   
   port->context->busy = TRUE;
}

#endif
",64,1887,2642
"#define TRACE_LEVEL TRACE_LEVEL_OFF




#include ""os_port.h""
#include ""os_port_freertos.h""
#include ""debug.h""




void osInitKernel(void)
{
}




void osStartKernel(void)
{
   
   vTaskStartScheduler();
}




OsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,
   void *param, size_t stackSize, int_t priority)
{
   portBASE_TYPE status;
   TaskHandle_t task = NULL;

   
   status = xTaskCreate((TaskFunction_t) taskCode, name, stackSize, param,
      priority, &task);

   
   if(status == pdPASS)
      return task;
   else
      return NULL;
}




void osDeleteTask(OsTask *task)
{
   
   vTaskDelete((TaskHandle_t) task);
}




void osDelayTask(systime_t delay)
{
   
   vTaskDelay(OS_MS_TO_SYSTICKS(delay));
}




void osSwitchTask(void)
{
   
   taskYIELD();
}




void osSuspendAllTasks(void)
{
   
   if(xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
   {
      
      vTaskSuspendAll();
   }
}




void osResumeAllTasks(void)
{
   
   if(xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
   {
      
      xTaskResumeAll();
   }
}




bool_t osCreateEvent(OsEvent *event)
{
#if (configSUPPORT_STATIC_ALLOCATION == 1)
   
   event->handle = xSemaphoreCreateBinaryStatic(&event->buffer);
#else
   
   event->handle = xSemaphoreCreateBinary();
#endif

   
   if(event->handle != NULL)
      return TRUE;
   else
      return FALSE;
}




void osDeleteEvent(OsEvent *event)
{
   
   if(event->handle != NULL)
   {
      
      vSemaphoreDelete(event->handle);
   }
}




void osSetEvent(OsEvent *event)
{
   
   xSemaphoreGive(event->handle);
}




void osResetEvent(OsEvent *event)
{
   
   xSemaphoreTake(event->handle, 0);
}




bool_t osWaitForEvent(OsEvent *event, systime_t timeout)
{
   portBASE_TYPE ret;

   
   if(timeout == INFINITE_DELAY)
   {
      
      ret = xSemaphoreTake(event->handle, portMAX_DELAY);
   }
   else
   {
      
      ret = xSemaphoreTake(event->handle, OS_MS_TO_SYSTICKS(timeout));
   }

   
   return ret;
}




bool_t osSetEventFromIsr(OsEvent *event)
{
   portBASE_TYPE flag = FALSE;

   
   xSemaphoreGiveFromISR(event->handle, &flag);

   
   return flag;
}




bool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)
{
#if (configSUPPORT_STATIC_ALLOCATION == 1)
   
   semaphore->handle = xSemaphoreCreateCountingStatic(count, count,
      &semaphore->buffer);
#else
   
   semaphore->handle = xSemaphoreCreateCounting(count, count);
#endif

   
   if(semaphore->handle != NULL)
      return TRUE;
   else
      return FALSE;
}




void osDeleteSemaphore(OsSemaphore *semaphore)
{
   
   if(semaphore->handle != NULL)
   {
      
      vSemaphoreDelete(semaphore->handle);
   }
}




bool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)
{
   portBASE_TYPE ret;

   
   if(timeout == INFINITE_DELAY)
   {
      
      ret = xSemaphoreTake(semaphore->handle, portMAX_DELAY);
   }
   else
   {
      
      ret = xSemaphoreTake(semaphore->handle, OS_MS_TO_SYSTICKS(timeout));
   }

   
   return ret;
}




void osReleaseSemaphore(OsSemaphore *semaphore)
{
   
   xSemaphoreGive(semaphore->handle);
}




bool_t osCreateMutex(OsMutex *mutex)
{
#if (configSUPPORT_STATIC_ALLOCATION == 1)
   
   mutex->handle = xSemaphoreCreateMutexStatic(&mutex->buffer);
#else
   
   mutex->handle = xSemaphoreCreateMutex();
#endif

   
   if(mutex->handle != NULL)
      return TRUE;
   else
      return FALSE;
}




void osDeleteMutex(OsMutex *mutex)
{
   
   if(mutex->handle != NULL)
   {
      
      vSemaphoreDelete(mutex->handle);
   }
}




void osAcquireMutex(OsMutex *mutex)
{
   
   xSemaphoreTake(mutex->handle, portMAX_DELAY);
}




void osReleaseMutex(OsMutex *mutex)
{
   
   xSemaphoreGive(mutex->handle);
}




systime_t osGetSystemTime(void)
{
   systime_t time;

   
   time = xTaskGetTickCount();

   
   return OS_SYSTICKS_TO_MS(time);
}




void *osAllocMem(size_t size)
{
   void *p;

   
   p = pvPortMalloc(size);

   
   TRACE_DEBUG(""Allocating %"" PRIuSIZE "" bytes at 0x%08"" PRIXPTR ""\r\n"", size, (uintptr_t) p);

   
   return p;
}




void osFreeMem(void *p)
{
   
   if(p != NULL)
   {
      
      TRACE_DEBUG(""Freeing memory at 0x%08"" PRIXPTR ""\r\n"", (uintptr_t) p);

      
      vPortFree(p);
   }
}


#if 0



void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName)
{
   (void) pcTaskName;
   (void) pxTask;

   taskDISABLE_INTERRUPTS();
   while(1);
}




void vAssertCalled(const char *pcFile, unsigned long ulLine)
{
   volatile unsigned long ul = 0;

   (void) pcFile;
   (void) ulLine;

   taskENTER_CRITICAL();

   
   while(ul == 0)
   {
      portNOP();
   }

   taskEXIT_CRITICAL();
}

#endif
",64,1888,1927
"#define TRACE_LEVEL SNMP_TRACE_LEVEL


#include ""core/net.h""
#include ""mibs/mib_common.h""
#include ""mibs/bridge_mib_module.h""
#include ""mibs/bridge_mib_impl.h""
#include ""mibs/bridge_mib_impl_base.h""
#include ""core/crypto.h""
#include ""encoding/asn1.h""
#include ""encoding/oid.h""
#include ""stp/stp.h""
#include ""stp/stp_mgmt.h""
#include ""rstp/rstp.h""
#include ""rstp/rstp_mgmt.h""
#include ""debug.h""


#if (BRIDGE_MIB_SUPPORT == ENABLED)




error_t bridgeMibGetDot1dBaseBridgeAddress(const MibObject *object, const uint8_t *oid,
   size_t oidLen, MibVariant *value, size_t *valueLen)
{
   error_t error;
   MacAddr bridgeAddr;

   
   if(*valueLen < sizeof(MacAddr))
      return ERROR_BUFFER_OVERFLOW;

   
   bridgeAddr = MAC_UNSPECIFIED_ADDR;

#if (STP_SUPPORT == ENABLED)
   
   if(bridgeMibBase.stpBridgeContext != NULL)
   {
      
      error = stpMgmtGetBridgeAddr(bridgeMibBase.stpBridgeContext,
         &bridgeAddr);
   }
   else
#endif
#if (RSTP_SUPPORT == ENABLED)
   
   if(bridgeMibBase.rstpBridgeContext != NULL)
   {
      
      error = rstpMgmtGetBridgeAddr(bridgeMibBase.rstpBridgeContext,
         &bridgeAddr);
   }
   else
#endif
   
   {
      
      error = ERROR_READ_FAILED;
   }

   
   if(!error)
   {
      
      macCopyAddr(value->octetString, &bridgeAddr);
      
      *valueLen = sizeof(MacAddr);
   }

   
   return error;
}




error_t bridgeMibGetDot1dBaseNumPorts(const MibObject *object, const uint8_t *oid,
   size_t oidLen, MibVariant *value, size_t *valueLen)
{
   error_t error;
   uint_t numPorts;

   
   numPorts = 0;

#if (STP_SUPPORT == ENABLED)
   
   if(bridgeMibBase.stpBridgeContext != NULL)
   {
      
      error = stpMgmtGetNumPorts(bridgeMibBase.stpBridgeContext, &numPorts);
   }
   else
#endif
#if (RSTP_SUPPORT == ENABLED)
   
   if(bridgeMibBase.rstpBridgeContext != NULL)
   {
      
      error = rstpMgmtGetNumPorts(bridgeMibBase.rstpBridgeContext, &numPorts);
   }
   else
#endif
   
   {
      
      error = ERROR_READ_FAILED;
   }

   
   if(!error)
   {
      
      value->integer = numPorts;
   }

   
   return error;
}




error_t bridgeMibGetDot1dBaseType(const MibObject *object, const uint8_t *oid,
   size_t oidLen, MibVariant *value, size_t *valueLen)
{
   
   value->integer = bridgeMibBase.dot1dBaseType;

   
   return NO_ERROR;
}




error_t bridgeMibGetDot1dBasePortEntry(const MibObject *object, const uint8_t *oid,
   size_t oidLen, MibVariant *value, size_t *valueLen)
{
   error_t error;
   size_t n;
   uint_t portIndex;
   uint16_t dot1dBasePort;

   
   n = object->oidLen;

   
   error = mibDecodePort(oid, oidLen, &n, &dot1dBasePort);
   
   if(error)
      return error;

   
   if(n != oidLen)
      return ERROR_INSTANCE_NOT_FOUND;

   
   portIndex = bridgeMibGetPortIndex(dot1dBasePort);
   
   if(portIndex == 0)
      return ERROR_INSTANCE_NOT_FOUND;

   
   if(!strcmp(object->name, ""dot1dBasePort""))
   {
      
      
      value->integer = dot1dBasePort;
   }
   
   else if(!strcmp(object->name, ""dot1dBasePortIfIndex""))
   {
      
      
      value->integer = portIndex;
   }
   
   else if(!strcmp(object->name, ""dot1dBasePortCircuit""))
   {
      
      if(*valueLen >= sizeof(uint8_t))
      {
         
         
         
         value->oid[0] = 0;

         
         *valueLen = sizeof(uint8_t);
      }
      else
      {
         
         error = ERROR_BUFFER_OVERFLOW;
      }
   }
   
   else if(!strcmp(object->name, ""dot1dBasePortDelayExceededDiscards""))
   {
      
      
      
      value->counter32 = 0;
   }
   
   else if(!strcmp(object->name, ""dot1dBasePortMtuExceededDiscards""))
   {
      
      
      value->counter32 = 0;
   }
   
   else
   {
      
      error = ERROR_OBJECT_NOT_FOUND;
   }

   
   return error;
}




error_t bridgeMibGetNextDot1dBasePortEntry(const MibObject *object, const uint8_t *oid,
   size_t oidLen, uint8_t *nextOid, size_t *nextOidLen)
{
   error_t error;
   uint_t i;
   size_t n;
   uint_t numPorts;
   uint16_t portNum;
   uint16_t curPortNum;

   
   portNum = 0;

   
   if(*nextOidLen < object->oidLen)
      return ERROR_BUFFER_OVERFLOW;

   
   osMemcpy(nextOid, object->oid, object->oidLen);

   
   numPorts = bridgeMibGetNumPorts();

   
   for(i = 1; i <= numPorts; i++)
   {
      
      curPortNum = bridgeMibGetPortNum(i);

      
      n = object->oidLen;

      
      error = mibEncodeIndex(nextOid, *nextOidLen, &n, curPortNum);
      
      if(error)
         return error;

      
      
      if(oidComp(nextOid, n, oid, oidLen) > 0)
      {
         
         
         if(portNum == 0 || curPortNum < portNum)
         {
            portNum = curPortNum;
         }
      }
   }

   
   
   if(portNum == 0)
      return ERROR_OBJECT_NOT_FOUND;

   
   n = object->oidLen;

   
   error = mibEncodeIndex(nextOid, *nextOidLen, &n, portNum);
   
   if(error)
      return error;

   
   *nextOidLen = n;
   
   return NO_ERROR;
}

#endif
",64,1889,2021
"#define TRACE_LEVEL SSH_TRACE_LEVEL


#include ""ssh/ssh.h""
#include ""ssh/ssh_server.h""
#include ""ssh/ssh_server_misc.h""
#include ""ssh/ssh_transport.h""
#include ""ssh/ssh_channel.h""
#include ""ssh/ssh_misc.h""
#include ""debug.h""


#if (SSH_SUPPORT == ENABLED && SSH_SERVER_SUPPORT == ENABLED)




void sshServerTick(SshServerContext *context)
{
   error_t error;
   uint_t i;
   systime_t time;
   SshConnection *connection;

   
   time = osGetSystemTime();

   
   for(i = 0; i < context->sshContext.numConnections; i++)
   {
      
      connection = &context->sshContext.connections[i];

      
      if(connection->state != SSH_CONN_STATE_CLOSED)
      {
         
         if(timeCompare(time, connection->timestamp + SSH_SERVER_TIMEOUT) >= 0)
         {
            
            TRACE_INFO(""SSH server: Closing inactive connection...\r\n"");

            
            error = sshSendDisconnect(connection, SSH_DISCONNECT_BY_APPLICATION,
               ""Session idle timeout"");

            
            if(error)
            {
               
               sshCloseConnection(connection);
            }
         }
      }
   }
}




void sshServerAcceptConnection(SshServerContext *context)
{
   Socket *socket;
   IpAddr clientIpAddr;
   uint16_t clientPort;
   SshConnection *connection;

   
   socket = socketAccept(context->socket, &clientIpAddr, &clientPort);

   
   if(socket != NULL)
   {
      
      connection = sshOpenConnection(&context->sshContext, socket);

      
      
      if(connection != NULL)
      {
         
         TRACE_INFO(""SSH server: Connection established with client %s port %""
            PRIu16 ""...\r\n"", ipAddrToString(&clientIpAddr, NULL), clientPort);

         
         socketSetTimeout(socket, 0);
      }
      else
      {
         
         TRACE_INFO(""SSH Server: Connection refused with client %s port %""
            PRIu16 ""...\r\n"", ipAddrToString(&clientIpAddr, NULL), clientPort);

         
         socketClose(socket);
      }
   }
}

#endif
",64,1890,662
"#define TRACE_LEVEL STP_TRACE_LEVEL


#include ""stp/stp.h""
#include ""stp/stp_conditions.h""
#include ""stp/stp_misc.h""
#include ""debug.h""


#if (STP_SUPPORT == ENABLED)




bool_t stpRootBridge(StpBridgeContext *context)
{
   bool_t res;

   
   
   if(stpCompareBridgeId(&context->designatedRoot, &context->bridgeId) == 0)
   {
      res = TRUE;
   }
   else
   {
      res = FALSE;
   }

   
   return res;
}




bool_t stpDesignatedBridge(StpBridgeContext *context)
{
   uint_t i;
   bool_t res;
   StpBridgePort *port;

   
   res = FALSE;

   
   for(i = 0; i < context->numPorts; i++)
   {
      
      port = &context->ports[i];

      
      
      if(stpCompareBridgeId(&port->designatedBridge, &context->bridgeId) == 0)
      {
         res = TRUE;
      }
   }

   
   
   return res;
}




bool_t stpRootPort(StpBridgePort *port)
{
   bool_t res;

   
   if(stpComparePortNum(port->portId, port->context->rootPort) == 0)
   {
      res = TRUE;
   }
   else
   {
      res = FALSE;
   }

   
   return res;
}




bool_t stpDesignatedPort(StpBridgePort *port)
{
   bool_t res;
   StpBridgeContext *context;

   
   context = port->context;

   
   
   
   if(stpCompareBridgeId(&port->designatedBridge, &context->bridgeId) == 0 &&
      port->designatedPort == port->portId)
   {
      res = TRUE;
   }
   else
   {
      res = FALSE;
   }

   
   
   return res;
}




bool_t stpSupersedesPortInfo(StpBridgePort *port, const StpBpdu *bpdu)
{
   bool_t res;
   StpBridgeId rootId;
   StpBridgeId bridgeId;
   StpBridgeContext *context;

   
   context = port->context;

   
   
   rootId.priority = ntohs(bpdu->rootId.priority);
   rootId.addr = bpdu->rootId.addr;
   bridgeId.priority = ntohs(bpdu->bridgeId.priority);
   bridgeId.addr = bpdu->bridgeId.addr;

   
   res = FALSE;

   
   
   if(stpCompareBridgeId(&rootId, &port->designatedRoot) < 0)
   {
      
      
      res = TRUE;
   }
   else if(stpCompareBridgeId(&rootId, &port->designatedRoot) > 0)
   {
   }
   else if(ntohl(bpdu->rootPathCost) < port->designatedCost)
   {
      
      
      
      res = TRUE;
   }
   else if(ntohl(bpdu->rootPathCost) > port->designatedCost)
   {
   }
   else if(stpCompareBridgeId(&bridgeId, &port->designatedBridge) < 0)
   {
      
      
      
      res = TRUE;
   }
   else if(stpCompareBridgeId(&bridgeId, &port->designatedBridge) > 0)
   {
   }
   else
   {
      
      
      
      if(stpCompareBridgeId(&bridgeId, &context->bridgeId) != 0)
      {
         
         
         res = TRUE;
      }
      else if(ntohs(bpdu->portId) <= port->designatedPort)
      {
         
         
         res = TRUE;
      }
      else
      {
      }
   }

   
   return res;
}

#endif
",64,1891,1104
"#define TRACE_LEVEL ACME_TRACE_LEVEL


#include ""acme/acme_client.h""
#include ""acme/acme_client_certificate.h""
#include ""acme/acme_client_jose.h""
#include ""acme/acme_client_misc.h""
#include ""pkix/pem_import.h""
#include ""encoding/base64url.h""
#include ""jansson.h""
#include ""jansson_private.h""
#include ""debug.h""


#if (ACME_CLIENT_SUPPORT == ENABLED)




error_t acmeClientSendDownloadCertRequest(AcmeClientContext *context,
   char_t *buffer, size_t size, size_t *length)
{
   error_t error;

   
   error = NO_ERROR;

   
   while(!error)
   {
      
      if(context->requestState == ACME_REQ_STATE_INIT)
      {
         
         TRACE_DEBUG(""\r\n"");
         TRACE_DEBUG(""###############################################################################\r\n"");
         TRACE_DEBUG(""## DOWNLOAD CERTIFICATE #######################################################\r\n"");
         TRACE_DEBUG(""###############################################################################\r\n"");
         TRACE_DEBUG(""\r\n"");

         
         context->requestState = ACME_REQ_STATE_FORMAT_BODY;
      }
      else if(context->requestState == ACME_REQ_STATE_FORMAT_BODY)
      {
         
         error = acmeClientFormatDownloadCertRequest(context);

         
         if(!error)
         {
            
            context->requestState = ACME_REQ_STATE_FORMAT_HEADER;
         }
      }
      else if(context->requestState == ACME_REQ_STATE_FORMAT_HEADER)
      {
         
         
         
         error = acmeClientFormatRequestHeader(context, ""POST"",
            context->order.certificate);

         
         if(!error)
         {
            
            context->requestState = ACME_REQ_STATE_SEND_HEADER;
         }
      }
      else if(context->requestState == ACME_REQ_STATE_SEND_HEADER ||
         context->requestState == ACME_REQ_STATE_SEND_BODY ||
         context->requestState == ACME_REQ_STATE_RECEIVE_HEADER ||
         context->requestState == ACME_REQ_STATE_PARSE_HEADER ||
         context->requestState == ACME_REQ_STATE_RECEIVE_BODY ||
         context->requestState == ACME_REQ_STATE_CLOSE_BODY)
      {
         
         error = acmeClientSendRequest(context);
      }
      else if(context->requestState == ACME_REQ_STATE_PARSE_BODY)
      {
         
         error = acmeClientParseDownloadCertResponse(context, buffer, size,
            length);

         
         context->requestState = ACME_REQ_STATE_INIT;
         break;
      }
      else
      {
         
         error = ERROR_WRONG_STATE;
      }
   }

   
   return error;
}




error_t acmeClientFormatDownloadCertRequest(AcmeClientContext *context)
{
   error_t error;
   size_t n;
   char_t *protected;
   const char_t *payload;

   
   payload = """";

   
   protected = context->buffer;

   
   error = acmeClientFormatJwsProtectedHeader(&context->accountKey,
      context->account.url, context->nonce, context->order.certificate,
      protected, &n);

   
   if(!error)
   {
      
      error = jwsCreate(context->prngAlgo, context->prngContext, protected,
         payload, context->accountKey.alg, context->accountKey.crv,
         context->accountKey.privateKey, context->buffer, &context->bufferLen);
   }

   
   return error;
}




error_t acmeClientParseDownloadCertResponse(AcmeClientContext *context,
   char_t *buffer, size_t size, size_t *length)
{
   error_t error;
   size_t n;

   
   error = NO_ERROR;

   
   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))
      return ERROR_UNEXPECTED_STATUS;

   
   
   if(context->nonce[0] == '\0')
      return ERROR_INVALID_RESPONSE;

   
   if(osStrcasecmp(context->contentType, ""application/pem-certificate-chain""))
      return ERROR_INVALID_RESPONSE;

   
   if(context->bufferLen >= ACME_CLIENT_BUFFER_SIZE)
      return ERROR_RESPONSE_TOO_LARGE;

   
   error = pemImportCertificate(context->buffer, context->bufferLen, NULL,
      &n, NULL);
   
   if(error)
      return ERROR_INVALID_RESPONSE;

   
   if(context->bufferLen > size)
      return ERROR_BUFFER_OVERFLOW;

   
   osMemcpy(buffer, context->buffer, context->bufferLen);

   
   *length = context->bufferLen;

   
   return error;
}




error_t acmeClientSendRevokeCertRequest(AcmeClientContext *context,
   const char_t *cert, size_t certLen, AcmeReasonCode reason)
{
   error_t error;

   
   error = NO_ERROR;

   
   while(!error)
   {
      
      if(context->requestState == ACME_REQ_STATE_INIT)
      {
         
         TRACE_DEBUG(""\r\n"");
         TRACE_DEBUG(""###############################################################################\r\n"");
         TRACE_DEBUG(""## REVOKE CERTIFICATE #########################################################\r\n"");
         TRACE_DEBUG(""###############################################################################\r\n"");
         TRACE_DEBUG(""\r\n"");

         
         context->requestState = ACME_REQ_STATE_FORMAT_BODY;
      }
      else if(context->requestState == ACME_REQ_STATE_FORMAT_BODY)
      {
         
         error = acmeClientFormatRevokeCertRequest(context, cert, certLen, reason);

         
         if(!error)
         {
            
            context->requestState = ACME_REQ_STATE_FORMAT_HEADER;
         }
      }
      else if(context->requestState == ACME_REQ_STATE_FORMAT_HEADER)
      {
         
         
         
         error = acmeClientFormatRequestHeader(context, ""POST"",
            context->directory.revokeCert);

         
         if(!error)
         {
            
            context->requestState = ACME_REQ_STATE_SEND_HEADER;
         }
      }
      else if(context->requestState == ACME_REQ_STATE_SEND_HEADER ||
         context->requestState == ACME_REQ_STATE_SEND_BODY ||
         context->requestState == ACME_REQ_STATE_RECEIVE_HEADER ||
         context->requestState == ACME_REQ_STATE_PARSE_HEADER ||
         context->requestState == ACME_REQ_STATE_RECEIVE_BODY ||
         context->requestState == ACME_REQ_STATE_CLOSE_BODY)
      {
         
         error = acmeClientSendRequest(context);
      }
      else if(context->requestState == ACME_REQ_STATE_PARSE_BODY)
      {
         
         error = acmeClientParseRevokeCertResponse(context);

         
         context->requestState = ACME_REQ_STATE_INIT;
         break;
      }
      else
      {
         
         error = ERROR_WRONG_STATE;
      }
   }

   
   return error;
}




error_t acmeClientFormatRevokeCertRequest(AcmeClientContext *context,
   const char_t *cert, size_t certLen, AcmeReasonCode reason)
{
   error_t error;
   int_t ret;
   size_t n;
   char_t *protected;
   char_t *payload;
   json_t *payloadObj;

   
   error = pemImportCertificate(cert, certLen, (uint8_t *) context->buffer,
      &n, NULL);
   
   if(error)
      return error;

   
   base64urlEncode(context->buffer, n, context->buffer, &n);

   
   payloadObj = json_object();

   
   ret = json_object_set_new(payloadObj, ""certificate"",
      json_string(context->buffer));

   
   ret |= json_object_set_new(payloadObj, ""reason"",
      json_integer((json_int_t) reason));

   
   if(ret == 0)
   {
      
      payload = json_dumps(payloadObj, JSON_COMPACT);
   }
   else
   {
      
      payload = NULL;
   }

   
   if(payload != NULL)
   {
      
      protected = context->buffer;

      
      error = acmeClientFormatJwsProtectedHeader(&context->accountKey,
         context->account.url, context->nonce, context->directory.revokeCert,
         protected, &n);

      
      if(!error)
      {
         
         error = jwsCreate(context->prngAlgo, context->prngContext, protected,
            payload, context->accountKey.alg, context->accountKey.crv,
            context->accountKey.privateKey, context->buffer, &context->bufferLen);
      }

      
      jsonp_free(payload);
   }
   else
   {
      
      error = ERROR_FAILURE;
   }

   
   json_decref(payloadObj);

   
   return error;
}




error_t acmeClientParseRevokeCertResponse(AcmeClientContext *context)
{
   
   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))
      return ERROR_UNEXPECTED_STATUS;

   
   
   if(context->nonce[0] == '\0')
      return ERROR_INVALID_RESPONSE;

   
   return NO_ERROR;
}

#endif
",64,1892,2685
"int minimo(int a[], int dim)
    {

    int valoreMinimo = a[0], locazione = 0;

    for(int i=0; i < dim; i++)
    {
        if ( a[i] < valoreMinimo ) 
        {
            valoreMinimo = a[i];
            locazione = i;
        }
    } 
    
    return locazione;
}

void delta_minimo(int a[], int n, int dim)
{
    int differenza[dim];
    int risultato;


    for(int i = 0; i<dim; i++)
    {
        if(abs(a[i]) > n)
        {
            differenza[i] = abs(a[i]) - n;
            
        }   else   {

            differenza[i] = n - abs(a[i]);
        }         
    }

    risultato = minimo(differenza, dim); 
    
    
    printf(""----------------------------\nIntero in valore assoluto piÃ¹ vicino a quello fornito: %d"", a[risultato]);

}

void stampa_vettore(int a[], int dim)
{

    for(int i=0; i<dim; i++)
    {
        printf(""a[%d] = "", i);
        printf(""%d\n"", a[i]);
    }
}

int main(void) {
    int dim;
    int i = 0;
    int n, risultato;

    printf(""Inserire dimensione array: ""); 
    scanf(""%d"", &dim);
    int a[dim];

    
    for(int i=0; i<dim; i++)
    {
        printf(""a[%d] = "", i);
        scanf(""%d"", &a[i]);
    }
    
    printf(""\n"");

    printf(""Inserisci il numero che vuoi ricercare nell'array: "");
    scanf(""%d"", &n);

    printf(""----------------------------\nVettore inserito:\n"");
    stampa_vettore(a, dim);
    printf(""\n"");
    delta_minimo(a, n, dim);
    
    

    return 0;

}",65,1893,566
"int pot_ricorsivo(int base, int esponente);

int main(void) {
  int a, b;
  int risultato;

  printf(""Base: "");
  scanf(""%d"", &a);

  printf(""Esponente: "");
  scanf(""%d"", &b);

  if (b > 0) {
    risultato = pot_ricorsivo(a,b);
    printf( ""Risultato: %d\n"", risultato ); 
  } else {
    printf(""Inserisci una potenza maggiore di 0"");
  }
 
  return 0;
}

int pot_ricorsivo(int base, int esponente)
{

    if (esponente == 1)
          return base;
 
    return base*pot_ricorsivo(base, esponente-1);
}",65,1894,212
"void scambia(int v[], int dim, int i, int j){

    if(dim > 0)
    {
        if((i >= 0) && (i <= dim) && (j >= 0) && (j <= dim))
        {
            int tmp = v[i];
            v[i] = v[j];
            v[j] = tmp;
        }
    }
}

int minimo(int a[], int dim)
    {

    int valoreMinimo = a[0], locazione = 0, i;

    for(i=0; i < dim; i++)
    {
        if ( a[i] < valoreMinimo ) 
        {
            valoreMinimo = a[i];
            locazione = i;
        }
    } 
    
    return locazione;
}

void stampa_vettore(int a[], int dim)
{

    for(int i=0; i<dim; i++)
    {
        printf(""a[%d] = "", i);
        printf(""%d\n"", a[i]);
    }
}

int main(void) {
    int dim, indice;
    int i = 0;

    printf(""Inserire dimensione array: ""); 
    scanf(""%d"", &dim);
    int a[dim];

    
    for(int i=0; i<dim; i++)
    {
        printf(""a[%d] = "", i);
        scanf(""%d"", &a[i]);
    }
    
    printf(""\n"");

    indice = minimo(a, dim);
    printf(""-------------------------------\n"");
    printf(""L'indice minore Ã¨: %d\n"", indice);
    
    scambia(a,dim, 0, indice);

    printf(""\nQuesto Ã¨ l'array con il valore minimo in testa:\n"");

    stampa_vettore(a, dim);
    
    return 0;

}",65,1895,502
"int somma(int a[], int dim){
  int s = 0; 
  for(int i=0; i<dim; i++){
    s+=a[i];
  }
  return s;
}


int check(int a[], int dim_a, int b[], int dim_b){
  int i = 0; 
  int trovato = 0; 
  
  int somma_b = somma(b, dim_b);
  
  
  while(i<dim_a && !trovato){
    
    if(a[i]==somma_b){
      
      trovato = 1;
    }
    
    i++;
  } 
  return trovato;
}

int main(){
  
  int dim_a, dim_b;
  printf(""Inserire dimensione a: "");
  scanf(""%d"", &dim_a);
  printf(""Inserire dimansione b: "");
  scanf(""%d"", &dim_b);

  
  int *a;
  a = malloc(sizeof(int)*dim_a);
  int *b;
  b = malloc(sizeof(int)*dim_b);

  
  for(int i=0; i<dim_a; i++){
    printf(""a[%d] = "", i);
    scanf(""%d"", &a[i]);
  }
  printf(""\n"");

  
  for(int i=0; i<dim_b; i++){
    printf(""b[%d] = "", i);
    scanf(""%d"", &b[i]);
  }
  printf(""\n"");

  int verifica = check(a, dim_a, b, dim_b);

  if(verifica==1){
    printf(""In a esiste un elemento uguale alla somma degli elementi di b\n"");
  }

  if(verifica==0){
    printf(""In a NON esiste un elemento uguale alla somma degli elementi di b\n"");
  }

  free(a);
  free(b);

  return(0);

}",65,1896,522
"struct elemento{ int info; struct elemento* next; };

typedef struct elemento ElementodiLista;
typedef ElementodiLista* ListadiElementi;

void addT(ListadiElementi* l, int x)
{
    ListadiElementi new = malloc(sizeof(ElementodiLista));
    new->info = x;
    new->next = *l;
    *l = new;
}

void addC(ListadiElementi* l, int x)
{
    
    ListadiElementi new = malloc(sizeof(ElementodiLista));
    (*new).info = x;
    (*new).next = NULL;
    
    if(*l == NULL) *l = new;
    else 
    {
        
        ListadiElementi corr = *l;
        
        while(corr->next != NULL) corr = corr->next;
        
        corr->next = new;
    }
}

int main(void) 
{
    ListadiElementi lista = NULL;
    
    addT(&lista , 2);
    addT(&lista, 3);
    addC(&lista, 1);
    
}

",65,1897,283
"int potenza(int base, int esponente);

int main(void) {
  int a, b;
  int risultato;

  printf(""Base: "");
  scanf(""%d"", &a);

  printf(""Esponente: "");
  scanf(""%d"", &b);

  if (b > 0) {
    risultato = potenza(a,b);
    printf( ""Risultato: %d\n"", risultato ); 
  } else {
    printf(""Inserisci una potenza maggiore di 0"");
  }
 
  return 0;
}

int potenza(int base, int esponente){
  int risultato = 1;

  for(int i = 0; i < esponente; i++){
    risultato = risultato * base;
  }

    return (risultato);
}  ",65,1898,214
"struct elemento{ int info; struct elemento* next; };

typedef struct elemento ElementodiLista;
typedef ElementodiLista* ListadiElementi;

int main(void) 
{
    
  
    return 0;
}

void inserisci(ListadiElementi *l, int x, int v)
{
    ListadiElementi prec, corr;

    corr = *l;
    int trovato = 0;
    prec = NULL;

    while(corr != NULL && !trovato)
    {
        if(corr->info == x) trovato = 1;
        else
        {
            prec = corr;
            corr = corr->next;
        }
    }

    if(trovato)
    {
        ListadiElementi new = malloc(sizeof(ElementodiLista));
        new->info = v;   
        new->next = corr;

        if(prec != NULL) prec->next = new;
        else *l = new;
    }
}

",65,1899,253
"void somma_armonica(int n, double* h)
{

    if(n == 1)
    {
        *h = 1.0 + *h;
    } else {       
        *h =  *h + (1.0/n);
        somma_armonica(n-1,h);     
    }
           
}

int main(void) 
{
    int n;
    double risultato;

    printf(""Inserisci n: "");
    scanf(""%d"", &n);

    somma_armonica(n, &risultato);
    printf(""Risultato = %lf"", risultato);


    return 0;

}",65,1900,172
"struct triangolo {
  float beta; 
  float alfa;
  float gamma;
  int ab;
  int bc;
  int ac; 
};

typedef struct triangolo Triangolo;

float calcolo_perimetro(Triangolo* t)
{

    return  (t->ab + t->bc + t->ac);
}

void similitudine(Triangolo t1, Triangolo* t2)
{
    if((t1.alfa == t2->alfa) && (t1.beta == t2->beta) && (t1.gamma == t2->gamma))
    {
        printf(""\n0 - l'equivalenza Ã¨ vera"");
    } else {
        printf(""\n1 - l'equivalenza Ã¨ falsa"");
    }
    
}

int main() {

  Triangolo x1;
  Triangolo x2;



  printf(""Inserire angolo alfa: "");
  scanf(""%f"", &x1.alfa);
  
  printf(""Inserire angolo beta: "");
  scanf(""%f"", &x1.beta);

  printf(""Inserire angolo gamma: "");
  scanf(""%f"", &x1.gamma);

  printf(""Inserire lato AB: "");
  scanf(""%d"", &x1.ab);

  printf(""Inserire lato BC: "");
  scanf(""%d"", &x1.bc);

  printf(""Inserire lato AC: "");
  scanf(""%d"", &x1.ac);



  printf(""Inserire angolo alfa: "");
  scanf(""%f"", &x2.alfa);
  
  printf(""Inserire angolo beta: "");
  scanf(""%f"", &x2.beta);

  printf(""Inserire angolo gamma: "");
  scanf(""%f"", &x2.gamma);

  printf(""Inserire lato AB: "");
  scanf(""%d"", &x2.ab);

  printf(""Inserire lato BC: "");
  scanf(""%d"", &x2.bc);

  printf(""Inserire lato AC: "");
  scanf(""%d"", &x2.ac);


    float primo = calcolo_perimetro(&x1);
    float secondo = calcolo_perimetro(&x2);
    printf(""primo: %f\nsecondo: %f"", primo, secondo);
    similitudine(x1, &x2);
  

  return(0);
}
",65,1901,634
"int main(void) {
  
  int dim; 
  printf(""inserire dimensione array: ""); 
  scanf(""%d"", &dim);
  int a[dim];
  int b[dim];

  
  for(int i=0; i<dim; i++){
    printf(""a[%d] = "", i);
    scanf(""%d"", &a[i]);
  }

  printf(""\n"");

  
  for(int i=0; i<dim; i++){
    printf(""b[%d] = "", i);
    scanf(""%d"", &b[i]);
  }

  printf(""\n"");

  int c[dim];

  
  for(int i=0; i<=dim-1; i++) {
    c[i] = a[i] + b[i];
  }

  for(int i=0; i<dim; i++){
    printf(""%d "", c[i]);
  }

  printf(""\n"");

  
  for(int i=0; i<dim; i++){
    c[i] = a[i] * b[i];
    printf(""%d "", c[i]);
  }

  printf(""\n"");

  
  for(int i=0; i<dim; i++){
    if(a[i]<=b[i]) {
      c[i] = b[i];
    }
    else {
      c[i] = a[i];
    }
    printf(""%d "", c[i]); 
  }

  printf(""\n"");

  int max, min;
  float media; 

  max = c[0];
  min = c[0];
  media = c[0];

  for(int i=1; i<dim; i++) {
    
    if(c[i]>max){
      max = c[i];
    }
    if(c[i]<min){
      min = c[i];
    }
    
    media += c[i];
  }

  printf(""\nMax in c: %d\n"", max);
  printf(""\nMin in c: %d\n"", min);

  media = media/dim; 

  printf(""\nMedia elementi di c: %lf\n"", media);

  return 0;
}",65,1902,568
"void isPrime(int dim, int a[])
{
    int contatore = 0, prime;
    int b[dim];

    
    for(int i=0; i<dim; i++)
    {
        for(int j=0; j<dim; j++)
        {
            prime = 0;
            
            if((i != j) && (a[i] % a[j] != 0))
            {
                prime = 1;
                break;                     
            }
        }

        if(prime == 1)
        {
            b[i] = a[i];
        } else {
            b[i] = 0;
        }

        printf(""b[%d] = %d\n"",i, b[i]);          
    }

   
}


int main(void) {
    int dim; 
    printf(""inserire dimensione array: ""); 
    scanf(""%d"", &dim);
    int a[dim];

    
    for(int i=0; i<dim; i++){
        printf(""a[%d] = "", i);
        scanf(""%d"", &a[i]);
    }

    printf(""\n"");
    printf(""----------------------------\n"");
    isPrime(dim,a);

  return 0;
}",65,1903,324
"int main(){
  int dim;
  int check = 0;

  
  printf(""dammi dim: "");
  scanf(""%d"", &dim);

  int arr[dim];

  printf(""riempi array arr.\n"");
  for(int i = 0; i < dim; i++){
    printf(""dammi un numero: "");
    scanf(""%d"", &arr[i]);
  }

  for(int i = 0; i < dim; i++){
  if(arr[i] != arr[dim - i - 1]){
      check = 1;
      i = dim; 
    }
  }


  if(check == 0){
    printf(""la sequenza Ã¨ palindroma.\n"");
  }else{
    printf(""la sequenza non Ã¨ palindroma.\n"");
  }

  return(0);
}",65,1904,219
"void rimuoviDuplicati(int a[], int* dim_a)
{
    for(int i=0;i<*dim_a;i++)
    {
        for(int j=i+1; j<*dim_a; j++)
        {
            if(a[i]==a[j])
            {
                for(int k=j; k<*dim_a-1;j++)
                {
                    a[k] = a[k+1];
                }

                *dim_a -= 1;
                j--;
            }
        }
    }
}

int main(void) {
    
    int dim_a = 7;
    int *a = malloc(sizeof(int)*dim_a);

    for(int i=0; i<dim_a; i++)
    {
        printf(""a[%d]="", i);
        scanf(""%d"", &a[i]);
    }
    printf(""\n"");

    rimuoviDuplicati(a, &dim_a);

    for(int i=0; i<dim_a; i++)
    {
        printf(""a[%d]="", i);
        scanf(""%d"", &a[i]);
    }

    free(a);

    return 0;
}",65,1905,320
"int mcd(int a, int b)
{
    int r = a % b;

    if(r == 0){

        return b;

    } else { 
        
        return mcd(b, r);
    
    }
}

int main() {
  
    int a, b;
  int risultato;

  printf(""Primo numero: "");
  scanf(""%d"", &a);

  printf(""Secondo numero: "");
  scanf(""%d"", &b);
  
    risultato = mcd(a, b);
  printf( ""Risultato: %d\n"", risultato ); 

    return 0;
}
",65,1906,167
"void lettura(int v[], int dim)
{
    int i=0;
    for(i=0;i<dim;i++)
    {
        scanf(""%d"", &v[i]);
    }
}

int somma(int v[], int dim)
    {
        int tot=0;
        int i=0;
        
        for(i=0;i<dim;i++)
        {
            tot += v[i]; 
        }

        return tot;
    }

int main(void) 
{
    int a[5];
    int tot;

    lettura(a,5);

    somma(a,5);

    printf(""Somma totale dell'array: %d"", tot);

}",65,1907,187
"void rimuovi(int a[], int *dim){
  
  for(int i=0; i<*dim; i++){
    
    for(int j=i+1; j<*dim; j++){
      
      if(a[i]==a[j]){
        
        for(int k=j; k<*dim-1; k++){
          a[k] = a[k+1];
        }
        
        *dim -=1;
        
        
        j--;
      }
    }
  }
}

int main(void) {
    int dim_a;
    printf(""Inserire dimensione a: "");
    scanf(""%d"", &dim_a);
    int *a = malloc(sizeof(int)*dim_a);

    
    for(int i=0; i<dim_a; i++){
        printf(""a[%d] = "", i);
        scanf(""%d"", &a[i]);
    }
    printf(""\n"");

    
    rimuovi(a, &dim_a);

}",65,1908,261
"int calcolaFattoriale(int n)
{
    if (n == 1)
        return 1;
    else
        return n * calcolaFattoriale(n - 1);
}
void stampa_vettore(int a[], int dim)
{

    for(int i=0; i<dim; i++)
    {
        printf(""a[%d] = "", i);
        printf(""%d\n"", a[i]);
    }
}

int main(void) {
    int dim;

    printf(""Inserire dimensione array: ""); 
    scanf(""%d"", &dim);
    int a[dim];

    
    for(int i=0; i<dim; i++)
    {
        printf(""a[%d] = "", i);
        scanf(""%d"", &a[i]);
    }
    
    printf(""---------------------------------\n"");

    for(int i=0; i<dim; i++)
    {
        a[i] = calcolaFattoriale(a[i]);
        printf(""Il fattoriale di a[%d] Ã¨: %d\n"", i, a[i]);
    }   

    return 0;

}",65,1909,303
"int max_finder(int a, int b, int c);

int main(void) {
  int a, b, c;
  int risultato;

  printf(""Primo numero: "");
  scanf(""%d"", &a);

  printf(""Secondo numero: "");
  scanf(""%d"", &b);

  printf(""Terzo numero: "");
  scanf(""%d"", &c);

  risultato = max_finder(a,b,c);
  printf( ""Risultato: %d\n"", risultato ); 

  return 0;
}

int max_finder(int a, int b, int c){

  if(a > b){
        if( a > c){
            return a;
        } else return c;
    } else if (b > c){
        return b;

    } else return c;

}  ",65,1910,217
"void decToBin(int dec)
{
    float resto;
    int numeriBinari[100], i = 0;

    while(dec > 0)
    {
        numeriBinari[i] = dec % 2;
        dec = dec/2;
        i++;
    }

    for(int j = i-1; j>=0; j--)
    {
        printf(""%d"",numeriBinari[j]);
    }

}


int main(){
    int n;
    printf(""Giac: "");
    scanf(""%d"",&n);

    decToBin(n);

        

    return 0;
}
",65,1911,172
"int decToBin(int dec)
{
    float resto;
    int numeriBinari[100], i = 0;

    while(dec > 0)
    {
        numeriBinari[i] = dec % 2;
        dec = dec/2;
        i++;
    }

    for(int j = i-1; j>=0; j--)
    {
        printf(""%d"",numeriBinari[j]);
    }

    return resto;
}


int main(){
    int n;
    printf(""Giac: "");
    scanf(""%d"",&n);

    int risultato = decToBin(n);
    printf(""\nrisultato = %d"", risultato);
        

    return 0;
}
",65,1912,195
"struct numero_complesso {
  float reale; 
  float immaginaria; 
};

typedef struct numero_complesso NumeroComplesso;


NumeroComplesso somma(NumeroComplesso x, NumeroComplesso y){
  
  NumeroComplesso s;
  
  s.reale = x.reale + y.reale;
  
  s.immaginaria = x.immaginaria + y.immaginaria;
  
  return s;
}

 
NumeroComplesso prodotto(NumeroComplesso x, NumeroComplesso y){
  
  NumeroComplesso p;
  
  p.reale = x.reale*y.reale - x.immaginaria*y.immaginaria;
  
  p.immaginaria = x.reale*y.immaginaria + x.immaginaria*y.reale;
  
  return p;
}


NumeroComplesso somma_array(NumeroComplesso z[],int dim){
  
  NumeroComplesso s;
  
  s.reale = z[0].reale;
  s.immaginaria = z[0].immaginaria;

  for(int i=1; i<dim; i++){
    
    s = somma(s, z[i]);
  }

  
  return s;
}


void stampa_complesso(NumeroComplesso x){
  
  printf(""%.2f + %.2f i\n"", x.reale, x.immaginaria);
}

int main() {
  
  NumeroComplesso x;
  printf(""Inserire parte reale e immaginaria di x: "");
  scanf(""%f %f"", &x.reale, &x.immaginaria);
  NumeroComplesso y;
  printf(""Inserire parte reale e immaginaria di y: "");
  scanf(""%f %f"", &y.reale, &y.immaginaria);

  
  printf(""\nx = "");
  stampa_complesso(x);

  
  printf(""\ny = "");
  stampa_complesso(y);

  
  NumeroComplesso s = somma(x, y);

  
  printf(""\nx + y = "");
  stampa_complesso(s);

  
  NumeroComplesso p = prodotto(x, y);

  
  printf(""\nx*y = "");
  stampa_complesso(p);

  
  
  int n = 5; 
  NumeroComplesso z[n];
  
  for(int i=0; i<n; i++){
    z[i].reale = i;
    z[i].immaginaria = i+3;
  }

 NumeroComplesso s1 = somma_array(z, n); 
 
 printf(""\nLa somma di tutti gli elementi nell'array Ã¨:\ns1 = "");
 stampa_complesso(s1);


  return(0);
}
",65,1913,766
"int main(void) {
    
    int dim; 
    printf(""inserire dimensione array: ""); 
    scanf(""%d"", &dim);
    int a[dim];
    int b[dim];

    
    for(int i=0; i<dim; i++)
    {
        printf(""a[%d] = "", i);
        scanf(""%d"", &a[i]);
    }

    printf(""\n"");
  
    
    for(int i=0; i<dim; i++)
    {
        printf(""b[%d] = "", i);
        scanf(""%d"", &b[i]);
    }

    printf(""\n"");

    int c[dim];

    printf(""Prodotto scalare dei due vettori: \n"");
    for(int i=0; i<dim; i++)
    {
        c[i] = a[i] * b[i];
        printf(""c[%d] = "", i );
        printf(""%d"", c[i]);
        printf(""\n"");
    }

}",65,1914,261
"void scambia(int v[], int dim, int i, int j){

    if(dim > 0)
    {
        if((i > 0) && (i <= dim-1) && (j > 0) && (j <= dim-1))
        {
            int tmp = v[i];
            v[i] = v[j];
            v[j] = tmp;
        }
    }

}

void scambiaEsplicito(int v[], int dim, int i, int j){

    if(dim > 0)
    {
        if((i > 0) && (i <= dim-1) && (j > 0) && (j <= dim-1))
        {
            int tmp = *(v + i);
            *(v + i) = *(v + j);
            *(v + j) = tmp;
        }
    }

}

int main(void) {

    


  return 0;
}",65,1915,242
"int idk(double x1, double y1);

int main(void) {

  double x, y;
    int risultato;

  printf(""Inserisci il primo numero: "");
  scanf(""%lf"", &x);

    printf(""Inserisci il secondo numero: "");
  scanf(""%lf"", &y);


  risultato = idk(x, y);
  printf( ""Risultato: %d\n"", risultato ); 

  return 0;
}

int idk(double x, double y){

    double randomNumber = pow(1/10, 9);

        if ((x - y) <= (randomNumber))
            return 1;
        else return 0; 
        
}

",65,1916,189
